{"file_name": "/home/qj213/afp-2021-10-22/thys/Finite_Automata_HF/Finite_Automata_HF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Finite_Automata_HF", "problem_names": ["lemma finite_final [simp]: \"finite (final M)\"", "lemma left_lang_disjoint:\n  \"q1 \\<noteq> q2 \\<Longrightarrow> left_lang q1 \\<inter> left_lang q2 = {}\"", "lemma language_eq_right_lang: \"language = right_lang (init M)\"", "lemma nextl_app: \"nextl q (xs@ys) = nextl (nextl q xs) ys\"", "lemma nextl_snoc [simp]: \"nextl q (xs@[x]) = nxt M (nextl q xs) x\"", "lemma nextl_state: \"q \\<in> states M \\<Longrightarrow> nextl q xs \\<in> states M\"", "lemma nextl_init_state [simp]: \"nextl (init M) xs \\<in> states M\"", "lemma equiv_eq_nextl: \"equiv UNIV eq_nextl\"", "lemma right_invariant_eq_nextl: \"right_invariant eq_nextl\"", "lemma range_nextl: \"range (nextl (init M)) \\<subseteq> states M\"", "lemma eq_nextl_class_in_left_lang_im: \"eq_nextl `` {u} \\<in> left_lang ` states M\"", "lemma language_eq_nextl: \"language = eq_nextl `` (\\<Union>q \\<in> final M. left_lang q)\"", "lemma finite_index_eq_nextl: \"finite (UNIV // eq_nextl)\"", "lemma index_eq_nextl_le_states: \"card (UNIV // eq_nextl) \\<le> card (states M)\"", "lemma accessible_imp_states: \"q \\<in> accessible \\<Longrightarrow> q \\<in> states M\"", "lemma nxt_accessible: \"q \\<in> accessible \\<Longrightarrow> nxt M q a \\<in> accessible\"", "lemma inj_on_left_lang: \"inj_on left_lang accessible\"", "lemma path_to_left_lang: \"q \\<in> accessible \\<Longrightarrow> path_to q \\<in> left_lang q\"", "lemma nextl_path_to: \"q \\<in> accessible \\<Longrightarrow> nextl (dfa.init M) (path_to q) = q\"", "lemma states_Accessible_dfa [simp]: \"states Accessible_dfa = accessible\"", "lemma init_Accessible_dfa [simp]: \"init Accessible_dfa = init M\"", "lemma final_Accessible_dfa [simp]: \"final Accessible_dfa = final M \\<inter> accessible\"", "lemma nxt_Accessible_dfa [simp]: \"nxt Accessible_dfa = nxt M\"", "lemma dfa_Accessible: \"dfa Accessible_dfa\"", "lemma nextl_Accessible_dfa [simp]:\n     \"q \\<in> accessible \\<Longrightarrow> Accessible.nextl q u = nextl q u\"", "lemma init_Accessible: \"init M \\<in> accessible\"", "lemma Accessible_left_lang_eq [simp]: \"Accessible.left_lang q = left_lang q\"", "lemma Accessible_right_lang_eq [simp]:\n  \"q \\<in> accessible \\<Longrightarrow> Accessible.right_lang q = right_lang q\"", "lemma Accessible_language [simp]: \"Accessible.language = language\"", "lemma Accessible_accessible [simp]: \"Accessible.accessible = accessible\"", "lemma left_lang_half:\n  assumes sb: \"\\<Union>(left_lang ` qs1) \\<subseteq> \\<Union>(left_lang ` qs2)\"\n      and ne: \"\\<And>x. x \\<in> qs1 \\<Longrightarrow> left_lang x \\<noteq> {}\"\n    shows \"qs1 \\<subseteq> qs2\"", "lemma left_lang_UN:\n     \"\\<lbrakk>\\<Union>(left_lang ` qs1) = \\<Union>(left_lang ` qs2); qs1 \\<union> qs2 \\<subseteq> accessible\\<rbrakk>\n      \\<Longrightarrow> qs1 = qs2\"", "lemma equiv_eq_right_lang: \"equiv (states M) eq_right_lang\"", "lemma eq_right_lang_finite_index: \"finite (states M // eq_right_lang)\"", "lemma nxt_Collapse_resp: \"(\\<lambda>q. eq_right_lang `` {nxt M q x}) respects eq_right_lang\"", "lemma finite_Collapse_state: \"Q \\<in> states M // eq_right_lang \\<Longrightarrow> finite Q\"", "lemma nextl_Collapse_dfa:\n     \"Q = HF (eq_right_lang `` {q}) \\<Longrightarrow> Q \\<in> dfa.states Collapse_dfa \\<Longrightarrow>\n      q \\<in> states M \\<Longrightarrow>\n             Collapse.nextl Q u = HF (eq_right_lang `` {nextl q u})\"", "lemma ext_language_Collapse_dfa:\n     \"u \\<in> Collapse.language \\<longleftrightarrow> u \\<in> language\"", "theorem language_Collapse_dfa:\n     \"Collapse.language = language\"", "lemma card_Collapse_dfa: \"card (states M // eq_right_lang) \\<le> card (states M)\"", "lemma nextl [simp]: \"q \\<in> states M \\<Longrightarrow> h (M.nextl q u) = N.nextl (h q) u\"", "theorem language: \"M.language = N.language\"", "lemma nxt_inv_into: \"q \\<in> states N \\<Longrightarrow> nxt N q x = h (nxt M (inv_into (states M) h q) x)\"", "lemma sym: \"dfa_isomorphism N M (inv_into (states M) h)\"", "lemma trans: \"dfa_isomorphism N N' h' \\<Longrightarrow> dfa_isomorphism M N' (h' o h)\"", "lemma equiv_eq_app_right: \"equiv UNIV (eq_app_right L)\"", "lemma right_invariant_eq_app_right: \"right_invariant (eq_app_right L)\"", "lemma eq_app_right_eq: \"eq_app_right L `` L = L\"", "lemma MN_eq_app_right:\n     \"finite (UNIV // eq_app_right L) \\<Longrightarrow> MyhillNerode L (eq_app_right L)\"", "lemma MN_refines: \"\\<lbrakk>MyhillNerode L R; (x,y) \\<in> R\\<rbrakk> \\<Longrightarrow> x \\<in> L \\<longleftrightarrow> y \\<in> L\"", "lemma MN_refines_eq_app_right: \"MyhillNerode L R \\<Longrightarrow> R \\<subseteq> eq_app_right L\"", "lemma MN_eq_nextl: \"MyhillNerode language eq_nextl\"", "lemma index_le_index_eq_nextl:\n       \"card (UNIV // eq_app_right language) \\<le> card (UNIV // eq_nextl)\"", "lemma index_eq_app_right_lower:\n       \"card (UNIV // eq_app_right language) \\<le> card (states M)\"", "lemma L1_2: \"regular L \\<Longrightarrow> \\<exists>R. MyhillNerode L R\"", "lemma L2_3:\n  assumes \"MyhillNerode L R\"\n  obtains \"finite (UNIV // eq_app_right L)\"\n          \"card (UNIV // eq_app_right L) \\<le> card (UNIV // R)\"", "lemma injh: \"inj_on h (UNIV//R)\"", "lemma finix: \"finite (UNIV//R)\"", "lemma resp: \"\\<And>x. (\\<lambda>u. R `` {u @ [x]}) respects R\"", "lemma dfa: \"dfa DFA\"", "lemma MyhillNerode: \"MyhillNerode L R\"", "lemma R_iff: \"(\\<exists>x\\<in>L. (u, x) \\<in> R) = (u \\<in> L)\"", "lemma nextl: \"MN.nextl (init DFA) u = h (R `` {u})\"", "lemma language: \"MN.language = L\"", "lemma card_states: \"card (states DFA) = card (UNIV // R)\"", "theorem MN_imp_dfa:\n  assumes \"MyhillNerode L R\"\n  obtains M where \"dfa M\" \"dfa.language M = L\" \"card (states M) = card (UNIV//R)\"", "lemma subset_states_finite [intro,simp]: \"Q \\<subseteq> states M \\<Longrightarrow> finite Q\"", "lemma epsclo_eq_Image: \"epsclo Q = states M \\<inter> (eps M)\\<^sup>* `` Q\"", "lemma epsclo_empty [simp]: \"epsclo {} = {}\"", "lemma epsclo_idem [simp]: \"epsclo (epsclo Q) = epsclo Q\"", "lemma epsclo_increasing: \"Q \\<inter> states M \\<subseteq> epsclo Q\"", "lemma epsclo_Un [simp]: \"epsclo (Q1 \\<union> Q2) = epsclo Q1 \\<union> epsclo Q2\"", "lemma epsclo_UN [simp]: \"epsclo (\\<Union>x\\<in>A. B x) = (\\<Union>x\\<in>A. epsclo (B x))\"", "lemma epsclo_subset [simp]: \"epsclo Q \\<subseteq> states M\"", "lemma epsclo_trivial [simp]: \"eps M \\<subseteq> Q \\<times> Q \\<Longrightarrow> epsclo Q = states M \\<inter> Q\"", "lemma epsclo_mono: \"Q' \\<subseteq> Q \\<Longrightarrow> epsclo Q' \\<subseteq> epsclo Q\"", "lemma finite_epsclo [simp]: \"finite (epsclo Q)\"", "lemma finite_final: \"finite (final M)\"", "lemma finite_nxt: \"q \\<in> states M \\<Longrightarrow> finite (nxt M q x)\"", "lemma nextl_epsclo [simp]: \"nextl (epsclo Q) xs = nextl Q xs\"", "lemma epsclo_nextl [simp]: \"epsclo (nextl Q xs) = nextl Q xs\"", "lemma nextl_app: \"nextl Q (xs@ys) = nextl (nextl Q xs) ys\"", "lemma nextl_snoc [simp]: \"nextl Q (xs@[x]) = (\\<Union>q \\<in> nextl Q xs. epsclo (nxt M q x))\"", "lemma nextl_state: \"nextl Q xs \\<subseteq> states M\"", "lemma nextl_mono: \"Q' \\<subseteq> Q \\<Longrightarrow> nextl Q' u \\<subseteq> nextl Q u\"", "lemma nextl_eps: \"q \\<in> nextl Q u \\<Longrightarrow> (q,q') \\<in> eps M \\<Longrightarrow> q' \\<in> states M \\<Longrightarrow> q' \\<in> nextl Q u\"", "lemma finite_nextl: \"finite (nextl Q u)\"", "lemma nextl_empty [simp]: \"nextl {} xs = {}\"", "lemma nextl_Un: \"nextl (Q1 \\<union> Q2) xs = nextl Q1 xs \\<union> nextl Q2 xs\"", "lemma nextl_UN: \"nextl (\\<Union>i\\<in>I. f i) xs = (\\<Union>i\\<in>I. nextl (f i) xs)\"", "lemma states_Power_dfa [simp]: \"dfa.states Power_dfa = HF ` epsclo ` Pow (states M)\"", "lemma init_Power_dfa [simp]: \"dfa.init Power_dfa = HF (epsclo (nfa.init M))\"", "lemma final_Power_dfa [simp]: \"dfa.final Power_dfa = {HF (epsclo Q) | Q. Q \\<subseteq> states M \\<and> Q \\<inter> final M \\<noteq> {}}\"", "lemma nxt_Power_dfa [simp]: \"dfa.nxt Power_dfa = (\\<lambda>Q x. HF(\\<Union>q \\<in> epsclo (hfset Q). epsclo (nxt M q x)))\"", "lemma nextl_Power_dfa:\n     \"qs \\<in> dfa.states Power_dfa\n     \\<Longrightarrow> dfa.nextl Power_dfa qs u = HF (\\<Union>q \\<in> hfset qs. nextl {q} u)\"", "lemma Power_right_lang:\n     \"qs \\<in> dfa.states Power_dfa \\<Longrightarrow> Power.right_lang qs = (\\<Union>q \\<in> hfset qs. right_lang q)\"", "theorem Power_language [simp]: \"Power.language = language\"", "theorem regular_empty:  \"regular {}\"", "theorem regular_nullstr:  \"regular {[]}\"", "theorem regular_singstr: \"regular {[a]}\"", "theorem regular_Compl:\n  assumes S: \"regular S\" shows \"regular (-S)\"", "theorem regular_Int:\n  assumes S: \"regular S\" and T: \"regular T\" shows \"regular (S \\<inter> T)\"", "lemma Inlr_rtrancl [simp]: \"((\\<lambda>q. (Inl q, Inr a)) ` A)\\<^sup>* = ((\\<lambda>q. (Inl q, Inr a)) ` A)\\<^sup>=\"", "theorem regular_conc:\n  assumes S: \"regular S\" and T: \"regular T\" shows \"regular (S @@ T)\"", "lemma regular_word: \"regular {u}\"", "theorem regular_finite: \"finite L \\<Longrightarrow> regular L\"", "theorem regular_star:\n  assumes S: \"regular S\" shows \"regular (star S)\"", "lemma states_Reverse_nfa [simp]: \"states (Reverse_nfa MS) = dfa.states MS\"", "lemma init_Reverse_nfa [simp]: \"init (Reverse_nfa MS) = dfa.final MS\"", "lemma final_Reverse_nfa [simp]: \"final (Reverse_nfa MS) = {dfa.init MS}\"", "lemma nxt_Reverse_nfa [simp]:\n  \"nxt (Reverse_nfa MS) q x = {q' \\<in> dfa.states MS. q = dfa.nxt MS q' x}\"", "lemma eps_Reverse_nfa [simp]: \"eps (Reverse_nfa MS) = {}\"", "lemma nfa_Reverse_nfa: \"nfa (Reverse_nfa M)\"", "lemma nextl_Reverse_nfa:\n    \"nfa.nextl (Reverse_nfa M) Q u = {q' \\<in> dfa.states M. dfa.nextl M q' (rev u) \\<in> Q}\"", "lemma right_lang_Reverse: \"nfa.right_lang (Reverse_nfa M) q = rev ` (dfa.left_lang M q)\"", "lemma right_lang_Reverse_disjoint:\n    \"q1 \\<noteq> q2 \\<Longrightarrow> nfa.right_lang (Reverse_nfa M) q1 \\<inter> nfa.right_lang (Reverse_nfa M) q2 = {}\"", "lemma epsclo_Reverse_nfa [simp]: \"nfa.epsclo (Reverse_nfa M) Q = Q \\<inter> dfa.states M\"", "theorem language_Reverse_nfa [simp]:\n     \"nfa.language (Reverse_nfa M) = (rev ` dfa.language M)\"", "theorem regular_lang: \"regular (lang r)\"", "lemma left_eq_app_right:\n       \"\\<lbrakk>u \\<in> left_lang q; v \\<in> left_lang q\\<rbrakk> \\<Longrightarrow> (u,v) \\<in> eq_app_right language\"", "lemma eq_app_right_class_eq:\n    \"UNIV // eq_app_right language = (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible\"", "lemma inj_right_lang_imp_eq_app_right_index:\n    assumes \"inj_on right_lang (dfa.states M)\"\n      shows \"bij_betw (\\<lambda>q. eq_app_right language `` {path_to q})\n                      accessible  (UNIV // eq_app_right language)\"", "lemma minimal_imp_index_eq_app_right:\n    \"minimal \\<Longrightarrow> card (dfa.states M) = min_states\"", "theorem minimal_imp_card_states_le:\n       \"\\<lbrakk>minimal; dfa M'; dfa.language M' = language\\<rbrakk>\n        \\<Longrightarrow> card (dfa.states M) \\<le> card (dfa.states M')\"", "lemma index_f: \"bij_betw index_f (UNIV // eq_app_right language) (hfset (ord_of min_states))\"", "theorem minimal_imp_isomorphic_to_canonical:\n    assumes minimal\n      shows \"dfa_isomorphism M Canon.DFA iso\"", "lemma states_PR [simp]:\n       \"dfa.states (nfa.Power_dfa (Reverse_nfa M)) = HF ` Pow (dfa.states M)\"", "lemma inj_on_right_lang_PR:\n    assumes \"dfa.states M = accessible\"\n      shows \"inj_on (dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)))\n                    (dfa.states (nfa.Power_dfa (Reverse_nfa M)))\"", "theorem minimal_APR:\n    assumes \"dfa.states M = accessible\"\n      shows \"dfa.minimal (APR M)\"", "lemma dfa_Brzozowski: \"dfa Brzozowski\"", "theorem language_Brzozowski: \"dfa.language Brzozowski = language\"", "theorem minimal_Brzozowski: \"dfa.minimal Brzozowski\"", "lemma index_f_cong:\n     \"\\<lbrakk>dfa.language M = dfa.language N; dfa M; dfa N\\<rbrakk> \\<Longrightarrow> dfa.index_f M = dfa.index_f N\"", "theorem minimal_imp_isomorphic:\n     \"\\<lbrakk>dfa.language M = dfa.language N; dfa.minimal M; dfa.minimal N; dfa M; dfa N\\<rbrakk>\n      \\<Longrightarrow> \\<exists>h. dfa_isomorphism M N h\""], "translations": [["", "lemma finite_final [simp]: \"finite (final M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (final M)", "using final finite_subset finite"], ["proof (prove)\nusing this:\n  final M \\<subseteq> states M\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  finite (states M)\n\ngoal (1 subgoal):\n 1. finite (final M)", "by blast"], ["", "text\\<open>Transition function for a given starting state and word.\\<close>"], ["", "primrec nextl :: \"[hf, 'a list] \\<Rightarrow> hf\" where\n    \"nextl q []     = q\"\n  | \"nextl q (x#xs) = nextl (nxt M q x) xs\""], ["", "definition language :: \"'a list set\"  where\n  \"language \\<equiv> {xs. nextl (init M) xs \\<in> final M}\""], ["", "text\\<open>The left language WRT a state q is the set of words that lead to q.\\<close>"], ["", "definition left_lang :: \"hf \\<Rightarrow> 'a list set\"  where\n  \"left_lang q \\<equiv> {u. nextl (init M) u = q}\""], ["", "text\\<open>Part of Prop 1 of\n  Jean-Marc Champarnaud, A. Khorsi and T. Parantho?n,\n  Split and join for minimizing: Brzozowski's algorithm,\n  Prague Stringology Conference 2002\\<close>"], ["", "lemma left_lang_disjoint:\n  \"q1 \\<noteq> q2 \\<Longrightarrow> left_lang q1 \\<inter> left_lang q2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2 \\<Longrightarrow> left_lang q1 \\<inter> left_lang q2 = {}", "unfolding left_lang_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2 \\<Longrightarrow>\n    {u. nextl (init M) u = q1} \\<inter> {u. nextl (init M) u = q2} = {}", "by auto"], ["", "text\\<open>The right language WRT a state q is the set of words that go from q to F.\\<close>"], ["", "definition right_lang :: \"hf \\<Rightarrow> 'a list set\"  where\n  \"right_lang q \\<equiv> {u. nextl q u \\<in> final M}\""], ["", "lemma language_eq_right_lang: \"language = right_lang (init M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language = right_lang (init M)", "using language_def right_lang_def"], ["proof (prove)\nusing this:\n  language \\<equiv> {xs. nextl (init M) xs \\<in> final M}\n  right_lang ?q \\<equiv> {u. nextl ?q u \\<in> final M}\n\ngoal (1 subgoal):\n 1. language = right_lang (init M)", "by auto"], ["", "lemma nextl_app: \"nextl q (xs@ys) = nextl (nextl q xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextl q (xs @ ys) = nextl (nextl q xs) ys", "by (induct xs arbitrary: q) auto"], ["", "lemma nextl_snoc [simp]: \"nextl q (xs@[x]) = nxt M (nextl q xs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextl q (xs @ [x]) = nxt M (nextl q xs) x", "by (simp add: nextl_app)"], ["", "lemma nextl_state: \"q \\<in> states M \\<Longrightarrow> nextl q xs \\<in> states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> states M \\<Longrightarrow> nextl q xs \\<in> states M", "by (induct xs arbitrary: q) (auto simp: nxt)"], ["", "lemma nextl_init_state [simp]: \"nextl (init M) xs \\<in> states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextl (init M) xs \\<in> states M", "by (simp add: nextl_state)"], ["", "subsection\\<open>An Equivalence Relation on States\\<close>"], ["", "text\\<open>Two words are equivalent if they take the machine to the same state.\n  See e.g. Kozen, Automata and Computability, Springer, 1997, page 90.\\<close>"], ["", "text\\<open>This relation asks, do @{term u} and @{term v} lead to the same state?\\<close>"], ["", "definition eq_nextl :: \"('a list \\<times> 'a list) set\" where\n  \"eq_nextl \\<equiv> {(u,v). nextl (init M) u = nextl (init M) v}\""], ["", "lemma equiv_eq_nextl: \"equiv UNIV eq_nextl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv UNIV eq_nextl", "by (simp add: equivI refl_on_def sym_def trans_def eq_nextl_def)"], ["", "lemma right_invariant_eq_nextl: \"right_invariant eq_nextl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_invariant eq_nextl", "by (auto simp: right_invariant_def eq_nextl_def nextl_app)"], ["", "lemma range_nextl: \"range (nextl (init M)) \\<subseteq> states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (nextl (init M)) \\<subseteq> states M", "using hmem_def nextl_init_state"], ["proof (prove)\nusing this:\n  (?a \\<^bold>\\<in> ?b) = (?a \\<in> hfset ?b)\n  nextl (init M) ?xs \\<in> states M\n\ngoal (1 subgoal):\n 1. range (nextl (init M)) \\<subseteq> states M", "by auto"], ["", "lemma eq_nextl_class_in_left_lang_im: \"eq_nextl `` {u} \\<in> left_lang ` states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_nextl `` {u} \\<in> left_lang ` states M", "apply (rule rev_image_eqI [of \"nextl (init M) u\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. nextl (init M) u \\<in> states M\n 2. eq_nextl `` {u} = left_lang (nextl (init M) u)", "apply (auto simp: eq_nextl_def left_lang_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma language_eq_nextl: \"language = eq_nextl `` (\\<Union>q \\<in> final M. left_lang q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language = eq_nextl `` \\<Union> (left_lang ` final M)", "by (auto simp: language_def eq_nextl_def left_lang_def hmem_def)"], ["", "lemma finite_index_eq_nextl: \"finite (UNIV // eq_nextl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UNIV // eq_nextl)", "apply (rule finite_surj [where f = left_lang, OF finite])"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV // eq_nextl \\<subseteq> left_lang ` states M", "apply (auto simp: quotient_def eq_nextl_class_in_left_lang_im)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma index_eq_nextl_le_states: \"card (UNIV // eq_nextl) \\<le> card (states M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (UNIV // eq_nextl) \\<le> card (states M)", "apply (rule surj_card_le [where f = left_lang, OF finite])"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV // eq_nextl \\<subseteq> left_lang ` states M", "apply (auto simp: quotient_def eq_nextl_class_in_left_lang_im)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Minimisation via Accessibility\\<close>"], ["", "definition accessible :: \"hf set\"  where\n  \"accessible \\<equiv> {q. left_lang q \\<noteq> {}}\""], ["", "lemma accessible_imp_states: \"q \\<in> accessible \\<Longrightarrow> q \\<in> states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> accessible \\<Longrightarrow> q \\<in> states M", "by (auto simp: accessible_def left_lang_def)"], ["", "lemma nxt_accessible: \"q \\<in> accessible \\<Longrightarrow> nxt M q a \\<in> accessible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> accessible \\<Longrightarrow> nxt M q a \\<in> accessible", "by (auto simp: image_iff accessible_def left_lang_def) (metis nextl.simps nextl_app)"], ["", "lemma inj_on_left_lang: \"inj_on left_lang accessible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on left_lang accessible", "by (auto simp: inj_on_def left_lang_def accessible_def)"], ["", "definition path_to :: \"hf \\<Rightarrow> 'a list\"  where\n  \"path_to q \\<equiv> SOME u. u \\<in> left_lang q\""], ["", "lemma path_to_left_lang: \"q \\<in> accessible \\<Longrightarrow> path_to q \\<in> left_lang q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> accessible \\<Longrightarrow> path_to q \\<in> left_lang q", "unfolding path_to_def left_lang_def accessible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> {q. {u. nextl (init M) u = q} \\<noteq> {}} \\<Longrightarrow>\n    (SOME u. u \\<in> {u. nextl (init M) u = q})\n    \\<in> {u. nextl (init M) u = q}", "by (auto intro: someI)"], ["", "lemma nextl_path_to: \"q \\<in> accessible \\<Longrightarrow> nextl (dfa.init M) (path_to q) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> accessible \\<Longrightarrow> nextl (init M) (path_to q) = q", "using path_to_left_lang"], ["proof (prove)\nusing this:\n  ?q \\<in> accessible \\<Longrightarrow> path_to ?q \\<in> left_lang ?q\n\ngoal (1 subgoal):\n 1. q \\<in> accessible \\<Longrightarrow> nextl (init M) (path_to q) = q", "unfolding left_lang_def"], ["proof (prove)\nusing this:\n  ?q \\<in> accessible \\<Longrightarrow>\n  path_to ?q \\<in> {u. nextl (init M) u = ?q}\n\ngoal (1 subgoal):\n 1. q \\<in> accessible \\<Longrightarrow> nextl (init M) (path_to q) = q", "by auto"], ["", "definition Accessible_dfa :: \"'a dfa\" where\n  \"Accessible_dfa = \\<lparr>dfa.states = accessible,\n                     init  = init M,\n                     final = final M \\<inter> accessible,\n                     nxt   = nxt M\\<rparr>\""], ["", "lemma states_Accessible_dfa [simp]: \"states Accessible_dfa = accessible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states Accessible_dfa = accessible", "by (simp add: Accessible_dfa_def)"], ["", "lemma init_Accessible_dfa [simp]: \"init Accessible_dfa = init M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init Accessible_dfa = init M", "by (simp add: Accessible_dfa_def)"], ["", "lemma final_Accessible_dfa [simp]: \"final Accessible_dfa = final M \\<inter> accessible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final Accessible_dfa = final M \\<inter> accessible", "by (simp add: Accessible_dfa_def)"], ["", "lemma nxt_Accessible_dfa [simp]: \"nxt Accessible_dfa = nxt M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nxt Accessible_dfa = nxt M", "by (simp add: Accessible_dfa_def)"], ["", "interpretation Accessible: dfa Accessible_dfa"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa Accessible_dfa", "proof unfold_locales"], ["proof (state)\ngoal (4 subgoals):\n 1. init Accessible_dfa \\<in> states Accessible_dfa\n 2. final Accessible_dfa \\<subseteq> states Accessible_dfa\n 3. \\<And>q x.\n       q \\<in> states Accessible_dfa \\<Longrightarrow>\n       nxt Accessible_dfa q x \\<in> states Accessible_dfa\n 4. finite (states Accessible_dfa)", "show \"init Accessible_dfa \\<in> states Accessible_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init Accessible_dfa \\<in> states Accessible_dfa", "by (auto simp: accessible_def left_lang_def) (metis nextl.simps(1))"], ["proof (state)\nthis:\n  init Accessible_dfa \\<in> states Accessible_dfa\n\ngoal (3 subgoals):\n 1. final Accessible_dfa \\<subseteq> states Accessible_dfa\n 2. \\<And>q x.\n       q \\<in> states Accessible_dfa \\<Longrightarrow>\n       nxt Accessible_dfa q x \\<in> states Accessible_dfa\n 3. finite (states Accessible_dfa)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. final Accessible_dfa \\<subseteq> states Accessible_dfa\n 2. \\<And>q x.\n       q \\<in> states Accessible_dfa \\<Longrightarrow>\n       nxt Accessible_dfa q x \\<in> states Accessible_dfa\n 3. finite (states Accessible_dfa)", "show \"final Accessible_dfa \\<subseteq> states Accessible_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final Accessible_dfa \\<subseteq> states Accessible_dfa", "by (auto simp: accessible_imp_states)"], ["proof (state)\nthis:\n  final Accessible_dfa \\<subseteq> states Accessible_dfa\n\ngoal (2 subgoals):\n 1. \\<And>q x.\n       q \\<in> states Accessible_dfa \\<Longrightarrow>\n       nxt Accessible_dfa q x \\<in> states Accessible_dfa\n 2. finite (states Accessible_dfa)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       q \\<in> states Accessible_dfa \\<Longrightarrow>\n       nxt Accessible_dfa q x \\<in> states Accessible_dfa\n 2. finite (states Accessible_dfa)", "fix q a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       q \\<in> states Accessible_dfa \\<Longrightarrow>\n       nxt Accessible_dfa q x \\<in> states Accessible_dfa\n 2. finite (states Accessible_dfa)", "show \"q \\<in> states Accessible_dfa \\<Longrightarrow> nxt Accessible_dfa q a \\<in> states Accessible_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> states Accessible_dfa \\<Longrightarrow>\n    nxt Accessible_dfa q a \\<in> states Accessible_dfa", "by (auto simp: nxt nxt_accessible)"], ["proof (state)\nthis:\n  q \\<in> states Accessible_dfa \\<Longrightarrow>\n  nxt Accessible_dfa q a \\<in> states Accessible_dfa\n\ngoal (1 subgoal):\n 1. finite (states Accessible_dfa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (states Accessible_dfa)", "show \"finite (states Accessible_dfa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (states Accessible_dfa)", "by (auto intro: accessible_imp_states finite_subset finite)"], ["proof (state)\nthis:\n  finite (states Accessible_dfa)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dfa_Accessible: \"dfa Accessible_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa Accessible_dfa", "by unfold_locales"], ["", "lemma nextl_Accessible_dfa [simp]:\n     \"q \\<in> accessible \\<Longrightarrow> Accessible.nextl q u = nextl q u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> accessible \\<Longrightarrow> Accessible.nextl q u = nextl q u", "by (induct u rule: List.rev_induct, auto)"], ["", "lemma init_Accessible: \"init M \\<in> accessible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init M \\<in> accessible", "using dfa.init dfa_Accessible"], ["proof (prove)\nusing this:\n  dfa ?M \\<Longrightarrow> init ?M \\<in> states ?M\n  dfa Accessible_dfa\n\ngoal (1 subgoal):\n 1. init M \\<in> accessible", "by force"], ["", "declare nextl_Accessible_dfa [OF init_Accessible, simp]"], ["", "lemma Accessible_left_lang_eq [simp]: \"Accessible.left_lang q = left_lang q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Accessible.left_lang q = left_lang q", "by (auto simp: Accessible.left_lang_def left_lang_def)"], ["", "lemma Accessible_right_lang_eq [simp]:\n  \"q \\<in> accessible \\<Longrightarrow> Accessible.right_lang q = right_lang q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> accessible \\<Longrightarrow>\n    Accessible.right_lang q = right_lang q", "by (auto simp: Accessible.right_lang_def right_lang_def accessible_def left_lang_def nextl_app [symmetric])"], ["", "lemma Accessible_language [simp]: \"Accessible.language = language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Accessible.language = language", "by (simp add: Accessible.language_eq_right_lang language_eq_right_lang\n                Accessible_right_lang_eq [OF init_Accessible])"], ["", "lemma Accessible_accessible [simp]: \"Accessible.accessible = accessible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Accessible.accessible = accessible", "using Accessible.accessible_def accessible_def"], ["proof (prove)\nusing this:\n  Accessible.accessible \\<equiv> {q. Accessible.left_lang q \\<noteq> {}}\n  accessible \\<equiv> {q. left_lang q \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. Accessible.accessible = accessible", "by auto"], ["", "lemma left_lang_half:\n  assumes sb: \"\\<Union>(left_lang ` qs1) \\<subseteq> \\<Union>(left_lang ` qs2)\"\n      and ne: \"\\<And>x. x \\<in> qs1 \\<Longrightarrow> left_lang x \\<noteq> {}\"\n    shows \"qs1 \\<subseteq> qs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs1 \\<subseteq> qs2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> qs1 \\<Longrightarrow> x \\<in> qs2", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> qs1 \\<Longrightarrow> x \\<in> qs2", "assume x: \"x \\<in> qs1\""], ["proof (state)\nthis:\n  x \\<in> qs1\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> qs1 \\<Longrightarrow> x \\<in> qs2", "with ne"], ["proof (chain)\npicking this:\n  ?x \\<in> qs1 \\<Longrightarrow> left_lang ?x \\<noteq> {}\n  x \\<in> qs1", "obtain y where y: \"y \\<in> left_lang x\""], ["proof (prove)\nusing this:\n  ?x \\<in> qs1 \\<Longrightarrow> left_lang ?x \\<noteq> {}\n  x \\<in> qs1\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<in> left_lang x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> left_lang x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> qs1 \\<Longrightarrow> x \\<in> qs2", "then"], ["proof (chain)\npicking this:\n  y \\<in> left_lang x", "have \"y \\<in> \\<Union>(left_lang ` qs2)\""], ["proof (prove)\nusing this:\n  y \\<in> left_lang x\n\ngoal (1 subgoal):\n 1. y \\<in> \\<Union> (left_lang ` qs2)", "using x sb [THEN subsetD]"], ["proof (prove)\nusing this:\n  y \\<in> left_lang x\n  x \\<in> qs1\n  ?c \\<in> \\<Union> (left_lang ` qs1) \\<Longrightarrow>\n  ?c \\<in> \\<Union> (left_lang ` qs2)\n\ngoal (1 subgoal):\n 1. y \\<in> \\<Union> (left_lang ` qs2)", "by blast"], ["proof (state)\nthis:\n  y \\<in> \\<Union> (left_lang ` qs2)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> qs1 \\<Longrightarrow> x \\<in> qs2", "then"], ["proof (chain)\npicking this:\n  y \\<in> \\<Union> (left_lang ` qs2)", "show \"x \\<in> qs2\""], ["proof (prove)\nusing this:\n  y \\<in> \\<Union> (left_lang ` qs2)\n\ngoal (1 subgoal):\n 1. x \\<in> qs2", "by (metis UN_E disjoint_iff_not_equal left_lang_disjoint y)"], ["proof (state)\nthis:\n  x \\<in> qs2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_lang_UN:\n     \"\\<lbrakk>\\<Union>(left_lang ` qs1) = \\<Union>(left_lang ` qs2); qs1 \\<union> qs2 \\<subseteq> accessible\\<rbrakk>\n      \\<Longrightarrow> qs1 = qs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Union> (left_lang ` qs1) = \\<Union> (left_lang ` qs2);\n     qs1 \\<union> qs2 \\<subseteq> accessible\\<rbrakk>\n    \\<Longrightarrow> qs1 = qs2", "apply (rule equalityI [OF _ dfa.left_lang_half [OF dfa_Accessible]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Union> (left_lang ` qs1) = \\<Union> (left_lang ` qs2);\n     qs1 \\<union> qs2 \\<subseteq> accessible\\<rbrakk>\n    \\<Longrightarrow> qs1 \\<subseteq> qs2\n 2. \\<lbrakk>\\<Union> (left_lang ` qs1) = \\<Union> (left_lang ` qs2);\n     qs1 \\<union> qs2 \\<subseteq> accessible\\<rbrakk>\n    \\<Longrightarrow> \\<Union> (Accessible.left_lang ` qs2)\n                      \\<subseteq> \\<Union> (Accessible.left_lang ` qs1)\n 3. \\<And>x.\n       \\<lbrakk>\\<Union> (left_lang ` qs1) = \\<Union> (left_lang ` qs2);\n        qs1 \\<union> qs2 \\<subseteq> accessible; x \\<in> qs2\\<rbrakk>\n       \\<Longrightarrow> Accessible.left_lang x \\<noteq> {}", "apply (rule dfa.left_lang_half [OF dfa_Accessible], auto simp: accessible_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition minimal where\n  \"minimal \\<equiv> accessible = states M \\<and> inj_on right_lang (dfa.states M)\""], ["", "subsection\\<open>An Equivalence Relation on States\\<close>"], ["", "text\\<open>Collapsing map on states. Two states are equivalent if they yield identical outcomes\\<close>"], ["", "definition eq_right_lang :: \"(hf \\<times> hf) set\" where\n  \"eq_right_lang \\<equiv> {(u,v). u \\<in> states M \\<and> v \\<in> states M \\<and> right_lang u = right_lang v}\""], ["", "lemma equiv_eq_right_lang: \"equiv (states M) eq_right_lang\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv (states M) eq_right_lang", "by (auto simp: equiv_def refl_on_def sym_def trans_def eq_right_lang_def)"], ["", "lemma eq_right_lang_finite_index: \"finite (states M // eq_right_lang)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (states M // eq_right_lang)", "by (metis finite_imageI finite proj_image)"], ["", "definition Collapse_dfa :: \"'a dfa\" where\n  \"Collapse_dfa = \\<lparr>dfa.states = HF ` (states M // eq_right_lang),\n                   init       = HF (eq_right_lang `` {init M}),\n                   final      = {HF (eq_right_lang `` {q}) | q. q \\<in> final M},\n                   nxt        = \\<lambda>Q x. HF (\\<Union>q \\<in> hfset Q. eq_right_lang `` {nxt M q x})\\<rparr>\""], ["", "lemma nxt_Collapse_resp: \"(\\<lambda>q. eq_right_lang `` {nxt M q x}) respects eq_right_lang\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>q. eq_right_lang `` {nxt M q x}) respects eq_right_lang", "by (auto simp: nextl.simps [symmetric] congruent_def eq_right_lang_def nxt right_lang_def\n           simp del: nextl.simps)"], ["", "lemma finite_Collapse_state: \"Q \\<in> states M // eq_right_lang \\<Longrightarrow> finite Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<in> states M // eq_right_lang \\<Longrightarrow> finite Q", "by (meson equiv_eq_right_lang finite_subset in_quotient_imp_subset finite)"], ["", "interpretation Collapse: dfa Collapse_dfa"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa Collapse_dfa", "proof unfold_locales"], ["proof (state)\ngoal (4 subgoals):\n 1. init Collapse_dfa \\<in> states Collapse_dfa\n 2. final Collapse_dfa \\<subseteq> states Collapse_dfa\n 3. \\<And>q x.\n       q \\<in> states Collapse_dfa \\<Longrightarrow>\n       nxt Collapse_dfa q x \\<in> states Collapse_dfa\n 4. finite (states Collapse_dfa)", "show \"dfa.init Collapse_dfa \\<in> dfa.states Collapse_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init Collapse_dfa \\<in> states Collapse_dfa", "by (simp add: Collapse_dfa_def quotientI)"], ["proof (state)\nthis:\n  init Collapse_dfa \\<in> states Collapse_dfa\n\ngoal (3 subgoals):\n 1. final Collapse_dfa \\<subseteq> states Collapse_dfa\n 2. \\<And>q x.\n       q \\<in> states Collapse_dfa \\<Longrightarrow>\n       nxt Collapse_dfa q x \\<in> states Collapse_dfa\n 3. finite (states Collapse_dfa)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. final Collapse_dfa \\<subseteq> states Collapse_dfa\n 2. \\<And>q x.\n       q \\<in> states Collapse_dfa \\<Longrightarrow>\n       nxt Collapse_dfa q x \\<in> states Collapse_dfa\n 3. finite (states Collapse_dfa)", "show \"dfa.final Collapse_dfa \\<subseteq> dfa.states Collapse_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final Collapse_dfa \\<subseteq> states Collapse_dfa", "using final"], ["proof (prove)\nusing this:\n  final M \\<subseteq> states M\n\ngoal (1 subgoal):\n 1. final Collapse_dfa \\<subseteq> states Collapse_dfa", "by (auto simp: Collapse_dfa_def quotientI)"], ["proof (state)\nthis:\n  final Collapse_dfa \\<subseteq> states Collapse_dfa\n\ngoal (2 subgoals):\n 1. \\<And>q x.\n       q \\<in> states Collapse_dfa \\<Longrightarrow>\n       nxt Collapse_dfa q x \\<in> states Collapse_dfa\n 2. finite (states Collapse_dfa)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       q \\<in> states Collapse_dfa \\<Longrightarrow>\n       nxt Collapse_dfa q x \\<in> states Collapse_dfa\n 2. finite (states Collapse_dfa)", "fix q a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       q \\<in> states Collapse_dfa \\<Longrightarrow>\n       nxt Collapse_dfa q x \\<in> states Collapse_dfa\n 2. finite (states Collapse_dfa)", "show \"q \\<in> dfa.states Collapse_dfa \\<Longrightarrow> dfa.nxt Collapse_dfa q a \\<in> dfa.states Collapse_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> states Collapse_dfa \\<Longrightarrow>\n    nxt Collapse_dfa q a \\<in> states Collapse_dfa", "by (auto simp: Collapse_dfa_def nxt quotientI finite_Collapse_state\n                   UN_equiv_class_type [OF equiv_eq_right_lang nxt_Collapse_resp])"], ["proof (state)\nthis:\n  q \\<in> states Collapse_dfa \\<Longrightarrow>\n  nxt Collapse_dfa q a \\<in> states Collapse_dfa\n\ngoal (1 subgoal):\n 1. finite (states Collapse_dfa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (states Collapse_dfa)", "show \"finite (dfa.states Collapse_dfa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (states Collapse_dfa)", "by (simp add: Collapse_dfa_def eq_right_lang_finite_index)"], ["proof (state)\nthis:\n  finite (states Collapse_dfa)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary dfa_Collapse: \"dfa Collapse_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa Collapse_dfa", "by unfold_locales"], ["", "lemma nextl_Collapse_dfa:\n     \"Q = HF (eq_right_lang `` {q}) \\<Longrightarrow> Q \\<in> dfa.states Collapse_dfa \\<Longrightarrow>\n      q \\<in> states M \\<Longrightarrow>\n             Collapse.nextl Q u = HF (eq_right_lang `` {nextl q u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q = HF (eq_right_lang `` {q}); Q \\<in> states Collapse_dfa;\n     q \\<in> states M\\<rbrakk>\n    \\<Longrightarrow> Collapse.nextl Q u = HF (eq_right_lang `` {nextl q u})", "apply (induct u rule: List.rev_induct, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>Collapse.nextl (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q});\n        HF (eq_right_lang `` {q}) \\<in> states Collapse_dfa;\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> nxt Collapse_dfa\n                          (HF (eq_right_lang `` {nextl q xs})) x =\n                         HF (eq_right_lang `` {nxt M (nextl q xs) x})", "apply (simp add: Collapse_dfa_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>dfa.nextl\n                 \\<lparr>states = HF ` states M // eq_right_lang,\n                    init = HF (eq_right_lang `` {init M}),\n                    final = {HF (eq_right_lang `` {q}) |q. q \\<in> final M},\n                    nxt =\n                      \\<lambda>Q x.\n                         HF (\\<Union>q\\<in>hfset Q.\n                                eq_right_lang `` {nxt M q x})\\<rparr>\n                 (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q});\n        HF (eq_right_lang `` {q}) \\<in> HF ` states M // eq_right_lang;\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> HF (\\<Union>q\\<in>hfset\n      (HF (eq_right_lang `` {nextl q xs})).\n                                eq_right_lang `` {nxt M q x}) =\n                         HF (eq_right_lang `` {nxt M (nextl q xs) x})", "apply (subst inj_on_eq_iff [OF inj_on_HF])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>dfa.nextl\n                 \\<lparr>states = HF ` states M // eq_right_lang,\n                    init = HF (eq_right_lang `` {init M}),\n                    final = {HF (eq_right_lang `` {q}) |q. q \\<in> final M},\n                    nxt =\n                      \\<lambda>Q x.\n                         HF (\\<Union>q\\<in>hfset Q.\n                                eq_right_lang `` {nxt M q x})\\<rparr>\n                 (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q});\n        HF (eq_right_lang `` {q}) \\<in> HF ` states M // eq_right_lang;\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>q\\<in>hfset\n   (HF (eq_right_lang `` {nextl q xs})).\n                             eq_right_lang `` {nxt M q x})\n                         \\<in> Collect finite\n 2. \\<And>x xs.\n       \\<lbrakk>dfa.nextl\n                 \\<lparr>states = HF ` states M // eq_right_lang,\n                    init = HF (eq_right_lang `` {init M}),\n                    final = {HF (eq_right_lang `` {q}) |q. q \\<in> final M},\n                    nxt =\n                      \\<lambda>Q x.\n                         HF (\\<Union>q\\<in>hfset Q.\n                                eq_right_lang `` {nxt M q x})\\<rparr>\n                 (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q});\n        HF (eq_right_lang `` {q}) \\<in> HF ` states M // eq_right_lang;\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> eq_right_lang `` {nxt M (nextl q xs) x}\n                         \\<in> Collect finite\n 3. \\<And>x xs.\n       \\<lbrakk>dfa.nextl\n                 \\<lparr>states = HF ` states M // eq_right_lang,\n                    init = HF (eq_right_lang `` {init M}),\n                    final = {HF (eq_right_lang `` {q}) |q. q \\<in> final M},\n                    nxt =\n                      \\<lambda>Q x.\n                         HF (\\<Union>q\\<in>hfset Q.\n                                eq_right_lang `` {nxt M q x})\\<rparr>\n                 (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q});\n        HF (eq_right_lang `` {q}) \\<in> HF ` states M // eq_right_lang;\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>q\\<in>hfset\n   (HF (eq_right_lang `` {nextl q xs})).\n                             eq_right_lang `` {nxt M q x}) =\n                         eq_right_lang `` {nxt M (nextl q xs) x}", "apply (rule UN_equiv_class_type [OF equiv_eq_right_lang nxt_Collapse_resp])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>dfa.nextl\n                 \\<lparr>states = HF ` states M // eq_right_lang,\n                    init = HF (eq_right_lang `` {init M}),\n                    final = {HF (eq_right_lang `` {q}) |q. q \\<in> final M},\n                    nxt =\n                      \\<lambda>Q x.\n                         HF (\\<Union>q\\<in>hfset Q.\n                                eq_right_lang `` {nxt M q x})\\<rparr>\n                 (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q});\n        HF (eq_right_lang `` {q}) \\<in> HF ` states M // eq_right_lang;\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> hfset (HF (eq_right_lang `` {nextl q xs}))\n                         \\<in> states M // eq_right_lang\n 2. \\<And>x xs qa.\n       \\<lbrakk>dfa.nextl\n                 \\<lparr>states = HF ` states M // eq_right_lang,\n                    init = HF (eq_right_lang `` {init M}),\n                    final = {HF (eq_right_lang `` {q}) |q. q \\<in> final M},\n                    nxt =\n                      \\<lambda>Q x.\n                         HF (\\<Union>q\\<in>hfset Q.\n                                eq_right_lang `` {nxt M q x})\\<rparr>\n                 (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q});\n        HF (eq_right_lang `` {q}) \\<in> HF ` states M // eq_right_lang;\n        q \\<in> states M; qa \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> eq_right_lang `` {nxt M qa x} \\<in> Collect finite\n 3. \\<And>x xs.\n       \\<lbrakk>dfa.nextl\n                 \\<lparr>states = HF ` states M // eq_right_lang,\n                    init = HF (eq_right_lang `` {init M}),\n                    final = {HF (eq_right_lang `` {q}) |q. q \\<in> final M},\n                    nxt =\n                      \\<lambda>Q x.\n                         HF (\\<Union>q\\<in>hfset Q.\n                                eq_right_lang `` {nxt M q x})\\<rparr>\n                 (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q});\n        HF (eq_right_lang `` {q}) \\<in> HF ` states M // eq_right_lang;\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> eq_right_lang `` {nxt M (nextl q xs) x}\n                         \\<in> Collect finite\n 4. \\<And>x xs.\n       \\<lbrakk>dfa.nextl\n                 \\<lparr>states = HF ` states M // eq_right_lang,\n                    init = HF (eq_right_lang `` {init M}),\n                    final = {HF (eq_right_lang `` {q}) |q. q \\<in> final M},\n                    nxt =\n                      \\<lambda>Q x.\n                         HF (\\<Union>q\\<in>hfset Q.\n                                eq_right_lang `` {nxt M q x})\\<rparr>\n                 (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q});\n        HF (eq_right_lang `` {q}) \\<in> HF ` states M // eq_right_lang;\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>q\\<in>hfset\n   (HF (eq_right_lang `` {nextl q xs})).\n                             eq_right_lang `` {nxt M q x}) =\n                         eq_right_lang `` {nxt M (nextl q xs) x}", "apply (auto simp: nxt quotientI finite_Collapse_state nextl_state)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs xa xb.\n       \\<lbrakk>dfa.nextl\n                 \\<lparr>states = HF ` states M // eq_right_lang,\n                    init = HF (eq_right_lang `` {init M}),\n                    final = {HF (eq_right_lang `` {q}) |q. q \\<in> final M},\n                    nxt =\n                      \\<lambda>Q x.\n                         HF (\\<Union>q\\<in>hfset Q.\n                                eq_right_lang `` {nxt M q x})\\<rparr>\n                 (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q}); q \\<in> states M;\n        (nextl q xs, xb) \\<in> eq_right_lang;\n        (nxt M xb x, xa) \\<in> eq_right_lang\\<rbrakk>\n       \\<Longrightarrow> (nxt M (nextl q xs) x, xa) \\<in> eq_right_lang\n 2. \\<And>x xs xa.\n       \\<lbrakk>dfa.nextl\n                 \\<lparr>states = HF ` states M // eq_right_lang,\n                    init = HF (eq_right_lang `` {init M}),\n                    final = {HF (eq_right_lang `` {q}) |q. q \\<in> final M},\n                    nxt =\n                      \\<lambda>Q x.\n                         HF (\\<Union>q\\<in>hfset Q.\n                                eq_right_lang `` {nxt M q x})\\<rparr>\n                 (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q}); q \\<in> states M;\n        (nxt M (nextl q xs) x, xa) \\<in> eq_right_lang\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>eq_right_lang `` {nextl q xs}.\n                            (nxt M xb x, xa) \\<in> eq_right_lang", "apply (force simp add: nextl.simps [symmetric]  eq_right_lang_def nxt right_lang_def\n               simp del: nextl.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>dfa.nextl\n                 \\<lparr>states = HF ` states M // eq_right_lang,\n                    init = HF (eq_right_lang `` {init M}),\n                    final = {HF (eq_right_lang `` {q}) |q. q \\<in> final M},\n                    nxt =\n                      \\<lambda>Q x.\n                         HF (\\<Union>q\\<in>hfset Q.\n                                eq_right_lang `` {nxt M q x})\\<rparr>\n                 (HF (eq_right_lang `` {q})) xs =\n                HF (eq_right_lang `` {nextl q xs});\n        Q = HF (eq_right_lang `` {q}); q \\<in> states M;\n        (nxt M (nextl q xs) x, xa) \\<in> eq_right_lang\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>eq_right_lang `` {nextl q xs}.\n                            (nxt M xb x, xa) \\<in> eq_right_lang", "apply (metis equiv_class_self equiv_eq_right_lang nextl_state)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ext_language_Collapse_dfa:\n     \"u \\<in> Collapse.language \\<longleftrightarrow> u \\<in> language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<in> Collapse.language) = (u \\<in> language)", "apply (simp add: Collapse.language_def language_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Collapse.nextl (init Collapse_dfa) u \\<in> final Collapse_dfa) =\n    (nextl (init M) u \\<in> final M)", "apply (subst nextl_Collapse_dfa)"], ["proof (prove)\ngoal (4 subgoals):\n 1. init Collapse_dfa = HF (eq_right_lang `` {?q})\n 2. init Collapse_dfa \\<in> states Collapse_dfa\n 3. ?q \\<in> states M\n 4. (HF (eq_right_lang `` {nextl ?q u}) \\<in> final Collapse_dfa) =\n    (nextl (init M) u \\<in> final M)", "apply (auto simp: Collapse_dfa_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. HF (eq_right_lang `` {init M}) \\<in> HF ` states M // eq_right_lang\n 2. \\<And>q.\n       \\<lbrakk>HF (eq_right_lang `` {nextl (init M) u}) =\n                HF (eq_right_lang `` {q});\n        q \\<in> final M\\<rbrakk>\n       \\<Longrightarrow> nextl (init M) u \\<in> final M", "using final [THEN subsetD] init"], ["proof (prove)\nusing this:\n  ?c \\<in> final M \\<Longrightarrow> ?c \\<in> states M\n  init M \\<in> states M\n\ngoal (2 subgoals):\n 1. HF (eq_right_lang `` {init M}) \\<in> HF ` states M // eq_right_lang\n 2. \\<And>q.\n       \\<lbrakk>HF (eq_right_lang `` {nextl (init M) u}) =\n                HF (eq_right_lang `` {q});\n        q \\<in> final M\\<rbrakk>\n       \\<Longrightarrow> nextl (init M) u \\<in> final M", "apply (auto simp: quotientI  inj_on_eq_iff [OF inj_on_HF] finite_Collapse_state\n                    UN_equiv_class_type [OF equiv_eq_right_lang nxt_Collapse_resp])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>eq_right_lang `` {nextl (init M) u} = eq_right_lang `` {q};\n        q \\<in> final M;\n        \\<And>c. c \\<in> final M \\<Longrightarrow> c \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> nextl (init M) u \\<in> final M", "apply (drule eq_equiv_class [OF _ equiv_eq_right_lang])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> final M;\n        \\<And>c. c \\<in> final M \\<Longrightarrow> c \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> q \\<in> states M\n 2. \\<And>q.\n       \\<lbrakk>q \\<in> final M;\n        \\<And>c. c \\<in> final M \\<Longrightarrow> c \\<in> states M;\n        (nextl (init M) u, q) \\<in> eq_right_lang\\<rbrakk>\n       \\<Longrightarrow> nextl (init M) u \\<in> final M", "apply (auto simp: eq_right_lang_def right_lang_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> final M;\n        \\<And>c. c \\<in> final M \\<Longrightarrow> c \\<in> states M;\n        {ua. nextl (nextl (init M) u) ua \\<in> final M} =\n        {u. nextl q u \\<in> final M}\\<rbrakk>\n       \\<Longrightarrow> nextl (init M) u \\<in> final M", "apply (metis mem_Collect_eq nextl.simps(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem language_Collapse_dfa:\n     \"Collapse.language = language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collapse.language = language", "by (simp add: ext_language_Collapse_dfa subset_antisym subset_iff)"], ["", "lemma card_Collapse_dfa: \"card (states M // eq_right_lang) \\<le> card (states M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (states M // eq_right_lang) \\<le> card (states M)", "by (metis card_image_le finite proj_image)"], ["", "end"], ["", "subsection \\<open>Isomorphisms Between DFAs\\<close>"], ["", "locale dfa_isomorphism = M: dfa M + N: dfa N for M :: \"'a dfa\" and N :: \"'a dfa\" +\n  fixes h :: \"hf \\<Rightarrow> hf\"\n  assumes h: \"bij_betw h (states M) (states N)\"\n      and init  [simp]: \"h (init M) = init N\"\n      and final [simp]: \"h ` final M = final N\"\n      and nxt   [simp]: \"\\<And>q x. q \\<in> states M \\<Longrightarrow> h (nxt M q x) = nxt N (h q) x\"\n\nbegin"], ["", "lemma nextl [simp]: \"q \\<in> states M \\<Longrightarrow> h (M.nextl q u) = N.nextl (h q) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> states M \\<Longrightarrow> h (M.nextl q u) = N.nextl (h q) u", "by (induct u rule: List.rev_induct) (auto simp: M.nextl_state)"], ["", "theorem language: \"M.language = N.language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.language = N.language", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> M.language) = (x \\<in> N.language)", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> M.language) = (x \\<in> N.language)", "have \"M.nextl (init M) u \\<in> final M \\<longleftrightarrow> h (M.nextl (init M) u) \\<in> h ` final M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M.nextl (init M) u \\<in> final M) =\n    (h (M.nextl (init M) u) \\<in> h ` final M)", "by (subst inj_on_image_mem_iff [OF bij_betw_imp_inj_on [OF h] _ M.final]) (auto)"], ["proof (state)\nthis:\n  (M.nextl (init M) u \\<in> final M) =\n  (h (M.nextl (init M) u) \\<in> h ` final M)\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> M.language) = (x \\<in> N.language)", "also"], ["proof (state)\nthis:\n  (M.nextl (init M) u \\<in> final M) =\n  (h (M.nextl (init M) u) \\<in> h ` final M)\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> M.language) = (x \\<in> N.language)", "have \"... \\<longleftrightarrow> N.nextl (init N) u \\<in> final N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h (M.nextl (init M) u) \\<in> h ` final M) =\n    (N.nextl (init N) u \\<in> final N)", "by simp"], ["proof (state)\nthis:\n  (h (M.nextl (init M) u) \\<in> h ` final M) =\n  (N.nextl (init N) u \\<in> final N)\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> M.language) = (x \\<in> N.language)", "finally"], ["proof (chain)\npicking this:\n  (M.nextl (init M) u \\<in> final M) = (N.nextl (init N) u \\<in> final N)", "show \"u \\<in> M.language \\<longleftrightarrow> u \\<in> dfa.language N\""], ["proof (prove)\nusing this:\n  (M.nextl (init M) u \\<in> final M) = (N.nextl (init N) u \\<in> final N)\n\ngoal (1 subgoal):\n 1. (u \\<in> M.language) = (u \\<in> N.language)", "by (simp add: M.language_def N.language_def)"], ["proof (state)\nthis:\n  (u \\<in> M.language) = (u \\<in> N.language)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nxt_inv_into: \"q \\<in> states N \\<Longrightarrow> nxt N q x = h (nxt M (inv_into (states M) h q) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> states N \\<Longrightarrow>\n    nxt N q x = h (nxt M (inv_into (states M) h q) x)", "apply (subst nxt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q \\<in> states N \\<Longrightarrow>\n    inv_into (states M) h q \\<in> states M\n 2. q \\<in> states N \\<Longrightarrow>\n    nxt N q x = nxt N (h (inv_into (states M) h q)) x", "apply (metis bij_betw_def h inv_into_into)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> states N \\<Longrightarrow>\n    nxt N q x = nxt N (h (inv_into (states M) h q)) x", "apply (metis bij_betw_inv_into_right h)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sym: \"dfa_isomorphism N M (inv_into (states M) h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_isomorphism N M (inv_into (states M) h)", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. bij_betw (inv_into (states M) h) (states N) (states M)\n 2. inv_into (states M) h (init N) = init M\n 3. inv_into (states M) h ` final N = final M\n 4. \\<And>q x.\n       q \\<in> states N \\<Longrightarrow>\n       inv_into (states M) h (nxt N q x) = nxt M (inv_into (states M) h q) x", "apply (metis bij_betw_inv_into h)"], ["proof (prove)\ngoal (3 subgoals):\n 1. inv_into (states M) h (init N) = init M\n 2. inv_into (states M) h ` final N = final M\n 3. \\<And>q x.\n       q \\<in> states N \\<Longrightarrow>\n       inv_into (states M) h (nxt N q x) = nxt M (inv_into (states M) h q) x", "apply (metis M.init bij_betw_imp_inj_on h inv_into_f_eq init)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inv_into (states M) h ` final N = final M\n 2. \\<And>q x.\n       q \\<in> states N \\<Longrightarrow>\n       inv_into (states M) h (nxt N q x) = nxt M (inv_into (states M) h q) x", "apply (metis M.final bij_betw_def bij_betw_inv_into_subset h final)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q x.\n       q \\<in> states N \\<Longrightarrow>\n       inv_into (states M) h (nxt N q x) = nxt M (inv_into (states M) h q) x", "apply (simp add: nxt_inv_into)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q x.\n       q \\<in> states N \\<Longrightarrow>\n       inv_into (states M) h (h (nxt M (inv_into (states M) h q) x)) =\n       nxt M (inv_into (states M) h q) x", "apply (metis M.nxt bij_betw_def h inv_into_f_eq inv_into_into)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma trans: \"dfa_isomorphism N N' h' \\<Longrightarrow> dfa_isomorphism M N' (h' o h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_isomorphism N N' h' \\<Longrightarrow>\n    dfa_isomorphism M N' (h' \\<circ> h)", "apply (auto simp: dfa_isomorphism_def dfa_isomorphism_axioms_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n     h' (init N) = init N'; h' ` final N = final N';\n     \\<forall>q.\n        q \\<in> states N \\<longrightarrow>\n        (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x)\\<rbrakk>\n    \\<Longrightarrow> dfa M\n 2. \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n     h' (init N) = init N'; h' ` final N = final N';\n     \\<forall>q.\n        q \\<in> states N \\<longrightarrow>\n        (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x)\\<rbrakk>\n    \\<Longrightarrow> bij_betw (h' \\<circ> h) (states M) (states N')\n 3. \\<And>xa.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        xa \\<in> final M\\<rbrakk>\n       \\<Longrightarrow> h' (h xa) \\<in> final N'\n 4. \\<And>x.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        x \\<in> final N'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. h' (h x)) ` final M\n 5. \\<And>q x.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> h' (nxt N (h q) x) = nxt N' (h' (h q)) x", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n     h' (init N) = init N'; h' ` final N = final N';\n     \\<forall>q.\n        q \\<in> states N \\<longrightarrow>\n        (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x)\\<rbrakk>\n    \\<Longrightarrow> bij_betw (h' \\<circ> h) (states M) (states N')\n 2. \\<And>xa.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        xa \\<in> final M\\<rbrakk>\n       \\<Longrightarrow> h' (h xa) \\<in> final N'\n 3. \\<And>x.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        x \\<in> final N'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. h' (h x)) ` final M\n 4. \\<And>q x.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> h' (nxt N (h q) x) = nxt N' (h' (h q)) x", "apply (metis bij_betw_comp_iff h)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        xa \\<in> final M\\<rbrakk>\n       \\<Longrightarrow> h' (h xa) \\<in> final N'\n 2. \\<And>x.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        x \\<in> final N'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. h' (h x)) ` final M\n 3. \\<And>q x.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> h' (nxt N (h q) x) = nxt N' (h' (h q)) x", "apply (metis imageI final)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        x \\<in> final N'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. h' (h x)) ` final M\n 2. \\<And>q x.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> h' (nxt N (h q) x) = nxt N' (h' (h q)) x", "apply (simp only: final [symmetric] image_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; (h' \\<circ> h) ` final M = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        x \\<in> final N'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. h' (h x)) ` final M\n 2. \\<And>q x.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> h' (nxt N (h q) x) = nxt N' (h' (h q)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q x.\n       \\<lbrakk>dfa N; dfa N'; bij_betw h' (states N) (states N');\n        h' (init N) = init N'; h' ` final N = final N';\n        \\<forall>q.\n           q \\<in> states N \\<longrightarrow>\n           (\\<forall>x. h' (nxt N q x) = nxt N' (h' q) x);\n        q \\<in> states M\\<rbrakk>\n       \\<Longrightarrow> h' (nxt N (h q) x) = nxt N' (h' (h q)) x", "apply (metis bij_betw_def h image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "section\\<open>The Myhill-Nerode theorem: three characterisations of a regular language\\<close>"], ["", "definition regular :: \"'a list set \\<Rightarrow> bool\" where\n  \"regular L \\<equiv> \\<exists>M. dfa M \\<and> dfa.language M = L\""], ["", "definition MyhillNerode :: \"'a list set \\<Rightarrow> ('a list * 'a list) set \\<Rightarrow> bool\" where\n  \"MyhillNerode L R \\<equiv> equiv UNIV R \\<and> right_invariant R \\<and> finite (UNIV//R) \\<and> (\\<exists>A. L = R``A)\""], ["", "text\\<open>This relation can be seen as an abstraction of the idea, do @{term u} and @{term v}\n  lead to the same state?  Compare with @{term eq_nextl}, which does precisely that.\\<close>"], ["", "definition eq_app_right :: \"'a list set \\<Rightarrow> ('a list * 'a list) set\" where\n  \"eq_app_right L \\<equiv> {(u,v). \\<forall>w. u@w \\<in> L \\<longleftrightarrow> v@w \\<in> L}\""], ["", "lemma equiv_eq_app_right: \"equiv UNIV (eq_app_right L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv UNIV (eq_app_right L)", "by (simp add: equivI refl_on_def sym_def trans_def eq_app_right_def)"], ["", "lemma right_invariant_eq_app_right: \"right_invariant (eq_app_right L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_invariant (eq_app_right L)", "by (simp add: right_invariant_def eq_app_right_def)"], ["", "lemma eq_app_right_eq: \"eq_app_right L `` L = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_app_right L `` L = L", "unfolding eq_app_right_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v). \\<forall>w. (u @ w \\<in> L) = (v @ w \\<in> L)} `` L = L", "by auto (metis append_Nil2)"], ["", "lemma MN_eq_app_right:\n     \"finite (UNIV // eq_app_right L) \\<Longrightarrow> MyhillNerode L (eq_app_right L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UNIV // eq_app_right L) \\<Longrightarrow>\n    MyhillNerode L (eq_app_right L)", "unfolding MyhillNerode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UNIV // eq_app_right L) \\<Longrightarrow>\n    equiv UNIV (eq_app_right L) \\<and>\n    right_invariant (eq_app_right L) \\<and>\n    finite (UNIV // eq_app_right L) \\<and>\n    (\\<exists>A. L = eq_app_right L `` A)", "using eq_app_right_eq"], ["proof (prove)\nusing this:\n  eq_app_right ?L `` ?L = ?L\n\ngoal (1 subgoal):\n 1. finite (UNIV // eq_app_right L) \\<Longrightarrow>\n    equiv UNIV (eq_app_right L) \\<and>\n    right_invariant (eq_app_right L) \\<and>\n    finite (UNIV // eq_app_right L) \\<and>\n    (\\<exists>A. L = eq_app_right L `` A)", "by (auto simp: equiv_eq_app_right right_invariant_eq_app_right)"], ["", "lemma MN_refines: \"\\<lbrakk>MyhillNerode L R; (x,y) \\<in> R\\<rbrakk> \\<Longrightarrow> x \\<in> L \\<longleftrightarrow> y \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MyhillNerode L R; (x, y) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> L) = (y \\<in> L)", "unfolding equiv_def trans_def sym_def MyhillNerode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(refl R \\<and>\n              (\\<forall>x y.\n                  (x, y) \\<in> R \\<longrightarrow> (y, x) \\<in> R) \\<and>\n              (\\<forall>x y z.\n                  (x, y) \\<in> R \\<longrightarrow>\n                  (y, z) \\<in> R \\<longrightarrow> (x, z) \\<in> R)) \\<and>\n             right_invariant R \\<and>\n             finite (UNIV // R) \\<and> (\\<exists>A. L = R `` A);\n     (x, y) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> L) = (y \\<in> L)", "by blast"], ["", "lemma MN_refines_eq_app_right: \"MyhillNerode L R \\<Longrightarrow> R \\<subseteq> eq_app_right L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MyhillNerode L R \\<Longrightarrow> R \\<subseteq> eq_app_right L", "unfolding eq_app_right_def MyhillNerode_def right_invariant_def equiv_def trans_def sym_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (refl R \\<and>\n     (\\<forall>x y. (x, y) \\<in> R \\<longrightarrow> (y, x) \\<in> R) \\<and>\n     (\\<forall>x y z.\n         (x, y) \\<in> R \\<longrightarrow>\n         (y, z) \\<in> R \\<longrightarrow> (x, z) \\<in> R)) \\<and>\n    (\\<forall>u v w.\n        (u, v) \\<in> R \\<longrightarrow> (u @ w, v @ w) \\<in> R) \\<and>\n    finite (UNIV // R) \\<and> (\\<exists>A. L = R `` A) \\<Longrightarrow>\n    R \\<subseteq> {(u, v). \\<forall>w. (u @ w \\<in> L) = (v @ w \\<in> L)}", "by blast"], ["", "text\\<open>Step 1 in the circle of implications: every regular language @{term L} is recognised\n  by some Myhill-Nerode relation, @{term R}\\<close>"], ["", "context dfa\nbegin"], ["", "lemma MN_eq_nextl: \"MyhillNerode language eq_nextl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MyhillNerode language eq_nextl", "unfolding MyhillNerode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv UNIV eq_nextl \\<and>\n    right_invariant eq_nextl \\<and>\n    finite (UNIV // eq_nextl) \\<and> (\\<exists>A. language = eq_nextl `` A)", "using language_eq_nextl"], ["proof (prove)\nusing this:\n  language = eq_nextl `` \\<Union> (left_lang ` final M)\n\ngoal (1 subgoal):\n 1. equiv UNIV eq_nextl \\<and>\n    right_invariant eq_nextl \\<and>\n    finite (UNIV // eq_nextl) \\<and> (\\<exists>A. language = eq_nextl `` A)", "by (blast intro: equiv_eq_nextl right_invariant_eq_nextl finite_index_eq_nextl)"], ["", "corollary eq_nextl_refines_eq_app_right: \"eq_nextl \\<subseteq> eq_app_right language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_nextl \\<subseteq> eq_app_right language", "by (simp add: MN_eq_nextl MN_refines_eq_app_right)"], ["", "lemma index_le_index_eq_nextl:\n       \"card (UNIV // eq_app_right language) \\<le> card (UNIV // eq_nextl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (UNIV // eq_app_right language) \\<le> card (UNIV // eq_nextl)", "by (metis finite_refines_card_le finite_index_eq_nextl equiv_eq_nextl equiv_eq_app_right\n              eq_nextl_refines_eq_app_right)"], ["", "text\\<open>A specific lower bound on the number of states in a DFA\\<close>"], ["", "lemma index_eq_app_right_lower:\n       \"card (UNIV // eq_app_right language) \\<le> card (states M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (UNIV // eq_app_right language) \\<le> card (states M)", "using index_eq_nextl_le_states index_le_index_eq_nextl order_trans"], ["proof (prove)\nusing this:\n  card (UNIV // eq_nextl) \\<le> card (states M)\n  card (UNIV // eq_app_right language) \\<le> card (UNIV // eq_nextl)\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. card (UNIV // eq_app_right language) \\<le> card (states M)", "by blast"], ["", "end"], ["", "lemma L1_2: \"regular L \\<Longrightarrow> \\<exists>R. MyhillNerode L R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular L \\<Longrightarrow> \\<exists>R. MyhillNerode L R", "by (metis dfa.MN_eq_nextl regular_def)"], ["", "text\\<open>Step 2: every Myhill-Nerode relation @{term R} for the language @{term L}\n  can be mapped to the canonical M-N relation.\\<close>"], ["", "lemma L2_3:\n  assumes \"MyhillNerode L R\"\n  obtains \"finite (UNIV // eq_app_right L)\"\n          \"card (UNIV // eq_app_right L) \\<le> card (UNIV // R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>finite (UNIV // eq_app_right L);\n      card (UNIV // eq_app_right L) \\<le> card (UNIV // R)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson assms MN_refines_eq_app_right MyhillNerode_def equiv_eq_app_right finite_refines_finite finite_refines_card_le)"], ["", "text \\<open>Working towards step 3.  Also, every Myhill-Nerode relation @{term R} for @{term L}\n  can be mapped to a machine. The locale below constructs such a DFA.\\<close>"], ["", "locale MyhillNerode_dfa =\n  fixes L :: \"'a list set\" and R :: \"('a list * 'a list) set\"\n    and A :: \"'a list set\" and n :: nat and h :: \"'a list set \\<Rightarrow> hf\"\n  assumes eqR: \"equiv UNIV R\"\n      and riR: \"right_invariant R\"\n      and L:   \"L = R``A\"\n      and h:   \"bij_betw h (UNIV//R) (hfset (ord_of n))\"\nbegin"], ["", "lemma injh: \"inj_on h (UNIV//R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on h (UNIV // R)", "using h bij_betw_imp_inj_on"], ["proof (prove)\nusing this:\n  bij_betw h (UNIV // R) (hfset (ord_of n))\n  bij_betw ?f ?A ?B \\<Longrightarrow> inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. inj_on h (UNIV // R)", "by blast"], ["", "definition hinv (\"h\\<^sup>-\\<^sup>1\") where \"h\\<^sup>-\\<^sup>1 \\<equiv> inv_into (UNIV//R) h\""], ["", "lemma finix: \"finite (UNIV//R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UNIV // R)", "using h bij_betw_finite finite_hfset"], ["proof (prove)\nusing this:\n  bij_betw h (UNIV // R) (hfset (ord_of n))\n  bij_betw ?f ?A ?B \\<Longrightarrow> finite ?A = finite ?B\n  finite (hfset ?a)\n\ngoal (1 subgoal):\n 1. finite (UNIV // R)", "by blast"], ["", "definition DFA :: \"'a dfa\" where\n    \"DFA = \\<lparr>states = h ` (UNIV//R),\n            init  = h (R `` {[]}),\n            final = {h (R `` {u}) | u. u \\<in> A},\n            nxt   = \\<lambda>q x. h (\\<Union>u \\<in> h\\<^sup>-\\<^sup>1 q. R `` {u@[x]})\\<rparr>\""], ["", "lemma resp: \"\\<And>x. (\\<lambda>u. R `` {u @ [x]}) respects R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<lambda>u. R `` {u @ [x]}) respects R", "using riR"], ["proof (prove)\nusing this:\n  right_invariant R\n\ngoal (1 subgoal):\n 1. \\<And>x. (\\<lambda>u. R `` {u @ [x]}) respects R", "by (auto simp: congruent_def right_invariant_def intro!: equiv_class_eq [OF eqR])"], ["", "lemma dfa: \"dfa DFA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa DFA", "apply (auto simp: dfa_def DFA_def quotientI finix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       x \\<in> UNIV // R \\<Longrightarrow>\n       h (\\<Union>u\\<in>h\\<^sup>-\\<^sup>1 (h x). R `` {u @ [xa]})\n       \\<in> h ` UNIV // R", "apply (subst inj_on_image_mem_iff [OF injh])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       x \\<in> UNIV // R \\<Longrightarrow>\n       (\\<Union>u\\<in>h\\<^sup>-\\<^sup>1 (h x). R `` {u @ [xa]})\n       \\<in> UNIV // R\n 2. \\<And>x xa.\n       x \\<in> UNIV // R \\<Longrightarrow> UNIV // R \\<subseteq> UNIV // R", "apply (rule UN_equiv_class_type [OF eqR resp])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       x \\<in> UNIV // R \\<Longrightarrow>\n       h\\<^sup>-\\<^sup>1 (h x) \\<in> UNIV // R\n 2. \\<And>x xa u.\n       \\<lbrakk>x \\<in> UNIV // R; u \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> R `` {u @ [xa]} \\<in> UNIV // R\n 3. \\<And>x xa.\n       x \\<in> UNIV // R \\<Longrightarrow> UNIV // R \\<subseteq> UNIV // R", "apply (auto simp: injh DFA_def hinv_def quotientI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation MN: dfa DFA"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa DFA", "by (simp add: dfa)"], ["", "lemma MyhillNerode: \"MyhillNerode L R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MyhillNerode L R", "using L"], ["proof (prove)\nusing this:\n  L = R `` A\n\ngoal (1 subgoal):\n 1. MyhillNerode L R", "by (auto simp: MyhillNerode_def eqR riR finix)"], ["", "lemma R_iff: \"(\\<exists>x\\<in>L. (u, x) \\<in> R) = (u \\<in> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>L. (u, x) \\<in> R) = (u \\<in> L)", "using MN_refines MyhillNerode eqR eq_equiv_class_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>MyhillNerode ?L ?R; (?x, ?y) \\<in> ?R\\<rbrakk>\n  \\<Longrightarrow> (?x \\<in> ?L) = (?y \\<in> ?L)\n  MyhillNerode L R\n  equiv UNIV R\n  \\<lbrakk>equiv ?A ?r; ?x \\<in> ?A; ?y \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (?r `` {?x} = ?r `` {?y}) = ((?x, ?y) \\<in> ?r)\n\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>L. (u, x) \\<in> R) = (u \\<in> L)", "by fastforce"], ["", "lemma nextl: \"MN.nextl (init DFA) u = h (R `` {u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MN.nextl (init DFA) u = h (R `` {u})", "apply (induct u rule: List.rev_induct, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. init DFA = h (R `` {[]})\n 2. \\<And>x xs.\n       MN.nextl (init DFA) xs = h (R `` {xs}) \\<Longrightarrow>\n       nxt DFA (h (R `` {xs})) x = h (R `` {xs @ [x]})", "apply (simp_all add: DFA_def hinv_def injh quotientI UN_equiv_class [OF eqR resp])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma language: \"MN.language = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MN.language = L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MN.language = L", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. MN.language = L", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. MN.language = L", "have \"u \\<in> MN.language \\<longleftrightarrow> u \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<in> MN.language) = (u \\<in> L)", "using L eqR"], ["proof (prove)\nusing this:\n  L = R `` A\n  equiv UNIV R\n\ngoal (1 subgoal):\n 1. (u \\<in> MN.language) = (u \\<in> L)", "apply (simp add: MN.language_def nextl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L = R `` A; equiv UNIV R\\<rbrakk>\n    \\<Longrightarrow> (h (R `` {u}) \\<in> final DFA) = (u \\<in> R `` A)", "apply (simp add: DFA_def inj_on_eq_iff [OF injh] eq_equiv_class_iff [OF eqR] quotientI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L = R `` A; equiv UNIV R\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ua. (u, ua) \\<in> R \\<and> ua \\<in> A) =\n                      (u \\<in> R `` A)", "apply (auto simp: equiv_def sym_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (u \\<in> MN.language) = (u \\<in> L)\n\ngoal (1 subgoal):\n 1. MN.language = L", "}"], ["proof (state)\nthis:\n  (?u2 \\<in> MN.language) = (?u2 \\<in> L)\n\ngoal (1 subgoal):\n 1. MN.language = L", "then"], ["proof (chain)\npicking this:\n  (?u2 \\<in> MN.language) = (?u2 \\<in> L)", "show ?thesis"], ["proof (prove)\nusing this:\n  (?u2 \\<in> MN.language) = (?u2 \\<in> L)\n\ngoal (1 subgoal):\n 1. MN.language = L", "by blast"], ["proof (state)\nthis:\n  MN.language = L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_states: \"card (states DFA) = card (UNIV // R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (states DFA) = card (UNIV // R)", "using h"], ["proof (prove)\nusing this:\n  bij_betw h (UNIV // R) (hfset (ord_of n))\n\ngoal (1 subgoal):\n 1. card (states DFA) = card (UNIV // R)", "by (simp add: DFA_def bij_betw_def) (metis card_image)"], ["", "end"], ["", "theorem MN_imp_dfa:\n  assumes \"MyhillNerode L R\"\n  obtains M where \"dfa M\" \"dfa.language M = L\" \"card (states M) = card (UNIV//R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>dfa M; dfa.language M = L;\n         card (states M) = card (UNIV // R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>dfa M; dfa.language M = L;\n         card (states M) = card (UNIV // R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  MyhillNerode L R", "obtain A\n    where eqR: \"equiv UNIV R\"\n      and riR: \"right_invariant R\"\n      and finix: \"finite (UNIV//R)\"\n      and L: \"L = R``A\""], ["proof (prove)\nusing this:\n  MyhillNerode L R\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>equiv UNIV R; right_invariant R; finite (UNIV // R);\n         L = R `` A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: MyhillNerode_def)"], ["proof (state)\nthis:\n  equiv UNIV R\n  right_invariant R\n  finite (UNIV // R)\n  L = R `` A\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>dfa M; dfa.language M = L;\n         card (states M) = card (UNIV // R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?n = \"card (UNIV//R)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>dfa M; dfa.language M = L;\n         card (states M) = card (UNIV // R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ex_bij_betw_finite_nat [OF finix]"], ["proof (chain)\npicking this:\n  \\<exists>h. bij_betw h (UNIV // R) {0..<card (UNIV // R)}", "obtain h where h: \"bij_betw h (UNIV//R) (hfset (ord_of ?n))\""], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h (UNIV // R) {0..<card (UNIV // R)}\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        bij_betw h (UNIV // R)\n         (hfset (ord_of (card (UNIV // R)))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using bij_betw_ord_ofI"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h (UNIV // R) {0..<card (UNIV // R)}\n  bij_betw ?h ?A {0..<?n} \\<Longrightarrow>\n  bij_betw (ord_of \\<circ> ?h) ?A (hfset (ord_of ?n))\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        bij_betw h (UNIV // R)\n         (hfset (ord_of (card (UNIV // R)))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bij_betw h (UNIV // R) (hfset (ord_of (card (UNIV // R))))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>dfa M; dfa.language M = L;\n         card (states M) = card (UNIV // R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "interpret MN: MyhillNerode_dfa L R A \"?n\" h"], ["proof (prove)\ngoal (1 subgoal):\n 1. MyhillNerode_dfa L R A (card (UNIV // R)) h", "by (simp add: MyhillNerode_dfa_def eqR riR L h)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>dfa M; dfa.language M = L;\n         card (states M) = card (UNIV // R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: MN.language intro: that MN.dfa MN.language MN.card_states)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary MN_imp_regular:\n  assumes \"MyhillNerode L R\"  shows \"regular L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular L", "using MN_imp_dfa [OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>M.\n      \\<lbrakk>dfa M; dfa.language M = L;\n       card (states M) = card (UNIV // R)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. regular L", "unfolding regular_def"], ["proof (prove)\nusing this:\n  (\\<And>M.\n      \\<lbrakk>dfa M; dfa.language M = L;\n       card (states M) = card (UNIV // R)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>M. dfa M \\<and> dfa.language M = L", "by auto"], ["", "corollary eq_app_right_finite_index_imp_dfa:\n  assumes \"finite (UNIV // eq_app_right L)\"\n  obtains M where\n    \"dfa M\" \"dfa.language M = L\" \"card (states M) = card (UNIV // eq_app_right L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>dfa M; dfa.language M = L;\n         card (states M) = card (UNIV // eq_app_right L)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using MN_eq_app_right MN_imp_dfa assms"], ["proof (prove)\nusing this:\n  finite (UNIV // eq_app_right ?L) \\<Longrightarrow>\n  MyhillNerode ?L (eq_app_right ?L)\n  \\<lbrakk>MyhillNerode ?L ?R;\n   \\<And>M.\n      \\<lbrakk>dfa M; dfa.language M = ?L;\n       card (states M) = card (UNIV // ?R)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  finite (UNIV // eq_app_right L)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>dfa M; dfa.language M = L;\n         card (states M) = card (UNIV // eq_app_right L)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "text\\<open>Step 3\\<close>"], ["", "corollary L3_1: \"finite (UNIV // eq_app_right L) \\<Longrightarrow> regular L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UNIV // eq_app_right L) \\<Longrightarrow> regular L", "using eq_app_right_finite_index_imp_dfa regular_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (UNIV // eq_app_right ?L);\n   \\<And>M.\n      \\<lbrakk>dfa M; dfa.language M = ?L;\n       card (states M) = card (UNIV // eq_app_right ?L)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  regular ?L \\<equiv> \\<exists>M. dfa M \\<and> dfa.language M = ?L\n\ngoal (1 subgoal):\n 1. finite (UNIV // eq_app_right L) \\<Longrightarrow> regular L", "by blast"], ["", "section\\<open>Non-Deterministic Finite Automata\\<close>"], ["", "text\\<open>These NFAs may include epsilon-transitions and multiple start states.\\<close>"], ["", "subsection\\<open>Basic Definitions\\<close>"], ["", "record 'a nfa = states :: \"hf set\"\n                init   :: \"hf set\"\n                final  :: \"hf set\"\n                nxt    :: \"hf \\<Rightarrow> 'a \\<Rightarrow> hf set\"\n                eps    :: \"(hf * hf) set\""], ["", "locale nfa =\n  fixes M :: \"'a nfa\"\n  assumes init: \"init M \\<subseteq> states M\"\n      and final: \"final M \\<subseteq> states M\"\n      and nxt:   \"\\<And>q x. q \\<in> states M \\<Longrightarrow> nxt M q x \\<subseteq> states M\"\n      and finite: \"finite (states M)\"\nbegin"], ["", "lemma subset_states_finite [intro,simp]: \"Q \\<subseteq> states M \\<Longrightarrow> finite Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<subseteq> nfa.states M \\<Longrightarrow> finite Q", "by (simp add: finite_subset finite)"], ["", "definition epsclo :: \"hf set \\<Rightarrow> hf set\" where\n  \"epsclo Q \\<equiv> states M \\<inter> (\\<Union>q\\<in>Q. {q'. (q,q') \\<in> (eps M)\\<^sup>*})\""], ["", "lemma epsclo_eq_Image: \"epsclo Q = states M \\<inter> (eps M)\\<^sup>* `` Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epsclo Q = nfa.states M \\<inter> (eps M)\\<^sup>* `` Q", "by (auto simp: epsclo_def)"], ["", "lemma epsclo_empty [simp]: \"epsclo {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epsclo {} = {}", "by (auto simp: epsclo_def)"], ["", "lemma epsclo_idem [simp]: \"epsclo (epsclo Q) = epsclo Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epsclo (epsclo Q) = epsclo Q", "by (auto simp: epsclo_def)"], ["", "lemma epsclo_increasing: \"Q \\<inter> states M \\<subseteq> epsclo Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<inter> nfa.states M \\<subseteq> epsclo Q", "by (auto simp: epsclo_def)"], ["", "lemma epsclo_Un [simp]: \"epsclo (Q1 \\<union> Q2) = epsclo Q1 \\<union> epsclo Q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epsclo (Q1 \\<union> Q2) = epsclo Q1 \\<union> epsclo Q2", "by (auto simp: epsclo_def)"], ["", "lemma epsclo_UN [simp]: \"epsclo (\\<Union>x\\<in>A. B x) = (\\<Union>x\\<in>A. epsclo (B x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epsclo (\\<Union> (B ` A)) = (\\<Union>x\\<in>A. epsclo (B x))", "by (auto simp: epsclo_def)"], ["", "lemma epsclo_subset [simp]: \"epsclo Q \\<subseteq> states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epsclo Q \\<subseteq> nfa.states M", "by (auto simp: epsclo_def)"], ["", "lemma epsclo_trivial [simp]: \"eps M \\<subseteq> Q \\<times> Q \\<Longrightarrow> epsclo Q = states M \\<inter> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eps M \\<subseteq> Q \\<times> Q \\<Longrightarrow>\n    epsclo Q = nfa.states M \\<inter> Q", "by (auto simp: epsclo_def elim: rtranclE)"], ["", "lemma epsclo_mono: \"Q' \\<subseteq> Q \\<Longrightarrow> epsclo Q' \\<subseteq> epsclo Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q' \\<subseteq> Q \\<Longrightarrow> epsclo Q' \\<subseteq> epsclo Q", "by (auto simp: epsclo_def)"], ["", "lemma finite_epsclo [simp]: \"finite (epsclo Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (epsclo Q)", "using epsclo_subset finite_subset finite"], ["proof (prove)\nusing this:\n  epsclo ?Q \\<subseteq> nfa.states M\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  finite (nfa.states M)\n\ngoal (1 subgoal):\n 1. finite (epsclo Q)", "by blast"], ["", "lemma finite_final: \"finite (final M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nfa.final M)", "using final finite_subset finite"], ["proof (prove)\nusing this:\n  nfa.final M \\<subseteq> nfa.states M\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  finite (nfa.states M)\n\ngoal (1 subgoal):\n 1. finite (nfa.final M)", "by blast"], ["", "lemma finite_nxt: \"q \\<in> states M \\<Longrightarrow> finite (nxt M q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> nfa.states M \\<Longrightarrow> finite (nfa.nxt M q x)", "by (metis finite_subset finite nxt)"], ["", "text\\<open>Transition function for a given starting state and word.\\<close>"], ["", "primrec nextl :: \"[hf set, 'a list] \\<Rightarrow> hf set\" where\n    \"nextl Q []     = epsclo Q\"\n  | \"nextl Q (x#xs) = nextl (\\<Union>q \\<in> epsclo Q. nxt M q x) xs\""], ["", "definition language :: \"'a list set\"  where\n  \"language \\<equiv> {xs. nextl (init M) xs \\<inter> final M \\<noteq> {}}\""], ["", "text\\<open>The right language WRT a state q is the set of words that go from q to F.\\<close>"], ["", "definition right_lang :: \"hf \\<Rightarrow> 'a list set\"  where\n  \"right_lang q \\<equiv> {u. nextl {q} u \\<inter> final M \\<noteq> {}}\""], ["", "lemma nextl_epsclo [simp]: \"nextl (epsclo Q) xs = nextl Q xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextl (epsclo Q) xs = nextl Q xs", "by (induct xs) auto"], ["", "lemma epsclo_nextl [simp]: \"epsclo (nextl Q xs) = nextl Q xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epsclo (nextl Q xs) = nextl Q xs", "by (induct xs arbitrary: Q) auto"], ["", "lemma nextl_app: \"nextl Q (xs@ys) = nextl (nextl Q xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextl Q (xs @ ys) = nextl (nextl Q xs) ys", "by (induct xs arbitrary: Q) auto"], ["", "lemma nextl_snoc [simp]: \"nextl Q (xs@[x]) = (\\<Union>q \\<in> nextl Q xs. epsclo (nxt M q x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextl Q (xs @ [x]) = (\\<Union>q\\<in>nextl Q xs. epsclo (nfa.nxt M q x))", "by (simp add: nextl_app)"], ["", "lemma nextl_state: \"nextl Q xs \\<subseteq> states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextl Q xs \\<subseteq> nfa.states M", "by (induct xs arbitrary: Q) auto"], ["", "lemma nextl_mono: \"Q' \\<subseteq> Q \\<Longrightarrow> nextl Q' u \\<subseteq> nextl Q u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q' \\<subseteq> Q \\<Longrightarrow> nextl Q' u \\<subseteq> nextl Q u", "by (induct u rule: rev_induct) (auto simp: epsclo_mono)"], ["", "lemma nextl_eps: \"q \\<in> nextl Q u \\<Longrightarrow> (q,q') \\<in> eps M \\<Longrightarrow> q' \\<in> states M \\<Longrightarrow> q' \\<in> nextl Q u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> nextl Q u; (q, q') \\<in> eps M;\n     q' \\<in> nfa.states M\\<rbrakk>\n    \\<Longrightarrow> q' \\<in> nextl Q u", "using rtrancl_into_rtrancl epsclo_nextl epsclo_eq_Image"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b) \\<in> ?r\\<^sup>*; (?b, ?c) \\<in> ?r\\<rbrakk>\n  \\<Longrightarrow> (?a, ?c) \\<in> ?r\\<^sup>*\n  epsclo (nextl ?Q ?xs) = nextl ?Q ?xs\n  epsclo ?Q = nfa.states M \\<inter> (eps M)\\<^sup>* `` ?Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> nextl Q u; (q, q') \\<in> eps M;\n     q' \\<in> nfa.states M\\<rbrakk>\n    \\<Longrightarrow> q' \\<in> nextl Q u", "by fastforce"], ["", "lemma finite_nextl: \"finite (nextl Q u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nextl Q u)", "by (induct u rule: List.rev_induct) auto"], ["", "lemma nextl_empty [simp]: \"nextl {} xs = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextl {} xs = {}", "by (induct xs) auto"], ["", "lemma nextl_Un: \"nextl (Q1 \\<union> Q2) xs = nextl Q1 xs \\<union> nextl Q2 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextl (Q1 \\<union> Q2) xs = nextl Q1 xs \\<union> nextl Q2 xs", "by (induct xs arbitrary: Q1 Q2) auto"], ["", "lemma nextl_UN: \"nextl (\\<Union>i\\<in>I. f i) xs = (\\<Union>i\\<in>I. nextl (f i) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextl (\\<Union> (f ` I)) xs = (\\<Union>i\\<in>I. nextl (f i) xs)", "by (induct xs arbitrary: f) auto"], ["", "subsection\\<open>The Powerset Construction\\<close>"], ["", "definition Power_dfa :: \"'a dfa\" where\n  \"Power_dfa = \\<lparr>dfa.states = {HF (epsclo q) | q. q \\<in> Pow (states M)},\n                     init  = HF (epsclo (init M)),\n                     final = {HF (epsclo Q) | Q. Q \\<subseteq> states M \\<and> Q \\<inter> final M \\<noteq> {}},\n                     nxt   = \\<lambda>Q x. HF(\\<Union>q \\<in> epsclo (hfset Q). epsclo (nxt M q x))\\<rparr>\""], ["", "lemma states_Power_dfa [simp]: \"dfa.states Power_dfa = HF ` epsclo ` Pow (states M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.states Power_dfa = HF ` epsclo ` Pow (nfa.states M)", "by (auto simp add: Power_dfa_def)"], ["", "lemma init_Power_dfa [simp]: \"dfa.init Power_dfa = HF (epsclo (nfa.init M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.init Power_dfa = HF (epsclo (nfa.init M))", "by (simp add: Power_dfa_def)"], ["", "lemma final_Power_dfa [simp]: \"dfa.final Power_dfa = {HF (epsclo Q) | Q. Q \\<subseteq> states M \\<and> Q \\<inter> final M \\<noteq> {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.final Power_dfa =\n    {HF (epsclo Q) |Q.\n     Q \\<subseteq> nfa.states M \\<and> Q \\<inter> nfa.final M \\<noteq> {}}", "by (simp add: Power_dfa_def)"], ["", "lemma nxt_Power_dfa [simp]: \"dfa.nxt Power_dfa = (\\<lambda>Q x. HF(\\<Union>q \\<in> epsclo (hfset Q). epsclo (nxt M q x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.nxt Power_dfa =\n    (\\<lambda>Q x.\n        HF (\\<Union>q\\<in>epsclo (hfset Q). epsclo (nfa.nxt M q x)))", "by (simp add: Power_dfa_def)"], ["", "interpretation Power: dfa Power_dfa"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa Power_dfa", "proof unfold_locales"], ["proof (state)\ngoal (4 subgoals):\n 1. dfa.init Power_dfa \\<in> dfa.states Power_dfa\n 2. dfa.final Power_dfa \\<subseteq> dfa.states Power_dfa\n 3. \\<And>q x.\n       q \\<in> dfa.states Power_dfa \\<Longrightarrow>\n       dfa.nxt Power_dfa q x \\<in> dfa.states Power_dfa\n 4. finite (dfa.states Power_dfa)", "show \"dfa.init Power_dfa \\<in> dfa.states Power_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.init Power_dfa \\<in> dfa.states Power_dfa", "by (force simp add: init)"], ["proof (state)\nthis:\n  dfa.init Power_dfa \\<in> dfa.states Power_dfa\n\ngoal (3 subgoals):\n 1. dfa.final Power_dfa \\<subseteq> dfa.states Power_dfa\n 2. \\<And>q x.\n       q \\<in> dfa.states Power_dfa \\<Longrightarrow>\n       dfa.nxt Power_dfa q x \\<in> dfa.states Power_dfa\n 3. finite (dfa.states Power_dfa)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. dfa.final Power_dfa \\<subseteq> dfa.states Power_dfa\n 2. \\<And>q x.\n       q \\<in> dfa.states Power_dfa \\<Longrightarrow>\n       dfa.nxt Power_dfa q x \\<in> dfa.states Power_dfa\n 3. finite (dfa.states Power_dfa)", "show \"dfa.final Power_dfa \\<subseteq> dfa.states Power_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.final Power_dfa \\<subseteq> dfa.states Power_dfa", "by auto"], ["proof (state)\nthis:\n  dfa.final Power_dfa \\<subseteq> dfa.states Power_dfa\n\ngoal (2 subgoals):\n 1. \\<And>q x.\n       q \\<in> dfa.states Power_dfa \\<Longrightarrow>\n       dfa.nxt Power_dfa q x \\<in> dfa.states Power_dfa\n 2. finite (dfa.states Power_dfa)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       q \\<in> dfa.states Power_dfa \\<Longrightarrow>\n       dfa.nxt Power_dfa q x \\<in> dfa.states Power_dfa\n 2. finite (dfa.states Power_dfa)", "fix q a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       q \\<in> dfa.states Power_dfa \\<Longrightarrow>\n       dfa.nxt Power_dfa q x \\<in> dfa.states Power_dfa\n 2. finite (dfa.states Power_dfa)", "show \"q \\<in> dfa.states Power_dfa \\<Longrightarrow> dfa.nxt Power_dfa q a \\<in> dfa.states Power_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> dfa.states Power_dfa \\<Longrightarrow>\n    dfa.nxt Power_dfa q a \\<in> dfa.states Power_dfa", "apply (auto simp: nxt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>q = HF (epsclo xa); xa \\<subseteq> nfa.states M\\<rbrakk>\n       \\<Longrightarrow> HF (\\<Union>x\\<in>epsclo xa.\n                                epsclo (nfa.nxt M x a))\n                         \\<in> HF ` epsclo ` Pow (nfa.states M)", "apply (subst inj_on_image_mem_iff [OF inj_on_HF])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>q = HF (epsclo xa); xa \\<subseteq> nfa.states M\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>x\\<in>epsclo xa. epsclo (nfa.nxt M x a))\n                         \\<in> Collect finite\n 2. \\<And>xa.\n       \\<lbrakk>q = HF (epsclo xa); xa \\<subseteq> nfa.states M\\<rbrakk>\n       \\<Longrightarrow> epsclo ` Pow (nfa.states M)\n                         \\<subseteq> Collect finite\n 3. \\<And>xa.\n       \\<lbrakk>q = HF (epsclo xa); xa \\<subseteq> nfa.states M\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>x\\<in>epsclo xa. epsclo (nfa.nxt M x a))\n                         \\<in> epsclo ` Pow (nfa.states M)", "apply (auto simp: rev_finite_subset [OF finite] nxt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>q = HF (epsclo xa); xa \\<subseteq> nfa.states M\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>x\\<in>epsclo xa. epsclo (nfa.nxt M x a))\n                         \\<in> epsclo ` Pow (nfa.states M)", "apply (metis Pow_iff epsclo_UN epsclo_idem epsclo_subset image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  q \\<in> dfa.states Power_dfa \\<Longrightarrow>\n  dfa.nxt Power_dfa q a \\<in> dfa.states Power_dfa\n\ngoal (1 subgoal):\n 1. finite (dfa.states Power_dfa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (dfa.states Power_dfa)", "show \"finite (dfa.states Power_dfa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dfa.states Power_dfa)", "by (force simp: finite)"], ["proof (state)\nthis:\n  finite (dfa.states Power_dfa)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary dfa_Power: \"dfa Power_dfa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa Power_dfa", "by unfold_locales"], ["", "lemma nextl_Power_dfa:\n     \"qs \\<in> dfa.states Power_dfa\n     \\<Longrightarrow> dfa.nextl Power_dfa qs u = HF (\\<Union>q \\<in> hfset qs. nextl {q} u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> dfa.states Power_dfa \\<Longrightarrow>\n    Power.nextl qs u = HF (\\<Union>q\\<in>hfset qs. nextl {q} u)", "apply (induct u rule: List.rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. qs \\<in> dfa.states Power_dfa \\<Longrightarrow>\n    Power.nextl qs [] = HF (\\<Union>q\\<in>hfset qs. nextl {q} [])\n 2. \\<And>x xs.\n       \\<lbrakk>qs \\<in> dfa.states Power_dfa \\<Longrightarrow>\n                Power.nextl qs xs =\n                HF (\\<Union>q\\<in>hfset qs. nextl {q} xs);\n        qs \\<in> dfa.states Power_dfa\\<rbrakk>\n       \\<Longrightarrow> Power.nextl qs (xs @ [x]) =\n                         HF (\\<Union>q\\<in>hfset qs. nextl {q} (xs @ [x]))", "apply (auto simp: finite_nextl inj_on_HF [THEN inj_on_eq_iff])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa x.\n       \\<lbrakk>qs = HF (epsclo xa); xa \\<subseteq> nfa.states M;\n        x \\<in> epsclo xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>epsclo xa. x \\<in> epsclo {xa}\n 2. \\<And>xa x xb.\n       \\<lbrakk>qs = HF (epsclo xa); xa \\<subseteq> nfa.states M;\n        xb \\<in> epsclo xa; x \\<in> epsclo {xb}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> epsclo xa", "apply (metis Int_empty_left Int_insert_left_if1 epsclo_increasing epsclo_subset subsetD singletonI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x xb.\n       \\<lbrakk>qs = HF (epsclo xa); xa \\<subseteq> nfa.states M;\n        xb \\<in> epsclo xa; x \\<in> epsclo {xb}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> epsclo xa", "apply (metis contra_subsetD empty_subsetI epsclo_idem epsclo_mono insert_subset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Part of Prop 4 of Jean-Marc Champarnaud, A. Khorsi and T. Parantho?n (2002)\\<close>"], ["", "lemma Power_right_lang:\n     \"qs \\<in> dfa.states Power_dfa \\<Longrightarrow> Power.right_lang qs = (\\<Union>q \\<in> hfset qs. right_lang q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs \\<in> dfa.states Power_dfa \\<Longrightarrow>\n    Power.right_lang qs = \\<Union> (right_lang ` hfset qs)", "using epsclo_increasing"], ["proof (prove)\nusing this:\n  ?Q \\<inter> nfa.states M \\<subseteq> epsclo ?Q\n\ngoal (1 subgoal):\n 1. qs \\<in> dfa.states Power_dfa \\<Longrightarrow>\n    Power.right_lang qs = \\<Union> (right_lang ` hfset qs)", "apply (auto simp: Power.right_lang_def right_lang_def nextl_Power_dfa\n                  inj_on_HF [THEN inj_on_eq_iff] finite_nextl, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>\\<And>Q. Q \\<inter> nfa.states M \\<subseteq> epsclo Q;\n        qs = HF (epsclo xa); xa \\<subseteq> nfa.states M;\n        xc \\<in> epsclo xa;\n        \\<forall>Q\\<subseteq>nfa.states M.\n           (\\<Union>x\\<in>epsclo xa. nextl {x} xb) =\n           epsclo Q \\<longrightarrow>\n           Q \\<inter> nfa.final M = {};\n        xd \\<in> nextl {xc} xb; xd \\<in> nfa.final M\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac Q u q1 q2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Q u q1 q2.\n       \\<lbrakk>\\<And>Q. Q \\<inter> nfa.states M \\<subseteq> epsclo Q;\n        qs = HF (epsclo Q); Q \\<subseteq> nfa.states M; q1 \\<in> epsclo Q;\n        \\<forall>Qa\\<subseteq>nfa.states M.\n           (\\<Union>x\\<in>epsclo Q. nextl {x} u) =\n           epsclo Qa \\<longrightarrow>\n           Qa \\<inter> nfa.final M = {};\n        q2 \\<in> nextl {q1} u; q2 \\<in> nfa.final M\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x=\"(\\<Union>x\\<in>epsclo Q. nextl {x} u)\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Q u q1 q2.\n       \\<lbrakk>\\<And>Q. Q \\<inter> nfa.states M \\<subseteq> epsclo Q;\n        qs = HF (epsclo Q); Q \\<subseteq> nfa.states M; q1 \\<in> epsclo Q;\n        q2 \\<in> nextl {q1} u; q2 \\<in> nfa.final M;\n        (\\<Union>x\\<in>epsclo Q. nextl {x} u)\n        \\<subseteq> nfa.states M \\<longrightarrow>\n        (\\<Union>x\\<in>epsclo Q. nextl {x} u) =\n        epsclo (\\<Union>x\\<in>epsclo Q. nextl {x} u) \\<longrightarrow>\n        (\\<Union>x\\<in>epsclo Q. nextl {x} u) \\<inter> nfa.final M =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Q u q1 q2 x xa.\n       \\<lbrakk>\\<And>Q. Q \\<inter> nfa.states M \\<subseteq> epsclo Q;\n        qs = HF (epsclo Q); Q \\<subseteq> nfa.states M; q1 \\<in> epsclo Q;\n        q2 \\<in> nextl {q1} u; q2 \\<in> nfa.final M; xa \\<in> epsclo Q;\n        x \\<in> nextl {xa} u\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nfa.states M", "using nextl_state"], ["proof (prove)\nusing this:\n  nextl ?Q ?xs \\<subseteq> nfa.states M\n\ngoal (1 subgoal):\n 1. \\<And>Q u q1 q2 x xa.\n       \\<lbrakk>\\<And>Q. Q \\<inter> nfa.states M \\<subseteq> epsclo Q;\n        qs = HF (epsclo Q); Q \\<subseteq> nfa.states M; q1 \\<in> epsclo Q;\n        q2 \\<in> nextl {q1} u; q2 \\<in> nfa.final M; xa \\<in> epsclo Q;\n        x \\<in> nextl {xa} u\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nfa.states M", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>The Power DFA accepts the same language as the NFA.\\<close>"], ["", "theorem Power_language [simp]: \"Power.language = language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Power.language = language", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Power.language = language", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Power.language = language", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. Power.language = language", "have \"(Power.nextl (dfa.init Power_dfa) u) = HF (nextl (init M) u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Power.nextl (dfa.init Power_dfa) u = HF (nextl (nfa.init M) u)", "proof (induct u rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. Power.nextl (dfa.init Power_dfa) [] = HF (nextl (nfa.init M) [])\n 2. \\<And>x xs.\n       Power.nextl (dfa.init Power_dfa) xs =\n       HF (nextl (nfa.init M) xs) \\<Longrightarrow>\n       Power.nextl (dfa.init Power_dfa) (xs @ [x]) =\n       HF (nextl (nfa.init M) (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Power.nextl (dfa.init Power_dfa) [] = HF (nextl (nfa.init M) [])\n 2. \\<And>x xs.\n       Power.nextl (dfa.init Power_dfa) xs =\n       HF (nextl (nfa.init M) xs) \\<Longrightarrow>\n       Power.nextl (dfa.init Power_dfa) (xs @ [x]) =\n       HF (nextl (nfa.init M) (xs @ [x]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Power.nextl (dfa.init Power_dfa) [] = HF (nextl (nfa.init M) [])", "using Power.nextl.simps"], ["proof (prove)\nusing this:\n  Power.nextl ?q [] = ?q\n  Power.nextl ?q (?x # ?xs) = Power.nextl (dfa.nxt Power_dfa ?q ?x) ?xs\n\ngoal (1 subgoal):\n 1. Power.nextl (dfa.init Power_dfa) [] = HF (nextl (nfa.init M) [])", "by (auto simp: hinsert_def)"], ["proof (state)\nthis:\n  Power.nextl (dfa.init Power_dfa) [] = HF (nextl (nfa.init M) [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Power.nextl (dfa.init Power_dfa) xs =\n       HF (nextl (nfa.init M) xs) \\<Longrightarrow>\n       Power.nextl (dfa.init Power_dfa) (xs @ [x]) =\n       HF (nextl (nfa.init M) (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Power.nextl (dfa.init Power_dfa) xs =\n       HF (nextl (nfa.init M) xs) \\<Longrightarrow>\n       Power.nextl (dfa.init Power_dfa) (xs @ [x]) =\n       HF (nextl (nfa.init M) (xs @ [x]))", "case (snoc x u)"], ["proof (state)\nthis:\n  Power.nextl (dfa.init Power_dfa) u = HF (nextl (nfa.init M) u)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       Power.nextl (dfa.init Power_dfa) xs =\n       HF (nextl (nfa.init M) xs) \\<Longrightarrow>\n       Power.nextl (dfa.init Power_dfa) (xs @ [x]) =\n       HF (nextl (nfa.init M) (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  Power.nextl (dfa.init Power_dfa) u = HF (nextl (nfa.init M) u)", "show ?case"], ["proof (prove)\nusing this:\n  Power.nextl (dfa.init Power_dfa) u = HF (nextl (nfa.init M) u)\n\ngoal (1 subgoal):\n 1. Power.nextl (dfa.init Power_dfa) (u @ [x]) =\n    HF (nextl (nfa.init M) (u @ [x]))", "by (simp add: init finite_nextl nextl_state [THEN subsetD])"], ["proof (state)\nthis:\n  Power.nextl (dfa.init Power_dfa) (u @ [x]) =\n  HF (nextl (nfa.init M) (u @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Power.nextl (dfa.init Power_dfa) u = HF (nextl (nfa.init M) u)\n\ngoal (1 subgoal):\n 1. Power.language = language", "then"], ["proof (chain)\npicking this:\n  Power.nextl (dfa.init Power_dfa) u = HF (nextl (nfa.init M) u)", "have \"u \\<in> Power.language \\<longleftrightarrow> u \\<in> language\""], ["proof (prove)\nusing this:\n  Power.nextl (dfa.init Power_dfa) u = HF (nextl (nfa.init M) u)\n\ngoal (1 subgoal):\n 1. (u \\<in> Power.language) = (u \\<in> language)", "apply (auto simp add: Power.language_def language_def disjoint_iff_not_equal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Q x.\n       \\<lbrakk>Power.nextl (HF (epsclo (nfa.init M))) u = HF (epsclo Q);\n        HF (nextl (nfa.init M) u) = HF (epsclo Q);\n        Q \\<subseteq> nfa.states M; x \\<in> Q; x \\<in> nfa.final M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>nextl (nfa.init M) u.\n                            x \\<in> nfa.final M\n 2. \\<And>x.\n       \\<lbrakk>Power.nextl (HF (epsclo (nfa.init M))) u =\n                HF (nextl (nfa.init M) u);\n        x \\<in> nextl (nfa.init M) u; x \\<in> nfa.final M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            HF (nextl (nfa.init M) u) = HF (epsclo Q) \\<and>\n                            Q \\<subseteq> nfa.states M \\<and>\n                            (\\<exists>x\\<in>Q. x \\<in> nfa.final M)", "apply (metis Int_iff finite_nextl hfset_HF nextl.simps(1) epsclo_increasing subsetCE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Power.nextl (HF (epsclo (nfa.init M))) u =\n                HF (nextl (nfa.init M) u);\n        x \\<in> nextl (nfa.init M) u; x \\<in> nfa.final M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q.\n                            HF (nextl (nfa.init M) u) = HF (epsclo Q) \\<and>\n                            Q \\<subseteq> nfa.states M \\<and>\n                            (\\<exists>x\\<in>Q. x \\<in> nfa.final M)", "apply (metis epsclo_nextl nextl_state)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (u \\<in> Power.language) = (u \\<in> language)\n\ngoal (1 subgoal):\n 1. Power.language = language", "}"], ["proof (state)\nthis:\n  (?u2 \\<in> Power.language) = (?u2 \\<in> language)\n\ngoal (1 subgoal):\n 1. Power.language = language", "then"], ["proof (chain)\npicking this:\n  (?u2 \\<in> Power.language) = (?u2 \\<in> language)", "show ?thesis"], ["proof (prove)\nusing this:\n  (?u2 \\<in> Power.language) = (?u2 \\<in> language)\n\ngoal (1 subgoal):\n 1. Power.language = language", "by blast"], ["proof (state)\nthis:\n  Power.language = language\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Every language accepted by a NFA is also accepted by a DFA.\\<close>"], ["", "corollary imp_regular: \"regular language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular language", "using Power_language dfa_Power regular_def"], ["proof (prove)\nusing this:\n  Power.language = language\n  dfa Power_dfa\n  regular ?L \\<equiv> \\<exists>M. dfa M \\<and> dfa.language M = ?L\n\ngoal (1 subgoal):\n 1. regular language", "by blast"], ["", "end"], ["", "text\\<open>As above, outside the locale\\<close>"], ["", "corollary nfa_imp_regular:\n  assumes \"nfa M\" \"nfa.language M = L\"\n    shows \"regular L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular L", "using assms nfa.imp_regular"], ["proof (prove)\nusing this:\n  nfa M\n  nfa.language M = L\n  nfa ?M \\<Longrightarrow> regular (nfa.language ?M)\n\ngoal (1 subgoal):\n 1. regular L", "by blast"], ["", "section\\<open>Closure Properties for Regular Languages\\<close>"], ["", "subsection\\<open>The Empty Language\\<close>"], ["", "theorem regular_empty:  \"regular {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular {}", "interpret D: dfa \"\\<lparr>dfa.states = {0}, init = 0, final = {}, nxt = \\<lambda>q x. q\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa \\<lparr>dfa.states = {0}, init = 0, final = {},\n           nxt = \\<lambda>q x. q\\<rparr>", "by (auto simp: dfa_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. regular {}", "have \"D.language = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.language = {}", "by (simp add: D.language_def)"], ["proof (state)\nthis:\n  D.language = {}\n\ngoal (1 subgoal):\n 1. regular {}", "then"], ["proof (chain)\npicking this:\n  D.language = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  D.language = {}\n\ngoal (1 subgoal):\n 1. regular {}", "unfolding regular_def dfa_def"], ["proof (prove)\nusing this:\n  D.language = {}\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       ((dfa.init M \\<in> dfa.states M \\<and>\n         dfa.final M \\<subseteq> dfa.states M) \\<and>\n        (\\<forall>q x.\n            q \\<in> dfa.states M \\<longrightarrow>\n            dfa.nxt M q x \\<in> dfa.states M) \\<and>\n        finite (dfa.states M)) \\<and>\n       dfa.language M = {}", "by force"], ["proof (state)\nthis:\n  regular {}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>The Empty Word\\<close>"], ["", "theorem regular_nullstr:  \"regular {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular {[]}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular {[]}", "interpret N: nfa \"\\<lparr>states = {0}, init = {0}, final = {0}, nxt = \\<lambda>q x. {}, eps = {} \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa \\<lparr>nfa.states = {0}, init = {0}, final = {0},\n           nxt = \\<lambda>q x. {}, eps = {}\\<rparr>", "by (auto simp: nfa_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. regular {[]}", "have \"\\<And>u. 0 \\<in> N.nextl {0} u \\<Longrightarrow> u = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. 0 \\<in> N.nextl {0} u \\<Longrightarrow> u = []", "by (rule list.exhaust, auto)"], ["proof (state)\nthis:\n  0 \\<in> N.nextl {0} ?u1 \\<Longrightarrow> ?u1 = []\n\ngoal (1 subgoal):\n 1. regular {[]}", "then"], ["proof (chain)\npicking this:\n  0 \\<in> N.nextl {0} ?u1 \\<Longrightarrow> ?u1 = []", "have \"N.language = {[]}\""], ["proof (prove)\nusing this:\n  0 \\<in> N.nextl {0} ?u1 \\<Longrightarrow> ?u1 = []\n\ngoal (1 subgoal):\n 1. N.language = {[]}", "by (auto simp: N.language_def)"], ["proof (state)\nthis:\n  N.language = {[]}\n\ngoal (1 subgoal):\n 1. regular {[]}", "then"], ["proof (chain)\npicking this:\n  N.language = {[]}", "show ?thesis"], ["proof (prove)\nusing this:\n  N.language = {[]}\n\ngoal (1 subgoal):\n 1. regular {[]}", "by (metis N.imp_regular)"], ["proof (state)\nthis:\n  regular {[]}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Single Symbol Languages\\<close>"], ["", "theorem regular_singstr: \"regular {[a]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular {[a]}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular {[a]}", "let ?N = \"\\<lparr>states = {0,1}, init = {0}, final = {1},\n             nxt = \\<lambda>q x. if q=0 \\<and> x=a then {1} else {},\n             eps = {}\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. regular {[a]}", "interpret N: nfa ?N"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa \\<lparr>nfa.states = {0, 1}, init = {0}, final = {1},\n           nxt = \\<lambda>q x. if q = 0 \\<and> x = a then {1} else {},\n           eps = {}\\<rparr>", "by (auto simp: nfa_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. regular {[a]}", "have [intro]: \"\\<And>u. 1 \\<in> N.nextl {1} u \\<Longrightarrow> u = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. 1 \\<in> N.nextl {1} u \\<Longrightarrow> u = []", "by (rule list.exhaust) auto"], ["proof (state)\nthis:\n  1 \\<in> N.nextl {1} ?u \\<Longrightarrow> ?u = []\n\ngoal (1 subgoal):\n 1. regular {[a]}", "{"], ["proof (state)\nthis:\n  1 \\<in> N.nextl {1} ?u \\<Longrightarrow> ?u = []\n\ngoal (1 subgoal):\n 1. regular {[a]}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. regular {[a]}", "have \"\\<lbrakk>1 \\<in> nfa.nextl ?N {0} u\\<rbrakk> \\<Longrightarrow> u = [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> N.nextl {0} u \\<Longrightarrow> u = [a]", "by (cases u) (auto split: if_split_asm)"], ["proof (state)\nthis:\n  1 \\<in> N.nextl {0} u \\<Longrightarrow> u = [a]\n\ngoal (1 subgoal):\n 1. regular {[a]}", "}"], ["proof (state)\nthis:\n  1 \\<in> N.nextl {0} ?u2 \\<Longrightarrow> ?u2 = [a]\n\ngoal (1 subgoal):\n 1. regular {[a]}", "then"], ["proof (chain)\npicking this:\n  1 \\<in> N.nextl {0} ?u2 \\<Longrightarrow> ?u2 = [a]", "have \"N.language = {[a]}\""], ["proof (prove)\nusing this:\n  1 \\<in> N.nextl {0} ?u2 \\<Longrightarrow> ?u2 = [a]\n\ngoal (1 subgoal):\n 1. N.language = {[a]}", "by (auto simp: N.language_def split: if_split_asm)"], ["proof (state)\nthis:\n  N.language = {[a]}\n\ngoal (1 subgoal):\n 1. regular {[a]}", "then"], ["proof (chain)\npicking this:\n  N.language = {[a]}", "show ?thesis"], ["proof (prove)\nusing this:\n  N.language = {[a]}\n\ngoal (1 subgoal):\n 1. regular {[a]}", "by (metis N.imp_regular)"], ["proof (state)\nthis:\n  regular {[a]}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>The Complement of a Language\\<close>"], ["", "theorem regular_Compl:\n  assumes S: \"regular S\" shows \"regular (-S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (- S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (- S)", "obtain MS  where M: \"dfa MS\" and lang: \"dfa.language MS = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>MS.\n        \\<lbrakk>dfa MS; dfa.language MS = S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using S"], ["proof (prove)\nusing this:\n  regular S\n\ngoal (1 subgoal):\n 1. (\\<And>MS.\n        \\<lbrakk>dfa MS; dfa.language MS = S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: regular_def)"], ["proof (state)\nthis:\n  dfa MS\n  dfa.language MS = S\n\ngoal (1 subgoal):\n 1. regular (- S)", "interpret ST: dfa \"\\<lparr>dfa.states= dfa.states MS,\n                     init= dfa.init MS, final= dfa.states MS - dfa.final MS,\n                     nxt= \\<lambda>q x. dfa.nxt MS q x\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa \\<lparr>dfa.states = dfa.states MS, init = dfa.init MS,\n           final = dfa.states MS - dfa.final MS, nxt = dfa.nxt MS\\<rparr>", "using M"], ["proof (prove)\nusing this:\n  dfa MS\n\ngoal (1 subgoal):\n 1. dfa \\<lparr>dfa.states = dfa.states MS, init = dfa.init MS,\n           final = dfa.states MS - dfa.final MS, nxt = dfa.nxt MS\\<rparr>", "by (force simp add: dfa_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (- S)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (- S)", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (- S)", "have \"ST.nextl (dfa.init MS) u = dfa.nextl MS (dfa.init MS) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ST.nextl (dfa.init MS) u = dfa.nextl MS (dfa.init MS) u", "by (induct u rule: List.rev_induct) (auto simp: dfa.nextl_snoc dfa.nextl.simps M)"], ["proof (state)\nthis:\n  ST.nextl (dfa.init MS) u = dfa.nextl MS (dfa.init MS) u\n\ngoal (1 subgoal):\n 1. regular (- S)", "then"], ["proof (chain)\npicking this:\n  ST.nextl (dfa.init MS) u = dfa.nextl MS (dfa.init MS) u", "have \"u \\<in> ST.language \\<longleftrightarrow> u \\<notin> dfa.language MS\""], ["proof (prove)\nusing this:\n  ST.nextl (dfa.init MS) u = dfa.nextl MS (dfa.init MS) u\n\ngoal (1 subgoal):\n 1. (u \\<in> ST.language) = (u \\<notin> dfa.language MS)", "by (auto simp: M dfa.nextl_init_state ST.language_def dfa.language_def)"], ["proof (state)\nthis:\n  (u \\<in> ST.language) = (u \\<notin> dfa.language MS)\n\ngoal (1 subgoal):\n 1. regular (- S)", "}"], ["proof (state)\nthis:\n  (?u2 \\<in> ST.language) = (?u2 \\<notin> dfa.language MS)\n\ngoal (1 subgoal):\n 1. regular (- S)", "then"], ["proof (chain)\npicking this:\n  (?u2 \\<in> ST.language) = (?u2 \\<notin> dfa.language MS)", "have eq_L: \"ST.language = -S\""], ["proof (prove)\nusing this:\n  (?u2 \\<in> ST.language) = (?u2 \\<notin> dfa.language MS)\n\ngoal (1 subgoal):\n 1. ST.language = - S", "using lang"], ["proof (prove)\nusing this:\n  (?u2 \\<in> ST.language) = (?u2 \\<notin> dfa.language MS)\n  dfa.language MS = S\n\ngoal (1 subgoal):\n 1. ST.language = - S", "by blast"], ["proof (state)\nthis:\n  ST.language = - S\n\ngoal (1 subgoal):\n 1. regular (- S)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (- S)", "unfolding regular_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M. dfa M \\<and> dfa.language M = - S", "by (intro exI conjI, unfold_locales) (rule eq_L)"], ["proof (state)\nthis:\n  regular (- S)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>The Intersection and Union of Two Languages\\<close>"], ["", "text\\<open>By the familiar product construction\\<close>"], ["", "theorem regular_Int:\n  assumes S: \"regular S\" and T: \"regular T\" shows \"regular (S \\<inter> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "obtain MS MT where M: \"dfa MS\" \"dfa MT\" and lang: \"dfa.language MS = S\" \"dfa.language MT = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>MS MT.\n        \\<lbrakk>dfa MS; dfa MT; dfa.language MS = S;\n         dfa.language MT = T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using S T"], ["proof (prove)\nusing this:\n  regular S\n  regular T\n\ngoal (1 subgoal):\n 1. (\\<And>MS MT.\n        \\<lbrakk>dfa MS; dfa MT; dfa.language MS = S;\n         dfa.language MT = T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: regular_def)"], ["proof (state)\nthis:\n  dfa MS\n  dfa MT\n  dfa.language MS = S\n  dfa.language MT = T\n\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "interpret ST: dfa \"\\<lparr>dfa.states = {\\<langle>q1,q2\\<rangle> | q1 q2. q1 \\<in> dfa.states MS \\<and> q2 \\<in> dfa.states MT},\n                     init       = \\<langle>dfa.init MS, dfa.init MT\\<rangle>,\n                     final      = {\\<langle>q1,q2\\<rangle> | q1 q2. q1 \\<in> dfa.final MS \\<and> q2 \\<in> dfa.final MT},\n                     nxt        = \\<lambda>\\<langle>qs,qt\\<rangle> x. \\<langle>dfa.nxt MS qs x, dfa.nxt MT qt x\\<rangle>\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa \\<lparr>dfa.states =\n                  {\\<langle>q1, q2\\<rangle> |q1 q2.\n                   q1 \\<in> dfa.states MS \\<and> q2 \\<in> dfa.states MT},\n           init = \\<langle>dfa.init MS, dfa.init MT\\<rangle>,\n           final =\n             {\\<langle>q1, q2\\<rangle> |q1 q2.\n              q1 \\<in> dfa.final MS \\<and> q2 \\<in> dfa.final MT},\n           nxt =\n             \\<lambda>\\<langle>qs, qt\\<rangle> x.\n                \\<langle>dfa.nxt MS qs x, dfa.nxt MT qt x\\<rangle>\\<rparr>", "using M"], ["proof (prove)\nusing this:\n  dfa MS\n  dfa MT\n\ngoal (1 subgoal):\n 1. dfa \\<lparr>dfa.states =\n                  {\\<langle>q1, q2\\<rangle> |q1 q2.\n                   q1 \\<in> dfa.states MS \\<and> q2 \\<in> dfa.states MT},\n           init = \\<langle>dfa.init MS, dfa.init MT\\<rangle>,\n           final =\n             {\\<langle>q1, q2\\<rangle> |q1 q2.\n              q1 \\<in> dfa.final MS \\<and> q2 \\<in> dfa.final MT},\n           nxt =\n             \\<lambda>\\<langle>qs, qt\\<rangle> x.\n                \\<langle>dfa.nxt MS qs x, dfa.nxt MT qt x\\<rangle>\\<rparr>", "by (auto simp: dfa_def finite_image_set2)"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "have \"ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> u =\n         \\<langle>dfa.nextl MS (dfa.init MS) u, dfa.nextl MT (dfa.init MT) u\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> u =\n    \\<langle>dfa.nextl MS (dfa.init MS) u,\n             dfa.nextl MT (dfa.init MT) u\\<rangle>", "proof (induct u rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> [] =\n    \\<langle>dfa.nextl MS (dfa.init MS) [],\n             dfa.nextl MT (dfa.init MT) []\\<rangle>\n 2. \\<And>x xs.\n       ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> xs =\n       \\<langle>dfa.nextl MS (dfa.init MS) xs,\n                dfa.nextl MT (dfa.init MT) xs\\<rangle> \\<Longrightarrow>\n       ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> (xs @ [x]) =\n       \\<langle>dfa.nextl MS (dfa.init MS) (xs @ [x]),\n                dfa.nextl MT (dfa.init MT) (xs @ [x])\\<rangle>", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> [] =\n    \\<langle>dfa.nextl MS (dfa.init MS) [],\n             dfa.nextl MT (dfa.init MT) []\\<rangle>\n 2. \\<And>x xs.\n       ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> xs =\n       \\<langle>dfa.nextl MS (dfa.init MS) xs,\n                dfa.nextl MT (dfa.init MT) xs\\<rangle> \\<Longrightarrow>\n       ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> (xs @ [x]) =\n       \\<langle>dfa.nextl MS (dfa.init MS) (xs @ [x]),\n                dfa.nextl MT (dfa.init MT) (xs @ [x])\\<rangle>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> [] =\n    \\<langle>dfa.nextl MS (dfa.init MS) [],\n             dfa.nextl MT (dfa.init MT) []\\<rangle>", "by (auto simp: dfa.nextl.simps M)"], ["proof (state)\nthis:\n  ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> [] =\n  \\<langle>dfa.nextl MS (dfa.init MS) [],\n           dfa.nextl MT (dfa.init MT) []\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> xs =\n       \\<langle>dfa.nextl MS (dfa.init MS) xs,\n                dfa.nextl MT (dfa.init MT) xs\\<rangle> \\<Longrightarrow>\n       ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> (xs @ [x]) =\n       \\<langle>dfa.nextl MS (dfa.init MS) (xs @ [x]),\n                dfa.nextl MT (dfa.init MT) (xs @ [x])\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> xs =\n       \\<langle>dfa.nextl MS (dfa.init MS) xs,\n                dfa.nextl MT (dfa.init MT) xs\\<rangle> \\<Longrightarrow>\n       ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> (xs @ [x]) =\n       \\<langle>dfa.nextl MS (dfa.init MS) (xs @ [x]),\n                dfa.nextl MT (dfa.init MT) (xs @ [x])\\<rangle>", "case (snoc x u)"], ["proof (state)\nthis:\n  ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> u =\n  \\<langle>dfa.nextl MS (dfa.init MS) u,\n           dfa.nextl MT (dfa.init MT) u\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> xs =\n       \\<langle>dfa.nextl MS (dfa.init MS) xs,\n                dfa.nextl MT (dfa.init MT) xs\\<rangle> \\<Longrightarrow>\n       ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> (xs @ [x]) =\n       \\<langle>dfa.nextl MS (dfa.init MS) (xs @ [x]),\n                dfa.nextl MT (dfa.init MT) (xs @ [x])\\<rangle>", "then"], ["proof (chain)\npicking this:\n  ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> u =\n  \\<langle>dfa.nextl MS (dfa.init MS) u,\n           dfa.nextl MT (dfa.init MT) u\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> u =\n  \\<langle>dfa.nextl MS (dfa.init MS) u,\n           dfa.nextl MT (dfa.init MT) u\\<rangle>\n\ngoal (1 subgoal):\n 1. ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> (u @ [x]) =\n    \\<langle>dfa.nextl MS (dfa.init MS) (u @ [x]),\n             dfa.nextl MT (dfa.init MT) (u @ [x])\\<rangle>", "by (simp add: dfa.nextl_snoc M)"], ["proof (state)\nthis:\n  ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> (u @ [x]) =\n  \\<langle>dfa.nextl MS (dfa.init MS) (u @ [x]),\n           dfa.nextl MT (dfa.init MT) (u @ [x])\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> u =\n  \\<langle>dfa.nextl MS (dfa.init MS) u,\n           dfa.nextl MT (dfa.init MT) u\\<rangle>\n\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "then"], ["proof (chain)\npicking this:\n  ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> u =\n  \\<langle>dfa.nextl MS (dfa.init MS) u,\n           dfa.nextl MT (dfa.init MT) u\\<rangle>", "have \"u \\<in> ST.language \\<longleftrightarrow> u \\<in> dfa.language MS \\<and> u \\<in> dfa.language MT\""], ["proof (prove)\nusing this:\n  ST.nextl \\<langle>dfa.init MS, dfa.init MT\\<rangle> u =\n  \\<langle>dfa.nextl MS (dfa.init MS) u,\n           dfa.nextl MT (dfa.init MT) u\\<rangle>\n\ngoal (1 subgoal):\n 1. (u \\<in> ST.language) =\n    (u \\<in> dfa.language MS \\<and> u \\<in> dfa.language MT)", "by (auto simp: M ST.language_def dfa.language_def dfa.finite_final)"], ["proof (state)\nthis:\n  (u \\<in> ST.language) =\n  (u \\<in> dfa.language MS \\<and> u \\<in> dfa.language MT)\n\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "}"], ["proof (state)\nthis:\n  (?u2 \\<in> ST.language) =\n  (?u2 \\<in> dfa.language MS \\<and> ?u2 \\<in> dfa.language MT)\n\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "then"], ["proof (chain)\npicking this:\n  (?u2 \\<in> ST.language) =\n  (?u2 \\<in> dfa.language MS \\<and> ?u2 \\<in> dfa.language MT)", "have eq_L: \"ST.language = S \\<inter> T\""], ["proof (prove)\nusing this:\n  (?u2 \\<in> ST.language) =\n  (?u2 \\<in> dfa.language MS \\<and> ?u2 \\<in> dfa.language MT)\n\ngoal (1 subgoal):\n 1. ST.language = S \\<inter> T", "using lang"], ["proof (prove)\nusing this:\n  (?u2 \\<in> ST.language) =\n  (?u2 \\<in> dfa.language MS \\<and> ?u2 \\<in> dfa.language MT)\n  dfa.language MS = S\n  dfa.language MT = T\n\ngoal (1 subgoal):\n 1. ST.language = S \\<inter> T", "by blast"], ["proof (state)\nthis:\n  ST.language = S \\<inter> T\n\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "unfolding regular_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M. dfa M \\<and> dfa.language M = S \\<inter> T", "by (intro exI conjI, unfold_locales) (rule eq_L)"], ["proof (state)\nthis:\n  regular (S \\<inter> T)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary regular_Un:\n  assumes S: \"regular S\" and T: \"regular T\" shows \"regular (S \\<union> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (S \\<union> T)", "by (metis S T compl_sup double_compl regular_Compl  regular_Int [of \"-S\" \"-T\"])"], ["", "subsection\\<open>The Concatenation of Two Languages\\<close>"], ["", "lemma Inlr_rtrancl [simp]: \"((\\<lambda>q. (Inl q, Inr a)) ` A)\\<^sup>* = ((\\<lambda>q. (Inl q, Inr a)) ` A)\\<^sup>=\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>q. (HF.Inl q, HF.Inr a)) ` A)\\<^sup>* =\n    ((\\<lambda>q. (HF.Inl q, HF.Inr a)) ` A)\\<^sup>=", "by (auto elim: rtranclE)"], ["", "theorem regular_conc:\n  assumes S: \"regular S\" and T: \"regular T\" shows \"regular (S @@ T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (S @@ T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (S @@ T)", "obtain MS MT where M: \"dfa MS\" \"dfa MT\" and lang: \"dfa.language MS = S\" \"dfa.language MT = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>MS MT.\n        \\<lbrakk>dfa MS; dfa MT; dfa.language MS = S;\n         dfa.language MT = T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using S T"], ["proof (prove)\nusing this:\n  regular S\n  regular T\n\ngoal (1 subgoal):\n 1. (\\<And>MS MT.\n        \\<lbrakk>dfa MS; dfa MT; dfa.language MS = S;\n         dfa.language MT = T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: regular_def)"], ["proof (state)\nthis:\n  dfa MS\n  dfa MT\n  dfa.language MS = S\n  dfa.language MT = T\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "note [simp] = dfa.init dfa.nxt dfa.nextl.simps dfa.nextl_snoc"], ["proof (state)\nthis:\n  dfa ?M \\<Longrightarrow> dfa.init ?M \\<in> dfa.states ?M\n  \\<lbrakk>dfa ?M; ?q \\<in> dfa.states ?M\\<rbrakk>\n  \\<Longrightarrow> dfa.nxt ?M ?q ?x \\<in> dfa.states ?M\n  dfa ?M \\<Longrightarrow> dfa.nextl ?M ?q [] = ?q\n  dfa ?M \\<Longrightarrow>\n  dfa.nextl ?M ?q (?x # ?xs) = dfa.nextl ?M (dfa.nxt ?M ?q ?x) ?xs\n  dfa ?M \\<Longrightarrow>\n  dfa.nextl ?M ?q (?xs @ [?x]) = dfa.nxt ?M (dfa.nextl ?M ?q ?xs) ?x\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "let ?ST = \"\\<lparr>nfa.states = Inl ` (dfa.states MS) \\<union> Inr ` (dfa.states MT),\n                  init  = {Inl (dfa.init MS)},\n                  final = Inr ` (dfa.final MT),\n                  nxt   = \\<lambda>q x. sum_case (\\<lambda>qs. {Inl (dfa.nxt MS qs x)})\n                                             (\\<lambda>qt. {Inr (dfa.nxt MT qt x)}) q,\n                  eps   = (\\<lambda>q. (Inl q, Inr (dfa.init MT))) ` dfa.final MS\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. regular (S @@ T)", "interpret ST: nfa ?ST"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa \\<lparr>nfa.states =\n                  HF.Inl ` dfa.states MS \\<union> HF.Inr ` dfa.states MT,\n           init = {HF.Inl (dfa.init MS)}, final = HF.Inr ` dfa.final MT,\n           nxt =\n             \\<lambda>q x.\n                sum_case (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                 (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) q,\n           eps =\n             (\\<lambda>q. (HF.Inl q, HF.Inr (dfa.init MT))) `\n             dfa.final MS\\<rparr>", "using M dfa.final"], ["proof (prove)\nusing this:\n  dfa MS\n  dfa MT\n  dfa ?M \\<Longrightarrow> dfa.final ?M \\<subseteq> dfa.states ?M\n\ngoal (1 subgoal):\n 1. nfa \\<lparr>nfa.states =\n                  HF.Inl ` dfa.states MS \\<union> HF.Inr ` dfa.states MT,\n           init = {HF.Inl (dfa.init MS)}, final = HF.Inr ` dfa.final MT,\n           nxt =\n             \\<lambda>q x.\n                sum_case (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                 (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) q,\n           eps =\n             (\\<lambda>q. (HF.Inl q, HF.Inr (dfa.init MT))) `\n             dfa.final MS\\<rparr>", "by (force simp add: nfa_def dfa.finite)"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (S @@ T)", "have Inl_in_eps_iff: \"\\<And>q Q. Inl q \\<in> nfa.epsclo ?ST Q \\<longleftrightarrow> Inl q \\<in> Q \\<and> q \\<in> dfa.states MS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q Q.\n       (HF.Inl q \\<in> ST.epsclo Q) =\n       (HF.Inl q \\<in> Q \\<and> q \\<in> dfa.states MS)", "by (auto simp: M dfa.finite ST.epsclo_def)"], ["proof (state)\nthis:\n  (HF.Inl ?q \\<in> ST.epsclo ?Q) =\n  (HF.Inl ?q \\<in> ?Q \\<and> ?q \\<in> dfa.states MS)\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "have Inr_in_eps_iff: \"\\<And>q Q. Inr q \\<in> nfa.epsclo ?ST Q \\<longleftrightarrow>\n           (Inr q \\<in> Q \\<and> q \\<in> dfa.states MT \\<or> (q = dfa.init MT \\<and> (\\<exists>qf \\<in> dfa.final MS. Inl qf \\<in> Q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q Q.\n       (HF.Inr q \\<in> ST.epsclo Q) =\n       (HF.Inr q \\<in> Q \\<and> q \\<in> dfa.states MT \\<or>\n        q = dfa.init MT \\<and>\n        (\\<exists>qf\\<in>dfa.final MS. HF.Inl qf \\<in> Q))", "by (auto simp: M dfa.finite ST.epsclo_def)"], ["proof (state)\nthis:\n  (HF.Inr ?q \\<in> ST.epsclo ?Q) =\n  (HF.Inr ?q \\<in> ?Q \\<and> ?q \\<in> dfa.states MT \\<or>\n   ?q = dfa.init MT \\<and>\n   (\\<exists>qf\\<in>dfa.final MS. HF.Inl qf \\<in> ?Q))\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "{"], ["proof (state)\nthis:\n  (HF.Inr ?q \\<in> ST.epsclo ?Q) =\n  (HF.Inr ?q \\<in> ?Q \\<and> ?q \\<in> dfa.states MT \\<or>\n   ?q = dfa.init MT \\<and>\n   (\\<exists>qf\\<in>dfa.final MS. HF.Inl qf \\<in> ?Q))\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (S @@ T)", "have \"\\<And>q. Inl q \\<in> ST.nextl {Inl (dfa.init MS)} u \\<longleftrightarrow> q = (dfa.nextl MS (dfa.init MS) u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n       (q = dfa.nextl MS (dfa.init MS) u)", "proof (induct u rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} []) =\n       (q = dfa.nextl MS (dfa.init MS) [])\n 2. \\<And>x xs q.\n       (\\<And>q.\n           (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} xs) =\n           (q = dfa.nextl MS (dfa.init MS) xs)) \\<Longrightarrow>\n       (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (xs @ [x])) =\n       (q = dfa.nextl MS (dfa.init MS) (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>q.\n       (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} []) =\n       (q = dfa.nextl MS (dfa.init MS) [])\n 2. \\<And>x xs q.\n       (\\<And>q.\n           (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} xs) =\n           (q = dfa.nextl MS (dfa.init MS) xs)) \\<Longrightarrow>\n       (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (xs @ [x])) =\n       (q = dfa.nextl MS (dfa.init MS) (xs @ [x]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} []) =\n    (q = dfa.nextl MS (dfa.init MS) [])", "by (auto simp: M Inl_in_eps_iff)"], ["proof (state)\nthis:\n  (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} []) =\n  (q = dfa.nextl MS (dfa.init MS) [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       (\\<And>q.\n           (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} xs) =\n           (q = dfa.nextl MS (dfa.init MS) xs)) \\<Longrightarrow>\n       (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (xs @ [x])) =\n       (q = dfa.nextl MS (dfa.init MS) (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       (\\<And>q.\n           (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} xs) =\n           (q = dfa.nextl MS (dfa.init MS) xs)) \\<Longrightarrow>\n       (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (xs @ [x])) =\n       (q = dfa.nextl MS (dfa.init MS) (xs @ [x]))", "case (snoc x u)"], ["proof (state)\nthis:\n  (HF.Inl ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n  (?q = dfa.nextl MS (dfa.init MS) u)\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       (\\<And>q.\n           (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} xs) =\n           (q = dfa.nextl MS (dfa.init MS) xs)) \\<Longrightarrow>\n       (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (xs @ [x])) =\n       (q = dfa.nextl MS (dfa.init MS) (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  (HF.Inl ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n  (?q = dfa.nextl MS (dfa.init MS) u)", "show ?case"], ["proof (prove)\nusing this:\n  (HF.Inl ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n  (?q = dfa.nextl MS (dfa.init MS) u)\n\ngoal (1 subgoal):\n 1. (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (u @ [x])) =\n    (q = dfa.nextl MS (dfa.init MS) (u @ [x]))", "apply (auto simp add: M dfa.nextl_init_state Inl_in_eps_iff is_hsum_def split: sum_case_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (q = dfa.nextl MS (dfa.init MS) u);\n        q \\<in> dfa.states MS; xa \\<in> ST.nextl {HF.Inl (dfa.init MS)} u;\n        \\<forall>xb. xa = HF.Inl xb \\<longrightarrow> q = dfa.nxt MS xb x;\n        \\<forall>y. xa \\<noteq> HF.Inr y; HF.Inl q \\<in> undefined\\<rbrakk>\n       \\<Longrightarrow> q = dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x", "apply (frule ST.nextl_state [THEN subsetD], auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (HF.Inl q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (u @ [x])) =\n  (q = dfa.nextl MS (dfa.init MS) (u @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (HF.Inl ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n  (?q = dfa.nextl MS (dfa.init MS) u)\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "}"], ["proof (state)\nthis:\n  (HF.Inl ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} ?u3) =\n  (?q = dfa.nextl MS (dfa.init MS) ?u3)\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "note Inl_ST_iff = this"], ["proof (state)\nthis:\n  (HF.Inl ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} ?u3) =\n  (?q = dfa.nextl MS (dfa.init MS) ?u3)\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "{"], ["proof (state)\nthis:\n  (HF.Inl ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} ?u3) =\n  (?q = dfa.nextl MS (dfa.init MS) ?u3)\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (S @@ T)", "have \"\\<And>q. Inr q \\<in> ST.nextl {Inl (dfa.init MS)} u  \\<longleftrightarrow>\n               (\\<exists>uS uT. uS \\<in> dfa.language MS \\<and> u = uS@uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n       (\\<exists>uS uT.\n           uS \\<in> dfa.language MS \\<and>\n           u = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)", "proof (induct u rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} []) =\n       (\\<exists>uS uT.\n           uS \\<in> dfa.language MS \\<and>\n           [] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)\n 2. \\<And>x xs q.\n       (\\<And>q.\n           (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} xs) =\n           (\\<exists>uS uT.\n               uS \\<in> dfa.language MS \\<and>\n               xs = uS @ uT \\<and>\n               q = dfa.nextl MT (dfa.init MT) uT)) \\<Longrightarrow>\n       (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (xs @ [x])) =\n       (\\<exists>uS uT.\n           uS \\<in> dfa.language MS \\<and>\n           xs @ [x] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>q.\n       (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} []) =\n       (\\<exists>uS uT.\n           uS \\<in> dfa.language MS \\<and>\n           [] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)\n 2. \\<And>x xs q.\n       (\\<And>q.\n           (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} xs) =\n           (\\<exists>uS uT.\n               uS \\<in> dfa.language MS \\<and>\n               xs = uS @ uT \\<and>\n               q = dfa.nextl MT (dfa.init MT) uT)) \\<Longrightarrow>\n       (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (xs @ [x])) =\n       (\\<exists>uS uT.\n           uS \\<in> dfa.language MS \\<and>\n           xs @ [x] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} []) =\n    (\\<exists>uS uT.\n        uS \\<in> dfa.language MS \\<and>\n        [] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)", "by (auto simp: M dfa.language_def Inr_in_eps_iff)"], ["proof (state)\nthis:\n  (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} []) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      [] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       (\\<And>q.\n           (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} xs) =\n           (\\<exists>uS uT.\n               uS \\<in> dfa.language MS \\<and>\n               xs = uS @ uT \\<and>\n               q = dfa.nextl MT (dfa.init MT) uT)) \\<Longrightarrow>\n       (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (xs @ [x])) =\n       (\\<exists>uS uT.\n           uS \\<in> dfa.language MS \\<and>\n           xs @ [x] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       (\\<And>q.\n           (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} xs) =\n           (\\<exists>uS uT.\n               uS \\<in> dfa.language MS \\<and>\n               xs = uS @ uT \\<and>\n               q = dfa.nextl MT (dfa.init MT) uT)) \\<Longrightarrow>\n       (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (xs @ [x])) =\n       (\\<exists>uS uT.\n           uS \\<in> dfa.language MS \\<and>\n           xs @ [x] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)", "case (snoc x u)"], ["proof (state)\nthis:\n  (HF.Inr ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      u = uS @ uT \\<and> ?q = dfa.nextl MT (dfa.init MT) uT)\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       (\\<And>q.\n           (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} xs) =\n           (\\<exists>uS uT.\n               uS \\<in> dfa.language MS \\<and>\n               xs = uS @ uT \\<and>\n               q = dfa.nextl MT (dfa.init MT) uT)) \\<Longrightarrow>\n       (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (xs @ [x])) =\n       (\\<exists>uS uT.\n           uS \\<in> dfa.language MS \\<and>\n           xs @ [x] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)", "then"], ["proof (chain)\npicking this:\n  (HF.Inr ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      u = uS @ uT \\<and> ?q = dfa.nextl MT (dfa.init MT) uT)", "show ?case"], ["proof (prove)\nusing this:\n  (HF.Inr ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      u = uS @ uT \\<and> ?q = dfa.nextl MT (dfa.init MT) uT)\n\ngoal (1 subgoal):\n 1. (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (u @ [x])) =\n    (\\<exists>uS uT.\n        uS \\<in> dfa.language MS \\<and>\n        u @ [x] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)", "using M"], ["proof (prove)\nusing this:\n  (HF.Inr ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      u = uS @ uT \\<and> ?q = dfa.nextl MT (dfa.init MT) uT)\n  dfa MS\n  dfa MT\n\ngoal (1 subgoal):\n 1. (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (u @ [x])) =\n    (\\<exists>uS uT.\n        uS \\<in> dfa.language MS \\<and>\n        u @ [x] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)", "apply (auto simp: Inr_in_eps_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       uS \\<in> dfa.language MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; xa \\<in> ST.nextl {HF.Inl (dfa.init MS)} u;\n        HF.Inr q\n        \\<in> sum_case (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n               (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa;\n        q \\<in> dfa.states MT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>uS.\n                            uS \\<in> dfa.language MS \\<and>\n                            (\\<exists>uT.\n                                u @ [x] = uS @ uT \\<and>\n                                q = dfa.nextl MT (dfa.init MT) uT)\n 2. \\<And>xa qf.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       uS \\<in> dfa.language MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; xa \\<in> ST.nextl {HF.Inl (dfa.init MS)} u;\n        q = dfa.init MT; qf \\<in> dfa.final MS;\n        HF.Inl qf\n        \\<in> sum_case (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n               (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>uS.\n                            uS \\<in> dfa.language MS \\<and>\n                            (\\<exists>uT.\n                                u @ [x] = uS @ uT \\<and>\n                                dfa.init MT = dfa.nextl MT (dfa.init MT) uT)\n 3. \\<And>uS uT.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       uS \\<in> dfa.language MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; uS \\<in> dfa.language MS; u @ [x] = uS @ uT;\n        q = dfa.nextl MT (dfa.init MT) uT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>ST.nextl {HF.Inl (dfa.init MS)} u.\n                            HF.Inr (dfa.nextl MT (dfa.init MT) uT)\n                            \\<in> sum_case\n                                   (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                   (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                   xa \\<and>\n                            dfa.nextl MT (dfa.init MT) uT\n                            \\<in> dfa.states MT \\<or>\n                            dfa.nextl MT (dfa.init MT) uT =\n                            dfa.init MT \\<and>\n                            (\\<exists>qf\\<in>dfa.final MS.\n                                HF.Inl qf\n                                \\<in> sum_case\n (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa)", "apply (frule ST.nextl_state [THEN subsetD], force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa qf.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       uS \\<in> dfa.language MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; xa \\<in> ST.nextl {HF.Inl (dfa.init MS)} u;\n        q = dfa.init MT; qf \\<in> dfa.final MS;\n        HF.Inl qf\n        \\<in> sum_case (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n               (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>uS.\n                            uS \\<in> dfa.language MS \\<and>\n                            (\\<exists>uT.\n                                u @ [x] = uS @ uT \\<and>\n                                dfa.init MT = dfa.nextl MT (dfa.init MT) uT)\n 2. \\<And>uS uT.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       uS \\<in> dfa.language MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; uS \\<in> dfa.language MS; u @ [x] = uS @ uT;\n        q = dfa.nextl MT (dfa.init MT) uT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>ST.nextl {HF.Inl (dfa.init MS)} u.\n                            HF.Inr (dfa.nextl MT (dfa.init MT) uT)\n                            \\<in> sum_case\n                                   (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                   (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                   xa \\<and>\n                            dfa.nextl MT (dfa.init MT) uT\n                            \\<in> dfa.states MT \\<or>\n                            dfa.nextl MT (dfa.init MT) uT =\n                            dfa.init MT \\<and>\n                            (\\<exists>qf\\<in>dfa.final MS.\n                                HF.Inl qf\n                                \\<in> sum_case\n (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa)", "apply (frule ST.nextl_state [THEN subsetD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa qf.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       uS \\<in> dfa.language MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; xa \\<in> ST.nextl {HF.Inl (dfa.init MS)} u;\n        q = dfa.init MT; qf \\<in> dfa.final MS;\n        HF.Inl qf\n        \\<in> sum_case (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n               (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa;\n        xa \\<in> nfa.states\n                  \\<lparr>nfa.states =\n                            HF.Inl ` dfa.states MS \\<union>\n                            HF.Inr ` dfa.states MT,\n                     init = {HF.Inl (dfa.init MS)},\n                     final = HF.Inr ` dfa.final MT,\n                     nxt =\n                       \\<lambda>q x.\n                          sum_case (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                           (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) q,\n                     eps =\n                       (\\<lambda>q. (HF.Inl q, HF.Inr (dfa.init MT))) `\n                       dfa.final MS\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>uS.\n                            uS \\<in> dfa.language MS \\<and>\n                            (\\<exists>uT.\n                                u @ [x] = uS @ uT \\<and>\n                                dfa.init MT = dfa.nextl MT (dfa.init MT) uT)\n 2. \\<And>uS uT.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       uS \\<in> dfa.language MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; uS \\<in> dfa.language MS; u @ [x] = uS @ uT;\n        q = dfa.nextl MT (dfa.init MT) uT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>ST.nextl {HF.Inl (dfa.init MS)} u.\n                            HF.Inr (dfa.nextl MT (dfa.init MT) uT)\n                            \\<in> sum_case\n                                   (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                   (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                   xa \\<and>\n                            dfa.nextl MT (dfa.init MT) uT\n                            \\<in> dfa.states MT \\<or>\n                            dfa.nextl MT (dfa.init MT) uT =\n                            dfa.init MT \\<and>\n                            (\\<exists>qf\\<in>dfa.final MS.\n                                HF.Inl qf\n                                \\<in> sum_case\n (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa)", "apply (auto simp: dfa.language_def Inl_ST_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                (\\<exists>uS.\n                    dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS \\<and>\n                    (\\<exists>uT.\n                        u = uS @ uT \\<and>\n                        q = dfa.nextl MT (dfa.init MT) uT));\n     dfa MS; dfa MT; q = dfa.init MT;\n     dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x \\<in> dfa.final MS;\n     dfa.nextl MS (dfa.init MS) u \\<in> dfa.states MS\\<rbrakk>\n    \\<Longrightarrow> \\<exists>uS.\n                         dfa.nextl MS (dfa.init MS) uS\n                         \\<in> dfa.final MS \\<and>\n                         (\\<exists>uT.\n                             u @ [x] = uS @ uT \\<and>\n                             dfa.init MT = dfa.nextl MT (dfa.init MT) uT)\n 2. \\<And>uS uT.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       dfa.nextl MS (dfa.init MS) uS\n                       \\<in> dfa.final MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS;\n        u @ [x] = uS @ uT; q = dfa.nextl MT (dfa.init MT) uT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>ST.nextl {HF.Inl (dfa.init MS)} u.\n                            HF.Inr (dfa.nextl MT (dfa.init MT) uT)\n                            \\<in> sum_case\n                                   (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                   (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                   xa \\<and>\n                            dfa.nextl MT (dfa.init MT) uT\n                            \\<in> dfa.states MT \\<or>\n                            dfa.nextl MT (dfa.init MT) uT =\n                            dfa.init MT \\<and>\n                            (\\<exists>qf\\<in>dfa.final MS.\n                                HF.Inl qf\n                                \\<in> sum_case\n (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa)", "apply (metis (lifting) append_Nil2 dfa.nextl.simps(1) dfa.nextl_snoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uS uT.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       dfa.nextl MS (dfa.init MS) uS\n                       \\<in> dfa.final MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS;\n        u @ [x] = uS @ uT; q = dfa.nextl MT (dfa.init MT) uT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>ST.nextl {HF.Inl (dfa.init MS)} u.\n                            HF.Inr (dfa.nextl MT (dfa.init MT) uT)\n                            \\<in> sum_case\n                                   (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                   (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                   xa \\<and>\n                            dfa.nextl MT (dfa.init MT) uT\n                            \\<in> dfa.states MT \\<or>\n                            dfa.nextl MT (dfa.init MT) uT =\n                            dfa.init MT \\<and>\n                            (\\<exists>qf\\<in>dfa.final MS.\n                                HF.Inl qf\n                                \\<in> sum_case\n (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa)", "apply (rename_tac uS uT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uS uT.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       dfa.nextl MS (dfa.init MS) uS\n                       \\<in> dfa.final MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS;\n        u @ [x] = uS @ uT; q = dfa.nextl MT (dfa.init MT) uT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>ST.nextl {HF.Inl (dfa.init MS)} u.\n                            HF.Inr (dfa.nextl MT (dfa.init MT) uT)\n                            \\<in> sum_case\n                                   (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                   (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                   xa \\<and>\n                            dfa.nextl MT (dfa.init MT) uT\n                            \\<in> dfa.states MT \\<or>\n                            dfa.nextl MT (dfa.init MT) uT =\n                            dfa.init MT \\<and>\n                            (\\<exists>qf\\<in>dfa.final MS.\n                                HF.Inl qf\n                                \\<in> sum_case\n (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa)", "apply (rule_tac xs=uT in rev_exhaust, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uS uT.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       dfa.nextl MS (dfa.init MS) uS\n                       \\<in> dfa.final MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS;\n        u @ [x] = uS; q = dfa.init MT; uT = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>ST.nextl {HF.Inl (dfa.init MS)} u.\n                            HF.Inr (dfa.init MT)\n                            \\<in> sum_case\n                                   (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                   (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                   xa \\<or>\n                            (\\<exists>qf\\<in>dfa.final MS.\n                                HF.Inl qf\n                                \\<in> sum_case\n (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa)\n 2. \\<And>uS uT ys y.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       dfa.nextl MS (dfa.init MS) uS\n                       \\<in> dfa.final MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS;\n        u @ [x] = uS @ uT; q = dfa.nextl MT (dfa.init MT) uT;\n        uT = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>ST.nextl {HF.Inl (dfa.init MS)} u.\n                            HF.Inr (dfa.nextl MT (dfa.init MT) uT)\n                            \\<in> sum_case\n                                   (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                   (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                   xa \\<and>\n                            dfa.nextl MT (dfa.init MT) uT\n                            \\<in> dfa.states MT \\<or>\n                            dfa.nextl MT (dfa.init MT) uT =\n                            dfa.init MT \\<and>\n                            (\\<exists>qf\\<in>dfa.final MS.\n                                HF.Inl qf\n                                \\<in> sum_case\n (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa)", "apply (rule bexI [where x=\"Inl (dfa.nextl MS (dfa.init MS) u)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uS uT.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       dfa.nextl MS (dfa.init MS) uS\n                       \\<in> dfa.final MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS;\n        u @ [x] = uS; q = dfa.init MT; uT = []\\<rbrakk>\n       \\<Longrightarrow> HF.Inr (dfa.init MT)\n                         \\<in> sum_case\n                                (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                (HF.Inl\n                                  (dfa.nextl MS (dfa.init MS) u)) \\<or>\n                         (\\<exists>qf\\<in>dfa.final MS.\n                             HF.Inl qf\n                             \\<in> sum_case\n                                    (\\<lambda>qs.\n  {HF.Inl (dfa.nxt MS qs x)})\n                                    (\\<lambda>qt.\n  {HF.Inr (dfa.nxt MT qt x)})\n                                    (HF.Inl (dfa.nextl MS (dfa.init MS) u)))\n 2. \\<And>uS uT.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       dfa.nextl MS (dfa.init MS) uS\n                       \\<in> dfa.final MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS;\n        u @ [x] = uS; q = dfa.init MT; uT = []\\<rbrakk>\n       \\<Longrightarrow> HF.Inl (dfa.nextl MS (dfa.init MS) u)\n                         \\<in> ST.nextl {HF.Inl (dfa.init MS)} u\n 3. \\<And>uS uT ys y.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n                   (\\<exists>uS.\n                       dfa.nextl MS (dfa.init MS) uS\n                       \\<in> dfa.final MS \\<and>\n                       (\\<exists>uT.\n                           u = uS @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS;\n        u @ [x] = uS @ uT; q = dfa.nextl MT (dfa.init MT) uT;\n        uT = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>ST.nextl {HF.Inl (dfa.init MS)} u.\n                            HF.Inr (dfa.nextl MT (dfa.init MT) uT)\n                            \\<in> sum_case\n                                   (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                   (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                   xa \\<and>\n                            dfa.nextl MT (dfa.init MT) uT\n                            \\<in> dfa.states MT \\<or>\n                            dfa.nextl MT (dfa.init MT) uT =\n                            dfa.init MT \\<and>\n                            (\\<exists>qf\\<in>dfa.final MS.\n                                HF.Inl qf\n                                \\<in> sum_case\n (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa)", "apply (auto simp: Inl_ST_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uS ys.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q\n                    \\<in> ST.nextl {HF.Inl (dfa.init MS)} (uS @ ys)) =\n                   (\\<exists>uSa.\n                       dfa.nextl MS (dfa.init MS) uSa\n                       \\<in> dfa.final MS \\<and>\n                       (\\<exists>uT.\n                           uS @ ys = uSa @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS;\n        u = uS @ ys;\n        q = dfa.nxt MT (dfa.nextl MT (dfa.init MT) ys) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>ST.nextl {HF.Inl (dfa.init MS)}\n    (uS @ ys).\n                            HF.Inr\n                             (dfa.nxt MT (dfa.nextl MT (dfa.init MT) ys) x)\n                            \\<in> sum_case\n                                   (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                   (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                   xa \\<and>\n                            dfa.nxt MT (dfa.nextl MT (dfa.init MT) ys) x\n                            \\<in> dfa.states MT \\<or>\n                            dfa.nxt MT (dfa.nextl MT (dfa.init MT) ys) x =\n                            dfa.init MT \\<and>\n                            (\\<exists>qf\\<in>dfa.final MS.\n                                HF.Inl qf\n                                \\<in> sum_case\n (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)}) xa)", "apply (rule bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uS ys.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q\n                    \\<in> ST.nextl {HF.Inl (dfa.init MS)} (uS @ ys)) =\n                   (\\<exists>uSa.\n                       dfa.nextl MS (dfa.init MS) uSa\n                       \\<in> dfa.final MS \\<and>\n                       (\\<exists>uT.\n                           uS @ ys = uSa @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS;\n        u = uS @ ys;\n        q = dfa.nxt MT (dfa.nextl MT (dfa.init MT) ys) x\\<rbrakk>\n       \\<Longrightarrow> HF.Inr\n                          (dfa.nxt MT (dfa.nextl MT (dfa.init MT) ys) x)\n                         \\<in> sum_case\n                                (\\<lambda>qs. {HF.Inl (dfa.nxt MS qs x)})\n                                (\\<lambda>qt. {HF.Inr (dfa.nxt MT qt x)})\n                                (?x75 uS ys) \\<and>\n                         dfa.nxt MT (dfa.nextl MT (dfa.init MT) ys) x\n                         \\<in> dfa.states MT \\<or>\n                         dfa.nxt MT (dfa.nextl MT (dfa.init MT) ys) x =\n                         dfa.init MT \\<and>\n                         (\\<exists>qf\\<in>dfa.final MS.\n                             HF.Inl qf\n                             \\<in> sum_case\n                                    (\\<lambda>qs.\n  {HF.Inl (dfa.nxt MS qs x)})\n                                    (\\<lambda>qt.\n  {HF.Inr (dfa.nxt MT qt x)})\n                                    (?x75 uS ys))\n 2. \\<And>uS ys.\n       \\<lbrakk>\\<And>q.\n                   (HF.Inr q\n                    \\<in> ST.nextl {HF.Inl (dfa.init MS)} (uS @ ys)) =\n                   (\\<exists>uSa.\n                       dfa.nextl MS (dfa.init MS) uSa\n                       \\<in> dfa.final MS \\<and>\n                       (\\<exists>uT.\n                           uS @ ys = uSa @ uT \\<and>\n                           q = dfa.nextl MT (dfa.init MT) uT));\n        dfa MS; dfa MT; dfa.nextl MS (dfa.init MS) uS \\<in> dfa.final MS;\n        u = uS @ ys;\n        q = dfa.nxt MT (dfa.nextl MT (dfa.init MT) ys) x\\<rbrakk>\n       \\<Longrightarrow> ?x75 uS ys\n                         \\<in> ST.nextl {HF.Inl (dfa.init MS)} (uS @ ys)", "apply (auto simp: dfa.nextl_init_state)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (HF.Inr q \\<in> ST.nextl {HF.Inl (dfa.init MS)} (u @ [x])) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      u @ [x] = uS @ uT \\<and> q = dfa.nextl MT (dfa.init MT) uT)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (HF.Inr ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      u = uS @ uT \\<and> ?q = dfa.nextl MT (dfa.init MT) uT)\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "then"], ["proof (chain)\npicking this:\n  (HF.Inr ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      u = uS @ uT \\<and> ?q = dfa.nextl MT (dfa.init MT) uT)", "have \"u \\<in> ST.language \\<longleftrightarrow>\n               (\\<exists>uS uT. uS \\<in> dfa.language MS \\<and> uT \\<in> dfa.language MT \\<and> u = uS@uT)\""], ["proof (prove)\nusing this:\n  (HF.Inr ?q \\<in> ST.nextl {HF.Inl (dfa.init MS)} u) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      u = uS @ uT \\<and> ?q = dfa.nextl MT (dfa.init MT) uT)\n\ngoal (1 subgoal):\n 1. (u \\<in> ST.language) =\n    (\\<exists>uS uT.\n        uS \\<in> dfa.language MS \\<and>\n        uT \\<in> dfa.language MT \\<and> u = uS @ uT)", "by (force simp: M ST.language_def dfa.language_def)"], ["proof (state)\nthis:\n  (u \\<in> ST.language) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      uT \\<in> dfa.language MT \\<and> u = uS @ uT)\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "}"], ["proof (state)\nthis:\n  (?u2 \\<in> ST.language) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      uT \\<in> dfa.language MT \\<and> ?u2 = uS @ uT)\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "then"], ["proof (chain)\npicking this:\n  (?u2 \\<in> ST.language) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      uT \\<in> dfa.language MT \\<and> ?u2 = uS @ uT)", "have eq_L: \"ST.language = S @@ T\""], ["proof (prove)\nusing this:\n  (?u2 \\<in> ST.language) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      uT \\<in> dfa.language MT \\<and> ?u2 = uS @ uT)\n\ngoal (1 subgoal):\n 1. ST.language = S @@ T", "using lang"], ["proof (prove)\nusing this:\n  (?u2 \\<in> ST.language) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      uT \\<in> dfa.language MT \\<and> ?u2 = uS @ uT)\n  dfa.language MS = S\n  dfa.language MT = T\n\ngoal (1 subgoal):\n 1. ST.language = S @@ T", "unfolding conc_def"], ["proof (prove)\nusing this:\n  (?u2 \\<in> ST.language) =\n  (\\<exists>uS uT.\n      uS \\<in> dfa.language MS \\<and>\n      uT \\<in> dfa.language MT \\<and> ?u2 = uS @ uT)\n  dfa.language MS = S\n  dfa.language MT = T\n\ngoal (1 subgoal):\n 1. ST.language = {xs @ ys |xs ys. xs \\<in> S \\<and> ys \\<in> T}", "by blast"], ["proof (state)\nthis:\n  ST.language = S @@ T\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "then"], ["proof (chain)\npicking this:\n  ST.language = S @@ T", "show ?thesis"], ["proof (prove)\nusing this:\n  ST.language = S @@ T\n\ngoal (1 subgoal):\n 1. regular (S @@ T)", "by (metis ST.imp_regular)"], ["proof (state)\nthis:\n  regular (S @@ T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma regular_word: \"regular {u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular {u}", "proof (induction u)"], ["proof (state)\ngoal (2 subgoals):\n 1. regular {[]}\n 2. \\<And>a u. regular {u} \\<Longrightarrow> regular {a # u}", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. regular {[]}\n 2. \\<And>a u. regular {u} \\<Longrightarrow> regular {a # u}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. regular {[]}", "by (simp add: regular_nullstr)"], ["proof (state)\nthis:\n  regular {[]}\n\ngoal (1 subgoal):\n 1. \\<And>a u. regular {u} \\<Longrightarrow> regular {a # u}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a u. regular {u} \\<Longrightarrow> regular {a # u}", "case (Cons x l)"], ["proof (state)\nthis:\n  regular {l}\n\ngoal (1 subgoal):\n 1. \\<And>a u. regular {u} \\<Longrightarrow> regular {a # u}", "have \"{x#l} = {[x]} @@ {l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x # l} = {[x]} @@ {l}", "by (simp add: conc_def)"], ["proof (state)\nthis:\n  {x # l} = {[x]} @@ {l}\n\ngoal (1 subgoal):\n 1. \\<And>a u. regular {u} \\<Longrightarrow> regular {a # u}", "then"], ["proof (chain)\npicking this:\n  {x # l} = {[x]} @@ {l}", "show ?case"], ["proof (prove)\nusing this:\n  {x # l} = {[x]} @@ {l}\n\ngoal (1 subgoal):\n 1. regular {x # l}", "by (simp add: Cons.IH regular_conc regular_singstr)"], ["proof (state)\nthis:\n  regular {x # l}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>All finite sets are regular.\\<close>"], ["", "theorem regular_finite: \"finite L \\<Longrightarrow> regular L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite L \\<Longrightarrow> regular L", "apply (induct L rule: finite.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. regular {}\n 2. \\<And>A a.\n       \\<lbrakk>finite A; regular A\\<rbrakk>\n       \\<Longrightarrow> regular (insert a A)", "apply (simp add: regular_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A; regular A\\<rbrakk>\n       \\<Longrightarrow> regular (insert a A)", "using regular_Un regular_word"], ["proof (prove)\nusing this:\n  \\<lbrakk>regular ?S; regular ?T\\<rbrakk>\n  \\<Longrightarrow> regular (?S \\<union> ?T)\n  regular {?u}\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A; regular A\\<rbrakk>\n       \\<Longrightarrow> regular (insert a A)", "by fastforce"], ["", "subsection\\<open>The Kleene Star of a Language\\<close>"], ["", "theorem regular_star:\n  assumes S: \"regular S\" shows \"regular (star S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (star S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (star S)", "obtain MS where M: \"dfa MS\" and lang: \"dfa.language MS = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>MS.\n        \\<lbrakk>dfa MS; dfa.language MS = S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using S"], ["proof (prove)\nusing this:\n  regular S\n\ngoal (1 subgoal):\n 1. (\\<And>MS.\n        \\<lbrakk>dfa MS; dfa.language MS = S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: regular_def)"], ["proof (state)\nthis:\n  dfa MS\n  dfa.language MS = S\n\ngoal (1 subgoal):\n 1. regular (star S)", "note [simp] = dfa.init [OF M] dfa.nextl.simps [OF M] dfa.nextl_snoc [OF M]"], ["proof (state)\nthis:\n  dfa.init MS \\<in> dfa.states MS\n  dfa.nextl MS ?q [] = ?q\n  dfa.nextl MS ?q (?x # ?xs) = dfa.nextl MS (dfa.nxt MS ?q ?x) ?xs\n  dfa.nextl MS ?q (?xs @ [?x]) = dfa.nxt MS (dfa.nextl MS ?q ?xs) ?x\n\ngoal (1 subgoal):\n 1. regular (star S)", "obtain q0 where q0: \"q0 \\<notin> dfa.states MS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q0.\n        q0 \\<notin> dfa.states MS \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using dfa.finite [OF M]"], ["proof (prove)\nusing this:\n  finite (dfa.states MS)\n\ngoal (1 subgoal):\n 1. (\\<And>q0.\n        q0 \\<notin> dfa.states MS \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis hdomain_not_mem hfset_HF hmem_def)"], ["proof (state)\nthis:\n  q0 \\<notin> dfa.states MS\n\ngoal (1 subgoal):\n 1. regular (star S)", "have [simp]: \"q0 \\<noteq> dfa.init MS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q0 \\<noteq> dfa.init MS", "using M dfa.init q0"], ["proof (prove)\nusing this:\n  dfa MS\n  dfa ?M \\<Longrightarrow> dfa.init ?M \\<in> dfa.states ?M\n  q0 \\<notin> dfa.states MS\n\ngoal (1 subgoal):\n 1. q0 \\<noteq> dfa.init MS", "by blast"], ["proof (state)\nthis:\n  q0 \\<noteq> dfa.init MS\n\ngoal (1 subgoal):\n 1. regular (star S)", "have [simp]: \"\\<And>q x. q \\<in> dfa.states MS \\<Longrightarrow> q0 \\<noteq> dfa.nxt MS q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q x.\n       q \\<in> dfa.states MS \\<Longrightarrow> q0 \\<noteq> dfa.nxt MS q x", "using M dfa.nxt q0"], ["proof (prove)\nusing this:\n  dfa MS\n  \\<lbrakk>dfa ?M; ?q \\<in> dfa.states ?M\\<rbrakk>\n  \\<Longrightarrow> dfa.nxt ?M ?q ?x \\<in> dfa.states ?M\n  q0 \\<notin> dfa.states MS\n\ngoal (1 subgoal):\n 1. \\<And>q x.\n       q \\<in> dfa.states MS \\<Longrightarrow> q0 \\<noteq> dfa.nxt MS q x", "by fastforce"], ["proof (state)\nthis:\n  ?q \\<in> dfa.states MS \\<Longrightarrow> q0 \\<noteq> dfa.nxt MS ?q ?x\n\ngoal (1 subgoal):\n 1. regular (star S)", "have [simp]: \"\\<And>q u. q \\<in> dfa.states MS \\<Longrightarrow> q0 \\<noteq> dfa.nextl MS q u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q u.\n       q \\<in> dfa.states MS \\<Longrightarrow> q0 \\<noteq> dfa.nextl MS q u", "using M dfa.nextl_state q0"], ["proof (prove)\nusing this:\n  dfa MS\n  \\<lbrakk>dfa ?M; ?q \\<in> dfa.states ?M\\<rbrakk>\n  \\<Longrightarrow> dfa.nextl ?M ?q ?xs \\<in> dfa.states ?M\n  q0 \\<notin> dfa.states MS\n\ngoal (1 subgoal):\n 1. \\<And>q u.\n       q \\<in> dfa.states MS \\<Longrightarrow> q0 \\<noteq> dfa.nextl MS q u", "by blast"], ["proof (state)\nthis:\n  ?q \\<in> dfa.states MS \\<Longrightarrow> q0 \\<noteq> dfa.nextl MS ?q ?u\n\ngoal (1 subgoal):\n 1. regular (star S)", "let ?ST = \"\\<lparr>nfa.states = insert q0 (dfa.states MS),\n                   init  = {q0},\n                   final = {q0},\n                   nxt   = \\<lambda>q x. if q \\<in> dfa.states MS then {dfa.nxt MS q x} else {},\n                   eps   = insert (q0, dfa.init MS) (((\\<lambda>q. (q, q0)) ` (dfa.final MS)))\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. regular (star S)", "interpret ST: nfa ?ST"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa \\<lparr>nfa.states = insert q0 (dfa.states MS), init = {q0},\n           final = {q0},\n           nxt =\n             \\<lambda>q x.\n                if q \\<in> dfa.states MS then {dfa.nxt MS q x} else {},\n           eps =\n             insert (q0, dfa.init MS)\n              ((\\<lambda>q. (q, q0)) ` dfa.final MS)\\<rparr>", "using M dfa.final"], ["proof (prove)\nusing this:\n  dfa MS\n  dfa ?M \\<Longrightarrow> dfa.final ?M \\<subseteq> dfa.states ?M\n\ngoal (1 subgoal):\n 1. nfa \\<lparr>nfa.states = insert q0 (dfa.states MS), init = {q0},\n           final = {q0},\n           nxt =\n             \\<lambda>q x.\n                if q \\<in> dfa.states MS then {dfa.nxt MS q x} else {},\n           eps =\n             insert (q0, dfa.init MS)\n              ((\\<lambda>q. (q, q0)) ` dfa.final MS)\\<rparr>", "by (auto simp: q0 nfa_def dfa.init dfa.finite dfa.nxt)"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (star S)", "have \"\\<And>x y. (x, y) \\<in> (insert (q0, dfa.init MS) ((\\<lambda>q. (q, q0)) ` dfa.final MS))\\<^sup>* \\<longleftrightarrow>\n                 (x=y) \\<or> (x = q0 \\<and> y = dfa.init MS) \\<or>\n                 (x \\<in> dfa.final MS \\<and> y \\<in> {q0, dfa.init MS})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       ((x, y)\n        \\<in> (insert (q0, dfa.init MS)\n                ((\\<lambda>q. (q, q0)) ` dfa.final MS))\\<^sup>*) =\n       (x = y \\<or>\n        x = q0 \\<and> y = dfa.init MS \\<or>\n        x \\<in> dfa.final MS \\<and> y \\<in> {q0, dfa.init MS})", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> (insert (q0, dfa.init MS)\n               ((\\<lambda>q. (q, q0)) `\n                dfa.final MS))\\<^sup>* \\<Longrightarrow>\n       x = y \\<or>\n       x = q0 \\<and> y = dfa.init MS \\<or>\n       x \\<in> dfa.final MS \\<and> y \\<in> {q0, dfa.init MS}\n 2. \\<And>x y.\n       x = y \\<or>\n       x = q0 \\<and> y = dfa.init MS \\<or>\n       x \\<in> dfa.final MS \\<and>\n       y \\<in> {q0, dfa.init MS} \\<Longrightarrow>\n       (x, y)\n       \\<in> (insert (q0, dfa.init MS)\n               ((\\<lambda>q. (q, q0)) ` dfa.final MS))\\<^sup>*", "apply (erule rtrancl_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       x = x \\<or>\n       x = q0 \\<and> x = dfa.init MS \\<or>\n       x \\<in> dfa.final MS \\<and> x \\<in> {q0, dfa.init MS}\n 2. \\<And>x y ya z.\n       \\<lbrakk>(x, ya)\n                \\<in> (insert (q0, dfa.init MS)\n                        ((\\<lambda>q. (q, q0)) ` dfa.final MS))\\<^sup>*;\n        (ya, z)\n        \\<in> insert (q0, dfa.init MS)\n               ((\\<lambda>q. (q, q0)) ` dfa.final MS);\n        x = ya \\<or>\n        x = q0 \\<and> ya = dfa.init MS \\<or>\n        x \\<in> dfa.final MS \\<and> ya \\<in> {q0, dfa.init MS}\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or>\n                         x = q0 \\<and> z = dfa.init MS \\<or>\n                         x \\<in> dfa.final MS \\<and>\n                         z \\<in> {q0, dfa.init MS}\n 3. \\<And>x y.\n       x = y \\<or>\n       x = q0 \\<and> y = dfa.init MS \\<or>\n       x \\<in> dfa.final MS \\<and>\n       y \\<in> {q0, dfa.init MS} \\<Longrightarrow>\n       (x, y)\n       \\<in> (insert (q0, dfa.init MS)\n               ((\\<lambda>q. (q, q0)) ` dfa.final MS))\\<^sup>*", "apply (auto intro: rtrancl.rtrancl_into_rtrancl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((?x, ?y)\n   \\<in> (insert (q0, dfa.init MS)\n           ((\\<lambda>q. (q, q0)) ` dfa.final MS))\\<^sup>*) =\n  (?x = ?y \\<or>\n   ?x = q0 \\<and> ?y = dfa.init MS \\<or>\n   ?x \\<in> dfa.final MS \\<and> ?y \\<in> {q0, dfa.init MS})\n\ngoal (1 subgoal):\n 1. regular (star S)", "then"], ["proof (chain)\npicking this:\n  ((?x, ?y)\n   \\<in> (insert (q0, dfa.init MS)\n           ((\\<lambda>q. (q, q0)) ` dfa.final MS))\\<^sup>*) =\n  (?x = ?y \\<or>\n   ?x = q0 \\<and> ?y = dfa.init MS \\<or>\n   ?x \\<in> dfa.final MS \\<and> ?y \\<in> {q0, dfa.init MS})", "have eps_iff:\n    \"\\<And>q Q. q \\<in> ST.epsclo Q \\<longleftrightarrow>\n                 q \\<in> Q \\<inter> insert q0 (dfa.states MS) \\<or>\n                 (q = q0 \\<and> dfa.final MS \\<inter> Q \\<noteq> {}) \\<or>\n                 (q = dfa.init MS \\<and> insert q0 (dfa.final MS) \\<inter> Q \\<noteq> {})\""], ["proof (prove)\nusing this:\n  ((?x, ?y)\n   \\<in> (insert (q0, dfa.init MS)\n           ((\\<lambda>q. (q, q0)) ` dfa.final MS))\\<^sup>*) =\n  (?x = ?y \\<or>\n   ?x = q0 \\<and> ?y = dfa.init MS \\<or>\n   ?x \\<in> dfa.final MS \\<and> ?y \\<in> {q0, dfa.init MS})\n\ngoal (1 subgoal):\n 1. \\<And>q Q.\n       (q \\<in> ST.epsclo Q) =\n       (q \\<in> Q \\<inter> insert q0 (dfa.states MS) \\<or>\n        q = q0 \\<and> dfa.final MS \\<inter> Q \\<noteq> {} \\<or>\n        q = dfa.init MS \\<and>\n        insert q0 (dfa.final MS) \\<inter> Q \\<noteq> {})", "by (auto simp: q0 ST.epsclo_def)"], ["proof (state)\nthis:\n  (?q \\<in> ST.epsclo ?Q) =\n  (?q \\<in> ?Q \\<inter> insert q0 (dfa.states MS) \\<or>\n   ?q = q0 \\<and> dfa.final MS \\<inter> ?Q \\<noteq> {} \\<or>\n   ?q = dfa.init MS \\<and> insert q0 (dfa.final MS) \\<inter> ?Q \\<noteq> {})\n\ngoal (1 subgoal):\n 1. regular (star S)", "{"], ["proof (state)\nthis:\n  (?q \\<in> ST.epsclo ?Q) =\n  (?q \\<in> ?Q \\<inter> insert q0 (dfa.states MS) \\<or>\n   ?q = q0 \\<and> dfa.final MS \\<inter> ?Q \\<noteq> {} \\<or>\n   ?q = dfa.init MS \\<and> insert q0 (dfa.final MS) \\<inter> ?Q \\<noteq> {})\n\ngoal (1 subgoal):\n 1. regular (star S)", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (star S)", "have \"dfa.nextl MS (dfa.init MS) u \\<in> ST.nextl {q0} u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.nextl MS (dfa.init MS) u \\<in> ST.nextl {q0} u", "proof (induct u rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. dfa.nextl MS (dfa.init MS) [] \\<in> ST.nextl {q0} []\n 2. \\<And>x xs.\n       dfa.nextl MS (dfa.init MS) xs\n       \\<in> ST.nextl {q0} xs \\<Longrightarrow>\n       dfa.nextl MS (dfa.init MS) (xs @ [x]) \\<in> ST.nextl {q0} (xs @ [x])", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. dfa.nextl MS (dfa.init MS) [] \\<in> ST.nextl {q0} []\n 2. \\<And>x xs.\n       dfa.nextl MS (dfa.init MS) xs\n       \\<in> ST.nextl {q0} xs \\<Longrightarrow>\n       dfa.nextl MS (dfa.init MS) (xs @ [x]) \\<in> ST.nextl {q0} (xs @ [x])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.nextl MS (dfa.init MS) [] \\<in> ST.nextl {q0} []", "by (auto simp: M eps_iff)"], ["proof (state)\nthis:\n  dfa.nextl MS (dfa.init MS) [] \\<in> ST.nextl {q0} []\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       dfa.nextl MS (dfa.init MS) xs\n       \\<in> ST.nextl {q0} xs \\<Longrightarrow>\n       dfa.nextl MS (dfa.init MS) (xs @ [x]) \\<in> ST.nextl {q0} (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       dfa.nextl MS (dfa.init MS) xs\n       \\<in> ST.nextl {q0} xs \\<Longrightarrow>\n       dfa.nextl MS (dfa.init MS) (xs @ [x]) \\<in> ST.nextl {q0} (xs @ [x])", "case (snoc x u)"], ["proof (state)\nthis:\n  dfa.nextl MS (dfa.init MS) u \\<in> ST.nextl {q0} u\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       dfa.nextl MS (dfa.init MS) xs\n       \\<in> ST.nextl {q0} xs \\<Longrightarrow>\n       dfa.nextl MS (dfa.init MS) (xs @ [x]) \\<in> ST.nextl {q0} (xs @ [x])", "then"], ["proof (chain)\npicking this:\n  dfa.nextl MS (dfa.init MS) u \\<in> ST.nextl {q0} u", "show ?case"], ["proof (prove)\nusing this:\n  dfa.nextl MS (dfa.init MS) u \\<in> ST.nextl {q0} u\n\ngoal (1 subgoal):\n 1. dfa.nextl MS (dfa.init MS) (u @ [x]) \\<in> ST.nextl {q0} (u @ [x])", "using M q0"], ["proof (prove)\nusing this:\n  dfa.nextl MS (dfa.init MS) u \\<in> ST.nextl {q0} u\n  dfa MS\n  q0 \\<notin> dfa.states MS\n\ngoal (1 subgoal):\n 1. dfa.nextl MS (dfa.init MS) (u @ [x]) \\<in> ST.nextl {q0} (u @ [x])", "apply (simp add: eps_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dfa.nextl MS (dfa.init MS) u \\<in> ST.nextl {q0} u; dfa MS;\n     q0 \\<notin> dfa.states MS\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>ST.nextl {q0} u.\n                         (xa \\<in> dfa.states MS \\<longrightarrow>\n                          dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x =\n                          dfa.nxt MS xa x \\<and>\n                          dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x\n                          \\<in> dfa.states MS \\<or>\n                          dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x =\n                          q0 \\<and>\n                          dfa.nxt MS xa x \\<in> dfa.final MS \\<or>\n                          dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x =\n                          dfa.init MS \\<and>\n                          dfa.nxt MS xa x \\<in> dfa.final MS) \\<and>\n                         xa \\<in> dfa.states MS", "apply (rule bexI [where x=\"dfa.nextl MS (dfa.init MS) u\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dfa.nextl MS (dfa.init MS) u \\<in> ST.nextl {q0} u; dfa MS;\n     q0 \\<notin> dfa.states MS\\<rbrakk>\n    \\<Longrightarrow> (dfa.nextl MS (dfa.init MS) u\n                       \\<in> dfa.states MS \\<longrightarrow>\n                       dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x =\n                       dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x \\<and>\n                       dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x\n                       \\<in> dfa.states MS \\<or>\n                       dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x =\n                       q0 \\<and>\n                       dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x\n                       \\<in> dfa.final MS \\<or>\n                       dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x =\n                       dfa.init MS \\<and>\n                       dfa.nxt MS (dfa.nextl MS (dfa.init MS) u) x\n                       \\<in> dfa.final MS) \\<and>\n                      dfa.nextl MS (dfa.init MS) u \\<in> dfa.states MS\n 2. \\<lbrakk>dfa.nextl MS (dfa.init MS) u \\<in> ST.nextl {q0} u; dfa MS;\n     q0 \\<notin> dfa.states MS\\<rbrakk>\n    \\<Longrightarrow> dfa.nextl MS (dfa.init MS) u \\<in> ST.nextl {q0} u", "apply (auto simp: dfa.nextl_init_state dfa.nxt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dfa.nextl MS (dfa.init MS) (u @ [x]) \\<in> ST.nextl {q0} (u @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dfa.nextl MS (dfa.init MS) u \\<in> ST.nextl {q0} u\n\ngoal (1 subgoal):\n 1. regular (star S)", "}"], ["proof (state)\nthis:\n  dfa.nextl MS (dfa.init MS) ?u2 \\<in> ST.nextl {q0} ?u2\n\ngoal (1 subgoal):\n 1. regular (star S)", "note dfa_in_ST = this"], ["proof (state)\nthis:\n  dfa.nextl MS (dfa.init MS) ?u2 \\<in> ST.nextl {q0} ?u2\n\ngoal (1 subgoal):\n 1. regular (star S)", "{"], ["proof (state)\nthis:\n  dfa.nextl MS (dfa.init MS) ?u2 \\<in> ST.nextl {q0} ?u2\n\ngoal (1 subgoal):\n 1. regular (star S)", "fix ustar"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (star S)", "assume \"ustar \\<in> star (dfa.language MS)\""], ["proof (state)\nthis:\n  ustar \\<in> star (dfa.language MS)\n\ngoal (1 subgoal):\n 1. regular (star S)", "then"], ["proof (chain)\npicking this:\n  ustar \\<in> star (dfa.language MS)", "have \"q0 \\<in> ST.nextl {q0} ustar\""], ["proof (prove)\nusing this:\n  ustar \\<in> star (dfa.language MS)\n\ngoal (1 subgoal):\n 1. q0 \\<in> ST.nextl {q0} ustar", "proof (induct rule: star_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. q0 \\<in> ST.nextl {q0} []\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> dfa.language MS; v \\<in> star (dfa.language MS);\n        q0 \\<in> ST.nextl {q0} v\\<rbrakk>\n       \\<Longrightarrow> q0 \\<in> ST.nextl {q0} (u @ v)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. q0 \\<in> ST.nextl {q0} []\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> dfa.language MS; v \\<in> star (dfa.language MS);\n        q0 \\<in> ST.nextl {q0} v\\<rbrakk>\n       \\<Longrightarrow> q0 \\<in> ST.nextl {q0} (u @ v)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. q0 \\<in> ST.nextl {q0} []", "by (auto simp: eps_iff)"], ["proof (state)\nthis:\n  q0 \\<in> ST.nextl {q0} []\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> dfa.language MS; v \\<in> star (dfa.language MS);\n        q0 \\<in> ST.nextl {q0} v\\<rbrakk>\n       \\<Longrightarrow> q0 \\<in> ST.nextl {q0} (u @ v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> dfa.language MS; v \\<in> star (dfa.language MS);\n        q0 \\<in> ST.nextl {q0} v\\<rbrakk>\n       \\<Longrightarrow> q0 \\<in> ST.nextl {q0} (u @ v)", "case (append u v)"], ["proof (state)\nthis:\n  u \\<in> dfa.language MS\n  v \\<in> star (dfa.language MS)\n  q0 \\<in> ST.nextl {q0} v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> dfa.language MS; v \\<in> star (dfa.language MS);\n        q0 \\<in> ST.nextl {q0} v\\<rbrakk>\n       \\<Longrightarrow> q0 \\<in> ST.nextl {q0} (u @ v)", "then"], ["proof (chain)\npicking this:\n  u \\<in> dfa.language MS\n  v \\<in> star (dfa.language MS)\n  q0 \\<in> ST.nextl {q0} v", "have \"dfa.nextl MS (dfa.init MS) u \\<in> dfa.final MS\""], ["proof (prove)\nusing this:\n  u \\<in> dfa.language MS\n  v \\<in> star (dfa.language MS)\n  q0 \\<in> ST.nextl {q0} v\n\ngoal (1 subgoal):\n 1. dfa.nextl MS (dfa.init MS) u \\<in> dfa.final MS", "by (simp add: M dfa.language_def)"], ["proof (state)\nthis:\n  dfa.nextl MS (dfa.init MS) u \\<in> dfa.final MS\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> dfa.language MS; v \\<in> star (dfa.language MS);\n        q0 \\<in> ST.nextl {q0} v\\<rbrakk>\n       \\<Longrightarrow> q0 \\<in> ST.nextl {q0} (u @ v)", "then"], ["proof (chain)\npicking this:\n  dfa.nextl MS (dfa.init MS) u \\<in> dfa.final MS", "have \"q0 \\<in> ST.nextl {q0} u\""], ["proof (prove)\nusing this:\n  dfa.nextl MS (dfa.init MS) u \\<in> dfa.final MS\n\ngoal (1 subgoal):\n 1. q0 \\<in> ST.nextl {q0} u", "by (auto intro: ST.nextl_eps dfa_in_ST)"], ["proof (state)\nthis:\n  q0 \\<in> ST.nextl {q0} u\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> dfa.language MS; v \\<in> star (dfa.language MS);\n        q0 \\<in> ST.nextl {q0} v\\<rbrakk>\n       \\<Longrightarrow> q0 \\<in> ST.nextl {q0} (u @ v)", "then"], ["proof (chain)\npicking this:\n  q0 \\<in> ST.nextl {q0} u", "show ?case"], ["proof (prove)\nusing this:\n  q0 \\<in> ST.nextl {q0} u\n\ngoal (1 subgoal):\n 1. q0 \\<in> ST.nextl {q0} (u @ v)", "using append ST.nextl_mono"], ["proof (prove)\nusing this:\n  q0 \\<in> ST.nextl {q0} u\n  u \\<in> dfa.language MS\n  v \\<in> star (dfa.language MS)\n  q0 \\<in> ST.nextl {q0} v\n  ?Q' \\<subseteq> ?Q \\<Longrightarrow>\n  ST.nextl ?Q' ?u \\<subseteq> ST.nextl ?Q ?u\n\ngoal (1 subgoal):\n 1. q0 \\<in> ST.nextl {q0} (u @ v)", "by (clarsimp simp add: ST.nextl_app) blast"], ["proof (state)\nthis:\n  q0 \\<in> ST.nextl {q0} (u @ v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q0 \\<in> ST.nextl {q0} ustar\n\ngoal (1 subgoal):\n 1. regular (star S)", "}"], ["proof (state)\nthis:\n  ?ustar2 \\<in> star (dfa.language MS) \\<Longrightarrow>\n  q0 \\<in> ST.nextl {q0} ?ustar2\n\ngoal (1 subgoal):\n 1. regular (star S)", "note star_dfa_in_ST = this"], ["proof (state)\nthis:\n  ?ustar2 \\<in> star (dfa.language MS) \\<Longrightarrow>\n  q0 \\<in> ST.nextl {q0} ?ustar2\n\ngoal (1 subgoal):\n 1. regular (star S)", "{"], ["proof (state)\nthis:\n  ?ustar2 \\<in> star (dfa.language MS) \\<Longrightarrow>\n  q0 \\<in> ST.nextl {q0} ?ustar2\n\ngoal (1 subgoal):\n 1. regular (star S)", "fix u q"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (star S)", "assume \"q \\<in> ST.nextl {q0} u\""], ["proof (state)\nthis:\n  q \\<in> ST.nextl {q0} u\n\ngoal (1 subgoal):\n 1. regular (star S)", "then"], ["proof (chain)\npicking this:\n  q \\<in> ST.nextl {q0} u", "have  \"q = q0 \\<and> u=[] \\<or>\n                (\\<exists>u1 u2. u = u1@u2 \\<and> u1 \\<in> star (dfa.language MS) \\<and>\n                  (q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2}))\""], ["proof (prove)\nusing this:\n  q \\<in> ST.nextl {q0} u\n\ngoal (1 subgoal):\n 1. q = q0 \\<and> u = [] \\<or>\n    (\\<exists>u1 u2.\n        u = u1 @ u2 \\<and>\n        u1 \\<in> star (dfa.language MS) \\<and>\n        q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})", "proof (induction u arbitrary: q rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       q \\<in> ST.nextl {q0} [] \\<Longrightarrow>\n       q = q0 \\<and> [] = [] \\<or>\n       (\\<exists>u1 u2.\n           [] = u1 @ u2 \\<and>\n           u1 \\<in> star (dfa.language MS) \\<and>\n           q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})\n 2. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> ST.nextl {q0} xs \\<Longrightarrow>\n                   q = q0 \\<and> xs = [] \\<or>\n                   (\\<exists>u1 u2.\n                       xs = u1 @ u2 \\<and>\n                       u1 \\<in> star (dfa.language MS) \\<and>\n                       q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2});\n        q \\<in> ST.nextl {q0} (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> q = q0 \\<and> xs @ [x] = [] \\<or>\n                         (\\<exists>u1 u2.\n                             xs @ [x] = u1 @ u2 \\<and>\n                             u1 \\<in> star (dfa.language MS) \\<and>\n                             q \\<in> ST.epsclo\n{dfa.nextl MS (dfa.init MS) u2})", "case Nil"], ["proof (state)\nthis:\n  q \\<in> ST.nextl {q0} []\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q \\<in> ST.nextl {q0} [] \\<Longrightarrow>\n       q = q0 \\<and> [] = [] \\<or>\n       (\\<exists>u1 u2.\n           [] = u1 @ u2 \\<and>\n           u1 \\<in> star (dfa.language MS) \\<and>\n           q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})\n 2. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> ST.nextl {q0} xs \\<Longrightarrow>\n                   q = q0 \\<and> xs = [] \\<or>\n                   (\\<exists>u1 u2.\n                       xs = u1 @ u2 \\<and>\n                       u1 \\<in> star (dfa.language MS) \\<and>\n                       q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2});\n        q \\<in> ST.nextl {q0} (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> q = q0 \\<and> xs @ [x] = [] \\<or>\n                         (\\<exists>u1 u2.\n                             xs @ [x] = u1 @ u2 \\<and>\n                             u1 \\<in> star (dfa.language MS) \\<and>\n                             q \\<in> ST.epsclo\n{dfa.nextl MS (dfa.init MS) u2})", "then"], ["proof (chain)\npicking this:\n  q \\<in> ST.nextl {q0} []", "show ?case"], ["proof (prove)\nusing this:\n  q \\<in> ST.nextl {q0} []\n\ngoal (1 subgoal):\n 1. q = q0 \\<and> [] = [] \\<or>\n    (\\<exists>u1 u2.\n        [] = u1 @ u2 \\<and>\n        u1 \\<in> star (dfa.language MS) \\<and>\n        q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})", "by (auto simp: M  dfa.init eps_iff)"], ["proof (state)\nthis:\n  q = q0 \\<and> [] = [] \\<or>\n  (\\<exists>u1 u2.\n      [] = u1 @ u2 \\<and>\n      u1 \\<in> star (dfa.language MS) \\<and>\n      q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> ST.nextl {q0} xs \\<Longrightarrow>\n                   q = q0 \\<and> xs = [] \\<or>\n                   (\\<exists>u1 u2.\n                       xs = u1 @ u2 \\<and>\n                       u1 \\<in> star (dfa.language MS) \\<and>\n                       q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2});\n        q \\<in> ST.nextl {q0} (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> q = q0 \\<and> xs @ [x] = [] \\<or>\n                         (\\<exists>u1 u2.\n                             xs @ [x] = u1 @ u2 \\<and>\n                             u1 \\<in> star (dfa.language MS) \\<and>\n                             q \\<in> ST.epsclo\n{dfa.nextl MS (dfa.init MS) u2})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> ST.nextl {q0} xs \\<Longrightarrow>\n                   q = q0 \\<and> xs = [] \\<or>\n                   (\\<exists>u1 u2.\n                       xs = u1 @ u2 \\<and>\n                       u1 \\<in> star (dfa.language MS) \\<and>\n                       q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2});\n        q \\<in> ST.nextl {q0} (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> q = q0 \\<and> xs @ [x] = [] \\<or>\n                         (\\<exists>u1 u2.\n                             xs @ [x] = u1 @ u2 \\<and>\n                             u1 \\<in> star (dfa.language MS) \\<and>\n                             q \\<in> ST.epsclo\n{dfa.nextl MS (dfa.init MS) u2})", "case (snoc x u)"], ["proof (state)\nthis:\n  ?q \\<in> ST.nextl {q0} u \\<Longrightarrow>\n  ?q = q0 \\<and> u = [] \\<or>\n  (\\<exists>u1 u2.\n      u = u1 @ u2 \\<and>\n      u1 \\<in> star (dfa.language MS) \\<and>\n      ?q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})\n  q \\<in> ST.nextl {q0} (u @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> ST.nextl {q0} xs \\<Longrightarrow>\n                   q = q0 \\<and> xs = [] \\<or>\n                   (\\<exists>u1 u2.\n                       xs = u1 @ u2 \\<and>\n                       u1 \\<in> star (dfa.language MS) \\<and>\n                       q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2});\n        q \\<in> ST.nextl {q0} (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> q = q0 \\<and> xs @ [x] = [] \\<or>\n                         (\\<exists>u1 u2.\n                             xs @ [x] = u1 @ u2 \\<and>\n                             u1 \\<in> star (dfa.language MS) \\<and>\n                             q \\<in> ST.epsclo\n{dfa.nextl MS (dfa.init MS) u2})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. q = q0 \\<and> u @ [x] = [] \\<or>\n    (\\<exists>u1 u2.\n        u @ [x] = u1 @ u2 \\<and>\n        u1 \\<in> star (dfa.language MS) \\<and>\n        q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})", "using snoc.prems q0 M"], ["proof (prove)\nusing this:\n  q \\<in> ST.nextl {q0} (u @ [x])\n  q0 \\<notin> dfa.states MS\n  dfa MS\n\ngoal (1 subgoal):\n 1. q = q0 \\<and> u @ [x] = [] \\<or>\n    (\\<exists>u1 u2.\n        u @ [x] = u1 @ u2 \\<and>\n        u1 \\<in> star (dfa.language MS) \\<and>\n        q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})", "apply (auto split: if_split_asm simp: dfa.language_def eps_iff\n                    dest!: snoc.IH)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.states MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x \\<in> dfa.states MS;\n        q = dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x =\n                             q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x =\n                             dfa.init MS \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)\n 2. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.states MS;\n        q = dfa.nxt MS (dfa.init MS) x;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.nxt MS (dfa.init MS) x =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.nxt MS (dfa.init MS) x = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nxt MS (dfa.init MS) x = dfa.init MS \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)\n 3. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.states MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x \\<in> dfa.final MS;\n        q = q0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            dfa.nextl MS (dfa.init MS) u2a\n                            \\<in> dfa.final MS\n 4. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = q0;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            dfa.nextl MS (dfa.init MS) u2a\n                            \\<in> dfa.final MS\n 5. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.states MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x \\<in> dfa.final MS;\n        q = dfa.init MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)\n 6. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = dfa.init MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)", "apply (metis dfa.nextl_snoc)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.states MS;\n        q = dfa.nxt MS (dfa.init MS) x;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.nxt MS (dfa.init MS) x =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.nxt MS (dfa.init MS) x = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nxt MS (dfa.init MS) x = dfa.init MS \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)\n 2. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.states MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x \\<in> dfa.final MS;\n        q = q0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            dfa.nextl MS (dfa.init MS) u2a\n                            \\<in> dfa.final MS\n 3. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = q0;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            dfa.nextl MS (dfa.init MS) u2a\n                            \\<in> dfa.final MS\n 4. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.states MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x \\<in> dfa.final MS;\n        q = dfa.init MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)\n 5. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = dfa.init MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)", "apply (rename_tac u1 u2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.states MS;\n        q = dfa.nxt MS (dfa.init MS) x;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.nxt MS (dfa.init MS) x =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.nxt MS (dfa.init MS) x = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nxt MS (dfa.init MS) x = dfa.init MS \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)\n 2. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.states MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x \\<in> dfa.final MS;\n        q = q0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            dfa.nextl MS (dfa.init MS) u2a\n                            \\<in> dfa.final MS\n 3. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = q0;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            dfa.nextl MS (dfa.init MS) u2a\n                            \\<in> dfa.final MS\n 4. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.states MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x \\<in> dfa.final MS;\n        q = dfa.init MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)\n 5. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = dfa.init MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)", "apply (rule_tac x=\"u1@u2\" in exI, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.states MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x \\<in> dfa.final MS;\n        q = q0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            dfa.nextl MS (dfa.init MS) u2a\n                            \\<in> dfa.final MS\n 2. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = q0;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            dfa.nextl MS (dfa.init MS) u2a\n                            \\<in> dfa.final MS\n 3. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.states MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x \\<in> dfa.final MS;\n        q = dfa.init MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)\n 4. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = dfa.init MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)", "apply (rule_tac x = u1 in exI, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = q0;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            dfa.nextl MS (dfa.init MS) u2a\n                            \\<in> dfa.final MS\n 2. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.states MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x \\<in> dfa.final MS;\n        q = dfa.init MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)\n 3. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = dfa.init MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)", "apply (rule_tac x=\"u1@u2\" in exI, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.states MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.nextl MS (dfa.init MS) u2) x \\<in> dfa.final MS;\n        q = dfa.init MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)\n 2. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = dfa.init MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)", "apply (rule_tac x=\"u1@u2@[x]\" in exI, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u1 u2.\n       \\<lbrakk>q0 \\<notin> dfa.states MS; dfa MS; u = u1 @ u2;\n        u1 \\<in> star\n                  {xs. dfa.nextl MS (dfa.init MS) xs \\<in> dfa.final MS};\n        dfa.nxt MS (dfa.init MS) x \\<in> dfa.final MS; q = dfa.init MS;\n        dfa.nextl MS (dfa.init MS) u2 \\<in> dfa.final MS\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u1a u2a.\n                            u1 @ u2 @ [x] = u1a @ u2a \\<and>\n                            u1a\n                            \\<in> star\n                                   {xs.\n                                    dfa.nextl MS (dfa.init MS) xs\n                                    \\<in> dfa.final MS} \\<and>\n                            (dfa.init MS =\n                             dfa.nextl MS (dfa.init MS) u2a \\<or>\n                             dfa.init MS = q0 \\<and>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS \\<or>\n                             dfa.nextl MS (dfa.init MS) u2a\n                             \\<in> dfa.final MS)", "apply (rule_tac x=\"u1@u2@[x]\" in exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  q = q0 \\<and> u @ [x] = [] \\<or>\n  (\\<exists>u1 u2.\n      u @ [x] = u1 @ u2 \\<and>\n      u1 \\<in> star (dfa.language MS) \\<and>\n      q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q = q0 \\<and> u = [] \\<or>\n  (\\<exists>u1 u2.\n      u = u1 @ u2 \\<and>\n      u1 \\<in> star (dfa.language MS) \\<and>\n      q \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})\n\ngoal (1 subgoal):\n 1. regular (star S)", "}"], ["proof (state)\nthis:\n  ?q2 \\<in> ST.nextl {q0} ?u2 \\<Longrightarrow>\n  ?q2 = q0 \\<and> ?u2 = [] \\<or>\n  (\\<exists>u1 u2.\n      ?u2 = u1 @ u2 \\<and>\n      u1 \\<in> star (dfa.language MS) \\<and>\n      ?q2 \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})\n\ngoal (1 subgoal):\n 1. regular (star S)", "note in_ST_imp = this"], ["proof (state)\nthis:\n  ?q2 \\<in> ST.nextl {q0} ?u2 \\<Longrightarrow>\n  ?q2 = q0 \\<and> ?u2 = [] \\<or>\n  (\\<exists>u1 u2.\n      ?u2 = u1 @ u2 \\<and>\n      u1 \\<in> star (dfa.language MS) \\<and>\n      ?q2 \\<in> ST.epsclo {dfa.nextl MS (dfa.init MS) u2})\n\ngoal (1 subgoal):\n 1. regular (star S)", "have \"\\<And>u. q0 \\<in> ST.nextl {q0} u \\<Longrightarrow> u \\<in> star (dfa.language MS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       q0 \\<in> ST.nextl {q0} u \\<Longrightarrow>\n       u \\<in> star (dfa.language MS)", "by (auto simp: M dfa.init dfa.language_def eps_iff dest: in_ST_imp)"], ["proof (state)\nthis:\n  q0 \\<in> ST.nextl {q0} ?u \\<Longrightarrow>\n  ?u \\<in> star (dfa.language MS)\n\ngoal (1 subgoal):\n 1. regular (star S)", "then"], ["proof (chain)\npicking this:\n  q0 \\<in> ST.nextl {q0} ?u \\<Longrightarrow>\n  ?u \\<in> star (dfa.language MS)", "have eq_L: \"ST.language = star S\""], ["proof (prove)\nusing this:\n  q0 \\<in> ST.nextl {q0} ?u \\<Longrightarrow>\n  ?u \\<in> star (dfa.language MS)\n\ngoal (1 subgoal):\n 1. ST.language = star S", "using lang"], ["proof (prove)\nusing this:\n  q0 \\<in> ST.nextl {q0} ?u \\<Longrightarrow>\n  ?u \\<in> star (dfa.language MS)\n  dfa.language MS = S\n\ngoal (1 subgoal):\n 1. ST.language = star S", "by (auto simp: ST.language_def star_dfa_in_ST)"], ["proof (state)\nthis:\n  ST.language = star S\n\ngoal (1 subgoal):\n 1. regular (star S)", "then"], ["proof (chain)\npicking this:\n  ST.language = star S", "show ?thesis"], ["proof (prove)\nusing this:\n  ST.language = star S\n\ngoal (1 subgoal):\n 1. regular (star S)", "by (metis ST.imp_regular)"], ["proof (state)\nthis:\n  regular (star S)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>The Reversal of a Regular Language\\<close>"], ["", "definition Reverse_nfa :: \"'a dfa \\<Rightarrow> 'a nfa\" where\n  \"Reverse_nfa MS = \\<lparr>nfa.states = dfa.states MS,\n                         init  = dfa.final MS,\n                         final = {dfa.init MS},\n                         nxt   = \\<lambda>q x. {q' \\<in> dfa.states MS. q = dfa.nxt MS q' x},\n                         eps   = {}\\<rparr>\""], ["", "lemma states_Reverse_nfa [simp]: \"states (Reverse_nfa MS) = dfa.states MS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa.states (Reverse_nfa MS) = dfa.states MS", "by (simp add: Reverse_nfa_def)"], ["", "lemma init_Reverse_nfa [simp]: \"init (Reverse_nfa MS) = dfa.final MS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa.init (Reverse_nfa MS) = dfa.final MS", "by (simp add: Reverse_nfa_def)"], ["", "lemma final_Reverse_nfa [simp]: \"final (Reverse_nfa MS) = {dfa.init MS}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa.final (Reverse_nfa MS) = {dfa.init MS}", "by (simp add: Reverse_nfa_def)"], ["", "lemma nxt_Reverse_nfa [simp]:\n  \"nxt (Reverse_nfa MS) q x = {q' \\<in> dfa.states MS. q = dfa.nxt MS q' x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa.nxt (Reverse_nfa MS) q x =\n    {q' \\<in> dfa.states MS. q = dfa.nxt MS q' x}", "by (simp add: Reverse_nfa_def)"], ["", "lemma eps_Reverse_nfa [simp]: \"eps (Reverse_nfa MS) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eps (Reverse_nfa MS) = {}", "by (simp add: Reverse_nfa_def)"], ["", "context dfa\nbegin"], ["", "lemma nfa_Reverse_nfa: \"nfa (Reverse_nfa M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa (Reverse_nfa M)", "by unfold_locales (auto simp: final finite)"], ["", "lemma nextl_Reverse_nfa:\n    \"nfa.nextl (Reverse_nfa M) Q u = {q' \\<in> dfa.states M. dfa.nextl M q' (rev u) \\<in> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa.nextl (Reverse_nfa M) Q u =\n    {q' \\<in> dfa.states M. nextl q' (rev u) \\<in> Q}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfa.nextl (Reverse_nfa M) Q u =\n    {q' \\<in> dfa.states M. nextl q' (rev u) \\<in> Q}", "interpret NR: nfa \"Reverse_nfa M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa (Reverse_nfa M)", "by (rule nfa_Reverse_nfa)"], ["proof (state)\ngoal (1 subgoal):\n 1. NR.nextl Q u = {q' \\<in> dfa.states M. nextl q' (rev u) \\<in> Q}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NR.nextl Q u = {q' \\<in> dfa.states M. nextl q' (rev u) \\<in> Q}", "by (induct u rule: rev_induct) (auto simp: nxt)"], ["proof (state)\nthis:\n  NR.nextl Q u = {q' \\<in> dfa.states M. nextl q' (rev u) \\<in> Q}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Part of Prop 3 of Jean-Marc Champarnaud, A. Khorsi and T. Parantho?n (2002)\\<close>"], ["", "lemma right_lang_Reverse: \"nfa.right_lang (Reverse_nfa M) q = rev ` (dfa.left_lang M q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa.right_lang (Reverse_nfa M) q = rev ` left_lang q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfa.right_lang (Reverse_nfa M) q = rev ` left_lang q", "interpret NR: nfa \"Reverse_nfa M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa (Reverse_nfa M)", "by (rule nfa_Reverse_nfa)"], ["proof (state)\ngoal (1 subgoal):\n 1. NR.right_lang q = rev ` left_lang q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NR.right_lang q = rev ` left_lang q", "by (force simp add: left_lang_def NR.right_lang_def nfa_Reverse_nfa nextl_Reverse_nfa)"], ["proof (state)\nthis:\n  NR.right_lang q = rev ` left_lang q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma right_lang_Reverse_disjoint:\n    \"q1 \\<noteq> q2 \\<Longrightarrow> nfa.right_lang (Reverse_nfa M) q1 \\<inter> nfa.right_lang (Reverse_nfa M) q2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2 \\<Longrightarrow>\n    nfa.right_lang (Reverse_nfa M) q1 \\<inter>\n    nfa.right_lang (Reverse_nfa M) q2 =\n    {}", "by (auto simp: left_lang_def right_lang_Reverse)"], ["", "lemma epsclo_Reverse_nfa [simp]: \"nfa.epsclo (Reverse_nfa M) Q = Q \\<inter> dfa.states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa.epsclo (Reverse_nfa M) Q = Q \\<inter> dfa.states M", "by (auto simp: nfa.epsclo_def nfa_Reverse_nfa)"], ["", "theorem language_Reverse_nfa [simp]:\n     \"nfa.language (Reverse_nfa M) = (rev ` dfa.language M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa.language (Reverse_nfa M) = rev ` language", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nfa.language (Reverse_nfa M) = rev ` language", "interpret NR: nfa \"Reverse_nfa M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfa (Reverse_nfa M)", "by (rule nfa_Reverse_nfa)"], ["proof (state)\ngoal (1 subgoal):\n 1. NR.language = rev ` language", "have \"NR.language = {u. rev u \\<in> dfa.language M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR.language = {u. rev u \\<in> language}", "proof (rule set_eqI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> NR.language) = (rev x \\<in> language)", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> NR.language) = (rev x \\<in> language)", "have \"\\<And>Q q'. q' \\<in> dfa.states M \\<Longrightarrow>\n                   q' \\<in> NR.nextl Q u \\<longleftrightarrow> dfa.nextl M q' (rev u) \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Q q'.\n       q' \\<in> dfa.states M \\<Longrightarrow>\n       (q' \\<in> NR.nextl Q u) = (nextl q' (rev u) \\<in> Q)", "by (induct u rule: List.rev_induct) (auto simp: nxt)"], ["proof (state)\nthis:\n  ?q' \\<in> dfa.states M \\<Longrightarrow>\n  (?q' \\<in> NR.nextl ?Q u) = (nextl ?q' (rev u) \\<in> ?Q)\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> NR.language) = (rev x \\<in> language)", "then"], ["proof (chain)\npicking this:\n  ?q' \\<in> dfa.states M \\<Longrightarrow>\n  (?q' \\<in> NR.nextl ?Q u) = (nextl ?q' (rev u) \\<in> ?Q)", "show \"u \\<in> nfa.language (Reverse_nfa M) \\<longleftrightarrow> rev u \\<in> language\""], ["proof (prove)\nusing this:\n  ?q' \\<in> dfa.states M \\<Longrightarrow>\n  (?q' \\<in> NR.nextl ?Q u) = (nextl ?q' (rev u) \\<in> ?Q)\n\ngoal (1 subgoal):\n 1. (u \\<in> NR.language) = (rev u \\<in> language)", "by (simp add: NR.language_def language_def)"], ["proof (state)\nthis:\n  (u \\<in> NR.language) = (rev u \\<in> language)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NR.language = {u. rev u \\<in> language}\n\ngoal (1 subgoal):\n 1. NR.language = rev ` language", "then"], ["proof (chain)\npicking this:\n  NR.language = {u. rev u \\<in> language}", "show ?thesis"], ["proof (prove)\nusing this:\n  NR.language = {u. rev u \\<in> language}\n\ngoal (1 subgoal):\n 1. NR.language = rev ` language", "by (force simp add: language_def)"], ["proof (state)\nthis:\n  NR.language = rev ` language\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "corollary regular_Reverse:\n  assumes S: \"regular S\" shows \"regular (rev ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (rev ` S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (rev ` S)", "obtain MS where MS: \"dfa MS\" \"dfa.language MS = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>MS.\n        \\<lbrakk>dfa MS; dfa.language MS = S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using S"], ["proof (prove)\nusing this:\n  regular S\n\ngoal (1 subgoal):\n 1. (\\<And>MS.\n        \\<lbrakk>dfa MS; dfa.language MS = S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: regular_def)"], ["proof (state)\nthis:\n  dfa MS\n  dfa.language MS = S\n\ngoal (1 subgoal):\n 1. regular (rev ` S)", "then"], ["proof (chain)\npicking this:\n  dfa MS\n  dfa.language MS = S", "interpret dfa \"MS\""], ["proof (prove)\nusing this:\n  dfa MS\n  dfa.language MS = S\n\ngoal (1 subgoal):\n 1. dfa MS", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (rev ` S)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (rev ` S)", "using nfa_Reverse_nfa nfa_imp_regular language_Reverse_nfa MS"], ["proof (prove)\nusing this:\n  nfa (Reverse_nfa MS)\n  \\<lbrakk>nfa ?M; nfa.language ?M = ?L\\<rbrakk>\n  \\<Longrightarrow> regular ?L\n  nfa.language (Reverse_nfa MS) = rev ` language\n  dfa MS\n  language = S\n\ngoal (1 subgoal):\n 1. regular (rev ` S)", "by blast"], ["proof (state)\nthis:\n  regular (rev ` S)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>All regular expressions yield regular languages.\\<close>"], ["", "theorem regular_lang: \"regular (lang r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (lang r)", "by (induct r)\n     (auto simp: regular_empty regular_nullstr regular_singstr regular_Un regular_conc regular_star)"], ["", "section\\<open>Brzozowski's Minimization Algorithm\\<close>"], ["", "context dfa\n  begin"], ["", "subsection\\<open>More about the relation @{term eq_app_right}\\<close>"], ["", "lemma left_eq_app_right:\n       \"\\<lbrakk>u \\<in> left_lang q; v \\<in> left_lang q\\<rbrakk> \\<Longrightarrow> (u,v) \\<in> eq_app_right language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> left_lang q; v \\<in> left_lang q\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> eq_app_right language", "by (simp add: eq_app_right_def left_lang_def language_def nextl_app)"], ["", "lemma eq_app_right_class_eq:\n    \"UNIV // eq_app_right language = (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV // eq_app_right language =\n    (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UNIV // eq_app_right language =\n    (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. UNIV // eq_app_right language =\n    (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. UNIV // eq_app_right language =\n    (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible", "have \"eq_app_right language `` {u} \\<in> (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_app_right language `` {u}\n    \\<in> (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible", "apply (rule image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. eq_app_right language `` {u} = eq_app_right language `` {path_to ?x}\n 2. ?x \\<in> accessible", "apply (rule equiv_class_eq [OF equiv_eq_app_right])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (u, path_to ?x) \\<in> eq_app_right language\n 2. ?x \\<in> accessible", "apply (rule left_eq_app_right [OF _ path_to_left_lang])"], ["proof (prove)\ngoal (3 subgoals):\n 1. u \\<in> left_lang ?x\n 2. ?x \\<in> accessible\n 3. ?x \\<in> accessible", "apply (auto simp: left_lang_def accessible_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eq_app_right language `` {u}\n  \\<in> (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible\n\ngoal (1 subgoal):\n 1. UNIV // eq_app_right language =\n    (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible", "}"], ["proof (state)\nthis:\n  eq_app_right language `` {?u2}\n  \\<in> (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible\n\ngoal (1 subgoal):\n 1. UNIV // eq_app_right language =\n    (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible", "then"], ["proof (chain)\npicking this:\n  eq_app_right language `` {?u2}\n  \\<in> (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible", "show ?thesis"], ["proof (prove)\nusing this:\n  eq_app_right language `` {?u2}\n  \\<in> (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible\n\ngoal (1 subgoal):\n 1. UNIV // eq_app_right language =\n    (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible", "by (auto simp: quotient_def)"], ["proof (state)\nthis:\n  UNIV // eq_app_right language =\n  (\\<lambda>q. eq_app_right language `` {path_to q}) ` accessible\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_right_lang_imp_eq_app_right_index:\n    assumes \"inj_on right_lang (dfa.states M)\"\n      shows \"bij_betw (\\<lambda>q. eq_app_right language `` {path_to q})\n                      accessible  (UNIV // eq_app_right language)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>q. eq_app_right language `` {path_to q}) accessible\n     (UNIV // eq_app_right language)", "using assms"], ["proof (prove)\nusing this:\n  inj_on right_lang (dfa.states M)\n\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>q. eq_app_right language `` {path_to q}) accessible\n     (UNIV // eq_app_right language)", "apply (auto simp: bij_betw_def inj_on_def eq_app_right_class_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x\\<in>dfa.states M.\n                   \\<forall>y\\<in>dfa.states M.\n                      right_lang x = right_lang y \\<longrightarrow> x = y;\n        x \\<in> accessible; y \\<in> accessible;\n        eq_app_right language `` {path_to x} =\n        eq_app_right language `` {path_to y}\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (drule eq_equiv_class [OF _ equiv_eq_app_right])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x\\<in>dfa.states M.\n                   \\<forall>y\\<in>dfa.states M.\n                      right_lang x = right_lang y \\<longrightarrow> x = y;\n        x \\<in> accessible; y \\<in> accessible\\<rbrakk>\n       \\<Longrightarrow> path_to y \\<in> UNIV\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>x\\<in>dfa.states M.\n                   \\<forall>y\\<in>dfa.states M.\n                      right_lang x = right_lang y \\<longrightarrow> x = y;\n        x \\<in> accessible; y \\<in> accessible;\n        (path_to x, path_to y) \\<in> eq_app_right language\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (auto simp: nextl_path_to eq_app_right_def language_def right_lang_def\n                 nextl_app accessible_imp_states)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition min_states where\n    \"min_states \\<equiv> card (UNIV // eq_app_right language)\""], ["", "lemma minimal_imp_index_eq_app_right:\n    \"minimal \\<Longrightarrow> card (dfa.states M) = min_states\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal \\<Longrightarrow> card (dfa.states M) = min_states", "unfolding min_states_def minimal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. accessible = dfa.states M \\<and>\n    inj_on right_lang (dfa.states M) \\<Longrightarrow>\n    card (dfa.states M) = card (UNIV // eq_app_right language)", "by (metis bij_betw_def card_image inj_right_lang_imp_eq_app_right_index)"], ["", "text\\<open>A minimal machine has a minimal number of states, compared with any other machine\n        for the same language.\\<close>"], ["", "theorem minimal_imp_card_states_le:\n       \"\\<lbrakk>minimal; dfa M'; dfa.language M' = language\\<rbrakk>\n        \\<Longrightarrow> card (dfa.states M) \\<le> card (dfa.states M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>minimal; dfa M'; dfa.language M' = language\\<rbrakk>\n    \\<Longrightarrow> card (dfa.states M) \\<le> card (dfa.states M')", "using minimal_imp_index_eq_app_right dfa.index_eq_app_right_lower min_states_def"], ["proof (prove)\nusing this:\n  minimal \\<Longrightarrow> card (dfa.states M) = min_states\n  dfa ?M \\<Longrightarrow>\n  card (UNIV // eq_app_right (dfa.language ?M)) \\<le> card (dfa.states ?M)\n  min_states \\<equiv> card (UNIV // eq_app_right language)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>minimal; dfa M'; dfa.language M' = language\\<rbrakk>\n    \\<Longrightarrow> card (dfa.states M) \\<le> card (dfa.states M')", "by fastforce"], ["", "definition index_f :: \"'a list set \\<Rightarrow> hf\" where\n    \"index_f \\<equiv> SOME h. bij_betw h (UNIV // eq_app_right language) (hfset (ord_of min_states))\""], ["", "lemma index_f: \"bij_betw index_f (UNIV // eq_app_right language) (hfset (ord_of min_states))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw index_f (UNIV // eq_app_right language)\n     (hfset (ord_of min_states))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw index_f (UNIV // eq_app_right language)\n     (hfset (ord_of min_states))", "have \"\\<exists>h. bij_betw h (UNIV // eq_app_right language) (hfset (ord_of min_states))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h.\n       bij_betw h (UNIV // eq_app_right language)\n        (hfset (ord_of min_states))", "unfolding min_states_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h.\n       bij_betw h (UNIV // eq_app_right language)\n        (hfset (ord_of (card (UNIV // eq_app_right language))))", "by (metis L2_3 MN_eq_nextl ex_bij_betw_finite_nat bij_betw_ord_ofI)"], ["proof (state)\nthis:\n  \\<exists>h.\n     bij_betw h (UNIV // eq_app_right language) (hfset (ord_of min_states))\n\ngoal (1 subgoal):\n 1. bij_betw index_f (UNIV // eq_app_right language)\n     (hfset (ord_of min_states))", "then"], ["proof (chain)\npicking this:\n  \\<exists>h.\n     bij_betw h (UNIV // eq_app_right language) (hfset (ord_of min_states))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>h.\n     bij_betw h (UNIV // eq_app_right language) (hfset (ord_of min_states))\n\ngoal (1 subgoal):\n 1. bij_betw index_f (UNIV // eq_app_right language)\n     (hfset (ord_of min_states))", "unfolding index_f_def"], ["proof (prove)\nusing this:\n  \\<exists>h.\n     bij_betw h (UNIV // eq_app_right language) (hfset (ord_of min_states))\n\ngoal (1 subgoal):\n 1. bij_betw\n     (SOME h.\n         bij_betw h (UNIV // eq_app_right language)\n          (hfset (ord_of min_states)))\n     (UNIV // eq_app_right language) (hfset (ord_of min_states))", "by (metis someI_ex)"], ["proof (state)\nthis:\n  bij_betw index_f (UNIV // eq_app_right language)\n   (hfset (ord_of min_states))\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation Canon:\n      MyhillNerode_dfa language \"eq_app_right language\"\n                       language\n                       min_states index_f"], ["proof (prove)\ngoal (1 subgoal):\n 1. MyhillNerode_dfa language (eq_app_right language) language min_states\n     index_f", "by (simp add: MyhillNerode_dfa_def equiv_eq_app_right right_invariant_eq_app_right\n                  index_f eq_app_right_eq)"], ["", "interpretation MN: dfa Canon.DFA"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa Canon.DFA", "by (fact Canon.dfa)"], ["", "definition iso :: \"hf \\<Rightarrow> hf\" where\n    \"iso \\<equiv> index_f o (\\<lambda>q. eq_app_right language `` {path_to q})\""], ["", "theorem minimal_imp_isomorphic_to_canonical:\n    assumes minimal\n      shows \"dfa_isomorphism M Canon.DFA iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa_isomorphism M Canon.DFA local.iso", "proof (unfold_locales, simp_all add: Canon.DFA_def)"], ["proof (state)\ngoal (4 subgoals):\n 1. bij_betw local.iso (dfa.states M)\n     (index_f ` UNIV // eq_app_right language)\n 2. local.iso (dfa.init M) = index_f (eq_app_right language `` {[]})\n 3. local.iso ` dfa.final M =\n    {index_f (eq_app_right language `` {u}) |u. u \\<in> language}\n 4. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "have \"bij_betw iso accessible (hfset (ord_of min_states))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw local.iso accessible (hfset (ord_of min_states))", "using assms bij_betw_trans index_f inj_right_lang_imp_eq_app_right_index"], ["proof (prove)\nusing this:\n  minimal\n  \\<lbrakk>bij_betw ?f ?A ?B; bij_betw ?g ?B ?C\\<rbrakk>\n  \\<Longrightarrow> bij_betw (?g \\<circ> ?f) ?A ?C\n  bij_betw index_f (UNIV // eq_app_right language)\n   (hfset (ord_of min_states))\n  inj_on right_lang (dfa.states M) \\<Longrightarrow>\n  bij_betw (\\<lambda>q. eq_app_right language `` {path_to q}) accessible\n   (UNIV // eq_app_right language)\n\ngoal (1 subgoal):\n 1. bij_betw local.iso accessible (hfset (ord_of min_states))", "unfolding iso_def minimal_def"], ["proof (prove)\nusing this:\n  accessible = dfa.states M \\<and> inj_on right_lang (dfa.states M)\n  \\<lbrakk>bij_betw ?f ?A ?B; bij_betw ?g ?B ?C\\<rbrakk>\n  \\<Longrightarrow> bij_betw (?g \\<circ> ?f) ?A ?C\n  bij_betw index_f (UNIV // eq_app_right language)\n   (hfset (ord_of min_states))\n  inj_on right_lang (dfa.states M) \\<Longrightarrow>\n  bij_betw (\\<lambda>q. eq_app_right language `` {path_to q}) accessible\n   (UNIV // eq_app_right language)\n\ngoal (1 subgoal):\n 1. bij_betw\n     (index_f \\<circ> (\\<lambda>q. eq_app_right language `` {path_to q}))\n     accessible (hfset (ord_of min_states))", "by blast"], ["proof (state)\nthis:\n  bij_betw local.iso accessible (hfset (ord_of min_states))\n\ngoal (4 subgoals):\n 1. bij_betw local.iso (dfa.states M)\n     (index_f ` UNIV // eq_app_right language)\n 2. local.iso (dfa.init M) = index_f (eq_app_right language `` {[]})\n 3. local.iso ` dfa.final M =\n    {index_f (eq_app_right language `` {u}) |u. u \\<in> language}\n 4. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "then"], ["proof (chain)\npicking this:\n  bij_betw local.iso accessible (hfset (ord_of min_states))", "show \"bij_betw iso (dfa.states M) (index_f ` (UNIV // eq_app_right language))\""], ["proof (prove)\nusing this:\n  bij_betw local.iso accessible (hfset (ord_of min_states))\n\ngoal (1 subgoal):\n 1. bij_betw local.iso (dfa.states M)\n     (index_f ` UNIV // eq_app_right language)", "by (metis assms bij_betw_def index_f minimal_def)"], ["proof (state)\nthis:\n  bij_betw local.iso (dfa.states M)\n   (index_f ` UNIV // eq_app_right language)\n\ngoal (3 subgoals):\n 1. local.iso (dfa.init M) = index_f (eq_app_right language `` {[]})\n 2. local.iso ` dfa.final M =\n    {index_f (eq_app_right language `` {u}) |u. u \\<in> language}\n 3. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. local.iso (dfa.init M) = index_f (eq_app_right language `` {[]})\n 2. local.iso ` dfa.final M =\n    {index_f (eq_app_right language `` {u}) |u. u \\<in> language}\n 3. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "have \"eq_app_right language `` {path_to (dfa.init M)} = eq_app_right language `` {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_app_right language `` {path_to (dfa.init M)} =\n    eq_app_right language `` {[]}", "proof (rule equiv_class_eq [OF equiv_eq_app_right])"], ["proof (state)\ngoal (1 subgoal):\n 1. (path_to (dfa.init M), []) \\<in> eq_app_right language", "show \"(path_to (dfa.init M), []) \\<in> eq_app_right language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (path_to (dfa.init M), []) \\<in> eq_app_right language", "using nextl_path_to assms"], ["proof (prove)\nusing this:\n  ?q \\<in> accessible \\<Longrightarrow> nextl (dfa.init M) (path_to ?q) = ?q\n  minimal\n\ngoal (1 subgoal):\n 1. (path_to (dfa.init M), []) \\<in> eq_app_right language", "by (auto simp: minimal_def eq_app_right_def language_def nextl_app)"], ["proof (state)\nthis:\n  (path_to (dfa.init M), []) \\<in> eq_app_right language\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eq_app_right language `` {path_to (dfa.init M)} =\n  eq_app_right language `` {[]}\n\ngoal (3 subgoals):\n 1. local.iso (dfa.init M) = index_f (eq_app_right language `` {[]})\n 2. local.iso ` dfa.final M =\n    {index_f (eq_app_right language `` {u}) |u. u \\<in> language}\n 3. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "then"], ["proof (chain)\npicking this:\n  eq_app_right language `` {path_to (dfa.init M)} =\n  eq_app_right language `` {[]}", "show \"iso (dfa.init M) = index_f (eq_app_right language `` {[]})\""], ["proof (prove)\nusing this:\n  eq_app_right language `` {path_to (dfa.init M)} =\n  eq_app_right language `` {[]}\n\ngoal (1 subgoal):\n 1. local.iso (dfa.init M) = index_f (eq_app_right language `` {[]})", "by (simp add: iso_def)"], ["proof (state)\nthis:\n  local.iso (dfa.init M) = index_f (eq_app_right language `` {[]})\n\ngoal (2 subgoals):\n 1. local.iso ` dfa.final M =\n    {index_f (eq_app_right language `` {u}) |u. u \\<in> language}\n 2. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. local.iso ` dfa.final M =\n    {index_f (eq_app_right language `` {u}) |u. u \\<in> language}\n 2. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "have \"(\\<lambda>u. eq_app_right language `` {path_to u}) ` dfa.final M =\n            (\\<lambda>l. eq_app_right language `` {l}) ` language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>u. eq_app_right language `` {path_to u}) ` dfa.final M =\n    (\\<lambda>l. eq_app_right language `` {l}) ` language", "using assms final nextl_path_to nextl_app"], ["proof (prove)\nusing this:\n  minimal\n  dfa.final M \\<subseteq> dfa.states M\n  ?q \\<in> accessible \\<Longrightarrow> nextl (dfa.init M) (path_to ?q) = ?q\n  nextl ?q (?xs @ ?ys) = nextl (nextl ?q ?xs) ?ys\n\ngoal (1 subgoal):\n 1. (\\<lambda>u. eq_app_right language `` {path_to u}) ` dfa.final M =\n    (\\<lambda>l. eq_app_right language `` {l}) ` language", "apply (auto simp: dfa_isomorphism_def language_def minimal_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>dfa.final M \\<subseteq> dfa.states M;\n        \\<And>q.\n           q \\<in> dfa.states M \\<Longrightarrow>\n           nextl (dfa.init M) (path_to q) = q;\n        \\<And>q xs ys. nextl q (xs @ ys) = nextl (nextl q xs) ys;\n        accessible = dfa.states M; inj_on right_lang (dfa.states M);\n        nextl (dfa.init M) xa \\<in> dfa.final M\\<rbrakk>\n       \\<Longrightarrow> eq_app_right\n                          {xs. nextl (dfa.init M) xs \\<in> dfa.final M} ``\n                         {xa}\n                         \\<in> (\\<lambda>x.\n                                   eq_app_right\n                                    {xs.\n                                     nextl (dfa.init M) xs\n                                     \\<in> dfa.final M} ``\n                                   {path_to x}) `\n                               dfa.final M", "apply (auto simp: eq_app_right_def\n                    intro: rev_image_eqI equiv_class_eq [OF equiv_eq_app_right])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>u. eq_app_right language `` {path_to u}) ` dfa.final M =\n  (\\<lambda>l. eq_app_right language `` {l}) ` language\n\ngoal (2 subgoals):\n 1. local.iso ` dfa.final M =\n    {index_f (eq_app_right language `` {u}) |u. u \\<in> language}\n 2. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "from this [THEN image_eq_imp_comp [where h = index_f]]"], ["proof (chain)\npicking this:\n  (index_f \\<circ> (\\<lambda>u. eq_app_right language `` {path_to u})) `\n  dfa.final M =\n  (index_f \\<circ> (\\<lambda>l. eq_app_right language `` {l})) ` language", "show \"iso ` dfa.final M = {index_f (eq_app_right language `` {u}) |u. u \\<in> language}\""], ["proof (prove)\nusing this:\n  (index_f \\<circ> (\\<lambda>u. eq_app_right language `` {path_to u})) `\n  dfa.final M =\n  (index_f \\<circ> (\\<lambda>l. eq_app_right language `` {l})) ` language\n\ngoal (1 subgoal):\n 1. local.iso ` dfa.final M =\n    {index_f (eq_app_right language `` {u}) |u. u \\<in> language}", "by (simp add: iso_def o_def Setcompr_eq_image)"], ["proof (state)\nthis:\n  local.iso ` dfa.final M =\n  {index_f (eq_app_right language `` {u}) |u. u \\<in> language}\n\ngoal (1 subgoal):\n 1. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "have nxt: \"\\<And>q x. q \\<in> dfa.states M \\<Longrightarrow>\n                       eq_app_right language `` {path_to (dfa.nxt M q x)} =\n                       eq_app_right language `` {path_to q @ [x]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       eq_app_right language `` {path_to (dfa.nxt M q x)} =\n       eq_app_right language `` {path_to q @ [x]}", "apply (rule equiv_class_eq [OF equiv_eq_app_right])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       (path_to (dfa.nxt M q x), path_to q @ [x])\n       \\<in> eq_app_right language", "using assms nextl_path_to nxt nextl_app"], ["proof (prove)\nusing this:\n  minimal\n  ?q \\<in> accessible \\<Longrightarrow> nextl (dfa.init M) (path_to ?q) = ?q\n  ?q \\<in> dfa.states M \\<Longrightarrow> dfa.nxt M ?q ?x \\<in> dfa.states M\n  nextl ?q (?xs @ ?ys) = nextl (nextl ?q ?xs) ?ys\n\ngoal (1 subgoal):\n 1. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       (path_to (dfa.nxt M q x), path_to q @ [x])\n       \\<in> eq_app_right language", "apply (auto simp: minimal_def nextl_path_to eq_app_right_def language_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?q \\<in> dfa.states M \\<Longrightarrow>\n  eq_app_right language `` {path_to (dfa.nxt M ?q ?x)} =\n  eq_app_right language `` {path_to ?q @ [?x]}\n\ngoal (1 subgoal):\n 1. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "show \"\\<And>q x. q \\<in> dfa.states M \\<Longrightarrow>\n           iso (dfa.nxt M q x) =\n           index_f\n            (\\<Union>u\\<in>MyhillNerode_dfa.hinv (eq_app_right language) index_f (iso q).\n                eq_app_right language `` {u @ [x]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q x.\n       q \\<in> dfa.states M \\<Longrightarrow>\n       local.iso (dfa.nxt M q x) =\n       index_f\n        (\\<Union>u\\<in>Canon.hinv (local.iso q).\n            eq_app_right language `` {u @ [x]})", "by (simp add: iso_def Canon.injh Canon.hinv_def quotientI Canon.resp nxt\n                      UN_equiv_class [OF equiv_eq_app_right])"], ["proof (state)\nthis:\n  ?q \\<in> dfa.states M \\<Longrightarrow>\n  local.iso (dfa.nxt M ?q ?x) =\n  index_f\n   (\\<Union>u\\<in>Canon.hinv (local.iso ?q).\n       eq_app_right language `` {u @ [?x]})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma states_PR [simp]:\n       \"dfa.states (nfa.Power_dfa (Reverse_nfa M)) = HF ` Pow (dfa.states M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.states (nfa.Power_dfa (Reverse_nfa M)) = HF ` Pow (dfa.states M)", "by (rule set_eqI)\n       (auto simp: nfa.states_Power_dfa nfa_Reverse_nfa image_iff Bex_def)"], ["", "lemma inj_on_right_lang_PR:\n    assumes \"dfa.states M = accessible\"\n      shows \"inj_on (dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)))\n                    (dfa.states (nfa.Power_dfa (Reverse_nfa M)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)))\n     (dfa.states (nfa.Power_dfa (Reverse_nfa M)))", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M));\n        y \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M));\n        dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) x =\n        dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix q1 q2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M));\n        y \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M));\n        dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) x =\n        dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume *: \"q1 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\"\n              \"q2 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\"\n              \"dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q1 =\n               dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q2\""], ["proof (state)\nthis:\n  q1 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  q2 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q1 =\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M));\n        y \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M));\n        dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) x =\n        dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  q1 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  q2 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q1 =\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q2", "have \"hfset q1 \\<subseteq> accessible \\<and> hfset q2 \\<subseteq> accessible\""], ["proof (prove)\nusing this:\n  q1 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  q2 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q1 =\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q2\n\ngoal (1 subgoal):\n 1. hfset q1 \\<subseteq> accessible \\<and> hfset q2 \\<subseteq> accessible", "using assms rev_finite_subset [OF finite]"], ["proof (prove)\nusing this:\n  q1 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  q2 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q1 =\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q2\n  dfa.states M = accessible\n  ?A \\<subseteq> dfa.states M \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. hfset q1 \\<subseteq> accessible \\<and> hfset q2 \\<subseteq> accessible", "by force"], ["proof (state)\nthis:\n  hfset q1 \\<subseteq> accessible \\<and> hfset q2 \\<subseteq> accessible\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M));\n        y \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M));\n        dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) x =\n        dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with *"], ["proof (chain)\npicking this:\n  q1 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  q2 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q1 =\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q2\n  hfset q1 \\<subseteq> accessible \\<and> hfset q2 \\<subseteq> accessible", "show \"q1 = q2\""], ["proof (prove)\nusing this:\n  q1 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  q2 \\<in> dfa.states (nfa.Power_dfa (Reverse_nfa M))\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q1 =\n  dfa.right_lang (nfa.Power_dfa (Reverse_nfa M)) q2\n  hfset q1 \\<subseteq> accessible \\<and> hfset q2 \\<subseteq> accessible\n\ngoal (1 subgoal):\n 1. q1 = q2", "apply (simp add: nfa_Reverse_nfa nfa.Power_right_lang right_lang_Reverse\n                       image_UN [symmetric] inj_image_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q1 \\<in> HF ` Pow (dfa.states M);\n     q2 \\<in> HF ` Pow (dfa.states M);\n     \\<Union> (left_lang ` hfset q1) = \\<Union> (left_lang ` hfset q2);\n     hfset q1 \\<subseteq> accessible \\<and>\n     hfset q2 \\<subseteq> accessible\\<rbrakk>\n    \\<Longrightarrow> q1 = q2", "apply (metis HF_hfset le_sup_iff left_lang_UN)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  q1 = q2\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation APR :: \"'x dfa \\<Rightarrow> 'x dfa\" where\n    \"APR X \\<equiv> dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa X))\""], ["", "theorem minimal_APR:\n    assumes \"dfa.states M = accessible\"\n      shows \"dfa.minimal (APR M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.minimal (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa.minimal (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))", "have PR: \"dfa (APR M)\"\n               \"dfa (nfa.Power_dfa (Reverse_nfa M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M))) &&&\n    dfa (nfa.Power_dfa (Reverse_nfa M))", "by (auto simp: dfa.dfa_Accessible nfa.dfa_Power nfa_Reverse_nfa)"], ["proof (state)\nthis:\n  dfa (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))\n  dfa (nfa.Power_dfa (Reverse_nfa M))\n\ngoal (1 subgoal):\n 1. dfa.minimal (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))", "then"], ["proof (chain)\npicking this:\n  dfa (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))\n  dfa (nfa.Power_dfa (Reverse_nfa M))", "show ?thesis"], ["proof (prove)\nusing this:\n  dfa (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))\n  dfa (nfa.Power_dfa (Reverse_nfa M))\n\ngoal (1 subgoal):\n 1. dfa.minimal (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))", "apply (simp add: dfa.minimal_def dfa.states_Accessible_dfa dfa.Accessible_accessible)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dfa (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)));\n     dfa (nfa.Power_dfa (Reverse_nfa M))\\<rbrakk>\n    \\<Longrightarrow> inj_on\n                       (dfa.right_lang\n                         (dfa.Accessible_dfa\n                           (nfa.Power_dfa (Reverse_nfa M))))\n                       (dfa.accessible (nfa.Power_dfa (Reverse_nfa M)))", "apply (simp add: inj_on_def dfa.Accessible_right_lang_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dfa (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)));\n     dfa (nfa.Power_dfa (Reverse_nfa M))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>dfa.accessible\n(nfa.Power_dfa (Reverse_nfa M)).\n                         \\<forall>y\\<in>dfa.accessible\n   (nfa.Power_dfa (Reverse_nfa M)).\n                            dfa.right_lang (nfa.Power_dfa (Reverse_nfa M))\n                             x =\n                            dfa.right_lang (nfa.Power_dfa (Reverse_nfa M))\n                             y \\<longrightarrow>\n                            x = y", "apply (meson assms dfa.accessible_imp_states inj_onD inj_on_right_lang_PR)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dfa.minimal (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Brzozowski :: \"'a dfa\" where\n    \"Brzozowski \\<equiv> APR (APR M)\""], ["", "lemma dfa_Brzozowski: \"dfa Brzozowski\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa Brzozowski", "by (simp add: Brzozowski_def dfa.dfa_Accessible dfa.nfa_Reverse_nfa\n                  nfa.dfa_Power nfa_Reverse_nfa)"], ["", "theorem language_Brzozowski: \"dfa.language Brzozowski = language\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.language Brzozowski = language", "by (simp add: Brzozowski_def dfa.Accessible_language nfa.Power_language\n          dfa.dfa_Accessible dfa.nfa_Reverse_nfa nfa.dfa_Power nfa_Reverse_nfa\n          dfa.language_Reverse_nfa image_image)"], ["", "theorem minimal_Brzozowski: \"dfa.minimal Brzozowski\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.minimal Brzozowski", "unfolding Brzozowski_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.minimal\n     (dfa.Accessible_dfa\n       (nfa.Power_dfa\n         (Reverse_nfa\n           (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M))))))", "proof (rule dfa.minimal_APR)"], ["proof (state)\ngoal (2 subgoals):\n 1. dfa (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))\n 2. dfa.states (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M))) =\n    dfa.accessible (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))", "show \"dfa (APR M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))", "by (simp add: dfa.dfa_Accessible nfa.dfa_Power nfa_Reverse_nfa)"], ["proof (state)\nthis:\n  dfa (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))\n\ngoal (1 subgoal):\n 1. dfa.states (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M))) =\n    dfa.accessible (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dfa.states (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M))) =\n    dfa.accessible (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))", "show \"dfa.states (APR M) = dfa.accessible (APR M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfa.states (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M))) =\n    dfa.accessible (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))", "by (simp add: dfa.Accessible_accessible dfa.states_Accessible_dfa nfa.dfa_Power nfa_Reverse_nfa)"], ["proof (state)\nthis:\n  dfa.states (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M))) =\n  dfa.accessible (dfa.Accessible_dfa (nfa.Power_dfa (Reverse_nfa M)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma index_f_cong:\n     \"\\<lbrakk>dfa.language M = dfa.language N; dfa M; dfa N\\<rbrakk> \\<Longrightarrow> dfa.index_f M = dfa.index_f N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dfa.language M = dfa.language N; dfa M; dfa N\\<rbrakk>\n    \\<Longrightarrow> dfa.index_f M = dfa.index_f N", "by (simp add: dfa.index_f_def dfa.min_states_def)"], ["", "theorem minimal_imp_isomorphic:\n     \"\\<lbrakk>dfa.language M = dfa.language N; dfa.minimal M; dfa.minimal N; dfa M; dfa N\\<rbrakk>\n      \\<Longrightarrow> \\<exists>h. dfa_isomorphism M N h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dfa.language M = dfa.language N; dfa.minimal M; dfa.minimal N;\n     dfa M; dfa N\\<rbrakk>\n    \\<Longrightarrow> \\<exists>h. dfa_isomorphism M N h", "by (metis dfa_isomorphism.sym dfa_isomorphism.trans\n            dfa.minimal_imp_isomorphic_to_canonical index_f_cong)"], ["", "end"]]}