{"file_name": "/home/qj213/afp-2021-10-22/thys/Free-Boolean-Algebra/Free_Boolean_Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Free-Boolean-Algebra", "problem_names": ["lemma sup_conv_inf:\n  fixes x y :: \"'a::boolean_algebra\"\n  shows \"x \\<squnion> y = - (- x \\<sqinter> - y)\"", "lemma fba_Diff: \"S \\<in> fba \\<Longrightarrow> T \\<in> fba \\<Longrightarrow> S - T \\<in> fba\"", "lemma fba_union: \"S \\<in> fba \\<Longrightarrow> T \\<in> fba \\<Longrightarrow> S \\<union> T \\<in> fba\"", "lemma fba_empty: \"({} :: 'a set set) \\<in> fba\"", "lemma fba_UNIV: \"(UNIV :: 'a set set) \\<in> fba\"", "lemma Rep_formula_var: \"Rep_formula (var i) = {A. i \\<in> A}\"", "lemma Rep_formula_inf:\n  \"Rep_formula (x \\<sqinter> y) = Rep_formula x \\<inter> Rep_formula y\"", "lemma Rep_formula_sup:\n  \"Rep_formula (x \\<squnion> y) = Rep_formula x \\<union> Rep_formula y\"", "lemma Rep_formula_top: \"Rep_formula \\<top> = UNIV\"", "lemma Rep_formula_bot: \"Rep_formula \\<bottom> = {}\"", "lemma Rep_formula_compl: \"Rep_formula (- x) = - Rep_formula x\"", "lemma Rep_formula_diff:\n  \"Rep_formula (x - y) = Rep_formula x - Rep_formula y\"", "lemmas eq_formula_iff = Rep_formula_inject [symmetric]", "lemmas Rep_formula_simps =\n  less_eq_formula_def less_formula_def eq_formula_iff\n  Rep_formula_sup Rep_formula_inf Rep_formula_top Rep_formula_bot\n  Rep_formula_compl Rep_formula_diff Rep_formula_var", "lemma bot_neq_top_formula [simp]: \"(\\<bottom> :: 'a formula) \\<noteq> \\<top>\"", "lemma top_neq_bot_formula [simp]: \"(\\<top> :: 'a formula) \\<noteq> \\<bottom>\"", "lemma var_le_var_simps [simp]:\n  \"var i \\<le> var j \\<longleftrightarrow> i = j\"\n  \"\\<not> var i \\<le> - var j\"\n  \"\\<not> - var i \\<le> var j\"", "lemma var_eq_var_simps [simp]:\n  \"var i = var j \\<longleftrightarrow> i = j\"\n  \"var i \\<noteq> - var j\"\n  \"- var i \\<noteq> var j\"", "lemma formula_induct [case_names var compl inf, induct type: formula]:\n  fixes P :: \"'a formula \\<Rightarrow> bool\"\n  assumes 1: \"\\<And>i. P (var i)\"\n  assumes 2: \"\\<And>x. P x \\<Longrightarrow> P (- x)\"\n  assumes 3: \"\\<And>x y. P x \\<Longrightarrow> P y \\<Longrightarrow> P (x \\<sqinter> y)\"\n  shows \"P x\"", "lemma ifte_top [simp]: \"ifte \\<top> x y = x\"", "lemma ifte_bot [simp]: \"ifte \\<bottom> x y = y\"", "lemma ifte_same: \"ifte a x x = x\"", "lemma compl_ifte: \"- ifte a x y = ifte a (- x) (- y)\"", "lemma inf_ifte_distrib:\n  \"ifte x a b \\<sqinter> ifte x c d = ifte x (a \\<sqinter> c) (b \\<sqinter> d)\"", "lemma ifte_ifte_distrib:\n  \"ifte x (ifte y a b) (ifte y c d) = ifte y (ifte x a c) (ifte x b d)\"", "lemma formulasI:\n  assumes \"\\<And>A B. \\<forall>i\\<in>S. i \\<in> A \\<longleftrightarrow> i \\<in> B\n    \\<Longrightarrow> A \\<in> Rep_formula x \\<longleftrightarrow> B \\<in> Rep_formula x\"\n  shows \"x \\<in> formulas S\"", "lemma formulasD:\n  assumes \"x \\<in> formulas S\"\n  assumes \"\\<forall>i\\<in>S. i \\<in> A \\<longleftrightarrow> i \\<in> B\"\n  shows \"A \\<in> Rep_formula x \\<longleftrightarrow> B \\<in> Rep_formula x\"", "lemma formulas_mono: \"S \\<subseteq> T \\<Longrightarrow> formulas S \\<subseteq> formulas T\"", "lemma formulas_insert: \"x \\<in> formulas S \\<Longrightarrow> x \\<in> formulas (insert a S)\"", "lemma formulas_var: \"i \\<in> S \\<Longrightarrow> var i \\<in> formulas S\"", "lemma formulas_var_iff: \"var i \\<in> formulas S \\<longleftrightarrow> i \\<in> S\"", "lemma formulas_bot: \"\\<bottom> \\<in> formulas S\"", "lemma formulas_top: \"\\<top> \\<in> formulas S\"", "lemma formulas_compl: \"x \\<in> formulas S \\<Longrightarrow> - x \\<in> formulas S\"", "lemma formulas_inf:\n  \"x \\<in> formulas S \\<Longrightarrow> y \\<in> formulas S \\<Longrightarrow> x \\<sqinter> y \\<in> formulas S\"", "lemma formulas_sup:\n  \"x \\<in> formulas S \\<Longrightarrow> y \\<in> formulas S \\<Longrightarrow> x \\<squnion> y \\<in> formulas S\"", "lemma formulas_diff:\n  \"x \\<in> formulas S \\<Longrightarrow> y \\<in> formulas S \\<Longrightarrow> x - y \\<in> formulas S\"", "lemma formulas_ifte:\n  \"a \\<in> formulas S \\<Longrightarrow> x \\<in> formulas S \\<Longrightarrow> y \\<in> formulas S \\<Longrightarrow>\n    ifte a x y \\<in> formulas S\"", "lemmas formulas_intros =\n  formulas_var formulas_bot formulas_top formulas_compl\n  formulas_inf formulas_sup formulas_diff formulas_ifte", "lemma ifte_inject:\n  assumes \"ifte (var i) x y = ifte (var i) x' y'\" \n  assumes \"i \\<notin> S\"\n  assumes \"x \\<in> formulas S\" and \"x' \\<in> formulas S\"\n  assumes \"y \\<in> formulas S\" and \"y' \\<in> formulas S\"\n  shows \"x = x' \\<and> y = y'\"", "lemma hom_graph_dest:\n  \"hom_graph f S x a \\<Longrightarrow> k \\<in> S \\<Longrightarrow> \\<exists>y z b c.\n    x = ifte (var k) y z \\<and> a = ifte (f k) b c \\<and>\n    hom_graph f (S - {k}) y b \\<and> hom_graph f (S - {k}) z c\"", "lemma hom_graph_insert_elim:\n  assumes \"hom_graph f (insert i S) x a\" and \"i \\<notin> S\"\n  obtains y z b c\n  where \"x = ifte (var i) y z\"\n    and \"a = ifte (f i) b c\"\n    and \"hom_graph f S y b\"\n    and \"hom_graph f S z c\"", "lemma hom_graph_imp_formulas:\n  \"hom_graph f S x a \\<Longrightarrow> x \\<in> formulas S\"", "lemma hom_graph_unique:\n  \"hom_graph f S x a \\<Longrightarrow> hom_graph f S x a' \\<Longrightarrow> a = a'\"", "lemma hom_graph_insert:\n  assumes \"hom_graph f S x a\"\n  shows \"hom_graph f (insert i S) x a\"", "lemma hom_graph_finite_superset:\n  assumes \"hom_graph f S x a\" and \"finite T\" and \"S \\<subseteq> T\"\n  shows \"hom_graph f T x a\"", "lemma hom_graph_imp_finite:\n  \"hom_graph f S x a \\<Longrightarrow> finite S\"", "lemma hom_graph_unique':\n  assumes \"hom_graph f S x a\" and \"hom_graph f T x a'\"\n  shows \"a = a'\"", "lemma hom_graph_var: \"hom_graph f {i} (var i) (f i)\"", "lemma hom_graph_compl:\n  \"hom_graph f S x a \\<Longrightarrow> hom_graph f S (- x) (- a)\"", "lemma hom_graph_inf:\n  \"hom_graph f S x a \\<Longrightarrow> hom_graph f S y b \\<Longrightarrow>\n   hom_graph f S (x \\<sqinter> y) (a \\<sqinter> b)\"", "lemma hom_graph_union_inf:\n  assumes \"hom_graph f S x a\" and \"hom_graph f T y b\"\n  shows \"hom_graph f (S \\<union> T) (x \\<sqinter> y) (a \\<sqinter> b)\"", "lemma hom_graph_exists: \"\\<exists>a S. hom_graph f S x a\"", "lemma hom_graph_hom: \"\\<exists>S. hom_graph f S x (hom f x)\"", "lemma hom_equality:\n  \"hom_graph f S x a \\<Longrightarrow> hom f x = a\"", "lemma hom_var [simp]: \"hom f (var i) = f i\"", "lemma hom_bot [simp]: \"hom f \\<bottom> = \\<bottom>\"", "lemma hom_top [simp]: \"hom f \\<top> = \\<top>\"", "lemma hom_compl [simp]: \"hom f (- x) = - hom f x\"", "lemma hom_inf [simp]: \"hom f (x \\<sqinter> y) = hom f x \\<sqinter> hom f y\"", "lemma hom_sup [simp]: \"hom f (x \\<squnion> y) = hom f x \\<squnion> hom f y\"", "lemma hom_diff [simp]: \"hom f (x - y) = hom f x - hom f y\"", "lemma hom_ifte [simp]:\n  \"hom f (ifte x y z) = ifte (hom f x) (hom f y) (hom f z)\"", "lemmas hom_simps =\n  hom_var hom_bot hom_top hom_compl\n  hom_inf hom_sup hom_diff hom_ifte", "lemma hom_var_eq_id: \"hom var x = x\"", "lemma hom_hom: \"hom f (hom g x) = hom (\\<lambda>i. hom f (g i)) x\"", "lemma fmap_var [simp]: \"fmap f (var i) = var (f i)\"", "lemma fmap_bot [simp]: \"fmap f \\<bottom> = \\<bottom>\"", "lemma fmap_top [simp]: \"fmap f \\<top> = \\<top>\"", "lemma fmap_compl [simp]: \"fmap f (- x) = - fmap f x\"", "lemma fmap_inf [simp]: \"fmap f (x \\<sqinter> y) = fmap f x \\<sqinter> fmap f y\"", "lemma fmap_sup [simp]: \"fmap f (x \\<squnion> y) = fmap f x \\<squnion> fmap f y\"", "lemma fmap_diff [simp]: \"fmap f (x - y) = fmap f x - fmap f y\"", "lemma fmap_ifte [simp]:\n  \"fmap f (ifte x y z) = ifte (fmap f x) (fmap f y) (fmap f z)\"", "lemmas fmap_simps =\n  fmap_var fmap_bot fmap_top fmap_compl\n  fmap_inf fmap_sup fmap_diff fmap_ifte", "lemma fmap_ident: \"fmap (\\<lambda>i. i) x = x\"", "lemma fmap_fmap: \"fmap f (fmap g x) = fmap (f \\<circ> g) x\""], "translations": [["", "lemma sup_conv_inf:\n  fixes x y :: \"'a::boolean_algebra\"\n  shows \"x \\<squnion> y = - (- x \\<sqinter> - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y = - (- x \\<sqinter> - y)", "by simp"], ["", "(*>*)"], ["", "subsection \\<open>Free boolean algebra as a set\\<close>"], ["", "text \\<open>\n  We start by defining the free boolean algebra over type @{typ 'a} as\n  an inductive set.  Here \\<open>i :: 'a\\<close> represents a variable;\n  \\<open>A :: 'a set\\<close> represents a valuation, assigning a truth\n  value to each variable; and \\<open>S :: 'a set set\\<close> represents a\n  formula, as the set of valuations that make the formula true.  The\n  set \\<open>fba\\<close> contains representatives of formulas built from\n  finite combinations of variables with negation and conjunction.\n\\<close>"], ["", "inductive_set\n  fba :: \"'a set set set\"\nwhere\n  var: \"{A. i \\<in> A} \\<in> fba\"\n| Compl: \"S \\<in> fba \\<Longrightarrow> - S \\<in> fba\"\n| inter: \"S \\<in> fba \\<Longrightarrow> T \\<in> fba \\<Longrightarrow> S \\<inter> T \\<in> fba\""], ["", "lemma fba_Diff: \"S \\<in> fba \\<Longrightarrow> T \\<in> fba \\<Longrightarrow> S - T \\<in> fba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<in> fba; T \\<in> fba\\<rbrakk>\n    \\<Longrightarrow> S - T \\<in> fba", "unfolding Diff_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<in> fba; T \\<in> fba\\<rbrakk>\n    \\<Longrightarrow> S \\<inter> - T \\<in> fba", "by (intro fba.inter fba.Compl)"], ["", "lemma fba_union: \"S \\<in> fba \\<Longrightarrow> T \\<in> fba \\<Longrightarrow> S \\<union> T \\<in> fba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<in> fba; T \\<in> fba\\<rbrakk>\n    \\<Longrightarrow> S \\<union> T \\<in> fba", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<in> fba; T \\<in> fba\\<rbrakk>\n    \\<Longrightarrow> S \\<union> T \\<in> fba", "assume \"S \\<in> fba\" and \"T \\<in> fba\""], ["proof (state)\nthis:\n  S \\<in> fba\n  T \\<in> fba\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<in> fba; T \\<in> fba\\<rbrakk>\n    \\<Longrightarrow> S \\<union> T \\<in> fba", "hence \"- (- S \\<inter> - T) \\<in> fba\""], ["proof (prove)\nusing this:\n  S \\<in> fba\n  T \\<in> fba\n\ngoal (1 subgoal):\n 1. - (- S \\<inter> - T) \\<in> fba", "by (intro fba.intros)"], ["proof (state)\nthis:\n  - (- S \\<inter> - T) \\<in> fba\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<in> fba; T \\<in> fba\\<rbrakk>\n    \\<Longrightarrow> S \\<union> T \\<in> fba", "thus \"S \\<union> T \\<in> fba\""], ["proof (prove)\nusing this:\n  - (- S \\<inter> - T) \\<in> fba\n\ngoal (1 subgoal):\n 1. S \\<union> T \\<in> fba", "by simp"], ["proof (state)\nthis:\n  S \\<union> T \\<in> fba\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fba_empty: \"({} :: 'a set set) \\<in> fba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<in> fba", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {} \\<in> fba", "obtain S :: \"'a set set\" where \"S \\<in> fba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S. S \\<in> fba \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (fast intro: fba.var)"], ["proof (state)\nthis:\n  S \\<in> fba\n\ngoal (1 subgoal):\n 1. {} \\<in> fba", "hence \"S \\<inter> - S \\<in> fba\""], ["proof (prove)\nusing this:\n  S \\<in> fba\n\ngoal (1 subgoal):\n 1. S \\<inter> - S \\<in> fba", "by (intro fba.intros)"], ["proof (state)\nthis:\n  S \\<inter> - S \\<in> fba\n\ngoal (1 subgoal):\n 1. {} \\<in> fba", "thus ?thesis"], ["proof (prove)\nusing this:\n  S \\<inter> - S \\<in> fba\n\ngoal (1 subgoal):\n 1. {} \\<in> fba", "by simp"], ["proof (state)\nthis:\n  {} \\<in> fba\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fba_UNIV: \"(UNIV :: 'a set set) \\<in> fba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<in> fba", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UNIV \\<in> fba", "have \"- {} \\<in> fba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - {} \\<in> fba", "using fba_empty"], ["proof (prove)\nusing this:\n  {} \\<in> fba\n\ngoal (1 subgoal):\n 1. - {} \\<in> fba", "by (rule fba.Compl)"], ["proof (state)\nthis:\n  - {} \\<in> fba\n\ngoal (1 subgoal):\n 1. UNIV \\<in> fba", "thus \"UNIV \\<in> fba\""], ["proof (prove)\nusing this:\n  - {} \\<in> fba\n\ngoal (1 subgoal):\n 1. UNIV \\<in> fba", "by simp"], ["proof (state)\nthis:\n  UNIV \\<in> fba\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Free boolean algebra as a type\\<close>"], ["", "text \\<open>\n  The next step is to use \\<open>typedef\\<close> to define a type isomorphic\n  to the set @{const fba}.  We also define a constructor \\<open>var\\<close>\n  that corresponds with the similarly-named introduction rule for\n  @{const fba}.\n\\<close>"], ["", "typedef 'a formula = \"fba :: 'a set set set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> fba", "by (auto intro: fba_empty)"], ["", "definition var :: \"'a \\<Rightarrow> 'a formula\"\nwhere \"var i = Abs_formula {A. i \\<in> A}\""], ["", "lemma Rep_formula_var: \"Rep_formula (var i) = {A. i \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (var i) = {A. i \\<in> A}", "unfolding var_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (Abs_formula (Collect ((\\<in>) i))) = {A. i \\<in> A}", "using fba.var"], ["proof (prove)\nusing this:\n  Collect ((\\<in>) ?i) \\<in> fba\n\ngoal (1 subgoal):\n 1. Rep_formula (Abs_formula (Collect ((\\<in>) i))) = {A. i \\<in> A}", "by (rule Abs_formula_inverse)"], ["", "text \\<open>\n  \\medskip\n  Now we make type @{typ \"'a formula\"} into a Boolean algebra.  This\n  involves defining the various operations (ordering relations, binary\n  infimum and supremum, complement, difference, top and bottom\n  elements) and proving that they satisfy the appropriate laws.\n\\<close>"], ["", "instantiation formula :: (type) boolean_algebra\nbegin"], ["", "definition\n  \"x \\<sqinter> y = Abs_formula (Rep_formula x \\<inter> Rep_formula y)\""], ["", "definition\n  \"x \\<squnion> y = Abs_formula (Rep_formula x \\<union> Rep_formula y)\""], ["", "definition\n  \"\\<top> = Abs_formula UNIV\""], ["", "definition\n  \"\\<bottom> = Abs_formula {}\""], ["", "definition\n  \"x \\<le> y \\<longleftrightarrow> Rep_formula x \\<subseteq> Rep_formula y\""], ["", "definition\n  \"x < y \\<longleftrightarrow> Rep_formula x \\<subset> Rep_formula y\""], ["", "definition\n  \"- x = Abs_formula (- Rep_formula x)\""], ["", "definition\n  \"x - y = Abs_formula (Rep_formula x - Rep_formula y)\""], ["", "lemma Rep_formula_inf:\n  \"Rep_formula (x \\<sqinter> y) = Rep_formula x \\<inter> Rep_formula y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (x \\<sqinter> y) = Rep_formula x \\<inter> Rep_formula y", "unfolding inf_formula_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (Abs_formula (Rep_formula x \\<inter> Rep_formula y)) =\n    Rep_formula x \\<inter> Rep_formula y", "by (intro Abs_formula_inverse fba.inter Rep_formula)"], ["", "lemma Rep_formula_sup:\n  \"Rep_formula (x \\<squnion> y) = Rep_formula x \\<union> Rep_formula y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (x \\<squnion> y) = Rep_formula x \\<union> Rep_formula y", "unfolding sup_formula_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (Abs_formula (Rep_formula x \\<union> Rep_formula y)) =\n    Rep_formula x \\<union> Rep_formula y", "by (intro Abs_formula_inverse fba_union Rep_formula)"], ["", "lemma Rep_formula_top: \"Rep_formula \\<top> = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula \\<top> = UNIV", "unfolding top_formula_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (Abs_formula UNIV) = UNIV", "by (intro Abs_formula_inverse fba_UNIV)"], ["", "lemma Rep_formula_bot: \"Rep_formula \\<bottom> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula \\<bottom> = {}", "unfolding bot_formula_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (Abs_formula {}) = {}", "by (intro Abs_formula_inverse fba_empty)"], ["", "lemma Rep_formula_compl: \"Rep_formula (- x) = - Rep_formula x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (- x) = - Rep_formula x", "unfolding uminus_formula_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (Abs_formula (- Rep_formula x)) = - Rep_formula x", "by (intro Abs_formula_inverse fba.Compl Rep_formula)"], ["", "lemma Rep_formula_diff:\n  \"Rep_formula (x - y) = Rep_formula x - Rep_formula y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (x - y) = Rep_formula x - Rep_formula y", "unfolding minus_formula_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula (Abs_formula (Rep_formula x - Rep_formula y)) =\n    Rep_formula x - Rep_formula y", "by (intro Abs_formula_inverse fba_Diff Rep_formula)"], ["", "lemmas eq_formula_iff = Rep_formula_inject [symmetric]"], ["", "lemmas Rep_formula_simps =\n  less_eq_formula_def less_formula_def eq_formula_iff\n  Rep_formula_sup Rep_formula_inf Rep_formula_top Rep_formula_bot\n  Rep_formula_compl Rep_formula_diff Rep_formula_var"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a formula, boolean_algebra_class)", "proof"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 16 subgoals...", "qed (unfold Rep_formula_simps, auto)"], ["", "end"], ["", "text \\<open>\n  \\medskip\n  The laws of a Boolean algebra do not require the top and bottom\n  elements to be distinct, so the following rules must be proved\n  separately:\n\\<close>"], ["", "lemma bot_neq_top_formula [simp]: \"(\\<bottom> :: 'a formula) \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<noteq> \\<top>", "unfolding Rep_formula_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<noteq> UNIV", "by auto"], ["", "lemma top_neq_bot_formula [simp]: \"(\\<top> :: 'a formula) \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<noteq> \\<bottom>", "unfolding Rep_formula_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<noteq> {}", "by auto"], ["", "text \\<open>\n  \\medskip\n  Here we prove an essential property of a free Boolean algebra:\n  all generators are independent.\n\\<close>"], ["", "lemma var_le_var_simps [simp]:\n  \"var i \\<le> var j \\<longleftrightarrow> i = j\"\n  \"\\<not> var i \\<le> - var j\"\n  \"\\<not> - var i \\<le> var j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (var i \\<le> var j) = (i = j) &&&\n    \\<not> var i \\<le> - var j &&& \\<not> - var i \\<le> var j", "unfolding Rep_formula_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Collect ((\\<in>) i) \\<subseteq> Collect ((\\<in>) j)) = (i = j) &&&\n    \\<not> Collect ((\\<in>) i) \\<subseteq> - Collect ((\\<in>) j) &&&\n    \\<not> - Collect ((\\<in>) i) \\<subseteq> Collect ((\\<in>) j)", "by fast+"], ["", "lemma var_eq_var_simps [simp]:\n  \"var i = var j \\<longleftrightarrow> i = j\"\n  \"var i \\<noteq> - var j\"\n  \"- var i \\<noteq> var j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (var i = var j) = (i = j) &&&\n    var i \\<noteq> - var j &&& - var i \\<noteq> var j", "unfolding Rep_formula_simps set_eq_subset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Collect ((\\<in>) i) \\<subseteq> Collect ((\\<in>) j) \\<and>\n     Collect ((\\<in>) j) \\<subseteq> Collect ((\\<in>) i)) =\n    (i = j) &&&\n    \\<not> (Collect ((\\<in>) i) \\<subseteq> - Collect ((\\<in>) j) \\<and>\n            - Collect ((\\<in>) j) \\<subseteq> Collect ((\\<in>) i)) &&&\n    \\<not> (- Collect ((\\<in>) i) \\<subseteq> Collect ((\\<in>) j) \\<and>\n            Collect ((\\<in>) j) \\<subseteq> - Collect ((\\<in>) i))", "by fast+"], ["", "text \\<open>\n  \\medskip\n  We conclude this section by proving an induction principle for\n  formulas.  It mirrors the definition of the inductive set \\<open>fba\\<close>, with cases for variables, complements, and conjunction.\n\\<close>"], ["", "lemma formula_induct [case_names var compl inf, induct type: formula]:\n  fixes P :: \"'a formula \\<Rightarrow> bool\"\n  assumes 1: \"\\<And>i. P (var i)\"\n  assumes 2: \"\\<And>x. P x \\<Longrightarrow> P (- x)\"\n  assumes 3: \"\\<And>x y. P x \\<Longrightarrow> P y \\<Longrightarrow> P (x \\<sqinter> y)\"\n  shows \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "proof (induct x rule: Abs_formula_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> fba \\<Longrightarrow> P (Abs_formula y)", "fix y :: \"'a set set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> fba \\<Longrightarrow> P (Abs_formula y)", "assume \"y \\<in> fba\""], ["proof (state)\nthis:\n  y \\<in> fba\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> fba \\<Longrightarrow> P (Abs_formula y)", "thus \"P (Abs_formula y)\""], ["proof (prove)\nusing this:\n  y \\<in> fba\n\ngoal (1 subgoal):\n 1. P (Abs_formula y)", "proof (induct rule: fba.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i. P (Abs_formula {A. i \\<in> A})\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (- S))\n 3. \\<And>S T.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S); T \\<in> fba;\n        P (Abs_formula T)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (S \\<inter> T))", "case (var i)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>i. P (Abs_formula {A. i \\<in> A})\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (- S))\n 3. \\<And>S T.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S); T \\<in> fba;\n        P (Abs_formula T)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (S \\<inter> T))", "have \"P (var i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (var i)", "by (rule 1)"], ["proof (state)\nthis:\n  P (var i)\n\ngoal (3 subgoals):\n 1. \\<And>i. P (Abs_formula {A. i \\<in> A})\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (- S))\n 3. \\<And>S T.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S); T \\<in> fba;\n        P (Abs_formula T)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (S \\<inter> T))", "thus ?case"], ["proof (prove)\nusing this:\n  P (var i)\n\ngoal (1 subgoal):\n 1. P (Abs_formula {A. i \\<in> A})", "unfolding var_def"], ["proof (prove)\nusing this:\n  P (Abs_formula (Collect ((\\<in>) i)))\n\ngoal (1 subgoal):\n 1. P (Abs_formula {A. i \\<in> A})", "."], ["proof (state)\nthis:\n  P (Abs_formula {A. i \\<in> A})\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (- S))\n 2. \\<And>S T.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S); T \\<in> fba;\n        P (Abs_formula T)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (S \\<inter> T))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (- S))\n 2. \\<And>S T.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S); T \\<in> fba;\n        P (Abs_formula T)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (S \\<inter> T))", "case (Compl S)"], ["proof (state)\nthis:\n  S \\<in> fba\n  P (Abs_formula S)\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (- S))\n 2. \\<And>S T.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S); T \\<in> fba;\n        P (Abs_formula T)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (S \\<inter> T))", "from \\<open>P (Abs_formula S)\\<close>"], ["proof (chain)\npicking this:\n  P (Abs_formula S)", "have \"P (- Abs_formula S)\""], ["proof (prove)\nusing this:\n  P (Abs_formula S)\n\ngoal (1 subgoal):\n 1. P (- Abs_formula S)", "by (rule 2)"], ["proof (state)\nthis:\n  P (- Abs_formula S)\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (- S))\n 2. \\<And>S T.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S); T \\<in> fba;\n        P (Abs_formula T)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (S \\<inter> T))", "with \\<open>S \\<in> fba\\<close>"], ["proof (chain)\npicking this:\n  S \\<in> fba\n  P (- Abs_formula S)", "show ?case"], ["proof (prove)\nusing this:\n  S \\<in> fba\n  P (- Abs_formula S)\n\ngoal (1 subgoal):\n 1. P (Abs_formula (- S))", "unfolding uminus_formula_def"], ["proof (prove)\nusing this:\n  S \\<in> fba\n  P (Abs_formula (- Rep_formula (Abs_formula S)))\n\ngoal (1 subgoal):\n 1. P (Abs_formula (- S))", "by (simp add: Abs_formula_inverse)"], ["proof (state)\nthis:\n  P (Abs_formula (- S))\n\ngoal (1 subgoal):\n 1. \\<And>S T.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S); T \\<in> fba;\n        P (Abs_formula T)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (S \\<inter> T))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S T.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S); T \\<in> fba;\n        P (Abs_formula T)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (S \\<inter> T))", "case (inter S T)"], ["proof (state)\nthis:\n  S \\<in> fba\n  P (Abs_formula S)\n  T \\<in> fba\n  P (Abs_formula T)\n\ngoal (1 subgoal):\n 1. \\<And>S T.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S); T \\<in> fba;\n        P (Abs_formula T)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (S \\<inter> T))", "from \\<open>P (Abs_formula S)\\<close> and \\<open>P (Abs_formula T)\\<close>"], ["proof (chain)\npicking this:\n  P (Abs_formula S)\n  P (Abs_formula T)", "have \"P (Abs_formula S \\<sqinter> Abs_formula T)\""], ["proof (prove)\nusing this:\n  P (Abs_formula S)\n  P (Abs_formula T)\n\ngoal (1 subgoal):\n 1. P (Abs_formula S \\<sqinter> Abs_formula T)", "by (rule 3)"], ["proof (state)\nthis:\n  P (Abs_formula S \\<sqinter> Abs_formula T)\n\ngoal (1 subgoal):\n 1. \\<And>S T.\n       \\<lbrakk>S \\<in> fba; P (Abs_formula S); T \\<in> fba;\n        P (Abs_formula T)\\<rbrakk>\n       \\<Longrightarrow> P (Abs_formula (S \\<inter> T))", "with \\<open>S \\<in> fba\\<close> and \\<open>T \\<in> fba\\<close>"], ["proof (chain)\npicking this:\n  S \\<in> fba\n  T \\<in> fba\n  P (Abs_formula S \\<sqinter> Abs_formula T)", "show ?case"], ["proof (prove)\nusing this:\n  S \\<in> fba\n  T \\<in> fba\n  P (Abs_formula S \\<sqinter> Abs_formula T)\n\ngoal (1 subgoal):\n 1. P (Abs_formula (S \\<inter> T))", "unfolding inf_formula_def"], ["proof (prove)\nusing this:\n  S \\<in> fba\n  T \\<in> fba\n  P (Abs_formula\n      (Rep_formula (Abs_formula S) \\<inter> Rep_formula (Abs_formula T)))\n\ngoal (1 subgoal):\n 1. P (Abs_formula (S \\<inter> T))", "by (simp add: Abs_formula_inverse)"], ["proof (state)\nthis:\n  P (Abs_formula (S \\<inter> T))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (Abs_formula y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>If-then-else for Boolean algebras\\<close>"], ["", "text \\<open>\n  This is a generic if-then-else operator for arbitrary Boolean\n  algebras.\n\\<close>"], ["", "definition\n  ifte :: \"'a::boolean_algebra \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\nwhere\n  \"ifte a x y = (a \\<sqinter> x) \\<squnion> (- a \\<sqinter> y)\""], ["", "lemma ifte_top [simp]: \"ifte \\<top> x y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ifte \\<top> x y = x", "unfolding ifte_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<sqinter> x \\<squnion> - \\<top> \\<sqinter> y = x", "by simp"], ["", "lemma ifte_bot [simp]: \"ifte \\<bottom> x y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ifte \\<bottom> x y = y", "unfolding ifte_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<sqinter> x \\<squnion> - \\<bottom> \\<sqinter> y = y", "by simp"], ["", "lemma ifte_same: \"ifte a x x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ifte a x x = x", "unfolding ifte_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter> x \\<squnion> - a \\<sqinter> x = x", "by (simp add: inf_sup_distrib2 [symmetric] sup_compl_top)"], ["", "lemma compl_ifte: \"- ifte a x y = ifte a (- x) (- y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ifte a x y = ifte a (- x) (- y)", "unfolding ifte_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (a \\<sqinter> x \\<squnion> - a \\<sqinter> y) =\n    a \\<sqinter> - x \\<squnion> - a \\<sqinter> - y", "apply (rule order_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - (a \\<sqinter> x \\<squnion> - a \\<sqinter> y)\n    \\<le> a \\<sqinter> - x \\<squnion> - a \\<sqinter> - y\n 2. a \\<sqinter> - x \\<squnion> - a \\<sqinter> - y\n    \\<le> - (a \\<sqinter> x \\<squnion> - a \\<sqinter> y)", "apply (simp add: inf_sup_distrib1 inf_sup_distrib2 compl_inf_bot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - x \\<sqinter> a\n    \\<le> a \\<sqinter> - x \\<squnion> - a \\<sqinter> - y \\<and>\n    - x \\<sqinter> - y \\<le> a \\<sqinter> - x \\<squnion> - a \\<sqinter> - y\n 2. a \\<sqinter> - x \\<squnion> - a \\<sqinter> - y\n    \\<le> - (a \\<sqinter> x \\<squnion> - a \\<sqinter> y)", "apply (simp add: sup_inf_distrib1 sup_inf_distrib2 sup_compl_top)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - x \\<sqinter> a \\<le> - x \\<squnion> - a \\<and>\n    - x \\<sqinter> a \\<le> a \\<squnion> - y \\<and>\n    - x \\<sqinter> a \\<le> - x \\<squnion> - y \\<and>\n    - x \\<sqinter> - y \\<le> - x \\<squnion> - a \\<and>\n    - x \\<sqinter> - y \\<le> a \\<squnion> - y \\<and>\n    - x \\<sqinter> - y \\<le> - x \\<squnion> - y\n 2. a \\<sqinter> - x \\<squnion> - a \\<sqinter> - y\n    \\<le> - (a \\<sqinter> x \\<squnion> - a \\<sqinter> y)", "apply (simp add: le_infI1 le_infI2 le_supI1 le_supI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter> - x \\<squnion> - a \\<sqinter> - y\n    \\<le> - (a \\<sqinter> x \\<squnion> - a \\<sqinter> y)", "apply (simp add: le_infI1 le_infI2 le_supI1 le_supI2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inf_ifte_distrib:\n  \"ifte x a b \\<sqinter> ifte x c d = ifte x (a \\<sqinter> c) (b \\<sqinter> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ifte x a b \\<sqinter> ifte x c d =\n    ifte x (a \\<sqinter> c) (b \\<sqinter> d)", "unfolding ifte_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> a \\<squnion> - x \\<sqinter> b) \\<sqinter>\n    (x \\<sqinter> c \\<squnion> - x \\<sqinter> d) =\n    x \\<sqinter> (a \\<sqinter> c) \\<squnion> - x \\<sqinter> (b \\<sqinter> d)", "apply (simp add: inf_sup_distrib1 inf_sup_distrib2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> a \\<sqinter> (x \\<sqinter> c) \\<squnion>\n    - x \\<sqinter> b \\<sqinter> (- x \\<sqinter> d) =\n    x \\<sqinter> (a \\<sqinter> c) \\<squnion> - x \\<sqinter> (b \\<sqinter> d)", "apply (simp add: inf_sup_aci inf_compl_bot)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ifte_ifte_distrib:\n  \"ifte x (ifte y a b) (ifte y c d) = ifte y (ifte x a c) (ifte x b d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ifte x (ifte y a b) (ifte y c d) = ifte y (ifte x a c) (ifte x b d)", "unfolding ifte_def [of x] sup_conv_inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- (x \\<sqinter> ifte y a b) \\<sqinter>\n       - (- x \\<sqinter> ifte y c d)) =\n    ifte y (- (- (x \\<sqinter> a) \\<sqinter> - (- x \\<sqinter> c)))\n     (- (- (x \\<sqinter> b) \\<sqinter> - (- x \\<sqinter> d)))", "by (simp only: compl_ifte [symmetric] inf_ifte_distrib [symmetric] ifte_same)"], ["", "subsection \\<open>Formulas over a set of generators\\<close>"], ["", "text \\<open>\n  The set \\<open>formulas S\\<close> consists of those formulas that only\n  depend on variables in the set \\<open>S\\<close>.  It is analogous to the\n  @{const lists} operator for the list datatype.\n\\<close>"], ["", "definition\n  formulas :: \"'a set \\<Rightarrow> 'a formula set\"\nwhere\n  \"formulas S =\n    {x. \\<forall>A B. (\\<forall>i\\<in>S. i \\<in> A \\<longleftrightarrow> i \\<in> B) \\<longrightarrow>\n      A \\<in> Rep_formula x \\<longleftrightarrow> B \\<in> Rep_formula x}\""], ["", "lemma formulasI:\n  assumes \"\\<And>A B. \\<forall>i\\<in>S. i \\<in> A \\<longleftrightarrow> i \\<in> B\n    \\<Longrightarrow> A \\<in> Rep_formula x \\<longleftrightarrow> B \\<in> Rep_formula x\"\n  shows \"x \\<in> formulas S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> formulas S", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>S. (i \\<in> ?A) = (i \\<in> ?B) \\<Longrightarrow>\n  (?A \\<in> Rep_formula x) = (?B \\<in> Rep_formula x)\n\ngoal (1 subgoal):\n 1. x \\<in> formulas S", "unfolding formulas_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>S. (i \\<in> ?A) = (i \\<in> ?B) \\<Longrightarrow>\n  (?A \\<in> Rep_formula x) = (?B \\<in> Rep_formula x)\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<forall>A B.\n                   (\\<forall>i\\<in>S.\n                       (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                   (A \\<in> Rep_formula x) = (B \\<in> Rep_formula x)}", "by simp"], ["", "lemma formulasD:\n  assumes \"x \\<in> formulas S\"\n  assumes \"\\<forall>i\\<in>S. i \\<in> A \\<longleftrightarrow> i \\<in> B\"\n  shows \"A \\<in> Rep_formula x \\<longleftrightarrow> B \\<in> Rep_formula x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<in> Rep_formula x) = (B \\<in> Rep_formula x)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> formulas S\n  \\<forall>i\\<in>S. (i \\<in> A) = (i \\<in> B)\n\ngoal (1 subgoal):\n 1. (A \\<in> Rep_formula x) = (B \\<in> Rep_formula x)", "unfolding formulas_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<forall>A B.\n                 (\\<forall>i\\<in>S.\n                     (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                 (A \\<in> Rep_formula x) = (B \\<in> Rep_formula x)}\n  \\<forall>i\\<in>S. (i \\<in> A) = (i \\<in> B)\n\ngoal (1 subgoal):\n 1. (A \\<in> Rep_formula x) = (B \\<in> Rep_formula x)", "by simp"], ["", "lemma formulas_mono: \"S \\<subseteq> T \\<Longrightarrow> formulas S \\<subseteq> formulas T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> T \\<Longrightarrow> formulas S \\<subseteq> formulas T", "by (fast intro!: formulasI elim!: formulasD)"], ["", "lemma formulas_insert: \"x \\<in> formulas S \\<Longrightarrow> x \\<in> formulas (insert a S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> formulas S \\<Longrightarrow> x \\<in> formulas (insert a S)", "unfolding formulas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<forall>A B.\n                   (\\<forall>i\\<in>S.\n                       (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                   (A \\<in> Rep_formula x) =\n                   (B \\<in> Rep_formula x)} \\<Longrightarrow>\n    x \\<in> {x. \\<forall>A B.\n                   (\\<forall>i\\<in>insert a S.\n                       (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                   (A \\<in> Rep_formula x) = (B \\<in> Rep_formula x)}", "by simp"], ["", "lemma formulas_var: \"i \\<in> S \\<Longrightarrow> var i \\<in> formulas S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> S \\<Longrightarrow> var i \\<in> formulas S", "unfolding formulas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> S \\<Longrightarrow>\n    var i\n    \\<in> {x. \\<forall>A B.\n                 (\\<forall>i\\<in>S.\n                     (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                 (A \\<in> Rep_formula x) = (B \\<in> Rep_formula x)}", "by (simp add: Rep_formula_simps)"], ["", "lemma formulas_var_iff: \"var i \\<in> formulas S \\<longleftrightarrow> i \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (var i \\<in> formulas S) = (i \\<in> S)", "unfolding formulas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (var i\n     \\<in> {x. \\<forall>A B.\n                  (\\<forall>i\\<in>S.\n                      (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                  (A \\<in> Rep_formula x) = (B \\<in> Rep_formula x)}) =\n    (i \\<in> S)", "by (simp add: Rep_formula_simps, fast)"], ["", "lemma formulas_bot: \"\\<bottom> \\<in> formulas S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<in> formulas S", "unfolding formulas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom>\n    \\<in> {x. \\<forall>A B.\n                 (\\<forall>i\\<in>S.\n                     (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                 (A \\<in> Rep_formula x) = (B \\<in> Rep_formula x)}", "by (simp add: Rep_formula_simps)"], ["", "lemma formulas_top: \"\\<top> \\<in> formulas S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<in> formulas S", "unfolding formulas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top>\n    \\<in> {x. \\<forall>A B.\n                 (\\<forall>i\\<in>S.\n                     (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                 (A \\<in> Rep_formula x) = (B \\<in> Rep_formula x)}", "by (simp add: Rep_formula_simps)"], ["", "lemma formulas_compl: \"x \\<in> formulas S \\<Longrightarrow> - x \\<in> formulas S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> formulas S \\<Longrightarrow> - x \\<in> formulas S", "unfolding formulas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<forall>A B.\n                   (\\<forall>i\\<in>S.\n                       (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                   (A \\<in> Rep_formula x) =\n                   (B \\<in> Rep_formula x)} \\<Longrightarrow>\n    - x\n    \\<in> {x. \\<forall>A B.\n                 (\\<forall>i\\<in>S.\n                     (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                 (A \\<in> Rep_formula x) = (B \\<in> Rep_formula x)}", "by (simp add: Rep_formula_simps)"], ["", "lemma formulas_inf:\n  \"x \\<in> formulas S \\<Longrightarrow> y \\<in> formulas S \\<Longrightarrow> x \\<sqinter> y \\<in> formulas S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> formulas S; y \\<in> formulas S\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<in> formulas S", "unfolding formulas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {x. \\<forall>A B.\n                            (\\<forall>i\\<in>S.\n                                (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                            (A \\<in> Rep_formula x) =\n                            (B \\<in> Rep_formula x)};\n     y \\<in> {x. \\<forall>A B.\n                    (\\<forall>i\\<in>S.\n                        (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                    (A \\<in> Rep_formula x) =\n                    (B \\<in> Rep_formula x)}\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y\n                      \\<in> {x. \\<forall>A B.\n                                   (\\<forall>i\\<in>S.\n (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                                   (A \\<in> Rep_formula x) =\n                                   (B \\<in> Rep_formula x)}", "by (auto simp add: Rep_formula_simps)"], ["", "lemma formulas_sup:\n  \"x \\<in> formulas S \\<Longrightarrow> y \\<in> formulas S \\<Longrightarrow> x \\<squnion> y \\<in> formulas S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> formulas S; y \\<in> formulas S\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y \\<in> formulas S", "unfolding formulas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {x. \\<forall>A B.\n                            (\\<forall>i\\<in>S.\n                                (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                            (A \\<in> Rep_formula x) =\n                            (B \\<in> Rep_formula x)};\n     y \\<in> {x. \\<forall>A B.\n                    (\\<forall>i\\<in>S.\n                        (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                    (A \\<in> Rep_formula x) =\n                    (B \\<in> Rep_formula x)}\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y\n                      \\<in> {x. \\<forall>A B.\n                                   (\\<forall>i\\<in>S.\n (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                                   (A \\<in> Rep_formula x) =\n                                   (B \\<in> Rep_formula x)}", "by (auto simp add: Rep_formula_simps)"], ["", "lemma formulas_diff:\n  \"x \\<in> formulas S \\<Longrightarrow> y \\<in> formulas S \\<Longrightarrow> x - y \\<in> formulas S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> formulas S; y \\<in> formulas S\\<rbrakk>\n    \\<Longrightarrow> x - y \\<in> formulas S", "unfolding formulas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {x. \\<forall>A B.\n                            (\\<forall>i\\<in>S.\n                                (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                            (A \\<in> Rep_formula x) =\n                            (B \\<in> Rep_formula x)};\n     y \\<in> {x. \\<forall>A B.\n                    (\\<forall>i\\<in>S.\n                        (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                    (A \\<in> Rep_formula x) =\n                    (B \\<in> Rep_formula x)}\\<rbrakk>\n    \\<Longrightarrow> x - y\n                      \\<in> {x. \\<forall>A B.\n                                   (\\<forall>i\\<in>S.\n (i \\<in> A) = (i \\<in> B)) \\<longrightarrow>\n                                   (A \\<in> Rep_formula x) =\n                                   (B \\<in> Rep_formula x)}", "by (auto simp add: Rep_formula_simps)"], ["", "lemma formulas_ifte:\n  \"a \\<in> formulas S \\<Longrightarrow> x \\<in> formulas S \\<Longrightarrow> y \\<in> formulas S \\<Longrightarrow>\n    ifte a x y \\<in> formulas S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> formulas S; x \\<in> formulas S;\n     y \\<in> formulas S\\<rbrakk>\n    \\<Longrightarrow> ifte a x y \\<in> formulas S", "unfolding ifte_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> formulas S; x \\<in> formulas S;\n     y \\<in> formulas S\\<rbrakk>\n    \\<Longrightarrow> a \\<sqinter> x \\<squnion> - a \\<sqinter> y\n                      \\<in> formulas S", "by (intro formulas_sup formulas_inf formulas_compl)"], ["", "lemmas formulas_intros =\n  formulas_var formulas_bot formulas_top formulas_compl\n  formulas_inf formulas_sup formulas_diff formulas_ifte"], ["", "subsection \\<open>Injectivity of if-then-else\\<close>"], ["", "text \\<open>\n  The if-then-else operator is injective in some limited\n  circumstances: when the scrutinee is a variable that is not\n  mentioned in either branch.\n\\<close>"], ["", "lemma ifte_inject:\n  assumes \"ifte (var i) x y = ifte (var i) x' y'\" \n  assumes \"i \\<notin> S\"\n  assumes \"x \\<in> formulas S\" and \"x' \\<in> formulas S\"\n  assumes \"y \\<in> formulas S\" and \"y' \\<in> formulas S\"\n  shows \"x = x' \\<and> y = y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x' \\<and> y = y'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x = x'\n 2. y = y'", "have 1: \"\\<And>A. i \\<in> A \\<Longrightarrow> A \\<in> Rep_formula x \\<longleftrightarrow> A \\<in> Rep_formula x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       i \\<in> A \\<Longrightarrow>\n       (A \\<in> Rep_formula x) = (A \\<in> Rep_formula x')", "using assms(1)"], ["proof (prove)\nusing this:\n  ifte (var i) x y = ifte (var i) x' y'\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       i \\<in> A \\<Longrightarrow>\n       (A \\<in> Rep_formula x) = (A \\<in> Rep_formula x')", "by (simp add: Rep_formula_simps ifte_def set_eq_iff, fast)"], ["proof (state)\nthis:\n  i \\<in> ?A \\<Longrightarrow>\n  (?A \\<in> Rep_formula x) = (?A \\<in> Rep_formula x')\n\ngoal (2 subgoals):\n 1. x = x'\n 2. y = y'", "have 2: \"\\<And>A. i \\<notin> A \\<Longrightarrow> A \\<in> Rep_formula y \\<longleftrightarrow> A \\<in> Rep_formula y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       i \\<notin> A \\<Longrightarrow>\n       (A \\<in> Rep_formula y) = (A \\<in> Rep_formula y')", "using assms(1)"], ["proof (prove)\nusing this:\n  ifte (var i) x y = ifte (var i) x' y'\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       i \\<notin> A \\<Longrightarrow>\n       (A \\<in> Rep_formula y) = (A \\<in> Rep_formula y')", "by (simp add: Rep_formula_simps ifte_def set_eq_iff, fast)"], ["proof (state)\nthis:\n  i \\<notin> ?A \\<Longrightarrow>\n  (?A \\<in> Rep_formula y) = (?A \\<in> Rep_formula y')\n\ngoal (2 subgoals):\n 1. x = x'\n 2. y = y'", "show \"x = x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x'", "unfolding Rep_formula_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula x = Rep_formula x'", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. (xa \\<in> Rep_formula x) = (xa \\<in> Rep_formula x')", "fix A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. (xa \\<in> Rep_formula x) = (xa \\<in> Rep_formula x')", "have \"A \\<in> Rep_formula x \\<longleftrightarrow> insert i A \\<in> Rep_formula x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<in> Rep_formula x) = (insert i A \\<in> Rep_formula x)", "using \\<open>x \\<in> formulas S\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> formulas S\n\ngoal (1 subgoal):\n 1. (A \\<in> Rep_formula x) = (insert i A \\<in> Rep_formula x)", "by (rule formulasD, force simp add: \\<open>i \\<notin> S\\<close>)"], ["proof (state)\nthis:\n  (A \\<in> Rep_formula x) = (insert i A \\<in> Rep_formula x)\n\ngoal (1 subgoal):\n 1. \\<And>xa. (xa \\<in> Rep_formula x) = (xa \\<in> Rep_formula x')", "also"], ["proof (state)\nthis:\n  (A \\<in> Rep_formula x) = (insert i A \\<in> Rep_formula x)\n\ngoal (1 subgoal):\n 1. \\<And>xa. (xa \\<in> Rep_formula x) = (xa \\<in> Rep_formula x')", "have \"\\<dots> \\<longleftrightarrow> insert i A \\<in> Rep_formula x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (insert i A \\<in> Rep_formula x) = (insert i A \\<in> Rep_formula x')", "by (rule 1, simp)"], ["proof (state)\nthis:\n  (insert i A \\<in> Rep_formula x) = (insert i A \\<in> Rep_formula x')\n\ngoal (1 subgoal):\n 1. \\<And>xa. (xa \\<in> Rep_formula x) = (xa \\<in> Rep_formula x')", "also"], ["proof (state)\nthis:\n  (insert i A \\<in> Rep_formula x) = (insert i A \\<in> Rep_formula x')\n\ngoal (1 subgoal):\n 1. \\<And>xa. (xa \\<in> Rep_formula x) = (xa \\<in> Rep_formula x')", "have \"\\<dots> \\<longleftrightarrow> A \\<in> Rep_formula x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (insert i A \\<in> Rep_formula x') = (A \\<in> Rep_formula x')", "using \\<open>x' \\<in> formulas S\\<close>"], ["proof (prove)\nusing this:\n  x' \\<in> formulas S\n\ngoal (1 subgoal):\n 1. (insert i A \\<in> Rep_formula x') = (A \\<in> Rep_formula x')", "by (rule formulasD, force simp add: \\<open>i \\<notin> S\\<close>)"], ["proof (state)\nthis:\n  (insert i A \\<in> Rep_formula x') = (A \\<in> Rep_formula x')\n\ngoal (1 subgoal):\n 1. \\<And>xa. (xa \\<in> Rep_formula x) = (xa \\<in> Rep_formula x')", "finally"], ["proof (chain)\npicking this:\n  (A \\<in> Rep_formula x) = (A \\<in> Rep_formula x')", "show \"A \\<in> Rep_formula x \\<longleftrightarrow> A \\<in> Rep_formula x'\""], ["proof (prove)\nusing this:\n  (A \\<in> Rep_formula x) = (A \\<in> Rep_formula x')\n\ngoal (1 subgoal):\n 1. (A \\<in> Rep_formula x) = (A \\<in> Rep_formula x')", "."], ["proof (state)\nthis:\n  (A \\<in> Rep_formula x) = (A \\<in> Rep_formula x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = x'\n\ngoal (1 subgoal):\n 1. y = y'", "show  \"y = y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = y'", "unfolding Rep_formula_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_formula y = Rep_formula y'", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> Rep_formula y) = (x \\<in> Rep_formula y')", "fix A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> Rep_formula y) = (x \\<in> Rep_formula y')", "have \"A \\<in> Rep_formula y \\<longleftrightarrow> A - {i} \\<in> Rep_formula y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<in> Rep_formula y) = (A - {i} \\<in> Rep_formula y)", "using \\<open>y \\<in> formulas S\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> formulas S\n\ngoal (1 subgoal):\n 1. (A \\<in> Rep_formula y) = (A - {i} \\<in> Rep_formula y)", "by (rule formulasD, force simp add: \\<open>i \\<notin> S\\<close>)"], ["proof (state)\nthis:\n  (A \\<in> Rep_formula y) = (A - {i} \\<in> Rep_formula y)\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> Rep_formula y) = (x \\<in> Rep_formula y')", "also"], ["proof (state)\nthis:\n  (A \\<in> Rep_formula y) = (A - {i} \\<in> Rep_formula y)\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> Rep_formula y) = (x \\<in> Rep_formula y')", "have \"\\<dots> \\<longleftrightarrow> A - {i} \\<in> Rep_formula y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - {i} \\<in> Rep_formula y) = (A - {i} \\<in> Rep_formula y')", "by (rule 2, simp)"], ["proof (state)\nthis:\n  (A - {i} \\<in> Rep_formula y) = (A - {i} \\<in> Rep_formula y')\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> Rep_formula y) = (x \\<in> Rep_formula y')", "also"], ["proof (state)\nthis:\n  (A - {i} \\<in> Rep_formula y) = (A - {i} \\<in> Rep_formula y')\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> Rep_formula y) = (x \\<in> Rep_formula y')", "have \"\\<dots> \\<longleftrightarrow> A \\<in> Rep_formula y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - {i} \\<in> Rep_formula y') = (A \\<in> Rep_formula y')", "using \\<open>y' \\<in> formulas S\\<close>"], ["proof (prove)\nusing this:\n  y' \\<in> formulas S\n\ngoal (1 subgoal):\n 1. (A - {i} \\<in> Rep_formula y') = (A \\<in> Rep_formula y')", "by (rule formulasD, force simp add: \\<open>i \\<notin> S\\<close>)"], ["proof (state)\nthis:\n  (A - {i} \\<in> Rep_formula y') = (A \\<in> Rep_formula y')\n\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> Rep_formula y) = (x \\<in> Rep_formula y')", "finally"], ["proof (chain)\npicking this:\n  (A \\<in> Rep_formula y) = (A \\<in> Rep_formula y')", "show \"A \\<in> Rep_formula y \\<longleftrightarrow> A \\<in> Rep_formula y'\""], ["proof (prove)\nusing this:\n  (A \\<in> Rep_formula y) = (A \\<in> Rep_formula y')\n\ngoal (1 subgoal):\n 1. (A \\<in> Rep_formula y) = (A \\<in> Rep_formula y')", "."], ["proof (state)\nthis:\n  (A \\<in> Rep_formula y) = (A \\<in> Rep_formula y')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y = y'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Specification of homomorphism operator\\<close>"], ["", "text \\<open>\n  Our goal is to define a homomorphism operator \\<open>hom\\<close> such that\n  for any function \\<open>f\\<close>, \\<open>hom f\\<close> is the unique Boolean\n  algebra homomorphism satisfying \\<open>hom f (var i) = f i\\<close>\n  for all \\<open>i\\<close>.\n\n  Instead of defining \\<open>hom\\<close> directly, we will follow the\n  approach used to define Isabelle's \\<open>fold\\<close> operator for finite\n  sets.  First we define the graph of the \\<open>hom\\<close> function as a\n  relation; later we will define the \\<open>hom\\<close> function itself using\n  definite choice.\n\n  The \\<open>hom_graph\\<close> relation is defined inductively, with\n  introduction rules based on the if-then-else normal form of Boolean\n  formulas.  The relation is also indexed by an extra set parameter\n  \\<open>S\\<close>, to ensure that branches of each if-then-else do not use\n  the same variable again.\n\\<close>"], ["", "inductive\n  hom_graph ::\n    \"('a \\<Rightarrow> 'b::boolean_algebra) \\<Rightarrow> 'a set \\<Rightarrow> 'a formula \\<Rightarrow> 'b \\<Rightarrow> bool\"\n  for f :: \"'a \\<Rightarrow> 'b::boolean_algebra\"\nwhere\n  bot: \"hom_graph f {} bot bot\"\n| top: \"hom_graph f {} top top\"\n| ifte: \"i \\<notin> S \\<Longrightarrow> hom_graph f S x a \\<Longrightarrow> hom_graph f S y b \\<Longrightarrow>\n  hom_graph f (insert i S) (ifte (var i) x y) (ifte (f i) a b)\""], ["", "text \\<open>\n  \\medskip\n  The next two lemmas establish a stronger elimination rule for\n  assumptions of the form @{term \"hom_graph f (insert i S) x a\"}.\n  Essentially, they say that we can arrange the top-level if-then-else\n  to use the variable of our choice.  The proof makes use of the\n  distributive properties of if-then-else.\n\\<close>"], ["", "lemma hom_graph_dest:\n  \"hom_graph f S x a \\<Longrightarrow> k \\<in> S \\<Longrightarrow> \\<exists>y z b c.\n    x = ifte (var k) y z \\<and> a = ifte (f k) b c \\<and>\n    hom_graph f (S - {k}) y b \\<and> hom_graph f (S - {k}) z c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hom_graph f S x a; k \\<in> S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y z b c.\n                         x = ifte (var k) y z \\<and>\n                         a = ifte (f k) b c \\<and>\n                         hom_graph f (S - {k}) y b \\<and>\n                         hom_graph f (S - {k}) z c", "proof (induct set: hom_graph)"], ["proof (state)\ngoal (3 subgoals):\n 1. k \\<in> {} \\<Longrightarrow>\n    \\<exists>y z b c.\n       \\<bottom> = ifte (var k) y z \\<and>\n       \\<bottom> = ifte (f k) b c \\<and>\n       hom_graph f ({} - {k}) y b \\<and> hom_graph f ({} - {k}) z c\n 2. k \\<in> {} \\<Longrightarrow>\n    \\<exists>y z b c.\n       \\<top> = ifte (var k) y z \\<and>\n       \\<top> = ifte (f k) b c \\<and>\n       hom_graph f ({} - {k}) y b \\<and> hom_graph f ({} - {k}) z c\n 3. \\<And>i S x a y b.\n       \\<lbrakk>i \\<notin> S; hom_graph f S x a;\n        k \\<in> S \\<Longrightarrow>\n        \\<exists>y z b c.\n           x = ifte (var k) y z \\<and>\n           a = ifte (f k) b c \\<and>\n           hom_graph f (S - {k}) y b \\<and> hom_graph f (S - {k}) z c;\n        hom_graph f S y b;\n        k \\<in> S \\<Longrightarrow>\n        \\<exists>ya z ba c.\n           y = ifte (var k) ya z \\<and>\n           b = ifte (f k) ba c \\<and>\n           hom_graph f (S - {k}) ya ba \\<and> hom_graph f (S - {k}) z c;\n        k \\<in> insert i S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya z ba c.\n                            ifte (var i) x y = ifte (var k) ya z \\<and>\n                            ifte (f i) a b = ifte (f k) ba c \\<and>\n                            hom_graph f (insert i S - {k}) ya ba \\<and>\n                            hom_graph f (insert i S - {k}) z c", "case (ifte i S x a y b)"], ["proof (state)\nthis:\n  i \\<notin> S\n  hom_graph f S x a\n  k \\<in> S \\<Longrightarrow>\n  \\<exists>y z b c.\n     x = ifte (var k) y z \\<and>\n     a = ifte (f k) b c \\<and>\n     hom_graph f (S - {k}) y b \\<and> hom_graph f (S - {k}) z c\n  hom_graph f S y b\n  k \\<in> S \\<Longrightarrow>\n  \\<exists>ya z ba c.\n     y = ifte (var k) ya z \\<and>\n     b = ifte (f k) ba c \\<and>\n     hom_graph f (S - {k}) ya ba \\<and> hom_graph f (S - {k}) z c\n  k \\<in> insert i S\n\ngoal (3 subgoals):\n 1. k \\<in> {} \\<Longrightarrow>\n    \\<exists>y z b c.\n       \\<bottom> = ifte (var k) y z \\<and>\n       \\<bottom> = ifte (f k) b c \\<and>\n       hom_graph f ({} - {k}) y b \\<and> hom_graph f ({} - {k}) z c\n 2. k \\<in> {} \\<Longrightarrow>\n    \\<exists>y z b c.\n       \\<top> = ifte (var k) y z \\<and>\n       \\<top> = ifte (f k) b c \\<and>\n       hom_graph f ({} - {k}) y b \\<and> hom_graph f ({} - {k}) z c\n 3. \\<And>i S x a y b.\n       \\<lbrakk>i \\<notin> S; hom_graph f S x a;\n        k \\<in> S \\<Longrightarrow>\n        \\<exists>y z b c.\n           x = ifte (var k) y z \\<and>\n           a = ifte (f k) b c \\<and>\n           hom_graph f (S - {k}) y b \\<and> hom_graph f (S - {k}) z c;\n        hom_graph f S y b;\n        k \\<in> S \\<Longrightarrow>\n        \\<exists>ya z ba c.\n           y = ifte (var k) ya z \\<and>\n           b = ifte (f k) ba c \\<and>\n           hom_graph f (S - {k}) ya ba \\<and> hom_graph f (S - {k}) z c;\n        k \\<in> insert i S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya z ba c.\n                            ifte (var i) x y = ifte (var k) ya z \\<and>\n                            ifte (f i) a b = ifte (f k) ba c \\<and>\n                            hom_graph f (insert i S - {k}) ya ba \\<and>\n                            hom_graph f (insert i S - {k}) z c", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c\n 2. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c", "assume \"i = k\""], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c\n 2. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c", "with ifte(1,2,4)"], ["proof (chain)\npicking this:\n  i \\<notin> S\n  hom_graph f S x a\n  hom_graph f S y b\n  i = k", "show ?case"], ["proof (prove)\nusing this:\n  i \\<notin> S\n  hom_graph f S x a\n  hom_graph f S y b\n  i = k\n\ngoal (1 subgoal):\n 1. \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c", "by auto"], ["proof (state)\nthis:\n  \\<exists>ya z ba c.\n     ifte (var i) x y = ifte (var k) ya z \\<and>\n     ifte (f i) a b = ifte (f k) ba c \\<and>\n     hom_graph f (insert i S - {k}) ya ba \\<and>\n     hom_graph f (insert i S - {k}) z c\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c", "assume \"i \\<noteq> k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c", "with \\<open>k \\<in> insert i S\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> insert i S\n  i \\<noteq> k", "have k: \"k \\<in> S\""], ["proof (prove)\nusing this:\n  k \\<in> insert i S\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. k \\<in> S", "by simp"], ["proof (state)\nthis:\n  k \\<in> S\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c", "have *: \"insert i S - {k} = insert i (S - {k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert i S - {k} = insert i (S - {k})", "using \\<open>i \\<noteq> k\\<close>"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. insert i S - {k} = insert i (S - {k})", "by (simp add: insert_Diff_if)"], ["proof (state)\nthis:\n  insert i S - {k} = insert i (S - {k})\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c", "have **: \"i \\<notin> S - {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> S - {k}", "using \\<open>i \\<notin> S\\<close>"], ["proof (prove)\nusing this:\n  i \\<notin> S\n\ngoal (1 subgoal):\n 1. i \\<notin> S - {k}", "by simp"], ["proof (state)\nthis:\n  i \\<notin> S - {k}\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c", "from ifte(1) ifte(3) [OF k] ifte(5) [OF k]"], ["proof (chain)\npicking this:\n  i \\<notin> S\n  \\<exists>y z b c.\n     x = ifte (var k) y z \\<and>\n     a = ifte (f k) b c \\<and>\n     hom_graph f (S - {k}) y b \\<and> hom_graph f (S - {k}) z c\n  \\<exists>ya z ba c.\n     y = ifte (var k) ya z \\<and>\n     b = ifte (f k) ba c \\<and>\n     hom_graph f (S - {k}) ya ba \\<and> hom_graph f (S - {k}) z c", "show ?case"], ["proof (prove)\nusing this:\n  i \\<notin> S\n  \\<exists>y z b c.\n     x = ifte (var k) y z \\<and>\n     a = ifte (f k) b c \\<and>\n     hom_graph f (S - {k}) y b \\<and> hom_graph f (S - {k}) z c\n  \\<exists>ya z ba c.\n     y = ifte (var k) ya z \\<and>\n     b = ifte (f k) ba c \\<and>\n     hom_graph f (S - {k}) ya ba \\<and> hom_graph f (S - {k}) z c\n\ngoal (1 subgoal):\n 1. \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i S - {k}) ya ba \\<and>\n       hom_graph f (insert i S - {k}) z c", "unfolding *"], ["proof (prove)\nusing this:\n  i \\<notin> S\n  \\<exists>y z b c.\n     x = ifte (var k) y z \\<and>\n     a = ifte (f k) b c \\<and>\n     hom_graph f (S - {k}) y b \\<and> hom_graph f (S - {k}) z c\n  \\<exists>ya z ba c.\n     y = ifte (var k) ya z \\<and>\n     b = ifte (f k) ba c \\<and>\n     hom_graph f (S - {k}) ya ba \\<and> hom_graph f (S - {k}) z c\n\ngoal (1 subgoal):\n 1. \\<exists>ya z ba c.\n       ifte (var i) x y = ifte (var k) ya z \\<and>\n       ifte (f i) a b = ifte (f k) ba c \\<and>\n       hom_graph f (insert i (S - {k})) ya ba \\<and>\n       hom_graph f (insert i (S - {k})) z c", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya yaa z za ba baa c ca.\n       \\<lbrakk>i \\<notin> S; x = ifte (var k) ya z;\n        y = ifte (var k) yaa za; a = ifte (f k) ba c; b = ifte (f k) baa ca;\n        hom_graph f (S - {k}) ya ba; hom_graph f (S - {k}) z c;\n        hom_graph f (S - {k}) yaa baa; hom_graph f (S - {k}) za ca\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y zb b cb.\n                            ifte (var i) (ifte (var k) ya z)\n                             (ifte (var k) yaa za) =\n                            ifte (var k) y zb \\<and>\n                            ifte (f i) (ifte (f k) ba c)\n                             (ifte (f k) baa ca) =\n                            ifte (f k) b cb \\<and>\n                            hom_graph f (insert i (S - {k})) y b \\<and>\n                            hom_graph f (insert i (S - {k})) zb cb", "apply (simp only: ifte_ifte_distrib [of \"var i\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya yaa z za ba baa c ca.\n       \\<lbrakk>i \\<notin> S; x = ifte (var k) ya z;\n        y = ifte (var k) yaa za; a = ifte (f k) ba c; b = ifte (f k) baa ca;\n        hom_graph f (S - {k}) ya ba; hom_graph f (S - {k}) z c;\n        hom_graph f (S - {k}) yaa baa; hom_graph f (S - {k}) za ca\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y zb b cb.\n                            ifte (var k) (ifte (var i) ya yaa)\n                             (ifte (var i) z za) =\n                            ifte (var k) y zb \\<and>\n                            ifte (f i) (ifte (f k) ba c)\n                             (ifte (f k) baa ca) =\n                            ifte (f k) b cb \\<and>\n                            hom_graph f (insert i (S - {k})) y b \\<and>\n                            hom_graph f (insert i (S - {k})) zb cb", "apply (simp only: ifte_ifte_distrib [of \"f i\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya yaa z za ba baa c ca.\n       \\<lbrakk>i \\<notin> S; x = ifte (var k) ya z;\n        y = ifte (var k) yaa za; a = ifte (f k) ba c; b = ifte (f k) baa ca;\n        hom_graph f (S - {k}) ya ba; hom_graph f (S - {k}) z c;\n        hom_graph f (S - {k}) yaa baa; hom_graph f (S - {k}) za ca\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y zb b cb.\n                            ifte (var k) (ifte (var i) ya yaa)\n                             (ifte (var i) z za) =\n                            ifte (var k) y zb \\<and>\n                            ifte (f k) (ifte (f i) ba baa)\n                             (ifte (f i) c ca) =\n                            ifte (f k) b cb \\<and>\n                            hom_graph f (insert i (S - {k})) y b \\<and>\n                            hom_graph f (insert i (S - {k})) zb cb", "apply (fast intro: hom_graph.ifte [OF **])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ya z ba c.\n     ifte (var i) x y = ifte (var k) ya z \\<and>\n     ifte (f i) a b = ifte (f k) ba c \\<and>\n     hom_graph f (insert i S - {k}) ya ba \\<and>\n     hom_graph f (insert i S - {k}) z c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ya z ba c.\n     ifte (var i) x y = ifte (var k) ya z \\<and>\n     ifte (f i) a b = ifte (f k) ba c \\<and>\n     hom_graph f (insert i S - {k}) ya ba \\<and>\n     hom_graph f (insert i S - {k}) z c\n\ngoal (2 subgoals):\n 1. k \\<in> {} \\<Longrightarrow>\n    \\<exists>y z b c.\n       \\<bottom> = ifte (var k) y z \\<and>\n       \\<bottom> = ifte (f k) b c \\<and>\n       hom_graph f ({} - {k}) y b \\<and> hom_graph f ({} - {k}) z c\n 2. k \\<in> {} \\<Longrightarrow>\n    \\<exists>y z b c.\n       \\<top> = ifte (var k) y z \\<and>\n       \\<top> = ifte (f k) b c \\<and>\n       hom_graph f ({} - {k}) y b \\<and> hom_graph f ({} - {k}) z c", "qed simp_all"], ["", "lemma hom_graph_insert_elim:\n  assumes \"hom_graph f (insert i S) x a\" and \"i \\<notin> S\"\n  obtains y z b c\n  where \"x = ifte (var i) y z\"\n    and \"a = ifte (f i) b c\"\n    and \"hom_graph f S y b\"\n    and \"hom_graph f S z c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y z b c.\n        \\<lbrakk>x = ifte (var i) y z; a = ifte (f i) b c;\n         hom_graph f S y b; hom_graph f S z c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hom_graph_dest [OF assms(1) insertI1]"], ["proof (prove)\nusing this:\n  \\<exists>y z b c.\n     x = ifte (var i) y z \\<and>\n     a = ifte (f i) b c \\<and>\n     hom_graph f (insert i S - {i}) y b \\<and>\n     hom_graph f (insert i S - {i}) z c\n\ngoal (1 subgoal):\n 1. (\\<And>y z b c.\n        \\<lbrakk>x = ifte (var i) y z; a = ifte (f i) b c;\n         hom_graph f S y b; hom_graph f S z c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarify, simp add: assms(2))"], ["", "text \\<open>\n  \\medskip\n  Now we prove the first uniqueness property of the @{const hom_graph}\n  relation.  This version of uniqueness says that for any particular\n  value of \\<open>S\\<close>, the relation @{term \"hom_graph f S\"} maps each\n  \\<open>x\\<close> to at most one \\<open>a\\<close>.  The proof uses the\n  injectiveness of if-then-else, which we proved earlier.\n\\<close>"], ["", "lemma hom_graph_imp_formulas:\n  \"hom_graph f S x a \\<Longrightarrow> x \\<in> formulas S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f S x a \\<Longrightarrow> x \\<in> formulas S", "by (induct set: hom_graph, simp_all add: formulas_intros formulas_insert)"], ["", "lemma hom_graph_unique:\n  \"hom_graph f S x a \\<Longrightarrow> hom_graph f S x a' \\<Longrightarrow> a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hom_graph f S x a; hom_graph f S x a'\\<rbrakk>\n    \\<Longrightarrow> a = a'", "proof (induct arbitrary: a' set: hom_graph)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a'. hom_graph f {} \\<bottom> a' \\<Longrightarrow> \\<bottom> = a'\n 2. \\<And>a'. hom_graph f {} \\<top> a' \\<Longrightarrow> \\<top> = a'\n 3. \\<And>i S x a y b a'.\n       \\<lbrakk>i \\<notin> S; hom_graph f S x a;\n        \\<And>a'. hom_graph f S x a' \\<Longrightarrow> a = a';\n        hom_graph f S y b;\n        \\<And>a'. hom_graph f S y a' \\<Longrightarrow> b = a';\n        hom_graph f (insert i S) (ifte (var i) x y) a'\\<rbrakk>\n       \\<Longrightarrow> ifte (f i) a b = a'", "case (ifte i S y b z c a')"], ["proof (state)\nthis:\n  i \\<notin> S\n  hom_graph f S y b\n  hom_graph f S y ?a' \\<Longrightarrow> b = ?a'\n  hom_graph f S z c\n  hom_graph f S z ?a' \\<Longrightarrow> c = ?a'\n  hom_graph f (insert i S) (ifte (var i) y z) a'\n\ngoal (3 subgoals):\n 1. \\<And>a'. hom_graph f {} \\<bottom> a' \\<Longrightarrow> \\<bottom> = a'\n 2. \\<And>a'. hom_graph f {} \\<top> a' \\<Longrightarrow> \\<top> = a'\n 3. \\<And>i S x a y b a'.\n       \\<lbrakk>i \\<notin> S; hom_graph f S x a;\n        \\<And>a'. hom_graph f S x a' \\<Longrightarrow> a = a';\n        hom_graph f S y b;\n        \\<And>a'. hom_graph f S y a' \\<Longrightarrow> b = a';\n        hom_graph f (insert i S) (ifte (var i) x y) a'\\<rbrakk>\n       \\<Longrightarrow> ifte (f i) a b = a'", "from ifte(6,1)"], ["proof (chain)\npicking this:\n  hom_graph f (insert i S) (ifte (var i) y z) a'\n  i \\<notin> S", "obtain y' z' b' c'\n    where 1: \"ifte (var i) y z = ifte (var i) y' z'\"\n      and 2: \"a' = ifte (f i) b' c'\"\n      and 3: \"hom_graph f S y' b'\"\n      and 4: \"hom_graph f S z' c'\""], ["proof (prove)\nusing this:\n  hom_graph f (insert i S) (ifte (var i) y z) a'\n  i \\<notin> S\n\ngoal (1 subgoal):\n 1. (\\<And>y' z' b' c'.\n        \\<lbrakk>ifte (var i) y z = ifte (var i) y' z';\n         a' = ifte (f i) b' c'; hom_graph f S y' b';\n         hom_graph f S z' c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule hom_graph_insert_elim)"], ["proof (state)\nthis:\n  ifte (var i) y z = ifte (var i) y' z'\n  a' = ifte (f i) b' c'\n  hom_graph f S y' b'\n  hom_graph f S z' c'\n\ngoal (3 subgoals):\n 1. \\<And>a'. hom_graph f {} \\<bottom> a' \\<Longrightarrow> \\<bottom> = a'\n 2. \\<And>a'. hom_graph f {} \\<top> a' \\<Longrightarrow> \\<top> = a'\n 3. \\<And>i S x a y b a'.\n       \\<lbrakk>i \\<notin> S; hom_graph f S x a;\n        \\<And>a'. hom_graph f S x a' \\<Longrightarrow> a = a';\n        hom_graph f S y b;\n        \\<And>a'. hom_graph f S y a' \\<Longrightarrow> b = a';\n        hom_graph f (insert i S) (ifte (var i) x y) a'\\<rbrakk>\n       \\<Longrightarrow> ifte (f i) a b = a'", "from 1 3 4 ifte(1,2,4)"], ["proof (chain)\npicking this:\n  ifte (var i) y z = ifte (var i) y' z'\n  hom_graph f S y' b'\n  hom_graph f S z' c'\n  i \\<notin> S\n  hom_graph f S y b\n  hom_graph f S z c", "have \"y = y' \\<and> z = z'\""], ["proof (prove)\nusing this:\n  ifte (var i) y z = ifte (var i) y' z'\n  hom_graph f S y' b'\n  hom_graph f S z' c'\n  i \\<notin> S\n  hom_graph f S y b\n  hom_graph f S z c\n\ngoal (1 subgoal):\n 1. y = y' \\<and> z = z'", "by (intro ifte_inject hom_graph_imp_formulas)"], ["proof (state)\nthis:\n  y = y' \\<and> z = z'\n\ngoal (3 subgoals):\n 1. \\<And>a'. hom_graph f {} \\<bottom> a' \\<Longrightarrow> \\<bottom> = a'\n 2. \\<And>a'. hom_graph f {} \\<top> a' \\<Longrightarrow> \\<top> = a'\n 3. \\<And>i S x a y b a'.\n       \\<lbrakk>i \\<notin> S; hom_graph f S x a;\n        \\<And>a'. hom_graph f S x a' \\<Longrightarrow> a = a';\n        hom_graph f S y b;\n        \\<And>a'. hom_graph f S y a' \\<Longrightarrow> b = a';\n        hom_graph f (insert i S) (ifte (var i) x y) a'\\<rbrakk>\n       \\<Longrightarrow> ifte (f i) a b = a'", "with 2 3 4 ifte(3,5)"], ["proof (chain)\npicking this:\n  a' = ifte (f i) b' c'\n  hom_graph f S y' b'\n  hom_graph f S z' c'\n  hom_graph f S y ?a' \\<Longrightarrow> b = ?a'\n  hom_graph f S z ?a' \\<Longrightarrow> c = ?a'\n  y = y' \\<and> z = z'", "show \"ifte (f i) b c = a'\""], ["proof (prove)\nusing this:\n  a' = ifte (f i) b' c'\n  hom_graph f S y' b'\n  hom_graph f S z' c'\n  hom_graph f S y ?a' \\<Longrightarrow> b = ?a'\n  hom_graph f S z ?a' \\<Longrightarrow> c = ?a'\n  y = y' \\<and> z = z'\n\ngoal (1 subgoal):\n 1. ifte (f i) b c = a'", "by simp"], ["proof (state)\nthis:\n  ifte (f i) b c = a'\n\ngoal (2 subgoals):\n 1. \\<And>a'. hom_graph f {} \\<bottom> a' \\<Longrightarrow> \\<bottom> = a'\n 2. \\<And>a'. hom_graph f {} \\<top> a' \\<Longrightarrow> \\<top> = a'", "qed (erule hom_graph.cases, simp_all)+"], ["", "text \\<open>\n  \\medskip\n  The next few lemmas will help to establish a stronger version of the\n  uniqueness property of @{const hom_graph}.  They show that the @{const\n  hom_graph} relation is preserved if we replace \\<open>S\\<close> with a\n  larger finite set.\n\\<close>"], ["", "lemma hom_graph_insert:\n  assumes \"hom_graph f S x a\"\n  shows \"hom_graph f (insert i S) x a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f (insert i S) x a", "proof (cases \"i \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> S \\<Longrightarrow> hom_graph f (insert i S) x a\n 2. i \\<notin> S \\<Longrightarrow> hom_graph f (insert i S) x a", "assume \"i \\<in> S\""], ["proof (state)\nthis:\n  i \\<in> S\n\ngoal (2 subgoals):\n 1. i \\<in> S \\<Longrightarrow> hom_graph f (insert i S) x a\n 2. i \\<notin> S \\<Longrightarrow> hom_graph f (insert i S) x a", "with assms"], ["proof (chain)\npicking this:\n  hom_graph f S x a\n  i \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  hom_graph f S x a\n  i \\<in> S\n\ngoal (1 subgoal):\n 1. hom_graph f (insert i S) x a", "by (simp add: insert_absorb)"], ["proof (state)\nthis:\n  hom_graph f (insert i S) x a\n\ngoal (1 subgoal):\n 1. i \\<notin> S \\<Longrightarrow> hom_graph f (insert i S) x a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> S \\<Longrightarrow> hom_graph f (insert i S) x a", "assume \"i \\<notin> S\""], ["proof (state)\nthis:\n  i \\<notin> S\n\ngoal (1 subgoal):\n 1. i \\<notin> S \\<Longrightarrow> hom_graph f (insert i S) x a", "hence \"hom_graph f (insert i S) (ifte (var i) x x) (ifte (f i) a a)\""], ["proof (prove)\nusing this:\n  i \\<notin> S\n\ngoal (1 subgoal):\n 1. hom_graph f (insert i S) (ifte (var i) x x) (ifte (f i) a a)", "by (intro hom_graph.ifte assms)"], ["proof (state)\nthis:\n  hom_graph f (insert i S) (ifte (var i) x x) (ifte (f i) a a)\n\ngoal (1 subgoal):\n 1. i \\<notin> S \\<Longrightarrow> hom_graph f (insert i S) x a", "thus \"hom_graph f (insert i S) x a\""], ["proof (prove)\nusing this:\n  hom_graph f (insert i S) (ifte (var i) x x) (ifte (f i) a a)\n\ngoal (1 subgoal):\n 1. hom_graph f (insert i S) x a", "by (simp only: ifte_same)"], ["proof (state)\nthis:\n  hom_graph f (insert i S) x a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_graph_finite_superset:\n  assumes \"hom_graph f S x a\" and \"finite T\" and \"S \\<subseteq> T\"\n  shows \"hom_graph f T x a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f T x a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom_graph f T x a", "from \\<open>finite T\\<close>"], ["proof (chain)\npicking this:\n  finite T", "have \"hom_graph f (S \\<union> T) x a\""], ["proof (prove)\nusing this:\n  finite T\n\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) x a", "by (induct set: finite, simp add: assms, simp add: hom_graph_insert)"], ["proof (state)\nthis:\n  hom_graph f (S \\<union> T) x a\n\ngoal (1 subgoal):\n 1. hom_graph f T x a", "with \\<open>S \\<subseteq> T\\<close>"], ["proof (chain)\npicking this:\n  S \\<subseteq> T\n  hom_graph f (S \\<union> T) x a", "show \"hom_graph f T x a\""], ["proof (prove)\nusing this:\n  S \\<subseteq> T\n  hom_graph f (S \\<union> T) x a\n\ngoal (1 subgoal):\n 1. hom_graph f T x a", "by (simp only: subset_Un_eq)"], ["proof (state)\nthis:\n  hom_graph f T x a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_graph_imp_finite:\n  \"hom_graph f S x a \\<Longrightarrow> finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f S x a \\<Longrightarrow> finite S", "by (induct set: hom_graph) simp_all"], ["", "text \\<open>\n  \\medskip\n  This stronger uniqueness property says that @{term \"hom_graph f\"}\n  maps each \\<open>x\\<close> to at most one \\<open>a\\<close>, even for\n  \\emph{different} values of the set parameter.\n\\<close>"], ["", "lemma hom_graph_unique':\n  assumes \"hom_graph f S x a\" and \"hom_graph f T x a'\"\n  shows \"a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a'", "proof (rule hom_graph_unique)"], ["proof (state)\ngoal (2 subgoals):\n 1. hom_graph ?f ?S ?x a\n 2. hom_graph ?f ?S ?x a'", "have fin: \"finite (S \\<union> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S \\<union> T)", "using assms"], ["proof (prove)\nusing this:\n  hom_graph f S x a\n  hom_graph f T x a'\n\ngoal (1 subgoal):\n 1. finite (S \\<union> T)", "by (intro finite_UnI hom_graph_imp_finite)"], ["proof (state)\nthis:\n  finite (S \\<union> T)\n\ngoal (2 subgoals):\n 1. hom_graph ?f ?S ?x a\n 2. hom_graph ?f ?S ?x a'", "show \"hom_graph f (S \\<union> T) x a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) x a", "using assms(1) fin Un_upper1"], ["proof (prove)\nusing this:\n  hom_graph f S x a\n  finite (S \\<union> T)\n  ?A \\<subseteq> ?A \\<union> ?B\n\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) x a", "by (rule hom_graph_finite_superset)"], ["proof (state)\nthis:\n  hom_graph f (S \\<union> T) x a\n\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) x a'", "show \"hom_graph f (S \\<union> T) x a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) x a'", "using assms(2) fin Un_upper2"], ["proof (prove)\nusing this:\n  hom_graph f T x a'\n  finite (S \\<union> T)\n  ?B \\<subseteq> ?A \\<union> ?B\n\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) x a'", "by (rule hom_graph_finite_superset)"], ["proof (state)\nthis:\n  hom_graph f (S \\<union> T) x a'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  \\medskip\n  Finally, these last few lemmas establish that the @{term \"hom_graph\n  f\"} relation is total: every \\<open>x\\<close> is mapped to some \\<open>a\\<close>.\n\\<close>"], ["", "lemma hom_graph_var: \"hom_graph f {i} (var i) (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f {i} (var i) (f i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom_graph f {i} (var i) (f i)", "have \"hom_graph f {i} (ifte (var i) top bot) (ifte (f i) top bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f {i} (ifte (var i) \\<top> \\<bottom>)\n     (ifte (f i) \\<top> \\<bottom>)", "by (simp add: hom_graph.intros)"], ["proof (state)\nthis:\n  hom_graph f {i} (ifte (var i) \\<top> \\<bottom>)\n   (ifte (f i) \\<top> \\<bottom>)\n\ngoal (1 subgoal):\n 1. hom_graph f {i} (var i) (f i)", "thus \"hom_graph f {i} (var i) (f i)\""], ["proof (prove)\nusing this:\n  hom_graph f {i} (ifte (var i) \\<top> \\<bottom>)\n   (ifte (f i) \\<top> \\<bottom>)\n\ngoal (1 subgoal):\n 1. hom_graph f {i} (var i) (f i)", "unfolding ifte_def"], ["proof (prove)\nusing this:\n  hom_graph f {i}\n   (var i \\<sqinter> \\<top> \\<squnion> - var i \\<sqinter> \\<bottom>)\n   (f i \\<sqinter> \\<top> \\<squnion> - f i \\<sqinter> \\<bottom>)\n\ngoal (1 subgoal):\n 1. hom_graph f {i} (var i) (f i)", "by simp"], ["proof (state)\nthis:\n  hom_graph f {i} (var i) (f i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_graph_compl:\n  \"hom_graph f S x a \\<Longrightarrow> hom_graph f S (- x) (- a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f S x a \\<Longrightarrow> hom_graph f S (- x) (- a)", "by (induct set: hom_graph, simp_all add: hom_graph.intros compl_ifte)"], ["", "lemma hom_graph_inf:\n  \"hom_graph f S x a \\<Longrightarrow> hom_graph f S y b \\<Longrightarrow>\n   hom_graph f S (x \\<sqinter> y) (a \\<sqinter> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hom_graph f S x a; hom_graph f S y b\\<rbrakk>\n    \\<Longrightarrow> hom_graph f S (x \\<sqinter> y) (a \\<sqinter> b)", "apply (induct arbitrary: y b set: hom_graph)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y b.\n       hom_graph f {} y b \\<Longrightarrow>\n       hom_graph f {} (\\<bottom> \\<sqinter> y) (\\<bottom> \\<sqinter> b)\n 2. \\<And>y b.\n       hom_graph f {} y b \\<Longrightarrow>\n       hom_graph f {} (\\<top> \\<sqinter> y) (\\<top> \\<sqinter> b)\n 3. \\<And>i S x a y b ya ba.\n       \\<lbrakk>i \\<notin> S; hom_graph f S x a;\n        \\<And>y b.\n           hom_graph f S y b \\<Longrightarrow>\n           hom_graph f S (x \\<sqinter> y) (a \\<sqinter> b);\n        hom_graph f S y b;\n        \\<And>ya ba.\n           hom_graph f S ya ba \\<Longrightarrow>\n           hom_graph f S (y \\<sqinter> ya) (b \\<sqinter> ba);\n        hom_graph f (insert i S) ya ba\\<rbrakk>\n       \\<Longrightarrow> hom_graph f (insert i S)\n                          (ifte (var i) x y \\<sqinter> ya)\n                          (ifte (f i) a b \\<sqinter> ba)", "apply (simp add: hom_graph.bot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y b.\n       hom_graph f {} y b \\<Longrightarrow>\n       hom_graph f {} (\\<top> \\<sqinter> y) (\\<top> \\<sqinter> b)\n 2. \\<And>i S x a y b ya ba.\n       \\<lbrakk>i \\<notin> S; hom_graph f S x a;\n        \\<And>y b.\n           hom_graph f S y b \\<Longrightarrow>\n           hom_graph f S (x \\<sqinter> y) (a \\<sqinter> b);\n        hom_graph f S y b;\n        \\<And>ya ba.\n           hom_graph f S ya ba \\<Longrightarrow>\n           hom_graph f S (y \\<sqinter> ya) (b \\<sqinter> ba);\n        hom_graph f (insert i S) ya ba\\<rbrakk>\n       \\<Longrightarrow> hom_graph f (insert i S)\n                          (ifte (var i) x y \\<sqinter> ya)\n                          (ifte (f i) a b \\<sqinter> ba)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i S x a y b ya ba.\n       \\<lbrakk>i \\<notin> S; hom_graph f S x a;\n        \\<And>y b.\n           hom_graph f S y b \\<Longrightarrow>\n           hom_graph f S (x \\<sqinter> y) (a \\<sqinter> b);\n        hom_graph f S y b;\n        \\<And>ya ba.\n           hom_graph f S ya ba \\<Longrightarrow>\n           hom_graph f S (y \\<sqinter> ya) (b \\<sqinter> ba);\n        hom_graph f (insert i S) ya ba\\<rbrakk>\n       \\<Longrightarrow> hom_graph f (insert i S)\n                          (ifte (var i) x y \\<sqinter> ya)\n                          (ifte (f i) a b \\<sqinter> ba)", "apply (erule (1) hom_graph_insert_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i S x a y b ya ba yb z bb c.\n       \\<lbrakk>i \\<notin> S; hom_graph f S x a;\n        \\<And>y b.\n           hom_graph f S y b \\<Longrightarrow>\n           hom_graph f S (x \\<sqinter> y) (a \\<sqinter> b);\n        hom_graph f S y b;\n        \\<And>ya ba.\n           hom_graph f S ya ba \\<Longrightarrow>\n           hom_graph f S (y \\<sqinter> ya) (b \\<sqinter> ba);\n        ya = ifte (var i) yb z; ba = ifte (f i) bb c; hom_graph f S yb bb;\n        hom_graph f S z c\\<rbrakk>\n       \\<Longrightarrow> hom_graph f (insert i S)\n                          (ifte (var i) x y \\<sqinter> ya)\n                          (ifte (f i) a b \\<sqinter> ba)", "apply (auto simp add: inf_ifte_distrib hom_graph.ifte)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hom_graph_union_inf:\n  assumes \"hom_graph f S x a\" and \"hom_graph f T y b\"\n  shows \"hom_graph f (S \\<union> T) (x \\<sqinter> y) (a \\<sqinter> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) (x \\<sqinter> y) (a \\<sqinter> b)", "proof (rule hom_graph_inf)"], ["proof (state)\ngoal (2 subgoals):\n 1. hom_graph f (S \\<union> T) x a\n 2. hom_graph f (S \\<union> T) y b", "have fin: \"finite (S \\<union> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S \\<union> T)", "using assms"], ["proof (prove)\nusing this:\n  hom_graph f S x a\n  hom_graph f T y b\n\ngoal (1 subgoal):\n 1. finite (S \\<union> T)", "by (intro finite_UnI hom_graph_imp_finite)"], ["proof (state)\nthis:\n  finite (S \\<union> T)\n\ngoal (2 subgoals):\n 1. hom_graph f (S \\<union> T) x a\n 2. hom_graph f (S \\<union> T) y b", "show \"hom_graph f (S \\<union> T) x a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) x a", "using assms(1) fin Un_upper1"], ["proof (prove)\nusing this:\n  hom_graph f S x a\n  finite (S \\<union> T)\n  ?A \\<subseteq> ?A \\<union> ?B\n\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) x a", "by (rule hom_graph_finite_superset)"], ["proof (state)\nthis:\n  hom_graph f (S \\<union> T) x a\n\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) y b", "show \"hom_graph f (S \\<union> T) y b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) y b", "using assms(2) fin Un_upper2"], ["proof (prove)\nusing this:\n  hom_graph f T y b\n  finite (S \\<union> T)\n  ?B \\<subseteq> ?A \\<union> ?B\n\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) y b", "by (rule hom_graph_finite_superset)"], ["proof (state)\nthis:\n  hom_graph f (S \\<union> T) y b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_graph_exists: \"\\<exists>a S. hom_graph f S x a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a S. hom_graph f S x a", "by (induct x)\n   (auto intro: hom_graph_var hom_graph_compl hom_graph_union_inf)"], ["", "subsection \\<open>Homomorphisms into other boolean algebras\\<close>"], ["", "text \\<open>\n  Now that we have proved the necessary existence and uniqueness\n  properties of @{const hom_graph}, we can define the function \\<open>hom\\<close> using definite choice.\n\\<close>"], ["", "definition\n  hom :: \"('a \\<Rightarrow> 'b::boolean_algebra) \\<Rightarrow> 'a formula \\<Rightarrow> 'b\"\nwhere\n  \"hom f x = (THE a. \\<exists>S. hom_graph f S x a)\""], ["", "lemma hom_graph_hom: \"\\<exists>S. hom_graph f S x (hom f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S. hom_graph f S x (hom f x)", "unfolding hom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S. hom_graph f S x (THE a. \\<exists>S. hom_graph f S x a)", "apply (rule theI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!xa. \\<exists>S. hom_graph f S x xa", "apply (rule ex_ex1I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>xa S. hom_graph f S x xa\n 2. \\<And>xa y.\n       \\<lbrakk>\\<exists>S. hom_graph f S x xa;\n        \\<exists>S. hom_graph f S x y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "apply (rule hom_graph_exists)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>\\<exists>S. hom_graph f S x xa;\n        \\<exists>S. hom_graph f S x y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "apply (fast elim: hom_graph_unique')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hom_equality:\n  \"hom_graph f S x a \\<Longrightarrow> hom f x = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f S x a \\<Longrightarrow> hom f x = a", "unfolding hom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f S x a \\<Longrightarrow>\n    (THE a. \\<exists>S. hom_graph f S x a) = a", "apply (rule the_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. hom_graph f S x a \\<Longrightarrow> \\<exists>S. hom_graph f S x a\n 2. \\<And>aa.\n       \\<lbrakk>hom_graph f S x a; \\<exists>S. hom_graph f S x aa\\<rbrakk>\n       \\<Longrightarrow> aa = a", "apply (erule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>hom_graph f S x a; \\<exists>S. hom_graph f S x aa\\<rbrakk>\n       \\<Longrightarrow> aa = a", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa Sa.\n       \\<lbrakk>hom_graph f S x a; hom_graph f Sa x aa\\<rbrakk>\n       \\<Longrightarrow> aa = a", "apply (erule (1) hom_graph_unique')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  \\medskip\n  The @{const hom} function correctly implements its specification:\n\\<close>"], ["", "lemma hom_var [simp]: \"hom f (var i) = f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f (var i) = f i", "by (rule hom_equality, rule hom_graph_var)"], ["", "lemma hom_bot [simp]: \"hom f \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f \\<bottom> = \\<bottom>", "by (rule hom_equality, rule hom_graph.bot)"], ["", "lemma hom_top [simp]: \"hom f \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f \\<top> = \\<top>", "by (rule hom_equality, rule hom_graph.top)"], ["", "lemma hom_compl [simp]: \"hom f (- x) = - hom f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f (- x) = - hom f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom f (- x) = - hom f x", "obtain S where \"hom_graph f S x (hom f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        hom_graph f S x (hom f x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using hom_graph_hom"], ["proof (prove)\nusing this:\n  \\<exists>S. hom_graph ?f S ?x (hom ?f ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        hom_graph f S x (hom f x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  hom_graph f S x (hom f x)\n\ngoal (1 subgoal):\n 1. hom f (- x) = - hom f x", "hence \"hom_graph f S (- x) (- hom f x)\""], ["proof (prove)\nusing this:\n  hom_graph f S x (hom f x)\n\ngoal (1 subgoal):\n 1. hom_graph f S (- x) (- hom f x)", "by (rule hom_graph_compl)"], ["proof (state)\nthis:\n  hom_graph f S (- x) (- hom f x)\n\ngoal (1 subgoal):\n 1. hom f (- x) = - hom f x", "thus \"hom f (- x) = - hom f x\""], ["proof (prove)\nusing this:\n  hom_graph f S (- x) (- hom f x)\n\ngoal (1 subgoal):\n 1. hom f (- x) = - hom f x", "by (rule hom_equality)"], ["proof (state)\nthis:\n  hom f (- x) = - hom f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_inf [simp]: \"hom f (x \\<sqinter> y) = hom f x \\<sqinter> hom f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f (x \\<sqinter> y) = hom f x \\<sqinter> hom f y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom f (x \\<sqinter> y) = hom f x \\<sqinter> hom f y", "obtain S where S: \"hom_graph f S x (hom f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        hom_graph f S x (hom f x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using hom_graph_hom"], ["proof (prove)\nusing this:\n  \\<exists>S. hom_graph ?f S ?x (hom ?f ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        hom_graph f S x (hom f x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  hom_graph f S x (hom f x)\n\ngoal (1 subgoal):\n 1. hom f (x \\<sqinter> y) = hom f x \\<sqinter> hom f y", "obtain T where T: \"hom_graph f T y (hom f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        hom_graph f T y (hom f y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using hom_graph_hom"], ["proof (prove)\nusing this:\n  \\<exists>S. hom_graph ?f S ?x (hom ?f ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        hom_graph f T y (hom f y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  hom_graph f T y (hom f y)\n\ngoal (1 subgoal):\n 1. hom f (x \\<sqinter> y) = hom f x \\<sqinter> hom f y", "have \"hom_graph f (S \\<union> T) (x \\<sqinter> y) (hom f x \\<sqinter> hom f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) (x \\<sqinter> y) (hom f x \\<sqinter> hom f y)", "using S T"], ["proof (prove)\nusing this:\n  hom_graph f S x (hom f x)\n  hom_graph f T y (hom f y)\n\ngoal (1 subgoal):\n 1. hom_graph f (S \\<union> T) (x \\<sqinter> y) (hom f x \\<sqinter> hom f y)", "by (rule hom_graph_union_inf)"], ["proof (state)\nthis:\n  hom_graph f (S \\<union> T) (x \\<sqinter> y) (hom f x \\<sqinter> hom f y)\n\ngoal (1 subgoal):\n 1. hom f (x \\<sqinter> y) = hom f x \\<sqinter> hom f y", "thus ?thesis"], ["proof (prove)\nusing this:\n  hom_graph f (S \\<union> T) (x \\<sqinter> y) (hom f x \\<sqinter> hom f y)\n\ngoal (1 subgoal):\n 1. hom f (x \\<sqinter> y) = hom f x \\<sqinter> hom f y", "by (rule hom_equality)"], ["proof (state)\nthis:\n  hom f (x \\<sqinter> y) = hom f x \\<sqinter> hom f y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_sup [simp]: \"hom f (x \\<squnion> y) = hom f x \\<squnion> hom f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f (x \\<squnion> y) = hom f x \\<squnion> hom f y", "unfolding sup_conv_inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f (- (- x \\<sqinter> - y)) = - (- hom f x \\<sqinter> - hom f y)", "by (simp only: hom_compl hom_inf)"], ["", "lemma hom_diff [simp]: \"hom f (x - y) = hom f x - hom f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f (x - y) = hom f x - hom f y", "unfolding diff_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f (x \\<sqinter> - y) = hom f x \\<sqinter> - hom f y", "by (simp only: hom_compl hom_inf)"], ["", "lemma hom_ifte [simp]:\n  \"hom f (ifte x y z) = ifte (hom f x) (hom f y) (hom f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f (ifte x y z) = ifte (hom f x) (hom f y) (hom f z)", "unfolding ifte_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f (x \\<sqinter> y \\<squnion> - x \\<sqinter> z) =\n    hom f x \\<sqinter> hom f y \\<squnion> - hom f x \\<sqinter> hom f z", "by (simp only: hom_compl hom_inf hom_sup)"], ["", "lemmas hom_simps =\n  hom_var hom_bot hom_top hom_compl\n  hom_inf hom_sup hom_diff hom_ifte"], ["", "text \\<open>\n  \\medskip\n  The type @{typ \"'a formula\"} can be viewed as a monad, with @{const\n  var} as the unit, and @{const hom} as the bind operator.  We can\n  prove the standard monad laws with simple proofs by induction.\n\\<close>"], ["", "lemma hom_var_eq_id: \"hom var x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom var x = x", "by (induct x) simp_all"], ["", "lemma hom_hom: \"hom f (hom g x) = hom (\\<lambda>i. hom f (g i)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom f (hom g x) = hom (\\<lambda>i. hom f (g i)) x", "by (induct x) simp_all"], ["", "subsection \\<open>Map operation on Boolean formulas\\<close>"], ["", "text \\<open>\n  We can define a map functional in terms of @{const hom} and @{const\n  var}.  The properties of \\<open>fmap\\<close> follow directly from the\n  lemmas we have already proved about @{const hom}.\n\\<close>"], ["", "definition\n  fmap :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a formula \\<Rightarrow> 'b formula\"\nwhere\n  \"fmap f = hom (\\<lambda>i. var (f i))\""], ["", "lemma fmap_var [simp]: \"fmap f (var i) = var (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap f (var i) = var (f i)", "unfolding fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (\\<lambda>i. var (f i)) (var i) = var (f i)", "by simp"], ["", "lemma fmap_bot [simp]: \"fmap f \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap f \\<bottom> = \\<bottom>", "unfolding fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (\\<lambda>i. var (f i)) \\<bottom> = \\<bottom>", "by simp"], ["", "lemma fmap_top [simp]: \"fmap f \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap f \\<top> = \\<top>", "unfolding fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (\\<lambda>i. var (f i)) \\<top> = \\<top>", "by simp"], ["", "lemma fmap_compl [simp]: \"fmap f (- x) = - fmap f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap f (- x) = - fmap f x", "unfolding fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (\\<lambda>i. var (f i)) (- x) = - hom (\\<lambda>i. var (f i)) x", "by simp"], ["", "lemma fmap_inf [simp]: \"fmap f (x \\<sqinter> y) = fmap f x \\<sqinter> fmap f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap f (x \\<sqinter> y) = fmap f x \\<sqinter> fmap f y", "unfolding fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (\\<lambda>i. var (f i)) (x \\<sqinter> y) =\n    hom (\\<lambda>i. var (f i)) x \\<sqinter> hom (\\<lambda>i. var (f i)) y", "by simp"], ["", "lemma fmap_sup [simp]: \"fmap f (x \\<squnion> y) = fmap f x \\<squnion> fmap f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap f (x \\<squnion> y) = fmap f x \\<squnion> fmap f y", "unfolding fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (\\<lambda>i. var (f i)) (x \\<squnion> y) =\n    hom (\\<lambda>i. var (f i)) x \\<squnion> hom (\\<lambda>i. var (f i)) y", "by simp"], ["", "lemma fmap_diff [simp]: \"fmap f (x - y) = fmap f x - fmap f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap f (x - y) = fmap f x - fmap f y", "unfolding fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (\\<lambda>i. var (f i)) (x - y) =\n    hom (\\<lambda>i. var (f i)) x - hom (\\<lambda>i. var (f i)) y", "by simp"], ["", "lemma fmap_ifte [simp]:\n  \"fmap f (ifte x y z) = ifte (fmap f x) (fmap f y) (fmap f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap f (ifte x y z) = ifte (fmap f x) (fmap f y) (fmap f z)", "unfolding fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (\\<lambda>i. var (f i)) (ifte x y z) =\n    ifte (hom (\\<lambda>i. var (f i)) x) (hom (\\<lambda>i. var (f i)) y)\n     (hom (\\<lambda>i. var (f i)) z)", "by simp"], ["", "lemmas fmap_simps =\n  fmap_var fmap_bot fmap_top fmap_compl\n  fmap_inf fmap_sup fmap_diff fmap_ifte"], ["", "text \\<open>\n  \\medskip\n  The map functional satisfies the functor laws: it preserves identity\n  and function composition.\n\\<close>"], ["", "lemma fmap_ident: \"fmap (\\<lambda>i. i) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap (\\<lambda>i. i) x = x", "by (induct x) simp_all"], ["", "lemma fmap_fmap: \"fmap f (fmap g x) = fmap (f \\<circ> g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap f (fmap g x) = fmap (f \\<circ> g) x", "by (induct x) simp_all"], ["", "subsection \\<open>Hiding lattice syntax\\<close>"], ["", "text \\<open>\n  The following command hides the lattice syntax, to avoid potential\n  conflicts with other theories that import this one.  To re-enable\n  the syntax, users should import theory \\<open>Lattice_Syntax\\<close> from\n  the Isabelle library.\n\\<close>"], ["", "no_notation\n  top (\"\\<top>\") and\n  bot (\"\\<bottom>\") and\n  inf  (infixl \"\\<sqinter>\" 70) and\n  sup  (infixl \"\\<squnion>\" 65)"], ["", "end"]]}