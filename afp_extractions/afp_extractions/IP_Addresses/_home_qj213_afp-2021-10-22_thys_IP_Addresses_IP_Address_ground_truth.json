{"file_name": "/home/qj213/afp-2021-10-22/thys/IP_Addresses/IP_Address.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IP_Addresses", "problem_names": ["lemma max_ip_addr_max_word: \"max_ip_addr = max_word\"", "lemma max_ip_addr_max: \"\\<forall>a. a \\<le> max_ip_addr\"", "lemma range_0_max_UNIV: \"UNIV = {0 .. max_ip_addr}\"", "lemma \"size (x::'i::len word) = len_of(TYPE('i))\"", "lemma ipset_from_netmask_minusone:\n    \"ipset_from_netmask ip (- 1) = {ip}\"", "lemma ipset_from_netmask_maxword:\n    \"ipset_from_netmask ip max_word = {ip}\"", "lemma ipset_from_netmask_zero:\n    \"ipset_from_netmask ip 0 = UNIV\"", "lemma \"(case ipcidr of (base, len) \\<Rightarrow> ipset_from_cidr base len) = uncurry ipset_from_cidr ipcidr\"", "lemma ipset_from_cidr_0: \"ipset_from_cidr ip 0 = UNIV\"", "lemma ipset_from_cidr_wordlength:\n    fixes ip :: \"'i::len word\"\n    shows \"ipset_from_cidr ip (LENGTH('i)) = {ip}\"", "lemma ipset_from_cidr_bl:\n    fixes addr :: \"'i::len word\"\n    shows \"ipset_from_cidr addr pflength \\<equiv>\n            ipset_from_netmask addr (of_bl ((replicate pflength True) @\n                                            (replicate ((len_of(TYPE('i))) - pflength)) False))\"", "lemma ipset_from_cidr_alt:\n    fixes pre :: \"'i::len word\"\n    shows \"ipset_from_cidr pre len =\n            {pre AND (mask len << LENGTH('i) - len)\n             ..\n             pre OR mask (LENGTH('i) - len)}\"", "lemma ipset_from_cidr_alt2:\n    fixes base ::\"'i::len word\"\n    shows \"ipset_from_cidr base len =\n           ipset_from_netmask base (NOT (mask (LENGTH('i) - len)))\"", "lemma ipset_from_cidr_not_empty: \"ipset_from_cidr base len \\<noteq> {}\"", "lemma ipset_from_cidr_base_wellforemd: fixes base:: \"'i::len word\"\n    assumes \"mask (LENGTH('i) - l) AND base = 0\"\n      shows \"ipset_from_cidr base l = {base .. base OR mask (LENGTH('i) - l)}\"", "lemma ipset_from_cidr_large_pfxlen:\n    fixes ip:: \"'i::len word\"\n    assumes \"n \\<ge> LENGTH('i)\"\n    shows \"ipset_from_cidr ip n = {ip}\"", "lemma ipset_from_netmask_base_mask_consume:\n    fixes base :: \"'i::len word\"\n    shows \"ipset_from_netmask (base AND NOT (mask (LENGTH('i) - m)))\n                              (NOT (mask (LENGTH('i) - m)))\n            =\n             ipset_from_netmask base (NOT (mask (LENGTH('i) - m)))\"", "lemma ipset_from_cidr_eq_ip_cidr_set:\n    fixes base::\"'i::len word\"\n    shows \"ipset_from_cidr base len = ip_cidr_set base len\"", "lemma ip_cidr_set_change_base: \"j \\<in> ip_cidr_set i r \\<Longrightarrow> ip_cidr_set j r = ip_cidr_set i r\"", "lemma iprange_interval_uncurry: \"iprange_interval ipcidr = uncurry WordInterval ipcidr\"", "lemma \"wordinterval_to_set (iprange_single ip) = {ip}\"", "lemma \"wordinterval_to_set (iprange_interval (ip1, ip2)) = {ip1 .. ip2}\"", "lemma ipset_from_cidr_ipcidr_to_interval:\n    \"ipset_from_cidr base len =\n      {ipcidr_to_interval_start (base,len) .. ipcidr_to_interval_end (base,len)}\"", "lemma ipcidr_to_interval:\n    \"ipcidr_to_interval (base, len) = (s,e) \\<Longrightarrow> ipset_from_cidr base len = {s .. e}\"", "lemma wordinterval_to_set_ipcidr_tuple_to_wordinterval:\n    \"wordinterval_to_set (ipcidr_tuple_to_wordinterval (b, m)) = ipset_from_cidr b m\"", "lemma wordinterval_to_set_ipcidr_tuple_to_wordinterval_uncurry:\n    \"wordinterval_to_set (ipcidr_tuple_to_wordinterval ipcidr) = uncurry ipset_from_cidr ipcidr\"", "lemma ipcidr_union_set_uncurry:\n    \"ipcidr_union_set ips = (\\<Union> ipcidr \\<in> ips. uncurry ipset_from_cidr ipcidr)\"", "lemma less_and_not_mask_eq:\n      fixes i :: \"('a :: len) word\"\n      assumes \"r2 \\<le> r1\" \"i && ~~ (mask r2) = x && ~~ (mask r2)\"\n      shows \"i && ~~ (mask r1) = x && ~~ (mask r1)\"", "lemma ip_cidr_set_less:\n      fixes i :: \"'i::len word\"\n      shows \"r1 \\<le> r2 \\<Longrightarrow> ip_cidr_set i r2 \\<subseteq> ip_cidr_set i r1\"", "lemma ip_cidr_set_intersect_subset_helper:\n      fixes i1 r1 i2 r2\n      assumes disj: \"ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 \\<noteq> {}\" and  \"r1 \\<le> r2\"\n      shows \"ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1\"", "lemma ip_cidr_set_notsubset_empty_inter:\n      \"\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2 \\<Longrightarrow>\n       \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1 \\<Longrightarrow>\n       ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}\"", "lemma ip_cidr_intersect:\n     \"\\<not> ipset_from_cidr b2 m2 \\<subseteq> ipset_from_cidr b1 m1 \\<Longrightarrow>\n      \\<not> ipset_from_cidr b1 m1 \\<subseteq> ipset_from_cidr b2 m2 \\<Longrightarrow>\n      ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2 = {}\"", "lemma ipcidr_conjunct_any: \"ipcidr_conjunct a (x,0) \\<noteq> None\" \"ipcidr_conjunct (y,0) b \\<noteq> None\"", "lemma ipcidr_conjunct_correct: \"(case ipcidr_conjunct (b1, m1) (b2, m2)\n                                          of Some (bx, mx) \\<Rightarrow> ipset_from_cidr bx mx\n                                          |  None \\<Rightarrow> {}) =\n                                   (ipset_from_cidr b1 m1) \\<inter> (ipset_from_cidr b2 m2)\"", "lemma ipcidr_conjunct_word[code_unfold]:\n  \"ipcidr_conjunct ips1 ips2 = (\n     if\n      wordinterval_empty (wordinterval_intersection\n                            (ipcidr_tuple_to_wordinterval ips1) (ipcidr_tuple_to_wordinterval ips2))\n     then\n       None\n     else if\n       wordinterval_subset (ipcidr_tuple_to_wordinterval ips1) (ipcidr_tuple_to_wordinterval ips2)\n     then\n       Some ips1\n     else\n       Some ips2\n     )\"", "lemma \"ipcidr_conjunct (0::32 word,0) (8,1) = Some (8, 1)\"", "lemma addr_in_ipset_from_netmask_code[code_unfold]:\n    \"addr \\<in> (ipset_from_netmask base netmask) \\<longleftrightarrow>\n      (base AND netmask) \\<le> addr \\<and> addr \\<le> (base AND netmask) OR (NOT netmask)\"", "lemma addr_in_ipset_from_cidr_code[code_unfold]:\n    \"(addr::'i::len word) \\<in> (ipset_from_cidr pre len) \\<longleftrightarrow>\n       (pre AND ((mask len) << (LENGTH('i) - len))) \\<le> addr \\<and>\n        addr \\<le> pre OR (mask (LENGTH('i) - len))\""], "translations": [["", "lemma max_ip_addr_max_word: \"max_ip_addr = max_word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_ip_addr = - 1", "by (simp only: max_ip_addr_def of_nat_mask_eq flip: mask_eq_exp_minus_1) simp"], ["", "lemma max_ip_addr_max: \"\\<forall>a. a \\<le> max_ip_addr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. a \\<le> max_ip_addr", "by(simp add: max_ip_addr_max_word)"], ["", "lemma range_0_max_UNIV: \"UNIV = {0 .. max_ip_addr}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {0..max_ip_addr}", "(*not in the simp set, for a reason*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {0..max_ip_addr}", "by(simp add: max_ip_addr_max_word) fastforce"], ["", "lemma \"size (x::'i::len word) = len_of(TYPE('i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size x = LENGTH('i)", "by(simp add:word_size)"], ["", "subsection\\<open>Sets of IP Addresses\\<close>"], ["", "(*Warning, not executable!*)"], ["", "text\\<open>Specifying sets with network masks: 192.168.0.0 255.255.255.0\\<close>"], ["", "definition ipset_from_netmask::\"'i::len word \\<Rightarrow> 'i::len word \\<Rightarrow> 'i::len word set\" where\n    \"ipset_from_netmask addr netmask \\<equiv>\n      let\n        network_prefix = (addr AND netmask)\n      in\n        {network_prefix .. network_prefix OR (NOT netmask)}\""], ["", "text\\<open>Example (pseudo syntax):\n    @{const ipset_from_netmask} \\<open>192.168.1.129  255.255.255.0\\<close> =\n        \\<open>{192.168.1.0 .. 192.168.1.255}\\<close>\\<close>"], ["", "text\\<open>A network mask of all ones (i.e. @{term \"(- 1)::'i::len word\"}).\\<close>"], ["", "lemma ipset_from_netmask_minusone:\n    \"ipset_from_netmask ip (- 1) = {ip}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_netmask ip (- 1) = {ip}", "by (simp add: ipset_from_netmask_def)"], ["", "lemma ipset_from_netmask_maxword:\n    \"ipset_from_netmask ip max_word = {ip}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_netmask ip (- 1) = {ip}", "by (simp add: ipset_from_netmask_def)"], ["", "lemma ipset_from_netmask_zero:\n    \"ipset_from_netmask ip 0 = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_netmask ip 0 = UNIV", "by (auto simp add: ipset_from_netmask_def)"], ["", "text\\<open>Specifying sets in Classless Inter-domain Routing (CIDR) notation: 192.168.0.0/24\\<close>"], ["", "definition ipset_from_cidr ::\"'i::len word \\<Rightarrow> nat \\<Rightarrow> 'i::len word set\" where\n    \"ipset_from_cidr addr pflength \\<equiv>\n       ipset_from_netmask addr ((mask pflength) << (len_of(TYPE('i)) - pflength))\""], ["", "text\\<open>Example (pseudo syntax):\n    @{const ipset_from_cidr} \\<open>192.168.1.129 24\\<close> = \\<open>{192.168.1.0 .. 192.168.1.255}\\<close>\\<close>"], ["", "(*does this simplify stuff?*)"], ["", "lemma \"(case ipcidr of (base, len) \\<Rightarrow> ipset_from_cidr base len) = uncurry ipset_from_cidr ipcidr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ipcidr of (base, len) \\<Rightarrow> ipset_from_cidr base len) =\n    uncurry ipset_from_cidr ipcidr", "by(simp add: uncurry_case_stmt)"], ["", "lemma ipset_from_cidr_0: \"ipset_from_cidr ip 0 = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr ip 0 = UNIV", "by(auto simp add: ipset_from_cidr_def ipset_from_netmask_def Let_def)"], ["", "text\\<open>A prefix length of word size gives back the singleton set with the IP address.\n       Example: \\<open>192.168.1.2/32 = {192.168.1.2}\\<close>\\<close>"], ["", "lemma ipset_from_cidr_wordlength:\n    fixes ip :: \"'i::len word\"\n    shows \"ipset_from_cidr ip (LENGTH('i)) = {ip}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr ip LENGTH('i) = {ip}", "by (simp add: ipset_from_cidr_def ipset_from_netmask_def)"], ["", "text\\<open>Alternative definition: Considering words as bit lists:\\<close>"], ["", "lemma ipset_from_cidr_bl:\n    fixes addr :: \"'i::len word\"\n    shows \"ipset_from_cidr addr pflength \\<equiv>\n            ipset_from_netmask addr (of_bl ((replicate pflength True) @\n                                            (replicate ((len_of(TYPE('i))) - pflength)) False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr addr pflength \\<equiv>\n    ipset_from_netmask addr\n     (of_bl\n       (replicate pflength True @ replicate (LENGTH('i) - pflength) False))", "by(simp add: ipset_from_cidr_def mask_bl shiftl_of_bl)"], ["", "lemma ipset_from_cidr_alt:\n    fixes pre :: \"'i::len word\"\n    shows \"ipset_from_cidr pre len =\n            {pre AND (mask len << LENGTH('i) - len)\n             ..\n             pre OR mask (LENGTH('i) - len)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr pre len =\n    {pre && (mask len << LENGTH('i) - len)..pre || mask (LENGTH('i) - len)}", "apply(simp add: ipset_from_cidr_def ipset_from_netmask_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre && (mask len << LENGTH('i) - len) ||\n    ~~ (mask len << LENGTH('i) - len) =\n    pre || mask (LENGTH('i) - len) \\<or>\n    \\<not> pre && (mask len << LENGTH('i) - len)\n           \\<le> pre && (mask len << LENGTH('i) - len) ||\n                 ~~ (mask len << LENGTH('i) - len) \\<and>\n    \\<not> pre && (mask len << LENGTH('i) - len)\n           \\<le> pre || mask (LENGTH('i) - len)", "apply(simp add: word_oa_dist)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre || ~~ (mask len << LENGTH('i) - len) =\n    pre || mask (LENGTH('i) - len) \\<or>\n    \\<not> pre && (mask len << LENGTH('i) - len)\n           \\<le> pre || ~~ (mask len << LENGTH('i) - len) \\<and>\n    \\<not> pre && (mask len << LENGTH('i) - len)\n           \\<le> pre || mask (LENGTH('i) - len)", "apply(simp add: NOT_mask_shifted_lenword)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ipset_from_cidr_alt2:\n    fixes base ::\"'i::len word\"\n    shows \"ipset_from_cidr base len =\n           ipset_from_netmask base (NOT (mask (LENGTH('i) - len)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr base len =\n    ipset_from_netmask base (~~ mask (LENGTH('i) - len))", "apply(simp add: ipset_from_cidr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_netmask base (mask len << LENGTH('i) - len) =\n    ipset_from_netmask base (~~ mask (LENGTH('i) - len))", "using NOT_mask_shifted_lenword"], ["proof (prove)\nusing this:\n  ~~ (mask ?len << LENGTH(?'a) - ?len) = mask (LENGTH(?'a) - ?len)\n\ngoal (1 subgoal):\n 1. ipset_from_netmask base (mask len << LENGTH('i) - len) =\n    ipset_from_netmask base (~~ mask (LENGTH('i) - len))", "by(metis word_not_not)"], ["", "text\\<open>In CIDR notation, we cannot express the empty set.\\<close>"], ["", "lemma ipset_from_cidr_not_empty: \"ipset_from_cidr base len \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr base len \\<noteq> {}", "by(simp add: ipset_from_cidr_alt bitmagic_zeroLast_leq_or1Last)"], ["", "text\\<open>Though we can write 192.168.1.2/24, we say that 192.168.0.0/24 is well-formed.\\<close>"], ["", "lemma ipset_from_cidr_base_wellforemd: fixes base:: \"'i::len word\"\n    assumes \"mask (LENGTH('i) - l) AND base = 0\"\n      shows \"ipset_from_cidr base l = {base .. base OR mask (LENGTH('i) - l)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr base l = {base..base || mask (LENGTH('i) - l)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipset_from_cidr base l = {base..base || mask (LENGTH('i) - l)}", "have maskshift_eq_not_mask_generic:\n      \"((mask l << LENGTH('i) - l) :: 'i::len word) = NOT (mask (LENGTH('i) - l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask l << LENGTH('i) - l = ~~ mask (LENGTH('i) - l)", "using NOT_mask_shifted_lenword"], ["proof (prove)\nusing this:\n  ~~ (mask ?len << LENGTH(?'a) - ?len) = mask (LENGTH(?'a) - ?len)\n\ngoal (1 subgoal):\n 1. mask l << LENGTH('i) - l = ~~ mask (LENGTH('i) - l)", "by (metis word_not_not)"], ["proof (state)\nthis:\n  mask l << LENGTH('i) - l = ~~ mask (LENGTH('i) - l)\n\ngoal (1 subgoal):\n 1. ipset_from_cidr base l = {base..base || mask (LENGTH('i) - l)}", "have *: \"base AND NOT (mask (LENGTH('i) - l)) = base\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base && ~~ mask (LENGTH('i) - l) = base", "unfolding mask_eq_0_eq_x[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. base && mask (LENGTH('i) - l) = 0", "using assms word_bw_comms(1)[of base]"], ["proof (prove)\nusing this:\n  mask (LENGTH('i) - l) && base = 0\n  base && ?y = ?y && base\n\ngoal (1 subgoal):\n 1. base && mask (LENGTH('i) - l) = 0", "by simp"], ["proof (state)\nthis:\n  base && ~~ mask (LENGTH('i) - l) = base\n\ngoal (1 subgoal):\n 1. ipset_from_cidr base l = {base..base || mask (LENGTH('i) - l)}", "hence **: \"base AND NOT (mask (LENGTH('i) - l)) OR mask (LENGTH('i) - l) =\n                base OR mask (LENGTH('i) - l)\""], ["proof (prove)\nusing this:\n  base && ~~ mask (LENGTH('i) - l) = base\n\ngoal (1 subgoal):\n 1. base && ~~ mask (LENGTH('i) - l) || mask (LENGTH('i) - l) =\n    base || mask (LENGTH('i) - l)", "by simp"], ["proof (state)\nthis:\n  base && ~~ mask (LENGTH('i) - l) || mask (LENGTH('i) - l) =\n  base || mask (LENGTH('i) - l)\n\ngoal (1 subgoal):\n 1. ipset_from_cidr base l = {base..base || mask (LENGTH('i) - l)}", "have \"ipset_from_netmask base (NOT (mask (LENGTH('i) - l))) =\n            {base .. base || mask (LENGTH('i) - l)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_netmask base (~~ mask (LENGTH('i) - l)) =\n    {base..base || mask (LENGTH('i) - l)}", "by(simp add: ipset_from_netmask_def Let_def ** *)"], ["proof (state)\nthis:\n  ipset_from_netmask base (~~ mask (LENGTH('i) - l)) =\n  {base..base || mask (LENGTH('i) - l)}\n\ngoal (1 subgoal):\n 1. ipset_from_cidr base l = {base..base || mask (LENGTH('i) - l)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ipset_from_netmask base (~~ mask (LENGTH('i) - l)) =\n  {base..base || mask (LENGTH('i) - l)}\n\ngoal (1 subgoal):\n 1. ipset_from_cidr base l = {base..base || mask (LENGTH('i) - l)}", "by(simp add: ipset_from_cidr_def maskshift_eq_not_mask_generic)"], ["proof (state)\nthis:\n  ipset_from_cidr base l = {base..base || mask (LENGTH('i) - l)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipset_from_cidr_large_pfxlen:\n    fixes ip:: \"'i::len word\"\n    assumes \"n \\<ge> LENGTH('i)\"\n    shows \"ipset_from_cidr ip n = {ip}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr ip n = {ip}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipset_from_cidr ip n = {ip}", "have obviously: \"mask (LENGTH('i) - n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (LENGTH('i) - n) = (0::'a)", "by (simp add: assms)"], ["proof (state)\nthis:\n  mask (LENGTH('i) - n) = (0::?'a1)\n\ngoal (1 subgoal):\n 1. ipset_from_cidr ip n = {ip}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr ip n = {ip}", "apply(subst ipset_from_cidr_base_wellforemd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mask (LENGTH('i) - n) && ip = 0\n 2. {ip..ip || mask (LENGTH('i) - n)} = {ip}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (LENGTH('i) - n) && ip = 0", "using assms"], ["proof (prove)\nusing this:\n  LENGTH('i) \\<le> n\n\ngoal (1 subgoal):\n 1. mask (LENGTH('i) - n) && ip = 0", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ip..ip || mask (LENGTH('i) - n)} = {ip}", "by (simp add: obviously)"], ["proof (state)\nthis:\n  ipset_from_cidr ip n = {ip}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipset_from_netmask_base_mask_consume:\n    fixes base :: \"'i::len word\"\n    shows \"ipset_from_netmask (base AND NOT (mask (LENGTH('i) - m)))\n                              (NOT (mask (LENGTH('i) - m)))\n            =\n             ipset_from_netmask base (NOT (mask (LENGTH('i) - m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_netmask (base && ~~ mask (LENGTH('i) - m))\n     (~~ mask (LENGTH('i) - m)) =\n    ipset_from_netmask base (~~ mask (LENGTH('i) - m))", "unfolding ipset_from_netmask_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let network_prefix =\n           (base && ~~ mask (LENGTH('i) - m)) && ~~ mask (LENGTH('i) - m)\n     in {network_prefix..network_prefix || ~~ ~~ mask (LENGTH('i) - m)}) =\n    (let network_prefix = base && ~~ mask (LENGTH('i) - m)\n     in {network_prefix..network_prefix || ~~ ~~ mask (LENGTH('i) - m)})", "by(simp)"], ["", "text\\<open>Another definition of CIDR notation:\n       All IP address which are equal on the first @{term \"len - n\"} bits\\<close>"], ["", "definition ip_cidr_set :: \"'i::len word \\<Rightarrow> nat \\<Rightarrow> 'i word set\" where\n    \"ip_cidr_set i r \\<equiv>\n      {j . i AND NOT (mask (LENGTH('i) - r)) = j AND NOT (mask (LENGTH('i) - r))}\""], ["", "text\\<open>The definitions are equal\\<close>"], ["", "lemma ipset_from_cidr_eq_ip_cidr_set:\n    fixes base::\"'i::len word\"\n    shows \"ipset_from_cidr base len = ip_cidr_set base len\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr base len = ip_cidr_set base len", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipset_from_cidr base len = ip_cidr_set base len", "have maskshift_eq_not_mask_generic:\n      \"((mask len << LENGTH('a) - len) :: 'a::len word) = NOT (mask (LENGTH('a) - len))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask len << LENGTH('a) - len = ~~ mask (LENGTH('a) - len)", "using NOT_mask_shifted_lenword"], ["proof (prove)\nusing this:\n  ~~ (mask ?len << LENGTH(?'a) - ?len) = mask (LENGTH(?'a) - ?len)\n\ngoal (1 subgoal):\n 1. mask len << LENGTH('a) - len = ~~ mask (LENGTH('a) - len)", "by (metis word_not_not)"], ["proof (state)\nthis:\n  mask len << LENGTH(?'a1) - len = ~~ mask (LENGTH(?'a1) - len)\n\ngoal (1 subgoal):\n 1. ipset_from_cidr base len = ip_cidr_set base len", "have 1: \"mask (len - m) AND base AND NOT (mask (len - m)) = 0\"\n      for len m and base::\"'i::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (len - m) && base && ~~ mask (len - m) = 0", "by(simp add: word_bw_lcs)"], ["proof (state)\nthis:\n  mask (?len1 - ?m1) && ?base1 && ~~ mask (?len1 - ?m1) = 0\n\ngoal (1 subgoal):\n 1. ipset_from_cidr base len = ip_cidr_set base len", "have 2: \"mask (LENGTH('i) - len) AND pfxm_p = 0 \\<Longrightarrow>\n           (a \\<in> ipset_from_netmask pfxm_p (NOT (mask (LENGTH('i) - len)))) \\<longleftrightarrow>\n           (pfxm_p = NOT (mask (LENGTH('i) - len)) AND a)\" for a::\"'i::len word\" and pfxm_p"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (LENGTH('i) - len) && pfxm_p = 0 \\<Longrightarrow>\n    (a \\<in> ipset_from_netmask pfxm_p (~~ mask (LENGTH('i) - len))) =\n    (pfxm_p = ~~ mask (LENGTH('i) - len) && a)", "apply(subst ipset_from_cidr_alt2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (LENGTH('i) - len) && pfxm_p = 0 \\<Longrightarrow>\n    (a \\<in> ipset_from_cidr pfxm_p len) =\n    (pfxm_p = ~~ mask (LENGTH('i) - len) && a)", "apply(subst zero_base_lsb_imp_set_eq_as_bit_operation)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mask (LENGTH('i) - len) && pfxm_p = 0 \\<Longrightarrow>\n    mask (LENGTH('i) - len) && pfxm_p = 0\n 2. mask (LENGTH('i) - len) && pfxm_p = 0 \\<Longrightarrow>\n    (a \\<in> ipset_from_cidr pfxm_p len) =\n    (a \\<in> {pfxm_p..pfxm_p || mask (LENGTH('i) - len)})", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (LENGTH('i) - len) && pfxm_p = 0 \\<Longrightarrow>\n    (a \\<in> ipset_from_cidr pfxm_p len) =\n    (a \\<in> {pfxm_p..pfxm_p || mask (LENGTH('i) - len)})", "apply(subst ipset_from_cidr_base_wellforemd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mask (LENGTH('i) - len) && pfxm_p = 0 \\<Longrightarrow>\n    mask (LENGTH('i) - len) && pfxm_p = 0\n 2. mask (LENGTH('i) - len) && pfxm_p = 0 \\<Longrightarrow>\n    (a \\<in> {pfxm_p..pfxm_p || mask (LENGTH('i) - len)}) =\n    (a \\<in> {pfxm_p..pfxm_p || mask (LENGTH('i) - len)})", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (LENGTH('i) - len) && pfxm_p = 0 \\<Longrightarrow>\n    (a \\<in> {pfxm_p..pfxm_p || mask (LENGTH('i) - len)}) =\n    (a \\<in> {pfxm_p..pfxm_p || mask (LENGTH('i) - len)})", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mask (LENGTH('i) - len) && ?pfxm_p1 = 0 \\<Longrightarrow>\n  (?a1 \\<in> ipset_from_netmask ?pfxm_p1 (~~ mask (LENGTH('i) - len))) =\n  (?pfxm_p1 = ~~ mask (LENGTH('i) - len) && ?a1)\n\ngoal (1 subgoal):\n 1. ipset_from_cidr base len = ip_cidr_set base len", "from 2[OF 1, of _ base]"], ["proof (chain)\npicking this:\n  (?a1\n   \\<in> ipset_from_netmask (base && ~~ mask (LENGTH('i) - len))\n          (~~ mask (LENGTH('i) - len))) =\n  (base && ~~ mask (LENGTH('i) - len) = ~~ mask (LENGTH('i) - len) && ?a1)", "have\n      \"(x \\<in> ipset_from_netmask base (~~ (mask (LENGTH('i) - len)))) \\<longleftrightarrow>\n       (base && ~~ (mask (LENGTH('i) - len)) = x && ~~ (mask (LENGTH('i) - len)))\" for x"], ["proof (prove)\nusing this:\n  (?a1\n   \\<in> ipset_from_netmask (base && ~~ mask (LENGTH('i) - len))\n          (~~ mask (LENGTH('i) - len))) =\n  (base && ~~ mask (LENGTH('i) - len) = ~~ mask (LENGTH('i) - len) && ?a1)\n\ngoal (1 subgoal):\n 1. (x \\<in> ipset_from_netmask base (~~ mask (LENGTH('i) - len))) =\n    (base && ~~ mask (LENGTH('i) - len) = x && ~~ mask (LENGTH('i) - len))", "apply(simp add: ipset_from_netmask_base_mask_consume)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        (a \\<in> ipset_from_netmask base (~~ mask (LENGTH('i) - len))) =\n        (base && ~~ mask (LENGTH('i) - len) =\n         ~~ mask (LENGTH('i) - len) && a)) \\<Longrightarrow>\n    (base && ~~ mask (LENGTH('i) - len) = ~~ mask (LENGTH('i) - len) && x) =\n    (base && ~~ mask (LENGTH('i) - len) = x && ~~ mask (LENGTH('i) - len))", "unfolding word_bw_comms(1)[of _ \" ~~ (mask (LENGTH('i) - len))\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        (a \\<in> ipset_from_netmask base (~~ mask (LENGTH('i) - len))) =\n        (~~ mask (LENGTH('i) - len) && base =\n         ~~ mask (LENGTH('i) - len) && a)) \\<Longrightarrow>\n    (~~ mask (LENGTH('i) - len) && base = ~~ mask (LENGTH('i) - len) && x) =\n    (~~ mask (LENGTH('i) - len) && base = ~~ mask (LENGTH('i) - len) && x)", "by simp"], ["proof (state)\nthis:\n  (?x1 \\<in> ipset_from_netmask base (~~ mask (LENGTH('i) - len))) =\n  (base && ~~ mask (LENGTH('i) - len) = ?x1 && ~~ mask (LENGTH('i) - len))\n\ngoal (1 subgoal):\n 1. ipset_from_cidr base len = ip_cidr_set base len", "then"], ["proof (chain)\npicking this:\n  (?x1 \\<in> ipset_from_netmask base (~~ mask (LENGTH('i) - len))) =\n  (base && ~~ mask (LENGTH('i) - len) = ?x1 && ~~ mask (LENGTH('i) - len))", "show ?thesis"], ["proof (prove)\nusing this:\n  (?x1 \\<in> ipset_from_netmask base (~~ mask (LENGTH('i) - len))) =\n  (base && ~~ mask (LENGTH('i) - len) = ?x1 && ~~ mask (LENGTH('i) - len))\n\ngoal (1 subgoal):\n 1. ipset_from_cidr base len = ip_cidr_set base len", "unfolding ip_cidr_set_def ipset_from_cidr_def"], ["proof (prove)\nusing this:\n  (?x1 \\<in> ipset_from_netmask base (~~ mask (LENGTH('i) - len))) =\n  (base && ~~ mask (LENGTH('i) - len) = ?x1 && ~~ mask (LENGTH('i) - len))\n\ngoal (1 subgoal):\n 1. ipset_from_netmask base (mask len << LENGTH('i) - len) =\n    {j. base && ~~ mask (LENGTH('i) - len) =\n        j && ~~ mask (LENGTH('i) - len)}", "by(auto simp add:  maskshift_eq_not_mask_generic)"], ["proof (state)\nthis:\n  ipset_from_cidr base len = ip_cidr_set base len\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ip_cidr_set_change_base: \"j \\<in> ip_cidr_set i r \\<Longrightarrow> ip_cidr_set j r = ip_cidr_set i r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> ip_cidr_set i r \\<Longrightarrow>\n    ip_cidr_set j r = ip_cidr_set i r", "by (auto simp: ip_cidr_set_def)"], ["", "subsection\\<open>IP Addresses as WordIntervals\\<close>"], ["", "text\\<open>The nice thing is: @{typ \"'i wordinterval\"}s are executable.\\<close>"], ["", "definition iprange_single :: \"'i::len word \\<Rightarrow> 'i wordinterval\" where\n    \"iprange_single ip \\<equiv> WordInterval ip ip\""], ["", "fun iprange_interval :: \"('i::len word \\<times> 'i::len word) \\<Rightarrow> 'i wordinterval\" where\n    \"iprange_interval (ip_start, ip_end) = WordInterval ip_start ip_end\""], ["", "declare iprange_interval.simps[simp del]"], ["", "lemma iprange_interval_uncurry: \"iprange_interval ipcidr = uncurry WordInterval ipcidr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iprange_interval ipcidr = uncurry WordInterval ipcidr", "by(cases ipcidr) (simp add: iprange_interval.simps)"], ["", "lemma \"wordinterval_to_set (iprange_single ip) = {ip}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (iprange_single ip) = {ip}", "by(simp add: iprange_single_def)"], ["", "lemma \"wordinterval_to_set (iprange_interval (ip1, ip2)) = {ip1 .. ip2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (iprange_interval (ip1, ip2)) = {ip1..ip2}", "by(simp add: iprange_interval.simps)"], ["", "text\\<open>Now we can use the set operations on @{typ \"'i::len wordinterval\"}s\\<close>"], ["", "term wordinterval_to_set"], ["", "term wordinterval_element"], ["", "term wordinterval_union"], ["", "term wordinterval_empty"], ["", "term wordinterval_setminus"], ["", "term wordinterval_UNIV"], ["", "term wordinterval_invert"], ["", "term wordinterval_intersection"], ["", "term wordinterval_subset"], ["", "term wordinterval_eq"], ["", "subsection\\<open>IP Addresses in CIDR Notation\\<close>"], ["", "text\\<open>We want to convert IP addresses in CIDR notation to intervals.\n    We already have @{const ipset_from_cidr}, which gives back a non-executable set.\n    We want to convert to something we can store in an @{typ \"'i wordinterval\"}.\\<close>"], ["", "fun ipcidr_to_interval_start :: \"('i::len word \\<times> nat) \\<Rightarrow> 'i::len word\" where\n    \"ipcidr_to_interval_start (pre, len) = (\n      let netmask = (mask len) << (LENGTH('i) - len);\n          network_prefix = (pre AND netmask)\n      in network_prefix)\""], ["", "fun ipcidr_to_interval_end :: \"('i::len word \\<times> nat) \\<Rightarrow> 'i::len word\" where\n    \"ipcidr_to_interval_end (pre, len) = (\n      let netmask = (mask len) << (LENGTH('i) - len);\n          network_prefix = (pre AND netmask)\n      in network_prefix OR (NOT netmask))\""], ["", "definition ipcidr_to_interval :: \"('i::len word \\<times> nat) \\<Rightarrow> ('i word \\<times> 'i word)\" where\n    \"ipcidr_to_interval cidr \\<equiv> (ipcidr_to_interval_start cidr, ipcidr_to_interval_end cidr)\""], ["", "lemma ipset_from_cidr_ipcidr_to_interval:\n    \"ipset_from_cidr base len =\n      {ipcidr_to_interval_start (base,len) .. ipcidr_to_interval_end (base,len)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr base len =\n    {ipcidr_to_interval_start\n      (base, len)..ipcidr_to_interval_end (base, len)}", "by(simp add: Let_def ipcidr_to_interval_def ipset_from_cidr_def ipset_from_netmask_def)"], ["", "declare ipcidr_to_interval_start.simps[simp del] ipcidr_to_interval_end.simps[simp del]"], ["", "lemma ipcidr_to_interval:\n    \"ipcidr_to_interval (base, len) = (s,e) \\<Longrightarrow> ipset_from_cidr base len = {s .. e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_to_interval (base, len) = (s, e) \\<Longrightarrow>\n    ipset_from_cidr base len = {s..e}", "by (simp add: ipcidr_to_interval_def ipset_from_cidr_ipcidr_to_interval)"], ["", "definition ipcidr_tuple_to_wordinterval :: \"('i::len word \\<times> nat) \\<Rightarrow> 'i wordinterval\" where\n    \"ipcidr_tuple_to_wordinterval iprng \\<equiv> iprange_interval (ipcidr_to_interval iprng)\""], ["", "lemma wordinterval_to_set_ipcidr_tuple_to_wordinterval:\n    \"wordinterval_to_set (ipcidr_tuple_to_wordinterval (b, m)) = ipset_from_cidr b m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (ipcidr_tuple_to_wordinterval (b, m)) =\n    ipset_from_cidr b m", "unfolding ipcidr_tuple_to_wordinterval_def ipset_from_cidr_ipcidr_to_interval\n              ipcidr_to_interval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (iprange_interval\n       (ipcidr_to_interval_start (b, m), ipcidr_to_interval_end (b, m))) =\n    {ipcidr_to_interval_start (b, m)..ipcidr_to_interval_end (b, m)}", "by(simp add: iprange_interval.simps)"], ["", "lemma wordinterval_to_set_ipcidr_tuple_to_wordinterval_uncurry:\n    \"wordinterval_to_set (ipcidr_tuple_to_wordinterval ipcidr) = uncurry ipset_from_cidr ipcidr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (ipcidr_tuple_to_wordinterval ipcidr) =\n    uncurry ipset_from_cidr ipcidr", "by(cases ipcidr, simp add: wordinterval_to_set_ipcidr_tuple_to_wordinterval)"], ["", "definition ipcidr_union_set :: \"('i::len word \\<times> nat) set \\<Rightarrow> ('i word) set\" where\n    \"ipcidr_union_set ips \\<equiv> \\<Union>(base, len) \\<in> ips. ipset_from_cidr base len\""], ["", "lemma ipcidr_union_set_uncurry:\n    \"ipcidr_union_set ips = (\\<Union> ipcidr \\<in> ips. uncurry ipset_from_cidr ipcidr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_union_set ips = \\<Union> (uncurry ipset_from_cidr ` ips)", "by(simp add: ipcidr_union_set_def uncurry_case_stmt)"], ["", "subsection\\<open>Clever Operations on IP Addresses in CIDR Notation\\<close>"], ["", "text\\<open>Intersecting two intervals may result in a new interval.\n    Example: \\<open>{1..10} \\<inter> {5..20} = {5..10}\\<close>\n\n    Intersecting two IP address ranges represented as CIDR ranges results either in the empty set\n    or the smaller of the two ranges. It will never create a new range.\n    \\<close>"], ["", "context\n  begin"], ["", "(*contributed by Lars Noschinski*)\n    private"], ["", "lemma less_and_not_mask_eq:\n      fixes i :: \"('a :: len) word\"\n      assumes \"r2 \\<le> r1\" \"i && ~~ (mask r2) = x && ~~ (mask r2)\"\n      shows \"i && ~~ (mask r1) = x && ~~ (mask r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i && ~~ mask r1 = x && ~~ mask r1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i && ~~ mask r1 = x && ~~ mask r1", "have \"i AND NOT (mask r1) = (i && ~~ (mask r2)) && ~~ (mask r1)\" (is \"_ = ?w && _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. i && ~~ mask r1 = (i && ~~ mask r2) && ~~ mask r1", "using \\<open>r2 \\<le> r1\\<close>"], ["proof (prove)\nusing this:\n  r2 \\<le> r1\n\ngoal (1 subgoal):\n 1. i && ~~ mask r1 = (i && ~~ mask r2) && ~~ mask r1", "by (simp add: and_not_mask_twice max_def)"], ["proof (state)\nthis:\n  i && ~~ mask r1 = (i && ~~ mask r2) && ~~ mask r1\n\ngoal (1 subgoal):\n 1. i && ~~ mask r1 = x && ~~ mask r1", "also"], ["proof (state)\nthis:\n  i && ~~ mask r1 = (i && ~~ mask r2) && ~~ mask r1\n\ngoal (1 subgoal):\n 1. i && ~~ mask r1 = x && ~~ mask r1", "have \"?w = x && ~~ (mask r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i && ~~ mask r2 = x && ~~ mask r2", "by fact"], ["proof (state)\nthis:\n  i && ~~ mask r2 = x && ~~ mask r2\n\ngoal (1 subgoal):\n 1. i && ~~ mask r1 = x && ~~ mask r1", "also"], ["proof (state)\nthis:\n  i && ~~ mask r2 = x && ~~ mask r2\n\ngoal (1 subgoal):\n 1. i && ~~ mask r1 = x && ~~ mask r1", "have \"\\<dots> && ~~ (mask r1) = x && ~~ (mask r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x && ~~ mask r2) && ~~ mask r1 = x && ~~ mask r1", "using \\<open>r2 \\<le> r1\\<close>"], ["proof (prove)\nusing this:\n  r2 \\<le> r1\n\ngoal (1 subgoal):\n 1. (x && ~~ mask r2) && ~~ mask r1 = x && ~~ mask r1", "by (simp add: and_not_mask_twice max_def)"], ["proof (state)\nthis:\n  (x && ~~ mask r2) && ~~ mask r1 = x && ~~ mask r1\n\ngoal (1 subgoal):\n 1. i && ~~ mask r1 = x && ~~ mask r1", "finally"], ["proof (chain)\npicking this:\n  i && ~~ mask r1 = x && ~~ mask r1", "show ?thesis"], ["proof (prove)\nusing this:\n  i && ~~ mask r1 = x && ~~ mask r1\n\ngoal (1 subgoal):\n 1. i && ~~ mask r1 = x && ~~ mask r1", "."], ["proof (state)\nthis:\n  i && ~~ mask r1 = x && ~~ mask r1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ip_cidr_set_less:\n      fixes i :: \"'i::len word\"\n      shows \"r1 \\<le> r2 \\<Longrightarrow> ip_cidr_set i r2 \\<subseteq> ip_cidr_set i r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1 \\<le> r2 \\<Longrightarrow>\n    ip_cidr_set i r2 \\<subseteq> ip_cidr_set i r1", "unfolding ip_cidr_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. r1 \\<le> r2 \\<Longrightarrow>\n    {j. i && ~~ mask (LENGTH('i) - r2) = j && ~~ mask (LENGTH('i) - r2)}\n    \\<subseteq> {j. i && ~~ mask (LENGTH('i) - r1) =\n                    j && ~~ mask (LENGTH('i) - r1)}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r1 \\<le> r2;\n        i && ~~ mask (LENGTH('i) - r2) =\n        x && ~~ mask (LENGTH('i) - r2)\\<rbrakk>\n       \\<Longrightarrow> i && ~~ mask (LENGTH('i) - r1) =\n                         x && ~~ mask (LENGTH('i) - r1)", "apply (rule less_and_not_mask_eq[where ?r2.0=\"LENGTH('i) - r2\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r1 \\<le> r2;\n        i && ~~ mask (LENGTH('i) - r2) =\n        x && ~~ mask (LENGTH('i) - r2)\\<rbrakk>\n       \\<Longrightarrow> LENGTH('i) - r2 \\<le> LENGTH('i) - r1\n 2. \\<And>x.\n       \\<lbrakk>r1 \\<le> r2;\n        i && ~~ mask (LENGTH('i) - r2) =\n        x && ~~ mask (LENGTH('i) - r2)\\<rbrakk>\n       \\<Longrightarrow> i && ~~ mask (LENGTH('i) - r2) =\n                         x && ~~ mask (LENGTH('i) - r2)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma ip_cidr_set_intersect_subset_helper:\n      fixes i1 r1 i2 r2\n      assumes disj: \"ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 \\<noteq> {}\" and  \"r1 \\<le> r2\"\n      shows \"ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1", "from disj"], ["proof (chain)\npicking this:\n  ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 \\<noteq> {}", "obtain j where \"j \\<in> ip_cidr_set i1 r1\" \"j \\<in> ip_cidr_set i2 r2\""], ["proof (prove)\nusing this:\n  ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> ip_cidr_set i1 r1;\n         j \\<in> ip_cidr_set i2 r2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<in> ip_cidr_set i1 r1\n  j \\<in> ip_cidr_set i2 r2\n\ngoal (1 subgoal):\n 1. ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1", "with \\<open>r1 \\<le> r2\\<close>"], ["proof (chain)\npicking this:\n  r1 \\<le> r2\n  j \\<in> ip_cidr_set i1 r1\n  j \\<in> ip_cidr_set i2 r2", "have \"j \\<in> ip_cidr_set j r1\" \"j \\<in> ip_cidr_set j r1\""], ["proof (prove)\nusing this:\n  r1 \\<le> r2\n  j \\<in> ip_cidr_set i1 r1\n  j \\<in> ip_cidr_set i2 r2\n\ngoal (1 subgoal):\n 1. j \\<in> ip_cidr_set j r1 &&& j \\<in> ip_cidr_set j r1", "using ip_cidr_set_change_base ip_cidr_set_less"], ["proof (prove)\nusing this:\n  r1 \\<le> r2\n  j \\<in> ip_cidr_set i1 r1\n  j \\<in> ip_cidr_set i2 r2\n  ?j \\<in> ip_cidr_set ?i ?r \\<Longrightarrow>\n  ip_cidr_set ?j ?r = ip_cidr_set ?i ?r\n  ?r1.0 \\<le> ?r2.0 \\<Longrightarrow>\n  ip_cidr_set ?i ?r2.0 \\<subseteq> ip_cidr_set ?i ?r1.0\n\ngoal (1 subgoal):\n 1. j \\<in> ip_cidr_set j r1 &&& j \\<in> ip_cidr_set j r1", "by blast+"], ["proof (state)\nthis:\n  j \\<in> ip_cidr_set j r1\n  j \\<in> ip_cidr_set j r1\n\ngoal (1 subgoal):\n 1. ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1", "show \"ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ip_cidr_set i2 r2 \\<Longrightarrow> x \\<in> ip_cidr_set i1 r1", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ip_cidr_set i2 r2 \\<Longrightarrow> x \\<in> ip_cidr_set i1 r1", "assume \"i \\<in> ip_cidr_set i2 r2\""], ["proof (state)\nthis:\n  i \\<in> ip_cidr_set i2 r2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ip_cidr_set i2 r2 \\<Longrightarrow> x \\<in> ip_cidr_set i1 r1", "with \\<open>j \\<in> ip_cidr_set i2 r2\\<close>"], ["proof (chain)\npicking this:\n  j \\<in> ip_cidr_set i2 r2\n  i \\<in> ip_cidr_set i2 r2", "have \"i \\<in> ip_cidr_set j r2\""], ["proof (prove)\nusing this:\n  j \\<in> ip_cidr_set i2 r2\n  i \\<in> ip_cidr_set i2 r2\n\ngoal (1 subgoal):\n 1. i \\<in> ip_cidr_set j r2", "using ip_cidr_set_change_base"], ["proof (prove)\nusing this:\n  j \\<in> ip_cidr_set i2 r2\n  i \\<in> ip_cidr_set i2 r2\n  ?j \\<in> ip_cidr_set ?i ?r \\<Longrightarrow>\n  ip_cidr_set ?j ?r = ip_cidr_set ?i ?r\n\ngoal (1 subgoal):\n 1. i \\<in> ip_cidr_set j r2", "by auto"], ["proof (state)\nthis:\n  i \\<in> ip_cidr_set j r2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ip_cidr_set i2 r2 \\<Longrightarrow> x \\<in> ip_cidr_set i1 r1", "also"], ["proof (state)\nthis:\n  i \\<in> ip_cidr_set j r2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ip_cidr_set i2 r2 \\<Longrightarrow> x \\<in> ip_cidr_set i1 r1", "have \"ip_cidr_set j r2 \\<subseteq> ip_cidr_set j r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip_cidr_set j r2 \\<subseteq> ip_cidr_set j r1", "using \\<open>r1 \\<le> r2\\<close> ip_cidr_set_less"], ["proof (prove)\nusing this:\n  r1 \\<le> r2\n  ?r1.0 \\<le> ?r2.0 \\<Longrightarrow>\n  ip_cidr_set ?i ?r2.0 \\<subseteq> ip_cidr_set ?i ?r1.0\n\ngoal (1 subgoal):\n 1. ip_cidr_set j r2 \\<subseteq> ip_cidr_set j r1", "by blast"], ["proof (state)\nthis:\n  ip_cidr_set j r2 \\<subseteq> ip_cidr_set j r1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ip_cidr_set i2 r2 \\<Longrightarrow> x \\<in> ip_cidr_set i1 r1", "also"], ["proof (state)\nthis:\n  ip_cidr_set j r2 \\<subseteq> ip_cidr_set j r1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ip_cidr_set i2 r2 \\<Longrightarrow> x \\<in> ip_cidr_set i1 r1", "have \"\\<dots> = ip_cidr_set i1 r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip_cidr_set j r1 = ip_cidr_set i1 r1", "using \\<open>j \\<in> ip_cidr_set i1 r1\\<close> ip_cidr_set_change_base"], ["proof (prove)\nusing this:\n  j \\<in> ip_cidr_set i1 r1\n  ?j \\<in> ip_cidr_set ?i ?r \\<Longrightarrow>\n  ip_cidr_set ?j ?r = ip_cidr_set ?i ?r\n\ngoal (1 subgoal):\n 1. ip_cidr_set j r1 = ip_cidr_set i1 r1", "by blast"], ["proof (state)\nthis:\n  ip_cidr_set j r1 = ip_cidr_set i1 r1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ip_cidr_set i2 r2 \\<Longrightarrow> x \\<in> ip_cidr_set i1 r1", "finally"], ["proof (chain)\npicking this:\n  i \\<in> ip_cidr_set i1 r1", "show \"i \\<in> ip_cidr_set i1 r1\""], ["proof (prove)\nusing this:\n  i \\<in> ip_cidr_set i1 r1\n\ngoal (1 subgoal):\n 1. i \\<in> ip_cidr_set i1 r1", "."], ["proof (state)\nthis:\n  i \\<in> ip_cidr_set i1 r1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ip_cidr_set_notsubset_empty_inter:\n      \"\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2 \\<Longrightarrow>\n       \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1 \\<Longrightarrow>\n       ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2;\n     \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}", "apply(cases \"r1 \\<le> r2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2;\n     \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1;\n     r1 \\<le> r2\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}\n 2. \\<lbrakk>\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2;\n     \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1;\n     \\<not> r1 \\<le> r2\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2;\n     \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1;\n     r1 \\<le> r2\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}", "using ip_cidr_set_intersect_subset_helper"], ["proof (prove)\nusing this:\n  \\<lbrakk>ip_cidr_set ?i1.0 ?r1.0 \\<inter> ip_cidr_set ?i2.0 ?r2.0 \\<noteq>\n           {};\n   ?r1.0 \\<le> ?r2.0\\<rbrakk>\n  \\<Longrightarrow> ip_cidr_set ?i2.0 ?r2.0\n                    \\<subseteq> ip_cidr_set ?i1.0 ?r1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2;\n     \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1;\n     r1 \\<le> r2\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2;\n     \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1;\n     \\<not> r1 \\<le> r2\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}", "apply(cases \"r2 \\<le> r1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2;\n     \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1;\n     \\<not> r1 \\<le> r2; r2 \\<le> r1\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}\n 2. \\<lbrakk>\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2;\n     \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1;\n     \\<not> r1 \\<le> r2; \\<not> r2 \\<le> r1\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2;\n     \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1;\n     \\<not> r1 \\<le> r2; r2 \\<le> r1\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}", "using ip_cidr_set_intersect_subset_helper"], ["proof (prove)\nusing this:\n  \\<lbrakk>ip_cidr_set ?i1.0 ?r1.0 \\<inter> ip_cidr_set ?i2.0 ?r2.0 \\<noteq>\n           {};\n   ?r1.0 \\<le> ?r2.0\\<rbrakk>\n  \\<Longrightarrow> ip_cidr_set ?i2.0 ?r2.0\n                    \\<subseteq> ip_cidr_set ?i1.0 ?r1.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2;\n     \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1;\n     \\<not> r1 \\<le> r2; r2 \\<le> r1\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ip_cidr_set i1 r1 \\<subseteq> ip_cidr_set i2 r2;\n     \\<not> ip_cidr_set i2 r2 \\<subseteq> ip_cidr_set i1 r1;\n     \\<not> r1 \\<le> r2; \\<not> r2 \\<le> r1\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set i1 r1 \\<inter> ip_cidr_set i2 r2 = {}", "by(simp)"], ["", "end"], ["", "lemma ip_cidr_intersect:\n     \"\\<not> ipset_from_cidr b2 m2 \\<subseteq> ipset_from_cidr b1 m1 \\<Longrightarrow>\n      \\<not> ipset_from_cidr b1 m1 \\<subseteq> ipset_from_cidr b2 m2 \\<Longrightarrow>\n      ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ipset_from_cidr b2 m2 \\<subseteq> ipset_from_cidr b1 m1;\n     \\<not> ipset_from_cidr b1 m1 \\<subseteq> ipset_from_cidr b2 m2\\<rbrakk>\n    \\<Longrightarrow> ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2 =\n                      {}", "apply(simp add: ipset_from_cidr_eq_ip_cidr_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ip_cidr_set b2 m2 \\<subseteq> ip_cidr_set b1 m1;\n     \\<not> ip_cidr_set b1 m1 \\<subseteq> ip_cidr_set b2 m2\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set b1 m1 \\<inter> ip_cidr_set b2 m2 = {}", "using ip_cidr_set_notsubset_empty_inter"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ip_cidr_set ?i1.0 ?r1.0\n                  \\<subseteq> ip_cidr_set ?i2.0 ?r2.0;\n   \\<not> ip_cidr_set ?i2.0 ?r2.0\n          \\<subseteq> ip_cidr_set ?i1.0 ?r1.0\\<rbrakk>\n  \\<Longrightarrow> ip_cidr_set ?i1.0 ?r1.0 \\<inter>\n                    ip_cidr_set ?i2.0 ?r2.0 =\n                    {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> ip_cidr_set b2 m2 \\<subseteq> ip_cidr_set b1 m1;\n     \\<not> ip_cidr_set b1 m1 \\<subseteq> ip_cidr_set b2 m2\\<rbrakk>\n    \\<Longrightarrow> ip_cidr_set b1 m1 \\<inter> ip_cidr_set b2 m2 = {}", "by blast"], ["", "text\\<open>Computing the intersection of two IP address ranges in CIDR notation\\<close>"], ["", "fun ipcidr_conjunct :: \"('i::len word \\<times> nat) \\<Rightarrow> ('i word \\<times> nat) \\<Rightarrow> ('i word \\<times> nat) option\" where\n    \"ipcidr_conjunct (base1, m1) (base2, m2) = (\n       if\n         ipset_from_cidr base1 m1 \\<inter> ipset_from_cidr base2 m2 = {}\n       then\n         None\n       else if\n         ipset_from_cidr base1 m1 \\<subseteq> ipset_from_cidr base2 m2\n       then\n         Some (base1, m1)\n       else\n         Some (base2, m2)\n      )\""], ["", "text\\<open>Intersecting with an address with prefix length zero always yields a non-empty result.\\<close>"], ["", "lemma ipcidr_conjunct_any: \"ipcidr_conjunct a (x,0) \\<noteq> None\" \"ipcidr_conjunct (y,0) b \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_conjunct a (x, 0) \\<noteq> None &&&\n    ipcidr_conjunct (y, 0) b \\<noteq> None", "apply(cases a, simp add: ipset_from_cidr_0 ipset_from_cidr_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_conjunct (y, 0) b \\<noteq> None", "by(cases b, simp add: ipset_from_cidr_0 ipset_from_cidr_not_empty)"], ["", "lemma ipcidr_conjunct_correct: \"(case ipcidr_conjunct (b1, m1) (b2, m2)\n                                          of Some (bx, mx) \\<Rightarrow> ipset_from_cidr bx mx\n                                          |  None \\<Rightarrow> {}) =\n                                   (ipset_from_cidr b1 m1) \\<inter> (ipset_from_cidr b2 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> {}\n     | Some (bx, mx) \\<Rightarrow> ipset_from_cidr bx mx) =\n    ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipset_from_cidr b1 m1\n     \\<subseteq> ipset_from_cidr b2 m2 \\<longrightarrow>\n     ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2 \\<noteq>\n     {} \\<longrightarrow>\n     ipset_from_cidr b1 m1 =\n     ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2) \\<and>\n    (\\<not> ipset_from_cidr b1 m1\n            \\<subseteq> ipset_from_cidr b2 m2 \\<longrightarrow>\n     ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2 \\<noteq>\n     {} \\<longrightarrow>\n     ipset_from_cidr b2 m2 =\n     ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2)", "using ip_cidr_intersect"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ipset_from_cidr ?b2.0 ?m2.0\n                  \\<subseteq> ipset_from_cidr ?b1.0 ?m1.0;\n   \\<not> ipset_from_cidr ?b1.0 ?m1.0\n          \\<subseteq> ipset_from_cidr ?b2.0 ?m2.0\\<rbrakk>\n  \\<Longrightarrow> ipset_from_cidr ?b1.0 ?m1.0 \\<inter>\n                    ipset_from_cidr ?b2.0 ?m2.0 =\n                    {}\n\ngoal (1 subgoal):\n 1. (ipset_from_cidr b1 m1\n     \\<subseteq> ipset_from_cidr b2 m2 \\<longrightarrow>\n     ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2 \\<noteq>\n     {} \\<longrightarrow>\n     ipset_from_cidr b1 m1 =\n     ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2) \\<and>\n    (\\<not> ipset_from_cidr b1 m1\n            \\<subseteq> ipset_from_cidr b2 m2 \\<longrightarrow>\n     ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2 \\<noteq>\n     {} \\<longrightarrow>\n     ipset_from_cidr b2 m2 =\n     ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2)", "by fast"], ["", "declare ipcidr_conjunct.simps[simp del]"], ["", "subsection\\<open>Code Equations\\<close>"], ["", "text\\<open>Executable definition using word intervals\\<close>"], ["", "lemma ipcidr_conjunct_word[code_unfold]:\n  \"ipcidr_conjunct ips1 ips2 = (\n     if\n      wordinterval_empty (wordinterval_intersection\n                            (ipcidr_tuple_to_wordinterval ips1) (ipcidr_tuple_to_wordinterval ips2))\n     then\n       None\n     else if\n       wordinterval_subset (ipcidr_tuple_to_wordinterval ips1) (ipcidr_tuple_to_wordinterval ips2)\n     then\n       Some ips1\n     else\n       Some ips2\n     )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_conjunct ips1 ips2 =\n    (if wordinterval_empty\n         (wordinterval_intersection (ipcidr_tuple_to_wordinterval ips1)\n           (ipcidr_tuple_to_wordinterval ips2))\n     then None\n     else if wordinterval_subset (ipcidr_tuple_to_wordinterval ips1)\n              (ipcidr_tuple_to_wordinterval ips2)\n          then Some ips1 else Some ips2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wordinterval_to_set (ipcidr_tuple_to_wordinterval ips1)\n     \\<subseteq> wordinterval_to_set\n                  (ipcidr_tuple_to_wordinterval ips2) \\<longrightarrow>\n     (wordinterval_to_set (ipcidr_tuple_to_wordinterval ips1) \\<inter>\n      wordinterval_to_set (ipcidr_tuple_to_wordinterval ips2) =\n      {} \\<longrightarrow>\n      ipcidr_conjunct ips1 ips2 = None) \\<and>\n     (wordinterval_to_set (ipcidr_tuple_to_wordinterval ips1) \\<inter>\n      wordinterval_to_set (ipcidr_tuple_to_wordinterval ips2) \\<noteq>\n      {} \\<longrightarrow>\n      ipcidr_conjunct ips1 ips2 = Some ips1)) \\<and>\n    (\\<not> wordinterval_to_set (ipcidr_tuple_to_wordinterval ips1)\n            \\<subseteq> wordinterval_to_set\n                         (ipcidr_tuple_to_wordinterval\n                           ips2) \\<longrightarrow>\n     (wordinterval_to_set (ipcidr_tuple_to_wordinterval ips1) \\<inter>\n      wordinterval_to_set (ipcidr_tuple_to_wordinterval ips2) =\n      {} \\<longrightarrow>\n      ipcidr_conjunct ips1 ips2 = None) \\<and>\n     (wordinterval_to_set (ipcidr_tuple_to_wordinterval ips1) \\<inter>\n      wordinterval_to_set (ipcidr_tuple_to_wordinterval ips2) \\<noteq>\n      {} \\<longrightarrow>\n      ipcidr_conjunct ips1 ips2 = Some ips2))", "apply(cases ips1, cases ips2, rename_tac b1 m1 b2 m2, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b1 m1 b2 m2.\n       \\<lbrakk>ips1 = (b1, m1); ips2 = (b2, m2)\\<rbrakk>\n       \\<Longrightarrow> (wordinterval_to_set\n                           (ipcidr_tuple_to_wordinterval (b1, m1))\n                          \\<subseteq> wordinterval_to_set\n (ipcidr_tuple_to_wordinterval (b2, m2)) \\<longrightarrow>\n                          (wordinterval_to_set\n                            (ipcidr_tuple_to_wordinterval (b1, m1)) \\<inter>\n                           wordinterval_to_set\n                            (ipcidr_tuple_to_wordinterval (b2, m2)) =\n                           {} \\<longrightarrow>\n                           ipcidr_conjunct (b1, m1) (b2, m2) = None) \\<and>\n                          (wordinterval_to_set\n                            (ipcidr_tuple_to_wordinterval (b1, m1)) \\<inter>\n                           wordinterval_to_set\n                            (ipcidr_tuple_to_wordinterval (b2, m2)) \\<noteq>\n                           {} \\<longrightarrow>\n                           ipcidr_conjunct (b1, m1) (b2, m2) =\n                           Some (b1, m1))) \\<and>\n                         (\\<not> wordinterval_to_set\n                                  (ipcidr_tuple_to_wordinterval (b1, m1))\n                                 \\<subseteq> wordinterval_to_set\n        (ipcidr_tuple_to_wordinterval (b2, m2)) \\<longrightarrow>\n                          (wordinterval_to_set\n                            (ipcidr_tuple_to_wordinterval (b1, m1)) \\<inter>\n                           wordinterval_to_set\n                            (ipcidr_tuple_to_wordinterval (b2, m2)) =\n                           {} \\<longrightarrow>\n                           ipcidr_conjunct (b1, m1) (b2, m2) = None) \\<and>\n                          (wordinterval_to_set\n                            (ipcidr_tuple_to_wordinterval (b1, m1)) \\<inter>\n                           wordinterval_to_set\n                            (ipcidr_tuple_to_wordinterval (b2, m2)) \\<noteq>\n                           {} \\<longrightarrow>\n                           ipcidr_conjunct (b1, m1) (b2, m2) =\n                           Some (b2, m2)))", "apply(auto simp add: wordinterval_to_set_ipcidr_tuple_to_wordinterval ipcidr_conjunct.simps\n             split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*with the code_unfold lemma before, this works!*)"], ["", "lemma \"ipcidr_conjunct (0::32 word,0) (8,1) = Some (8, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_conjunct (0, 0) (8, 1) = Some (8, 1)", "by eval"], ["", "export_code ipcidr_conjunct checking SML"], ["", "text\\<open>making element check executable\\<close>"], ["", "lemma addr_in_ipset_from_netmask_code[code_unfold]:\n    \"addr \\<in> (ipset_from_netmask base netmask) \\<longleftrightarrow>\n      (base AND netmask) \\<le> addr \\<and> addr \\<le> (base AND netmask) OR (NOT netmask)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (addr \\<in> ipset_from_netmask base netmask) =\n    (base && netmask \\<le> addr \\<and>\n     addr \\<le> base && netmask || ~~ netmask)", "by(simp add: ipset_from_netmask_def Let_def)"], ["", "lemma addr_in_ipset_from_cidr_code[code_unfold]:\n    \"(addr::'i::len word) \\<in> (ipset_from_cidr pre len) \\<longleftrightarrow>\n       (pre AND ((mask len) << (LENGTH('i) - len))) \\<le> addr \\<and>\n        addr \\<le> pre OR (mask (LENGTH('i) - len))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (addr \\<in> ipset_from_cidr pre len) =\n    (pre && (mask len << LENGTH('i) - len) \\<le> addr \\<and>\n     addr \\<le> pre || mask (LENGTH('i) - len))", "unfolding ipset_from_cidr_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (addr\n     \\<in> {pre &&\n            (mask len <<\n             LENGTH('i) - len)..pre || mask (LENGTH('i) - len)}) =\n    (pre && (mask len << LENGTH('i) - len) \\<le> addr \\<and>\n     addr \\<le> pre || mask (LENGTH('i) - len))", "by simp"], ["", "end"]]}