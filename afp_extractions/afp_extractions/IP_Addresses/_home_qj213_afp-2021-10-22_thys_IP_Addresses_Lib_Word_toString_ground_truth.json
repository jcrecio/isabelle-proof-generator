{"file_name": "/home/qj213/afp-2021-10-22/thys/IP_Addresses/Lib_Word_toString.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IP_Addresses", "problem_names": ["lemma \"let word_upto = ((\\<lambda> i j. map (of_nat \\<circ> nat) [i .. j]) :: int \\<Rightarrow> int \\<Rightarrow> 32 word list)\n       in map (string_of_word_single False) (word_upto 1 35) =\n  [''1'', ''2'', ''3'', ''4'', ''5'', ''6'', ''7'', ''8'', ''9'',\n   ''A'', ''B'', ''C'', ''D'', ''E'', ''F'', ''G'', ''H'', ''I'',\n   ''J'', ''K'', ''L'', ''M'', ''N'', ''O'', ''P'', ''Q'', ''R'',\n   ''S'', ''T'', ''U'', ''V'', ''W'', ''X'', ''Y'', ''Z'']\"", "lemma \"hex_string_of_word0 (0xdeadbeef42 :: 42 word) = ''deadbeef42''\"", "lemma \"hex_string_of_word 1 (0x1 :: 5 word) = ''01''\"", "lemma \"hex_string_of_word 8 (0xff::32 word) = ''0000000ff''\"", "lemma \"dec_string_of_word0 (8::32 word) = ''8''\"", "lemma \"dec_string_of_word0 (3::2 word) = ''11''\"", "lemma \"dec_string_of_word0 (-1::8 word) = ''255''\"", "lemma string_of_word_single_atoi:\n  \"n < 10 \\<Longrightarrow> string_of_word_single True n = [char_of (48 + unat n)]\"", "lemma bintrunc_pos_eq: \"x \\<ge> 0 \\<Longrightarrow> bintrunc n x = x \\<longleftrightarrow> x < 2^n\"", "lemma string_of_word_base_ten_zeropad:\n  fixes w ::\"'a::len word\"\n  assumes lena: \"LENGTH('a) \\<ge> 5\" (*word must be long enough to encode 10 = 0xA*)\n  shows \"base = 10 \\<Longrightarrow> zero = 0 \\<Longrightarrow> string_of_word True base zero w = string_of_nat (unat w)\"", "lemma dec_string_of_word0:\n  \"dec_string_of_word0 (w8:: 8 word) = string_of_nat (unat w8)\"\n  \"dec_string_of_word0 (w16:: 16 word) = string_of_nat (unat w16)\"\n  \"dec_string_of_word0 (w32:: 32 word) = string_of_nat (unat w32)\"\n  \"dec_string_of_word0 (w64:: 64 word) = string_of_nat (unat w64)\"\n  \"dec_string_of_word0 (w128:: 128 word) = string_of_nat (unat w128)\""], "translations": [["", "lemma \"let word_upto = ((\\<lambda> i j. map (of_nat \\<circ> nat) [i .. j]) :: int \\<Rightarrow> int \\<Rightarrow> 32 word list)\n       in map (string_of_word_single False) (word_upto 1 35) =\n  [''1'', ''2'', ''3'', ''4'', ''5'', ''6'', ''7'', ''8'', ''9'',\n   ''A'', ''B'', ''C'', ''D'', ''E'', ''F'', ''G'', ''H'', ''I'',\n   ''J'', ''K'', ''L'', ''M'', ''N'', ''O'', ''P'', ''Q'', ''R'',\n   ''S'', ''T'', ''U'', ''V'', ''W'', ''X'', ''Y'', ''Z'']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let word_upto = \\<lambda>i j. map (word_of_nat \\<circ> nat) [i..j]\n    in map (string_of_word_single False) (word_upto 1 35) =\n       [''1'', ''2'', ''3'', ''4'', ''5'', ''6'', ''7'', ''8'', ''9'',\n        ''A'', ''B'', ''C'', ''D'', ''E'', ''F'', ''G'', ''H'', ''I'',\n        ''J'', ''K'', ''L'', ''M'', ''N'', ''O'', ''P'', ''Q'', ''R'',\n        ''S'', ''T'', ''U'', ''V'', ''W'', ''X'', ''Y'', ''Z'']", "by eval"], ["", "(* parameters: lowercase, base, minimum length - 1, to-be-serialized word *)"], ["", "function string_of_word :: \"bool \\<Rightarrow> ('a :: len) word \\<Rightarrow> nat \\<Rightarrow> ('a :: len) word \\<Rightarrow> string\" where\n  \"string_of_word lc base ml w =\n    (if\n       base < 2 \\<or> LENGTH('a) < 2\n     then\n       undefined\n     else if\n       w < base \\<and> ml = 0\n     then\n       string_of_word_single lc w\n     else\n       string_of_word lc base (ml - 1) (w div base) @ string_of_word_single lc (w mod base)\n     )\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>lc base ml w.\n           x = (lc, base, ml, w) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>lc base ml w lca basea mla wa.\n       (lc, base, ml, w) = (lca, basea, mla, wa) \\<Longrightarrow>\n       (if base < 2 \\<or> LENGTH('a) < 2 then undefined\n        else if w < base \\<and> ml = 0 then string_of_word_single lc w\n             else string_of_word_sumC (lc, base, ml - 1, w div base) @\n                  string_of_word_single lc (w mod base)) =\n       (if basea < 2 \\<or> LENGTH('a) < 2 then undefined\n        else if wa < basea \\<and> mla = 0 then string_of_word_single lca wa\n             else string_of_word_sumC (lca, basea, mla - 1, wa div basea) @\n                  string_of_word_single lca (wa mod basea))", "by pat_completeness auto"], ["", "definition \"hex_string_of_word l \\<equiv> string_of_word True (16 :: ('a::len) word) l\""], ["", "definition \"hex_string_of_word0 \\<equiv> hex_string_of_word 0\""], ["", "(* be careful though, these functions only make sense with words > length 4.\n   With 4 bits, base 16 is not representable. *)"], ["", "definition \"dec_string_of_word0 \\<equiv> string_of_word True 10 0\""], ["", "termination string_of_word"], ["proof (prove)\ngoal (1 subgoal):\n 1. All string_of_word_dom", "apply(relation \"measure (\\<lambda>(a,b,c,d). unat d + c)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(a, b, c, d). unat d + c))\n 2. \\<And>lc base ml w.\n       \\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n        \\<not> (w < base \\<and> ml = 0)\\<rbrakk>\n       \\<Longrightarrow> ((lc, base, ml - 1, w div base), lc, base, ml, w)\n                         \\<in> measure (\\<lambda>(a, b, c, d). unat d + c)", "apply(rule wf_measure)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lc base ml w.\n       \\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n        \\<not> (w < base \\<and> ml = 0)\\<rbrakk>\n       \\<Longrightarrow> ((lc, base, ml - 1, w div base), lc, base, ml, w)\n                         \\<in> measure (\\<lambda>(a, b, c, d). unat d + c)", "apply(subst in_measure)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lc base ml w.\n       \\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n        \\<not> (w < base \\<and> ml = 0)\\<rbrakk>\n       \\<Longrightarrow> (case (lc, base, ml - 1, w div base) of\n                          (a, b, c, d) \\<Rightarrow> unat d + c)\n                         < (case (lc, base, ml, w) of\n                            (a, b, c, d) \\<Rightarrow> unat d + c)", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>w < base \\<longrightarrow> 0 < ml; \\<not> base < 2;\n        \\<not> LENGTH('a) < 2\\<rbrakk>\n       \\<Longrightarrow> unat (w div base) + (ml - Suc 0) < unat w + ml", "subgoal for base ml n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < base \\<longrightarrow> 0 < ml; \\<not> base < 2;\n     \\<not> LENGTH('a) < 2\\<rbrakk>\n    \\<Longrightarrow> unat (n div base) + (ml - Suc 0) < unat n + ml", "apply(case_tac \"ml \\<noteq> 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < base \\<longrightarrow> 0 < ml; \\<not> base < 2;\n     \\<not> LENGTH('a) < 2; ml \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat (n div base) + (ml - Suc 0) < unat n + ml\n 2. \\<lbrakk>n < base \\<longrightarrow> 0 < ml; \\<not> base < 2;\n     \\<not> LENGTH('a) < 2; \\<not> ml \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat (n div base) + (ml - Suc 0) < unat n + ml", "apply(simp add: less_eq_Suc_le unat_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < base \\<longrightarrow> 0 < ml; \\<not> base < 2;\n     \\<not> LENGTH('a) < 2; \\<not> ml \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> unat (n div base) + (ml - Suc 0) < unat n + ml", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < base; \\<not> base < 2; \\<not> LENGTH('a) < 2;\n     ml = 0\\<rbrakk>\n    \\<Longrightarrow> unat (n div base) < unat n", "apply(subgoal_tac \"(n div base) < n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n < base; \\<not> base < 2; \\<not> LENGTH('a) < 2;\n     ml = 0; n div base < n\\<rbrakk>\n    \\<Longrightarrow> unat (n div base) < unat n\n 2. \\<lbrakk>\\<not> n < base; \\<not> base < 2; \\<not> LENGTH('a) < 2;\n     ml = 0\\<rbrakk>\n    \\<Longrightarrow> n div base < n", "apply(blast intro: unat_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < base; \\<not> base < 2; \\<not> LENGTH('a) < 2;\n     ml = 0\\<rbrakk>\n    \\<Longrightarrow> n div base < n", "apply(rule div_less_dividend_word)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n < base; \\<not> base < 2; \\<not> LENGTH('a) < 2;\n     ml = 0\\<rbrakk>\n    \\<Longrightarrow> n \\<noteq> 0\n 2. \\<lbrakk>\\<not> n < base; \\<not> base < 2; \\<not> LENGTH('a) < 2;\n     ml = 0\\<rbrakk>\n    \\<Longrightarrow> base \\<noteq> 1", "apply (auto simp add: not_less word_le_nat_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare string_of_word.simps[simp del]"], ["", "lemma \"hex_string_of_word0 (0xdeadbeef42 :: 42 word) = ''deadbeef42''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hex_string_of_word0 956397711170 = ''deadbeef42''", "by eval"], ["", "lemma \"hex_string_of_word 1 (0x1 :: 5 word) = ''01''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hex_string_of_word 1 1 = ''01''", "by eval"], ["", "lemma \"hex_string_of_word 8 (0xff::32 word) = ''0000000ff''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hex_string_of_word 8 255 = ''0000000ff''", "by eval"], ["", "lemma \"dec_string_of_word0 (8::32 word) = ''8''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_string_of_word0 8 = ''8''", "by eval"], ["", "lemma \"dec_string_of_word0 (3::2 word) = ''11''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_string_of_word0 3 = ''11''", "by eval"], ["", "lemma \"dec_string_of_word0 (-1::8 word) = ''255''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_string_of_word0 (- 1) = ''255''", "by eval"], ["", "lemma string_of_word_single_atoi:\n  \"n < 10 \\<Longrightarrow> string_of_word_single True n = [char_of (48 + unat n)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 10 \\<Longrightarrow>\n    string_of_word_single True n = [char_of (48 + unat n)]", "by(simp add: string_of_word_single_def)"], ["", "(*TODO: move!*)"], ["", "lemma bintrunc_pos_eq: \"x \\<ge> 0 \\<Longrightarrow> bintrunc n x = x \\<longleftrightarrow> x < 2^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> (take_bit n x = x) = (x < 2 ^ n)", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; take_bit n x = x\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ n\n 2. \\<lbrakk>0 \\<le> x; x < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> take_bit n x = x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; take_bit n x = x\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ n", "using bintr_lt2p"], ["proof (prove)\nusing this:\n  take_bit ?n ?w < 2 ^ ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; take_bit n x = x\\<rbrakk>\n    \\<Longrightarrow> x < 2 ^ n", "by metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x < 2 ^ n\\<rbrakk>\n    \\<Longrightarrow> take_bit n x = x", "by (simp add: mod_pos_pos_trivial no_bintr_alt1; fail)"], ["", "(*The following lemma [symmetric] as [code_unfold] may give some cool speedup*)"], ["", "lemma string_of_word_base_ten_zeropad:\n  fixes w ::\"'a::len word\"\n  assumes lena: \"LENGTH('a) \\<ge> 5\" (*word must be long enough to encode 10 = 0xA*)\n  shows \"base = 10 \\<Longrightarrow> zero = 0 \\<Longrightarrow> string_of_word True base zero w = string_of_nat (unat w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>base = 10; zero = 0\\<rbrakk>\n    \\<Longrightarrow> string_of_word True base zero w =\n                      string_of_nat (unat w)", "proof(induction True base zero w rule: string_of_word.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "case (1 base ml n)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n   \\<not> (n < base \\<and> ml = 0); base = 10; ml - 1 = 0\\<rbrakk>\n  \\<Longrightarrow> string_of_word True base (ml - 1) (n div base) =\n                    string_of_nat (unat (n div base))\n  base = 10\n  ml = 0\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "note  Word.word_less_no[simp del]"], ["proof (state)\nthis:\n  (numeral ?a < numeral ?b) = (uint (numeral ?a) < uint (numeral ?b))\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "note  Word.uint_bintrunc[simp del]"], ["proof (state)\nthis:\n  uint (numeral ?bin) = take_bit LENGTH(?'a) (numeral ?bin)\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "have \"5 \\<le> n \\<Longrightarrow> bintrunc n 10 = 10\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow> take_bit n 10 = 10", "apply(subst bintrunc_pos_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 5 \\<le> n \\<Longrightarrow> 0 \\<le> 10\n 2. 5 \\<le> n \\<Longrightarrow> 10 < 2 ^ n", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow> 10 < 2 ^ n", "apply(induction rule: Nat.dec_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 10 < 2 ^ 5\n 2. \\<And>n.\n       \\<lbrakk>5 \\<le> n; n < n; 10 < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> 10 < 2 ^ Suc n", "by simp+"], ["proof (state)\nthis:\n  5 \\<le> ?n \\<Longrightarrow> take_bit ?n 10 = 10\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "with lena"], ["proof (chain)\npicking this:\n  5 \\<le> LENGTH('a)\n  5 \\<le> ?n \\<Longrightarrow> take_bit ?n 10 = 10", "have unat_ten: \"unat (0xA::'a::len word) = 10\""], ["proof (prove)\nusing this:\n  5 \\<le> LENGTH('a)\n  5 \\<le> ?n \\<Longrightarrow> take_bit ?n 10 = 10\n\ngoal (1 subgoal):\n 1. unat 10 = 10", "by(simp)"], ["proof (state)\nthis:\n  unat 10 = 10\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "have \"5 \\<le> n \\<Longrightarrow> bintrunc n 2 = 2\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow> take_bit n 2 = 2", "apply(subst bintrunc_pos_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 5 \\<le> n \\<Longrightarrow> 0 \\<le> 2\n 2. 5 \\<le> n \\<Longrightarrow> 2 < 2 ^ n", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 \\<le> n \\<Longrightarrow> 2 < 2 ^ n", "apply(induction rule: Nat.dec_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 2 < 2 ^ 5\n 2. \\<And>n.\n       \\<lbrakk>5 \\<le> n; n < n; 2 < 2 ^ n\\<rbrakk>\n       \\<Longrightarrow> 2 < 2 ^ Suc n", "by simp+"], ["proof (state)\nthis:\n  5 \\<le> ?n \\<Longrightarrow> take_bit ?n 2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "with lena"], ["proof (chain)\npicking this:\n  5 \\<le> LENGTH('a)\n  5 \\<le> ?n \\<Longrightarrow> take_bit ?n 2 = 2", "have unat_two: \"unat (2::'a::len word) = 2\""], ["proof (prove)\nusing this:\n  5 \\<le> LENGTH('a)\n  5 \\<le> ?n \\<Longrightarrow> take_bit ?n 2 = 2\n\ngoal (1 subgoal):\n 1. unat 2 = 2", "by(simp)"], ["proof (state)\nthis:\n  unat 2 = 2\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "have unat_mod_ten: \"unat (n mod 0xA) = unat n mod 10\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (n mod 10) = unat n mod 10", "apply(subst Word.unat_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat n mod unat 10 = unat n mod 10", "apply(subst unat_ten)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat n mod 10 = unat n mod 10", "by(simp)"], ["proof (state)\nthis:\n  unat (n mod 10) = unat n mod 10\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "have unat_div_ten: \"(unat (n div 0xA)) = unat n div 10\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat (n div 10) = unat n div 10", "apply(subst Word.unat_div)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat n div unat 10 = unat n div 10", "apply(subst unat_ten)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat n div 10 = unat n div 10", "by simp"], ["proof (state)\nthis:\n  unat (n div 10) = unat n div 10\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "have n_less_ten_unat: \"n < 0xA \\<Longrightarrow> (unat n < 10)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 10 \\<Longrightarrow> unat n < 10", "apply(rule unat_less_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 10 \\<Longrightarrow> n < word_of_nat 10", "by(simp)"], ["proof (state)\nthis:\n  n < 10 \\<Longrightarrow> unat n < 10\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "have \"0xA \\<le> n \\<Longrightarrow> 10 \\<le> unat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 10 \\<le> n \\<Longrightarrow> 10 \\<le> unat n", "apply(subst(asm) Word.word_le_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat 10 \\<le> unat n \\<Longrightarrow> 10 \\<le> unat n", "apply(subst(asm) unat_ten)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 10 \\<le> unat n \\<Longrightarrow> 10 \\<le> unat n", "by(simp)"], ["proof (state)\nthis:\n  10 \\<le> n \\<Longrightarrow> 10 \\<le> unat n\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "hence n_less_ten_unat_not: \"\\<not> n < 0xA \\<Longrightarrow> \\<not> unat n < 10\""], ["proof (prove)\nusing this:\n  10 \\<le> n \\<Longrightarrow> 10 \\<le> unat n\n\ngoal (1 subgoal):\n 1. \\<not> n < 10 \\<Longrightarrow> \\<not> unat n < 10", "by fastforce"], ["proof (state)\nthis:\n  \\<not> n < 10 \\<Longrightarrow> \\<not> unat n < 10\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "have not_wordlength_too_small: \"\\<not> LENGTH('a) < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> LENGTH('a) < 2", "using lena"], ["proof (prove)\nusing this:\n  5 \\<le> LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<not> LENGTH('a) < 2", "by fastforce"], ["proof (state)\nthis:\n  \\<not> LENGTH('a) < 2\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "have \"2 \\<le> (0xA::'a word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> 10", "apply(subst word_le_nat_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat 2 \\<le> unat 10", "apply(subst unat_ten unat_two)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unat 2 \\<le> 10", "apply(subst unat_two)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> 10", "by(simp)"], ["proof (state)\nthis:\n  2 \\<le> 10\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "hence ten_not_less_two: \"\\<not> (0xA::'a word) < 2\""], ["proof (prove)\nusing this:\n  2 \\<le> 10\n\ngoal (1 subgoal):\n 1. \\<not> 10 < 2", "by (simp add: Word.word_less_no Word.uint_bintrunc)"], ["proof (state)\nthis:\n  \\<not> 10 < 2\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "with 1(2,3)"], ["proof (chain)\npicking this:\n  base = 10\n  ml = 0\n  \\<not> 10 < 2", "have \" \\<not> (base < 2 \\<or> LENGTH(32) < 2)\""], ["proof (prove)\nusing this:\n  base = 10\n  ml = 0\n  \\<not> 10 < 2\n\ngoal (1 subgoal):\n 1. \\<not> (base < 2 \\<or> LENGTH(32) < 2)", "by(simp)"], ["proof (state)\nthis:\n  \\<not> (base < 2 \\<or> LENGTH(32) < 2)\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "with 1 not_wordlength_too_small"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n   \\<not> (n < base \\<and> ml = 0); base = 10; ml - 1 = 0\\<rbrakk>\n  \\<Longrightarrow> string_of_word True base (ml - 1) (n div base) =\n                    string_of_nat (unat (n div base))\n  base = 10\n  ml = 0\n  \\<not> LENGTH('a) < 2\n  \\<not> (base < 2 \\<or> LENGTH(32) < 2)", "have IH: \"\\<not> n < 0xA \\<Longrightarrow> string_of_word True 0xA 0 (n div 0xA) = string_of_nat (unat (n div 0xA))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n   \\<not> (n < base \\<and> ml = 0); base = 10; ml - 1 = 0\\<rbrakk>\n  \\<Longrightarrow> string_of_word True base (ml - 1) (n div base) =\n                    string_of_nat (unat (n div base))\n  base = 10\n  ml = 0\n  \\<not> LENGTH('a) < 2\n  \\<not> (base < 2 \\<or> LENGTH(32) < 2)\n\ngoal (1 subgoal):\n 1. \\<not> n < 10 \\<Longrightarrow>\n    string_of_word True 10 0 (n div 10) = string_of_nat (unat (n div 10))", "by(simp)"], ["proof (state)\nthis:\n  \\<not> n < 10 \\<Longrightarrow>\n  string_of_word True 10 0 (n div 10) = string_of_nat (unat (n div 10))\n\ngoal (1 subgoal):\n 1. \\<And>base ml w.\n       \\<lbrakk>\\<lbrakk>\\<not> (base < 2 \\<or> LENGTH('a) < 2);\n                 \\<not> (w < base \\<and> ml = 0); base = 10;\n                 ml - 1 = 0\\<rbrakk>\n                \\<Longrightarrow> string_of_word True base (ml - 1)\n                                   (w div base) =\n                                  string_of_nat (unat (w div base));\n        base = 10; ml = 0\\<rbrakk>\n       \\<Longrightarrow> string_of_word True base ml w =\n                         string_of_nat (unat w)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. string_of_word True base ml n = string_of_nat (unat n)", "apply(simp add: 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. string_of_word True 10 0 n = string_of_nat (unat n)", "apply(cases \"n < 0xA\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < 10 \\<Longrightarrow>\n    string_of_word True 10 0 n = string_of_nat (unat n)\n 2. \\<not> n < 10 \\<Longrightarrow>\n    string_of_word True 10 0 n = string_of_nat (unat n)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 10 \\<Longrightarrow>\n    string_of_word True 10 0 n = string_of_nat (unat n)", "apply(subst(1) string_of_word.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 10 \\<Longrightarrow>\n    (if 10 < 2 \\<or> LENGTH('a) < 2 then undefined\n     else if n < 10 \\<and> 0 = 0 then string_of_word_single True n\n          else string_of_word True 10 (0 - 1) (n div 10) @\n               string_of_word_single True (n mod 10)) =\n    string_of_nat (unat n)", "apply(subst(1) string_of_nat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 10 \\<Longrightarrow>\n    (if 10 < 2 \\<or> LENGTH('a) < 2 then undefined\n     else if n < 10 \\<and> 0 = 0 then string_of_word_single True n\n          else string_of_word True 10 (0 - 1) (n div 10) @\n               string_of_word_single True (n mod 10)) =\n    (if unat n < 10 then [char_of (48 + unat n)]\n     else string_of_nat (unat n div 10) @ [char_of (48 + unat n mod 10)])", "apply(simp add: n_less_ten_unat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 10 \\<Longrightarrow>\n    (10 < 2 \\<longrightarrow> undefined = [char_of (48 + unat n)]) \\<and>\n    (LENGTH('a) < 2 \\<longrightarrow>\n     undefined = [char_of (48 + unat n)]) \\<and>\n    (\\<not> 10 < 2 \\<and> \\<not> LENGTH('a) < 2 \\<longrightarrow>\n     string_of_word_single True n = [char_of (48 + unat n)])", "by(simp add: not_wordlength_too_small ten_not_less_two string_of_word_single_atoi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n < 10 \\<Longrightarrow>\n    string_of_word True 10 0 n = string_of_nat (unat n)", "using sym[OF IH]"], ["proof (prove)\nusing this:\n  \\<not> n < 10 \\<Longrightarrow>\n  string_of_nat (unat (n div 10)) = string_of_word True 10 0 (n div 10)\n\ngoal (1 subgoal):\n 1. \\<not> n < 10 \\<Longrightarrow>\n    string_of_word True 10 0 n = string_of_nat (unat n)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> string_of_word True 10 0 n = string_of_nat (unat n)", "apply(subst(1) string_of_word.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> (if 10 < 2 \\<or> LENGTH('a) < 2 then undefined\n                       else if n < 10 \\<and> 0 = 0\n                            then string_of_word_single True n\n                            else string_of_word True 10 (0 - 1) (n div 10) @\n                                 string_of_word_single True (n mod 10)) =\n                      string_of_nat (unat n)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> (10 < 2 \\<longrightarrow>\n                       undefined = string_of_nat (unat n)) \\<and>\n                      (LENGTH('a) < 2 \\<longrightarrow>\n                       undefined = string_of_nat (unat n)) \\<and>\n                      (\\<not> 10 < 2 \\<and>\n                       \\<not> LENGTH('a) < 2 \\<longrightarrow>\n                       string_of_word True 10 0 (n div 10) @\n                       string_of_word_single True (n mod 10) =\n                       string_of_nat (unat n))", "apply(subst(1) string_of_nat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> (10 < 2 \\<longrightarrow>\n                       undefined =\n                       (if unat n < 10 then [char_of (48 + unat n)]\n                        else string_of_nat (unat n div 10) @\n                             [char_of (48 + unat n mod 10)])) \\<and>\n                      (LENGTH('a) < 2 \\<longrightarrow>\n                       undefined = string_of_nat (unat n)) \\<and>\n                      (\\<not> 10 < 2 \\<and>\n                       \\<not> LENGTH('a) < 2 \\<longrightarrow>\n                       string_of_word True 10 0 (n div 10) @\n                       string_of_word_single True (n mod 10) =\n                       string_of_nat (unat n))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> (unat n < 10 \\<longrightarrow>\n                       (10 < 2 \\<longrightarrow>\n                        undefined = [char_of (48 + unat n)]) \\<and>\n                       (LENGTH('a) < 2 \\<longrightarrow>\n                        undefined = string_of_nat (unat n)) \\<and>\n                       (\\<not> 10 < 2 \\<and>\n                        \\<not> LENGTH('a) < 2 \\<longrightarrow>\n                        string_of_word True 10 0 (n div 10) @\n                        string_of_word_single True (n mod 10) =\n                        string_of_nat (unat n))) \\<and>\n                      (\\<not> unat n < 10 \\<longrightarrow>\n                       (10 < 2 \\<longrightarrow>\n                        undefined =\n                        string_of_nat (unat n div 10) @\n                        [char_of (48 + unat n mod 10)]) \\<and>\n                       (LENGTH('a) < 2 \\<longrightarrow>\n                        undefined = string_of_nat (unat n)) \\<and>\n                       (\\<not> 10 < 2 \\<and>\n                        \\<not> LENGTH('a) < 2 \\<longrightarrow>\n                        string_of_word True 10 0 (n div 10) @\n                        string_of_word_single True (n mod 10) =\n                        string_of_nat (unat n)))", "apply(simp add: not_wordlength_too_small ten_not_less_two)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> string_of_word True 10 0 (n div 10) @\n                      string_of_word_single True (n mod 10) =\n                      string_of_nat (unat n)", "apply(subst string_of_word_single_atoi)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> n mod 10 < 10\n 2. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> string_of_word True 10 0 (n div 10) @\n                      [char_of (48 + unat (n mod 10))] =\n                      string_of_nat (unat n)", "apply(rule Word.word_mod_less_divisor)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> 0 < 10\n 2. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> string_of_word True 10 0 (n div 10) @\n                      [char_of (48 + unat (n mod 10))] =\n                      string_of_nat (unat n)", "using unat_ten word_gt_0_no"], ["proof (prove)\nusing this:\n  unat 10 = 10\n  (0 < numeral ?y) = (0 \\<noteq> numeral ?y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> 0 < 10\n 2. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> string_of_word True 10 0 (n div 10) @\n                      [char_of (48 + unat (n mod 10))] =\n                      string_of_nat (unat n)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> string_of_word True 10 0 (n div 10) @\n                      [char_of (48 + unat (n mod 10))] =\n                      string_of_nat (unat n)", "apply(simp add: unat_mod_ten)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> string_of_word True 10 0 (n div 10) @\n                      [char_of (48 + unat n mod 10)] =\n                      string_of_nat (unat n)", "apply(rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> n < 10;\n     string_of_nat (unat (n div 10)) =\n     string_of_word True 10 0 (n div 10)\\<rbrakk>\n    \\<Longrightarrow> string_of_nat (unat n) =\n                      string_of_word True 10 0 (n div 10) @\n                      [char_of (48 + unat n mod 10)]", "apply(drule n_less_ten_unat_not)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>string_of_nat (unat (n div 10)) =\n             string_of_word True 10 0 (n div 10);\n     \\<not> unat n < 10\\<rbrakk>\n    \\<Longrightarrow> string_of_nat (unat n) =\n                      string_of_word True 10 0 (n div 10) @\n                      [char_of (48 + unat n mod 10)]", "apply(simp add: unat_div_ten)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>string_of_nat (unat n div 10) =\n             string_of_word True 10 0 (n div 10);\n     \\<not> unat n < 10\\<rbrakk>\n    \\<Longrightarrow> string_of_nat (unat n) =\n                      string_of_word True 10 0 (n div 10) @\n                      [char_of (48 + unat n mod 10)]", "by (simp add: string_of_nat.simps)"], ["proof (state)\nthis:\n  string_of_word True base ml n = string_of_nat (unat n)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*TODO: one for all words?*)"], ["", "lemma dec_string_of_word0:\n  \"dec_string_of_word0 (w8:: 8 word) = string_of_nat (unat w8)\"\n  \"dec_string_of_word0 (w16:: 16 word) = string_of_nat (unat w16)\"\n  \"dec_string_of_word0 (w32:: 32 word) = string_of_nat (unat w32)\"\n  \"dec_string_of_word0 (w64:: 64 word) = string_of_nat (unat w64)\"\n  \"dec_string_of_word0 (w128:: 128 word) = string_of_nat (unat w128)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dec_string_of_word0 w8 = string_of_nat (unat w8) &&&\n     dec_string_of_word0 w16 = string_of_nat (unat w16)) &&&\n    dec_string_of_word0 w32 = string_of_nat (unat w32) &&&\n    dec_string_of_word0 w64 = string_of_nat (unat w64) &&&\n    dec_string_of_word0 w128 = string_of_nat (unat w128)", "unfolding dec_string_of_word0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (string_of_word True 10 0 w8 = string_of_nat (unat w8) &&&\n     string_of_word True 10 0 w16 = string_of_nat (unat w16)) &&&\n    string_of_word True 10 0 w32 = string_of_nat (unat w32) &&&\n    string_of_word True 10 0 w64 = string_of_nat (unat w64) &&&\n    string_of_word True 10 0 w128 = string_of_nat (unat w128)", "using string_of_word_base_ten_zeropad"], ["proof (prove)\nusing this:\n  \\<lbrakk>5 \\<le> LENGTH(?'a); ?base = 10; ?zero = 0\\<rbrakk>\n  \\<Longrightarrow> string_of_word True ?base ?zero ?w =\n                    string_of_nat (unat ?w)\n\ngoal (1 subgoal):\n 1. (string_of_word True 10 0 w8 = string_of_nat (unat w8) &&&\n     string_of_word True 10 0 w16 = string_of_nat (unat w16)) &&&\n    string_of_word True 10 0 w32 = string_of_nat (unat w32) &&&\n    string_of_word True 10 0 w64 = string_of_nat (unat w64) &&&\n    string_of_word True 10 0 w128 = string_of_nat (unat w128)", "by force+"], ["", "end"]]}