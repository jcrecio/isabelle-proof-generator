{"file_name": "/home/qj213/afp-2021-10-22/thys/IP_Addresses/Lib_List_toString.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IP_Addresses", "problem_names": ["lemma list_separated_toString_helper: \"list_separated_toString = list_separated_toString_helper\"", "lemma list_separated_toString_intersperse:\n  \"intersperse sep (map f xs) = list_separated_toString [sep] f xs\"", "lemma \"list_toString string_of_nat [1,2,3] = ''[1, 2, 3]''\""], "translations": [["", "lemma list_separated_toString_helper: \"list_separated_toString = list_separated_toString_helper\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_separated_toString = list_separated_toString_helper", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_separated_toString = list_separated_toString_helper", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. list_separated_toString = list_separated_toString_helper", "fix sep and toStr::\"('a \\<Rightarrow> char list)\" and ls"], ["proof (state)\ngoal (1 subgoal):\n 1. list_separated_toString = list_separated_toString_helper", "have \"list_separated_toString sep toStr ls = list_separated_toString_helper sep toStr ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_separated_toString sep toStr ls =\n    list_separated_toString_helper sep toStr ls", "by(induction sep toStr ls rule: list_separated_toString_helper.induct) (simp_all add: list_separated_toString_def)"], ["proof (state)\nthis:\n  list_separated_toString sep toStr ls =\n  list_separated_toString_helper sep toStr ls\n\ngoal (1 subgoal):\n 1. list_separated_toString = list_separated_toString_helper", "}"], ["proof (state)\nthis:\n  list_separated_toString ?sep2 ?toStr2 ?ls2 =\n  list_separated_toString_helper ?sep2 ?toStr2 ?ls2\n\ngoal (1 subgoal):\n 1. list_separated_toString = list_separated_toString_helper", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_separated_toString ?sep2 ?toStr2 ?ls2 =\n  list_separated_toString_helper ?sep2 ?toStr2 ?ls2\n\ngoal (1 subgoal):\n 1. list_separated_toString = list_separated_toString_helper", "by(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  list_separated_toString = list_separated_toString_helper\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_separated_toString_intersperse:\n  \"intersperse sep (map f xs) = list_separated_toString [sep] f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intersperse sep (map f xs) = list_separated_toString [sep] f xs", "apply(simp add: list_separated_toString_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. intersperse sep (map f xs) = list_separated_toString_helper [sep] f xs", "apply(induction \"[sep]\" f xs rule: list_separated_toString_helper.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>toStr.\n       intersperse sep (map toStr []) =\n       list_separated_toString_helper [sep] toStr []\n 2. \\<And>toStr l.\n       intersperse sep (map toStr [l]) =\n       list_separated_toString_helper [sep] toStr [l]\n 3. \\<And>toStr l v va.\n       intersperse sep (map toStr (v # va)) =\n       list_separated_toString_helper [sep] toStr (v # va) \\<Longrightarrow>\n       intersperse sep (map toStr (l # v # va)) =\n       list_separated_toString_helper [sep] toStr (l # v # va)", "by simp+"], ["", "definition list_toString :: \"('a \\<Rightarrow> string) \\<Rightarrow> 'a list \\<Rightarrow> string\" where\n  \"list_toString toStr ls = ''[''@ list_separated_toString '', '' toStr ls @'']''\""], ["", "lemma \"list_toString string_of_nat [1,2,3] = ''[1, 2, 3]''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_toString string_of_nat [1, 2, 3] = ''[1, 2, 3]''", "by eval"], ["", "end"]]}