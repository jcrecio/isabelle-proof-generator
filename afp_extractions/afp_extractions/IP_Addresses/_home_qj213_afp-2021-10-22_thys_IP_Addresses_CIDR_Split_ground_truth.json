{"file_name": "/home/qj213/afp-2021-10-22/thys/IP_Addresses/CIDR_Split.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IP_Addresses", "problem_names": ["lemma \"map (of_nat \\<circ> nat) [1 .. 4] = ([1, 2, 3, 4]:: 32 word list)\"", "lemma ipv4addr_upto: \"set (ipv4addr_upto i j) = {i .. j}\"", "lemma find_SomeD: \"find f x = Some y \\<Longrightarrow> f y \\<and> y \\<in> set x\"", "lemma \"pfxes TYPE(32) = map nat [0 .. 32]\"", "lemma wordinterval_CIDR_split1_innard_helper: fixes a::\"'a::len word\"\n  shows \"wordinterval_lowest_element r = Some a \\<Longrightarrow> \n  largest_contained_prefix a r \\<noteq> None\"", "lemma r_split1_not_none: fixes r:: \"'a::len wordinterval\"\n  shows \"\\<not> wordinterval_empty r \\<Longrightarrow> fst (wordinterval_CIDR_split1 r) \\<noteq> None\"", "lemma largest_contained_prefix_subset:\n  \"largest_contained_prefix a r = Some p \\<Longrightarrow> wordinterval_to_set (prefix_to_wordinterval p) \\<subseteq> wordinterval_to_set r\"", "lemma wordinterval_CIDR_split1_snd: \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow> u = wordinterval_setminus r (prefix_to_wordinterval s)\"", "lemma largest_contained_prefix_subset_s1D:\n  \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow> wordinterval_to_set (prefix_to_wordinterval s) \\<subseteq> wordinterval_to_set r\"", "theorem wordinterval_CIDR_split1_preserve: fixes r:: \"'a::len wordinterval\"\n  shows \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow> wordinterval_eq (wordinterval_union (prefix_to_wordinterval s) u) r\"", "lemma wordinterval_CIDR_split1_some_r_ne:\n  \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow> \\<not> wordinterval_empty r\"", "lemma wordinterval_CIDR_split1_distinct: fixes r:: \"'a::len wordinterval\"\n  shows \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n           wordinterval_empty (wordinterval_intersection (prefix_to_wordinterval s) u)\"", "lemma wordinterval_CIDR_split1_distinct2: fixes r:: \"'a::len wordinterval\"\n  shows \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n          wordinterval_empty (wordinterval_intersection (prefix_to_wordinterval s) u)\"", "lemma unfold_rsplit_case:\n  assumes su: \"(Some s, u) = wordinterval_CIDR_split1 rs\"\n  shows \"(case wordinterval_CIDR_split1 rs of (None, u) \\<Rightarrow> []\n                                            | (Some s, u) \\<Rightarrow> s # wordinterval_CIDR_split_prefixmatch u) = s # wordinterval_CIDR_split_prefixmatch u\"", "lemma \"wordinterval_CIDR_split_prefixmatch\n          (RangeUnion (WordInterval (0x40000000) 0x5FEFBBCC) (WordInterval 0x5FEEBB1C 0x7FFFFFFF))\n       = [PrefixMatch (0x40000000::32 word) 2]\"", "lemma \"length (wordinterval_CIDR_split_prefixmatch (WordInterval 0 (0xFFFFFFFE::32 word))) = 32\"", "theorem wordinterval_CIDR_split_prefixmatch:\n  \"wordinterval_to_set r = (\\<Union>x\\<in>set (wordinterval_CIDR_split_prefixmatch r). prefix_to_wordset x)\"", "lemma wordinterval_CIDR_split_prefixmatch_all_valid_Ball: fixes r:: \"'a::len wordinterval\"\n  shows \"\\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch r). valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\"", "lemma wordinterval_CIDR_split_prefixmatch_all_valid_less_Ball_hlp:\n\t\"x \\<in> set [s\\<leftarrow>map (PrefixMatch x2) (pfxes TYPE('a::len0)) . valid_prefix s \\<and> wordinterval_to_set (prefix_to_wordinterval s) \\<subseteq> wordinterval_to_set rs] \\<Longrightarrow> pfxm_length x \\<le> LENGTH('a)\"", "lemma \"valid_prefix (PrefixMatch (0::16 word) 20)\"", "lemma wordinterval_CIDR_split_disjunct: \"a \\<in> set (wordinterval_CIDR_split_prefixmatch i) \\<Longrightarrow>\n  b \\<in> set (wordinterval_CIDR_split_prefixmatch i) \\<Longrightarrow> a \\<noteq> b \\<Longrightarrow>\n  prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\"", "lemma wordinterval_CIDR_split_distinct: \"distinct (wordinterval_CIDR_split_prefixmatch i)\"", "lemma wordinterval_CIDR_split_existential:\n\t\"x \\<in> wordinterval_to_set w \\<Longrightarrow> \\<exists>s. s \\<in> set (wordinterval_CIDR_split_prefixmatch w) \\<and> x \\<in> prefix_to_wordset s\"", "lemma interval_in_splitD: \"xa \\<in> foo \\<Longrightarrow> prefix_to_wordset xa \\<subseteq> \\<Union>(prefix_to_wordset ` foo)\"", "lemma cidrsplit_no_overlaps: \"\\<lbrakk>\n        x \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n        xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi); \n        pt && ~~ (pfxm_mask x) = pfxm_prefix x;\n        pt && ~~ (pfxm_mask xa) = pfxm_prefix xa\n        \\<rbrakk>\n       \\<Longrightarrow> x = xa\""], "translations": [["", "lemma \"map (of_nat \\<circ> nat) [1 .. 4] = ([1, 2, 3, 4]:: 32 word list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (word_of_nat \\<circ> nat) [1..4] = [1, 2, 3, 4]", "by eval"], ["", "private"], ["", "definition ipv4addr_upto :: \"32 word \\<Rightarrow> 32 word \\<Rightarrow> 32 word list\" where\n    \"ipv4addr_upto i j \\<equiv> map (of_nat \\<circ> nat) [int (unat i) .. int (unat j)]\""], ["", "private"], ["", "lemma ipv4addr_upto: \"set (ipv4addr_upto i j) = {i .. j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ipv4addr_upto i j) = {i..j}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (ipv4addr_upto i j) = {i..j}", "have int_interval_eq_image: \"{int m..int n} = int ` {m..n}\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. {int m..int n} = int ` {m..n}", "by (auto intro!: image_eqI [of _ int \"nat k\" for k])"], ["proof (state)\nthis:\n  {int ?m..int ?n} = int ` {?m..?n}\n\ngoal (1 subgoal):\n 1. set (ipv4addr_upto i j) = {i..j}", "have helpX:\"\\<And>f (i::nat) (j::nat). (f \\<circ> nat) ` {int i..int j} = f ` {i .. j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f i j. (f \\<circ> nat) ` {int i..int j} = f ` {i..j}", "by (auto simp add: image_comp int_interval_eq_image)"], ["proof (state)\nthis:\n  (?f \\<circ> nat) ` {int ?i..int ?j} = ?f ` {?i..?j}\n\ngoal (1 subgoal):\n 1. set (ipv4addr_upto i j) = {i..j}", "have hlp: \\<open>i \\<le> word_of_nat (nat xa)\\<close> \\<open>word_of_nat (nat xa) \\<le> j\\<close>\n        if \\<open>uint i \\<le> xa\\<close> \\<open>xa \\<le> uint j\\<close> for xa :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> word_of_nat (nat xa) &&& word_of_nat (nat xa) \\<le> j", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> word_of_nat (nat xa)\n 2. word_of_nat (nat xa) \\<le> j", "from uint_nonnegative [of i] \\<open>uint i \\<le> xa\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> uint i\n  uint i \\<le> xa", "have \\<open>0 \\<le> xa\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> uint i\n  uint i \\<le> xa\n\ngoal (1 subgoal):\n 1. 0 \\<le> xa", "by (rule order_trans)"], ["proof (state)\nthis:\n  0 \\<le> xa\n\ngoal (2 subgoals):\n 1. i \\<le> word_of_nat (nat xa)\n 2. word_of_nat (nat xa) \\<le> j", "moreover"], ["proof (state)\nthis:\n  0 \\<le> xa\n\ngoal (2 subgoals):\n 1. i \\<le> word_of_nat (nat xa)\n 2. word_of_nat (nat xa) \\<le> j", "from \\<open>xa \\<le> uint j\\<close> uint_bounded [of j]"], ["proof (chain)\npicking this:\n  xa \\<le> uint j\n  uint j < 2 ^ LENGTH(32)", "have \\<open>xa < 2 ^ 32\\<close>"], ["proof (prove)\nusing this:\n  xa \\<le> uint j\n  uint j < 2 ^ LENGTH(32)\n\ngoal (1 subgoal):\n 1. xa < 2 ^ 32", "by simp"], ["proof (state)\nthis:\n  xa < 2 ^ 32\n\ngoal (2 subgoals):\n 1. i \\<le> word_of_nat (nat xa)\n 2. word_of_nat (nat xa) \\<le> j", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> xa\n  xa < 2 ^ 32", "have xa: \\<open>take_bit 32 xa = xa\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> xa\n  xa < 2 ^ 32\n\ngoal (1 subgoal):\n 1. take_bit 32 xa = xa", "by (simp add: take_bit_int_eq_self)"], ["proof (state)\nthis:\n  take_bit 32 xa = xa\n\ngoal (2 subgoals):\n 1. i \\<le> word_of_nat (nat xa)\n 2. word_of_nat (nat xa) \\<le> j", "from xa \\<open>uint i \\<le> xa\\<close>"], ["proof (chain)\npicking this:\n  take_bit 32 xa = xa\n  uint i \\<le> xa", "show \\<open>i \\<le> word_of_nat (nat xa)\\<close>"], ["proof (prove)\nusing this:\n  take_bit 32 xa = xa\n  uint i \\<le> xa\n\ngoal (1 subgoal):\n 1. i \\<le> word_of_nat (nat xa)", "by transfer simp"], ["proof (state)\nthis:\n  i \\<le> word_of_nat (nat xa)\n\ngoal (1 subgoal):\n 1. word_of_nat (nat xa) \\<le> j", "from xa \\<open>xa \\<le> uint j\\<close>"], ["proof (chain)\npicking this:\n  take_bit 32 xa = xa\n  xa \\<le> uint j", "show \\<open>word_of_nat (nat xa) \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  take_bit 32 xa = xa\n  xa \\<le> uint j\n\ngoal (1 subgoal):\n 1. word_of_nat (nat xa) \\<le> j", "by transfer simp"], ["proof (state)\nthis:\n  word_of_nat (nat xa) \\<le> j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>uint i \\<le> ?xa1; ?xa1 \\<le> uint j\\<rbrakk>\n  \\<Longrightarrow> i \\<le> word_of_nat (nat ?xa1)\n  \\<lbrakk>uint i \\<le> ?xa1; ?xa1 \\<le> uint j\\<rbrakk>\n  \\<Longrightarrow> word_of_nat (nat ?xa1) \\<le> j\n\ngoal (1 subgoal):\n 1. set (ipv4addr_upto i j) = {i..j}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ipv4addr_upto i j) = {i..j}", "unfolding ipv4addr_upto_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (word_of_nat \\<circ> nat) [int (unat i)..int (unat j)]) =\n    {i..j}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> set (map (word_of_nat \\<circ> nat)\n                      [int (unat i)..int (unat j)])) =\n       (x \\<in> {i..j})", "apply (auto simp add: hlp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> x; x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. word_of_nat (nat x)) `\n                                 {uint i..uint j}", "apply (metis (mono_tags) atLeastAtMost_iff image_iff unat_eq_nat_uint word_less_eq_iff_unsigned word_unat.Rep_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set (ipv4addr_upto i j) = {i..j}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The function @{const ipv4addr_upto} gives back a list of all the ips in the list.\n        This list can be pretty huge! In the following, we will use CIDR notation (e.g. 192.168.0.0/24)\n        to describe the list more compactly.\\<close>"], ["", "end"], ["", "section\\<open>CIDR Split\\<close>"], ["", "context\nbegin"], ["", "private"], ["", "lemma find_SomeD: \"find f x = Some y \\<Longrightarrow> f y \\<and> y \\<in> set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find f x = Some y \\<Longrightarrow> f y \\<and> y \\<in> set x", "by(induction x; simp split: if_splits)"], ["", "(*pfxes needs a dummy parameter. The first parameter is a dummy that we have the 'a::len0 type and\n  can refer to its length.*)\nprivate"], ["", "definition pfxes :: \"'a::len0 itself \\<Rightarrow> nat list\" where\n  \"pfxes _ = map nat [0..int(len_of TYPE ('a))]\""], ["", "private"], ["", "lemma \"pfxes TYPE(32) = map nat [0 .. 32]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfxes TYPE(32) = map nat [0..32]", "by eval"], ["", "private"], ["", "definition \"largest_contained_prefix (a::('a :: len) word) r = (\n  let cs = (map (\\<lambda>s. PrefixMatch a s) (pfxes TYPE('a)));\n      \\<comment> \\<open>anything that is a subset should also be a valid prefix. but try proving that.\\<close>\n      cfs = find (\\<lambda>s. valid_prefix s \\<and> wordinterval_subset (prefix_to_wordinterval s) r) cs in\n  cfs)\n\""], ["", "(* The joke is that it is always Some, given that a \\<in> r. *)"], ["", "text\\<open>Split off one prefix:\\<close>"], ["", "private"], ["", "definition wordinterval_CIDR_split1\n  :: \"'a::len wordinterval \\<Rightarrow> 'a prefix_match option \\<times> 'a wordinterval\" where\n  \"wordinterval_CIDR_split1 r \\<equiv> (\n   let ma = wordinterval_lowest_element r in\n   case ma of \n      None \\<Rightarrow> (None, r) |\n      Some a \\<Rightarrow> (case largest_contained_prefix a r of \n        None \\<Rightarrow> (None, r) |\n        Some m \\<Rightarrow> (Some m, wordinterval_setminus r (prefix_to_wordinterval m))))\""], ["", "private"], ["", "lemma wordinterval_CIDR_split1_innard_helper: fixes a::\"'a::len word\"\n  shows \"wordinterval_lowest_element r = Some a \\<Longrightarrow> \n  largest_contained_prefix a r \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some a \\<Longrightarrow>\n    largest_contained_prefix a r \\<noteq> None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some a \\<Longrightarrow>\n    largest_contained_prefix a r \\<noteq> None", "assume a: \"wordinterval_lowest_element r = Some a\""], ["proof (state)\nthis:\n  wordinterval_lowest_element r = Some a\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some a \\<Longrightarrow>\n    largest_contained_prefix a r \\<noteq> None", "have b: \"(a,len_of(TYPE('a))) \\<in> set (map (Pair a) (pfxes TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, LENGTH('a)) \\<in> set (map (Pair a) (pfxes TYPE('a)))", "unfolding pfxes_def set_map set_upto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, LENGTH('a)) \\<in> Pair a ` nat ` {0..int LENGTH('a)}", "using Set.image_iff atLeastAtMost_iff int_eq_iff order_refl"], ["proof (prove)\nusing this:\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  (?i \\<in> {?l..?u}) = (?l \\<le> ?i \\<and> ?i \\<le> ?u)\n  (int ?m = ?z) = (?m = nat ?z \\<and> 0 \\<le> ?z)\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. (a, LENGTH('a)) \\<in> Pair a ` nat ` {0..int LENGTH('a)}", "by metis"], ["proof (state)\nthis:\n  (a, LENGTH('a)) \\<in> set (map (Pair a) (pfxes TYPE('a)))\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some a \\<Longrightarrow>\n    largest_contained_prefix a r \\<noteq> None", "(*400ms*)"], ["proof (state)\nthis:\n  (a, LENGTH('a)) \\<in> set (map (Pair a) (pfxes TYPE('a)))\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some a \\<Longrightarrow>\n    largest_contained_prefix a r \\<noteq> None", "have c: \"valid_prefix (PrefixMatch a (len_of(TYPE('a))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix (PrefixMatch a LENGTH('a))", "by(simp add: valid_prefix_def pfxm_mask_def)"], ["proof (state)\nthis:\n  valid_prefix (PrefixMatch a LENGTH('a))\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some a \\<Longrightarrow>\n    largest_contained_prefix a r \\<noteq> None", "have \"wordinterval_to_set (prefix_to_wordinterval (PrefixMatch a (len_of(TYPE('a))))) = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (prefix_to_wordinterval (PrefixMatch a LENGTH('a))) =\n    {a}", "unfolding prefix_to_wordinterval_def pfxm_mask_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (WordInterval (pfxm_prefix (PrefixMatch a LENGTH('a)))\n       (pfxm_prefix (PrefixMatch a LENGTH('a)) ||\n        mask (LENGTH('a) - pfxm_length (PrefixMatch a LENGTH('a))))) =\n    {a}", "by simp"], ["proof (state)\nthis:\n  wordinterval_to_set (prefix_to_wordinterval (PrefixMatch a LENGTH('a))) =\n  {a}\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some a \\<Longrightarrow>\n    largest_contained_prefix a r \\<noteq> None", "moreover"], ["proof (state)\nthis:\n  wordinterval_to_set (prefix_to_wordinterval (PrefixMatch a LENGTH('a))) =\n  {a}\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some a \\<Longrightarrow>\n    largest_contained_prefix a r \\<noteq> None", "have \"a \\<in> wordinterval_to_set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> wordinterval_to_set r", "using a wordinterval_lowest_element_set_eq wordinterval_lowest_none_empty"], ["proof (prove)\nusing this:\n  wordinterval_lowest_element r = Some a\n  \\<not> wordinterval_empty ?r \\<Longrightarrow>\n  (wordinterval_lowest_element ?r = Some ?x) =\n  is_lowest_element ?x (wordinterval_to_set ?r)\n  (wordinterval_lowest_element ?r = None) = wordinterval_empty ?r\n\ngoal (1 subgoal):\n 1. a \\<in> wordinterval_to_set r", "by (metis is_lowest_element_def option.distinct(1))"], ["proof (state)\nthis:\n  a \\<in> wordinterval_to_set r\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some a \\<Longrightarrow>\n    largest_contained_prefix a r \\<noteq> None", "ultimately"], ["proof (chain)\npicking this:\n  wordinterval_to_set (prefix_to_wordinterval (PrefixMatch a LENGTH('a))) =\n  {a}\n  a \\<in> wordinterval_to_set r", "have d:\n    \"wordinterval_to_set (prefix_to_wordinterval (PrefixMatch a (LENGTH('a)))) \\<subseteq> wordinterval_to_set r\""], ["proof (prove)\nusing this:\n  wordinterval_to_set (prefix_to_wordinterval (PrefixMatch a LENGTH('a))) =\n  {a}\n  a \\<in> wordinterval_to_set r\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (prefix_to_wordinterval (PrefixMatch a LENGTH('a)))\n    \\<subseteq> wordinterval_to_set r", "by simp"], ["proof (state)\nthis:\n  wordinterval_to_set (prefix_to_wordinterval (PrefixMatch a LENGTH('a)))\n  \\<subseteq> wordinterval_to_set r\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some a \\<Longrightarrow>\n    largest_contained_prefix a r \\<noteq> None", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. largest_contained_prefix a r \\<noteq> None", "unfolding largest_contained_prefix_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. find\n     (\\<lambda>s.\n         valid_prefix s \\<and>\n         wordinterval_subset (prefix_to_wordinterval s) r)\n     (map (PrefixMatch a) (pfxes TYPE('a))) \\<noteq>\n    None", "using b c d"], ["proof (prove)\nusing this:\n  (a, LENGTH('a)) \\<in> set (map (Pair a) (pfxes TYPE('a)))\n  valid_prefix (PrefixMatch a LENGTH('a))\n  wordinterval_to_set (prefix_to_wordinterval (PrefixMatch a LENGTH('a)))\n  \\<subseteq> wordinterval_to_set r\n\ngoal (1 subgoal):\n 1. find\n     (\\<lambda>s.\n         valid_prefix s \\<and>\n         wordinterval_subset (prefix_to_wordinterval s) r)\n     (map (PrefixMatch a) (pfxes TYPE('a))) \\<noteq>\n    None", "by(auto simp add: find_None_iff)"], ["proof (state)\nthis:\n  largest_contained_prefix a r \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma r_split1_not_none: fixes r:: \"'a::len wordinterval\"\n  shows \"\\<not> wordinterval_empty r \\<Longrightarrow> fst (wordinterval_CIDR_split1 r) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty r \\<Longrightarrow>\n    fst (wordinterval_CIDR_split1 r) \\<noteq> None", "unfolding wordinterval_CIDR_split1_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty r \\<Longrightarrow>\n    fst (case wordinterval_lowest_element r of None \\<Rightarrow> (None, r)\n         | Some a \\<Rightarrow>\n             case largest_contained_prefix a r of\n             None \\<Rightarrow> (None, r)\n             | Some m \\<Rightarrow>\n                 (Some m,\n                  wordinterval_setminus r\n                   (prefix_to_wordinterval m))) \\<noteq>\n    None", "by(cases \"wordinterval_lowest_element r\")\n    (auto simp add: wordinterval_lowest_none_empty \n          dest: wordinterval_CIDR_split1_innard_helper)"], ["", "private"], ["", "lemma largest_contained_prefix_subset:\n  \"largest_contained_prefix a r = Some p \\<Longrightarrow> wordinterval_to_set (prefix_to_wordinterval p) \\<subseteq> wordinterval_to_set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. largest_contained_prefix a r = Some p \\<Longrightarrow>\n    wordinterval_to_set (prefix_to_wordinterval p)\n    \\<subseteq> wordinterval_to_set r", "unfolding largest_contained_prefix_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. find\n     (\\<lambda>s.\n         valid_prefix s \\<and>\n         wordinterval_subset (prefix_to_wordinterval s) r)\n     (map (PrefixMatch a) (pfxes TYPE('a))) =\n    Some p \\<Longrightarrow>\n    wordinterval_to_set (prefix_to_wordinterval p)\n    \\<subseteq> wordinterval_to_set r", "by(drule find_SomeD) simp"], ["", "private"], ["", "lemma wordinterval_CIDR_split1_snd: \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow> u = wordinterval_setminus r (prefix_to_wordinterval s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    u = wordinterval_setminus r (prefix_to_wordinterval s)", "unfolding wordinterval_CIDR_split1_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case wordinterval_lowest_element r of None \\<Rightarrow> (None, r)\n     | Some a \\<Rightarrow>\n         case largest_contained_prefix a r of None \\<Rightarrow> (None, r)\n         | Some m \\<Rightarrow>\n             (Some m, wordinterval_setminus r (prefix_to_wordinterval m))) =\n    (Some s, u) \\<Longrightarrow>\n    u = wordinterval_setminus r (prefix_to_wordinterval s)", "by(clarsimp split: option.splits)"], ["", "private"], ["", "lemma largest_contained_prefix_subset_s1D:\n  \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow> wordinterval_to_set (prefix_to_wordinterval s) \\<subseteq> wordinterval_to_set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    wordinterval_to_set (prefix_to_wordinterval s)\n    \\<subseteq> wordinterval_to_set r", "by(intro largest_contained_prefix_subset[where a = \"the (wordinterval_lowest_element r)\"])\n  (simp add: wordinterval_CIDR_split1_def split: option.splits)"], ["", "private"], ["", "theorem wordinterval_CIDR_split1_preserve: fixes r:: \"'a::len wordinterval\"\n  shows \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow> wordinterval_eq (wordinterval_union (prefix_to_wordinterval s) u) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    wordinterval_eq (wordinterval_union (prefix_to_wordinterval s) u) r", "proof(unfold wordinterval_eq_set_eq)"], ["proof (state)\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    wordinterval_to_set (wordinterval_union (prefix_to_wordinterval s) u) =\n    wordinterval_to_set r", "assume as: \"wordinterval_CIDR_split1 r = (Some s, u)\""], ["proof (state)\nthis:\n  wordinterval_CIDR_split1 r = (Some s, u)\n\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    wordinterval_to_set (wordinterval_union (prefix_to_wordinterval s) u) =\n    wordinterval_to_set r", "have ud: \"u = wordinterval_setminus r (prefix_to_wordinterval s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = wordinterval_setminus r (prefix_to_wordinterval s)", "using as[THEN wordinterval_CIDR_split1_snd]"], ["proof (prove)\nusing this:\n  u = wordinterval_setminus r (prefix_to_wordinterval s)\n\ngoal (1 subgoal):\n 1. u = wordinterval_setminus r (prefix_to_wordinterval s)", "."], ["proof (state)\nthis:\n  u = wordinterval_setminus r (prefix_to_wordinterval s)\n\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    wordinterval_to_set (wordinterval_union (prefix_to_wordinterval s) u) =\n    wordinterval_to_set r", "with largest_contained_prefix_subset_s1D[OF as]"], ["proof (chain)\npicking this:\n  wordinterval_to_set (prefix_to_wordinterval s)\n  \\<subseteq> wordinterval_to_set r\n  u = wordinterval_setminus r (prefix_to_wordinterval s)", "show \"wordinterval_to_set (wordinterval_union (prefix_to_wordinterval s) u) = wordinterval_to_set r\""], ["proof (prove)\nusing this:\n  wordinterval_to_set (prefix_to_wordinterval s)\n  \\<subseteq> wordinterval_to_set r\n  u = wordinterval_setminus r (prefix_to_wordinterval s)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (wordinterval_union (prefix_to_wordinterval s) u) =\n    wordinterval_to_set r", "unfolding ud"], ["proof (prove)\nusing this:\n  wordinterval_to_set (prefix_to_wordinterval s)\n  \\<subseteq> wordinterval_to_set r\n  wordinterval_setminus r (prefix_to_wordinterval s) =\n  wordinterval_setminus r (prefix_to_wordinterval s)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (wordinterval_union (prefix_to_wordinterval s)\n       (wordinterval_setminus r (prefix_to_wordinterval s))) =\n    wordinterval_to_set r", "by auto"], ["proof (state)\nthis:\n  wordinterval_to_set (wordinterval_union (prefix_to_wordinterval s) u) =\n  wordinterval_to_set r\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma wordinterval_CIDR_split1_some_r_ne:\n  \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow> \\<not> wordinterval_empty r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    \\<not> wordinterval_empty r", "proof(rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wordinterval_CIDR_split1 r = (Some s, u);\n     \\<not> \\<not> wordinterval_empty r\\<rbrakk>\n    \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  wordinterval_CIDR_split1 r = (Some s, u)\n  \\<not> \\<not> wordinterval_empty r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wordinterval_CIDR_split1 r = (Some s, u);\n     \\<not> \\<not> wordinterval_empty r\\<rbrakk>\n    \\<Longrightarrow> False", "have \"wordinterval_lowest_element r = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = None", "unfolding wordinterval_lowest_none_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_empty r", "using 1(2)"], ["proof (prove)\nusing this:\n  \\<not> \\<not> wordinterval_empty r\n\ngoal (1 subgoal):\n 1. wordinterval_empty r", "unfolding not_not"], ["proof (prove)\nusing this:\n  wordinterval_empty r\n\ngoal (1 subgoal):\n 1. wordinterval_empty r", "."], ["proof (state)\nthis:\n  wordinterval_lowest_element r = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wordinterval_CIDR_split1 r = (Some s, u);\n     \\<not> \\<not> wordinterval_empty r\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  wordinterval_lowest_element r = None", "have \"wordinterval_CIDR_split1 r = (None, r)\""], ["proof (prove)\nusing this:\n  wordinterval_lowest_element r = None\n\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (None, r)", "unfolding wordinterval_CIDR_split1_def Let_def"], ["proof (prove)\nusing this:\n  wordinterval_lowest_element r = None\n\ngoal (1 subgoal):\n 1. (case wordinterval_lowest_element r of None \\<Rightarrow> (None, r)\n     | Some a \\<Rightarrow>\n         case largest_contained_prefix a r of None \\<Rightarrow> (None, r)\n         | Some m \\<Rightarrow>\n             (Some m, wordinterval_setminus r (prefix_to_wordinterval m))) =\n    (None, r)", "by simp"], ["proof (state)\nthis:\n  wordinterval_CIDR_split1 r = (None, r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wordinterval_CIDR_split1 r = (Some s, u);\n     \\<not> \\<not> wordinterval_empty r\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  wordinterval_CIDR_split1 r = (None, r)", "show False"], ["proof (prove)\nusing this:\n  wordinterval_CIDR_split1 r = (None, r)\n\ngoal (1 subgoal):\n 1. False", "using 1(1)"], ["proof (prove)\nusing this:\n  wordinterval_CIDR_split1 r = (None, r)\n  wordinterval_CIDR_split1 r = (Some s, u)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma wordinterval_CIDR_split1_distinct: fixes r:: \"'a::len wordinterval\"\n  shows \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n           wordinterval_empty (wordinterval_intersection (prefix_to_wordinterval s) u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    wordinterval_empty\n     (wordinterval_intersection (prefix_to_wordinterval s) u)", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    wordinterval_empty\n     (wordinterval_intersection (prefix_to_wordinterval s) u)", "case 1"], ["proof (state)\nthis:\n  wordinterval_CIDR_split1 r = (Some s, u)\n\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    wordinterval_empty\n     (wordinterval_intersection (prefix_to_wordinterval s) u)", "have nn: \"wordinterval_lowest_element r \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r \\<noteq> None", "using wordinterval_CIDR_split1_some_r_ne 1 wordinterval_lowest_none_empty"], ["proof (prove)\nusing this:\n  wordinterval_CIDR_split1 ?r = (Some ?s, ?u) \\<Longrightarrow>\n  \\<not> wordinterval_empty ?r\n  wordinterval_CIDR_split1 r = (Some s, u)\n  (wordinterval_lowest_element ?r = None) = wordinterval_empty ?r\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r \\<noteq> None", "by metis"], ["proof (state)\nthis:\n  wordinterval_lowest_element r \\<noteq> None\n\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    wordinterval_empty\n     (wordinterval_intersection (prefix_to_wordinterval s) u)", "from 1"], ["proof (chain)\npicking this:\n  wordinterval_CIDR_split1 r = (Some s, u)", "have \"u = wordinterval_setminus r (prefix_to_wordinterval s)\""], ["proof (prove)\nusing this:\n  wordinterval_CIDR_split1 r = (Some s, u)\n\ngoal (1 subgoal):\n 1. u = wordinterval_setminus r (prefix_to_wordinterval s)", "by(elim wordinterval_CIDR_split1_snd)"], ["proof (state)\nthis:\n  u = wordinterval_setminus r (prefix_to_wordinterval s)\n\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    wordinterval_empty\n     (wordinterval_intersection (prefix_to_wordinterval s) u)", "then"], ["proof (chain)\npicking this:\n  u = wordinterval_setminus r (prefix_to_wordinterval s)", "show ?thesis"], ["proof (prove)\nusing this:\n  u = wordinterval_setminus r (prefix_to_wordinterval s)\n\ngoal (1 subgoal):\n 1. wordinterval_empty\n     (wordinterval_intersection (prefix_to_wordinterval s) u)", "by simp"], ["proof (state)\nthis:\n  wordinterval_empty\n   (wordinterval_intersection (prefix_to_wordinterval s) u)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma wordinterval_CIDR_split1_distinct2: fixes r:: \"'a::len wordinterval\"\n  shows \"wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n          wordinterval_empty (wordinterval_intersection (prefix_to_wordinterval s) u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split1 r = (Some s, u) \\<Longrightarrow>\n    wordinterval_empty\n     (wordinterval_intersection (prefix_to_wordinterval s) u)", "by(rule wordinterval_CIDR_split1_distinct[where r = r]) simp"], ["", "function wordinterval_CIDR_split_prefixmatch\n  :: \"'a::len wordinterval \\<Rightarrow> 'a prefix_match list\" where\n  \"wordinterval_CIDR_split_prefixmatch rs = (\n      if\n        \\<not> wordinterval_empty rs\n      then case wordinterval_CIDR_split1 rs\n                      of (Some s, u) \\<Rightarrow> s # wordinterval_CIDR_split_prefixmatch u\n                      |   _ \\<Rightarrow> []\n      else\n        []\n      )\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>rs. x = rs \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>rs rsa.\n       rs = rsa \\<Longrightarrow>\n       (if \\<not> wordinterval_empty rs\n        then case wordinterval_CIDR_split1 rs of (None, u) \\<Rightarrow> []\n             | (Some s, u) \\<Rightarrow>\n                 s # wordinterval_CIDR_split_prefixmatch_sumC u\n        else []) =\n       (if \\<not> wordinterval_empty rsa\n        then case wordinterval_CIDR_split1 rsa of (None, u) \\<Rightarrow> []\n             | (Some s, u) \\<Rightarrow>\n                 s # wordinterval_CIDR_split_prefixmatch_sumC u\n        else [])", "by pat_completeness simp"], ["", "termination wordinterval_CIDR_split_prefixmatch"], ["proof (prove)\ngoal (1 subgoal):\n 1. All wordinterval_CIDR_split_prefixmatch_dom", "proof(relation \"measure (card \\<circ> wordinterval_to_set)\", rule wf_measure, unfold in_measure comp_def, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs x y x2.\n       \\<lbrakk>\\<not> wordinterval_empty rs;\n        (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n       \\<Longrightarrow> card (wordinterval_to_set y)\n                         < card (wordinterval_to_set rs)", "note vernichter = wordinterval_empty_set_eq wordinterval_intersection_set_eq wordinterval_union_set_eq wordinterval_eq_set_eq"], ["proof (state)\nthis:\n  wordinterval_empty ?r = (wordinterval_to_set ?r = {})\n  wordinterval_to_set (wordinterval_intersection ?r1.0 ?r2.0) =\n  wordinterval_to_set ?r1.0 \\<inter> wordinterval_to_set ?r2.0\n  wordinterval_to_set (wordinterval_union ?r1.0 ?r2.0) =\n  wordinterval_to_set ?r1.0 \\<union> wordinterval_to_set ?r2.0\n  wordinterval_eq ?r1.0 ?r2.0 =\n  (wordinterval_to_set ?r1.0 = wordinterval_to_set ?r2.0)\n\ngoal (1 subgoal):\n 1. \\<And>rs x y x2.\n       \\<lbrakk>\\<not> wordinterval_empty rs;\n        (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n       \\<Longrightarrow> card (wordinterval_to_set y)\n                         < card (wordinterval_to_set rs)", "case (1 rs x y x2)"], ["proof (state)\nthis:\n  \\<not> wordinterval_empty rs\n  (x, y) = wordinterval_CIDR_split1 rs\n  x = Some x2\n\ngoal (1 subgoal):\n 1. \\<And>rs x y x2.\n       \\<lbrakk>\\<not> wordinterval_empty rs;\n        (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n       \\<Longrightarrow> card (wordinterval_to_set y)\n                         < card (wordinterval_to_set rs)", "note some = 1(2)[unfolded 1(3), symmetric]"], ["proof (state)\nthis:\n  wordinterval_CIDR_split1 rs = (Some x2, y)\n\ngoal (1 subgoal):\n 1. \\<And>rs x y x2.\n       \\<lbrakk>\\<not> wordinterval_empty rs;\n        (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n       \\<Longrightarrow> card (wordinterval_to_set y)\n                         < card (wordinterval_to_set rs)", "from prefix_never_empty"], ["proof (chain)\npicking this:\n  \\<not> wordinterval_empty (prefix_to_wordinterval ?d)", "have \"wordinterval_to_set (prefix_to_wordinterval x2) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> wordinterval_empty (prefix_to_wordinterval ?d)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (prefix_to_wordinterval x2) \\<noteq> {}", "unfolding vernichter"], ["proof (prove)\nusing this:\n  wordinterval_to_set (prefix_to_wordinterval ?d) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (prefix_to_wordinterval x2) \\<noteq> {}", "."], ["proof (state)\nthis:\n  wordinterval_to_set (prefix_to_wordinterval x2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>rs x y x2.\n       \\<lbrakk>\\<not> wordinterval_empty rs;\n        (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n       \\<Longrightarrow> card (wordinterval_to_set y)\n                         < card (wordinterval_to_set rs)", "thus ?case"], ["proof (prove)\nusing this:\n  wordinterval_to_set (prefix_to_wordinterval x2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (wordinterval_to_set y) < card (wordinterval_to_set rs)", "unfolding wordinterval_CIDR_split1_preserve[OF some, unfolded vernichter, symmetric]"], ["proof (prove)\nusing this:\n  wordinterval_to_set (prefix_to_wordinterval x2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (wordinterval_to_set y)\n    < card\n       (wordinterval_to_set (prefix_to_wordinterval x2) \\<union>\n        wordinterval_to_set y)", "unfolding card_Un_disjoint[OF finite finite wordinterval_CIDR_split1_distinct[OF some, unfolded vernichter]]"], ["proof (prove)\nusing this:\n  wordinterval_to_set (prefix_to_wordinterval x2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (wordinterval_to_set y)\n    < card (wordinterval_to_set (prefix_to_wordinterval x2)) +\n      card (wordinterval_to_set y)", "by auto"], ["proof (state)\nthis:\n  card (wordinterval_to_set y) < card (wordinterval_to_set rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma unfold_rsplit_case:\n  assumes su: \"(Some s, u) = wordinterval_CIDR_split1 rs\"\n  shows \"(case wordinterval_CIDR_split1 rs of (None, u) \\<Rightarrow> []\n                                            | (Some s, u) \\<Rightarrow> s # wordinterval_CIDR_split_prefixmatch u) = s # wordinterval_CIDR_split_prefixmatch u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case wordinterval_CIDR_split1 rs of (None, u) \\<Rightarrow> []\n     | (Some s, u) \\<Rightarrow>\n         s # wordinterval_CIDR_split_prefixmatch u) =\n    s # wordinterval_CIDR_split_prefixmatch u", "using su"], ["proof (prove)\nusing this:\n  (Some s, u) = wordinterval_CIDR_split1 rs\n\ngoal (1 subgoal):\n 1. (case wordinterval_CIDR_split1 rs of (None, u) \\<Rightarrow> []\n     | (Some s, u) \\<Rightarrow>\n         s # wordinterval_CIDR_split_prefixmatch u) =\n    s # wordinterval_CIDR_split_prefixmatch u", "by (metis option.simps(5) split_conv)"], ["", "lemma \"wordinterval_CIDR_split_prefixmatch\n          (RangeUnion (WordInterval (0x40000000) 0x5FEFBBCC) (WordInterval 0x5FEEBB1C 0x7FFFFFFF))\n       = [PrefixMatch (0x40000000::32 word) 2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split_prefixmatch\n     (RangeUnion (WordInterval 1073741824 1609546700)\n       (WordInterval 1609480988 2147483647)) =\n    [PrefixMatch 1073741824 2]", "by eval"], ["", "lemma \"length (wordinterval_CIDR_split_prefixmatch (WordInterval 0 (0xFFFFFFFE::32 word))) = 32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (wordinterval_CIDR_split_prefixmatch (WordInterval 0 4294967294)) =\n    32", "by eval"], ["", "declare wordinterval_CIDR_split_prefixmatch.simps[simp del]"], ["", "theorem wordinterval_CIDR_split_prefixmatch:\n  \"wordinterval_to_set r = (\\<Union>x\\<in>set (wordinterval_CIDR_split_prefixmatch r). prefix_to_wordset x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set r =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch r))", "proof(induction r rule: wordinterval_CIDR_split_prefixmatch.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs.\n       (\\<And>x y x2.\n           \\<lbrakk>\\<not> wordinterval_empty rs;\n            (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n           \\<Longrightarrow> wordinterval_to_set y =\n                             \\<Union>\n                              (prefix_to_wordset `\n                               set (wordinterval_CIDR_split_prefixmatch\n                                     y))) \\<Longrightarrow>\n       wordinterval_to_set rs =\n       \\<Union>\n        (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "case (1 rs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> wordinterval_empty rs;\n   (?x, ?y) = wordinterval_CIDR_split1 rs; ?x = Some ?x2.0\\<rbrakk>\n  \\<Longrightarrow> wordinterval_to_set ?y =\n                    \\<Union>\n                     (prefix_to_wordset `\n                      set (wordinterval_CIDR_split_prefixmatch ?y))\n\ngoal (1 subgoal):\n 1. \\<And>rs.\n       (\\<And>x y x2.\n           \\<lbrakk>\\<not> wordinterval_empty rs;\n            (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n           \\<Longrightarrow> wordinterval_to_set y =\n                             \\<Union>\n                              (prefix_to_wordset `\n                               set (wordinterval_CIDR_split_prefixmatch\n                                     y))) \\<Longrightarrow>\n       wordinterval_to_set rs =\n       \\<Union>\n        (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "proof(cases \"wordinterval_empty rs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "case True"], ["proof (state)\nthis:\n  wordinterval_empty rs\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  wordinterval_empty rs\n\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "by(simp add: wordinterval_CIDR_split_prefixmatch.simps)"], ["proof (state)\nthis:\n  wordinterval_to_set rs =\n  \\<Union>\n   (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "case False"], ["proof (state)\nthis:\n  \\<not> wordinterval_empty rs\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "obtain x y where s1: \"wordinterval_CIDR_split1 rs = (Some x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        wordinterval_CIDR_split1 rs = (Some x, y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using r_split1_not_none[OF False]"], ["proof (prove)\nusing this:\n  fst (wordinterval_CIDR_split1 rs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        wordinterval_CIDR_split1 rs = (Some x, y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: fst_def split: prod.splits)"], ["proof (state)\nthis:\n  wordinterval_CIDR_split1 rs = (Some x, y)\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "have mIH: \"wordinterval_to_set y = (\\<Union>x\\<in>set (wordinterval_CIDR_split_prefixmatch y). prefix_to_wordset x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set y =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch y))", "using 1[OF False s1[symmetric] refl]"], ["proof (prove)\nusing this:\n  wordinterval_to_set y =\n  \\<Union> (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch y))\n\ngoal (1 subgoal):\n 1. wordinterval_to_set y =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch y))", "."], ["proof (state)\nthis:\n  wordinterval_to_set y =\n  \\<Union> (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch y))\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "have *: \"wordinterval_to_set rs = prefix_to_wordset x \\<union> (\\<Union>x\\<in>set (wordinterval_CIDR_split_prefixmatch y). prefix_to_wordset x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    prefix_to_wordset x \\<union>\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch y))", "unfolding mIH[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    prefix_to_wordset x \\<union> wordinterval_to_set y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    prefix_to_wordset x \\<union> wordinterval_to_set y", "have ud: \"y = wordinterval_setminus rs (prefix_to_wordinterval x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = wordinterval_setminus rs (prefix_to_wordinterval x)", "using wordinterval_CIDR_split1_snd[OF s1]"], ["proof (prove)\nusing this:\n  y = wordinterval_setminus rs (prefix_to_wordinterval x)\n\ngoal (1 subgoal):\n 1. y = wordinterval_setminus rs (prefix_to_wordinterval x)", "."], ["proof (state)\nthis:\n  y = wordinterval_setminus rs (prefix_to_wordinterval x)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    prefix_to_wordset x \\<union> wordinterval_to_set y", "have ss: \"prefix_to_wordset x \\<subseteq> wordinterval_to_set rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset x \\<subseteq> wordinterval_to_set rs", "using largest_contained_prefix_subset_s1D[OF s1]"], ["proof (prove)\nusing this:\n  wordinterval_to_set (prefix_to_wordinterval x)\n  \\<subseteq> wordinterval_to_set rs\n\ngoal (1 subgoal):\n 1. prefix_to_wordset x \\<subseteq> wordinterval_to_set rs", "by simp"], ["proof (state)\nthis:\n  prefix_to_wordset x \\<subseteq> wordinterval_to_set rs\n\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    prefix_to_wordset x \\<union> wordinterval_to_set y", "show \"wordinterval_to_set rs = prefix_to_wordset x \\<union> wordinterval_to_set y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    prefix_to_wordset x \\<union> wordinterval_to_set y", "unfolding ud"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    prefix_to_wordset x \\<union>\n    wordinterval_to_set\n     (wordinterval_setminus rs (prefix_to_wordinterval x))", "using ss"], ["proof (prove)\nusing this:\n  prefix_to_wordset x \\<subseteq> wordinterval_to_set rs\n\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    prefix_to_wordset x \\<union>\n    wordinterval_to_set\n     (wordinterval_setminus rs (prefix_to_wordinterval x))", "by simp blast"], ["proof (state)\nthis:\n  wordinterval_to_set rs =\n  prefix_to_wordset x \\<union> wordinterval_to_set y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wordinterval_to_set rs =\n  prefix_to_wordset x \\<union>\n  \\<Union> (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch y))\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))", "apply(subst wordinterval_CIDR_split_prefixmatch.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set rs =\n    \\<Union>\n     (prefix_to_wordset `\n      set (if \\<not> wordinterval_empty rs\n           then case wordinterval_CIDR_split1 rs of\n                (None, u) \\<Rightarrow> []\n                | (Some s, u) \\<Rightarrow>\n                    s # wordinterval_CIDR_split_prefixmatch u\n           else []))", "apply(unfold if_P[OF False] s1 prod.simps option.simps *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset x \\<union>\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch y)) =\n    \\<Union>\n     (prefix_to_wordset ` set (x # wordinterval_CIDR_split_prefixmatch y))", "(* WOOOOO simplifier bug (* try making this a simp add: *) *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset x \\<union>\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch y)) =\n    \\<Union>\n     (prefix_to_wordset ` set (x # wordinterval_CIDR_split_prefixmatch y))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wordinterval_to_set rs =\n  \\<Union>\n   (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wordinterval_to_set rs =\n  \\<Union>\n   (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch rs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wordinterval_CIDR_split_prefixmatch_all_valid_Ball: fixes r:: \"'a::len wordinterval\"\n  shows \"\\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch r). valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch r).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "(* The induction is somewhat verbose, so it is less annoying to write the two down at once *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch r).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "proof(induction r rule: wordinterval_CIDR_split_prefixmatch.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs.\n       (\\<And>x y x2.\n           \\<lbrakk>\\<not> wordinterval_empty rs;\n            (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>e\n\\<in>set (wordinterval_CIDR_split_prefixmatch y).\n                                valid_prefix e \\<and>\n                                pfxm_length e\n                                \\<le> LENGTH('a)) \\<Longrightarrow>\n       \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n          valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "case 1"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> wordinterval_empty rs_;\n   (?x, ?y) = wordinterval_CIDR_split1 rs_; ?x = Some ?x2.0\\<rbrakk>\n  \\<Longrightarrow> \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch\n   ?y).\n                       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<And>rs.\n       (\\<And>x y x2.\n           \\<lbrakk>\\<not> wordinterval_empty rs;\n            (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>e\n\\<in>set (wordinterval_CIDR_split_prefixmatch y).\n                                valid_prefix e \\<and>\n                                pfxm_length e\n                                \\<le> LENGTH('a)) \\<Longrightarrow>\n       \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n          valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "case (1 rs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> wordinterval_empty rs;\n   (?x, ?y) = wordinterval_CIDR_split1 rs; ?x = Some ?x2.0\\<rbrakk>\n  \\<Longrightarrow> \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch\n   ?y).\n                       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<And>rs.\n       (\\<And>x y x2.\n           \\<lbrakk>\\<not> wordinterval_empty rs;\n            (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n           \\<Longrightarrow> \\<forall>e\n\\<in>set (wordinterval_CIDR_split_prefixmatch y).\n                                valid_prefix e \\<and>\n                                pfxm_length e\n                                \\<le> LENGTH('a)) \\<Longrightarrow>\n       \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n          valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "proof(cases \"wordinterval_empty rs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "case False"], ["proof (state)\nthis:\n  \\<not> wordinterval_empty rs\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "obtain x y where s1: \"wordinterval_CIDR_split1 rs = (Some x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        wordinterval_CIDR_split1 rs = (Some x, y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using r_split1_not_none[OF False]"], ["proof (prove)\nusing this:\n  fst (wordinterval_CIDR_split1 rs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        wordinterval_CIDR_split1 rs = (Some x, y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: fst_def split: prod.splits)"], ["proof (state)\nthis:\n  wordinterval_CIDR_split1 rs = (Some x, y)\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "hence i1: \"valid_prefix x\""], ["proof (prove)\nusing this:\n  wordinterval_CIDR_split1 rs = (Some x, y)\n\ngoal (1 subgoal):\n 1. valid_prefix x", "unfolding wordinterval_CIDR_split1_def Let_def largest_contained_prefix_def"], ["proof (prove)\nusing this:\n  (case wordinterval_lowest_element rs of None \\<Rightarrow> (None, rs)\n   | Some a \\<Rightarrow>\n       case find\n             (\\<lambda>s.\n                 valid_prefix s \\<and>\n                 wordinterval_subset (prefix_to_wordinterval s) rs)\n             (map (PrefixMatch a) (pfxes TYPE('a))) of\n       None \\<Rightarrow> (None, rs)\n       | Some m \\<Rightarrow>\n           (Some m, wordinterval_setminus rs (prefix_to_wordinterval m))) =\n  (Some x, y)\n\ngoal (1 subgoal):\n 1. valid_prefix x", "by(auto dest: find_SomeD split: option.splits)"], ["proof (state)\nthis:\n  valid_prefix x\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "have i2: \"pfxm_length x \\<le> LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfxm_length x \\<le> LENGTH('a)", "using s1"], ["proof (prove)\nusing this:\n  wordinterval_CIDR_split1 rs = (Some x, y)\n\ngoal (1 subgoal):\n 1. pfxm_length x \\<le> LENGTH('a)", "unfolding wordinterval_CIDR_split1_def Let_def largest_contained_prefix_def pfxes_def"], ["proof (prove)\nusing this:\n  (case wordinterval_lowest_element rs of None \\<Rightarrow> (None, rs)\n   | Some a \\<Rightarrow>\n       case find\n             (\\<lambda>s.\n                 valid_prefix s \\<and>\n                 wordinterval_subset (prefix_to_wordinterval s) rs)\n             (map (PrefixMatch a) (map nat [0..int LENGTH('a)])) of\n       None \\<Rightarrow> (None, rs)\n       | Some m \\<Rightarrow>\n           (Some m, wordinterval_setminus rs (prefix_to_wordinterval m))) =\n  (Some x, y)\n\ngoal (1 subgoal):\n 1. pfxm_length x \\<le> LENGTH('a)", "by(force split: option.splits dest: find_SomeD simp: nat_le_iff)"], ["proof (state)\nthis:\n  pfxm_length x \\<le> LENGTH('a)\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "have mIH: \"\\<forall>a\\<in>set (wordinterval_CIDR_split_prefixmatch y). valid_prefix a \\<and> pfxm_length a \\<le> LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (wordinterval_CIDR_split_prefixmatch y).\n       valid_prefix a \\<and> pfxm_length a \\<le> LENGTH('a)", "using 1[OF False s1[symmetric] refl]"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch y).\n     valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (wordinterval_CIDR_split_prefixmatch y).\n       valid_prefix a \\<and> pfxm_length a \\<le> LENGTH('a)", "."], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (wordinterval_CIDR_split_prefixmatch y).\n     valid_prefix a \\<and> pfxm_length a \\<le> LENGTH('a)\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "with i1 i2"], ["proof (chain)\npicking this:\n  valid_prefix x\n  pfxm_length x \\<le> LENGTH('a)\n  \\<forall>a\\<in>set (wordinterval_CIDR_split_prefixmatch y).\n     valid_prefix a \\<and> pfxm_length a \\<le> LENGTH('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_prefix x\n  pfxm_length x \\<le> LENGTH('a)\n  \\<forall>a\\<in>set (wordinterval_CIDR_split_prefixmatch y).\n     valid_prefix a \\<and> pfxm_length a \\<le> LENGTH('a)\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "apply(subst wordinterval_CIDR_split_prefixmatch.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefix x; pfxm_length x \\<le> LENGTH('a);\n     \\<forall>a\\<in>set (wordinterval_CIDR_split_prefixmatch y).\n        valid_prefix a \\<and> pfxm_length a \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>e\\<in>set\n(if \\<not> wordinterval_empty rs\n then case wordinterval_CIDR_split1 rs of (None, u) \\<Rightarrow> []\n      | (Some s, u) \\<Rightarrow> s # wordinterval_CIDR_split_prefixmatch u\n else []).\n                         valid_prefix e \\<and>\n                         pfxm_length e \\<le> LENGTH('a)", "apply(unfold if_P[OF False] s1 prod.simps option.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefix x; pfxm_length x \\<le> LENGTH('a);\n     \\<forall>a\\<in>set (wordinterval_CIDR_split_prefixmatch y).\n        valid_prefix a \\<and> pfxm_length a \\<le> LENGTH('a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>e\\<in>set\n(x # wordinterval_CIDR_split_prefixmatch y).\n                         valid_prefix e \\<and>\n                         pfxm_length e \\<le> LENGTH('a)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n     valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\n\ngoal (1 subgoal):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n       valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)", "qed (simp add: wordinterval_CIDR_split_prefixmatch.simps)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch rs).\n     valid_prefix e \\<and> pfxm_length e \\<le> LENGTH('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma wordinterval_CIDR_split_prefixmatch_all_valid_less_Ball_hlp:\n\t\"x \\<in> set [s\\<leftarrow>map (PrefixMatch x2) (pfxes TYPE('a::len0)) . valid_prefix s \\<and> wordinterval_to_set (prefix_to_wordinterval s) \\<subseteq> wordinterval_to_set rs] \\<Longrightarrow> pfxm_length x \\<le> LENGTH('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (filter\n                  (\\<lambda>s.\n                      valid_prefix s \\<and>\n                      wordinterval_to_set (prefix_to_wordinterval s)\n                      \\<subseteq> wordinterval_to_set rs)\n                  (map (PrefixMatch x2) (pfxes TYPE('a)))) \\<Longrightarrow>\n    pfxm_length x \\<le> LENGTH('a)", "by(clarsimp simp: pfxes_def) presburger"], ["", "text\\<open>Since @{const wordinterval_CIDR_split_prefixmatch} only returns valid prefixes, we can safely convert it to CIDR lists\\<close>"], ["", "(* actually, just valid_prefix doesn't mean that the prefix length is sane. Fortunately, wordinterval_CIDR_split_prefixmatch_all_valid_Ball does entail that *)"], ["", "lemma \"valid_prefix (PrefixMatch (0::16 word) 20)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix (PrefixMatch 0 20)", "by(simp add: valid_prefix_def)"], ["", "lemma wordinterval_CIDR_split_disjunct: \"a \\<in> set (wordinterval_CIDR_split_prefixmatch i) \\<Longrightarrow>\n  b \\<in> set (wordinterval_CIDR_split_prefixmatch i) \\<Longrightarrow> a \\<noteq> b \\<Longrightarrow>\n  prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set (wordinterval_CIDR_split_prefixmatch i);\n     b \\<in> set (wordinterval_CIDR_split_prefixmatch i);\n     a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "proof(induction i rule: wordinterval_CIDR_split_prefixmatch.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs.\n       \\<lbrakk>\\<And>x y x2.\n                   \\<lbrakk>\\<not> wordinterval_empty rs;\n                    (x, y) = wordinterval_CIDR_split1 rs; x = Some x2;\n                    a \\<in> set (wordinterval_CIDR_split_prefixmatch y);\n                    b \\<in> set (wordinterval_CIDR_split_prefixmatch y);\n                    a \\<noteq> b\\<rbrakk>\n                   \\<Longrightarrow> prefix_to_wordset a \\<inter>\n                                     prefix_to_wordset b =\n                                     {};\n        a \\<in> set (wordinterval_CIDR_split_prefixmatch rs);\n        b \\<in> set (wordinterval_CIDR_split_prefixmatch rs);\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b =\n                         {}", "case (1 rs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> wordinterval_empty rs;\n   (?x, ?y) = wordinterval_CIDR_split1 rs; ?x = Some ?x2.0;\n   a \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   b \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n  a \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  b \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>rs.\n       \\<lbrakk>\\<And>x y x2.\n                   \\<lbrakk>\\<not> wordinterval_empty rs;\n                    (x, y) = wordinterval_CIDR_split1 rs; x = Some x2;\n                    a \\<in> set (wordinterval_CIDR_split_prefixmatch y);\n                    b \\<in> set (wordinterval_CIDR_split_prefixmatch y);\n                    a \\<noteq> b\\<rbrakk>\n                   \\<Longrightarrow> prefix_to_wordset a \\<inter>\n                                     prefix_to_wordset b =\n                                     {};\n        a \\<in> set (wordinterval_CIDR_split_prefixmatch rs);\n        b \\<in> set (wordinterval_CIDR_split_prefixmatch rs);\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b =\n                         {}", "note IH = 1(1)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> wordinterval_empty rs;\n   (?x, ?y) = wordinterval_CIDR_split1 rs; ?x = Some ?x2.0;\n   a \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   b \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n\ngoal (1 subgoal):\n 1. \\<And>rs.\n       \\<lbrakk>\\<And>x y x2.\n                   \\<lbrakk>\\<not> wordinterval_empty rs;\n                    (x, y) = wordinterval_CIDR_split1 rs; x = Some x2;\n                    a \\<in> set (wordinterval_CIDR_split_prefixmatch y);\n                    b \\<in> set (wordinterval_CIDR_split_prefixmatch y);\n                    a \\<noteq> b\\<rbrakk>\n                   \\<Longrightarrow> prefix_to_wordset a \\<inter>\n                                     prefix_to_wordset b =\n                                     {};\n        a \\<in> set (wordinterval_CIDR_split_prefixmatch rs);\n        b \\<in> set (wordinterval_CIDR_split_prefixmatch rs);\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b =\n                         {}", "have prema: \"a \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\" (is \"a \\<in> ?os\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (wordinterval_CIDR_split_prefixmatch rs)", "using 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> wordinterval_empty rs;\n   (?x, ?y) = wordinterval_CIDR_split1 rs; ?x = Some ?x2.0;\n   a \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   b \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n  a \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  b \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<in> set (wordinterval_CIDR_split_prefixmatch rs)", "by simp"], ["proof (state)\nthis:\n  a \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n\ngoal (1 subgoal):\n 1. \\<And>rs.\n       \\<lbrakk>\\<And>x y x2.\n                   \\<lbrakk>\\<not> wordinterval_empty rs;\n                    (x, y) = wordinterval_CIDR_split1 rs; x = Some x2;\n                    a \\<in> set (wordinterval_CIDR_split_prefixmatch y);\n                    b \\<in> set (wordinterval_CIDR_split_prefixmatch y);\n                    a \\<noteq> b\\<rbrakk>\n                   \\<Longrightarrow> prefix_to_wordset a \\<inter>\n                                     prefix_to_wordset b =\n                                     {};\n        a \\<in> set (wordinterval_CIDR_split_prefixmatch rs);\n        b \\<in> set (wordinterval_CIDR_split_prefixmatch rs);\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b =\n                         {}", "have premb: \"b \\<in> ?os\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> set (wordinterval_CIDR_split_prefixmatch rs)", "using 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> wordinterval_empty rs;\n   (?x, ?y) = wordinterval_CIDR_split1 rs; ?x = Some ?x2.0;\n   a \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   b \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n  a \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  b \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. b \\<in> set (wordinterval_CIDR_split_prefixmatch rs)", "by simp"], ["proof (state)\nthis:\n  b \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n\ngoal (1 subgoal):\n 1. \\<And>rs.\n       \\<lbrakk>\\<And>x y x2.\n                   \\<lbrakk>\\<not> wordinterval_empty rs;\n                    (x, y) = wordinterval_CIDR_split1 rs; x = Some x2;\n                    a \\<in> set (wordinterval_CIDR_split_prefixmatch y);\n                    b \\<in> set (wordinterval_CIDR_split_prefixmatch y);\n                    a \\<noteq> b\\<rbrakk>\n                   \\<Longrightarrow> prefix_to_wordset a \\<inter>\n                                     prefix_to_wordset b =\n                                     {};\n        a \\<in> set (wordinterval_CIDR_split_prefixmatch rs);\n        b \\<in> set (wordinterval_CIDR_split_prefixmatch rs);\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b =\n                         {}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "proof(cases \"wordinterval_empty rs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "case False"], ["proof (state)\nthis:\n  \\<not> wordinterval_empty rs\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "obtain x y where s1: \"wordinterval_CIDR_split1 rs = (Some x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        wordinterval_CIDR_split1 rs = (Some x, y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using r_split1_not_none[OF False]"], ["proof (prove)\nusing this:\n  fst (wordinterval_CIDR_split1 rs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        wordinterval_CIDR_split1 rs = (Some x, y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: fst_def split: prod.splits)"], ["proof (state)\nthis:\n  wordinterval_CIDR_split1 rs = (Some x, y)\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "have mi: \"k \\<in> set (wordinterval_CIDR_split_prefixmatch y)\" (is \"k \\<in> ?rs\") \n      if p: \"k \\<noteq> x\" \"k \\<in> ?os\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> set (wordinterval_CIDR_split_prefixmatch y)", "using p s1"], ["proof (prove)\nusing this:\n  k \\<noteq> x\n  k \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  wordinterval_CIDR_split1 rs = (Some x, y)\n\ngoal (1 subgoal):\n 1. k \\<in> set (wordinterval_CIDR_split_prefixmatch y)", "by(subst (asm) wordinterval_CIDR_split_prefixmatch.simps) (simp only: if_P[OF False] split: prod.splits option.splits; simp)"], ["proof (state)\nthis:\n  \\<lbrakk>?k \\<noteq> x;\n   ?k \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\\<rbrakk>\n  \\<Longrightarrow> ?k \\<in> set (wordinterval_CIDR_split_prefixmatch y)\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "have a: \"k \\<in> ?rs \\<Longrightarrow> prefix_to_wordset k \\<subseteq> wordinterval_to_set y\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> set (wordinterval_CIDR_split_prefixmatch y) \\<Longrightarrow>\n    prefix_to_wordset k \\<subseteq> wordinterval_to_set y", "(* this is actually a quite general statement, might make a lemma out of it *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> set (wordinterval_CIDR_split_prefixmatch y) \\<Longrightarrow>\n    prefix_to_wordset k \\<subseteq> wordinterval_to_set y", "unfolding wordinterval_CIDR_split_prefixmatch"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> set (wordinterval_CIDR_split_prefixmatch y) \\<Longrightarrow>\n    prefix_to_wordset k\n    \\<subseteq> \\<Union>\n                 (prefix_to_wordset `\n                  set (wordinterval_CIDR_split_prefixmatch y))", "by blast"], ["proof (state)\nthis:\n  ?k \\<in> set (wordinterval_CIDR_split_prefixmatch y) \\<Longrightarrow>\n  prefix_to_wordset ?k \\<subseteq> wordinterval_to_set y\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "have b: \"prefix_to_wordset x \\<inter> wordinterval_to_set y = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset x \\<inter> wordinterval_to_set y = {}", "using wordinterval_CIDR_split1_snd[OF s1]"], ["proof (prove)\nusing this:\n  y = wordinterval_setminus rs (prefix_to_wordinterval x)\n\ngoal (1 subgoal):\n 1. prefix_to_wordset x \\<inter> wordinterval_to_set y = {}", "by simp"], ["proof (state)\nthis:\n  prefix_to_wordset x \\<inter> wordinterval_to_set y = {}\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "proof(cases \"a = x\"; cases \"b = x\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<lbrakk>a = x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 3. \\<lbrakk>a \\<noteq> x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 4. \\<lbrakk>a \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "assume as: \"a = x\" \"b \\<noteq> x\""], ["proof (state)\nthis:\n  a = x\n  b \\<noteq> x\n\ngoal (4 subgoals):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<lbrakk>a = x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 3. \\<lbrakk>a \\<noteq> x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 4. \\<lbrakk>a \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "with a[OF mi[OF as(2) premb]] b"], ["proof (chain)\npicking this:\n  prefix_to_wordset b \\<subseteq> wordinterval_to_set y\n  prefix_to_wordset x \\<inter> wordinterval_to_set y = {}\n  a = x\n  b \\<noteq> x", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix_to_wordset b \\<subseteq> wordinterval_to_set y\n  prefix_to_wordset x \\<inter> wordinterval_to_set y = {}\n  a = x\n  b \\<noteq> x\n\ngoal (1 subgoal):\n 1. prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "by blast"], ["proof (state)\nthis:\n  prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<lbrakk>a \\<noteq> x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 3. \\<lbrakk>a \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<lbrakk>a \\<noteq> x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 3. \\<lbrakk>a \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "assume as: \"a \\<noteq> x\" \"b = x\""], ["proof (state)\nthis:\n  a \\<noteq> x\n  b = x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<lbrakk>a \\<noteq> x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 3. \\<lbrakk>a \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "with a[OF mi[OF as(1) prema]] b"], ["proof (chain)\npicking this:\n  prefix_to_wordset a \\<subseteq> wordinterval_to_set y\n  prefix_to_wordset x \\<inter> wordinterval_to_set y = {}\n  a \\<noteq> x\n  b = x", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix_to_wordset a \\<subseteq> wordinterval_to_set y\n  prefix_to_wordset x \\<inter> wordinterval_to_set y = {}\n  a \\<noteq> x\n  b = x\n\ngoal (1 subgoal):\n 1. prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "by blast"], ["proof (state)\nthis:\n  prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<lbrakk>a \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<lbrakk>a \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "assume as: \"a \\<noteq> x\" \"b \\<noteq> x\""], ["proof (state)\nthis:\n  a \\<noteq> x\n  b \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<lbrakk>a \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "(* Nothing to do case *)"], ["proof (state)\nthis:\n  a \\<noteq> x\n  b \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<lbrakk>a \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "have i: \"a \\<in> ?rs\" \"b \\<in> ?rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (wordinterval_CIDR_split_prefixmatch y) &&&\n    b \\<in> set (wordinterval_CIDR_split_prefixmatch y)", "using as mi prema premb"], ["proof (prove)\nusing this:\n  a \\<noteq> x\n  b \\<noteq> x\n  \\<lbrakk>?k \\<noteq> x;\n   ?k \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\\<rbrakk>\n  \\<Longrightarrow> ?k \\<in> set (wordinterval_CIDR_split_prefixmatch y)\n  a \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  b \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n\ngoal (1 subgoal):\n 1. a \\<in> set (wordinterval_CIDR_split_prefixmatch y) &&&\n    b \\<in> set (wordinterval_CIDR_split_prefixmatch y)", "by blast+"], ["proof (state)\nthis:\n  a \\<in> set (wordinterval_CIDR_split_prefixmatch y)\n  b \\<in> set (wordinterval_CIDR_split_prefixmatch y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n 2. \\<lbrakk>a \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "show \"prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "by(rule IH[OF False s1[symmetric] refl i]) (fact 1)"], ["proof (state)\nthis:\n  prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "assume as: \"a = x\" \"b = x\""], ["proof (state)\nthis:\n  a = x\n  b = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "(* impossible case *)"], ["proof (state)\nthis:\n  a = x\n  b = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> wordinterval_empty rs;\n   (?x, ?y) = wordinterval_CIDR_split1 rs; ?x = Some ?x2.0;\n   a \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   b \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n  a \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  b \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  a \\<noteq> b\n  a = x\n  b = x", "have False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> wordinterval_empty rs;\n   (?x, ?y) = wordinterval_CIDR_split1 rs; ?x = Some ?x2.0;\n   a \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   b \\<in> set (wordinterval_CIDR_split_prefixmatch ?y);\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n  a \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  b \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n  a \\<noteq> b\n  a = x\n  b = x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = x; b = x\\<rbrakk>\n    \\<Longrightarrow> prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", ".."], ["proof (state)\nthis:\n  prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n\ngoal (1 subgoal):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "case True"], ["proof (state)\nthis:\n  wordinterval_empty rs\n\ngoal (1 subgoal):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "hence \"wordinterval_CIDR_split_prefixmatch rs = []\""], ["proof (prove)\nusing this:\n  wordinterval_empty rs\n\ngoal (1 subgoal):\n 1. wordinterval_CIDR_split_prefixmatch rs = []", "by(simp add: wordinterval_CIDR_split_prefixmatch.simps)"], ["proof (state)\nthis:\n  wordinterval_CIDR_split_prefixmatch rs = []\n\ngoal (1 subgoal):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  wordinterval_CIDR_split_prefixmatch rs = []\n\ngoal (1 subgoal):\n 1. prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "using prema"], ["proof (prove)\nusing this:\n  wordinterval_CIDR_split_prefixmatch rs = []\n  a \\<in> set (wordinterval_CIDR_split_prefixmatch rs)\n\ngoal (1 subgoal):\n 1. prefix_to_wordset a \\<inter> prefix_to_wordset b = {}", "by simp"], ["proof (state)\nthis:\n  prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefix_to_wordset a \\<inter> prefix_to_wordset b = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wordinterval_CIDR_split_distinct: \"distinct (wordinterval_CIDR_split_prefixmatch i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (wordinterval_CIDR_split_prefixmatch i)", "(* wish this was a corollary *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (wordinterval_CIDR_split_prefixmatch i)", "proof(induction i rule: wordinterval_CIDR_split_prefixmatch.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs.\n       (\\<And>x y x2.\n           \\<lbrakk>\\<not> wordinterval_empty rs;\n            (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n           \\<Longrightarrow> distinct\n                              (wordinterval_CIDR_split_prefixmatch\n                                y)) \\<Longrightarrow>\n       distinct (wordinterval_CIDR_split_prefixmatch rs)", "case (1 rs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> wordinterval_empty rs;\n   (?x, ?y) = wordinterval_CIDR_split1 rs; ?x = Some ?x2.0\\<rbrakk>\n  \\<Longrightarrow> distinct (wordinterval_CIDR_split_prefixmatch ?y)\n\ngoal (1 subgoal):\n 1. \\<And>rs.\n       (\\<And>x y x2.\n           \\<lbrakk>\\<not> wordinterval_empty rs;\n            (x, y) = wordinterval_CIDR_split1 rs; x = Some x2\\<rbrakk>\n           \\<Longrightarrow> distinct\n                              (wordinterval_CIDR_split_prefixmatch\n                                y)) \\<Longrightarrow>\n       distinct (wordinterval_CIDR_split_prefixmatch rs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (wordinterval_CIDR_split_prefixmatch rs)", "proof(cases \"wordinterval_empty rs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)", "case False"], ["proof (state)\nthis:\n  \\<not> wordinterval_empty rs\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)", "obtain x y where s1: \"wordinterval_CIDR_split1 rs = (Some x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        wordinterval_CIDR_split1 rs = (Some x, y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using r_split1_not_none[OF False]"], ["proof (prove)\nusing this:\n  fst (wordinterval_CIDR_split1 rs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        wordinterval_CIDR_split1 rs = (Some x, y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: fst_def split: prod.splits)"], ["proof (state)\nthis:\n  wordinterval_CIDR_split1 rs = (Some x, y)\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)", "have mIH: \"distinct (wordinterval_CIDR_split_prefixmatch y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (wordinterval_CIDR_split_prefixmatch y)", "using 1[OF False s1[symmetric] refl]"], ["proof (prove)\nusing this:\n  distinct (wordinterval_CIDR_split_prefixmatch y)\n\ngoal (1 subgoal):\n 1. distinct (wordinterval_CIDR_split_prefixmatch y)", "."], ["proof (state)\nthis:\n  distinct (wordinterval_CIDR_split_prefixmatch y)\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)", "have \"prefix_to_wordset x \\<inter> wordinterval_to_set y = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset x \\<inter> wordinterval_to_set y = {}", "using wordinterval_CIDR_split1_snd[OF s1]"], ["proof (prove)\nusing this:\n  y = wordinterval_setminus rs (prefix_to_wordinterval x)\n\ngoal (1 subgoal):\n 1. prefix_to_wordset x \\<inter> wordinterval_to_set y = {}", "by simp"], ["proof (state)\nthis:\n  prefix_to_wordset x \\<inter> wordinterval_to_set y = {}\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)", "hence i1: \"x \\<notin> set (wordinterval_CIDR_split_prefixmatch y)\""], ["proof (prove)\nusing this:\n  prefix_to_wordset x \\<inter> wordinterval_to_set y = {}\n\ngoal (1 subgoal):\n 1. x \\<notin> set (wordinterval_CIDR_split_prefixmatch y)", "unfolding wordinterval_CIDR_split_prefixmatch"], ["proof (prove)\nusing this:\n  prefix_to_wordset x \\<inter>\n  \\<Union>\n   (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch y)) =\n  {}\n\ngoal (1 subgoal):\n 1. x \\<notin> set (wordinterval_CIDR_split_prefixmatch y)", "using prefix_never_empty[of x, simplified]"], ["proof (prove)\nusing this:\n  prefix_to_wordset x \\<inter>\n  \\<Union>\n   (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch y)) =\n  {}\n  prefix_to_wordset x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x \\<notin> set (wordinterval_CIDR_split_prefixmatch y)", "by blast"], ["proof (state)\nthis:\n  x \\<notin> set (wordinterval_CIDR_split_prefixmatch y)\n\ngoal (2 subgoals):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)\n 2. \\<not> wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (wordinterval_CIDR_split_prefixmatch rs)", "using s1"], ["proof (prove)\nusing this:\n  wordinterval_CIDR_split1 rs = (Some x, y)\n\ngoal (1 subgoal):\n 1. distinct (wordinterval_CIDR_split_prefixmatch rs)", "by(subst wordinterval_CIDR_split_prefixmatch.simps)\n        (simp add: if_P[OF False] mIH i1 split: option.splits prod.splits)"], ["proof (state)\nthis:\n  distinct (wordinterval_CIDR_split_prefixmatch rs)\n\ngoal (1 subgoal):\n 1. wordinterval_empty rs \\<Longrightarrow>\n    distinct (wordinterval_CIDR_split_prefixmatch rs)", "qed (simp add: wordinterval_CIDR_split_prefixmatch.simps)"], ["proof (state)\nthis:\n  distinct (wordinterval_CIDR_split_prefixmatch rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wordinterval_CIDR_split_existential:\n\t\"x \\<in> wordinterval_to_set w \\<Longrightarrow> \\<exists>s. s \\<in> set (wordinterval_CIDR_split_prefixmatch w) \\<and> x \\<in> prefix_to_wordset s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> wordinterval_to_set w \\<Longrightarrow>\n    \\<exists>s.\n       s \\<in> set (wordinterval_CIDR_split_prefixmatch w) \\<and>\n       x \\<in> prefix_to_wordset s", "using wordinterval_CIDR_split_prefixmatch[symmetric]"], ["proof (prove)\nusing this:\n  \\<Union>\n   (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch ?r)) =\n  wordinterval_to_set ?r\n\ngoal (1 subgoal):\n 1. x \\<in> wordinterval_to_set w \\<Longrightarrow>\n    \\<exists>s.\n       s \\<in> set (wordinterval_CIDR_split_prefixmatch w) \\<and>\n       x \\<in> prefix_to_wordset s", "by fastforce"], ["", "subsection\\<open>Versions for @{const ipset_from_cidr}\\<close>"], ["", "definition cidr_split :: \"'i::len wordinterval \\<Rightarrow> ('i word \\<times> nat) list\" where\n  \"cidr_split rs \\<equiv> map prefix_match_to_CIDR (wordinterval_CIDR_split_prefixmatch rs)\""], ["", "corollary cidr_split_prefix: \n  fixes r :: \"'i::len wordinterval\"\n  shows \"(\\<Union>x\\<in>set (cidr_split r). uncurry ipset_from_cidr x) = wordinterval_to_set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (uncurry ipset_from_cidr ` set (cidr_split r)) =\n    wordinterval_to_set r", "unfolding wordinterval_CIDR_split_prefixmatch[symmetric] cidr_split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (uncurry ipset_from_cidr `\n      set (map prefix_match_to_CIDR\n            (wordinterval_CIDR_split_prefixmatch r))) =\n    wordinterval_to_set r", "apply(simp add: prefix_match_to_CIDR_def2 wordinterval_CIDR_split_prefixmatch)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>set (wordinterval_CIDR_split_prefixmatch r).\n        ipset_from_cidr (pfxm_prefix x) (pfxm_length x)) =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch r))", "using prefix_to_wordset_ipset_from_cidr wordinterval_CIDR_split_prefixmatch_all_valid_Ball"], ["proof (prove)\nusing this:\n  valid_prefix ?pfx \\<Longrightarrow>\n  prefix_to_wordset ?pfx =\n  ipset_from_cidr (pfxm_prefix ?pfx) (pfxm_length ?pfx)\n  \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch ?r).\n     valid_prefix e \\<and> pfxm_length e \\<le> LENGTH(?'a)\n\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>set (wordinterval_CIDR_split_prefixmatch r).\n        ipset_from_cidr (pfxm_prefix x) (pfxm_length x)) =\n    \\<Union>\n     (prefix_to_wordset ` set (wordinterval_CIDR_split_prefixmatch r))", "by blast"], ["", "corollary cidr_split_prefix_single: \n  fixes start :: \"'i::len word\"\n  shows \"(\\<Union>x\\<in>set (cidr_split (iprange_interval (start, end))). uncurry ipset_from_cidr x) = {start..end}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (uncurry ipset_from_cidr `\n      set (cidr_split (iprange_interval (start, end)))) =\n    {start..end}", "unfolding wordinterval_to_set.simps[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (uncurry ipset_from_cidr `\n      set (cidr_split (iprange_interval (start, end)))) =\n    wordinterval_to_set (WordInterval start end)", "using cidr_split_prefix iprange_interval.simps"], ["proof (prove)\nusing this:\n  \\<Union> (uncurry ipset_from_cidr ` set (cidr_split ?r)) =\n  wordinterval_to_set ?r\n  iprange_interval (?ip_start, ?ip_end) = WordInterval ?ip_start ?ip_end\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (uncurry ipset_from_cidr `\n      set (cidr_split (iprange_interval (start, end)))) =\n    wordinterval_to_set (WordInterval start end)", "by metis"], ["", "private"], ["", "lemma interval_in_splitD: \"xa \\<in> foo \\<Longrightarrow> prefix_to_wordset xa \\<subseteq> \\<Union>(prefix_to_wordset ` foo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa \\<in> foo \\<Longrightarrow>\n    prefix_to_wordset xa \\<subseteq> \\<Union> (prefix_to_wordset ` foo)", "by auto"], ["", "lemma cidrsplit_no_overlaps: \"\\<lbrakk>\n        x \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n        xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi); \n        pt && ~~ (pfxm_mask x) = pfxm_prefix x;\n        pt && ~~ (pfxm_mask xa) = pfxm_prefix xa\n        \\<rbrakk>\n       \\<Longrightarrow> x = xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     pt && ~~ pfxm_mask x = pfxm_prefix x;\n     pt && ~~ pfxm_mask xa = pfxm_prefix xa\\<rbrakk>\n    \\<Longrightarrow> x = xa", "proof(rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     pt && ~~ pfxm_mask x = pfxm_prefix x;\n     pt && ~~ pfxm_mask xa = pfxm_prefix xa; x \\<noteq> xa\\<rbrakk>\n    \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  x \\<in> set (wordinterval_CIDR_split_prefixmatch wi)\n  xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi)\n  pt && ~~ pfxm_mask x = pfxm_prefix x\n  pt && ~~ pfxm_mask xa = pfxm_prefix xa\n  x \\<noteq> xa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     pt && ~~ pfxm_mask x = pfxm_prefix x;\n     pt && ~~ pfxm_mask xa = pfxm_prefix xa; x \\<noteq> xa\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"prefix_match_semantics x pt\" \"prefix_match_semantics xa pt\""], ["proof (prove)\nusing this:\n  x \\<in> set (wordinterval_CIDR_split_prefixmatch wi)\n  xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi)\n  pt && ~~ pfxm_mask x = pfxm_prefix x\n  pt && ~~ pfxm_mask xa = pfxm_prefix xa\n  x \\<noteq> xa\n\ngoal (1 subgoal):\n 1. prefix_match_semantics x pt &&& prefix_match_semantics xa pt", "unfolding prefix_match_semantics_def"], ["proof (prove)\nusing this:\n  x \\<in> set (wordinterval_CIDR_split_prefixmatch wi)\n  xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi)\n  pt && ~~ pfxm_mask x = pfxm_prefix x\n  pt && ~~ pfxm_mask xa = pfxm_prefix xa\n  x \\<noteq> xa\n\ngoal (1 subgoal):\n 1. pfxm_prefix x = ~~ pfxm_mask x && pt &&&\n    pfxm_prefix xa = ~~ pfxm_mask xa && pt", "by (simp_all add: word_bw_comms(1))"], ["proof (state)\nthis:\n  prefix_match_semantics x pt\n  prefix_match_semantics xa pt\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     pt && ~~ pfxm_mask x = pfxm_prefix x;\n     pt && ~~ pfxm_mask xa = pfxm_prefix xa; x \\<noteq> xa\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  prefix_match_semantics x pt\n  prefix_match_semantics xa pt\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     pt && ~~ pfxm_mask x = pfxm_prefix x;\n     pt && ~~ pfxm_mask xa = pfxm_prefix xa; x \\<noteq> xa\\<rbrakk>\n    \\<Longrightarrow> False", "have \"valid_prefix x\" \"valid_prefix xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix x &&& valid_prefix xa", "using 1(1-2) wordinterval_CIDR_split_prefixmatch_all_valid_Ball"], ["proof (prove)\nusing this:\n  x \\<in> set (wordinterval_CIDR_split_prefixmatch wi)\n  xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi)\n  \\<forall>e\\<in>set (wordinterval_CIDR_split_prefixmatch ?r).\n     valid_prefix e \\<and> pfxm_length e \\<le> LENGTH(?'a)\n\ngoal (1 subgoal):\n 1. valid_prefix x &&& valid_prefix xa", "by blast+"], ["proof (state)\nthis:\n  valid_prefix x\n  valid_prefix xa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     pt && ~~ pfxm_mask x = pfxm_prefix x;\n     pt && ~~ pfxm_mask xa = pfxm_prefix xa; x \\<noteq> xa\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  prefix_match_semantics x pt\n  prefix_match_semantics xa pt\n  valid_prefix x\n  valid_prefix xa", "have \"pt \\<in> prefix_to_wordset x\" \"pt \\<in> prefix_to_wordset xa\""], ["proof (prove)\nusing this:\n  prefix_match_semantics x pt\n  prefix_match_semantics xa pt\n  valid_prefix x\n  valid_prefix xa\n\ngoal (1 subgoal):\n 1. pt \\<in> prefix_to_wordset x &&& pt \\<in> prefix_to_wordset xa", "using prefix_match_semantics_wordset"], ["proof (prove)\nusing this:\n  prefix_match_semantics x pt\n  prefix_match_semantics xa pt\n  valid_prefix x\n  valid_prefix xa\n  valid_prefix ?pfx \\<Longrightarrow>\n  prefix_match_semantics ?pfx ?a = (?a \\<in> prefix_to_wordset ?pfx)\n\ngoal (1 subgoal):\n 1. pt \\<in> prefix_to_wordset x &&& pt \\<in> prefix_to_wordset xa", "by blast+"], ["proof (state)\nthis:\n  pt \\<in> prefix_to_wordset x\n  pt \\<in> prefix_to_wordset xa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     xa \\<in> set (wordinterval_CIDR_split_prefixmatch wi);\n     pt && ~~ pfxm_mask x = pfxm_prefix x;\n     pt && ~~ pfxm_mask xa = pfxm_prefix xa; x \\<noteq> xa\\<rbrakk>\n    \\<Longrightarrow> False", "with wordinterval_CIDR_split_disjunct[OF 1(1,2) 1(5)]"], ["proof (chain)\npicking this:\n  prefix_to_wordset x \\<inter> prefix_to_wordset xa = {}\n  pt \\<in> prefix_to_wordset x\n  pt \\<in> prefix_to_wordset xa", "show False"], ["proof (prove)\nusing this:\n  prefix_to_wordset x \\<inter> prefix_to_wordset xa = {}\n  pt \\<in> prefix_to_wordset x\n  pt \\<in> prefix_to_wordset xa\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}