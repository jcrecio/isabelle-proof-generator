{"file_name": "/home/qj213/afp-2021-10-22/thys/IP_Addresses/Prefix_Match.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IP_Addresses", "problem_names": ["lemma \"valid_prefix (PrefixMatch (0::32 word) 42)\"", "lemma mk_valid_prefix:\n  fixes base::\"'a::len word\"\n  shows \"valid_prefix (PrefixMatch (base AND NOT (mask (len_of TYPE ('a) - len))) len)\"", "lemma valid_prefix_00: \"valid_prefix (PrefixMatch 0 0)\"", "lemma prefix_match_to_CIDR_def2: \"prefix_match_to_CIDR = (\\<lambda>pfx. (pfxm_prefix pfx, pfxm_length pfx))\"", "lemma \"sorted_list_of_set\n {PrefixMatch 0 32 :: 32 prefix_match,\n  PrefixMatch 42 32,\n  PrefixMatch 0 0,\n  PrefixMatch 0 1,\n  PrefixMatch 12 31} =\n    [PrefixMatch 0 32, PrefixMatch 0x2A 32, PrefixMatch 0xC 31, PrefixMatch 0 1, PrefixMatch 0 0]\"", "lemma valid_prefix_E: \"valid_prefix pf \\<Longrightarrow> ((pfxm_mask pf) AND pfxm_prefix pf = 0)\"", "lemma valid_prefix_alt: fixes p::\"'a::len prefix_match\"\n  shows \"valid_prefix p = (pfxm_prefix p AND (2 ^ ((len_of TYPE ('a)) - pfxm_length p) - 1) = 0)\"", "lemma same_length_prefixes_distinct: \"valid_prefix pfx1 \\<Longrightarrow> valid_prefix pfx2 \\<Longrightarrow> pfx1 \\<noteq> pfx2 \\<Longrightarrow> pfxm_length pfx1 = pfxm_length pfx2 \\<Longrightarrow> prefix_match_semantics pfx1 w \\<Longrightarrow> prefix_match_semantics pfx2 w \\<Longrightarrow> False\"", "lemma pfx_not_empty: \"valid_prefix pfx \\<Longrightarrow> prefix_to_wordset pfx \\<noteq> {}\"", "lemma zero_prefix_match_all:\n    \"valid_prefix m \\<Longrightarrow> pfxm_length m = 0 \\<Longrightarrow> prefix_match_semantics m ip\"", "lemma prefix_to_wordset_subset_ipset_from_cidr: \n      \"prefix_to_wordset pfx \\<subseteq> ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\"", "theorem prefix_match_semantics_wordset:\n    assumes \"valid_prefix pfx\" \n    shows \"prefix_match_semantics pfx a \\<longleftrightarrow> a \\<in> prefix_to_wordset pfx\"", "lemma valid_prefix_ipset_from_netmask_ipset_from_cidr:\n    shows \"ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx)) =\n            ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\"", "lemma prefix_match_semantics_ipset_from_netmask:\n    assumes \"valid_prefix pfx\"\n    shows \"prefix_match_semantics pfx a \\<longleftrightarrow>\n            a \\<in> ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx))\"", "lemma prefix_match_semantics_ipset_from_netmask2:\n    assumes \"valid_prefix pfx\"\n    shows \"prefix_match_semantics pfx (a :: 'i::len word) \\<longleftrightarrow>\n            a \\<in> ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\"", "lemma prefix_to_wordset_ipset_from_cidr:\n    assumes \"valid_prefix (pfx::'a::len prefix_match)\"\n    shows \"prefix_to_wordset pfx = ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\"", "lemma prefix_to_wordinterval_set_eq[simp]:\n    \"wordinterval_to_set (prefix_to_wordinterval pfx) = prefix_to_wordset pfx\"", "lemma prefix_to_wordinterval_def2:\n    \"prefix_to_wordinterval pfx =\n      iprange_interval ((pfxm_prefix pfx), (pfxm_prefix pfx OR pfxm_mask pfx))\"", "lemma prefix_never_empty: \n  fixes d:: \"'a::len prefix_match\"\n  shows\"\\<not> wordinterval_empty (prefix_to_wordinterval d)\"", "lemma ipset_from_cidr_lowest: \"a \\<in> ipset_from_cidr a n\"", "lemma \"valid_prefix (PrefixMatch a n) \\<Longrightarrow> is_lowest_element a (ipset_from_cidr a n)\""], "translations": [["", "lemma \"valid_prefix (PrefixMatch (0::32 word) 42)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix (PrefixMatch 0 42)", "by eval"], ["", "text\\<open>When zeroing all least significant bits which exceed the @{const pfxm_length},\n     you get a @{const valid_prefix}\\<close>"], ["", "lemma mk_valid_prefix:\n  fixes base::\"'a::len word\"\n  shows \"valid_prefix (PrefixMatch (base AND NOT (mask (len_of TYPE ('a) - len))) len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix (PrefixMatch (base && ~~ mask (LENGTH('a) - len)) len)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_prefix (PrefixMatch (base && ~~ mask (LENGTH('a) - len)) len)", "have \"mask (len - m) AND base AND NOT (mask (len - m)) = 0\"\n    for m len and base::\"'a::len word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (len - m) && base && ~~ mask (len - m) = 0", "by(simp add: word_bw_lcs)"], ["proof (state)\nthis:\n  mask (?len - ?m) && ?base && ~~ mask (?len - ?m) = 0\n\ngoal (1 subgoal):\n 1. valid_prefix (PrefixMatch (base && ~~ mask (LENGTH('a) - len)) len)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mask (?len - ?m) && ?base && ~~ mask (?len - ?m) = 0\n\ngoal (1 subgoal):\n 1. valid_prefix (PrefixMatch (base && ~~ mask (LENGTH('a) - len)) len)", "by(simp add: valid_prefix_def pfxm_mask_def pfxm_length_def pfxm_prefix_def)"], ["proof (state)\nthis:\n  valid_prefix (PrefixMatch (base && ~~ mask (LENGTH('a) - len)) len)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The type @{typ \"'a prefix_match\"} usually requires @{const valid_prefix}.\n      When we allow working on arbitrary IPs in CIDR notation,\n      we will use the type @{typ \"('i::len word \\<times> nat)\"} directly.\\<close>"], ["", "lemma valid_prefix_00: \"valid_prefix (PrefixMatch 0 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix (PrefixMatch 0 0)", "by (simp add: valid_prefix_def)"], ["", "definition prefix_match_to_CIDR :: \"('i::len) prefix_match \\<Rightarrow> ('i word \\<times> nat)\" where\n  \"prefix_match_to_CIDR pfx \\<equiv> (pfxm_prefix pfx, pfxm_length pfx)\""], ["", "lemma prefix_match_to_CIDR_def2: \"prefix_match_to_CIDR = (\\<lambda>pfx. (pfxm_prefix pfx, pfxm_length pfx))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_match_to_CIDR =\n    (\\<lambda>pfx. (pfxm_prefix pfx, pfxm_length pfx))", "unfolding prefix_match_to_CIDR_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (pfxm_prefix x, pfxm_length x) = (pfxm_prefix x, pfxm_length x)", "by simp"], ["", "definition \"prefix_match_dtor m \\<equiv> (case m of PrefixMatch p l \\<Rightarrow> (p,l))\""], ["", "text\\<open>Some more or less random linear order on prefixes.\n     Only used for serialization at the time of this writing.\\<close>"], ["", "instantiation prefix_match :: (len) linorder\nbegin"], ["", "definition \"a \\<le> b \\<longleftrightarrow> (if pfxm_length a = pfxm_length b\n                         then pfxm_prefix a \\<le> pfxm_prefix b\n                         else pfxm_length a > pfxm_length b)\""], ["", "definition \"a < b \\<longleftrightarrow> (a \\<noteq> b \\<and>\n\t                       (if pfxm_length a = pfxm_length b\n\t                        then pfxm_prefix a \\<le> pfxm_prefix b\n\t                        else pfxm_length a > pfxm_length b))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a prefix_match, linorder_class)", "by standard (auto simp: less_eq_prefix_match_def less_prefix_match_def prefix_match.expand\n                  split: if_splits)"], ["", "end"], ["", "lemma \"sorted_list_of_set\n {PrefixMatch 0 32 :: 32 prefix_match,\n  PrefixMatch 42 32,\n  PrefixMatch 0 0,\n  PrefixMatch 0 1,\n  PrefixMatch 12 31} =\n    [PrefixMatch 0 32, PrefixMatch 0x2A 32, PrefixMatch 0xC 31, PrefixMatch 0 1, PrefixMatch 0 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {PrefixMatch 0 32, PrefixMatch 42 32, PrefixMatch 0 0, PrefixMatch 0 1,\n      PrefixMatch 12 31} =\n    [PrefixMatch 0 32, PrefixMatch 42 32, PrefixMatch 12 31,\n     PrefixMatch 0 1, PrefixMatch 0 0]", "by eval"], ["", "context\nbegin"], ["", "private"], ["", "lemma valid_prefix_E: \"valid_prefix pf \\<Longrightarrow> ((pfxm_mask pf) AND pfxm_prefix pf = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix pf \\<Longrightarrow> pfxm_mask pf && pfxm_prefix pf = 0", "unfolding valid_prefix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfxm_mask pf && pfxm_prefix pf = 0 \\<Longrightarrow>\n    pfxm_mask pf && pfxm_prefix pf = 0", "."], ["", "private"], ["", "lemma valid_prefix_alt: fixes p::\"'a::len prefix_match\"\n  shows \"valid_prefix p = (pfxm_prefix p AND (2 ^ ((len_of TYPE ('a)) - pfxm_length p) - 1) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix p =\n    (pfxm_prefix p && 2 ^ (LENGTH('a) - pfxm_length p) - 1 = 0)", "unfolding valid_prefix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pfxm_mask p && pfxm_prefix p = 0) =\n    (pfxm_prefix p && 2 ^ (LENGTH('a) - pfxm_length p) - 1 = 0)", "unfolding mask_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pfxm_mask p && pfxm_prefix p = 0) =\n    (pfxm_prefix p && 2 ^ (LENGTH('a) - pfxm_length p) - 1 = 0)", "using word_bw_comms(1)\n   arg_cong[where f = \"\\<lambda>x. (pfxm_prefix p AND x - 1 = 0)\"]\n   shiftl_1"], ["proof (prove)\nusing this:\n  ?x && ?y = ?y && ?x\n  ?x = ?y \\<Longrightarrow>\n  (pfxm_prefix p && ?x - 1 = 0) = (pfxm_prefix p && ?y - 1 = 0)\n  1 << ?n = 2 ^ ?n\n\ngoal (1 subgoal):\n 1. (pfxm_mask p && pfxm_prefix p = 0) =\n    (pfxm_prefix p && 2 ^ (LENGTH('a) - pfxm_length p) - 1 = 0)", "unfolding pfxm_prefix_def pfxm_mask_def mask_eq"], ["proof (prove)\nusing this:\n  ?x && ?y = ?y && ?x\n  ?x = ?y \\<Longrightarrow>\n  ((case p of PrefixMatch x1 x2 \\<Rightarrow> x1) && ?x - 1 = 0) =\n  ((case p of PrefixMatch x1 x2 \\<Rightarrow> x1) && ?y - 1 = 0)\n  1 << ?n = 2 ^ ?n\n\ngoal (1 subgoal):\n 1. ((1 << LENGTH('a) - pfxm_length p) - 1 &&\n     (case p of PrefixMatch x1 x2 \\<Rightarrow> x1) =\n     0) =\n    ((case p of PrefixMatch x1 x2 \\<Rightarrow> x1) &&\n     2 ^ (LENGTH('a) - pfxm_length p) - 1 =\n     0)", "apply (cases p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x y. x && y = y && x;\n        \\<And>x y.\n           x = y \\<Longrightarrow>\n           ((case p of PrefixMatch x1 x2 \\<Rightarrow> x1) && x - 1 = 0) =\n           ((case p of PrefixMatch x1 x2 \\<Rightarrow> x1) && y - 1 = 0);\n        \\<And>n. 1 << n = 2 ^ n; p = PrefixMatch x1 x2\\<rbrakk>\n       \\<Longrightarrow> ((1 << LENGTH('a) - pfxm_length p) - 1 &&\n                          (case p of PrefixMatch x1 x2 \\<Rightarrow> x1) =\n                          0) =\n                         ((case p of PrefixMatch x1 x2 \\<Rightarrow> x1) &&\n                          2 ^ (LENGTH('a) - pfxm_length p) - 1 =\n                          0)", "apply (simp add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Address Semantics\\<close>"], ["", "text\\<open>Matching on a @{typ \"'a::len prefix_match\"}. Think of routing tables.\\<close>"], ["", "definition prefix_match_semantics where\n    \"prefix_match_semantics m a \\<equiv> pfxm_prefix m = NOT (pfxm_mask m) AND a\""], ["", "lemma same_length_prefixes_distinct: \"valid_prefix pfx1 \\<Longrightarrow> valid_prefix pfx2 \\<Longrightarrow> pfx1 \\<noteq> pfx2 \\<Longrightarrow> pfxm_length pfx1 = pfxm_length pfx2 \\<Longrightarrow> prefix_match_semantics pfx1 w \\<Longrightarrow> prefix_match_semantics pfx2 w \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefix pfx1; valid_prefix pfx2; pfx1 \\<noteq> pfx2;\n     pfxm_length pfx1 = pfxm_length pfx2; prefix_match_semantics pfx1 w;\n     prefix_match_semantics pfx2 w\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: pfxm_mask_def prefix_match.expand prefix_match_semantics_def)"], ["", "subsection\\<open>Relation between prefix and set\\<close>"], ["", "definition prefix_to_wordset :: \"'a::len prefix_match \\<Rightarrow> 'a word set\" where\n    \"prefix_to_wordset pfx = {pfxm_prefix pfx .. pfxm_prefix pfx OR pfxm_mask pfx}\""], ["", "private"], ["", "lemma pfx_not_empty: \"valid_prefix pfx \\<Longrightarrow> prefix_to_wordset pfx \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix pfx \\<Longrightarrow> prefix_to_wordset pfx \\<noteq> {}", "unfolding valid_prefix_def prefix_to_wordset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfxm_mask pfx && pfxm_prefix pfx = 0 \\<Longrightarrow>\n    {pfxm_prefix pfx..pfxm_prefix pfx || pfxm_mask pfx} \\<noteq> {}", "by(simp add: le_word_or2)"], ["", "lemma zero_prefix_match_all:\n    \"valid_prefix m \\<Longrightarrow> pfxm_length m = 0 \\<Longrightarrow> prefix_match_semantics m ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefix m; pfxm_length m = 0\\<rbrakk>\n    \\<Longrightarrow> prefix_match_semantics m ip", "by(simp add: pfxm_mask_def mask_2pm1 valid_prefix_alt prefix_match_semantics_def)"], ["", "lemma prefix_to_wordset_subset_ipset_from_cidr: \n      \"prefix_to_wordset pfx \\<subseteq> ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset pfx\n    \\<subseteq> ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "apply(rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> prefix_to_wordset pfx \\<Longrightarrow>\n       x \\<in> ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "apply(simp add: prefix_to_wordset_def addr_in_ipset_from_cidr_code)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       pfxm_prefix pfx \\<le> x \\<and>\n       x \\<le> pfxm_prefix pfx || pfxm_mask pfx \\<Longrightarrow>\n       pfxm_prefix pfx &&\n       (mask (pfxm_length pfx) << LENGTH('a) - pfxm_length pfx)\n       \\<le> x \\<and>\n       x \\<le> pfxm_prefix pfx || mask (LENGTH('a) - pfxm_length pfx)", "apply(intro impI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       pfxm_prefix pfx \\<le> x \\<and>\n       x \\<le> pfxm_prefix pfx || pfxm_mask pfx \\<Longrightarrow>\n       pfxm_prefix pfx &&\n       (mask (pfxm_length pfx) << LENGTH('a) - pfxm_length pfx)\n       \\<le> x\n 2. \\<And>x.\n       pfxm_prefix pfx \\<le> x \\<and>\n       x \\<le> pfxm_prefix pfx || pfxm_mask pfx \\<Longrightarrow>\n       x \\<le> pfxm_prefix pfx || mask (LENGTH('a) - pfxm_length pfx)", "apply (metis (erased, hide_lams) order_trans word_and_le2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       pfxm_prefix pfx \\<le> x \\<and>\n       x \\<le> pfxm_prefix pfx || pfxm_mask pfx \\<Longrightarrow>\n       x \\<le> pfxm_prefix pfx || mask (LENGTH('a) - pfxm_length pfx)", "apply(simp add: pfxm_mask_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Equivalence Proofs\\<close>"], ["", "theorem prefix_match_semantics_wordset:\n    assumes \"valid_prefix pfx\" \n    shows \"prefix_match_semantics pfx a \\<longleftrightarrow> a \\<in> prefix_to_wordset pfx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_match_semantics pfx a = (a \\<in> prefix_to_wordset pfx)", "using assms"], ["proof (prove)\nusing this:\n  valid_prefix pfx\n\ngoal (1 subgoal):\n 1. prefix_match_semantics pfx a = (a \\<in> prefix_to_wordset pfx)", "unfolding valid_prefix_def pfxm_mask_def prefix_match_semantics_def prefix_to_wordset_def"], ["proof (prove)\nusing this:\n  mask (LENGTH('a) - pfxm_length pfx) && pfxm_prefix pfx = 0\n\ngoal (1 subgoal):\n 1. (pfxm_prefix pfx = ~~ mask (LENGTH('a) - pfxm_length pfx) && a) =\n    (a \\<in> {pfxm_prefix\n               pfx..pfxm_prefix pfx || mask (LENGTH('a) - pfxm_length pfx)})", "apply(cases pfx, rename_tac base len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>base len.\n       \\<lbrakk>mask (LENGTH('a) - pfxm_length pfx) && pfxm_prefix pfx = 0;\n        pfx = PrefixMatch base len;\n        mask (LENGTH('a) - pfxm_length pfx) && pfxm_prefix pfx = 0\\<rbrakk>\n       \\<Longrightarrow> (pfxm_prefix pfx =\n                          ~~ mask (LENGTH('a) - pfxm_length pfx) && a) =\n                         (a \\<in> {pfxm_prefix\n                                    pfx..pfxm_prefix pfx ||\n   mask (LENGTH('a) - pfxm_length pfx)})", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>base len.\n       \\<lbrakk>mask (LENGTH('a) - len) && base = 0;\n        pfx = PrefixMatch base len\\<rbrakk>\n       \\<Longrightarrow> (base = ~~ mask (LENGTH('a) - len) && a) =\n                         (base \\<le> a \\<and>\n                          a \\<le> base || mask (LENGTH('a) - len))", "apply(drule_tac base=base and len=len and a=a in zero_base_lsb_imp_set_eq_as_bit_operation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>base len.\n       \\<lbrakk>pfx = PrefixMatch base len;\n        (base = ~~ mask (LENGTH('a) - len) && a) =\n        (a \\<in> {base..base || mask (LENGTH('a) - len)})\\<rbrakk>\n       \\<Longrightarrow> (base = ~~ mask (LENGTH('a) - len) && a) =\n                         (base \\<le> a \\<and>\n                          a \\<le> base || mask (LENGTH('a) - len))", "by (simp)"], ["", "private"], ["", "lemma valid_prefix_ipset_from_netmask_ipset_from_cidr:\n    shows \"ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx)) =\n            ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_netmask (pfxm_prefix pfx) (~~ pfxm_mask pfx) =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "apply(cases pfx)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       pfx = PrefixMatch x1 x2 \\<Longrightarrow>\n       ipset_from_netmask (pfxm_prefix pfx) (~~ pfxm_mask pfx) =\n       ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "apply(simp add: ipset_from_cidr_alt2 pfxm_mask_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prefix_match_semantics_ipset_from_netmask:\n    assumes \"valid_prefix pfx\"\n    shows \"prefix_match_semantics pfx a \\<longleftrightarrow>\n            a \\<in> ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_match_semantics pfx a =\n    (a \\<in> ipset_from_netmask (pfxm_prefix pfx) (~~ pfxm_mask pfx))", "unfolding prefix_match_semantics_wordset[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> prefix_to_wordset pfx) =\n    (a \\<in> ipset_from_netmask (pfxm_prefix pfx) (~~ pfxm_mask pfx))", "unfolding valid_prefix_ipset_from_netmask_ipset_from_cidr"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> prefix_to_wordset pfx) =\n    (a \\<in> ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx))", "unfolding prefix_to_wordset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> {pfxm_prefix pfx..pfxm_prefix pfx || pfxm_mask pfx}) =\n    (a \\<in> ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx))", "apply(subst ipset_from_cidr_base_wellforemd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mask (LENGTH('a) - pfxm_length pfx) && pfxm_prefix pfx = 0\n 2. (a \\<in> {pfxm_prefix pfx..pfxm_prefix pfx || pfxm_mask pfx}) =\n    (a \\<in> {pfxm_prefix\n               pfx..pfxm_prefix pfx || mask (LENGTH('a) - pfxm_length pfx)})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (LENGTH('a) - pfxm_length pfx) && pfxm_prefix pfx = 0", "using assms"], ["proof (prove)\nusing this:\n  valid_prefix pfx\n\ngoal (1 subgoal):\n 1. mask (LENGTH('a) - pfxm_length pfx) && pfxm_prefix pfx = 0", "by(simp add: valid_prefix_def pfxm_mask_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> {pfxm_prefix pfx..pfxm_prefix pfx || pfxm_mask pfx}) =\n    (a \\<in> {pfxm_prefix\n               pfx..pfxm_prefix pfx || mask (LENGTH('a) - pfxm_length pfx)})", "by(simp add: pfxm_mask_def)"], ["", "lemma prefix_match_semantics_ipset_from_netmask2:\n    assumes \"valid_prefix pfx\"\n    shows \"prefix_match_semantics pfx (a :: 'i::len word) \\<longleftrightarrow>\n            a \\<in> ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_match_semantics pfx a =\n    (a \\<in> ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx))", "unfolding prefix_match_semantics_ipset_from_netmask[OF assms] pfxm_mask_def ipset_from_cidr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> ipset_from_netmask (pfxm_prefix pfx)\n              (~~ mask (LENGTH('i) - pfxm_length pfx))) =\n    (a \\<in> ipset_from_netmask (pfxm_prefix pfx)\n              (mask (pfxm_length pfx) << LENGTH('i) - pfxm_length pfx))", "by (metis (full_types) NOT_mask_shifted_lenword word_not_not)"], ["", "lemma prefix_to_wordset_ipset_from_cidr:\n    assumes \"valid_prefix (pfx::'a::len prefix_match)\"\n    shows \"prefix_to_wordset pfx = ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset pfx =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prefix_to_wordset pfx =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "have helper3: \"(x::'a::len word) OR y = x OR y AND NOT x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x || y = x || y && ~~ x", "by (simp add: word_oa_dist2)"], ["proof (state)\nthis:\n  ?x || ?y = ?x || ?y && ~~ ?x\n\ngoal (1 subgoal):\n 1. prefix_to_wordset pfx =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "have prefix_match_semantics_ipset_from_netmask:\n           \"(prefix_to_wordset pfx) = ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset pfx =\n    ipset_from_netmask (pfxm_prefix pfx) (~~ pfxm_mask pfx)", "unfolding prefix_to_wordset_def ipset_from_netmask_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {pfxm_prefix pfx..pfxm_prefix pfx || pfxm_mask pfx} =\n    {pfxm_prefix pfx &&\n     ~~ pfxm_mask\n         pfx..pfxm_prefix pfx && ~~ pfxm_mask pfx || ~~ ~~ pfxm_mask pfx}", "using assms"], ["proof (prove)\nusing this:\n  valid_prefix pfx\n\ngoal (1 subgoal):\n 1. {pfxm_prefix pfx..pfxm_prefix pfx || pfxm_mask pfx} =\n    {pfxm_prefix pfx &&\n     ~~ pfxm_mask\n         pfx..pfxm_prefix pfx && ~~ pfxm_mask pfx || ~~ ~~ pfxm_mask pfx}", "by (clarsimp dest!: valid_prefix_E) (metis bit.conj_commute mask_eq_0_eq_x)"], ["proof (state)\nthis:\n  prefix_to_wordset pfx =\n  ipset_from_netmask (pfxm_prefix pfx) (~~ pfxm_mask pfx)\n\ngoal (1 subgoal):\n 1. prefix_to_wordset pfx =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "have \"((mask len)::'a::len word) << LENGTH('a) - len = ~~ (mask (LENGTH('a) - len))\"\n        for len"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask len << LENGTH('a) - len = ~~ mask (LENGTH('a) - len)", "using NOT_mask_shifted_lenword"], ["proof (prove)\nusing this:\n  ~~ (mask ?len << LENGTH(?'a) - ?len) = mask (LENGTH(?'a) - ?len)\n\ngoal (1 subgoal):\n 1. mask len << LENGTH('a) - len = ~~ mask (LENGTH('a) - len)", "by (metis word_not_not)"], ["proof (state)\nthis:\n  mask ?len << LENGTH('a) - ?len = ~~ mask (LENGTH('a) - ?len)\n\ngoal (1 subgoal):\n 1. prefix_to_wordset pfx =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "from this[of \"(pfxm_length pfx)\"]"], ["proof (chain)\npicking this:\n  mask (pfxm_length pfx) << LENGTH('a) - pfxm_length pfx =\n  ~~ mask (LENGTH('a) - pfxm_length pfx)", "have mask_def2_symmetric:\n        \"((mask (pfxm_length pfx)::'a::len word) << LENGTH('a) - pfxm_length pfx) =\n          NOT (pfxm_mask pfx)\""], ["proof (prove)\nusing this:\n  mask (pfxm_length pfx) << LENGTH('a) - pfxm_length pfx =\n  ~~ mask (LENGTH('a) - pfxm_length pfx)\n\ngoal (1 subgoal):\n 1. mask (pfxm_length pfx) << LENGTH('a) - pfxm_length pfx =\n    ~~ pfxm_mask pfx", "unfolding pfxm_mask_def"], ["proof (prove)\nusing this:\n  mask (pfxm_length pfx) << LENGTH('a) - pfxm_length pfx =\n  ~~ mask (LENGTH('a) - pfxm_length pfx)\n\ngoal (1 subgoal):\n 1. mask (pfxm_length pfx) << LENGTH('a) - pfxm_length pfx =\n    ~~ mask (LENGTH('a) - pfxm_length pfx)", "by simp"], ["proof (state)\nthis:\n  mask (pfxm_length pfx) << LENGTH('a) - pfxm_length pfx = ~~ pfxm_mask pfx\n\ngoal (1 subgoal):\n 1. prefix_to_wordset pfx =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "have ipset_from_netmask_prefix: \n        \"ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx)) =\n          ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_netmask (pfxm_prefix pfx) (~~ pfxm_mask pfx) =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "unfolding ipset_from_netmask_def ipset_from_cidr_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let network_prefix = pfxm_prefix pfx && ~~ pfxm_mask pfx\n     in {network_prefix..network_prefix || ~~ ~~ pfxm_mask pfx}) =\n    {pfxm_prefix pfx &&\n     (mask (pfxm_length pfx) <<\n      LENGTH('a) -\n      pfxm_length\n       pfx)..pfxm_prefix pfx || mask (LENGTH('a) - pfxm_length pfx)}", "unfolding pfxm_mask_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let network_prefix = pfxm_prefix pfx && ~~ pfxm_mask pfx\n     in {network_prefix..network_prefix || ~~ ~~ pfxm_mask pfx}) =\n    {pfxm_prefix pfx &&\n     (mask (pfxm_length pfx) <<\n      LENGTH('a) - pfxm_length pfx)..pfxm_prefix pfx || pfxm_mask pfx}", "unfolding mask_def2_symmetric"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let network_prefix = pfxm_prefix pfx && ~~ pfxm_mask pfx\n     in {network_prefix..network_prefix || ~~ ~~ pfxm_mask pfx}) =\n    {pfxm_prefix pfx && ~~ pfxm_mask pfx..pfxm_prefix pfx || pfxm_mask pfx}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let network_prefix = pfxm_prefix pfx && ~~ pfxm_mask pfx\n     in {network_prefix..network_prefix || pfxm_mask pfx}) =\n    {pfxm_prefix pfx && ~~ pfxm_mask pfx..pfxm_prefix pfx || pfxm_mask pfx}", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {pfxm_prefix pfx &&\n     ~~ pfxm_mask\n         pfx..pfxm_prefix pfx && ~~ pfxm_mask pfx || pfxm_mask pfx} =\n    {pfxm_prefix pfx && ~~ pfxm_mask pfx..pfxm_prefix pfx || pfxm_mask pfx}", "using assms[unfolded valid_prefix_def]"], ["proof (prove)\nusing this:\n  pfxm_mask pfx && pfxm_prefix pfx = 0\n\ngoal (1 subgoal):\n 1. {pfxm_prefix pfx &&\n     ~~ pfxm_mask\n         pfx..pfxm_prefix pfx && ~~ pfxm_mask pfx || pfxm_mask pfx} =\n    {pfxm_prefix pfx && ~~ pfxm_mask pfx..pfxm_prefix pfx || pfxm_mask pfx}", "by (metis helper3 word_bw_comms(2))"], ["proof (state)\nthis:\n  ipset_from_netmask (pfxm_prefix pfx) (~~ pfxm_mask pfx) =\n  ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\n\ngoal (1 subgoal):\n 1. prefix_to_wordset pfx =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordset pfx =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "by (metis ipset_from_netmask_prefix local.prefix_match_semantics_ipset_from_netmask)"], ["proof (state)\nthis:\n  prefix_to_wordset pfx =\n  ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition prefix_to_wordinterval :: \"'a::len prefix_match \\<Rightarrow> 'a wordinterval\" where\n    \"prefix_to_wordinterval pfx \\<equiv> WordInterval (pfxm_prefix pfx) (pfxm_prefix pfx OR pfxm_mask pfx)\""], ["", "lemma prefix_to_wordinterval_set_eq[simp]:\n    \"wordinterval_to_set (prefix_to_wordinterval pfx) = prefix_to_wordset pfx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (prefix_to_wordinterval pfx) = prefix_to_wordset pfx", "unfolding prefix_to_wordinterval_def prefix_to_wordset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (WordInterval (pfxm_prefix pfx) (pfxm_prefix pfx || pfxm_mask pfx)) =\n    {pfxm_prefix pfx..pfxm_prefix pfx || pfxm_mask pfx}", "by simp"], ["", "lemma prefix_to_wordinterval_def2:\n    \"prefix_to_wordinterval pfx =\n      iprange_interval ((pfxm_prefix pfx), (pfxm_prefix pfx OR pfxm_mask pfx))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_to_wordinterval pfx =\n    iprange_interval (pfxm_prefix pfx, pfxm_prefix pfx || pfxm_mask pfx)", "unfolding iprange_interval.simps prefix_to_wordinterval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WordInterval (pfxm_prefix pfx) (pfxm_prefix pfx || pfxm_mask pfx) =\n    WordInterval (pfxm_prefix pfx) (pfxm_prefix pfx || pfxm_mask pfx)", "by simp"], ["", "corollary prefix_to_wordinterval_ipset_from_cidr: \"valid_prefix pfx \\<Longrightarrow>\n    wordinterval_to_set (prefix_to_wordinterval pfx) =\n      ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix pfx \\<Longrightarrow>\n    wordinterval_to_set (prefix_to_wordinterval pfx) =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "using prefix_to_wordset_ipset_from_cidr prefix_to_wordinterval_set_eq"], ["proof (prove)\nusing this:\n  valid_prefix ?pfx \\<Longrightarrow>\n  prefix_to_wordset ?pfx =\n  ipset_from_cidr (pfxm_prefix ?pfx) (pfxm_length ?pfx)\n  wordinterval_to_set (prefix_to_wordinterval ?pfx) = prefix_to_wordset ?pfx\n\ngoal (1 subgoal):\n 1. valid_prefix pfx \\<Longrightarrow>\n    wordinterval_to_set (prefix_to_wordinterval pfx) =\n    ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)", "by auto"], ["", "end"], ["", "lemma prefix_never_empty: \n  fixes d:: \"'a::len prefix_match\"\n  shows\"\\<not> wordinterval_empty (prefix_to_wordinterval d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty (prefix_to_wordinterval d)", "by (simp add: le_word_or2 prefix_to_wordinterval_def)"], ["", "text\\<open>Getting a lowest element\\<close>"], ["", "lemma ipset_from_cidr_lowest: \"a \\<in> ipset_from_cidr a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> ipset_from_cidr a n", "using ip_cidr_set_def ipset_from_cidr_eq_ip_cidr_set"], ["proof (prove)\nusing this:\n  ip_cidr_set ?i ?r \\<equiv>\n  {j. ?i && ~~ mask (LENGTH(?'i) - ?r) = j && ~~ mask (LENGTH(?'i) - ?r)}\n  ipset_from_cidr ?base ?len = ip_cidr_set ?base ?len\n\ngoal (1 subgoal):\n 1. a \\<in> ipset_from_cidr a n", "by blast"], ["", "(*this is why I call the previous lemma 'lowest'*)"], ["", "lemma \"valid_prefix (PrefixMatch a n) \\<Longrightarrow> is_lowest_element a (ipset_from_cidr a n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix (PrefixMatch a n) \\<Longrightarrow>\n    is_lowest_element a (ipset_from_cidr a n)", "apply(simp add: is_lowest_element_def ipset_from_cidr_lowest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix (PrefixMatch a n) \\<Longrightarrow>\n    \\<forall>y\\<in>ipset_from_cidr a n. y \\<le> a \\<longrightarrow> y = a", "apply(simp add: ipset_from_cidr_eq_ip_cidr_set ip_cidr_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix (PrefixMatch a n) \\<Longrightarrow>\n    \\<forall>y.\n       a && ~~ mask (LENGTH('a) - n) =\n       y && ~~ mask (LENGTH('a) - n) \\<longrightarrow>\n       y \\<le> a \\<longrightarrow> y = a", "apply(simp add: valid_prefix_def pfxm_mask_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mask (LENGTH('a) - n) && a = 0 \\<Longrightarrow>\n    \\<forall>y.\n       a && ~~ mask (LENGTH('a) - n) =\n       y && ~~ mask (LENGTH('a) - n) \\<longrightarrow>\n       y \\<le> a \\<longrightarrow> y = a", "by (metis diff_zero eq_iff mask_out_sub_mask word_and_le2 word_bw_comms(1))"], ["", "end"]]}