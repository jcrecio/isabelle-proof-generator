{"file_name": "/home/qj213/afp-2021-10-22/thys/IP_Addresses/IPv4.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IP_Addresses", "problem_names": ["lemma take_bit_word_beyond_length_eq:\n  \\<open>take_bit n w = w\\<close> if \\<open>LENGTH('a) \\<le> n\\<close> for w :: \\<open>'a::len word\\<close>", "lemma max_ipv4_addr_number: \"max_ipv4_addr = 4294967295\"", "lemma \"max_ipv4_addr = 0b11111111111111111111111111111111\"", "lemma max_ipv4_addr_max_word: \"max_ipv4_addr = max_word\"", "lemma max_ipv4_addr_max[simp]: \"\\<forall>a. a \\<le> max_ipv4_addr\"", "lemma UNIV_ipv4addrset: \"UNIV = {0 .. max_ipv4_addr}\"", "lemma nat_of_ipv4addr_ipv4addr_of_nat_mod: \"nat_of_ipv4addr (ipv4addr_of_nat n) = n mod 2^32\"", "lemma nat_of_ipv4addr_ipv4addr_of_nat:\n    \"\\<lbrakk> n \\<le> nat_of_ipv4addr max_ipv4_addr \\<rbrakk> \\<Longrightarrow> nat_of_ipv4addr (ipv4addr_of_nat n) = n\"", "lemma ipv4addr_of_nat_nat_of_ipv4addr: \"ipv4addr_of_nat (nat_of_ipv4addr addr) = addr\"", "lemma \"ipv4addr_of_dotdecimal (192, 168, 0, 1) = 3232235521\"", "lemma \"dotdecimal_of_ipv4addr 3232235521 = (192, 168, 0, 1)\"", "lemma ipv4addr_of_dotdecimal_bit:\n    \"ipv4addr_of_dotdecimal (a,b,c,d) =\n      (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n       (ipv4addr_of_nat c << 8) + ipv4addr_of_nat d\"", "lemma size_ipv4addr: \"size (x::ipv4addr) = 32\"", "lemma dotdecimal_of_ipv4addr_ipv4addr_of_dotdecimal:\n  \"\\<lbrakk> a < 256; b < 256; c < 256; d < 256 \\<rbrakk> \\<Longrightarrow>\n    dotdecimal_of_ipv4addr (ipv4addr_of_dotdecimal (a,b,c,d)) = (a,b,c,d)\"", "lemma ipv4addr_of_dotdecimal_dotdecimal_of_ipv4addr:\n    \"(ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip)) = ip\"", "lemma ipv4addr_of_dotdecimal_eqE:\n    \"\\<lbrakk> ipv4addr_of_dotdecimal (a,b,c,d) = ipv4addr_of_dotdecimal (e,f,g,h);\n       a < 256; b < 256; c < 256; d < 256; e < 256; f < 256; g < 256; h < 256 \\<rbrakk> \\<Longrightarrow>\n         a = e \\<and> b = f \\<and> c = g \\<and> d = h\"", "lemma \"(UNIV :: ipv4addr set) = {0 .. max_ipv4_addr}\"", "lemma \"(42::ipv4addr) \\<in> UNIV\"", "lemma \"ipset_from_netmask (ipv4addr_of_dotdecimal (192,168,0,42)) (ipv4addr_of_dotdecimal (255,255,0,0)) =\n          {ipv4addr_of_dotdecimal (192,168,0,0) .. ipv4addr_of_dotdecimal (192,168,255,255)}\"", "lemma \"ipset_from_netmask (ipv4addr_of_dotdecimal (192,168,0,42)) (ipv4addr_of_dotdecimal (0,0,0,0)) = UNIV\"", "lemma fixes addr :: ipv4addr\n    shows \"ipset_from_cidr addr pflength =\n            ipset_from_netmask addr ((mask pflength) << (32 - pflength))\"", "lemma \"ipset_from_cidr (ipv4addr_of_dotdecimal (192,168,0,42)) 16 =\n          {ipv4addr_of_dotdecimal (192,168,0,0) .. ipv4addr_of_dotdecimal (192,168,255,255)}\"", "lemma \"ip \\<in> (ipset_from_cidr (ipv4addr_of_dotdecimal (0, 0, 0, 0)) 0)\"", "lemma ipv4set_from_cidr_32: fixes addr :: ipv4addr\n    shows \"ipset_from_cidr addr 32 = {addr}\"", "lemma  fixes pre :: ipv4addr\n    shows \"ipset_from_cidr pre len = {(pre AND ((mask len) << (32 - len))) .. pre OR (mask (32 - len))}\"", "lemma addr_in_ipv4set_from_netmask_code[code_unfold]:\n    fixes addr :: ipv4addr\n    shows \"addr \\<in> (ipset_from_netmask base netmask) \\<longleftrightarrow>\n            (base AND netmask) \\<le> addr \\<and> addr \\<le> (base AND netmask) OR (NOT netmask)\"", "lemma addr_in_ipv4set_from_cidr_code[code_unfold]:\n    fixes addr :: ipv4addr\n    shows \"addr \\<in> (ipset_from_cidr pre len) \\<longleftrightarrow>\n              (pre AND ((mask len) << (32 - len))) \\<le> addr \\<and> addr \\<le> pre OR (mask (32 - len))\"", "lemma \"ipv4addr_of_dotdecimal (192,168,42,8) \\<in> (ipset_from_cidr (ipv4addr_of_dotdecimal (192,168,0,0)) 16)\"", "lemma ipv4range_UNIV_set_eq: \"wordinterval_to_set ipv4range_UNIV = UNIV\"", "lemma ipv4cidr_to_interval_simps[code_unfold]: \"ipcidr_to_interval ((pre::ipv4addr), len) = (\n      let netmask = (mask len) << (32 - len);\n          network_prefix = (pre AND netmask)\n      in (network_prefix, network_prefix OR (NOT netmask)))\""], "translations": [["", "lemma take_bit_word_beyond_length_eq:\n  \\<open>take_bit n w = w\\<close> if \\<open>LENGTH('a) \\<le> n\\<close> for w :: \\<open>'a::len word\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_bit n w = w", "using that"], ["proof (prove)\nusing this:\n  LENGTH('a) \\<le> n\n\ngoal (1 subgoal):\n 1. take_bit n w = w", "by transfer simp"], ["", "section \\<open>IPv4 Adresses\\<close>"], ["", "text\\<open>An IPv4 address is basically a 32 bit unsigned integer.\\<close>"], ["", "type_synonym ipv4addr = \"32 word\""], ["", "text\\<open>Conversion between natural numbers and IPv4 adresses\\<close>"], ["", "definition nat_of_ipv4addr :: \"ipv4addr \\<Rightarrow> nat\" where\n    \"nat_of_ipv4addr a = unat a\""], ["", "definition ipv4addr_of_nat :: \"nat \\<Rightarrow> ipv4addr\" where\n    \"ipv4addr_of_nat n =  of_nat n\""], ["", "text\\<open>The maximum IPv4 addres\\<close>"], ["", "definition max_ipv4_addr :: \"ipv4addr\" where\n    \"max_ipv4_addr \\<equiv> ipv4addr_of_nat ((2^32) - 1)\""], ["", "lemma max_ipv4_addr_number: \"max_ipv4_addr = 4294967295\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_ipv4_addr = 4294967295", "unfolding max_ipv4_addr_def ipv4addr_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_nat (2 ^ 32 - 1) = 4294967295", "by(simp)"], ["", "lemma \"max_ipv4_addr = 0b11111111111111111111111111111111\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_ipv4_addr = 4294967295", "by(fact max_ipv4_addr_number)"], ["", "lemma max_ipv4_addr_max_word: \"max_ipv4_addr = max_word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_ipv4_addr = - 1", "by(simp add: max_ipv4_addr_number)"], ["", "lemma max_ipv4_addr_max[simp]: \"\\<forall>a. a \\<le> max_ipv4_addr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. a \\<le> max_ipv4_addr", "by(simp add: max_ipv4_addr_max_word)"], ["", "lemma UNIV_ipv4addrset: \"UNIV = {0 .. max_ipv4_addr}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {0..max_ipv4_addr}", "(*not in the simp set, for a reason*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {0..max_ipv4_addr}", "by(simp add: max_ipv4_addr_max_word) fastforce"], ["", "text\\<open>identity functions\\<close>"], ["", "lemma nat_of_ipv4addr_ipv4addr_of_nat_mod: \"nat_of_ipv4addr (ipv4addr_of_nat n) = n mod 2^32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_ipv4addr (ipv4addr_of_nat n) = n mod 2 ^ 32", "by (simp add: ipv4addr_of_nat_def nat_of_ipv4addr_def unat_of_nat take_bit_eq_mod)"], ["", "lemma nat_of_ipv4addr_ipv4addr_of_nat:\n    \"\\<lbrakk> n \\<le> nat_of_ipv4addr max_ipv4_addr \\<rbrakk> \\<Longrightarrow> nat_of_ipv4addr (ipv4addr_of_nat n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> nat_of_ipv4addr max_ipv4_addr \\<Longrightarrow>\n    nat_of_ipv4addr (ipv4addr_of_nat n) = n", "by (simp add: nat_of_ipv4addr_ipv4addr_of_nat_mod max_ipv4_addr_def)"], ["", "lemma ipv4addr_of_nat_nat_of_ipv4addr: \"ipv4addr_of_nat (nat_of_ipv4addr addr) = addr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_nat (nat_of_ipv4addr addr) = addr", "by(simp add: ipv4addr_of_nat_def nat_of_ipv4addr_def)"], ["", "subsection\\<open>Representing IPv4 Adresses (Syntax)\\<close>"], ["", "fun ipv4addr_of_dotdecimal :: \"nat \\<times> nat \\<times> nat \\<times> nat \\<Rightarrow> ipv4addr\" where\n    \"ipv4addr_of_dotdecimal (a,b,c,d) = ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a )\""], ["", "fun dotdecimal_of_ipv4addr :: \"ipv4addr \\<Rightarrow> nat \\<times> nat \\<times> nat \\<times> nat\" where\n    \"dotdecimal_of_ipv4addr a = (nat_of_ipv4addr ((a >> 24) AND 0xFF),\n                                    nat_of_ipv4addr ((a >> 16) AND 0xFF),\n                                    nat_of_ipv4addr ((a >> 8) AND 0xFF),\n                                    nat_of_ipv4addr (a AND 0xff))\""], ["", "declare ipv4addr_of_dotdecimal.simps[simp del]"], ["", "declare dotdecimal_of_ipv4addr.simps[simp del]"], ["", "text\\<open>Examples:\\<close>"], ["", "lemma \"ipv4addr_of_dotdecimal (192, 168, 0, 1) = 3232235521\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (192, 168, 0, 1) = 3232235521", "by(simp add: ipv4addr_of_dotdecimal.simps ipv4addr_of_nat_def)"], ["", "(*could be solved by eval, but needs \"HOL-Library.Code_Target_Nat\"*)"], ["", "lemma \"dotdecimal_of_ipv4addr 3232235521 = (192, 168, 0, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dotdecimal_of_ipv4addr 3232235521 = (192, 168, 0, 1)", "by(simp add: dotdecimal_of_ipv4addr.simps nat_of_ipv4addr_def)"], ["", "text\\<open>a different notation for @{term ipv4addr_of_dotdecimal}\\<close>"], ["", "lemma ipv4addr_of_dotdecimal_bit:\n    \"ipv4addr_of_dotdecimal (a,b,c,d) =\n      (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n       (ipv4addr_of_nat c << 8) + ipv4addr_of_nat d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (a, b, c, d) =\n    (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n    (ipv4addr_of_nat c << 8) +\n    ipv4addr_of_nat d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (a, b, c, d) =\n    (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n    (ipv4addr_of_nat c << 8) +\n    ipv4addr_of_nat d", "have a: \"(ipv4addr_of_nat a) << 24 = ipv4addr_of_nat (a * 16777216)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_nat a << 24 = ipv4addr_of_nat (a * 16777216)", "by(simp add: ipv4addr_of_nat_def shiftl_t2n)"], ["proof (state)\nthis:\n  ipv4addr_of_nat a << 24 = ipv4addr_of_nat (a * 16777216)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (a, b, c, d) =\n    (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n    (ipv4addr_of_nat c << 8) +\n    ipv4addr_of_nat d", "have b: \"(ipv4addr_of_nat b) << 16 = ipv4addr_of_nat (b * 65536)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_nat b << 16 = ipv4addr_of_nat (b * 65536)", "by(simp add: ipv4addr_of_nat_def shiftl_t2n)"], ["proof (state)\nthis:\n  ipv4addr_of_nat b << 16 = ipv4addr_of_nat (b * 65536)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (a, b, c, d) =\n    (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n    (ipv4addr_of_nat c << 8) +\n    ipv4addr_of_nat d", "have c: \"(ipv4addr_of_nat c) << 8 = ipv4addr_of_nat (c * 256)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_nat c << 8 = ipv4addr_of_nat (c * 256)", "by(simp add: ipv4addr_of_nat_def shiftl_t2n)"], ["proof (state)\nthis:\n  ipv4addr_of_nat c << 8 = ipv4addr_of_nat (c * 256)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (a, b, c, d) =\n    (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n    (ipv4addr_of_nat c << 8) +\n    ipv4addr_of_nat d", "have ipv4addr_of_nat_suc: \"\\<And>x. ipv4addr_of_nat (Suc x) = word_succ (ipv4addr_of_nat (x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. ipv4addr_of_nat (Suc x) = word_succ (ipv4addr_of_nat x)", "by(simp add: ipv4addr_of_nat_def, metis Abs_fnat_hom_Suc of_nat_Suc)"], ["proof (state)\nthis:\n  ipv4addr_of_nat (Suc ?x) = word_succ (ipv4addr_of_nat ?x)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (a, b, c, d) =\n    (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n    (ipv4addr_of_nat c << 8) +\n    ipv4addr_of_nat d", "{"], ["proof (state)\nthis:\n  ipv4addr_of_nat (Suc ?x) = word_succ (ipv4addr_of_nat ?x)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (a, b, c, d) =\n    (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n    (ipv4addr_of_nat c << 8) +\n    ipv4addr_of_nat d", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (a, b, c, d) =\n    (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n    (ipv4addr_of_nat c << 8) +\n    ipv4addr_of_nat d", "have \"ipv4addr_of_nat x + ipv4addr_of_nat y = ipv4addr_of_nat (x+y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_nat x + ipv4addr_of_nat y = ipv4addr_of_nat (x + y)", "apply(induction x arbitrary: y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y. ipv4addr_of_nat 0 + ipv4addr_of_nat y = ipv4addr_of_nat (0 + y)\n 2. \\<And>x y.\n       (\\<And>y.\n           ipv4addr_of_nat x + ipv4addr_of_nat y =\n           ipv4addr_of_nat (x + y)) \\<Longrightarrow>\n       ipv4addr_of_nat (Suc x) + ipv4addr_of_nat y =\n       ipv4addr_of_nat (Suc x + y)", "apply(simp add: ipv4addr_of_nat_def; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (\\<And>y.\n           ipv4addr_of_nat x + ipv4addr_of_nat y =\n           ipv4addr_of_nat (x + y)) \\<Longrightarrow>\n       ipv4addr_of_nat (Suc x) + ipv4addr_of_nat y =\n       ipv4addr_of_nat (Suc x + y)", "by(simp add: ipv4addr_of_nat_suc word_succ_p1)"], ["proof (state)\nthis:\n  ipv4addr_of_nat x + ipv4addr_of_nat y = ipv4addr_of_nat (x + y)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (a, b, c, d) =\n    (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n    (ipv4addr_of_nat c << 8) +\n    ipv4addr_of_nat d", "}"], ["proof (state)\nthis:\n  ipv4addr_of_nat ?x2 + ipv4addr_of_nat ?y2 = ipv4addr_of_nat (?x2 + ?y2)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (a, b, c, d) =\n    (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n    (ipv4addr_of_nat c << 8) +\n    ipv4addr_of_nat d", "from this a b c"], ["proof (chain)\npicking this:\n  ipv4addr_of_nat ?x2 + ipv4addr_of_nat ?y2 = ipv4addr_of_nat (?x2 + ?y2)\n  ipv4addr_of_nat a << 24 = ipv4addr_of_nat (a * 16777216)\n  ipv4addr_of_nat b << 16 = ipv4addr_of_nat (b * 65536)\n  ipv4addr_of_nat c << 8 = ipv4addr_of_nat (c * 256)", "show ?thesis"], ["proof (prove)\nusing this:\n  ipv4addr_of_nat ?x2 + ipv4addr_of_nat ?y2 = ipv4addr_of_nat (?x2 + ?y2)\n  ipv4addr_of_nat a << 24 = ipv4addr_of_nat (a * 16777216)\n  ipv4addr_of_nat b << 16 = ipv4addr_of_nat (b * 65536)\n  ipv4addr_of_nat c << 8 = ipv4addr_of_nat (c * 256)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (a, b, c, d) =\n    (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n    (ipv4addr_of_nat c << 8) +\n    ipv4addr_of_nat d", "apply(simp add: ipv4addr_of_dotdecimal.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                ipv4addr_of_nat x + ipv4addr_of_nat y =\n                ipv4addr_of_nat (x + y);\n     ipv4addr_of_nat a << 24 = ipv4addr_of_nat (a * 16777216);\n     ipv4addr_of_nat b << 16 = ipv4addr_of_nat (b * 65536);\n     ipv4addr_of_nat c << 8 = ipv4addr_of_nat (c * 256)\\<rbrakk>\n    \\<Longrightarrow> ipv4addr_of_nat\n                       (d + 256 * c + 65536 * b + 16777216 * a) =\n                      ipv4addr_of_nat\n                       (a * 16777216 + b * 65536 + c * 256 + d)", "apply(rule arg_cong[where f=ipv4addr_of_nat])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                ipv4addr_of_nat x + ipv4addr_of_nat y =\n                ipv4addr_of_nat (x + y);\n     ipv4addr_of_nat a << 24 = ipv4addr_of_nat (a * 16777216);\n     ipv4addr_of_nat b << 16 = ipv4addr_of_nat (b * 65536);\n     ipv4addr_of_nat c << 8 = ipv4addr_of_nat (c * 256)\\<rbrakk>\n    \\<Longrightarrow> d + 256 * c + 65536 * b + 16777216 * a =\n                      a * 16777216 + b * 65536 + c * 256 + d", "apply(thin_tac _)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        ipv4addr_of_nat x + ipv4addr_of_nat y =\n        ipv4addr_of_nat (x + y)) \\<Longrightarrow>\n    d + 256 * c + 65536 * b + 16777216 * a =\n    a * 16777216 + b * 65536 + c * 256 + d", "by presburger"], ["proof (state)\nthis:\n  ipv4addr_of_dotdecimal (a, b, c, d) =\n  (ipv4addr_of_nat a << 24) + (ipv4addr_of_nat b << 16) +\n  (ipv4addr_of_nat c << 8) +\n  ipv4addr_of_nat d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma size_ipv4addr: \"size (x::ipv4addr) = 32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size x = 32", "by(simp add:word_size)"], ["", "lemma dotdecimal_of_ipv4addr_ipv4addr_of_dotdecimal:\n  \"\\<lbrakk> a < 256; b < 256; c < 256; d < 256 \\<rbrakk> \\<Longrightarrow>\n    dotdecimal_of_ipv4addr (ipv4addr_of_dotdecimal (a,b,c,d)) = (a,b,c,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> dotdecimal_of_ipv4addr\n                       (ipv4addr_of_dotdecimal (a, b, c, d)) =\n                      (a, b, c, d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> dotdecimal_of_ipv4addr\n                       (ipv4addr_of_dotdecimal (a, b, c, d)) =\n                      (a, b, c, d)", "assume  \"a < 256\" and \"b < 256\" and \"c < 256\" and \"d < 256\""], ["proof (state)\nthis:\n  a < 256\n  b < 256\n  c < 256\n  d < 256\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> dotdecimal_of_ipv4addr\n                       (ipv4addr_of_dotdecimal (a, b, c, d)) =\n                      (a, b, c, d)", "note assms= \\<open>a < 256\\<close> \\<open>b < 256\\<close> \\<open>c < 256\\<close> \\<open>d < 256\\<close>"], ["proof (state)\nthis:\n  a < 256\n  b < 256\n  c < 256\n  d < 256\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> dotdecimal_of_ipv4addr\n                       (ipv4addr_of_dotdecimal (a, b, c, d)) =\n                      (a, b, c, d)", "hence a:  \"nat_of_ipv4addr ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 24) AND mask 8) = a\""], ["proof (prove)\nusing this:\n  a < 256\n  b < 256\n  c < 256\n  d < 256\n\ngoal (1 subgoal):\n 1. nat_of_ipv4addr\n     ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 24) &&\n      mask 8) =\n    a", "apply (simp add: ipv4addr_of_nat_def nat_of_ipv4addr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> unat\n                       ((word_of_nat d + 256 * word_of_nat c +\n                         65536 * word_of_nat b +\n                         16777216 * word_of_nat a >>\n                         24) &&\n                        mask 8) =\n                      a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n       \\<Longrightarrow> (nat \\<circ> take_bit LENGTH(32))\n                          ((drop_bit 24 \\<circ> take_bit LENGTH(32))\n                            (int d + 256 * int c + 65536 * int b +\n                             16777216 * int a) AND\n                           mask 8) =\n                         a", "apply (simp add: drop_bit_take_bit nat_take_bit_eq flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n       \\<Longrightarrow> take_bit 8\n                          (nat (drop_bit 24\n                                 (int d + 256 * int c + 65536 * int b +\n                                  16777216 * int a))) =\n                         a", "apply (simp add: drop_bit_eq_div take_bit_eq_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nat_of_ipv4addr\n   ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 24) &&\n    mask 8) =\n  a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> dotdecimal_of_ipv4addr\n                       (ipv4addr_of_dotdecimal (a, b, c, d)) =\n                      (a, b, c, d)", "have ipv4addr_of_nat_AND_mask8: \"(ipv4addr_of_nat a) AND mask 8 = (ipv4addr_of_nat (a mod 256))\"\n      for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_nat a && mask 8 = ipv4addr_of_nat (a mod 256)", "apply (simp add: ipv4addr_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_nat a && mask 8 = word_of_nat (a mod 256)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       take_bit LENGTH(32) (int a AND mask 8) =\n       take_bit LENGTH(32) (int (a mod 256))", "apply (simp flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. take_bit 8 (int a) = take_bit 32 (int (a mod 256))", "apply (simp add: take_bit_eq_mod of_nat_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ipv4addr_of_nat ?a && mask 8 = ipv4addr_of_nat (?a mod 256)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> dotdecimal_of_ipv4addr\n                       (ipv4addr_of_dotdecimal (a, b, c, d)) =\n                      (a, b, c, d)", "from assms"], ["proof (chain)\npicking this:\n  a < 256\n  b < 256\n  c < 256\n  d < 256", "have b:\n      \"nat_of_ipv4addr ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 16) AND mask 8) = b\""], ["proof (prove)\nusing this:\n  a < 256\n  b < 256\n  c < 256\n  d < 256\n\ngoal (1 subgoal):\n 1. nat_of_ipv4addr\n     ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 16) &&\n      mask 8) =\n    b", "apply (simp add: ipv4addr_of_nat_def nat_of_ipv4addr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> unat\n                       ((word_of_nat d + 256 * word_of_nat c +\n                         65536 * word_of_nat b +\n                         16777216 * word_of_nat a >>\n                         16) &&\n                        mask 8) =\n                      b", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n       \\<Longrightarrow> (nat \\<circ> take_bit LENGTH(32))\n                          ((drop_bit 16 \\<circ> take_bit LENGTH(32))\n                            (int d + 256 * int c + 65536 * int b +\n                             16777216 * int a) AND\n                           mask 8) =\n                         b", "apply (simp add: drop_bit_take_bit flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n       \\<Longrightarrow> nat (take_bit 8\n                               (drop_bit 16\n                                 (int d + 256 * int c + 65536 * int b +\n                                  16777216 * int a))) =\n                         b", "using div65536"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < 256; ?b < 256; ?c < 256; ?d < 256\\<rbrakk>\n  \\<Longrightarrow> nat ((int ?d + int (256 * ?c) + int (65536 * ?b) +\n                          int (16777216 * ?a)) div\n                         65536 mod\n                         256) =\n                    ?b\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n       \\<Longrightarrow> nat (take_bit 8\n                               (drop_bit 16\n                                 (int d + 256 * int c + 65536 * int b +\n                                  16777216 * int a))) =\n                         b", "apply (simp add: drop_bit_eq_div take_bit_eq_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nat_of_ipv4addr\n   ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 16) &&\n    mask 8) =\n  b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> dotdecimal_of_ipv4addr\n                       (ipv4addr_of_dotdecimal (a, b, c, d)) =\n                      (a, b, c, d)", "from assms"], ["proof (chain)\npicking this:\n  a < 256\n  b < 256\n  c < 256\n  d < 256", "have c:\n      \"nat_of_ipv4addr ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 8) AND mask 8) = c\""], ["proof (prove)\nusing this:\n  a < 256\n  b < 256\n  c < 256\n  d < 256\n\ngoal (1 subgoal):\n 1. nat_of_ipv4addr\n     ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 8) &&\n      mask 8) =\n    c", "apply (simp add: ipv4addr_of_nat_def nat_of_ipv4addr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> unat\n                       ((word_of_nat d + 256 * word_of_nat c +\n                         65536 * word_of_nat b +\n                         16777216 * word_of_nat a >>\n                         8) &&\n                        mask 8) =\n                      c", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n       \\<Longrightarrow> (nat \\<circ> take_bit LENGTH(32))\n                          ((drop_bit 8 \\<circ> take_bit LENGTH(32))\n                            (int d + 256 * int c + 65536 * int b +\n                             16777216 * int a) AND\n                           mask 8) =\n                         c", "apply (simp add: drop_bit_take_bit flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n       \\<Longrightarrow> nat (take_bit 8\n                               (drop_bit 8\n                                 (int d + 256 * int c + 65536 * int b +\n                                  16777216 * int a))) =\n                         c", "using div256"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < 256; ?b < 256; ?c < 256; ?d < 256\\<rbrakk>\n  \\<Longrightarrow> nat ((int ?d + int (256 * ?c) + int (65536 * ?b) +\n                          int (16777216 * ?a)) div\n                         256 mod\n                         256) =\n                    ?c\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n       \\<Longrightarrow> nat (take_bit 8\n                               (drop_bit 8\n                                 (int d + 256 * int c + 65536 * int b +\n                                  16777216 * int a))) =\n                         c", "apply (simp add: drop_bit_eq_div take_bit_eq_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nat_of_ipv4addr\n   ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 8) &&\n    mask 8) =\n  c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> dotdecimal_of_ipv4addr\n                       (ipv4addr_of_dotdecimal (a, b, c, d)) =\n                      (a, b, c, d)", "from \\<open>d < 256\\<close>"], ["proof (chain)\npicking this:\n  d < 256", "have d: \"nat_of_ipv4addr (ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) AND mask 8) = d\""], ["proof (prove)\nusing this:\n  d < 256\n\ngoal (1 subgoal):\n 1. nat_of_ipv4addr\n     (ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) && mask 8) =\n    d", "apply (simp add: ipv4addr_of_nat_AND_mask8 ipv4addr_of_nat_def nat_of_ipv4addr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d < 256 \\<Longrightarrow>\n    unat\n     (word_of_nat d + 256 * word_of_nat c + 65536 * word_of_nat b +\n      16777216 * word_of_nat a &&\n      mask 8) =\n    d", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d c b a.\n       d < 256 \\<Longrightarrow>\n       (nat \\<circ> take_bit LENGTH(32))\n        (int d + 256 * int c + 65536 * int b + 16777216 * int a AND\n         mask 8) =\n       d", "apply (simp flip: take_bit_eq_mask)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d c b a.\n       d < 256 \\<Longrightarrow>\n       nat (take_bit 8\n             (int d + 256 * int c + 65536 * int b + 16777216 * int a)) =\n       d", "apply (simp add: take_bit_eq_mod nat_mod_distrib nat_add_distrib nat_mult_distrib mod256)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nat_of_ipv4addr\n   (ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) && mask 8) =\n  d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 256; b < 256; c < 256; d < 256\\<rbrakk>\n    \\<Longrightarrow> dotdecimal_of_ipv4addr\n                       (ipv4addr_of_dotdecimal (a, b, c, d)) =\n                      (a, b, c, d)", "from a b c d"], ["proof (chain)\npicking this:\n  nat_of_ipv4addr\n   ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 24) &&\n    mask 8) =\n  a\n  nat_of_ipv4addr\n   ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 16) &&\n    mask 8) =\n  b\n  nat_of_ipv4addr\n   ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 8) &&\n    mask 8) =\n  c\n  nat_of_ipv4addr\n   (ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) && mask 8) =\n  d", "show ?thesis"], ["proof (prove)\nusing this:\n  nat_of_ipv4addr\n   ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 24) &&\n    mask 8) =\n  a\n  nat_of_ipv4addr\n   ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 16) &&\n    mask 8) =\n  b\n  nat_of_ipv4addr\n   ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 8) &&\n    mask 8) =\n  c\n  nat_of_ipv4addr\n   (ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) && mask 8) =\n  d\n\ngoal (1 subgoal):\n 1. dotdecimal_of_ipv4addr (ipv4addr_of_dotdecimal (a, b, c, d)) =\n    (a, b, c, d)", "apply (simp add: ipv4addr_of_dotdecimal.simps dotdecimal_of_ipv4addr.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nat_of_ipv4addr\n              ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >>\n                24) &&\n               mask 8) =\n             a;\n     nat_of_ipv4addr\n      ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 16) &&\n       mask 8) =\n     b;\n     nat_of_ipv4addr\n      ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) >> 8) &&\n       mask 8) =\n     c;\n     nat_of_ipv4addr\n      (ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) && mask 8) =\n     d\\<rbrakk>\n    \\<Longrightarrow> nat_of_ipv4addr\n                       ((ipv4addr_of_nat\n                          (d + 256 * c + 65536 * b + 16777216 * a) >>\n                         24) &&\n                        255) =\n                      a \\<and>\n                      nat_of_ipv4addr\n                       ((ipv4addr_of_nat\n                          (d + 256 * c + 65536 * b + 16777216 * a) >>\n                         16) &&\n                        255) =\n                      b \\<and>\n                      nat_of_ipv4addr\n                       ((ipv4addr_of_nat\n                          (d + 256 * c + 65536 * b + 16777216 * a) >>\n                         8) &&\n                        255) =\n                      c \\<and>\n                      nat_of_ipv4addr\n                       (ipv4addr_of_nat\n                         (d + 256 * c + 65536 * b + 16777216 * a) &&\n                        255) =\n                      d", "apply (simp add: mask_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dotdecimal_of_ipv4addr (ipv4addr_of_dotdecimal (a, b, c, d)) =\n  (a, b, c, d)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipv4addr_of_dotdecimal_dotdecimal_of_ipv4addr:\n    \"(ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip)) = ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "have ip_and_mask8_bl_drop24: \"(ip::ipv4addr) AND mask 8 = of_bl (drop 24 (to_bl ip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip && mask 8 = of_bl (drop 24 (to_bl ip))", "by(simp add: of_drop_to_bl size_ipv4addr)"], ["proof (state)\nthis:\n  ip && mask 8 = of_bl (drop 24 (to_bl ip))\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "have List_rev_drop_geqn: \"length x \\<ge> n \\<Longrightarrow> (take n (rev x)) = rev (drop (length x - n) x)\"\n      for x :: \"'a list\" and n"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length x \\<Longrightarrow>\n    take n (rev x) = rev (drop (length x - n) x)", "by(simp add: List.rev_drop)"], ["proof (state)\nthis:\n  ?n1 \\<le> length ?x1 \\<Longrightarrow>\n  take ?n1 (rev ?x1) = rev (drop (length ?x1 - ?n1) ?x1)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "have and_mask_bl_take: \"length x \\<ge> n \\<Longrightarrow> ((of_bl x) AND mask n) = (of_bl (rev (take n (rev (x)))))\"\n      for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length x \\<Longrightarrow>\n    of_bl x && mask n = of_bl (rev (take n (rev x)))", "by(simp add: List_rev_drop_geqn of_bl_drop)"], ["proof (state)\nthis:\n  ?n2 \\<le> length ?x2 \\<Longrightarrow>\n  of_bl ?x2 && mask ?n2 = of_bl (rev (take ?n2 (rev ?x2)))\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "have ipv4addr_and_255: \"x AND 255 = x AND mask 8\" for x :: ipv4addr"], ["proof (prove)\ngoal (1 subgoal):\n 1. x && 255 = x && mask 8", "by(simp add: mask_eq)"], ["proof (state)\nthis:\n  ?x2 && 255 = ?x2 && mask 8\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "have bit_equality:\n      \"((ip >> 24) AND 0xFF << 24) + ((ip >> 16) AND 0xFF << 16) + ((ip >> 8) AND 0xFF << 8) + (ip AND 0xFF) =\n       of_bl (take 8 (to_bl ip) @ take 8 (drop 8 (to_bl ip)) @ take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ip >> 24) && 255 << 24) + ((ip >> 16) && 255 << 16) +\n    ((ip >> 8) && 255 << 8) +\n    (ip && 255) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))", "apply(simp add: ipv4addr_and_255)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ip >> 24) && mask 8 << 24) + ((ip >> 16) && mask 8 << 16) +\n    ((ip >> 8) && mask 8 << 8) +\n    (ip && mask 8) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))", "apply(simp add: shiftr_slice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (slice 24 ip && mask 8 << 24) + (slice 16 ip && mask 8 << 16) +\n    (slice 8 ip && mask 8 << 8) +\n    (ip && mask 8) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))", "apply(simp add: slice_take' size_ipv4addr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_bl (take 8 (to_bl ip)) && mask 8 << 24) +\n    (of_bl (take 16 (to_bl ip)) && mask 8 << 16) +\n    (of_bl (take 24 (to_bl ip)) && mask 8 << 8) +\n    (ip && mask 8) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))", "apply(simp add: and_mask_bl_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_bl (take 8 (to_bl ip)) << 24) +\n    (of_bl (rev (take 8 (rev (take 16 (to_bl ip))))) << 16) +\n    (of_bl (rev (take 8 (rev (take 24 (to_bl ip))))) << 8) +\n    (ip && mask 8) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))", "apply(simp add: List_rev_drop_geqn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_bl (take 8 (to_bl ip)) << 24) +\n    (of_bl (drop 8 (take 16 (to_bl ip))) << 16) +\n    (of_bl (drop 16 (take 24 (to_bl ip))) << 8) +\n    (ip && mask 8) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))", "apply(simp add: drop_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_bl (take 8 (to_bl ip)) << 24) +\n    (of_bl (take 8 (drop 8 (to_bl ip))) << 16) +\n    (of_bl (take 8 (drop 16 (to_bl ip))) << 8) +\n    (ip && mask 8) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))", "apply(simp add: shiftl_of_bl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bl (take 8 (to_bl ip) @ replicate 24 False) +\n    of_bl (take 8 (drop 8 (to_bl ip)) @ replicate 16 False) +\n    of_bl (take 8 (drop 16 (to_bl ip)) @ replicate 8 False) +\n    (ip && mask 8) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))", "apply(simp add: of_bl_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ip && mask 8 = of_bl (drop 24 (to_bl ip))", "apply(simp add: ip_and_mask8_bl_drop24)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((ip >> 24) && 255 << 24) + ((ip >> 16) && 255 << 16) +\n  ((ip >> 8) && 255 << 8) +\n  (ip && 255) =\n  of_bl\n   (take 8 (to_bl ip) @\n    take 8 (drop 8 (to_bl ip)) @\n    take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "have blip_split: \"\\<And> blip. length blip = 32 \\<Longrightarrow>\n      blip = (take 8 blip) @ (take 8 (drop 8 blip)) @ (take 8 (drop 16 blip)) @ (take 8 (drop 24 blip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>blip.\n       length blip = 32 \\<Longrightarrow>\n       blip =\n       take 8 blip @\n       take 8 (drop 8 blip) @ take 8 (drop 16 blip) @ take 8 (drop 24 blip)", "by(rename_tac blip,case_tac blip,simp_all)+"], ["proof (state)\nthis:\n  length ?blip2 = 32 \\<Longrightarrow>\n  ?blip2 =\n  take 8 ?blip2 @\n  take 8 (drop 8 ?blip2) @ take 8 (drop 16 ?blip2) @ take 8 (drop 24 ?blip2)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "(*I'm so sorry for this ...*)"], ["proof (state)\nthis:\n  length ?blip2 = 32 \\<Longrightarrow>\n  ?blip2 =\n  take 8 ?blip2 @\n  take 8 (drop 8 ?blip2) @ take 8 (drop 16 ?blip2) @ take 8 (drop 24 ?blip2)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "have \"ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = of_bl (to_bl ip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = of_bl (to_bl ip)", "apply(subst blip_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (to_bl ip) = 32\n 2. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ take 8 (drop 24 (to_bl ip)))", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ take 8 (drop 24 (to_bl ip)))", "apply(simp add: ipv4addr_of_dotdecimal_bit dotdecimal_of_ipv4addr.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipv4addr_of_nat (nat_of_ipv4addr ((ip >> 24) && 255)) << 24) +\n    (ipv4addr_of_nat (nat_of_ipv4addr ((ip >> 16) && 255)) << 16) +\n    (ipv4addr_of_nat (nat_of_ipv4addr ((ip >> 8) && 255)) << 8) +\n    ipv4addr_of_nat (nat_of_ipv4addr (ip && 255)) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))", "apply(simp add: ipv4addr_of_nat_nat_of_ipv4addr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ip >> 24) && 255 << 24) + ((ip >> 16) && 255 << 16) +\n    ((ip >> 8) && 255 << 8) +\n    (ip && 255) =\n    of_bl\n     (take 8 (to_bl ip) @\n      take 8 (drop 8 (to_bl ip)) @\n      take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))", "apply(simp add: bit_equality)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = of_bl (to_bl ip)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "thus ?thesis"], ["proof (prove)\nusing this:\n  ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = of_bl (to_bl ip)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "using word_bl.Rep_inverse[symmetric]"], ["proof (prove)\nusing this:\n  ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = of_bl (to_bl ip)\n  ?t = of_bl (to_bl ?t)\n\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip", "by simp"], ["proof (state)\nthis:\n  ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = ip\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipv4addr_of_dotdecimal_eqE:\n    \"\\<lbrakk> ipv4addr_of_dotdecimal (a,b,c,d) = ipv4addr_of_dotdecimal (e,f,g,h);\n       a < 256; b < 256; c < 256; d < 256; e < 256; f < 256; g < 256; h < 256 \\<rbrakk> \\<Longrightarrow>\n         a = e \\<and> b = f \\<and> c = g \\<and> d = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipv4addr_of_dotdecimal (a, b, c, d) =\n             ipv4addr_of_dotdecimal (e, f, g, h);\n     a < 256; b < 256; c < 256; d < 256; e < 256; f < 256; g < 256;\n     h < 256\\<rbrakk>\n    \\<Longrightarrow> a = e \\<and> b = f \\<and> c = g \\<and> d = h", "by (metis Pair_inject dotdecimal_of_ipv4addr_ipv4addr_of_dotdecimal)"], ["", "subsection\\<open>IP Ranges: Examples\\<close>"], ["", "lemma \"(UNIV :: ipv4addr set) = {0 .. max_ipv4_addr}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {0..max_ipv4_addr}", "by(simp add: UNIV_ipv4addrset)"], ["", "lemma \"(42::ipv4addr) \\<in> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 42 \\<in> UNIV", "by(simp)"], ["", "(*Warning, not executable!*)"], ["", "lemma \"ipset_from_netmask (ipv4addr_of_dotdecimal (192,168,0,42)) (ipv4addr_of_dotdecimal (255,255,0,0)) =\n          {ipv4addr_of_dotdecimal (192,168,0,0) .. ipv4addr_of_dotdecimal (192,168,255,255)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_netmask (ipv4addr_of_dotdecimal (192, 168, 0, 42))\n     (ipv4addr_of_dotdecimal (255, 255, 0, 0)) =\n    {ipv4addr_of_dotdecimal\n      (192, 168, 0, 0)..ipv4addr_of_dotdecimal (192, 168, 255, 255)}", "by(simp add: ipset_from_netmask_def ipv4addr_of_dotdecimal.simps ipv4addr_of_nat_def)"], ["", "lemma \"ipset_from_netmask (ipv4addr_of_dotdecimal (192,168,0,42)) (ipv4addr_of_dotdecimal (0,0,0,0)) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_netmask (ipv4addr_of_dotdecimal (192, 168, 0, 42))\n     (ipv4addr_of_dotdecimal (0, 0, 0, 0)) =\n    UNIV", "by(simp add: UNIV_ipv4addrset ipset_from_netmask_def ipv4addr_of_dotdecimal.simps\n                 ipv4addr_of_nat_def max_ipv4_addr_max_word)"], ["", "text\\<open>192.168.0.0/24\\<close>"], ["", "lemma fixes addr :: ipv4addr\n    shows \"ipset_from_cidr addr pflength =\n            ipset_from_netmask addr ((mask pflength) << (32 - pflength))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr addr pflength =\n    ipset_from_netmask addr (mask pflength << 32 - pflength)", "by(simp add: ipset_from_cidr_def)"], ["", "lemma \"ipset_from_cidr (ipv4addr_of_dotdecimal (192,168,0,42)) 16 =\n          {ipv4addr_of_dotdecimal (192,168,0,0) .. ipv4addr_of_dotdecimal (192,168,255,255)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 42)) 16 =\n    {ipv4addr_of_dotdecimal\n      (192, 168, 0, 0)..ipv4addr_of_dotdecimal (192, 168, 255, 255)}", "by(simp add: ipset_from_cidr_alt mask_eq ipv4addr_of_dotdecimal.simps ipv4addr_of_nat_def)"], ["", "lemma \"ip \\<in> (ipset_from_cidr (ipv4addr_of_dotdecimal (0, 0, 0, 0)) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip \\<in> ipset_from_cidr (ipv4addr_of_dotdecimal (0, 0, 0, 0)) 0", "by(simp add: ipset_from_cidr_0)"], ["", "lemma ipv4set_from_cidr_32: fixes addr :: ipv4addr\n    shows \"ipset_from_cidr addr 32 = {addr}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr addr 32 = {addr}", "by (simp add: ipset_from_cidr_alt take_bit_word_beyond_length_eq flip: take_bit_eq_mask)"], ["", "lemma  fixes pre :: ipv4addr\n    shows \"ipset_from_cidr pre len = {(pre AND ((mask len) << (32 - len))) .. pre OR (mask (32 - len))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipset_from_cidr pre len =\n    {pre && (mask len << 32 - len)..pre || mask (32 - len)}", "by (simp add: ipset_from_cidr_alt ipset_from_cidr_def)"], ["", "text\\<open>making element check executable\\<close>"], ["", "lemma addr_in_ipv4set_from_netmask_code[code_unfold]:\n    fixes addr :: ipv4addr\n    shows \"addr \\<in> (ipset_from_netmask base netmask) \\<longleftrightarrow>\n            (base AND netmask) \\<le> addr \\<and> addr \\<le> (base AND netmask) OR (NOT netmask)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (addr \\<in> ipset_from_netmask base netmask) =\n    (base && netmask \\<le> addr \\<and>\n     addr \\<le> base && netmask || ~~ netmask)", "by (simp add: addr_in_ipset_from_netmask_code)"], ["", "lemma addr_in_ipv4set_from_cidr_code[code_unfold]:\n    fixes addr :: ipv4addr\n    shows \"addr \\<in> (ipset_from_cidr pre len) \\<longleftrightarrow>\n              (pre AND ((mask len) << (32 - len))) \\<le> addr \\<and> addr \\<le> pre OR (mask (32 - len))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (addr \\<in> ipset_from_cidr pre len) =\n    (pre && (mask len << 32 - len) \\<le> addr \\<and>\n     addr \\<le> pre || mask (32 - len))", "by(simp add: addr_in_ipset_from_cidr_code)"], ["", "(*small numbers because we didn't load Code_Target_Nat. Should work by eval*)"], ["", "lemma \"ipv4addr_of_dotdecimal (192,168,42,8) \\<in> (ipset_from_cidr (ipv4addr_of_dotdecimal (192,168,0,0)) 16)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipv4addr_of_dotdecimal (192, 168, 42, 8)\n    \\<in> ipset_from_cidr (ipv4addr_of_dotdecimal (192, 168, 0, 0)) 16", "by (simp add: ipv4addr_of_nat_def ipset_from_cidr_def ipv4addr_of_dotdecimal.simps\n    ipset_from_netmask_def mask_eq_exp_minus_1 word_le_def take_bit_minus_one_eq_mask)"], ["", "definition ipv4range_UNIV :: \"32 wordinterval\" where \"ipv4range_UNIV \\<equiv> wordinterval_UNIV\""], ["", "lemma ipv4range_UNIV_set_eq: \"wordinterval_to_set ipv4range_UNIV = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set ipv4range_UNIV = UNIV", "by(simp only: ipv4range_UNIV_def wordinterval_UNIV_set_eq)"], ["", "thm iffD1[OF wordinterval_eq_set_eq]"], ["", "(*TODO: probably the following is a good idea?*)\n  (*\n  declare iffD1[OF wordinterval_eq_set_eq, cong]\n  *)"], ["", "text\\<open>This \\<open>LENGTH('a)\\<close> is 32 for IPv4 addresses.\\<close>"], ["", "lemma ipv4cidr_to_interval_simps[code_unfold]: \"ipcidr_to_interval ((pre::ipv4addr), len) = (\n      let netmask = (mask len) << (32 - len);\n          network_prefix = (pre AND netmask)\n      in (network_prefix, network_prefix OR (NOT netmask)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_to_interval (pre, len) =\n    (let netmask = mask len << 32 - len; network_prefix = pre && netmask\n     in (network_prefix, network_prefix || ~~ netmask))", "by(simp add: ipcidr_to_interval_def Let_def ipcidr_to_interval_start.simps ipcidr_to_interval_end.simps)"], ["", "end"]]}