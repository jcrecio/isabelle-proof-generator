{"file_name": "/home/qj213/afp-2021-10-22/thys/IP_Addresses/WordInterval.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IP_Addresses", "problem_names": ["lemma wordinterval_element_set_eq[simp]:\n    \"wordinterval_element el rg = (el \\<in> wordinterval_to_set rg)\"", "lemma wordinterval_union_set_eq[simp]:\n    \"wordinterval_to_set (wordinterval_union r1 r2) = wordinterval_to_set r1 \\<union> wordinterval_to_set r2\"", "lemma wordinterval_empty_set_eq[simp]: \"wordinterval_empty r \\<longleftrightarrow> wordinterval_to_set r = {}\"", "lemma wordinterval_empty_Empty_WordInterval: \"wordinterval_empty Empty_WordInterval\"", "lemma Empty_WordInterval_set_eq[simp]: \"wordinterval_to_set Empty_WordInterval = {}\"", "lemma l2wi_append: \"wordinterval_to_set (l2wi (l1@l2)) =\n                      wordinterval_to_set (l2wi l1) \\<union> wordinterval_to_set (l2wi l2)\"", "lemma l2wi_wi2l[simp]: \"wordinterval_to_set (l2wi (wi2l r)) = wordinterval_to_set r\"", "lemma l2wi: \"wordinterval_to_set (l2wi l) = (\\<Union> (i,j) \\<in> set l. {i .. j})\"", "lemma wi2l: \"(\\<Union>(i,j)\\<in>set (wi2l r). {i .. j}) = wordinterval_to_set r\"", "lemma l2wi_remdups[simp]: \"wordinterval_to_set (l2wi (remdups ls)) = wordinterval_to_set (l2wi ls)\"", "lemma wi2l_empty[simp]: \"wi2l Empty_WordInterval = []\"", "lemma wordinterval_optimize_empty_set_eq[simp]:\n    \"wordinterval_to_set (wordinterval_optimize_empty r) = wordinterval_to_set r\"", "lemma wordinterval_optimize_empty_double:\n    \"wordinterval_optimize_empty (wordinterval_optimize_empty r) = wordinterval_optimize_empty r\"", "lemma helper_optimize_shallow:\n    \"wordinterval_empty_shallow (wordinterval_optimize_empty r) =\n      wordinterval_empty (wordinterval_optimize_empty r)\"", "lemma wordinterval_optimize_empty_code[code_unfold]:\n    \"wordinterval_optimize_empty = wordinterval_optimize_empty2\"", "lemma [code]:\n    \"not_disjoint_intervals A B =\n      (case A of (s,e) \\<Rightarrow> case B of (s',e') \\<Rightarrow> s \\<le> e' \\<and> s' \\<le> e \\<and> s \\<le> e \\<and> s' \\<le> e')\"", "lemma [code]:\n    \"disjoint_intervals A B =\n      (case A of (s,e) \\<Rightarrow> case B of (s',e') \\<Rightarrow> s > e' \\<or> s' > e \\<or> s > e \\<or> s' > e')\"", "lemma not_disjoint_union:\n      fixes s :: \"('a::len) word\"\n      shows \"\\<not> disjoint {s..e} {s'..e'} \\<Longrightarrow> {s..e} \\<union> {s'..e'} = {min s s' .. max e e'}\"", "lemma disjoint_subset: \"disjoint A B \\<Longrightarrow> A \\<subseteq> B \\<union> C \\<Longrightarrow> A \\<subseteq> C\"", "lemma merge_overlap_helper1: \"interval_of A \\<subseteq> (\\<Union>s \\<in> set ss. interval_of s) \\<Longrightarrow>\n      (\\<Union>s \\<in> set (merge_overlap A ss). interval_of s) = (\\<Union>s \\<in> set ss. interval_of s)\"", "lemma merge_overlap_helper2: \"\\<exists>s'\\<in>set ss. \\<not> disjoint (interval_of A) (interval_of s') \\<Longrightarrow>\n          interval_of A \\<union> (\\<Union>s \\<in> set ss. interval_of s) = (\\<Union>s \\<in> set (merge_overlap A ss). interval_of s)\"", "lemma merge_overlap_length:\n    \"\\<exists>s' \\<in> set ss. \\<not> disjoint (interval_of A) (interval_of s') \\<Longrightarrow>\n      length (merge_overlap A ss) = length ss\"", "lemma \"merge_overlap (1:: 16 word,2) [(1, 7)] = [(1, 7)]\"", "lemma \"merge_overlap (1:: 16 word,2) [(2, 7)] = [(1, 7)]\"", "lemma \"merge_overlap (1:: 16 word,2) [(3, 7)] = [(3, 7), (1,2)]\"", "lemma listwordinterval_compress:\n    \"(\\<Union>s \\<in> set (listwordinterval_compress ss). interval_of s) = (\\<Union>s \\<in> set ss. interval_of s)\"", "lemma \"listwordinterval_compress [(1::32 word,3), (8,10), (2,5), (3,7)] = [(8, 10), (1, 7)]\"", "lemma A_in_listwordinterval_compress: \"A \\<in> set (listwordinterval_compress ss) \\<Longrightarrow>\n    interval_of A \\<subseteq> (\\<Union>s \\<in> set ss. interval_of s)\"", "lemma listwordinterval_compress_disjoint:\n    \"A \\<in> set (listwordinterval_compress ss) \\<Longrightarrow> B \\<in> set (listwordinterval_compress ss) \\<Longrightarrow>\n      A \\<noteq> B \\<Longrightarrow> disjoint (interval_of A) (interval_of B)\"", "lemma merge_adjacent_helper:\n  \"interval_of A \\<union> (\\<Union>s \\<in> set ss. interval_of s) = (\\<Union>s \\<in> set (merge_adjacent A ss). interval_of s)\"", "lemma merge_adjacent_length:\n    \"\\<exists>(s', e')\\<in>set ss. s \\<le> e \\<and> s' \\<le> e' \\<and> (word_next e = s' \\<or> word_next e' = s)\n     \\<Longrightarrow> length (merge_adjacent (s,e) ss) = length ss\"", "lemma listwordinterval_adjacent:\n    \"(\\<Union>s \\<in> set (listwordinterval_adjacent ss). interval_of s) = (\\<Union>s \\<in> set ss. interval_of s)\"", "lemma \"listwordinterval_adjacent [(1::16 word, 3), (5, 10), (10,10), (4,4)] = [(10, 10), (1, 10)]\"", "lemma wordinterval_compress:\n    \"wordinterval_to_set (wordinterval_compress r) = wordinterval_to_set r\"", "lemma \"(wi2l \\<circ> (wordinterval_compress :: 32 wordinterval \\<Rightarrow> 32 wordinterval) \\<circ> l2wi)\n          [(70, 80001), (0,0), (150, 8000), (1,3), (42,41), (3,7), (56, 200), (8,10)] =\n          [(56, 80001), (0, 10)]\"", "lemma \"wordinterval_compress (RangeUnion (RangeUnion (WordInterval (1::32 word) 5)\n                                                        (WordInterval 8 10)) (WordInterval 3 7)) =\n       WordInterval 1 10\"", "lemma wordinterval_Union:\n    \"wordinterval_to_set (wordinterval_Union ws) = (\\<Union> w \\<in> (set ws). wordinterval_to_set w)\"", "lemma wordinterval_setminus'_rr_set_eq:\n    \"wordinterval_to_set(wordinterval_setminus' (WordInterval s e) (WordInterval ms me)) =\n    wordinterval_to_set (WordInterval s e) - wordinterval_to_set (WordInterval ms me)\"", "lemma wordinterval_setminus'_set_eq:\n    \"wordinterval_to_set (wordinterval_setminus' r1 r2) =\n      wordinterval_to_set r1 - wordinterval_to_set r2\"", "lemma wordinterval_setminus'_empty_struct:\n    \"wordinterval_empty r2 \\<Longrightarrow> wordinterval_setminus' r1 r2 = r1\"", "lemma wordinterval_setminus_set_eq[simp]: \"wordinterval_to_set (wordinterval_setminus r1 r2) =\n    wordinterval_to_set r1 - wordinterval_to_set r2\"", "lemma wordinterval_UNIV_set_eq[simp]: \"wordinterval_to_set wordinterval_UNIV = UNIV\"", "lemma wordinterval_invert_set_eq[simp]:\n  \"wordinterval_to_set (wordinterval_invert r) = UNIV - wordinterval_to_set r\"", "lemma wordinterval_invert_UNIV_empty:\n  \"wordinterval_empty (wordinterval_invert wordinterval_UNIV)\"", "lemma wi2l_univ[simp]: \"wi2l wordinterval_UNIV = [(0, max_word)]\"", "lemma \"{(s::nat) .. e} \\<inter> {s' .. e'} = {} \\<longleftrightarrow> s > e' \\<or> s' > e \\<or> s > e \\<or> s' > e'\"", "lemma wordinterval_intersection'_set_eq:\n    \"wordinterval_to_set (wordinterval_intersection' r1 r2) =\n      wordinterval_to_set r1 \\<inter> wordinterval_to_set r2\"", "lemma \"wordinterval_intersection'\n          (RangeUnion (RangeUnion (WordInterval (1::32 word) 3) (WordInterval 8 10))\n                      (WordInterval 1 3)) (WordInterval 1 3) =\n          RangeUnion (RangeUnion (WordInterval 1 3) (WordInterval 1 0)) (WordInterval 1 3)\"", "lemma wordinterval_intersection_set_eq[simp]:\n    \"wordinterval_to_set (wordinterval_intersection r1 r2) =\n      wordinterval_to_set r1 \\<inter> wordinterval_to_set r2\"", "lemma \"wordinterval_intersection\n          (RangeUnion (RangeUnion (WordInterval (1::32 word) 3) (WordInterval 8 10))\n                      (WordInterval 1 3)) (WordInterval 1 3) =\n          WordInterval 1 3\"", "lemma wordinterval_subset_set_eq[simp]:\n  \"wordinterval_subset r1 r2 = (wordinterval_to_set r1 \\<subseteq> wordinterval_to_set r2)\"", "lemma wordinterval_eq_set_eq:\n  \"wordinterval_eq r1 r2 \\<longleftrightarrow> wordinterval_to_set r1 = wordinterval_to_set r2\"", "lemma wordinterval_eq_comm: \"wordinterval_eq r1 r2 \\<longleftrightarrow> wordinterval_eq r2 r1\"", "lemma wordinterval_to_set_alt: \"wordinterval_to_set r = {x. wordinterval_element x r}\"", "lemma wordinterval_un_empty:\n  \"wordinterval_empty r1 \\<Longrightarrow> wordinterval_eq (wordinterval_union r1 r2) r2\"", "lemma wordinterval_un_emty_b:\n  \"wordinterval_empty r2 \\<Longrightarrow> wordinterval_eq (wordinterval_union r1 r2) r1\"", "lemma wordinterval_Diff_triv:\n  \"wordinterval_empty (wordinterval_intersection a b) \\<Longrightarrow> wordinterval_eq (wordinterval_setminus a b) a\"", "lemma wordinterval_size_length: \"wordinterval_size r = length (wi2l r)\"", "lemma Ex_wordinterval_nonempty: \"\\<exists>x::('a::len wordinterval). y \\<in> wordinterval_to_set x\"", "lemma wordinterval_eq_reflp:\n  \"reflp wordinterval_eq\"", "lemma wordintervalt_eq_symp:\n  \"symp wordinterval_eq\"", "lemma wordinterval_eq_transp:\n  \"transp wordinterval_eq\"", "lemma wordinterval_eq_equivp:\n  \"equivp wordinterval_eq\"", "lemma\n  \tfixes x :: \"'a :: complete_lattice\"\n  \tassumes \"x \\<in> S\"\n  \tshows \" x = Inf S \\<Longrightarrow> is_lowest_element x S\"", "lemma\n  \tfixes x :: \"'a :: linorder\"\n  \tassumes \"finite S\" and \"x \\<in> S\"\n  \tshows \"is_lowest_element x S \\<longleftrightarrow> x = Min S\"", "lemma wordinterval_lowest_none_empty: \"wordinterval_lowest_element r = None \\<longleftrightarrow> wordinterval_empty r\"", "lemma wordinterval_lowest_element_correct_A:\n    \"wordinterval_lowest_element r = Some x \\<Longrightarrow> is_lowest_element x (wordinterval_to_set r)\"", "lemma wordinterval_lowest_element_set_eq: assumes \"\\<not> wordinterval_empty r\"\n    shows \"(wordinterval_lowest_element r = Some x) = (is_lowest_element x (wordinterval_to_set r))\"", "lemma card_atLeastAtMost_word: fixes s::\"('a::len) word\" shows \"card {s..e} = Suc (unat e) - (unat s)\"", "lemma wordinterval_card: \"wordinterval_card r \\<ge> card (wordinterval_to_set r)\""], "translations": [["", "lemma wordinterval_element_set_eq[simp]:\n    \"wordinterval_element el rg = (el \\<in> wordinterval_to_set rg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_element el rg = (el \\<in> wordinterval_to_set rg)", "by(induction rg rule: wordinterval_element.induct) simp_all"], ["", "definition wordinterval_union\n    :: \"'a::len wordinterval \\<Rightarrow> 'a::len wordinterval \\<Rightarrow> 'a::len wordinterval\" where\n    \"wordinterval_union r1 r2 = RangeUnion r1 r2\""], ["", "lemma wordinterval_union_set_eq[simp]:\n    \"wordinterval_to_set (wordinterval_union r1 r2) = wordinterval_to_set r1 \\<union> wordinterval_to_set r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (wordinterval_union r1 r2) =\n    wordinterval_to_set r1 \\<union> wordinterval_to_set r2", "unfolding wordinterval_union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (RangeUnion r1 r2) =\n    wordinterval_to_set r1 \\<union> wordinterval_to_set r2", "by simp"], ["", "fun wordinterval_empty :: \"'a::len wordinterval \\<Rightarrow> bool\" where\n    \"wordinterval_empty (WordInterval s e) \\<longleftrightarrow> e < s\" |\n    \"wordinterval_empty (RangeUnion r1 r2) \\<longleftrightarrow> wordinterval_empty r1 \\<and> wordinterval_empty r2\""], ["", "lemma wordinterval_empty_set_eq[simp]: \"wordinterval_empty r \\<longleftrightarrow> wordinterval_to_set r = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_empty r = (wordinterval_to_set r = {})", "by(induction r) auto"], ["", "definition Empty_WordInterval :: \"'a::len wordinterval\" where\n    \"Empty_WordInterval \\<equiv> WordInterval 1 0\""], ["", "lemma wordinterval_empty_Empty_WordInterval: \"wordinterval_empty Empty_WordInterval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_empty Empty_WordInterval", "by(simp add: Empty_WordInterval_def)"], ["", "lemma Empty_WordInterval_set_eq[simp]: \"wordinterval_to_set Empty_WordInterval = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set Empty_WordInterval = {}", "by(simp add: Empty_WordInterval_def)"], ["", "subsection\\<open>WordInterval and Lists\\<close>"], ["", "text\\<open>A list of \\<open>(start, end)\\<close> tuples.\\<close>"], ["", "text\\<open>wordinterval to list\\<close>"], ["", "fun wi2l :: \"'a::len wordinterval \\<Rightarrow> ('a::len word \\<times> 'a::len word) list\" where\n    \"wi2l (RangeUnion r1 r2) = wi2l r1 @ wi2l r2\" |\n    \"wi2l (WordInterval s e) = (if e < s then [] else [(s,e)])\""], ["", "text\\<open>list to wordinterval\\<close>"], ["", "fun l2wi :: \"('a::len word \\<times> 'a word) list \\<Rightarrow> 'a wordinterval\" where\n    \"l2wi [] = Empty_WordInterval\" |\n    \"l2wi [(s,e)] = (WordInterval s e)\" |\n    \"l2wi ((s,e)#rs) = (RangeUnion (WordInterval s e) (l2wi rs))\""], ["", "lemma l2wi_append: \"wordinterval_to_set (l2wi (l1@l2)) =\n                      wordinterval_to_set (l2wi l1) \\<union> wordinterval_to_set (l2wi l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (l2wi (l1 @ l2)) =\n    wordinterval_to_set (l2wi l1) \\<union> wordinterval_to_set (l2wi l2)", "proof(induction l1 arbitrary: l2 rule:l2wi.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l2.\n       wordinterval_to_set (l2wi ([] @ l2)) =\n       wordinterval_to_set (l2wi []) \\<union> wordinterval_to_set (l2wi l2)\n 2. \\<And>s e l2.\n       wordinterval_to_set (l2wi ([(s, e)] @ l2)) =\n       wordinterval_to_set (l2wi [(s, e)]) \\<union>\n       wordinterval_to_set (l2wi l2)\n 3. \\<And>s e v va l2.\n       (\\<And>l2.\n           wordinterval_to_set (l2wi ((v # va) @ l2)) =\n           wordinterval_to_set (l2wi (v # va)) \\<union>\n           wordinterval_to_set (l2wi l2)) \\<Longrightarrow>\n       wordinterval_to_set (l2wi (((s, e) # v # va) @ l2)) =\n       wordinterval_to_set (l2wi ((s, e) # v # va)) \\<union>\n       wordinterval_to_set (l2wi l2)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>l2.\n       wordinterval_to_set (l2wi ([] @ l2)) =\n       wordinterval_to_set (l2wi []) \\<union> wordinterval_to_set (l2wi l2)\n 2. \\<And>s e l2.\n       wordinterval_to_set (l2wi ([(s, e)] @ l2)) =\n       wordinterval_to_set (l2wi [(s, e)]) \\<union>\n       wordinterval_to_set (l2wi l2)\n 3. \\<And>s e v va l2.\n       (\\<And>l2.\n           wordinterval_to_set (l2wi ((v # va) @ l2)) =\n           wordinterval_to_set (l2wi (v # va)) \\<union>\n           wordinterval_to_set (l2wi l2)) \\<Longrightarrow>\n       wordinterval_to_set (l2wi (((s, e) # v # va) @ l2)) =\n       wordinterval_to_set (l2wi ((s, e) # v # va)) \\<union>\n       wordinterval_to_set (l2wi l2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (l2wi ([] @ l2)) =\n    wordinterval_to_set (l2wi []) \\<union> wordinterval_to_set (l2wi l2)", "by simp"], ["proof (state)\nthis:\n  wordinterval_to_set (l2wi ([] @ l2)) =\n  wordinterval_to_set (l2wi []) \\<union> wordinterval_to_set (l2wi l2)\n\ngoal (2 subgoals):\n 1. \\<And>s e l2.\n       wordinterval_to_set (l2wi ([(s, e)] @ l2)) =\n       wordinterval_to_set (l2wi [(s, e)]) \\<union>\n       wordinterval_to_set (l2wi l2)\n 2. \\<And>s e v va l2.\n       (\\<And>l2.\n           wordinterval_to_set (l2wi ((v # va) @ l2)) =\n           wordinterval_to_set (l2wi (v # va)) \\<union>\n           wordinterval_to_set (l2wi l2)) \\<Longrightarrow>\n       wordinterval_to_set (l2wi (((s, e) # v # va) @ l2)) =\n       wordinterval_to_set (l2wi ((s, e) # v # va)) \\<union>\n       wordinterval_to_set (l2wi l2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s e l2.\n       wordinterval_to_set (l2wi ([(s, e)] @ l2)) =\n       wordinterval_to_set (l2wi [(s, e)]) \\<union>\n       wordinterval_to_set (l2wi l2)\n 2. \\<And>s e v va l2.\n       (\\<And>l2.\n           wordinterval_to_set (l2wi ((v # va) @ l2)) =\n           wordinterval_to_set (l2wi (v # va)) \\<union>\n           wordinterval_to_set (l2wi l2)) \\<Longrightarrow>\n       wordinterval_to_set (l2wi (((s, e) # v # va) @ l2)) =\n       wordinterval_to_set (l2wi ((s, e) # v # va)) \\<union>\n       wordinterval_to_set (l2wi l2)", "case (2 s e l2)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s e l2.\n       wordinterval_to_set (l2wi ([(s, e)] @ l2)) =\n       wordinterval_to_set (l2wi [(s, e)]) \\<union>\n       wordinterval_to_set (l2wi l2)\n 2. \\<And>s e v va l2.\n       (\\<And>l2.\n           wordinterval_to_set (l2wi ((v # va) @ l2)) =\n           wordinterval_to_set (l2wi (v # va)) \\<union>\n           wordinterval_to_set (l2wi l2)) \\<Longrightarrow>\n       wordinterval_to_set (l2wi (((s, e) # v # va) @ l2)) =\n       wordinterval_to_set (l2wi ((s, e) # v # va)) \\<union>\n       wordinterval_to_set (l2wi l2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (l2wi ([(s, e)] @ l2)) =\n    wordinterval_to_set (l2wi [(s, e)]) \\<union>\n    wordinterval_to_set (l2wi l2)", "by (cases l2) simp_all"], ["proof (state)\nthis:\n  wordinterval_to_set (l2wi ([(s, e)] @ l2)) =\n  wordinterval_to_set (l2wi [(s, e)]) \\<union> wordinterval_to_set (l2wi l2)\n\ngoal (1 subgoal):\n 1. \\<And>s e v va l2.\n       (\\<And>l2.\n           wordinterval_to_set (l2wi ((v # va) @ l2)) =\n           wordinterval_to_set (l2wi (v # va)) \\<union>\n           wordinterval_to_set (l2wi l2)) \\<Longrightarrow>\n       wordinterval_to_set (l2wi (((s, e) # v # va) @ l2)) =\n       wordinterval_to_set (l2wi ((s, e) # v # va)) \\<union>\n       wordinterval_to_set (l2wi l2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s e v va l2.\n       (\\<And>l2.\n           wordinterval_to_set (l2wi ((v # va) @ l2)) =\n           wordinterval_to_set (l2wi (v # va)) \\<union>\n           wordinterval_to_set (l2wi l2)) \\<Longrightarrow>\n       wordinterval_to_set (l2wi (((s, e) # v # va) @ l2)) =\n       wordinterval_to_set (l2wi ((s, e) # v # va)) \\<union>\n       wordinterval_to_set (l2wi l2)", "case 3"], ["proof (state)\nthis:\n  wordinterval_to_set (l2wi ((v_ # va_) @ ?l2.0)) =\n  wordinterval_to_set (l2wi (v_ # va_)) \\<union>\n  wordinterval_to_set (l2wi ?l2.0)\n\ngoal (1 subgoal):\n 1. \\<And>s e v va l2.\n       (\\<And>l2.\n           wordinterval_to_set (l2wi ((v # va) @ l2)) =\n           wordinterval_to_set (l2wi (v # va)) \\<union>\n           wordinterval_to_set (l2wi l2)) \\<Longrightarrow>\n       wordinterval_to_set (l2wi (((s, e) # v # va) @ l2)) =\n       wordinterval_to_set (l2wi ((s, e) # v # va)) \\<union>\n       wordinterval_to_set (l2wi l2)", "thus ?case"], ["proof (prove)\nusing this:\n  wordinterval_to_set (l2wi ((v_ # va_) @ ?l2.0)) =\n  wordinterval_to_set (l2wi (v_ # va_)) \\<union>\n  wordinterval_to_set (l2wi ?l2.0)\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (l2wi (((s_, e_) # v_ # va_) @ l2)) =\n    wordinterval_to_set (l2wi ((s_, e_) # v_ # va_)) \\<union>\n    wordinterval_to_set (l2wi l2)", "by force"], ["proof (state)\nthis:\n  wordinterval_to_set (l2wi (((s_, e_) # v_ # va_) @ l2)) =\n  wordinterval_to_set (l2wi ((s_, e_) # v_ # va_)) \\<union>\n  wordinterval_to_set (l2wi l2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l2wi_wi2l[simp]: \"wordinterval_to_set (l2wi (wi2l r)) = wordinterval_to_set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (l2wi (wi2l r)) = wordinterval_to_set r", "by(induction r) (simp_all add: l2wi_append)"], ["", "lemma l2wi: \"wordinterval_to_set (l2wi l) = (\\<Union> (i,j) \\<in> set l. {i .. j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (l2wi l) = (\\<Union>(i, j)\\<in>set l. {i..j})", "by(induction l rule: l2wi.induct, simp_all)"], ["", "lemma wi2l: \"(\\<Union>(i,j)\\<in>set (wi2l r). {i .. j}) = wordinterval_to_set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(i, j)\\<in>set (wi2l r). {i..j}) = wordinterval_to_set r", "by(induction r rule: wi2l.induct, simp_all)"], ["", "lemma l2wi_remdups[simp]: \"wordinterval_to_set (l2wi (remdups ls)) = wordinterval_to_set (l2wi ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (l2wi (remdups ls)) = wordinterval_to_set (l2wi ls)", "by(simp add: l2wi)"], ["", "lemma wi2l_empty[simp]: \"wi2l Empty_WordInterval = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wi2l Empty_WordInterval = []", "unfolding Empty_WordInterval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wi2l (WordInterval 1 0) = []", "by simp"], ["", "subsection\\<open>Optimizing and minimizing @{typ \"('a::len) wordinterval\"}s\\<close>"], ["", "text\\<open>Removing empty intervals\\<close>"], ["", "context\nbegin"], ["", "fun wordinterval_optimize_empty :: \"'a::len wordinterval \\<Rightarrow> 'a wordinterval\" where\n    \"wordinterval_optimize_empty (RangeUnion r1 r2) = (let r1o = wordinterval_optimize_empty r1;\n                                                           r2o = wordinterval_optimize_empty r2\n      in if\n        wordinterval_empty r1o\n      then\n        r2o\n      else if\n        wordinterval_empty r2o\n      then\n        r1o\n      else\n        RangeUnion r1o r2o)\" |\n    \"wordinterval_optimize_empty r = r\""], ["", "lemma wordinterval_optimize_empty_set_eq[simp]:\n    \"wordinterval_to_set (wordinterval_optimize_empty r) = wordinterval_to_set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (wordinterval_optimize_empty r) =\n    wordinterval_to_set r", "by(induction r) (simp_all add: Let_def)"], ["", "lemma wordinterval_optimize_empty_double:\n    \"wordinterval_optimize_empty (wordinterval_optimize_empty r) = wordinterval_optimize_empty r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_optimize_empty (wordinterval_optimize_empty r) =\n    wordinterval_optimize_empty r", "by(induction r) (simp_all add: Let_def)"], ["", "private"], ["", "fun wordinterval_empty_shallow :: \"'a::len wordinterval \\<Rightarrow> bool\"  where\n    \"wordinterval_empty_shallow (WordInterval s e) \\<longleftrightarrow> e < s\" |\n    \"wordinterval_empty_shallow (RangeUnion _ _) \\<longleftrightarrow> False\""], ["", "private"], ["", "lemma helper_optimize_shallow:\n    \"wordinterval_empty_shallow (wordinterval_optimize_empty r) =\n      wordinterval_empty (wordinterval_optimize_empty r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_empty_shallow (wordinterval_optimize_empty r) =\n    wordinterval_empty (wordinterval_optimize_empty r)", "by(induction r) fastforce+"], ["", "private"], ["", "fun wordinterval_optimize_empty2 where\n    \"wordinterval_optimize_empty2 (RangeUnion r1 r2) = (let r1o = wordinterval_optimize_empty r1;\n                                                            r2o = wordinterval_optimize_empty r2\n      in if\n        wordinterval_empty_shallow r1o\n      then\n        r2o\n      else if\n        wordinterval_empty_shallow r2o\n      then\n        r1o\n      else\n        RangeUnion r1o r2o)\" |\n    \"wordinterval_optimize_empty2 r = r\""], ["", "lemma wordinterval_optimize_empty_code[code_unfold]:\n    \"wordinterval_optimize_empty = wordinterval_optimize_empty2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_optimize_empty = wordinterval_optimize_empty2", "by (subst fun_eq_iff, clarify, rename_tac r, induct_tac r)\n       (unfold wordinterval_optimize_empty.simps wordinterval_optimize_empty2.simps\n               Let_def helper_optimize_shallow, simp_all)"], ["", "end"], ["", "text\\<open>Merging overlapping intervals\\<close>"], ["", "context\nbegin"], ["", "private"], ["", "definition disjoint :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n    \"disjoint A B \\<equiv> A \\<inter> B = {}\""], ["", "private"], ["", "primrec interval_of :: \"('a::len) word \\<times> 'a word \\<Rightarrow> 'a word set\" where\n    \"interval_of (s,e) = {s .. e}\""], ["", "declare interval_of.simps[simp del]"], ["", "private"], ["", "definition disjoint_intervals\n    :: \"(('a::len) word \\<times> ('a::len) word) \\<Rightarrow> ('a word \\<times> 'a word) \\<Rightarrow> bool\"\n  where\n    \"disjoint_intervals A B \\<equiv> disjoint (interval_of A) (interval_of B)\""], ["", "private"], ["", "definition not_disjoint_intervals\n    :: \"(('a::len) word \\<times> ('a::len) word) \\<Rightarrow> ('a word \\<times> 'a word) \\<Rightarrow> bool\"\n  where\n    \"not_disjoint_intervals A B \\<equiv> \\<not> disjoint (interval_of A) (interval_of B)\""], ["", "private"], ["", "lemma [code]:\n    \"not_disjoint_intervals A B =\n      (case A of (s,e) \\<Rightarrow> case B of (s',e') \\<Rightarrow> s \\<le> e' \\<and> s' \\<le> e \\<and> s \\<le> e \\<and> s' \\<le> e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_disjoint_intervals A B =\n    (case A of\n     (s, e) \\<Rightarrow>\n       case B of\n       (s', e') \\<Rightarrow>\n         s \\<le> e' \\<and> s' \\<le> e \\<and> s \\<le> e \\<and> s' \\<le> e')", "apply(cases A, cases B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>A = (a, b); B = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> not_disjoint_intervals A B =\n                         (case A of\n                          (s, e) \\<Rightarrow>\n                            case B of\n                            (s', e') \\<Rightarrow>\n                              s \\<le> e' \\<and>\n                              s' \\<le> e \\<and>\n                              s \\<le> e \\<and> s' \\<le> e')", "apply(simp add: not_disjoint_intervals_def interval_of.simps disjoint_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma [code]:\n    \"disjoint_intervals A B =\n      (case A of (s,e) \\<Rightarrow> case B of (s',e') \\<Rightarrow> s > e' \\<or> s' > e \\<or> s > e \\<or> s' > e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjoint_intervals A B =\n    (case A of\n     (s, e) \\<Rightarrow>\n       case B of\n       (s', e') \\<Rightarrow> e' < s \\<or> e < s' \\<or> e < s \\<or> e' < s')", "apply(cases A, cases B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>A = (a, b); B = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> disjoint_intervals A B =\n                         (case A of\n                          (s, e) \\<Rightarrow>\n                            case B of\n                            (s', e') \\<Rightarrow>\n                              e' < s \\<or> e < s' \\<or> e < s \\<or> e' < s')", "apply(simp add: disjoint_intervals_def interval_of.simps disjoint_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>A = (a, b); B = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (a \\<le> ba \\<longrightarrow>\n                          aa \\<le> b \\<longrightarrow>\n                          a \\<le> b \\<longrightarrow> \\<not> aa \\<le> ba) =\n                         (ba < a \\<or> b < aa \\<or> b < a \\<or> ba < aa)", "by fastforce"], ["", "text\\<open>BEGIN merging overlapping intervals\\<close>"], ["", "(*result has no empty intervals and all are disjoint.\n    merging things such as [1,7] [8,10] would still be possible*)\n  private"], ["", "fun merge_overlap\n    :: \"(('a::len) word \\<times> ('a::len) word) \\<Rightarrow> ('a word \\<times> 'a word) list \\<Rightarrow> ('a word \\<times> 'a word) list\"\n  where\n    \"merge_overlap s [] = [s]\" |\n    \"merge_overlap (s,e) ((s',e')#ss) = (\n       if not_disjoint_intervals (s,e) (s',e')\n       then (min s s', max e e')#ss\n       else (s',e')#merge_overlap (s,e) ss)\""], ["", "private"], ["", "lemma not_disjoint_union:\n      fixes s :: \"('a::len) word\"\n      shows \"\\<not> disjoint {s..e} {s'..e'} \\<Longrightarrow> {s..e} \\<union> {s'..e'} = {min s s' .. max e e'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> disjoint {s..e} {s'..e'} \\<Longrightarrow>\n    {s..e} \\<union> {s'..e'} = {min s s'..max e e'}", "by(auto simp add: disjoint_def min_def max_def)"], ["", "private"], ["", "lemma disjoint_subset: \"disjoint A B \\<Longrightarrow> A \\<subseteq> B \\<union> C \\<Longrightarrow> A \\<subseteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>disjoint A B; A \\<subseteq> B \\<union> C\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq> C", "unfolding disjoint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<inter> B = {}; A \\<subseteq> B \\<union> C\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq> C", "by blast"], ["", "private"], ["", "lemma merge_overlap_helper1: \"interval_of A \\<subseteq> (\\<Union>s \\<in> set ss. interval_of s) \\<Longrightarrow>\n      (\\<Union>s \\<in> set (merge_overlap A ss). interval_of s) = (\\<Union>s \\<in> set ss. interval_of s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interval_of A\n    \\<subseteq> \\<Union> (interval_of ` set ss) \\<Longrightarrow>\n    \\<Union> (interval_of ` set (merge_overlap A ss)) =\n    \\<Union> (interval_of ` set ss)", "apply(induction ss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. interval_of A\n    \\<subseteq> \\<Union> (interval_of ` set []) \\<Longrightarrow>\n    \\<Union> (interval_of ` set (merge_overlap A [])) =\n    \\<Union> (interval_of ` set [])\n 2. \\<And>a ss.\n       \\<lbrakk>interval_of A\n                \\<subseteq> \\<Union>\n                             (interval_of ` set ss) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap A ss)) =\n                \\<Union> (interval_of ` set ss);\n        interval_of A\n        \\<subseteq> \\<Union> (interval_of ` set (a # ss))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (interval_of ` set (merge_overlap A (a # ss))) =\n                         \\<Union> (interval_of ` set (a # ss))", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>interval_of A\n                \\<subseteq> \\<Union>\n                             (interval_of ` set ss) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap A ss)) =\n                \\<Union> (interval_of ` set ss);\n        interval_of A\n        \\<subseteq> \\<Union> (interval_of ` set (a # ss))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (interval_of ` set (merge_overlap A (a # ss))) =\n                         \\<Union> (interval_of ` set (a # ss))", "apply(rename_tac x xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>interval_of A\n                \\<subseteq> \\<Union>\n                             (interval_of ` set xs) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap A xs)) =\n                \\<Union> (interval_of ` set xs);\n        interval_of A\n        \\<subseteq> \\<Union> (interval_of ` set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (interval_of ` set (merge_overlap A (x # xs))) =\n                         \\<Union> (interval_of ` set (x # xs))", "apply(cases A, rename_tac a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b.\n       \\<lbrakk>interval_of A\n                \\<subseteq> \\<Union>\n                             (interval_of ` set xs) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap A xs)) =\n                \\<Union> (interval_of ` set xs);\n        interval_of A \\<subseteq> \\<Union> (interval_of ` set (x # xs));\n        A = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (interval_of ` set (merge_overlap A (x # xs))) =\n                         \\<Union> (interval_of ` set (x # xs))", "apply(case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>interval_of A\n                \\<subseteq> \\<Union>\n                             (interval_of ` set xs) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap A xs)) =\n                \\<Union> (interval_of ` set xs);\n        interval_of A \\<subseteq> \\<Union> (interval_of ` set (x # xs));\n        A = (a, b); x = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (interval_of ` set (merge_overlap A (x # xs))) =\n                         \\<Union> (interval_of ` set (x # xs))", "apply(simp add: not_disjoint_intervals_def interval_of.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b}\n                \\<subseteq> \\<Union>\n                             (interval_of ` set xs) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs)) =\n                \\<Union> (interval_of ` set xs);\n        {a..b}\n        \\<subseteq> {aa..ba} \\<union> \\<Union> (interval_of ` set xs);\n        A = (a, b); x = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> disjoint {a..b} {aa..ba} \\<longrightarrow>\n                          {min a aa..max b ba} \\<union>\n                          \\<Union> (interval_of ` set xs) =\n                          {aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) \\<and>\n                         (disjoint {a..b} {aa..ba} \\<longrightarrow>\n                          {aa..ba} \\<union>\n                          \\<Union>\n                           (interval_of ` set (merge_overlap (a, b) xs)) =\n                          {aa..ba} \\<union> \\<Union> (interval_of ` set xs))", "apply(intro impI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b}\n                \\<subseteq> \\<Union>\n                             (interval_of ` set xs) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs)) =\n                \\<Union> (interval_of ` set xs);\n        {a..b}\n        \\<subseteq> {aa..ba} \\<union> \\<Union> (interval_of ` set xs);\n        A = (a, b); x = (aa, ba); \\<not> disjoint {a..b} {aa..ba}\\<rbrakk>\n       \\<Longrightarrow> {min a aa..max b ba} \\<union>\n                         \\<Union> (interval_of ` set xs) =\n                         {aa..ba} \\<union> \\<Union> (interval_of ` set xs)\n 2. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b}\n                \\<subseteq> \\<Union>\n                             (interval_of ` set xs) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs)) =\n                \\<Union> (interval_of ` set xs);\n        {a..b}\n        \\<subseteq> {aa..ba} \\<union> \\<Union> (interval_of ` set xs);\n        A = (a, b); x = (aa, ba); disjoint {a..b} {aa..ba}\\<rbrakk>\n       \\<Longrightarrow> {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_overlap (a, b) xs)) =\n                         {aa..ba} \\<union> \\<Union> (interval_of ` set xs)", "apply(drule not_disjoint_union)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b}\n                \\<subseteq> \\<Union>\n                             (interval_of ` set xs) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs)) =\n                \\<Union> (interval_of ` set xs);\n        {a..b}\n        \\<subseteq> {aa..ba} \\<union> \\<Union> (interval_of ` set xs);\n        A = (a, b); x = (aa, ba);\n        {a..b} \\<union> {aa..ba} = {min a aa..max b ba}\\<rbrakk>\n       \\<Longrightarrow> {min a aa..max b ba} \\<union>\n                         \\<Union> (interval_of ` set xs) =\n                         {aa..ba} \\<union> \\<Union> (interval_of ` set xs)\n 2. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b}\n                \\<subseteq> \\<Union>\n                             (interval_of ` set xs) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs)) =\n                \\<Union> (interval_of ` set xs);\n        {a..b}\n        \\<subseteq> {aa..ba} \\<union> \\<Union> (interval_of ` set xs);\n        A = (a, b); x = (aa, ba); disjoint {a..b} {aa..ba}\\<rbrakk>\n       \\<Longrightarrow> {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_overlap (a, b) xs)) =\n                         {aa..ba} \\<union> \\<Union> (interval_of ` set xs)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b}\n                \\<subseteq> \\<Union>\n                             (interval_of ` set xs) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs)) =\n                \\<Union> (interval_of ` set xs);\n        {a..b}\n        \\<subseteq> {aa..ba} \\<union> \\<Union> (interval_of ` set xs);\n        A = (a, b); x = (aa, ba); disjoint {a..b} {aa..ba}\\<rbrakk>\n       \\<Longrightarrow> {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_overlap (a, b) xs)) =\n                         {aa..ba} \\<union> \\<Union> (interval_of ` set xs)", "apply(drule_tac C=\"(\\<Union>x\\<in>set xs. interval_of x)\" in disjoint_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b}\n                \\<subseteq> \\<Union>\n                             (interval_of ` set xs) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs)) =\n                \\<Union> (interval_of ` set xs);\n        {a..b}\n        \\<subseteq> {aa..ba} \\<union> \\<Union> (interval_of ` set xs);\n        A = (a, b); x = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> {a..b}\n                         \\<subseteq> {aa..ba} \\<union>\n                                     \\<Union> (interval_of ` set xs)\n 2. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b}\n                \\<subseteq> \\<Union>\n                             (interval_of ` set xs) \\<Longrightarrow>\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs)) =\n                \\<Union> (interval_of ` set xs);\n        {a..b}\n        \\<subseteq> {aa..ba} \\<union> \\<Union> (interval_of ` set xs);\n        A = (a, b); x = (aa, ba);\n        {a..b} \\<subseteq> \\<Union> (interval_of ` set xs)\\<rbrakk>\n       \\<Longrightarrow> {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_overlap (a, b) xs)) =\n                         {aa..ba} \\<union> \\<Union> (interval_of ` set xs)", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma merge_overlap_helper2: \"\\<exists>s'\\<in>set ss. \\<not> disjoint (interval_of A) (interval_of s') \\<Longrightarrow>\n          interval_of A \\<union> (\\<Union>s \\<in> set ss. interval_of s) = (\\<Union>s \\<in> set (merge_overlap A ss). interval_of s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'\\<in>set ss.\n       \\<not> disjoint (interval_of A) (interval_of s') \\<Longrightarrow>\n    interval_of A \\<union> \\<Union> (interval_of ` set ss) =\n    \\<Union> (interval_of ` set (merge_overlap A ss))", "apply(induction ss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>s'\\<in>set [].\n       \\<not> disjoint (interval_of A) (interval_of s') \\<Longrightarrow>\n    interval_of A \\<union> \\<Union> (interval_of ` set []) =\n    \\<Union> (interval_of ` set (merge_overlap A []))\n 2. \\<And>a ss.\n       \\<lbrakk>\\<exists>s'\\<in>set ss.\n                   \\<not> disjoint (interval_of A)\n                           (interval_of s') \\<Longrightarrow>\n                interval_of A \\<union> \\<Union> (interval_of ` set ss) =\n                \\<Union> (interval_of ` set (merge_overlap A ss));\n        \\<exists>s'\\<in>set (a # ss).\n           \\<not> disjoint (interval_of A) (interval_of s')\\<rbrakk>\n       \\<Longrightarrow> interval_of A \\<union>\n                         \\<Union> (interval_of ` set (a # ss)) =\n                         \\<Union>\n                          (interval_of ` set (merge_overlap A (a # ss)))", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>\\<exists>s'\\<in>set ss.\n                   \\<not> disjoint (interval_of A)\n                           (interval_of s') \\<Longrightarrow>\n                interval_of A \\<union> \\<Union> (interval_of ` set ss) =\n                \\<Union> (interval_of ` set (merge_overlap A ss));\n        \\<exists>s'\\<in>set (a # ss).\n           \\<not> disjoint (interval_of A) (interval_of s')\\<rbrakk>\n       \\<Longrightarrow> interval_of A \\<union>\n                         \\<Union> (interval_of ` set (a # ss)) =\n                         \\<Union>\n                          (interval_of ` set (merge_overlap A (a # ss)))", "apply(rename_tac x xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint (interval_of A)\n                           (interval_of s') \\<Longrightarrow>\n                interval_of A \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_overlap A xs));\n        \\<exists>s'\\<in>set (x # xs).\n           \\<not> disjoint (interval_of A) (interval_of s')\\<rbrakk>\n       \\<Longrightarrow> interval_of A \\<union>\n                         \\<Union> (interval_of ` set (x # xs)) =\n                         \\<Union>\n                          (interval_of ` set (merge_overlap A (x # xs)))", "apply(cases A, rename_tac a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint (interval_of A)\n                           (interval_of s') \\<Longrightarrow>\n                interval_of A \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_overlap A xs));\n        \\<exists>s'\\<in>set (x # xs).\n           \\<not> disjoint (interval_of A) (interval_of s');\n        A = (a, b)\\<rbrakk>\n       \\<Longrightarrow> interval_of A \\<union>\n                         \\<Union> (interval_of ` set (x # xs)) =\n                         \\<Union>\n                          (interval_of ` set (merge_overlap A (x # xs)))", "apply(case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint (interval_of A)\n                           (interval_of s') \\<Longrightarrow>\n                interval_of A \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_overlap A xs));\n        \\<exists>s'\\<in>set (x # xs).\n           \\<not> disjoint (interval_of A) (interval_of s');\n        A = (a, b); x = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> interval_of A \\<union>\n                         \\<Union> (interval_of ` set (x # xs)) =\n                         \\<Union>\n                          (interval_of ` set (merge_overlap A (x # xs)))", "apply(simp add: not_disjoint_intervals_def interval_of.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint {a..b} (interval_of s') \\<Longrightarrow>\n                {a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs));\n        disjoint {a..b} {aa..ba} \\<longrightarrow>\n        (\\<exists>s'\\<in>set xs. \\<not> disjoint {a..b} (interval_of s'));\n        A = (a, b); x = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> disjoint {a..b} {aa..ba} \\<longrightarrow>\n                          {a..b} \\<union>\n                          ({aa..ba} \\<union>\n                           \\<Union> (interval_of ` set xs)) =\n                          {min a aa..max b ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) \\<and>\n                         (disjoint {a..b} {aa..ba} \\<longrightarrow>\n                          {a..b} \\<union>\n                          ({aa..ba} \\<union>\n                           \\<Union> (interval_of ` set xs)) =\n                          {aa..ba} \\<union>\n                          \\<Union>\n                           (interval_of ` set (merge_overlap (a, b) xs)))", "apply(intro impI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint {a..b} (interval_of s') \\<Longrightarrow>\n                {a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs));\n        disjoint {a..b} {aa..ba} \\<longrightarrow>\n        (\\<exists>s'\\<in>set xs. \\<not> disjoint {a..b} (interval_of s'));\n        A = (a, b); x = (aa, ba); \\<not> disjoint {a..b} {aa..ba}\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {min a aa..max b ba} \\<union>\n                         \\<Union> (interval_of ` set xs)\n 2. \\<And>x xs a b aa ba.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint {a..b} (interval_of s') \\<Longrightarrow>\n                {a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs));\n        disjoint {a..b} {aa..ba} \\<longrightarrow>\n        (\\<exists>s'\\<in>set xs. \\<not> disjoint {a..b} (interval_of s'));\n        A = (a, b); x = (aa, ba); disjoint {a..b} {aa..ba}\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_overlap (a, b) xs))", "apply(drule not_disjoint_union)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint {a..b} (interval_of s') \\<Longrightarrow>\n                {a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs));\n        disjoint {a..b} {aa..ba} \\<longrightarrow>\n        (\\<exists>s'\\<in>set xs. \\<not> disjoint {a..b} (interval_of s'));\n        A = (a, b); x = (aa, ba);\n        {a..b} \\<union> {aa..ba} = {min a aa..max b ba}\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {min a aa..max b ba} \\<union>\n                         \\<Union> (interval_of ` set xs)\n 2. \\<And>x xs a b aa ba.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint {a..b} (interval_of s') \\<Longrightarrow>\n                {a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs));\n        disjoint {a..b} {aa..ba} \\<longrightarrow>\n        (\\<exists>s'\\<in>set xs. \\<not> disjoint {a..b} (interval_of s'));\n        A = (a, b); x = (aa, ba); disjoint {a..b} {aa..ba}\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_overlap (a, b) xs))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint {a..b} (interval_of s') \\<Longrightarrow>\n                {a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs));\n        disjoint {a..b} {aa..ba} \\<longrightarrow>\n        (\\<exists>s'\\<in>set xs. \\<not> disjoint {a..b} (interval_of s'));\n        A = (a, b); x = (aa, ba); disjoint {a..b} {aa..ba}\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_overlap (a, b) xs))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_overlap (a, b) xs));\n        \\<exists>s'\\<in>set xs. \\<not> disjoint {a..b} (interval_of s');\n        A = (a, b); x = (aa, ba); disjoint {a..b} {aa..ba}\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_overlap (a, b) xs))", "by blast"], ["", "private"], ["", "lemma merge_overlap_length:\n    \"\\<exists>s' \\<in> set ss. \\<not> disjoint (interval_of A) (interval_of s') \\<Longrightarrow>\n      length (merge_overlap A ss) = length ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'\\<in>set ss.\n       \\<not> disjoint (interval_of A) (interval_of s') \\<Longrightarrow>\n    length (merge_overlap A ss) = length ss", "apply(induction ss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>s'\\<in>set [].\n       \\<not> disjoint (interval_of A) (interval_of s') \\<Longrightarrow>\n    length (merge_overlap A []) = length []\n 2. \\<And>a ss.\n       \\<lbrakk>\\<exists>s'\\<in>set ss.\n                   \\<not> disjoint (interval_of A)\n                           (interval_of s') \\<Longrightarrow>\n                length (merge_overlap A ss) = length ss;\n        \\<exists>s'\\<in>set (a # ss).\n           \\<not> disjoint (interval_of A) (interval_of s')\\<rbrakk>\n       \\<Longrightarrow> length (merge_overlap A (a # ss)) = length (a # ss)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>\\<exists>s'\\<in>set ss.\n                   \\<not> disjoint (interval_of A)\n                           (interval_of s') \\<Longrightarrow>\n                length (merge_overlap A ss) = length ss;\n        \\<exists>s'\\<in>set (a # ss).\n           \\<not> disjoint (interval_of A) (interval_of s')\\<rbrakk>\n       \\<Longrightarrow> length (merge_overlap A (a # ss)) = length (a # ss)", "apply(rename_tac x xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint (interval_of A)\n                           (interval_of s') \\<Longrightarrow>\n                length (merge_overlap A xs) = length xs;\n        \\<exists>s'\\<in>set (x # xs).\n           \\<not> disjoint (interval_of A) (interval_of s')\\<rbrakk>\n       \\<Longrightarrow> length (merge_overlap A (x # xs)) = length (x # xs)", "apply(cases A, rename_tac a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint (interval_of A)\n                           (interval_of s') \\<Longrightarrow>\n                length (merge_overlap A xs) = length xs;\n        \\<exists>s'\\<in>set (x # xs).\n           \\<not> disjoint (interval_of A) (interval_of s');\n        A = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length (merge_overlap A (x # xs)) = length (x # xs)", "apply(case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>\\<exists>s'\\<in>set xs.\n                   \\<not> disjoint (interval_of A)\n                           (interval_of s') \\<Longrightarrow>\n                length (merge_overlap A xs) = length xs;\n        \\<exists>s'\\<in>set (x # xs).\n           \\<not> disjoint (interval_of A) (interval_of s');\n        A = (a, b); x = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> length (merge_overlap A (x # xs)) = length (x # xs)", "apply(simp add: not_disjoint_intervals_def interval_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"merge_overlap (1:: 16 word,2) [(1, 7)] = [(1, 7)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_overlap (1, 2) [(1, 7)] = [(1, 7)]", "by eval"], ["", "lemma \"merge_overlap (1:: 16 word,2) [(2, 7)] = [(1, 7)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_overlap (1, 2) [(2, 7)] = [(1, 7)]", "by eval"], ["", "lemma \"merge_overlap (1:: 16 word,2) [(3, 7)] = [(3, 7), (1,2)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_overlap (1, 2) [(3, 7)] = [(3, 7), (1, 2)]", "by eval"], ["", "private"], ["", "function listwordinterval_compress\n    :: \"(('a::len) word \\<times> ('a::len) word) list \\<Rightarrow> ('a word \\<times> 'a word) list\" where\n    \"listwordinterval_compress [] = []\" |\n    \"listwordinterval_compress (s#ss) = (\n            if \\<forall>s' \\<in> set ss. disjoint_intervals s s'\n            then s#listwordinterval_compress ss\n            else listwordinterval_compress (merge_overlap s ss))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>s ss. x = s # ss \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. [] = [] \\<Longrightarrow> [] = []\n 3. \\<And>s ss.\n       [] = s # ss \\<Longrightarrow>\n       [] =\n       (if Ball (set ss) (disjoint_intervals s)\n        then s # listwordinterval_compress_sumC ss\n        else listwordinterval_compress_sumC (merge_overlap s ss))\n 4. \\<And>s ss sa ssa.\n       s # ss = sa # ssa \\<Longrightarrow>\n       (if Ball (set ss) (disjoint_intervals s)\n        then s # listwordinterval_compress_sumC ss\n        else listwordinterval_compress_sumC (merge_overlap s ss)) =\n       (if Ball (set ssa) (disjoint_intervals sa)\n        then sa # listwordinterval_compress_sumC ssa\n        else listwordinterval_compress_sumC (merge_overlap sa ssa))", "by(pat_completeness, auto)"], ["", "private"], ["", "termination listwordinterval_compress"], ["proof (prove)\ngoal (1 subgoal):\n 1. All listwordinterval_compress_dom", "apply (relation \"measure length\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (measure length)\n 2. \\<And>s ss.\n       Ball (set ss) (disjoint_intervals s) \\<Longrightarrow>\n       (ss, s # ss) \\<in> measure length\n 3. \\<And>s ss.\n       \\<not> Ball (set ss) (disjoint_intervals s) \\<Longrightarrow>\n       (merge_overlap s ss, s # ss) \\<in> measure length", "apply(rule wf_measure)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss.\n       Ball (set ss) (disjoint_intervals s) \\<Longrightarrow>\n       (ss, s # ss) \\<in> measure length\n 2. \\<And>s ss.\n       \\<not> Ball (set ss) (disjoint_intervals s) \\<Longrightarrow>\n       (merge_overlap s ss, s # ss) \\<in> measure length", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss.\n       \\<not> Ball (set ss) (disjoint_intervals s) \\<Longrightarrow>\n       (merge_overlap s ss, s # ss) \\<in> measure length", "using disjoint_intervals_def merge_overlap_length"], ["proof (prove)\nusing this:\n  disjoint_intervals ?A ?B \\<equiv>\n  disjoint (interval_of ?A) (interval_of ?B)\n  \\<exists>s'\\<in>set ?ss.\n     \\<not> disjoint (interval_of ?A) (interval_of s') \\<Longrightarrow>\n  length (merge_overlap ?A ?ss) = length ?ss\n\ngoal (1 subgoal):\n 1. \\<And>s ss.\n       \\<not> Ball (set ss) (disjoint_intervals s) \\<Longrightarrow>\n       (merge_overlap s ss, s # ss) \\<in> measure length", "by fastforce"], ["", "private"], ["", "lemma listwordinterval_compress:\n    \"(\\<Union>s \\<in> set (listwordinterval_compress ss). interval_of s) = (\\<Union>s \\<in> set ss. interval_of s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (interval_of ` set (listwordinterval_compress ss)) =\n    \\<Union> (interval_of ` set ss)", "apply(induction ss rule: listwordinterval_compress.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Union> (interval_of ` set (listwordinterval_compress [])) =\n    \\<Union> (interval_of ` set [])\n 2. \\<And>s ss.\n       \\<lbrakk>Ball (set ss) (disjoint_intervals s) \\<Longrightarrow>\n                \\<Union>\n                 (interval_of ` set (listwordinterval_compress ss)) =\n                \\<Union> (interval_of ` set ss);\n        \\<not> Ball (set ss) (disjoint_intervals s) \\<Longrightarrow>\n        \\<Union>\n         (interval_of `\n          set (listwordinterval_compress (merge_overlap s ss))) =\n        \\<Union> (interval_of ` set (merge_overlap s ss))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (interval_of `\n                           set (listwordinterval_compress (s # ss))) =\n                         \\<Union> (interval_of ` set (s # ss))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss.\n       \\<lbrakk>Ball (set ss) (disjoint_intervals s) \\<Longrightarrow>\n                \\<Union>\n                 (interval_of ` set (listwordinterval_compress ss)) =\n                \\<Union> (interval_of ` set ss);\n        \\<not> Ball (set ss) (disjoint_intervals s) \\<Longrightarrow>\n        \\<Union>\n         (interval_of `\n          set (listwordinterval_compress (merge_overlap s ss))) =\n        \\<Union> (interval_of ` set (merge_overlap s ss))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (interval_of `\n                           set (listwordinterval_compress (s # ss))) =\n                         \\<Union> (interval_of ` set (s # ss))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss.\n       \\<lbrakk>\\<forall>x\\<in>set ss.\n                   disjoint_intervals s x \\<Longrightarrow>\n                \\<Union>\n                 (interval_of ` set (listwordinterval_compress ss)) =\n                \\<Union> (interval_of ` set ss);\n        \\<exists>x\\<in>set ss.\n           \\<not> disjoint_intervals s x \\<Longrightarrow>\n        \\<Union>\n         (interval_of `\n          set (listwordinterval_compress (merge_overlap s ss))) =\n        \\<Union> (interval_of ` set (merge_overlap s ss))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>set ss.\n                             \\<not> disjoint_intervals s\n                                     x) \\<longrightarrow>\n                         \\<Union> (interval_of ` set (merge_overlap s ss)) =\n                         interval_of s \\<union>\n                         \\<Union> (interval_of ` set ss)", "apply(intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss.\n       \\<lbrakk>\\<forall>x\\<in>set ss.\n                   disjoint_intervals s x \\<Longrightarrow>\n                \\<Union>\n                 (interval_of ` set (listwordinterval_compress ss)) =\n                \\<Union> (interval_of ` set ss);\n        \\<exists>x\\<in>set ss.\n           \\<not> disjoint_intervals s x \\<Longrightarrow>\n        \\<Union>\n         (interval_of `\n          set (listwordinterval_compress (merge_overlap s ss))) =\n        \\<Union> (interval_of ` set (merge_overlap s ss));\n        \\<exists>x\\<in>set ss. \\<not> disjoint_intervals s x\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (interval_of ` set (merge_overlap s ss)) =\n                         interval_of s \\<union>\n                         \\<Union> (interval_of ` set ss)", "apply(simp add: disjoint_intervals_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss.\n       \\<lbrakk>\\<forall>x\\<in>set ss.\n                   disjoint (interval_of s)\n                    (interval_of x) \\<Longrightarrow>\n                \\<Union>\n                 (interval_of ` set (listwordinterval_compress ss)) =\n                \\<Union> (interval_of ` set ss);\n        \\<Union>\n         (interval_of `\n          set (listwordinterval_compress (merge_overlap s ss))) =\n        \\<Union> (interval_of ` set (merge_overlap s ss));\n        \\<exists>x\\<in>set ss.\n           \\<not> disjoint (interval_of s) (interval_of x)\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (interval_of ` set (merge_overlap s ss)) =\n                         interval_of s \\<union>\n                         \\<Union> (interval_of ` set ss)", "apply(drule merge_overlap_helper2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss.\n       \\<lbrakk>\\<forall>x\\<in>set ss.\n                   disjoint (interval_of s)\n                    (interval_of x) \\<Longrightarrow>\n                \\<Union>\n                 (interval_of ` set (listwordinterval_compress ss)) =\n                \\<Union> (interval_of ` set ss);\n        \\<Union>\n         (interval_of `\n          set (listwordinterval_compress (merge_overlap s ss))) =\n        \\<Union> (interval_of ` set (merge_overlap s ss));\n        interval_of s \\<union> \\<Union> (interval_of ` set ss) =\n        \\<Union> (interval_of ` set (merge_overlap s ss))\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (interval_of ` set (merge_overlap s ss)) =\n                         interval_of s \\<union>\n                         \\<Union> (interval_of ` set ss)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"listwordinterval_compress [(1::32 word,3), (8,10), (2,5), (3,7)] = [(8, 10), (1, 7)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. listwordinterval_compress [(1, 3), (8, 10), (2, 5), (3, 7)] =\n    [(8, 10), (1, 7)]", "by eval"], ["", "private"], ["", "lemma A_in_listwordinterval_compress: \"A \\<in> set (listwordinterval_compress ss) \\<Longrightarrow>\n    interval_of A \\<subseteq> (\\<Union>s \\<in> set ss. interval_of s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> set (listwordinterval_compress ss) \\<Longrightarrow>\n    interval_of A \\<subseteq> \\<Union> (interval_of ` set ss)", "using listwordinterval_compress"], ["proof (prove)\nusing this:\n  \\<Union> (interval_of ` set (listwordinterval_compress ?ss)) =\n  \\<Union> (interval_of ` set ?ss)\n\ngoal (1 subgoal):\n 1. A \\<in> set (listwordinterval_compress ss) \\<Longrightarrow>\n    interval_of A \\<subseteq> \\<Union> (interval_of ` set ss)", "by blast"], ["", "private"], ["", "lemma listwordinterval_compress_disjoint:\n    \"A \\<in> set (listwordinterval_compress ss) \\<Longrightarrow> B \\<in> set (listwordinterval_compress ss) \\<Longrightarrow>\n      A \\<noteq> B \\<Longrightarrow> disjoint (interval_of A) (interval_of B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (listwordinterval_compress ss);\n     B \\<in> set (listwordinterval_compress ss); A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> disjoint (interval_of A) (interval_of B)", "apply(induction ss arbitrary: rule: listwordinterval_compress.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> set (listwordinterval_compress []);\n     B \\<in> set (listwordinterval_compress []); A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> disjoint (interval_of A) (interval_of B)\n 2. \\<And>s ss.\n       \\<lbrakk>\\<lbrakk>Ball (set ss) (disjoint_intervals s);\n                 A \\<in> set (listwordinterval_compress ss);\n                 B \\<in> set (listwordinterval_compress ss);\n                 A \\<noteq> B\\<rbrakk>\n                \\<Longrightarrow> disjoint (interval_of A) (interval_of B);\n        \\<lbrakk>\\<not> Ball (set ss) (disjoint_intervals s);\n         A \\<in> set (listwordinterval_compress (merge_overlap s ss));\n         B \\<in> set (listwordinterval_compress (merge_overlap s ss));\n         A \\<noteq> B\\<rbrakk>\n        \\<Longrightarrow> disjoint (interval_of A) (interval_of B);\n        A \\<in> set (listwordinterval_compress (s # ss));\n        B \\<in> set (listwordinterval_compress (s # ss));\n        A \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> disjoint (interval_of A) (interval_of B)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss.\n       \\<lbrakk>\\<lbrakk>Ball (set ss) (disjoint_intervals s);\n                 A \\<in> set (listwordinterval_compress ss);\n                 B \\<in> set (listwordinterval_compress ss);\n                 A \\<noteq> B\\<rbrakk>\n                \\<Longrightarrow> disjoint (interval_of A) (interval_of B);\n        \\<lbrakk>\\<not> Ball (set ss) (disjoint_intervals s);\n         A \\<in> set (listwordinterval_compress (merge_overlap s ss));\n         B \\<in> set (listwordinterval_compress (merge_overlap s ss));\n         A \\<noteq> B\\<rbrakk>\n        \\<Longrightarrow> disjoint (interval_of A) (interval_of B);\n        A \\<in> set (listwordinterval_compress (s # ss));\n        B \\<in> set (listwordinterval_compress (s # ss));\n        A \\<noteq> B\\<rbrakk>\n       \\<Longrightarrow> disjoint (interval_of A) (interval_of B)", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss.\n       \\<lbrakk>B = s \\<or> B \\<in> set (listwordinterval_compress ss);\n        A \\<noteq> B;\n        \\<lbrakk>A \\<in> set (listwordinterval_compress ss);\n         B \\<in> set (listwordinterval_compress ss)\\<rbrakk>\n        \\<Longrightarrow> disjoint (interval_of A) (interval_of B);\n        \\<forall>x\\<in>set ss. disjoint_intervals s x;\n        A = s \\<or> A \\<in> set (listwordinterval_compress ss)\\<rbrakk>\n       \\<Longrightarrow> disjoint (interval_of A) (interval_of B)", "apply(elim disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s ss.\n       \\<lbrakk>A \\<noteq> B;\n        \\<lbrakk>A \\<in> set (listwordinterval_compress ss);\n         B \\<in> set (listwordinterval_compress ss)\\<rbrakk>\n        \\<Longrightarrow> disjoint (interval_of A) (interval_of B);\n        \\<forall>x\\<in>set ss. disjoint_intervals s x; B = s; A = s\\<rbrakk>\n       \\<Longrightarrow> disjoint (interval_of A) (interval_of B)\n 2. \\<And>s ss.\n       \\<lbrakk>A \\<noteq> B;\n        \\<lbrakk>A \\<in> set (listwordinterval_compress ss);\n         B \\<in> set (listwordinterval_compress ss)\\<rbrakk>\n        \\<Longrightarrow> disjoint (interval_of A) (interval_of B);\n        \\<forall>x\\<in>set ss. disjoint_intervals s x; B = s;\n        A \\<in> set (listwordinterval_compress ss)\\<rbrakk>\n       \\<Longrightarrow> disjoint (interval_of A) (interval_of B)\n 3. \\<And>s ss.\n       \\<lbrakk>A \\<noteq> B;\n        \\<lbrakk>A \\<in> set (listwordinterval_compress ss);\n         B \\<in> set (listwordinterval_compress ss)\\<rbrakk>\n        \\<Longrightarrow> disjoint (interval_of A) (interval_of B);\n        \\<forall>x\\<in>set ss. disjoint_intervals s x;\n        B \\<in> set (listwordinterval_compress ss); A = s\\<rbrakk>\n       \\<Longrightarrow> disjoint (interval_of A) (interval_of B)\n 4. \\<And>s ss.\n       \\<lbrakk>A \\<noteq> B;\n        \\<lbrakk>A \\<in> set (listwordinterval_compress ss);\n         B \\<in> set (listwordinterval_compress ss)\\<rbrakk>\n        \\<Longrightarrow> disjoint (interval_of A) (interval_of B);\n        \\<forall>x\\<in>set ss. disjoint_intervals s x;\n        B \\<in> set (listwordinterval_compress ss);\n        A \\<in> set (listwordinterval_compress ss)\\<rbrakk>\n       \\<Longrightarrow> disjoint (interval_of A) (interval_of B)", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss.\n       \\<lbrakk>A \\<noteq> s;\n        s \\<in> set (listwordinterval_compress ss) \\<Longrightarrow>\n        disjoint (interval_of A) (interval_of s);\n        \\<forall>x\\<in>set ss. disjoint_intervals s x; B = s;\n        A \\<in> set (listwordinterval_compress ss)\\<rbrakk>\n       \\<Longrightarrow> disjoint (interval_of A) (interval_of s)\n 2. \\<And>s ss.\n       \\<lbrakk>s \\<noteq> B;\n        s \\<in> set (listwordinterval_compress ss) \\<Longrightarrow>\n        disjoint (interval_of s) (interval_of B);\n        \\<forall>x\\<in>set ss. disjoint_intervals s x;\n        B \\<in> set (listwordinterval_compress ss); A = s\\<rbrakk>\n       \\<Longrightarrow> disjoint (interval_of s) (interval_of B)", "apply(simp_all add: disjoint_intervals_def disjoint_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss.\n       \\<lbrakk>A \\<noteq> s;\n        s \\<in> set (listwordinterval_compress ss) \\<Longrightarrow>\n        interval_of A \\<inter> interval_of s = {};\n        \\<forall>x\\<in>set ss. interval_of s \\<inter> interval_of x = {};\n        B = s; A \\<in> set (listwordinterval_compress ss)\\<rbrakk>\n       \\<Longrightarrow> interval_of A \\<inter> interval_of s = {}\n 2. \\<And>s ss.\n       \\<lbrakk>s \\<noteq> B;\n        s \\<in> set (listwordinterval_compress ss) \\<Longrightarrow>\n        interval_of s \\<inter> interval_of B = {};\n        \\<forall>x\\<in>set ss. interval_of s \\<inter> interval_of x = {};\n        B \\<in> set (listwordinterval_compress ss); A = s\\<rbrakk>\n       \\<Longrightarrow> interval_of s \\<inter> interval_of B = {}", "apply(blast dest: A_in_listwordinterval_compress)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>END merging overlapping intervals\\<close>"], ["", "text\\<open>BEGIN merging adjacent intervals\\<close>"], ["", "private"], ["", "fun merge_adjacent\n    :: \"(('a::len) word \\<times> ('a::len) word) \\<Rightarrow> ('a word \\<times> 'a word) list \\<Rightarrow> ('a word \\<times> 'a word) list\"\n  where\n    \"merge_adjacent s [] = [s]\" |\n    \"merge_adjacent (s,e) ((s',e')#ss) = (\n       if s \\<le>e \\<and> s' \\<le> e' \\<and> word_next e = s'\n       then (s, e')#ss\n       else if s \\<le>e \\<and> s' \\<le> e' \\<and> word_next e' = s\n       then (s', e)#ss\n       else (s',e')#merge_adjacent (s,e) ss)\""], ["", "private"], ["", "lemma merge_adjacent_helper:\n  \"interval_of A \\<union> (\\<Union>s \\<in> set ss. interval_of s) = (\\<Union>s \\<in> set (merge_adjacent A ss). interval_of s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interval_of A \\<union> \\<Union> (interval_of ` set ss) =\n    \\<Union> (interval_of ` set (merge_adjacent A ss))", "apply(induction ss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. interval_of A \\<union> \\<Union> (interval_of ` set []) =\n    \\<Union> (interval_of ` set (merge_adjacent A []))\n 2. \\<And>a ss.\n       interval_of A \\<union> \\<Union> (interval_of ` set ss) =\n       \\<Union> (interval_of ` set (merge_adjacent A ss)) \\<Longrightarrow>\n       interval_of A \\<union> \\<Union> (interval_of ` set (a # ss)) =\n       \\<Union> (interval_of ` set (merge_adjacent A (a # ss)))", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       interval_of A \\<union> \\<Union> (interval_of ` set ss) =\n       \\<Union> (interval_of ` set (merge_adjacent A ss)) \\<Longrightarrow>\n       interval_of A \\<union> \\<Union> (interval_of ` set (a # ss)) =\n       \\<Union> (interval_of ` set (merge_adjacent A (a # ss)))", "apply(rename_tac x xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       interval_of A \\<union> \\<Union> (interval_of ` set xs) =\n       \\<Union> (interval_of ` set (merge_adjacent A xs)) \\<Longrightarrow>\n       interval_of A \\<union> \\<Union> (interval_of ` set (x # xs)) =\n       \\<Union> (interval_of ` set (merge_adjacent A (x # xs)))", "apply(cases A, rename_tac a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b.\n       \\<lbrakk>interval_of A \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent A xs));\n        A = (a, b)\\<rbrakk>\n       \\<Longrightarrow> interval_of A \\<union>\n                         \\<Union> (interval_of ` set (x # xs)) =\n                         \\<Union>\n                          (interval_of ` set (merge_adjacent A (x # xs)))", "apply(case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>interval_of A \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent A xs));\n        A = (a, b); x = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> interval_of A \\<union>\n                         \\<Union> (interval_of ` set (x # xs)) =\n                         \\<Union>\n                          (interval_of ` set (merge_adjacent A (x # xs)))", "apply(simp add:  interval_of.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (a \\<le> b \\<and>\n                          aa \\<le> ba \\<and>\n                          word_next ba = a \\<longrightarrow>\n                          (word_next b = aa \\<longrightarrow>\n                           {a..b} \\<union>\n                           ({aa..ba} \\<union>\n                            \\<Union> (interval_of ` set xs)) =\n                           {a..ba} \\<union>\n                           \\<Union> (interval_of ` set xs)) \\<and>\n                          (word_next b \\<noteq> aa \\<longrightarrow>\n                           {a..b} \\<union>\n                           ({aa..ba} \\<union>\n                            \\<Union> (interval_of ` set xs)) =\n                           {aa..b} \\<union>\n                           \\<Union> (interval_of ` set xs))) \\<and>\n                         ((aa \\<le> ba \\<longrightarrow>\n                           a \\<le> b \\<longrightarrow>\n                           word_next ba \\<noteq> a) \\<longrightarrow>\n                          (a \\<le> b \\<and>\n                           aa \\<le> ba \\<and>\n                           word_next b = aa \\<longrightarrow>\n                           {a..b} \\<union>\n                           ({aa..ba} \\<union>\n                            \\<Union> (interval_of ` set xs)) =\n                           {a..ba} \\<union>\n                           \\<Union> (interval_of ` set xs)) \\<and>\n                          ((aa \\<le> ba \\<longrightarrow>\n                            a \\<le> b \\<longrightarrow>\n                            word_next b \\<noteq> aa) \\<longrightarrow>\n                           {a..b} \\<union>\n                           ({aa..ba} \\<union>\n                            \\<Union> (interval_of ` set xs)) =\n                           {aa..ba} \\<union>\n                           \\<Union>\n                            (interval_of ` set (merge_adjacent (a, b) xs))))", "apply(intro impI conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        a \\<le> b \\<and> aa \\<le> ba \\<and> word_next ba = a;\n        word_next b = aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {a..ba} \\<union> \\<Union> (interval_of ` set xs)\n 2. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        a \\<le> b \\<and> aa \\<le> ba \\<and> word_next ba = a;\n        word_next b \\<noteq> aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..b} \\<union> \\<Union> (interval_of ` set xs)\n 3. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next ba \\<noteq> a;\n        a \\<le> b \\<and> aa \\<le> ba \\<and> word_next b = aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {a..ba} \\<union> \\<Union> (interval_of ` set xs)\n 4. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next ba \\<noteq> a;\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next b \\<noteq> aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_adjacent (a, b) xs))", "apply (metis Un_assoc word_adjacent_union)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        a \\<le> b \\<and> aa \\<le> ba \\<and> word_next ba = a;\n        word_next b \\<noteq> aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..b} \\<union> \\<Union> (interval_of ` set xs)\n 2. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next ba \\<noteq> a;\n        a \\<le> b \\<and> aa \\<le> ba \\<and> word_next b = aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {a..ba} \\<union> \\<Union> (interval_of ` set xs)\n 3. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next ba \\<noteq> a;\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next b \\<noteq> aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_adjacent (a, b) xs))", "apply(elim conjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba); word_next b \\<noteq> aa; a \\<le> b;\n        aa \\<le> ba; word_next ba = a\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..b} \\<union> \\<Union> (interval_of ` set xs)\n 2. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next ba \\<noteq> a;\n        a \\<le> b \\<and> aa \\<le> ba \\<and> word_next b = aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {a..ba} \\<union> \\<Union> (interval_of ` set xs)\n 3. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next ba \\<noteq> a;\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next b \\<noteq> aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_adjacent (a, b) xs))", "apply(drule(2) word_adjacent_union)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba); word_next b \\<noteq> aa; a \\<le> b;\n        aa \\<le> ba; {aa..ba} \\<union> {a..b} = {aa..b}\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..b} \\<union> \\<Union> (interval_of ` set xs)\n 2. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next ba \\<noteq> a;\n        a \\<le> b \\<and> aa \\<le> ba \\<and> word_next b = aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {a..ba} \\<union> \\<Union> (interval_of ` set xs)\n 3. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next ba \\<noteq> a;\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next b \\<noteq> aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_adjacent (a, b) xs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a_..b_} \\<union> \\<Union> (interval_of ` set xs_) =\n             \\<Union> (interval_of ` set (merge_adjacent (a_, b_) xs_));\n     A = (a_, b_); x_ = (aa_, ba_); word_next b_ \\<noteq> aa_; a_ \\<le> b_;\n     aa_ \\<le> ba_; {aa_..ba_} \\<union> {a_..b_} = {aa_..b_}\\<rbrakk>\n    \\<Longrightarrow> {a_..b_} \\<union>\n                      ({aa_..ba_} \\<union>\n                       \\<Union> (interval_of ` set xs_)) =\n                      {aa_..b_} \\<union> \\<Union> (interval_of ` set xs_)", "by (blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next ba \\<noteq> a;\n        a \\<le> b \\<and> aa \\<le> ba \\<and> word_next b = aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {a..ba} \\<union> \\<Union> (interval_of ` set xs)\n 2. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next ba \\<noteq> a;\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next b \\<noteq> aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_adjacent (a, b) xs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{a_..b_} \\<union> \\<Union> (interval_of ` set xs_) =\n             \\<Union> (interval_of ` set (merge_adjacent (a_, b_) xs_));\n     A = (a_, b_); x_ = (aa_, ba_);\n     aa_ \\<le> ba_ \\<longrightarrow>\n     a_ \\<le> b_ \\<longrightarrow> word_next ba_ \\<noteq> a_;\n     a_ \\<le> b_ \\<and> aa_ \\<le> ba_ \\<and> word_next b_ = aa_\\<rbrakk>\n    \\<Longrightarrow> {a_..b_} \\<union>\n                      ({aa_..ba_} \\<union>\n                       \\<Union> (interval_of ` set xs_)) =\n                      {a_..ba_} \\<union> \\<Union> (interval_of ` set xs_)", "by (metis word_adjacent_union Un_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b aa ba.\n       \\<lbrakk>{a..b} \\<union> \\<Union> (interval_of ` set xs) =\n                \\<Union> (interval_of ` set (merge_adjacent (a, b) xs));\n        A = (a, b); x = (aa, ba);\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next ba \\<noteq> a;\n        aa \\<le> ba \\<longrightarrow>\n        a \\<le> b \\<longrightarrow> word_next b \\<noteq> aa\\<rbrakk>\n       \\<Longrightarrow> {a..b} \\<union>\n                         ({aa..ba} \\<union>\n                          \\<Union> (interval_of ` set xs)) =\n                         {aa..ba} \\<union>\n                         \\<Union>\n                          (interval_of ` set (merge_adjacent (a, b) xs))", "by blast"], ["", "private"], ["", "lemma merge_adjacent_length:\n    \"\\<exists>(s', e')\\<in>set ss. s \\<le> e \\<and> s' \\<le> e' \\<and> (word_next e = s' \\<or> word_next e' = s)\n     \\<Longrightarrow> length (merge_adjacent (s,e) ss) = length ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(s', e')\\<in>set ss.\n       s \\<le> e \\<and>\n       s' \\<le> e' \\<and>\n       (word_next e = s' \\<or> word_next e' = s) \\<Longrightarrow>\n    length (merge_adjacent (s, e) ss) = length ss", "apply(induction ss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>(s', e')\\<in>set [].\n       s \\<le> e \\<and>\n       s' \\<le> e' \\<and>\n       (word_next e = s' \\<or> word_next e' = s) \\<Longrightarrow>\n    length (merge_adjacent (s, e) []) = length []\n 2. \\<And>a ss.\n       \\<lbrakk>\\<exists>(s', e')\\<in>set ss.\n                   s \\<le> e \\<and>\n                   s' \\<le> e' \\<and>\n                   (word_next e = s' \\<or>\n                    word_next e' = s) \\<Longrightarrow>\n                length (merge_adjacent (s, e) ss) = length ss;\n        \\<exists>(s', e')\\<in>set (a # ss).\n           s \\<le> e \\<and>\n           s' \\<le> e' \\<and>\n           (word_next e = s' \\<or> word_next e' = s)\\<rbrakk>\n       \\<Longrightarrow> length (merge_adjacent (s, e) (a # ss)) =\n                         length (a # ss)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>\\<exists>(s', e')\\<in>set ss.\n                   s \\<le> e \\<and>\n                   s' \\<le> e' \\<and>\n                   (word_next e = s' \\<or>\n                    word_next e' = s) \\<Longrightarrow>\n                length (merge_adjacent (s, e) ss) = length ss;\n        \\<exists>(s', e')\\<in>set (a # ss).\n           s \\<le> e \\<and>\n           s' \\<le> e' \\<and>\n           (word_next e = s' \\<or> word_next e' = s)\\<rbrakk>\n       \\<Longrightarrow> length (merge_adjacent (s, e) (a # ss)) =\n                         length (a # ss)", "apply(rename_tac x xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<exists>(s', e')\\<in>set xs.\n                   s \\<le> e \\<and>\n                   s' \\<le> e' \\<and>\n                   (word_next e = s' \\<or>\n                    word_next e' = s) \\<Longrightarrow>\n                length (merge_adjacent (s, e) xs) = length xs;\n        \\<exists>(s', e')\\<in>set (x # xs).\n           s \\<le> e \\<and>\n           s' \\<le> e' \\<and>\n           (word_next e = s' \\<or> word_next e' = s)\\<rbrakk>\n       \\<Longrightarrow> length (merge_adjacent (s, e) (x # xs)) =\n                         length (x # xs)", "apply(case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b.\n       \\<lbrakk>\\<exists>(s', e')\\<in>set xs.\n                   s \\<le> e \\<and>\n                   s' \\<le> e' \\<and>\n                   (word_next e = s' \\<or>\n                    word_next e' = s) \\<Longrightarrow>\n                length (merge_adjacent (s, e) xs) = length xs;\n        \\<exists>(s', e')\\<in>set (x # xs).\n           s \\<le> e \\<and>\n           s' \\<le> e' \\<and> (word_next e = s' \\<or> word_next e' = s);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length (merge_adjacent (s, e) (x # xs)) =\n                         length (x # xs)", "apply(simp add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b.\n       \\<lbrakk>\\<exists>x\\<in>set xs.\n                   case x of\n                   (s', e') \\<Rightarrow>\n                     s' \\<le> e' \\<and>\n                     (word_next e = s' \\<or>\n                      word_next e' = s) \\<Longrightarrow>\n                length (merge_adjacent (s, e) xs) = length xs;\n        s \\<le> e \\<and>\n        (a \\<le> b \\<and> (word_next e = a \\<or> word_next b = s) \\<or>\n         (\\<exists>x\\<in>set xs.\n             case x of\n             (s', e') \\<Rightarrow>\n               s' \\<le> e' \\<and>\n               (word_next e = s' \\<or> word_next e' = s)));\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a \\<le> b \\<longrightarrow>\n                          word_next b \\<noteq> s) \\<longrightarrow>\n                         (a \\<le> b \\<longrightarrow>\n                          word_next e \\<noteq> a) \\<longrightarrow>\n                         length (merge_adjacent (s, e) xs) = length xs", "by blast"], ["", "private"], ["", "function listwordinterval_adjacent\n    :: \"(('a::len) word \\<times> ('a::len) word) list \\<Rightarrow> ('a word \\<times> 'a word) list\" where\n    \"listwordinterval_adjacent [] = []\" |\n    \"listwordinterval_adjacent ((s,e)#ss) = (\n            if \\<forall>(s',e') \\<in> set ss. \\<not> (s \\<le>e \\<and> s' \\<le> e' \\<and> (word_next e = s' \\<or> word_next e' = s))\n            then (s,e)#listwordinterval_adjacent ss\n            else listwordinterval_adjacent (merge_adjacent (s,e) ss))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>s e ss. x = (s, e) # ss \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. [] = [] \\<Longrightarrow> [] = []\n 3. \\<And>s e ss.\n       [] = (s, e) # ss \\<Longrightarrow>\n       [] =\n       (if \\<forall>(s', e')\\<in>set ss.\n              \\<not> (s \\<le> e \\<and>\n                      s' \\<le> e' \\<and>\n                      (word_next e = s' \\<or> word_next e' = s))\n        then (s, e) # listwordinterval_adjacent_sumC ss\n        else listwordinterval_adjacent_sumC (merge_adjacent (s, e) ss))\n 4. \\<And>s e ss sa ea ssa.\n       (s, e) # ss = (sa, ea) # ssa \\<Longrightarrow>\n       (if \\<forall>(s', e')\\<in>set ss.\n              \\<not> (s \\<le> e \\<and>\n                      s' \\<le> e' \\<and>\n                      (word_next e = s' \\<or> word_next e' = s))\n        then (s, e) # listwordinterval_adjacent_sumC ss\n        else listwordinterval_adjacent_sumC (merge_adjacent (s, e) ss)) =\n       (if \\<forall>(s', e')\\<in>set ssa.\n              \\<not> (sa \\<le> ea \\<and>\n                      s' \\<le> e' \\<and>\n                      (word_next ea = s' \\<or> word_next e' = sa))\n        then (sa, ea) # listwordinterval_adjacent_sumC ssa\n        else listwordinterval_adjacent_sumC (merge_adjacent (sa, ea) ssa))", "by(pat_completeness, auto)"], ["", "private"], ["", "termination listwordinterval_adjacent"], ["proof (prove)\ngoal (1 subgoal):\n 1. All listwordinterval_adjacent_dom", "apply (relation \"measure length\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (measure length)\n 2. \\<And>s e ss.\n       \\<forall>(s', e')\\<in>set ss.\n          \\<not> (s \\<le> e \\<and>\n                  s' \\<le> e' \\<and>\n                  (word_next e = s' \\<or>\n                   word_next e' = s)) \\<Longrightarrow>\n       (ss, (s, e) # ss) \\<in> measure length\n 3. \\<And>s e ss.\n       \\<not> (\\<forall>(s', e')\\<in>set ss.\n                  \\<not> (s \\<le> e \\<and>\n                          s' \\<le> e' \\<and>\n                          (word_next e = s' \\<or>\n                           word_next e' = s))) \\<Longrightarrow>\n       (merge_adjacent (s, e) ss, (s, e) # ss) \\<in> measure length", "apply(rule wf_measure)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s e ss.\n       \\<forall>(s', e')\\<in>set ss.\n          \\<not> (s \\<le> e \\<and>\n                  s' \\<le> e' \\<and>\n                  (word_next e = s' \\<or>\n                   word_next e' = s)) \\<Longrightarrow>\n       (ss, (s, e) # ss) \\<in> measure length\n 2. \\<And>s e ss.\n       \\<not> (\\<forall>(s', e')\\<in>set ss.\n                  \\<not> (s \\<le> e \\<and>\n                          s' \\<le> e' \\<and>\n                          (word_next e = s' \\<or>\n                           word_next e' = s))) \\<Longrightarrow>\n       (merge_adjacent (s, e) ss, (s, e) # ss) \\<in> measure length", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s e ss.\n       \\<not> (\\<forall>(s', e')\\<in>set ss.\n                  \\<not> (s \\<le> e \\<and>\n                          s' \\<le> e' \\<and>\n                          (word_next e = s' \\<or>\n                           word_next e' = s))) \\<Longrightarrow>\n       (merge_adjacent (s, e) ss, (s, e) # ss) \\<in> measure length", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s e ss.\n       \\<exists>x\\<in>set ss.\n          \\<not> (case x of\n                  (s', e') \\<Rightarrow>\n                    s' \\<le> e' \\<longrightarrow>\n                    s \\<le> e \\<longrightarrow>\n                    word_next e \\<noteq> s' \\<and>\n                    word_next e' \\<noteq> s) \\<Longrightarrow>\n       length (merge_adjacent (s, e) ss) < Suc (length ss)", "using merge_adjacent_length"], ["proof (prove)\nusing this:\n  \\<exists>(s', e')\\<in>set ?ss.\n     ?s \\<le> ?e \\<and>\n     s' \\<le> e' \\<and>\n     (word_next ?e = s' \\<or> word_next e' = ?s) \\<Longrightarrow>\n  length (merge_adjacent (?s, ?e) ?ss) = length ?ss\n\ngoal (1 subgoal):\n 1. \\<And>s e ss.\n       \\<exists>x\\<in>set ss.\n          \\<not> (case x of\n                  (s', e') \\<Rightarrow>\n                    s' \\<le> e' \\<longrightarrow>\n                    s \\<le> e \\<longrightarrow>\n                    word_next e \\<noteq> s' \\<and>\n                    word_next e' \\<noteq> s) \\<Longrightarrow>\n       length (merge_adjacent (s, e) ss) < Suc (length ss)", "by fastforce"], ["", "private"], ["", "lemma listwordinterval_adjacent:\n    \"(\\<Union>s \\<in> set (listwordinterval_adjacent ss). interval_of s) = (\\<Union>s \\<in> set ss. interval_of s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (interval_of ` set (listwordinterval_adjacent ss)) =\n    \\<Union> (interval_of ` set ss)", "apply(induction ss rule: listwordinterval_adjacent.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Union> (interval_of ` set (listwordinterval_adjacent [])) =\n    \\<Union> (interval_of ` set [])\n 2. \\<And>s e ss.\n       \\<lbrakk>\\<forall>(s', e')\\<in>set ss.\n                   \\<not> (s \\<le> e \\<and>\n                           s' \\<le> e' \\<and>\n                           (word_next e = s' \\<or>\n                            word_next e' = s)) \\<Longrightarrow>\n                \\<Union>\n                 (interval_of ` set (listwordinterval_adjacent ss)) =\n                \\<Union> (interval_of ` set ss);\n        \\<not> (\\<forall>(s', e')\\<in>set ss.\n                   \\<not> (s \\<le> e \\<and>\n                           s' \\<le> e' \\<and>\n                           (word_next e = s' \\<or>\n                            word_next e' = s))) \\<Longrightarrow>\n        \\<Union>\n         (interval_of `\n          set (listwordinterval_adjacent (merge_adjacent (s, e) ss))) =\n        \\<Union> (interval_of ` set (merge_adjacent (s, e) ss))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (interval_of `\n                           set (listwordinterval_adjacent ((s, e) # ss))) =\n                         \\<Union> (interval_of ` set ((s, e) # ss))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s e ss.\n       \\<lbrakk>\\<forall>(s', e')\\<in>set ss.\n                   \\<not> (s \\<le> e \\<and>\n                           s' \\<le> e' \\<and>\n                           (word_next e = s' \\<or>\n                            word_next e' = s)) \\<Longrightarrow>\n                \\<Union>\n                 (interval_of ` set (listwordinterval_adjacent ss)) =\n                \\<Union> (interval_of ` set ss);\n        \\<not> (\\<forall>(s', e')\\<in>set ss.\n                   \\<not> (s \\<le> e \\<and>\n                           s' \\<le> e' \\<and>\n                           (word_next e = s' \\<or>\n                            word_next e' = s))) \\<Longrightarrow>\n        \\<Union>\n         (interval_of `\n          set (listwordinterval_adjacent (merge_adjacent (s, e) ss))) =\n        \\<Union> (interval_of ` set (merge_adjacent (s, e) ss))\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (interval_of `\n                           set (listwordinterval_adjacent ((s, e) # ss))) =\n                         \\<Union> (interval_of ` set ((s, e) # ss))", "apply(simp add: merge_adjacent_helper)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"listwordinterval_adjacent [(1::16 word, 3), (5, 10), (10,10), (4,4)] = [(10, 10), (1, 10)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. listwordinterval_adjacent [(1, 3), (5, 10), (10, 10), (4, 4)] =\n    [(10, 10), (1, 10)]", "by eval"], ["", "text\\<open>END merging adjacent intervals\\<close>"], ["", "definition wordinterval_compress :: \"('a::len) wordinterval \\<Rightarrow> 'a wordinterval\" where\n    \"wordinterval_compress r \\<equiv>\n      l2wi (remdups (listwordinterval_adjacent (listwordinterval_compress\n        (wi2l (wordinterval_optimize_empty r)))))\""], ["", "text\\<open>Correctness: Compression preserves semantics\\<close>"], ["", "lemma wordinterval_compress:\n    \"wordinterval_to_set (wordinterval_compress r) = wordinterval_to_set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (wordinterval_compress r) = wordinterval_to_set r", "unfolding wordinterval_compress_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    wordinterval_to_set r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    wordinterval_to_set r", "have interval_of': \"interval_of s = (case s of (s,e) \\<Rightarrow> {s .. e})\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. interval_of s = (case s of (s, e) \\<Rightarrow> {s..e})", "by (cases s) (simp add: interval_of.simps)"], ["proof (state)\nthis:\n  interval_of ?s1 = (case ?s1 of (s, e) \\<Rightarrow> {s..e})\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    wordinterval_to_set r", "have \"wordinterval_to_set (l2wi (remdups (listwordinterval_adjacent\n              (listwordinterval_compress (wi2l (wordinterval_optimize_empty r)))))) =\n            (\\<Union>x\\<in>set (listwordinterval_adjacent (listwordinterval_compress\n                (wi2l (wordinterval_optimize_empty r)))). interval_of x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    \\<Union>\n     (interval_of `\n      set (listwordinterval_adjacent\n            (listwordinterval_compress\n              (wi2l (wordinterval_optimize_empty r)))))", "by (force simp: interval_of' l2wi)"], ["proof (state)\nthis:\n  wordinterval_to_set\n   (l2wi\n     (remdups\n       (listwordinterval_adjacent\n         (listwordinterval_compress\n           (wi2l (wordinterval_optimize_empty r)))))) =\n  \\<Union>\n   (interval_of `\n    set (listwordinterval_adjacent\n          (listwordinterval_compress\n            (wi2l (wordinterval_optimize_empty r)))))\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    wordinterval_to_set r", "also"], ["proof (state)\nthis:\n  wordinterval_to_set\n   (l2wi\n     (remdups\n       (listwordinterval_adjacent\n         (listwordinterval_compress\n           (wi2l (wordinterval_optimize_empty r)))))) =\n  \\<Union>\n   (interval_of `\n    set (listwordinterval_adjacent\n          (listwordinterval_compress\n            (wi2l (wordinterval_optimize_empty r)))))\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    wordinterval_to_set r", "have \"\\<dots> =  (\\<Union>s\\<in>set (wi2l (wordinterval_optimize_empty r)). interval_of s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (interval_of `\n      set (listwordinterval_adjacent\n            (listwordinterval_compress\n              (wi2l (wordinterval_optimize_empty r))))) =\n    \\<Union> (interval_of ` set (wi2l (wordinterval_optimize_empty r)))", "by(simp add: listwordinterval_compress listwordinterval_adjacent)"], ["proof (state)\nthis:\n  \\<Union>\n   (interval_of `\n    set (listwordinterval_adjacent\n          (listwordinterval_compress\n            (wi2l (wordinterval_optimize_empty r))))) =\n  \\<Union> (interval_of ` set (wi2l (wordinterval_optimize_empty r)))\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    wordinterval_to_set r", "also"], ["proof (state)\nthis:\n  \\<Union>\n   (interval_of `\n    set (listwordinterval_adjacent\n          (listwordinterval_compress\n            (wi2l (wordinterval_optimize_empty r))))) =\n  \\<Union> (interval_of ` set (wi2l (wordinterval_optimize_empty r)))\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    wordinterval_to_set r", "have \"\\<dots> = (\\<Union>(i, j)\\<in>set (wi2l (wordinterval_optimize_empty r)). {i..j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (interval_of ` set (wi2l (wordinterval_optimize_empty r))) =\n    (\\<Union>(i, j)\\<in>set (wi2l (wordinterval_optimize_empty r)). {i..j})", "by(simp add: interval_of')"], ["proof (state)\nthis:\n  \\<Union> (interval_of ` set (wi2l (wordinterval_optimize_empty r))) =\n  (\\<Union>(i, j)\\<in>set (wi2l (wordinterval_optimize_empty r)). {i..j})\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    wordinterval_to_set r", "also"], ["proof (state)\nthis:\n  \\<Union> (interval_of ` set (wi2l (wordinterval_optimize_empty r))) =\n  (\\<Union>(i, j)\\<in>set (wi2l (wordinterval_optimize_empty r)). {i..j})\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    wordinterval_to_set r", "have \"\\<dots> = wordinterval_to_set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(i, j)\\<in>set (wi2l (wordinterval_optimize_empty r)).\n        {i..j}) =\n    wordinterval_to_set r", "by(simp add: wi2l)"], ["proof (state)\nthis:\n  (\\<Union>(i, j)\\<in>set (wi2l (wordinterval_optimize_empty r)). {i..j}) =\n  wordinterval_to_set r\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    wordinterval_to_set r", "finally"], ["proof (chain)\npicking this:\n  wordinterval_to_set\n   (l2wi\n     (remdups\n       (listwordinterval_adjacent\n         (listwordinterval_compress\n           (wi2l (wordinterval_optimize_empty r)))))) =\n  wordinterval_to_set r", "show \"wordinterval_to_set\n        (l2wi (remdups (listwordinterval_adjacent (listwordinterval_compress\n            (wi2l (wordinterval_optimize_empty r))))))\n          = wordinterval_to_set r\""], ["proof (prove)\nusing this:\n  wordinterval_to_set\n   (l2wi\n     (remdups\n       (listwordinterval_adjacent\n         (listwordinterval_compress\n           (wi2l (wordinterval_optimize_empty r)))))) =\n  wordinterval_to_set r\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (l2wi\n       (remdups\n         (listwordinterval_adjacent\n           (listwordinterval_compress\n             (wi2l (wordinterval_optimize_empty r)))))) =\n    wordinterval_to_set r", "."], ["proof (state)\nthis:\n  wordinterval_to_set\n   (l2wi\n     (remdups\n       (listwordinterval_adjacent\n         (listwordinterval_compress\n           (wi2l (wordinterval_optimize_empty r)))))) =\n  wordinterval_to_set r\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>Example\\<close>"], ["", "lemma \"(wi2l \\<circ> (wordinterval_compress :: 32 wordinterval \\<Rightarrow> 32 wordinterval) \\<circ> l2wi)\n          [(70, 80001), (0,0), (150, 8000), (1,3), (42,41), (3,7), (56, 200), (8,10)] =\n          [(56, 80001), (0, 10)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wi2l \\<circ> wordinterval_compress \\<circ> l2wi)\n     [(70, 80001), (0, 0), (150, 8000), (1, 3), (42, 41), (3, 7), (56, 200),\n      (8, 10)] =\n    [(56, 80001), (0, 10)]", "by eval"], ["", "lemma \"wordinterval_compress (RangeUnion (RangeUnion (WordInterval (1::32 word) 5)\n                                                        (WordInterval 8 10)) (WordInterval 3 7)) =\n       WordInterval 1 10\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_compress\n     (RangeUnion (RangeUnion (WordInterval 1 5) (WordInterval 8 10))\n       (WordInterval 3 7)) =\n    WordInterval 1 10", "by eval"], ["", "subsection\\<open>Further operations\\<close>"], ["", "text\\<open>\\<open>\\<Union>\\<close>\\<close>"], ["", "definition wordinterval_Union :: \"('a::len) wordinterval list \\<Rightarrow> 'a wordinterval\" where\n    \"wordinterval_Union ws = wordinterval_compress (foldr wordinterval_union ws Empty_WordInterval)\""], ["", "lemma wordinterval_Union:\n    \"wordinterval_to_set (wordinterval_Union ws) = (\\<Union> w \\<in> (set ws). wordinterval_to_set w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (wordinterval_Union ws) =\n    \\<Union> (wordinterval_to_set ` set ws)", "by(induction ws) (simp_all add: wordinterval_compress wordinterval_Union_def)"], ["", "context\nbegin"], ["", "private"], ["", "fun wordinterval_setminus'\n    :: \"'a::len wordinterval \\<Rightarrow> 'a wordinterval \\<Rightarrow> 'a wordinterval\" where\n    \"wordinterval_setminus' (WordInterval s e) (WordInterval ms me) = (\n      if s > e \\<or> ms > me then WordInterval s e else\n      if me \\<ge> e\n        then\n          WordInterval (if ms = 0 then 1 else s) (min e (word_prev ms))\n        else if ms \\<le> s\n        then\n          WordInterval (max s (word_next me)) (if me = max_word then 0 else e)\n        else\n          RangeUnion (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n                     (WordInterval (word_next me) (if me = max_word then 0 else e))\n        )\" |\n     \"wordinterval_setminus' (RangeUnion r1 r2) t =\n        RangeUnion (wordinterval_setminus' r1 t) (wordinterval_setminus' r2 t)\"|\n     \"wordinterval_setminus' t (RangeUnion r1 r2) =\n        wordinterval_setminus' (wordinterval_setminus' t r1) r2\""], ["", "private"], ["", "lemma wordinterval_setminus'_rr_set_eq:\n    \"wordinterval_to_set(wordinterval_setminus' (WordInterval s e) (WordInterval ms me)) =\n    wordinterval_to_set (WordInterval s e) - wordinterval_to_set (WordInterval ms me)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (wordinterval_setminus' (WordInterval s e) (WordInterval ms me)) =\n    wordinterval_to_set (WordInterval s e) -\n    wordinterval_to_set (WordInterval ms me)", "apply(simp only: wordinterval_setminus'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (if e < s \\<or> me < ms then WordInterval s e\n      else if e \\<le> me\n           then WordInterval (if ms = 0 then 1 else s)\n                 (min e (word_prev ms))\n           else if ms \\<le> s\n                then WordInterval (max s (word_next me))\n                      (if me = - 1 then 0 else e)\n                else RangeUnion\n                      (WordInterval (if ms = 0 then 1 else s)\n                        (word_prev ms))\n                      (WordInterval (word_next me)\n                        (if me = - 1 then 0 else e))) =\n    wordinterval_to_set (WordInterval s e) -\n    wordinterval_to_set (WordInterval ms me)", "apply(case_tac \"e < s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. e < s \\<Longrightarrow>\n    wordinterval_to_set\n     (if e < s \\<or> me < ms then WordInterval s e\n      else if e \\<le> me\n           then WordInterval (if ms = 0 then 1 else s)\n                 (min e (word_prev ms))\n           else if ms \\<le> s\n                then WordInterval (max s (word_next me))\n                      (if me = - 1 then 0 else e)\n                else RangeUnion\n                      (WordInterval (if ms = 0 then 1 else s)\n                        (word_prev ms))\n                      (WordInterval (word_next me)\n                        (if me = - 1 then 0 else e))) =\n    wordinterval_to_set (WordInterval s e) -\n    wordinterval_to_set (WordInterval ms me)\n 2. \\<not> e < s \\<Longrightarrow>\n    wordinterval_to_set\n     (if e < s \\<or> me < ms then WordInterval s e\n      else if e \\<le> me\n           then WordInterval (if ms = 0 then 1 else s)\n                 (min e (word_prev ms))\n           else if ms \\<le> s\n                then WordInterval (max s (word_next me))\n                      (if me = - 1 then 0 else e)\n                else RangeUnion\n                      (WordInterval (if ms = 0 then 1 else s)\n                        (word_prev ms))\n                      (WordInterval (word_next me)\n                        (if me = - 1 then 0 else e))) =\n    wordinterval_to_set (WordInterval s e) -\n    wordinterval_to_set (WordInterval ms me)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> e < s \\<Longrightarrow>\n    wordinterval_to_set\n     (if e < s \\<or> me < ms then WordInterval s e\n      else if e \\<le> me\n           then WordInterval (if ms = 0 then 1 else s)\n                 (min e (word_prev ms))\n           else if ms \\<le> s\n                then WordInterval (max s (word_next me))\n                      (if me = - 1 then 0 else e)\n                else RangeUnion\n                      (WordInterval (if ms = 0 then 1 else s)\n                        (word_prev ms))\n                      (WordInterval (word_next me)\n                        (if me = - 1 then 0 else e))) =\n    wordinterval_to_set (WordInterval s e) -\n    wordinterval_to_set (WordInterval ms me)", "apply(case_tac \"me < ms\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> e < s; me < ms\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 2. \\<lbrakk>\\<not> e < s; \\<not> me < ms\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> e < s; \\<not> me < ms\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)", "apply(case_tac [!] \"e \\<le> me\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 2. \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)", "apply(case_tac [!] \"ms = 0\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms = 0\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 2. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me;\n     ms \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 3. \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n     ms = 0\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 4. \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n     ms \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)", "apply(case_tac [!] \"ms \\<le> s\")"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms = 0;\n     ms \\<le> s\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 2. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms = 0;\n     \\<not> ms \\<le> s\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 3. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n     ms \\<le> s\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 4. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n     \\<not> ms \\<le> s\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 5. \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me; ms = 0;\n     ms \\<le> s\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 6. \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me; ms = 0;\n     \\<not> ms \\<le> s\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 7. \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me; ms \\<noteq> 0;\n     ms \\<le> s\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 8. \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me; ms \\<noteq> 0;\n     \\<not> ms \\<le> s\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)", "apply(case_tac [!] \"me = max_word\")"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms = 0; ms \\<le> s;\n     me = - 1\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 2. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms = 0; ms \\<le> s;\n     me \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 3. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms = 0;\n     \\<not> ms \\<le> s; me = - 1\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 4. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms = 0;\n     \\<not> ms \\<le> s; me \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 5. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n     ms \\<le> s; me = - 1\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 6. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n     ms \\<le> s; me \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 7. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n     \\<not> ms \\<le> s; me = - 1\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 8. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n     \\<not> ms \\<le> s; me \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 9. \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me; ms = 0;\n     ms \\<le> s; me = - 1\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (if e < s \\<or> me < ms then WordInterval s e\n                        else if e \\<le> me\n                             then WordInterval (if ms = 0 then 1 else s)\n                                   (min e (word_prev ms))\n                             else if ms \\<le> s\n                                  then WordInterval (max s (word_next me))\n  (if me = - 1 then 0 else e)\n                                  else RangeUnion\n  (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n  (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                      wordinterval_to_set (WordInterval s e) -\n                      wordinterval_to_set (WordInterval ms me)\n 10. \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me; ms = 0;\n      ms \\<le> s; me \\<noteq> - 1\\<rbrakk>\n     \\<Longrightarrow> wordinterval_to_set\n                        (if e < s \\<or> me < ms then WordInterval s e\n                         else if e \\<le> me\n                              then WordInterval (if ms = 0 then 1 else s)\n                                    (min e (word_prev ms))\n                              else if ms \\<le> s\n                                   then WordInterval (max s (word_next me))\n   (if me = - 1 then 0 else e)\n                                   else RangeUnion\n   (WordInterval (if ms = 0 then 1 else s) (word_prev ms))\n   (WordInterval (word_next me) (if me = - 1 then 0 else e))) =\n                       wordinterval_to_set (WordInterval s e) -\n                       wordinterval_to_set (WordInterval ms me)\nA total of 16 subgoals...", "apply(simp_all add: word_next_unfold word_prev_unfold min_def max_def)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<not> e < s; ms = 0; me = - 1\\<rbrakk>\n    \\<Longrightarrow> {} = {s..e} - {0..- 1}\n 2. \\<lbrakk>\\<not> e < s; e \\<le> me; ms = 0; me \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> {} = {s..e} - {0..me}\n 3. \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; ms \\<le> s; me = - 1\\<rbrakk>\n    \\<Longrightarrow> (e \\<le> ms - 1 \\<longrightarrow>\n                       {s..e} = {s..e} - {ms..- 1}) \\<and>\n                      (\\<not> e \\<le> ms - 1 \\<longrightarrow>\n                       {s..ms - 1} = {s..e} - {ms..- 1})\n 4. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n     ms \\<le> s; me \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> (e \\<le> ms - 1 \\<longrightarrow>\n                       {s..e} = {s..e} - {ms..me}) \\<and>\n                      (\\<not> e \\<le> ms - 1 \\<longrightarrow>\n                       {s..ms - 1} = {s..e} - {ms..me})\n 5. \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s;\n     me = - 1\\<rbrakk>\n    \\<Longrightarrow> (e \\<le> ms - 1 \\<longrightarrow>\n                       {s..e} = {s..e} - {ms..- 1}) \\<and>\n                      (\\<not> e \\<le> ms - 1 \\<longrightarrow>\n                       {s..ms - 1} = {s..e} - {ms..- 1})\n 6. \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n     \\<not> ms \\<le> s; me \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> (e \\<le> ms - 1 \\<longrightarrow>\n                       {s..e} = {s..e} - {ms..me}) \\<and>\n                      (\\<not> e \\<le> ms - 1 \\<longrightarrow>\n                       {s..ms - 1} = {s..e} - {ms..me})\n 7. \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0;\n     me \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> (s \\<le> me + 1 \\<longrightarrow>\n                       {me + 1..e} = {s..e} - {0..me}) \\<and>\n                      (\\<not> s \\<le> me + 1 \\<longrightarrow>\n                       {s..e} = {s..e} - {0..me})\n 8. \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me; ms \\<noteq> 0;\n     ms \\<le> s; me \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> (s \\<le> me + 1 \\<longrightarrow>\n                       {me + 1..e} = {s..e} - {ms..me}) \\<and>\n                      (\\<not> s \\<le> me + 1 \\<longrightarrow>\n                       {s..e} = {s..e} - {ms..me})\n 9. \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me; ms \\<noteq> 0;\n     \\<not> ms \\<le> s; me \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> {s..ms - 1} \\<union> {me + 1..e} = {s..e} - {ms..me}", "apply(safe)"], ["proof (prove)\ngoal (31 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms = 0; me = - 1; x \\<in> {s..e};\n        x \\<notin> {0..- 1}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; e \\<le> me; ms = 0; me \\<noteq> - 1;\n        x \\<in> {s..e}; x \\<notin> {0..me}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; ms \\<le> s; me = - 1;\n        e \\<le> ms - 1; x \\<in> {s..e}; x \\<in> {ms..- 1}\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; x \\<in> {s..ms - 1}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {s..e}\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; x \\<in> {s..ms - 1};\n        x \\<in> {ms..- 1}\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; x \\<in> {s..e}; x \\<notin> {ms..- 1}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {s..ms - 1}\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; x \\<in> {s..e};\n        x \\<in> {ms..me}\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        x \\<in> {s..ms - 1}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {s..e}\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        x \\<in> {s..ms - 1}; x \\<in> {ms..me}\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n         ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1; x \\<in> {s..e};\n         x \\<notin> {ms..me}\\<rbrakk>\n        \\<Longrightarrow> x \\<in> {s..ms - 1}\nA total of 31 subgoals...", "apply(auto)"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; ms \\<le> s; me = - 1;\n        e \\<le> ms - 1; ms \\<le> x; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; ms \\<le> x; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; s \\<le> x; x \\<le> e;\n        ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1; s \\<le> x;\n        x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        e \\<le> ms - 1; ms \\<le> x; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; ms \\<le> x; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; \\<not> ms \\<le> x; s \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; s \\<le> x;\n        x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n         \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n         s \\<le> x; x \\<le> e; \\<not> ms \\<le> x\\<rbrakk>\n        \\<Longrightarrow> x \\<le> ms - 1\nA total of 22 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; ms \\<le> x; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; s \\<le> x; x \\<le> e;\n        ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1; s \\<le> x;\n        x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        e \\<le> ms - 1; ms \\<le> x; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; ms \\<le> x; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; \\<not> ms \\<le> x; s \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; s \\<le> x;\n        x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> e; \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n         s \\<le> me + 1; x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 21 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; s \\<le> x; x \\<le> e;\n        ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1; s \\<le> x;\n        x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        e \\<le> ms - 1; ms \\<le> x; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; ms \\<le> x; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; \\<not> ms \\<le> x; s \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; s \\<le> x;\n        x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> e; \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n         s \\<le> me + 1; \\<not> x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n        \\<Longrightarrow> me + 1 \\<le> x\nA total of 20 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1; s \\<le> x;\n        x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        e \\<le> ms - 1; ms \\<le> x; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; ms \\<le> x; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; \\<not> ms \\<le> x; s \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; s \\<le> x;\n        x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> e; \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; \\<not> x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n         \\<not> s \\<le> me + 1; x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 19 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        e \\<le> ms - 1; ms \\<le> x; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; ms \\<le> x; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; \\<not> ms \\<le> x; s \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; s \\<le> x;\n        x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> e; \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; \\<not> x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        \\<not> s \\<le> me + 1; x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n         ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n         me + 1 \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 18 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; ms \\<le> x; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; \\<not> ms \\<le> x; s \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; s \\<le> x;\n        x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> e; \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; \\<not> x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        \\<not> s \\<le> me + 1; x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        me + 1 \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n         ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n         s \\<le> x; x \\<le> e; \\<not> x \\<le> me\\<rbrakk>\n        \\<Longrightarrow> me + 1 \\<le> x\nA total of 17 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; ms \\<noteq> 0; \\<not> ms \\<le> s; me = - 1;\n        \\<not> e \\<le> ms - 1; \\<not> ms \\<le> x; s \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; s \\<le> x;\n        x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> e; \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; \\<not> x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        \\<not> s \\<le> me + 1; x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        me + 1 \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n         ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; \\<not> s \\<le> me + 1;\n         s \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 16 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; e \\<le> ms - 1; s \\<le> x;\n        x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> e; \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; \\<not> x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        \\<not> s \\<le> me + 1; x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        me + 1 \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; \\<not> s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n         ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; s \\<le> x;\n         x \\<le> ms - 1\\<rbrakk>\n        \\<Longrightarrow> x \\<le> e\nA total of 15 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> ms - 1; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> e; \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; \\<not> x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        \\<not> s \\<le> me + 1; x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        me + 1 \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; \\<not> s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> x \\<le> e\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n         ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; me + 1 \\<le> x;\n         x \\<le> e\\<rbrakk>\n        \\<Longrightarrow> s \\<le> x\nA total of 14 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; e \\<le> me; ms \\<noteq> 0;\n        \\<not> ms \\<le> s; me \\<noteq> - 1; \\<not> e \\<le> ms - 1;\n        s \\<le> x; x \\<le> e; \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; \\<not> x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        \\<not> s \\<le> me + 1; x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        me + 1 \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; \\<not> s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> x \\<le> e\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; me + 1 \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> s \\<le> x\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n         ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n         x \\<le> me; s \\<le> x; x \\<le> ms - 1\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 13 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; \\<not> x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        \\<not> s \\<le> me + 1; x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        me + 1 \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; \\<not> s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> x \\<le> e\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; me + 1 \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> s \\<le> x\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; s \\<le> x; x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n         ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n         x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 12 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        s \\<le> me + 1; \\<not> x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        \\<not> s \\<le> me + 1; x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        me + 1 \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; \\<not> s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> x \\<le> e\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; me + 1 \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> s \\<le> x\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; s \\<le> x; x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n         ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n         \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n         \\<not> ms \\<le> x\\<rbrakk>\n        \\<Longrightarrow> x \\<le> ms - 1\nA total of 11 subgoals...", "apply(uint_arith)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> e \\<le> me; ms = 0; me \\<noteq> - 1;\n        \\<not> s \\<le> me + 1; x \\<le> me; s \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        me + 1 \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; \\<not> s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> x \\<le> e\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; me + 1 \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> s \\<le> x\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; s \\<le> x; x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 10. \\<And>x.\n        \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n         ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n         \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n         \\<not> x \\<le> me\\<rbrakk>\n        \\<Longrightarrow> x \\<le> ms - 1", "apply(uint_arith)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        me + 1 \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; \\<not> s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> x \\<le> e\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; me + 1 \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> s \\<le> x\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; s \\<le> x; x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 9. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1", "apply(uint_arith)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> me + 1 \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; \\<not> s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> x \\<le> e\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; me + 1 \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> s \\<le> x\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; s \\<le> x; x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 8. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1", "apply(uint_arith)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; ms \\<le> s; me \\<noteq> - 1; \\<not> s \\<le> me + 1;\n        s \\<le> x; x \\<le> e; ms \\<le> x; x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> x \\<le> e\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; me + 1 \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> s \\<le> x\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; s \\<le> x; x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 7. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1", "apply(uint_arith)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; s \\<le> x;\n        x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> x \\<le> e\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; me + 1 \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> s \\<le> x\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; s \\<le> x; x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 6. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1", "apply(uint_arith)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; me + 1 \\<le> x;\n        x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> s \\<le> x\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; s \\<le> x; x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 5. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1", "apply(uint_arith)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; s \\<le> x; x \\<le> ms - 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 4. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1", "apply(uint_arith)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1; ms \\<le> x;\n        x \\<le> me; me + 1 \\<le> x; x \\<le> e\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 3. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1", "apply(uint_arith)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> ms \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1\n 2. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1", "apply(uint_arith)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> e < s; \\<not> me < ms; \\<not> e \\<le> me;\n        ms \\<noteq> 0; \\<not> ms \\<le> s; me \\<noteq> - 1;\n        \\<not> me + 1 \\<le> x; s \\<le> x; x \\<le> e;\n        \\<not> x \\<le> me\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ms - 1", "apply(uint_arith)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma wordinterval_setminus'_set_eq:\n    \"wordinterval_to_set (wordinterval_setminus' r1 r2) =\n      wordinterval_to_set r1 - wordinterval_to_set r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (wordinterval_setminus' r1 r2) =\n    wordinterval_to_set r1 - wordinterval_to_set r2", "apply(induction rule: wordinterval_setminus'.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s e ms me.\n       wordinterval_to_set\n        (wordinterval_setminus' (WordInterval s e) (WordInterval ms me)) =\n       wordinterval_to_set (WordInterval s e) -\n       wordinterval_to_set (WordInterval ms me)\n 2. \\<And>r1 r2 t.\n       \\<lbrakk>wordinterval_to_set (wordinterval_setminus' r1 t) =\n                wordinterval_to_set r1 - wordinterval_to_set t;\n        wordinterval_to_set (wordinterval_setminus' r2 t) =\n        wordinterval_to_set r2 - wordinterval_to_set t\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (wordinterval_setminus' (RangeUnion r1 r2) t) =\n                         wordinterval_to_set (RangeUnion r1 r2) -\n                         wordinterval_to_set t\n 3. \\<And>v va r1 r2.\n       \\<lbrakk>wordinterval_to_set\n                 (wordinterval_setminus' (WordInterval v va) r1) =\n                wordinterval_to_set (WordInterval v va) -\n                wordinterval_to_set r1;\n        wordinterval_to_set\n         (wordinterval_setminus'\n           (wordinterval_setminus' (WordInterval v va) r1) r2) =\n        wordinterval_to_set\n         (wordinterval_setminus' (WordInterval v va) r1) -\n        wordinterval_to_set r2\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (wordinterval_setminus' (WordInterval v va)\n                            (RangeUnion r1 r2)) =\n                         wordinterval_to_set (WordInterval v va) -\n                         wordinterval_to_set (RangeUnion r1 r2)", "using wordinterval_setminus'_rr_set_eq"], ["proof (prove)\nusing this:\n  wordinterval_to_set\n   (wordinterval_setminus' (WordInterval ?s ?e) (WordInterval ?ms ?me)) =\n  wordinterval_to_set (WordInterval ?s ?e) -\n  wordinterval_to_set (WordInterval ?ms ?me)\n\ngoal (3 subgoals):\n 1. \\<And>s e ms me.\n       wordinterval_to_set\n        (wordinterval_setminus' (WordInterval s e) (WordInterval ms me)) =\n       wordinterval_to_set (WordInterval s e) -\n       wordinterval_to_set (WordInterval ms me)\n 2. \\<And>r1 r2 t.\n       \\<lbrakk>wordinterval_to_set (wordinterval_setminus' r1 t) =\n                wordinterval_to_set r1 - wordinterval_to_set t;\n        wordinterval_to_set (wordinterval_setminus' r2 t) =\n        wordinterval_to_set r2 - wordinterval_to_set t\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (wordinterval_setminus' (RangeUnion r1 r2) t) =\n                         wordinterval_to_set (RangeUnion r1 r2) -\n                         wordinterval_to_set t\n 3. \\<And>v va r1 r2.\n       \\<lbrakk>wordinterval_to_set\n                 (wordinterval_setminus' (WordInterval v va) r1) =\n                wordinterval_to_set (WordInterval v va) -\n                wordinterval_to_set r1;\n        wordinterval_to_set\n         (wordinterval_setminus'\n           (wordinterval_setminus' (WordInterval v va) r1) r2) =\n        wordinterval_to_set\n         (wordinterval_setminus' (WordInterval v va) r1) -\n        wordinterval_to_set r2\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (wordinterval_setminus' (WordInterval v va)\n                            (RangeUnion r1 r2)) =\n                         wordinterval_to_set (WordInterval v va) -\n                         wordinterval_to_set (RangeUnion r1 r2)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r1 r2 t.\n       \\<lbrakk>wordinterval_to_set (wordinterval_setminus' r1 t) =\n                wordinterval_to_set r1 - wordinterval_to_set t;\n        wordinterval_to_set (wordinterval_setminus' r2 t) =\n        wordinterval_to_set r2 - wordinterval_to_set t\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (wordinterval_setminus' (RangeUnion r1 r2) t) =\n                         wordinterval_to_set (RangeUnion r1 r2) -\n                         wordinterval_to_set t\n 2. \\<And>v va r1 r2.\n       \\<lbrakk>wordinterval_to_set\n                 (wordinterval_setminus' (WordInterval v va) r1) =\n                wordinterval_to_set (WordInterval v va) -\n                wordinterval_to_set r1;\n        wordinterval_to_set\n         (wordinterval_setminus'\n           (wordinterval_setminus' (WordInterval v va) r1) r2) =\n        wordinterval_to_set\n         (wordinterval_setminus' (WordInterval v va) r1) -\n        wordinterval_to_set r2\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (wordinterval_setminus' (WordInterval v va)\n                            (RangeUnion r1 r2)) =\n                         wordinterval_to_set (WordInterval v va) -\n                         wordinterval_to_set (RangeUnion r1 r2)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wordinterval_setminus'_empty_struct:\n    \"wordinterval_empty r2 \\<Longrightarrow> wordinterval_setminus' r1 r2 = r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_empty r2 \\<Longrightarrow>\n    wordinterval_setminus' r1 r2 = r1", "by(induction r1 r2 rule: wordinterval_setminus'.induct) auto"], ["", "definition wordinterval_setminus\n    :: \"'a::len wordinterval \\<Rightarrow> 'a::len wordinterval \\<Rightarrow> 'a::len wordinterval\" where\n    \"wordinterval_setminus r1 r2 = wordinterval_compress (wordinterval_setminus' r1 r2)\""], ["", "lemma wordinterval_setminus_set_eq[simp]: \"wordinterval_to_set (wordinterval_setminus r1 r2) =\n    wordinterval_to_set r1 - wordinterval_to_set r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (wordinterval_setminus r1 r2) =\n    wordinterval_to_set r1 - wordinterval_to_set r2", "by(simp add: wordinterval_setminus_def wordinterval_compress wordinterval_setminus'_set_eq)"], ["", "end"], ["", "definition wordinterval_UNIV :: \"'a::len wordinterval\" where\n  \"wordinterval_UNIV \\<equiv> WordInterval 0 max_word\""], ["", "lemma wordinterval_UNIV_set_eq[simp]: \"wordinterval_to_set wordinterval_UNIV = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set wordinterval_UNIV = UNIV", "unfolding wordinterval_UNIV_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (WordInterval 0 (- 1)) = UNIV", "using max_word_max"], ["proof (prove)\nusing this:\n  ?n \\<le> - 1\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (WordInterval 0 (- 1)) = UNIV", "by fastforce"], ["", "fun wordinterval_invert :: \"'a::len wordinterval \\<Rightarrow> 'a::len wordinterval\" where\n  \"wordinterval_invert r = wordinterval_setminus wordinterval_UNIV r\""], ["", "lemma wordinterval_invert_set_eq[simp]:\n  \"wordinterval_to_set (wordinterval_invert r) = UNIV - wordinterval_to_set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (wordinterval_invert r) =\n    UNIV - wordinterval_to_set r", "by(auto)"], ["", "lemma wordinterval_invert_UNIV_empty:\n  \"wordinterval_empty (wordinterval_invert wordinterval_UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_empty (wordinterval_invert wordinterval_UNIV)", "by simp"], ["", "lemma wi2l_univ[simp]: \"wi2l wordinterval_UNIV = [(0, max_word)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wi2l wordinterval_UNIV = [(0, - 1)]", "unfolding wordinterval_UNIV_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wi2l (WordInterval 0 (- 1)) = [(0, - 1)]", "by simp"], ["", "text\\<open>\\<open>\\<inter>\\<close>\\<close>"], ["", "context\nbegin"], ["", "private"], ["", "lemma \"{(s::nat) .. e} \\<inter> {s' .. e'} = {} \\<longleftrightarrow> s > e' \\<or> s' > e \\<or> s > e \\<or> s' > e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({s..e} \\<inter> {s'..e'} = {}) =\n    (e' < s \\<or> e < s' \\<or> e < s \\<or> e' < s')", "by simp linarith"], ["", "private"], ["", "fun wordinterval_intersection'\n    :: \"'a::len wordinterval \\<Rightarrow> 'a::len wordinterval \\<Rightarrow> 'a::len wordinterval\" where\n    \"wordinterval_intersection' (WordInterval s e) (WordInterval s' e') = (\n        if s > e \\<or> s' > e' \\<or> s > e' \\<or> s' > e \\<or> s > e \\<or> s' > e'\n        then\n          Empty_WordInterval\n        else\n          WordInterval (max s s') (min e e')\n        )\" |\n    \"wordinterval_intersection' (RangeUnion r1 r2) t =\n        RangeUnion (wordinterval_intersection' r1 t) (wordinterval_intersection' r2 t)\"|\n    \"wordinterval_intersection' t (RangeUnion r1 r2) =\n        RangeUnion (wordinterval_intersection' t r1) (wordinterval_intersection' t r2)\""], ["", "private"], ["", "lemma wordinterval_intersection'_set_eq:\n    \"wordinterval_to_set (wordinterval_intersection' r1 r2) =\n      wordinterval_to_set r1 \\<inter> wordinterval_to_set r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (wordinterval_intersection' r1 r2) =\n    wordinterval_to_set r1 \\<inter> wordinterval_to_set r2", "by(induction r1 r2 rule: wordinterval_intersection'.induct) (auto)"], ["", "lemma \"wordinterval_intersection'\n          (RangeUnion (RangeUnion (WordInterval (1::32 word) 3) (WordInterval 8 10))\n                      (WordInterval 1 3)) (WordInterval 1 3) =\n          RangeUnion (RangeUnion (WordInterval 1 3) (WordInterval 1 0)) (WordInterval 1 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_intersection'\n     (RangeUnion (RangeUnion (WordInterval 1 3) (WordInterval 8 10))\n       (WordInterval 1 3))\n     (WordInterval 1 3) =\n    RangeUnion (RangeUnion (WordInterval 1 3) (WordInterval 1 0))\n     (WordInterval 1 3)", "by eval"], ["", "definition wordinterval_intersection\n    :: \"'a::len wordinterval \\<Rightarrow> 'a::len wordinterval \\<Rightarrow> 'a::len wordinterval\" where\n    \"wordinterval_intersection r1 r2 \\<equiv> wordinterval_compress (wordinterval_intersection' r1 r2)\""], ["", "lemma wordinterval_intersection_set_eq[simp]:\n    \"wordinterval_to_set (wordinterval_intersection r1 r2) =\n      wordinterval_to_set r1 \\<inter> wordinterval_to_set r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (wordinterval_intersection r1 r2) =\n    wordinterval_to_set r1 \\<inter> wordinterval_to_set r2", "by(simp add: wordinterval_intersection_def\n                 wordinterval_compress wordinterval_intersection'_set_eq)"], ["", "lemma \"wordinterval_intersection\n          (RangeUnion (RangeUnion (WordInterval (1::32 word) 3) (WordInterval 8 10))\n                      (WordInterval 1 3)) (WordInterval 1 3) =\n          WordInterval 1 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_intersection\n     (RangeUnion (RangeUnion (WordInterval 1 3) (WordInterval 8 10))\n       (WordInterval 1 3))\n     (WordInterval 1 3) =\n    WordInterval 1 3", "by eval"], ["", "end"], ["", "definition wordinterval_subset :: \"'a::len wordinterval \\<Rightarrow> 'a::len wordinterval \\<Rightarrow> bool\" where\n  \"wordinterval_subset r1 r2 \\<equiv> wordinterval_empty (wordinterval_setminus r1 r2)\""], ["", "lemma wordinterval_subset_set_eq[simp]:\n  \"wordinterval_subset r1 r2 = (wordinterval_to_set r1 \\<subseteq> wordinterval_to_set r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_subset r1 r2 =\n    (wordinterval_to_set r1 \\<subseteq> wordinterval_to_set r2)", "unfolding wordinterval_subset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_empty (wordinterval_setminus r1 r2) =\n    (wordinterval_to_set r1 \\<subseteq> wordinterval_to_set r2)", "by simp"], ["", "definition wordinterval_eq :: \"'a::len wordinterval \\<Rightarrow> 'a::len wordinterval \\<Rightarrow> bool\" where\n  \"wordinterval_eq r1 r2 = (wordinterval_subset r1 r2 \\<and> wordinterval_subset r2 r1)\""], ["", "lemma wordinterval_eq_set_eq:\n  \"wordinterval_eq r1 r2 \\<longleftrightarrow> wordinterval_to_set r1 = wordinterval_to_set r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_eq r1 r2 =\n    (wordinterval_to_set r1 = wordinterval_to_set r2)", "unfolding wordinterval_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wordinterval_subset r1 r2 \\<and> wordinterval_subset r2 r1) =\n    (wordinterval_to_set r1 = wordinterval_to_set r2)", "by auto"], ["", "thm iffD1[OF wordinterval_eq_set_eq]"], ["", "(*declare iffD1[OF wordinterval_eq_set_eq, simp]*)"], ["", "lemma wordinterval_eq_comm: \"wordinterval_eq r1 r2 \\<longleftrightarrow> wordinterval_eq r2 r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_eq r1 r2 = wordinterval_eq r2 r1", "unfolding wordinterval_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wordinterval_subset r1 r2 \\<and> wordinterval_subset r2 r1) =\n    (wordinterval_subset r2 r1 \\<and> wordinterval_subset r1 r2)", "by fast"], ["", "lemma wordinterval_to_set_alt: \"wordinterval_to_set r = {x. wordinterval_element x r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set r = {x. wordinterval_element x r}", "unfolding wordinterval_element_set_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set r = {x. x \\<in> wordinterval_to_set r}", "by blast"], ["", "lemma wordinterval_un_empty:\n  \"wordinterval_empty r1 \\<Longrightarrow> wordinterval_eq (wordinterval_union r1 r2) r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_empty r1 \\<Longrightarrow>\n    wordinterval_eq (wordinterval_union r1 r2) r2", "by(subst wordinterval_eq_set_eq, simp)"], ["", "lemma wordinterval_un_emty_b:\n  \"wordinterval_empty r2 \\<Longrightarrow> wordinterval_eq (wordinterval_union r1 r2) r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_empty r2 \\<Longrightarrow>\n    wordinterval_eq (wordinterval_union r1 r2) r1", "by(subst wordinterval_eq_set_eq, simp)"], ["", "lemma wordinterval_Diff_triv:\n  \"wordinterval_empty (wordinterval_intersection a b) \\<Longrightarrow> wordinterval_eq (wordinterval_setminus a b) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_empty (wordinterval_intersection a b) \\<Longrightarrow>\n    wordinterval_eq (wordinterval_setminus a b) a", "unfolding wordinterval_eq_set_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_empty (wordinterval_intersection a b) \\<Longrightarrow>\n    wordinterval_to_set (wordinterval_setminus a b) = wordinterval_to_set a", "by simp blast"], ["", "text\\<open>A size of the datatype, does not correspond to the cardinality of the corresponding set\\<close>"], ["", "fun wordinterval_size :: \"('a::len) wordinterval \\<Rightarrow> nat\" where\n  \"wordinterval_size (RangeUnion a b) = wordinterval_size a + wordinterval_size b\" |\n  \"wordinterval_size (WordInterval s e) = (if s \\<le> e then 1 else 0)\""], ["", "lemma wordinterval_size_length: \"wordinterval_size r = length (wi2l r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_size r = length (wi2l r)", "by(induction r) (auto)"], ["", "lemma Ex_wordinterval_nonempty: \"\\<exists>x::('a::len wordinterval). y \\<in> wordinterval_to_set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. y \\<in> wordinterval_to_set x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> wordinterval_to_set ?x", "show \"y \\<in> wordinterval_to_set wordinterval_UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> wordinterval_to_set wordinterval_UNIV", "by simp"], ["proof (state)\nthis:\n  y \\<in> wordinterval_to_set wordinterval_UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wordinterval_eq_reflp:\n  \"reflp wordinterval_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp wordinterval_eq", "apply(rule reflpI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. wordinterval_eq x x", "by(simp only: wordinterval_eq_set_eq)"], ["", "lemma wordintervalt_eq_symp:\n  \"symp wordinterval_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symp wordinterval_eq", "apply(rule sympI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. wordinterval_eq a b \\<Longrightarrow> wordinterval_eq b a", "by(simp add: wordinterval_eq_comm)"], ["", "lemma wordinterval_eq_transp:\n  \"transp wordinterval_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp wordinterval_eq", "apply(rule transpI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>wordinterval_eq x y; wordinterval_eq y z\\<rbrakk>\n       \\<Longrightarrow> wordinterval_eq x z", "by(simp only: wordinterval_eq_set_eq)"], ["", "lemma wordinterval_eq_equivp:\n  \"equivp wordinterval_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivp wordinterval_eq", "by (auto intro: equivpI wordinterval_eq_reflp wordintervalt_eq_symp wordinterval_eq_transp)"], ["", "text\\<open>The smallest element in the interval\\<close>"], ["", "definition is_lowest_element :: \"'a::ord \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n    \"is_lowest_element x S = (x \\<in> S \\<and> (\\<forall>y\\<in>S. y \\<le> x \\<longrightarrow> y = x))\""], ["", "lemma\n  \tfixes x :: \"'a :: complete_lattice\"\n  \tassumes \"x \\<in> S\"\n  \tshows \" x = Inf S \\<Longrightarrow> is_lowest_element x S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = Inf S \\<Longrightarrow> is_lowest_element x S", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x = Inf S \\<Longrightarrow> is_lowest_element x S", "apply(simp add: is_lowest_element_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Inf S; Inf S \\<in> S\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>S.\n                         y \\<le> Inf S \\<longrightarrow> y = Inf S", "by (simp add: Inf_lower eq_iff)"], ["", "lemma\n  \tfixes x :: \"'a :: linorder\"\n  \tassumes \"finite S\" and \"x \\<in> S\"\n  \tshows \"is_lowest_element x S \\<longleftrightarrow> x = Min S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lowest_element x S = (x = Min S)", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_lowest_element x S \\<Longrightarrow> x = Min S\n 2. x = Min S \\<Longrightarrow> is_lowest_element x S", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lowest_element x S \\<Longrightarrow> x = Min S", "apply(simp add: is_lowest_element_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<and>\n    (\\<forall>y\\<in>S. y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n    x = Min S", "apply(subst Min_eqI[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. x \\<in> S \\<and>\n    (\\<forall>y\\<in>S. y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n    finite ?A\n 2. \\<And>y.\n       \\<lbrakk>x \\<in> S \\<and>\n                (\\<forall>y\\<in>S. y \\<le> x \\<longrightarrow> y = x);\n        y \\<in> ?A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 3. x \\<in> S \\<and>\n    (\\<forall>y\\<in>S. y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n    x \\<in> ?A\n 4. x \\<in> S \\<and>\n    (\\<forall>y\\<in>S. y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n    Min ?A = Min S", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  x \\<in> S\n\ngoal (4 subgoals):\n 1. x \\<in> S \\<and>\n    (\\<forall>y\\<in>S. y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n    finite ?A\n 2. \\<And>y.\n       \\<lbrakk>x \\<in> S \\<and>\n                (\\<forall>y\\<in>S. y \\<le> x \\<longrightarrow> y = x);\n        y \\<in> ?A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 3. x \\<in> S \\<and>\n    (\\<forall>y\\<in>S. y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n    x \\<in> ?A\n 4. x \\<in> S \\<and>\n    (\\<forall>y\\<in>S. y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n    Min ?A = Min S", "by(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = Min S \\<Longrightarrow> is_lowest_element x S", "by (metis Min.coboundedI assms(1) assms(2) dual_order.antisym is_lowest_element_def)"], ["", "text\\<open>Smallest element in the interval\\<close>"], ["", "fun wordinterval_lowest_element :: \"'a::len wordinterval \\<Rightarrow> 'a word option\" where\n    \"wordinterval_lowest_element (WordInterval s e) = (if s \\<le> e then Some s else None)\" |\n    \"wordinterval_lowest_element (RangeUnion A B) =\n      (case (wordinterval_lowest_element A, wordinterval_lowest_element B) of\n          (Some a, Some b) \\<Rightarrow> Some (if a < b then a else b) |\n          (None, Some b) \\<Rightarrow> Some b |\n          (Some a, None) \\<Rightarrow> Some a |\n          (None, None) \\<Rightarrow> None)\""], ["", "lemma wordinterval_lowest_none_empty: \"wordinterval_lowest_element r = None \\<longleftrightarrow> wordinterval_empty r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wordinterval_lowest_element r = None) = wordinterval_empty r", "proof(induction r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       (wordinterval_lowest_element (WordInterval x1 x2) = None) =\n       wordinterval_empty (WordInterval x1 x2)\n 2. \\<And>r1 r2.\n       \\<lbrakk>(wordinterval_lowest_element r1 = None) =\n                wordinterval_empty r1;\n        (wordinterval_lowest_element r2 = None) =\n        wordinterval_empty r2\\<rbrakk>\n       \\<Longrightarrow> (wordinterval_lowest_element (RangeUnion r1 r2) =\n                          None) =\n                         wordinterval_empty (RangeUnion r1 r2)", "case WordInterval"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       (wordinterval_lowest_element (WordInterval x1 x2) = None) =\n       wordinterval_empty (WordInterval x1 x2)\n 2. \\<And>r1 r2.\n       \\<lbrakk>(wordinterval_lowest_element r1 = None) =\n                wordinterval_empty r1;\n        (wordinterval_lowest_element r2 = None) =\n        wordinterval_empty r2\\<rbrakk>\n       \\<Longrightarrow> (wordinterval_lowest_element (RangeUnion r1 r2) =\n                          None) =\n                         wordinterval_empty (RangeUnion r1 r2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wordinterval_lowest_element (WordInterval x1_ x2_) = None) =\n    wordinterval_empty (WordInterval x1_ x2_)", "by simp"], ["proof (state)\nthis:\n  (wordinterval_lowest_element (WordInterval x1_ x2_) = None) =\n  wordinterval_empty (WordInterval x1_ x2_)\n\ngoal (1 subgoal):\n 1. \\<And>r1 r2.\n       \\<lbrakk>(wordinterval_lowest_element r1 = None) =\n                wordinterval_empty r1;\n        (wordinterval_lowest_element r2 = None) =\n        wordinterval_empty r2\\<rbrakk>\n       \\<Longrightarrow> (wordinterval_lowest_element (RangeUnion r1 r2) =\n                          None) =\n                         wordinterval_empty (RangeUnion r1 r2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r1 r2.\n       \\<lbrakk>(wordinterval_lowest_element r1 = None) =\n                wordinterval_empty r1;\n        (wordinterval_lowest_element r2 = None) =\n        wordinterval_empty r2\\<rbrakk>\n       \\<Longrightarrow> (wordinterval_lowest_element (RangeUnion r1 r2) =\n                          None) =\n                         wordinterval_empty (RangeUnion r1 r2)", "case RangeUnion"], ["proof (state)\nthis:\n  (wordinterval_lowest_element r1_ = None) = wordinterval_empty r1_\n  (wordinterval_lowest_element r2_ = None) = wordinterval_empty r2_\n\ngoal (1 subgoal):\n 1. \\<And>r1 r2.\n       \\<lbrakk>(wordinterval_lowest_element r1 = None) =\n                wordinterval_empty r1;\n        (wordinterval_lowest_element r2 = None) =\n        wordinterval_empty r2\\<rbrakk>\n       \\<Longrightarrow> (wordinterval_lowest_element (RangeUnion r1 r2) =\n                          None) =\n                         wordinterval_empty (RangeUnion r1 r2)", "thus ?case"], ["proof (prove)\nusing this:\n  (wordinterval_lowest_element r1_ = None) = wordinterval_empty r1_\n  (wordinterval_lowest_element r2_ = None) = wordinterval_empty r2_\n\ngoal (1 subgoal):\n 1. (wordinterval_lowest_element (RangeUnion r1_ r2_) = None) =\n    wordinterval_empty (RangeUnion r1_ r2_)", "by fastforce"], ["proof (state)\nthis:\n  (wordinterval_lowest_element (RangeUnion r1_ r2_) = None) =\n  wordinterval_empty (RangeUnion r1_ r2_)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wordinterval_lowest_element_correct_A:\n    \"wordinterval_lowest_element r = Some x \\<Longrightarrow> is_lowest_element x (wordinterval_to_set r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some x \\<Longrightarrow>\n    is_lowest_element x (wordinterval_to_set r)", "unfolding is_lowest_element_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some x \\<Longrightarrow>\n    x \\<in> wordinterval_to_set r \\<and>\n    (\\<forall>y\\<in>wordinterval_to_set r.\n        y \\<le> x \\<longrightarrow> y = x)", "apply(induction r arbitrary: x rule: wordinterval_lowest_element.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s e x.\n       wordinterval_lowest_element (WordInterval s e) =\n       Some x \\<Longrightarrow>\n       x \\<in> wordinterval_to_set (WordInterval s e) \\<and>\n       (\\<forall>y\\<in>wordinterval_to_set (WordInterval s e).\n           y \\<le> x \\<longrightarrow> y = x)\n 2. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   wordinterval_lowest_element A = Some x \\<Longrightarrow>\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x);\n        \\<And>x.\n           wordinterval_lowest_element B = Some x \\<Longrightarrow>\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x);\n        wordinterval_lowest_element (RangeUnion A B) = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wordinterval_to_set (RangeUnion A B) \\<and>\n                         (\\<forall>y\\<in>wordinterval_to_set\n    (RangeUnion A B).\n                             y \\<le> x \\<longrightarrow> y = x)", "apply(rename_tac rs re x, case_tac \"rs \\<le> re\", auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   wordinterval_lowest_element A = Some x \\<Longrightarrow>\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x);\n        \\<And>x.\n           wordinterval_lowest_element B = Some x \\<Longrightarrow>\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x);\n        wordinterval_lowest_element (RangeUnion A B) = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wordinterval_to_set (RangeUnion A B) \\<and>\n                         (\\<forall>y\\<in>wordinterval_to_set\n    (RangeUnion A B).\n                             y \\<le> x \\<longrightarrow> y = x)", "apply(subst(asm) wordinterval_lowest_element.simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   wordinterval_lowest_element A = Some x \\<Longrightarrow>\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x);\n        \\<And>x.\n           wordinterval_lowest_element B = Some x \\<Longrightarrow>\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x);\n        (case (wordinterval_lowest_element A,\n               wordinterval_lowest_element B) of\n         (None, None) \\<Rightarrow> None\n         | (None, Some x) \\<Rightarrow> Some x\n         | (Some a, None) \\<Rightarrow> Some a\n         | (Some a, Some b) \\<Rightarrow> Some (if a < b then a else b)) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wordinterval_to_set (RangeUnion A B) \\<and>\n                         (\\<forall>y\\<in>wordinterval_to_set\n    (RangeUnion A B).\n                             y \\<le> x \\<longrightarrow> y = x)", "apply(rename_tac A B x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   wordinterval_lowest_element A = Some x \\<Longrightarrow>\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x);\n        \\<And>x.\n           wordinterval_lowest_element B = Some x \\<Longrightarrow>\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x);\n        (case (wordinterval_lowest_element A,\n               wordinterval_lowest_element B) of\n         (None, None) \\<Rightarrow> None\n         | (None, Some x) \\<Rightarrow> Some x\n         | (Some a, None) \\<Rightarrow> Some a\n         | (Some a, Some b) \\<Rightarrow> Some (if a < b then a else b)) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wordinterval_to_set (RangeUnion A B) \\<and>\n                         (\\<forall>y\\<in>wordinterval_to_set\n    (RangeUnion A B).\n                             y \\<le> x \\<longrightarrow> y = x)", "apply(case_tac     \"wordinterval_lowest_element B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   wordinterval_lowest_element A = Some x \\<Longrightarrow>\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x);\n        \\<And>x.\n           wordinterval_lowest_element B = Some x \\<Longrightarrow>\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x);\n        (case (wordinterval_lowest_element A,\n               wordinterval_lowest_element B) of\n         (None, None) \\<Rightarrow> None\n         | (None, Some x) \\<Rightarrow> Some x\n         | (Some a, None) \\<Rightarrow> Some a\n         | (Some a, Some b) \\<Rightarrow> Some (if a < b then a else b)) =\n        Some x;\n        wordinterval_lowest_element B = None\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wordinterval_to_set (RangeUnion A B) \\<and>\n                         (\\<forall>y\\<in>wordinterval_to_set\n    (RangeUnion A B).\n                             y \\<le> x \\<longrightarrow> y = x)\n 2. \\<And>A B x a.\n       \\<lbrakk>\\<And>x.\n                   wordinterval_lowest_element A = Some x \\<Longrightarrow>\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x);\n        \\<And>x.\n           wordinterval_lowest_element B = Some x \\<Longrightarrow>\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x);\n        (case (wordinterval_lowest_element A,\n               wordinterval_lowest_element B) of\n         (None, None) \\<Rightarrow> None\n         | (None, Some x) \\<Rightarrow> Some x\n         | (Some a, None) \\<Rightarrow> Some a\n         | (Some a, Some b) \\<Rightarrow> Some (if a < b then a else b)) =\n        Some x;\n        wordinterval_lowest_element B = Some a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wordinterval_to_set (RangeUnion A B) \\<and>\n                         (\\<forall>y\\<in>wordinterval_to_set\n    (RangeUnion A B).\n                             y \\<le> x \\<longrightarrow> y = x)", "apply(case_tac[!] \"wordinterval_lowest_element A\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   wordinterval_lowest_element A = Some x \\<Longrightarrow>\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x);\n        \\<And>x.\n           wordinterval_lowest_element B = Some x \\<Longrightarrow>\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x);\n        (case (wordinterval_lowest_element A,\n               wordinterval_lowest_element B) of\n         (None, None) \\<Rightarrow> None\n         | (None, Some x) \\<Rightarrow> Some x\n         | (Some a, None) \\<Rightarrow> Some a\n         | (Some a, Some b) \\<Rightarrow> Some (if a < b then a else b)) =\n        Some x;\n        wordinterval_lowest_element B = None;\n        wordinterval_lowest_element A = None\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wordinterval_to_set (RangeUnion A B) \\<and>\n                         (\\<forall>y\\<in>wordinterval_to_set\n    (RangeUnion A B).\n                             y \\<le> x \\<longrightarrow> y = x)\n 2. \\<And>A B x a.\n       \\<lbrakk>\\<And>x.\n                   wordinterval_lowest_element A = Some x \\<Longrightarrow>\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x);\n        \\<And>x.\n           wordinterval_lowest_element B = Some x \\<Longrightarrow>\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x);\n        (case (wordinterval_lowest_element A,\n               wordinterval_lowest_element B) of\n         (None, None) \\<Rightarrow> None\n         | (None, Some x) \\<Rightarrow> Some x\n         | (Some a, None) \\<Rightarrow> Some a\n         | (Some a, Some b) \\<Rightarrow> Some (if a < b then a else b)) =\n        Some x;\n        wordinterval_lowest_element B = None;\n        wordinterval_lowest_element A = Some a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wordinterval_to_set (RangeUnion A B) \\<and>\n                         (\\<forall>y\\<in>wordinterval_to_set\n    (RangeUnion A B).\n                             y \\<le> x \\<longrightarrow> y = x)\n 3. \\<And>A B x a.\n       \\<lbrakk>\\<And>x.\n                   wordinterval_lowest_element A = Some x \\<Longrightarrow>\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x);\n        \\<And>x.\n           wordinterval_lowest_element B = Some x \\<Longrightarrow>\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x);\n        (case (wordinterval_lowest_element A,\n               wordinterval_lowest_element B) of\n         (None, None) \\<Rightarrow> None\n         | (None, Some x) \\<Rightarrow> Some x\n         | (Some a, None) \\<Rightarrow> Some a\n         | (Some a, Some b) \\<Rightarrow> Some (if a < b then a else b)) =\n        Some x;\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = None\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wordinterval_to_set (RangeUnion A B) \\<and>\n                         (\\<forall>y\\<in>wordinterval_to_set\n    (RangeUnion A B).\n                             y \\<le> x \\<longrightarrow> y = x)\n 4. \\<And>A B x a aa.\n       \\<lbrakk>\\<And>x.\n                   wordinterval_lowest_element A = Some x \\<Longrightarrow>\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x);\n        \\<And>x.\n           wordinterval_lowest_element B = Some x \\<Longrightarrow>\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x);\n        (case (wordinterval_lowest_element A,\n               wordinterval_lowest_element B) of\n         (None, None) \\<Rightarrow> None\n         | (None, Some x) \\<Rightarrow> Some x\n         | (Some a, None) \\<Rightarrow> Some a\n         | (Some a, Some b) \\<Rightarrow> Some (if a < b then a else b)) =\n        Some x;\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = Some aa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wordinterval_to_set (RangeUnion A B) \\<and>\n                         (\\<forall>y\\<in>wordinterval_to_set\n    (RangeUnion A B).\n                             y \\<le> x \\<longrightarrow> y = x)", "apply(simp_all add: wordinterval_lowest_none_empty)[3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B x a aa.\n       \\<lbrakk>\\<And>x.\n                   wordinterval_lowest_element A = Some x \\<Longrightarrow>\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x);\n        \\<And>x.\n           wordinterval_lowest_element B = Some x \\<Longrightarrow>\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x);\n        (case (wordinterval_lowest_element A,\n               wordinterval_lowest_element B) of\n         (None, None) \\<Rightarrow> None\n         | (None, Some x) \\<Rightarrow> Some x\n         | (Some a, None) \\<Rightarrow> Some a\n         | (Some a, Some b) \\<Rightarrow> Some (if a < b then a else b)) =\n        Some x;\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = Some aa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> wordinterval_to_set (RangeUnion A B) \\<and>\n                         (\\<forall>y\\<in>wordinterval_to_set\n    (RangeUnion A B).\n                             y \\<le> x \\<longrightarrow> y = x)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wordinterval_lowest_element_set_eq: assumes \"\\<not> wordinterval_empty r\"\n    shows \"(wordinterval_lowest_element r = Some x) = (is_lowest_element x (wordinterval_to_set r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wordinterval_lowest_element r = Some x) =\n    is_lowest_element x (wordinterval_to_set r)", "(*unfolding is_lowest_element_def*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (wordinterval_lowest_element r = Some x) =\n    is_lowest_element x (wordinterval_to_set r)", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. wordinterval_lowest_element r = Some x \\<Longrightarrow>\n    is_lowest_element x (wordinterval_to_set r)\n 2. is_lowest_element x (wordinterval_to_set r) \\<Longrightarrow>\n    wordinterval_lowest_element r = Some x", "assume \"wordinterval_lowest_element r = Some x\""], ["proof (state)\nthis:\n  wordinterval_lowest_element r = Some x\n\ngoal (2 subgoals):\n 1. wordinterval_lowest_element r = Some x \\<Longrightarrow>\n    is_lowest_element x (wordinterval_to_set r)\n 2. is_lowest_element x (wordinterval_to_set r) \\<Longrightarrow>\n    wordinterval_lowest_element r = Some x", "thus \"is_lowest_element x (wordinterval_to_set r)\""], ["proof (prove)\nusing this:\n  wordinterval_lowest_element r = Some x\n\ngoal (1 subgoal):\n 1. is_lowest_element x (wordinterval_to_set r)", "using wordinterval_lowest_element_correct_A wordinterval_lowest_none_empty"], ["proof (prove)\nusing this:\n  wordinterval_lowest_element r = Some x\n  wordinterval_lowest_element ?r = Some ?x \\<Longrightarrow>\n  is_lowest_element ?x (wordinterval_to_set ?r)\n  (wordinterval_lowest_element ?r = None) = wordinterval_empty ?r\n\ngoal (1 subgoal):\n 1. is_lowest_element x (wordinterval_to_set r)", "by simp"], ["proof (state)\nthis:\n  is_lowest_element x (wordinterval_to_set r)\n\ngoal (1 subgoal):\n 1. is_lowest_element x (wordinterval_to_set r) \\<Longrightarrow>\n    wordinterval_lowest_element r = Some x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_lowest_element x (wordinterval_to_set r) \\<Longrightarrow>\n    wordinterval_lowest_element r = Some x", "assume \"is_lowest_element x (wordinterval_to_set r)\""], ["proof (state)\nthis:\n  is_lowest_element x (wordinterval_to_set r)\n\ngoal (1 subgoal):\n 1. is_lowest_element x (wordinterval_to_set r) \\<Longrightarrow>\n    wordinterval_lowest_element r = Some x", "with assms"], ["proof (chain)\npicking this:\n  \\<not> wordinterval_empty r\n  is_lowest_element x (wordinterval_to_set r)", "show \"(wordinterval_lowest_element r = Some x)\""], ["proof (prove)\nusing this:\n  \\<not> wordinterval_empty r\n  is_lowest_element x (wordinterval_to_set r)\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element r = Some x", "proof(induction r arbitrary: x rule: wordinterval_lowest_element.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s e x.\n       \\<lbrakk>\\<not> wordinterval_empty (WordInterval s e);\n        is_lowest_element x\n         (wordinterval_to_set (WordInterval s e))\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (WordInterval s e) =\n                         Some x\n 2. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B))\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "case 1"], ["proof (state)\nthis:\n  \\<not> wordinterval_empty (WordInterval s_ e_)\n  is_lowest_element x (wordinterval_to_set (WordInterval s_ e_))\n\ngoal (2 subgoals):\n 1. \\<And>s e x.\n       \\<lbrakk>\\<not> wordinterval_empty (WordInterval s e);\n        is_lowest_element x\n         (wordinterval_to_set (WordInterval s e))\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (WordInterval s e) =\n                         Some x\n 2. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B))\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> wordinterval_empty (WordInterval s_ e_)\n  is_lowest_element x (wordinterval_to_set (WordInterval s_ e_))\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element (WordInterval s_ e_) = Some x", "by(simp add: is_lowest_element_def)"], ["proof (state)\nthis:\n  wordinterval_lowest_element (WordInterval s_ e_) = Some x\n\ngoal (1 subgoal):\n 1. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B))\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B))\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "case (2 A B x)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> wordinterval_empty A;\n   is_lowest_element ?x (wordinterval_to_set A)\\<rbrakk>\n  \\<Longrightarrow> wordinterval_lowest_element A = Some ?x\n  \\<lbrakk>\\<not> wordinterval_empty B;\n   is_lowest_element ?x (wordinterval_to_set B)\\<rbrakk>\n  \\<Longrightarrow> wordinterval_lowest_element B = Some ?x\n  \\<not> wordinterval_empty (RangeUnion A B)\n  is_lowest_element x (wordinterval_to_set (RangeUnion A B))\n\ngoal (1 subgoal):\n 1. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B))\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "have is_lowest_RangeUnion: \"is_lowest_element x (wordinterval_to_set A \\<union> wordinterval_to_set B) \\<Longrightarrow>\n          is_lowest_element x (wordinterval_to_set A) \\<or> is_lowest_element x (wordinterval_to_set B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lowest_element x\n     (wordinterval_to_set A \\<union>\n      wordinterval_to_set B) \\<Longrightarrow>\n    is_lowest_element x (wordinterval_to_set A) \\<or>\n    is_lowest_element x (wordinterval_to_set B)", "by(simp add: is_lowest_element_def)"], ["proof (state)\nthis:\n  is_lowest_element x\n   (wordinterval_to_set A \\<union> wordinterval_to_set B) \\<Longrightarrow>\n  is_lowest_element x (wordinterval_to_set A) \\<or>\n  is_lowest_element x (wordinterval_to_set B)\n\ngoal (1 subgoal):\n 1. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B))\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "(*why \\<And> A B?*)"], ["proof (state)\nthis:\n  is_lowest_element x\n   (wordinterval_to_set A \\<union> wordinterval_to_set B) \\<Longrightarrow>\n  is_lowest_element x (wordinterval_to_set A) \\<or>\n  is_lowest_element x (wordinterval_to_set B)\n\ngoal (1 subgoal):\n 1. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B))\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "have wordinterval_lowest_element_RangeUnion:\n          \"\\<And>a b A B. wordinterval_lowest_element A = Some a \\<Longrightarrow>\n                  wordinterval_lowest_element B = Some b \\<Longrightarrow>\n                  wordinterval_lowest_element (RangeUnion A B) = Some (min a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b A B.\n       \\<lbrakk>wordinterval_lowest_element A = Some a;\n        wordinterval_lowest_element B = Some b\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some (min a b)", "by(auto dest!: wordinterval_lowest_element_correct_A simp add: is_lowest_element_def min_def)"], ["proof (state)\nthis:\n  \\<lbrakk>wordinterval_lowest_element ?A = Some ?a;\n   wordinterval_lowest_element ?B = Some ?b\\<rbrakk>\n  \\<Longrightarrow> wordinterval_lowest_element (RangeUnion ?A ?B) =\n                    Some (min ?a ?b)\n\ngoal (1 subgoal):\n 1. \\<And>A B x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B))\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> wordinterval_empty A;\n   is_lowest_element ?x (wordinterval_to_set A)\\<rbrakk>\n  \\<Longrightarrow> wordinterval_lowest_element A = Some ?x\n  \\<lbrakk>\\<not> wordinterval_empty B;\n   is_lowest_element ?x (wordinterval_to_set B)\\<rbrakk>\n  \\<Longrightarrow> wordinterval_lowest_element B = Some ?x\n  \\<not> wordinterval_empty (RangeUnion A B)\n  is_lowest_element x (wordinterval_to_set (RangeUnion A B))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> wordinterval_empty A;\n   is_lowest_element ?x (wordinterval_to_set A)\\<rbrakk>\n  \\<Longrightarrow> wordinterval_lowest_element A = Some ?x\n  \\<lbrakk>\\<not> wordinterval_empty B;\n   is_lowest_element ?x (wordinterval_to_set B)\\<rbrakk>\n  \\<Longrightarrow> wordinterval_lowest_element B = Some ?x\n  \\<not> wordinterval_empty (RangeUnion A B)\n  is_lowest_element x (wordinterval_to_set (RangeUnion A B))\n\ngoal (1 subgoal):\n 1. wordinterval_lowest_element (RangeUnion A B) = Some x", "apply(case_tac     \"wordinterval_lowest_element B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>\\<not> wordinterval_empty A;\n                 is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n     \\<And>x.\n        \\<lbrakk>\\<not> wordinterval_empty B;\n         is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n        \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n     \\<not> wordinterval_empty (RangeUnion A B);\n     is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n     wordinterval_lowest_element B = None\\<rbrakk>\n    \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) = Some x\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = Some a\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "apply(case_tac[!] \"wordinterval_lowest_element A\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>\\<not> wordinterval_empty A;\n                 is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n     \\<And>x.\n        \\<lbrakk>\\<not> wordinterval_empty B;\n         is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n        \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n     \\<not> wordinterval_empty (RangeUnion A B);\n     is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n     wordinterval_lowest_element B = None;\n     wordinterval_lowest_element A = None\\<rbrakk>\n    \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) = Some x\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = None;\n        wordinterval_lowest_element A = Some a\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x\n 3. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = None\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x\n 4. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = Some aa\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "apply(auto simp add: is_lowest_element_def)[3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = Some aa\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "apply(subgoal_tac \"\\<not> wordinterval_empty A \\<and> \\<not> wordinterval_empty B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = Some aa;\n        \\<not> wordinterval_empty A \\<and>\n        \\<not> wordinterval_empty B\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x\n 2. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<not> wordinterval_empty A \\<and>\n                         \\<not> wordinterval_empty B", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<not> wordinterval_empty A \\<and>\n                         \\<not> wordinterval_empty B\n 2. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = Some aa;\n        \\<not> wordinterval_empty A \\<and>\n        \\<not> wordinterval_empty B\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "using arg_cong[where f = Not, OF wordinterval_lowest_none_empty]"], ["proof (prove)\nusing this:\n  (wordinterval_lowest_element ?r1 \\<noteq> None) =\n  (\\<not> wordinterval_empty ?r1)\n\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<not> wordinterval_empty A \\<and>\n                         \\<not> wordinterval_empty B\n 2. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = Some aa;\n        \\<not> wordinterval_empty A \\<and>\n        \\<not> wordinterval_empty B\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element B = Some a;\n        wordinterval_lowest_element A = Some aa;\n        \\<not> wordinterval_empty A \\<and>\n        \\<not> wordinterval_empty B\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "apply(drule(1) wordinterval_lowest_element_RangeUnion)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> wordinterval_empty A;\n                    is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n                   \\<Longrightarrow> wordinterval_lowest_element A = Some x;\n        \\<And>x.\n           \\<lbrakk>\\<not> wordinterval_empty B;\n            is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n           \\<Longrightarrow> wordinterval_lowest_element B = Some x;\n        \\<not> wordinterval_empty (RangeUnion A B);\n        is_lowest_element x (wordinterval_to_set (RangeUnion A B));\n        wordinterval_lowest_element A = Some aa;\n        \\<not> wordinterval_empty A \\<and> \\<not> wordinterval_empty B;\n        wordinterval_lowest_element (RangeUnion B A) =\n        Some (min a aa)\\<rbrakk>\n       \\<Longrightarrow> wordinterval_lowest_element (RangeUnion A B) =\n                         Some x", "apply(simp split: option.split_asm add: min_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   is_lowest_element x\n                    (wordinterval_to_set A) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           is_lowest_element x (wordinterval_to_set B) \\<Longrightarrow>\n           False;\n        is_lowest_element x\n         (wordinterval_to_set A \\<union> wordinterval_to_set B);\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_lowest_element B = None;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        aa = (if a \\<le> aa then a else aa)\\<rbrakk>\n       \\<Longrightarrow> aa = x\n 2. \\<And>a aa x2.\n       \\<lbrakk>\\<And>x.\n                   is_lowest_element x\n                    (wordinterval_to_set A) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           is_lowest_element x (wordinterval_to_set B) \\<Longrightarrow>\n           x2 = x;\n        is_lowest_element x\n         (wordinterval_to_set A \\<union> wordinterval_to_set B);\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        wordinterval_lowest_element B = Some x2;\n        (if x2 < aa then x2 else aa) =\n        (if a \\<le> aa then a else aa)\\<rbrakk>\n       \\<Longrightarrow> (aa < x2 \\<longrightarrow> aa = x) \\<and>\n                         (\\<not> aa < x2 \\<longrightarrow> x2 = x)", "apply(drule is_lowest_RangeUnion)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   is_lowest_element x\n                    (wordinterval_to_set A) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           is_lowest_element x (wordinterval_to_set B) \\<Longrightarrow>\n           False;\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_lowest_element B = None;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        aa = (if a \\<le> aa then a else aa);\n        is_lowest_element x (wordinterval_to_set A) \\<or>\n        is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n       \\<Longrightarrow> aa = x\n 2. \\<And>a aa x2.\n       \\<lbrakk>\\<And>x.\n                   is_lowest_element x\n                    (wordinterval_to_set A) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           is_lowest_element x (wordinterval_to_set B) \\<Longrightarrow>\n           x2 = x;\n        is_lowest_element x\n         (wordinterval_to_set A \\<union> wordinterval_to_set B);\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        wordinterval_lowest_element B = Some x2;\n        (if x2 < aa then x2 else aa) =\n        (if a \\<le> aa then a else aa)\\<rbrakk>\n       \\<Longrightarrow> (aa < x2 \\<longrightarrow> aa = x) \\<and>\n                         (\\<not> aa < x2 \\<longrightarrow> x2 = x)", "apply(elim disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   is_lowest_element x\n                    (wordinterval_to_set A) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           is_lowest_element x (wordinterval_to_set B) \\<Longrightarrow>\n           False;\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_lowest_element B = None;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        aa = (if a \\<le> aa then a else aa);\n        is_lowest_element x (wordinterval_to_set A)\\<rbrakk>\n       \\<Longrightarrow> aa = x\n 2. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   is_lowest_element x\n                    (wordinterval_to_set A) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           is_lowest_element x (wordinterval_to_set B) \\<Longrightarrow>\n           False;\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_lowest_element B = None;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        aa = (if a \\<le> aa then a else aa);\n        is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n       \\<Longrightarrow> aa = x\n 3. \\<And>a aa x2.\n       \\<lbrakk>\\<And>x.\n                   is_lowest_element x\n                    (wordinterval_to_set A) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           is_lowest_element x (wordinterval_to_set B) \\<Longrightarrow>\n           x2 = x;\n        is_lowest_element x\n         (wordinterval_to_set A \\<union> wordinterval_to_set B);\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        wordinterval_lowest_element B = Some x2;\n        (if x2 < aa then x2 else aa) =\n        (if a \\<le> aa then a else aa)\\<rbrakk>\n       \\<Longrightarrow> (aa < x2 \\<longrightarrow> aa = x) \\<and>\n                         (\\<not> aa < x2 \\<longrightarrow> x2 = x)", "apply(simp add: is_lowest_element_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<And>x.\n                   is_lowest_element x\n                    (wordinterval_to_set A) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           is_lowest_element x (wordinterval_to_set B) \\<Longrightarrow>\n           False;\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_lowest_element B = None;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        aa = (if a \\<le> aa then a else aa);\n        is_lowest_element x (wordinterval_to_set B)\\<rbrakk>\n       \\<Longrightarrow> aa = x\n 2. \\<And>a aa x2.\n       \\<lbrakk>\\<And>x.\n                   is_lowest_element x\n                    (wordinterval_to_set A) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           is_lowest_element x (wordinterval_to_set B) \\<Longrightarrow>\n           x2 = x;\n        is_lowest_element x\n         (wordinterval_to_set A \\<union> wordinterval_to_set B);\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        wordinterval_lowest_element B = Some x2;\n        (if x2 < aa then x2 else aa) =\n        (if a \\<le> aa then a else aa)\\<rbrakk>\n       \\<Longrightarrow> (aa < x2 \\<longrightarrow> aa = x) \\<and>\n                         (\\<not> aa < x2 \\<longrightarrow> x2 = x)", "apply(clarsimp simp add: wordinterval_lowest_none_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa x2.\n       \\<lbrakk>\\<And>x.\n                   is_lowest_element x\n                    (wordinterval_to_set A) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           is_lowest_element x (wordinterval_to_set B) \\<Longrightarrow>\n           x2 = x;\n        is_lowest_element x\n         (wordinterval_to_set A \\<union> wordinterval_to_set B);\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        wordinterval_lowest_element B = Some x2;\n        (if x2 < aa then x2 else aa) =\n        (if a \\<le> aa then a else aa)\\<rbrakk>\n       \\<Longrightarrow> (aa < x2 \\<longrightarrow> aa = x) \\<and>\n                         (\\<not> aa < x2 \\<longrightarrow> x2 = x)", "apply(simp add: is_lowest_element_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa x2.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n           x2 = x;\n        (x \\<in> wordinterval_to_set A \\<or>\n         x \\<in> wordinterval_to_set B) \\<and>\n        (\\<forall>y\\<in>wordinterval_to_set A \\<union>\n                        wordinterval_to_set B.\n            y \\<le> x \\<longrightarrow> y = x);\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        wordinterval_lowest_element B = Some x2;\n        (if x2 < aa then x2 else aa) =\n        (if a \\<le> aa then a else aa)\\<rbrakk>\n       \\<Longrightarrow> (aa < x2 \\<longrightarrow> aa = x) \\<and>\n                         (\\<not> aa < x2 \\<longrightarrow> x2 = x)", "apply(clarsimp simp add: wordinterval_lowest_none_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa x2.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n           x2 = x;\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        wordinterval_lowest_element B = Some x2;\n        (if x2 < aa then x2 else aa) = (if a \\<le> aa then a else aa);\n        x \\<in> wordinterval_to_set A \\<or> x \\<in> wordinterval_to_set B;\n        \\<forall>y\\<in>wordinterval_to_set A \\<union> wordinterval_to_set B.\n           y \\<le> x \\<longrightarrow> y = x\\<rbrakk>\n       \\<Longrightarrow> (aa < x2 \\<longrightarrow> aa = x) \\<and>\n                         (\\<not> aa < x2 \\<longrightarrow> x2 = x)", "using wordinterval_lowest_element_correct_A[simplified is_lowest_element_def]"], ["proof (prove)\nusing this:\n  wordinterval_lowest_element ?r = Some ?x \\<Longrightarrow>\n  ?x \\<in> wordinterval_to_set ?r \\<and>\n  (\\<forall>y\\<in>wordinterval_to_set ?r.\n      y \\<le> ?x \\<longrightarrow> y = ?x)\n\ngoal (1 subgoal):\n 1. \\<And>a aa x2.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> wordinterval_to_set A \\<and>\n                   (\\<forall>y\\<in>wordinterval_to_set A.\n                       y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n                   aa = x;\n        \\<And>x.\n           x \\<in> wordinterval_to_set B \\<and>\n           (\\<forall>y\\<in>wordinterval_to_set B.\n               y \\<le> x \\<longrightarrow> y = x) \\<Longrightarrow>\n           x2 = x;\n        wordinterval_lowest_element A = Some aa;\n        wordinterval_to_set A \\<noteq> {};\n        wordinterval_to_set B \\<noteq> {};\n        wordinterval_lowest_element B = Some x2;\n        (if x2 < aa then x2 else aa) = (if a \\<le> aa then a else aa);\n        x \\<in> wordinterval_to_set A \\<or> x \\<in> wordinterval_to_set B;\n        \\<forall>y\\<in>wordinterval_to_set A \\<union> wordinterval_to_set B.\n           y \\<le> x \\<longrightarrow> y = x\\<rbrakk>\n       \\<Longrightarrow> (aa < x2 \\<longrightarrow> aa = x) \\<and>\n                         (\\<not> aa < x2 \\<longrightarrow> x2 = x)", "by (metis Un_iff not_le)"], ["proof (state)\nthis:\n  wordinterval_lowest_element (RangeUnion A B) = Some x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wordinterval_lowest_element r = Some x\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Cardinality approximation for @{typ \"('a::len) wordinterval\"}s\\<close>"], ["", "context\nbegin"], ["", "lemma card_atLeastAtMost_word: fixes s::\"('a::len) word\" shows \"card {s..e} = Suc (unat e) - (unat s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {s..e} = Suc (unat e) - unat s", "apply(cases \"s > e\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. e < s \\<Longrightarrow> card {s..e} = Suc (unat e) - unat s\n 2. \\<not> e < s \\<Longrightarrow> card {s..e} = Suc (unat e) - unat s", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. e < s \\<Longrightarrow> Suc (unat e) \\<le> unat s\n 2. \\<not> e < s \\<Longrightarrow> card {s..e} = Suc (unat e) - unat s", "apply(subst(asm) Word.word_less_nat_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. unat e < unat s \\<Longrightarrow> Suc (unat e) \\<le> unat s\n 2. \\<not> e < s \\<Longrightarrow> card {s..e} = Suc (unat e) - unat s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> e < s \\<Longrightarrow> card {s..e} = Suc (unat e) - unat s", "apply(subst upto_enum_set_conv2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> e < s \\<Longrightarrow>\n    card (set [s .e. e]) = Suc (unat e) - unat s", "apply(subst List.card_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> e < s \\<Longrightarrow>\n    length (remdups [s .e. e]) = Suc (unat e) - unat s", "apply(simp add: remdups_enum_upto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun wordinterval_card :: \"('a::len) wordinterval \\<Rightarrow> nat\" where\n    \"wordinterval_card (WordInterval s e) = Suc (unat e) - (unat s)\" |\n    \"wordinterval_card (RangeUnion a b) = wordinterval_card a + wordinterval_card b\""], ["", "lemma wordinterval_card: \"wordinterval_card r \\<ge> card (wordinterval_to_set r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (wordinterval_to_set r) \\<le> wordinterval_card r", "proof(induction r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       card (wordinterval_to_set (WordInterval x1 x2))\n       \\<le> wordinterval_card (WordInterval x1 x2)\n 2. \\<And>r1 r2.\n       \\<lbrakk>card (wordinterval_to_set r1) \\<le> wordinterval_card r1;\n        card (wordinterval_to_set r2) \\<le> wordinterval_card r2\\<rbrakk>\n       \\<Longrightarrow> card (wordinterval_to_set (RangeUnion r1 r2))\n                         \\<le> wordinterval_card (RangeUnion r1 r2)", "case WordInterval"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       card (wordinterval_to_set (WordInterval x1 x2))\n       \\<le> wordinterval_card (WordInterval x1 x2)\n 2. \\<And>r1 r2.\n       \\<lbrakk>card (wordinterval_to_set r1) \\<le> wordinterval_card r1;\n        card (wordinterval_to_set r2) \\<le> wordinterval_card r2\\<rbrakk>\n       \\<Longrightarrow> card (wordinterval_to_set (RangeUnion r1 r2))\n                         \\<le> wordinterval_card (RangeUnion r1 r2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (wordinterval_to_set (WordInterval x1_ x2_))\n    \\<le> wordinterval_card (WordInterval x1_ x2_)", "by (simp add: card_atLeastAtMost_word)"], ["proof (state)\nthis:\n  card (wordinterval_to_set (WordInterval x1_ x2_))\n  \\<le> wordinterval_card (WordInterval x1_ x2_)\n\ngoal (1 subgoal):\n 1. \\<And>r1 r2.\n       \\<lbrakk>card (wordinterval_to_set r1) \\<le> wordinterval_card r1;\n        card (wordinterval_to_set r2) \\<le> wordinterval_card r2\\<rbrakk>\n       \\<Longrightarrow> card (wordinterval_to_set (RangeUnion r1 r2))\n                         \\<le> wordinterval_card (RangeUnion r1 r2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r1 r2.\n       \\<lbrakk>card (wordinterval_to_set r1) \\<le> wordinterval_card r1;\n        card (wordinterval_to_set r2) \\<le> wordinterval_card r2\\<rbrakk>\n       \\<Longrightarrow> card (wordinterval_to_set (RangeUnion r1 r2))\n                         \\<le> wordinterval_card (RangeUnion r1 r2)", "case (RangeUnion r1 r2)"], ["proof (state)\nthis:\n  card (wordinterval_to_set r1) \\<le> wordinterval_card r1\n  card (wordinterval_to_set r2) \\<le> wordinterval_card r2\n\ngoal (1 subgoal):\n 1. \\<And>r1 r2.\n       \\<lbrakk>card (wordinterval_to_set r1) \\<le> wordinterval_card r1;\n        card (wordinterval_to_set r2) \\<le> wordinterval_card r2\\<rbrakk>\n       \\<Longrightarrow> card (wordinterval_to_set (RangeUnion r1 r2))\n                         \\<le> wordinterval_card (RangeUnion r1 r2)", "have \"card (wordinterval_to_set r1 \\<union> wordinterval_to_set r2) \\<le>\n              card (wordinterval_to_set r1) + card (wordinterval_to_set r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (wordinterval_to_set r1 \\<union> wordinterval_to_set r2)\n    \\<le> card (wordinterval_to_set r1) + card (wordinterval_to_set r2)", "using Finite_Set.card_Un_le"], ["proof (prove)\nusing this:\n  card (?A \\<union> ?B) \\<le> card ?A + card ?B\n\ngoal (1 subgoal):\n 1. card (wordinterval_to_set r1 \\<union> wordinterval_to_set r2)\n    \\<le> card (wordinterval_to_set r1) + card (wordinterval_to_set r2)", "by blast"], ["proof (state)\nthis:\n  card (wordinterval_to_set r1 \\<union> wordinterval_to_set r2)\n  \\<le> card (wordinterval_to_set r1) + card (wordinterval_to_set r2)\n\ngoal (1 subgoal):\n 1. \\<And>r1 r2.\n       \\<lbrakk>card (wordinterval_to_set r1) \\<le> wordinterval_card r1;\n        card (wordinterval_to_set r2) \\<le> wordinterval_card r2\\<rbrakk>\n       \\<Longrightarrow> card (wordinterval_to_set (RangeUnion r1 r2))\n                         \\<le> wordinterval_card (RangeUnion r1 r2)", "with RangeUnion"], ["proof (chain)\npicking this:\n  card (wordinterval_to_set r1) \\<le> wordinterval_card r1\n  card (wordinterval_to_set r2) \\<le> wordinterval_card r2\n  card (wordinterval_to_set r1 \\<union> wordinterval_to_set r2)\n  \\<le> card (wordinterval_to_set r1) + card (wordinterval_to_set r2)", "show ?case"], ["proof (prove)\nusing this:\n  card (wordinterval_to_set r1) \\<le> wordinterval_card r1\n  card (wordinterval_to_set r2) \\<le> wordinterval_card r2\n  card (wordinterval_to_set r1 \\<union> wordinterval_to_set r2)\n  \\<le> card (wordinterval_to_set r1) + card (wordinterval_to_set r2)\n\ngoal (1 subgoal):\n 1. card (wordinterval_to_set (RangeUnion r1 r2))\n    \\<le> wordinterval_card (RangeUnion r1 r2)", "by(simp)"], ["proof (state)\nthis:\n  card (wordinterval_to_set (RangeUnion r1 r2))\n  \\<le> wordinterval_card (RangeUnion r1 r2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>With @{thm wordinterval_compress} it should be possible to get the exact cardinality\\<close>"], ["", "end"], ["", "end"]]}