{"file_name": "/home/qj213/afp-2021-10-22/thys/Comparison_Sort_Lower_Bound/Comparison_Sort_Lower_Bound.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Comparison_Sort_Lower_Bound", "problem_names": ["lemma count_wc_queries_empty [simp]: \"count_wc_queries {} sorter = 0\"", "lemma count_wc_queries_aux:\n  assumes \"\\<And>R. R \\<in> Rs \\<Longrightarrow> sorter = sorter' R\" \"Rs \\<subseteq> Rs'\" \"finite Rs'\"\n  shows   \"count_wc_queries Rs sorter \\<le> Max ((\\<lambda>R. count_queries R (sorter' R)) ` Rs')\"", "lemma card_range_eval_sorter:\n  assumes \"finite Rs\"\n  shows   \"card ((\\<lambda>R. eval_sorter R e) ` Rs) \\<le> 2 ^ count_wc_queries Rs e\"", "theorem\n  fixes sorter :: \"'a sorter\" and xs :: \"'a list\"\n  assumes distinct: \"distinct xs\"\n  assumes sorter: \"\\<And>R. linorder_on (set xs) R \\<Longrightarrow> is_sorting R xs (eval_sorter R sorter)\"\n  defines \"Rs \\<equiv> {R. linorder_on (set xs) R}\"\n  shows   two_power_count_queries_ge: \"fact (length xs) \\<le> (2 ^ count_wc_queries Rs sorter :: nat)\"\n    and   count_queries_ge:           \"log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)\"", "lemma ln_fact_bigo: \"(\\<lambda>n. ln (fact n) - (ln (2 * pi * n) / 2 + n * ln n - n)) \\<in> O(\\<lambda>n. 1 / n)\"\n  and asymp_equiv_ln_fact [asymp_equiv_intros]: \"(\\<lambda>n. ln (fact n)) \\<sim>[at_top] (\\<lambda>n. n * ln n)\""], "translations": [["", "lemma count_wc_queries_empty [simp]: \"count_wc_queries {} sorter = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_wc_queries {} sorter = 0", "by (simp add: count_wc_queries_def)"], ["", "lemma count_wc_queries_aux:\n  assumes \"\\<And>R. R \\<in> Rs \\<Longrightarrow> sorter = sorter' R\" \"Rs \\<subseteq> Rs'\" \"finite Rs'\"\n  shows   \"count_wc_queries Rs sorter \\<le> Max ((\\<lambda>R. count_queries R (sorter' R)) ` Rs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "proof (cases \"Rs = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "case False"], ["proof (state)\nthis:\n  Rs \\<noteq> {}\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "hence \"count_wc_queries Rs sorter = Max ((\\<lambda>R. count_queries R sorter) ` Rs)\""], ["proof (prove)\nusing this:\n  Rs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. count_wc_queries Rs sorter = (MAX R\\<in>Rs. count_queries R sorter)", "by (simp add: count_wc_queries_def)"], ["proof (state)\nthis:\n  count_wc_queries Rs sorter = (MAX R\\<in>Rs. count_queries R sorter)\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "also"], ["proof (state)\nthis:\n  count_wc_queries Rs sorter = (MAX R\\<in>Rs. count_queries R sorter)\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "have \"(\\<lambda>R. count_queries R sorter) ` Rs = (\\<lambda>R. count_queries R (sorter' R)) ` Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>R. count_queries R sorter) ` Rs =\n    (\\<lambda>R. count_queries R (sorter' R)) ` Rs", "by (intro image_cong refl) (simp_all add: assms)"], ["proof (state)\nthis:\n  (\\<lambda>R. count_queries R sorter) ` Rs =\n  (\\<lambda>R. count_queries R (sorter' R)) ` Rs\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "also"], ["proof (state)\nthis:\n  (\\<lambda>R. count_queries R sorter) ` Rs =\n  (\\<lambda>R. count_queries R (sorter' R)) ` Rs\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "have \"Max \\<dots> \\<le> Max ((\\<lambda>R. count_queries R (sorter' R)) ` Rs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX R\\<in>Rs. count_queries R (sorter' R))\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "using False"], ["proof (prove)\nusing this:\n  Rs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (MAX R\\<in>Rs. count_queries R (sorter' R))\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "by (intro Max_mono assms image_mono finite_imageI) auto"], ["proof (state)\nthis:\n  (MAX R\\<in>Rs. count_queries R (sorter' R))\n  \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "finally"], ["proof (chain)\npicking this:\n  count_wc_queries Rs sorter\n  \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "show ?thesis"], ["proof (prove)\nusing this:\n  count_wc_queries Rs sorter\n  \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))\n\ngoal (1 subgoal):\n 1. count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "."], ["proof (state)\nthis:\n  count_wc_queries Rs sorter\n  \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))\n\ngoal (1 subgoal):\n 1. Rs = {} \\<Longrightarrow>\n    count_wc_queries Rs sorter\n    \\<le> (MAX R\\<in>Rs'. count_queries R (sorter' R))", "qed simp_all"], ["", "primrec eval_sorter :: \"('a \\<times> 'a) set \\<Rightarrow> 'a sorter \\<Rightarrow> 'a list\" where\n  \"eval_sorter _ (Return ys)   = ys\"\n| \"eval_sorter R (Query a b f) = eval_sorter R (f ((a,b) \\<in> R))\""], ["", "text \\<open>\n  We now get an obvious bound on the maximum number of different results that a given sorter \n  can produce.\n\\<close>"], ["", "lemma card_range_eval_sorter:\n  assumes \"finite Rs\"\n  shows   \"card ((\\<lambda>R. eval_sorter R e) ` Rs) \\<le> 2 ^ count_wc_queries Rs e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>R. eval_sorter R e) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs e", "using assms"], ["proof (prove)\nusing this:\n  finite Rs\n\ngoal (1 subgoal):\n 1. card ((\\<lambda>R. eval_sorter R e) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs e", "proof (induction e arbitrary: Rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x Rs.\n       finite Rs \\<Longrightarrow>\n       card ((\\<lambda>R. eval_sorter R (Return x)) ` Rs)\n       \\<le> 2 ^ count_wc_queries Rs (Return x)\n 2. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "case (Return xs Rs)"], ["proof (state)\nthis:\n  finite Rs\n\ngoal (2 subgoals):\n 1. \\<And>x Rs.\n       finite Rs \\<Longrightarrow>\n       card ((\\<lambda>R. eval_sorter R (Return x)) ` Rs)\n       \\<le> 2 ^ count_wc_queries Rs (Return x)\n 2. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "have *: \"(\\<lambda>R. eval_sorter R (Return xs)) ` Rs = (if Rs = {} then {} else {xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>R. eval_sorter R (Return xs)) ` Rs =\n    (if Rs = {} then {} else {xs})", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>R. eval_sorter R (Return xs)) ` Rs =\n  (if Rs = {} then {} else {xs})\n\ngoal (2 subgoals):\n 1. \\<And>x Rs.\n       finite Rs \\<Longrightarrow>\n       card ((\\<lambda>R. eval_sorter R (Return x)) ` Rs)\n       \\<le> 2 ^ count_wc_queries Rs (Return x)\n 2. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>R. eval_sorter R (Return xs)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Return xs)", "by (subst *) auto"], ["proof (state)\nthis:\n  card ((\\<lambda>R. eval_sorter R (Return xs)) ` Rs)\n  \\<le> 2 ^ count_wc_queries Rs (Return xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "case (Query a b f Rs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x3a \\<in> range f; finite ?Rs\\<rbrakk>\n  \\<Longrightarrow> card ((\\<lambda>R. eval_sorter R ?x3a) ` ?Rs)\n                    \\<le> 2 ^ count_wc_queries ?Rs ?x3a\n  finite Rs\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "have \"f True \\<in> range f\" \"f False \\<in> range f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f True \\<in> range f &&& f False \\<in> range f", "by simp_all"], ["proof (state)\nthis:\n  f True \\<in> range f\n  f False \\<in> range f\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "note IH = this [THEN Query.IH]"], ["proof (state)\nthis:\n  finite ?Rs \\<Longrightarrow>\n  card ((\\<lambda>R. eval_sorter R (f True)) ` ?Rs)\n  \\<le> 2 ^ count_wc_queries ?Rs (f True)\n  finite ?Rs \\<Longrightarrow>\n  card ((\\<lambda>R. eval_sorter R (f False)) ` ?Rs)\n  \\<le> 2 ^ count_wc_queries ?Rs (f False)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "let ?Rs1 = \"{R\\<in>Rs. (a, b) \\<in> R}\" and ?Rs2 = \"{R\\<in>Rs. (a, b) \\<notin> R}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "let ?A = \"(\\<lambda>R. eval_sorter R (f True)) ` ?Rs1\" and ?B = \"(\\<lambda>R. eval_sorter R (f False)) ` ?Rs2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "from Query.prems"], ["proof (chain)\npicking this:\n  finite Rs", "have fin: \"finite ?Rs1\" \"finite ?Rs2\""], ["proof (prove)\nusing this:\n  finite Rs\n\ngoal (1 subgoal):\n 1. finite {R \\<in> Rs. (a, b) \\<in> R} &&&\n    finite {R \\<in> Rs. (a, b) \\<notin> R}", "by simp_all"], ["proof (state)\nthis:\n  finite {R \\<in> Rs. (a, b) \\<in> R}\n  finite {R \\<in> Rs. (a, b) \\<notin> R}\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "have *: \"(\\<lambda>R. eval_sorter R (Query a b f)) ` Rs \\<subseteq> ?A \\<union> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>R. eval_sorter R (Query a b f)) ` Rs\n    \\<subseteq> (\\<lambda>R. eval_sorter R (f True)) `\n                {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n                (\\<lambda>R. eval_sorter R (f False)) `\n                {R \\<in> Rs. (a, b) \\<notin> R}", "proof (intro subsetI, elim imageE, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x R.\n       \\<lbrakk>x = eval_sorter R (Query a b f); R \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>R. eval_sorter R (f True)) `\n                                 {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n                                 (\\<lambda>R. eval_sorter R (f False)) `\n                                 {R \\<in> Rs. (a, b) \\<notin> R}", "case (1 xs R)"], ["proof (state)\nthis:\n  xs = eval_sorter R (Query a b f)\n  R \\<in> Rs\n\ngoal (1 subgoal):\n 1. \\<And>x R.\n       \\<lbrakk>x = eval_sorter R (Query a b f); R \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>R. eval_sorter R (f True)) `\n                                 {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n                                 (\\<lambda>R. eval_sorter R (f False)) `\n                                 {R \\<in> Rs. (a, b) \\<notin> R}", "thus ?case"], ["proof (prove)\nusing this:\n  xs = eval_sorter R (Query a b f)\n  R \\<in> Rs\n\ngoal (1 subgoal):\n 1. xs \\<in> (\\<lambda>R. eval_sorter R (f True)) `\n             {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n             (\\<lambda>R. eval_sorter R (f False)) `\n             {R \\<in> Rs. (a, b) \\<notin> R}", "by (cases \"(a,b) \\<in> R\") auto"], ["proof (state)\nthis:\n  xs \\<in> (\\<lambda>R. eval_sorter R (f True)) `\n           {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n           (\\<lambda>R. eval_sorter R (f False)) `\n           {R \\<in> Rs. (a, b) \\<notin> R}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>R. eval_sorter R (Query a b f)) ` Rs\n  \\<subseteq> (\\<lambda>R. eval_sorter R (f True)) `\n              {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n              (\\<lambda>R. eval_sorter R (f False)) `\n              {R \\<in> Rs. (a, b) \\<notin> R}\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x3 Rs.\n       \\<lbrakk>\\<And>x3a Rs.\n                   \\<lbrakk>x3a \\<in> range x3; finite Rs\\<rbrakk>\n                   \\<Longrightarrow> card\n((\\<lambda>R. eval_sorter R x3a) ` Rs)\n                                     \\<le> 2 ^ count_wc_queries Rs x3a;\n        finite Rs\\<rbrakk>\n       \\<Longrightarrow> card\n                          ((\\<lambda>R. eval_sorter R (Query x1a x2 x3)) `\n                           Rs)\n                         \\<le> 2 ^ count_wc_queries Rs (Query x1a x2 x3)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "proof (cases \"Rs = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "case False"], ["proof (state)\nthis:\n  Rs \\<noteq> {}\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "have \"card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs) \\<le> card (?A \\<union> ?B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> card\n           ((\\<lambda>R. eval_sorter R (f True)) `\n            {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n            (\\<lambda>R. eval_sorter R (f False)) `\n            {R \\<in> Rs. (a, b) \\<notin> R})", "by (intro card_mono finite_UnI finite_imageI fin *)"], ["proof (state)\nthis:\n  card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n  \\<le> card\n         ((\\<lambda>R. eval_sorter R (f True)) `\n          {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n          (\\<lambda>R. eval_sorter R (f False)) `\n          {R \\<in> Rs. (a, b) \\<notin> R})\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "also"], ["proof (state)\nthis:\n  card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n  \\<le> card\n         ((\\<lambda>R. eval_sorter R (f True)) `\n          {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n          (\\<lambda>R. eval_sorter R (f False)) `\n          {R \\<in> Rs. (a, b) \\<notin> R})\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "have \"\\<dots> \\<le> card ?A + card ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>R. eval_sorter R (f True)) `\n      {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n      (\\<lambda>R. eval_sorter R (f False)) `\n      {R \\<in> Rs. (a, b) \\<notin> R})\n    \\<le> card\n           ((\\<lambda>R. eval_sorter R (f True)) `\n            {R \\<in> Rs. (a, b) \\<in> R}) +\n          card\n           ((\\<lambda>R. eval_sorter R (f False)) `\n            {R \\<in> Rs. (a, b) \\<notin> R})", "by (rule card_Un_le)"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>R. eval_sorter R (f True)) `\n    {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n    (\\<lambda>R. eval_sorter R (f False)) ` {R \\<in> Rs. (a, b) \\<notin> R})\n  \\<le> card\n         ((\\<lambda>R. eval_sorter R (f True)) `\n          {R \\<in> Rs. (a, b) \\<in> R}) +\n        card\n         ((\\<lambda>R. eval_sorter R (f False)) `\n          {R \\<in> Rs. (a, b) \\<notin> R})\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "also"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>R. eval_sorter R (f True)) `\n    {R \\<in> Rs. (a, b) \\<in> R} \\<union>\n    (\\<lambda>R. eval_sorter R (f False)) ` {R \\<in> Rs. (a, b) \\<notin> R})\n  \\<le> card\n         ((\\<lambda>R. eval_sorter R (f True)) `\n          {R \\<in> Rs. (a, b) \\<in> R}) +\n        card\n         ((\\<lambda>R. eval_sorter R (f False)) `\n          {R \\<in> Rs. (a, b) \\<notin> R})\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "have \"\\<dots> \\<le> 2 ^ count_wc_queries ?Rs1 (f True) + 2 ^ count_wc_queries ?Rs2 (f False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>R. eval_sorter R (f True)) ` {R \\<in> Rs. (a, b) \\<in> R}) +\n    card\n     ((\\<lambda>R. eval_sorter R (f False)) `\n      {R \\<in> Rs. (a, b) \\<notin> R})\n    \\<le> 2 ^ count_wc_queries {R \\<in> Rs. (a, b) \\<in> R} (f True) +\n          2 ^ count_wc_queries {R \\<in> Rs. (a, b) \\<notin> R} (f False)", "by (intro add_mono IH fin)"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>R. eval_sorter R (f True)) ` {R \\<in> Rs. (a, b) \\<in> R}) +\n  card\n   ((\\<lambda>R. eval_sorter R (f False)) ` {R \\<in> Rs. (a, b) \\<notin> R})\n  \\<le> 2 ^ count_wc_queries {R \\<in> Rs. (a, b) \\<in> R} (f True) +\n        2 ^ count_wc_queries {R \\<in> Rs. (a, b) \\<notin> R} (f False)\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "also"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>R. eval_sorter R (f True)) ` {R \\<in> Rs. (a, b) \\<in> R}) +\n  card\n   ((\\<lambda>R. eval_sorter R (f False)) ` {R \\<in> Rs. (a, b) \\<notin> R})\n  \\<le> 2 ^ count_wc_queries {R \\<in> Rs. (a, b) \\<in> R} (f True) +\n        2 ^ count_wc_queries {R \\<in> Rs. (a, b) \\<notin> R} (f False)\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "have \"count_wc_queries ?Rs1 (f True) \\<le> Max ((\\<lambda>R. count_queries R (f ((a,b)\\<in>R))) ` Rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_wc_queries {R \\<in> Rs. (a, b) \\<in> R} (f True)\n    \\<le> (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R)))", "by (intro count_wc_queries_aux Query.prems) auto"], ["proof (state)\nthis:\n  count_wc_queries {R \\<in> Rs. (a, b) \\<in> R} (f True)\n  \\<le> (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R)))\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "also"], ["proof (state)\nthis:\n  count_wc_queries {R \\<in> Rs. (a, b) \\<in> R} (f True)\n  \\<le> (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R)))\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "have \"count_wc_queries ?Rs2 (f False) \\<le> Max ((\\<lambda>R. count_queries R (f ((a,b)\\<in>R))) ` Rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_wc_queries {R \\<in> Rs. (a, b) \\<notin> R} (f False)\n    \\<le> (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R)))", "by (intro count_wc_queries_aux Query.prems) auto"], ["proof (state)\nthis:\n  count_wc_queries {R \\<in> Rs. (a, b) \\<notin> R} (f False)\n  \\<le> (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R)))\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "also"], ["proof (state)\nthis:\n  count_wc_queries {R \\<in> Rs. (a, b) \\<notin> R} (f False)\n  \\<le> (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R)))\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "have \"2 ^ \\<dots> + 2 ^ \\<dots> = (2 ^ Suc \\<dots> :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) +\n    2 ^ (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) =\n    2 ^ Suc (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R)))", "by simp"], ["proof (state)\nthis:\n  2 ^ (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) +\n  2 ^ (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) =\n  2 ^ Suc (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R)))\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "also"], ["proof (state)\nthis:\n  2 ^ (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) +\n  2 ^ (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) =\n  2 ^ Suc (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R)))\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "have \"Suc (Max ((\\<lambda>R. count_queries R (f ((a,b)\\<in>R))) ` Rs)) = \n                 Max (Suc ` ((\\<lambda>R. count_queries R (f ((a,b)\\<in>R))) ` Rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) =\n    Max (Suc ` (\\<lambda>R. count_queries R (f ((a, b) \\<in> R))) ` Rs)", "using False"], ["proof (prove)\nusing this:\n  Rs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Suc (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) =\n    Max (Suc ` (\\<lambda>R. count_queries R (f ((a, b) \\<in> R))) ` Rs)", "by (intro mono_Max_commute finite_imageI Query.prems) (auto simp: incseq_def)"], ["proof (state)\nthis:\n  Suc (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) =\n  Max (Suc ` (\\<lambda>R. count_queries R (f ((a, b) \\<in> R))) ` Rs)\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "also"], ["proof (state)\nthis:\n  Suc (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) =\n  Max (Suc ` (\\<lambda>R. count_queries R (f ((a, b) \\<in> R))) ` Rs)\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "have \"Suc ` ((\\<lambda>R. count_queries R (f ((a,b)\\<in>R))) ` Rs) = \n                 (\\<lambda>R. Suc (count_queries R (f ((a,b)\\<in>R)))) ` Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc ` (\\<lambda>R. count_queries R (f ((a, b) \\<in> R))) ` Rs =\n    (\\<lambda>R. Suc (count_queries R (f ((a, b) \\<in> R)))) ` Rs", "by (simp add: image_image)"], ["proof (state)\nthis:\n  Suc ` (\\<lambda>R. count_queries R (f ((a, b) \\<in> R))) ` Rs =\n  (\\<lambda>R. Suc (count_queries R (f ((a, b) \\<in> R)))) ` Rs\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "also"], ["proof (state)\nthis:\n  Suc ` (\\<lambda>R. count_queries R (f ((a, b) \\<in> R))) ` Rs =\n  (\\<lambda>R. Suc (count_queries R (f ((a, b) \\<in> R)))) ` Rs\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "have \"Max \\<dots> = count_wc_queries Rs (Query a b f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX R\\<in>Rs. Suc (count_queries R (f ((a, b) \\<in> R)))) =\n    count_wc_queries Rs (Query a b f)", "using False"], ["proof (prove)\nusing this:\n  Rs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (MAX R\\<in>Rs. Suc (count_queries R (f ((a, b) \\<in> R)))) =\n    count_wc_queries Rs (Query a b f)", "by (auto simp add: count_wc_queries_def)"], ["proof (state)\nthis:\n  (MAX R\\<in>Rs. Suc (count_queries R (f ((a, b) \\<in> R)))) =\n  count_wc_queries Rs (Query a b f)\n\ngoal (2 subgoals):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n 2. Rs \\<noteq> {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              2 ^ x +\n              2 ^ count_wc_queries {R \\<in> Rs. (a, b) \\<notin> R} (f False)\n              \\<le> 2 ^ y +\n                    2 ^\n                    count_wc_queries {R \\<in> Rs. (a, b) \\<notin> R}\n                     (f False);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 ^ (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) + 2 ^ x\n      \\<le> 2 ^ (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) +\n            2 ^ y\\<rbrakk>\n  \\<Longrightarrow> card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n                    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              2 ^ x +\n              2 ^ count_wc_queries {R \\<in> Rs. (a, b) \\<notin> R} (f False)\n              \\<le> 2 ^ y +\n                    2 ^\n                    count_wc_queries {R \\<in> Rs. (a, b) \\<notin> R}\n                     (f False);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 ^ (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) + 2 ^ x\n      \\<le> 2 ^ (MAX R\\<in>Rs. count_queries R (f ((a, b) \\<in> R))) +\n            2 ^ y\\<rbrakk>\n  \\<Longrightarrow> card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n                    \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n\ngoal (1 subgoal):\n 1. card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "by - simp_all"], ["proof (state)\nthis:\n  card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n  \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n\ngoal (1 subgoal):\n 1. Rs = {} \\<Longrightarrow>\n    card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs (Query a b f)", "qed simp_all"], ["proof (state)\nthis:\n  card ((\\<lambda>R. eval_sorter R (Query a b f)) ` Rs)\n  \\<le> 2 ^ count_wc_queries Rs (Query a b f)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following predicate describes what constitutes a valid sorting result for a given \n  ordering and a given input list. Note that when the ordering is linear, the result is\n  actually unique.\n\\<close>"], ["", "definition is_sorting :: \"('a \\<times> 'a) set \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  \"is_sorting R xs ys \\<longleftrightarrow> (mset xs = mset ys) \\<and> sorted_wrt R ys\""], ["", "subsection \\<open>Lower bounds on number of comparisons\\<close>"], ["", "text \\<open>\n  For a list of $n$ distinct elements, there are $n!$ linear orderings on $n$ elements,\n  each of which leads to a different result after sorting the original list. \n  Since a sorter can produce at most $2^k$ different results with $k$ comparisons, we get \n  the bound $2^k \\geq n!$:\n\\<close>"], ["", "theorem\n  fixes sorter :: \"'a sorter\" and xs :: \"'a list\"\n  assumes distinct: \"distinct xs\"\n  assumes sorter: \"\\<And>R. linorder_on (set xs) R \\<Longrightarrow> is_sorting R xs (eval_sorter R sorter)\"\n  defines \"Rs \\<equiv> {R. linorder_on (set xs) R}\"\n  shows   two_power_count_queries_ge: \"fact (length xs) \\<le> (2 ^ count_wc_queries Rs sorter :: nat)\"\n    and   count_queries_ge:           \"log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter &&&\n    log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter\n 2. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "have \"Rs \\<subseteq> Pow (set xs \\<times> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs \\<subseteq> Pow (set xs \\<times> set xs)", "by (auto simp: Rs_def linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  Rs \\<subseteq> Pow (set xs \\<times> set xs)\n\ngoal (2 subgoals):\n 1. fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter\n 2. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "hence fin: \"finite Rs\""], ["proof (prove)\nusing this:\n  Rs \\<subseteq> Pow (set xs \\<times> set xs)\n\ngoal (1 subgoal):\n 1. finite Rs", "by (rule finite_subset) simp_all"], ["proof (state)\nthis:\n  finite Rs\n\ngoal (2 subgoals):\n 1. fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter\n 2. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "from assms"], ["proof (chain)\npicking this:\n  distinct xs\n  linorder_on (set xs) ?R \\<Longrightarrow>\n  is_sorting ?R xs (eval_sorter ?R sorter)\n  Rs \\<equiv> {R. linorder_on (set xs) R}", "have \"fact (length xs) = card (permutations_of_set (set xs))\""], ["proof (prove)\nusing this:\n  distinct xs\n  linorder_on (set xs) ?R \\<Longrightarrow>\n  is_sorting ?R xs (eval_sorter ?R sorter)\n  Rs \\<equiv> {R. linorder_on (set xs) R}\n\ngoal (1 subgoal):\n 1. fact (length xs) = card (permutations_of_set (set xs))", "by (simp add: distinct_card)"], ["proof (state)\nthis:\n  fact (length xs) = card (permutations_of_set (set xs))\n\ngoal (2 subgoals):\n 1. fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter\n 2. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "also"], ["proof (state)\nthis:\n  fact (length xs) = card (permutations_of_set (set xs))\n\ngoal (2 subgoals):\n 1. fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter\n 2. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "have \"permutations_of_set (set xs) \\<subseteq> (\\<lambda>R. eval_sorter R sorter) ` Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutations_of_set (set xs)\n    \\<subseteq> (\\<lambda>R. eval_sorter R sorter) ` Rs", "proof (rule subsetI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "case (1 ys)"], ["proof (state)\nthis:\n  ys \\<in> permutations_of_set (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "define R where \"R = linorder_of_list ys\""], ["proof (state)\nthis:\n  R = linorder_of_list ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "define zs where \"zs = eval_sorter R sorter\""], ["proof (state)\nthis:\n  zs = eval_sorter R sorter\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "from 1 and distinct"], ["proof (chain)\npicking this:\n  ys \\<in> permutations_of_set (set xs)\n  distinct xs", "have mset_ys: \"mset ys = mset xs\""], ["proof (prove)\nusing this:\n  ys \\<in> permutations_of_set (set xs)\n  distinct xs\n\ngoal (1 subgoal):\n 1. mset ys = mset xs", "by (auto simp: set_eq_iff_mset_eq_distinct permutations_of_set_def)"], ["proof (state)\nthis:\n  mset ys = mset xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "from 1"], ["proof (chain)\npicking this:\n  ys \\<in> permutations_of_set (set xs)", "have *: \"linorder_on (set xs) R\""], ["proof (prove)\nusing this:\n  ys \\<in> permutations_of_set (set xs)\n\ngoal (1 subgoal):\n 1. linorder_on (set xs) R", "unfolding R_def"], ["proof (prove)\nusing this:\n  ys \\<in> permutations_of_set (set xs)\n\ngoal (1 subgoal):\n 1. linorder_on (set xs) (linorder_of_list ys)", "using linorder_linorder_of_list[of ys]"], ["proof (prove)\nusing this:\n  ys \\<in> permutations_of_set (set xs)\n  distinct ys \\<Longrightarrow> linorder_on (set ys) (linorder_of_list ys)\n\ngoal (1 subgoal):\n 1. linorder_on (set xs) (linorder_of_list ys)", "by (simp add: permutations_of_set_def)"], ["proof (state)\nthis:\n  linorder_on (set xs) R\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "from sorter[OF this]"], ["proof (chain)\npicking this:\n  is_sorting R xs (eval_sorter R sorter)", "have \"mset xs = mset zs\" \"sorted_wrt R zs\""], ["proof (prove)\nusing this:\n  is_sorting R xs (eval_sorter R sorter)\n\ngoal (1 subgoal):\n 1. mset xs = mset zs &&& Linorder_Relations.sorted_wrt R zs", "by (simp_all add: is_sorting_def zs_def)"], ["proof (state)\nthis:\n  mset xs = mset zs\n  Linorder_Relations.sorted_wrt R zs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "moreover"], ["proof (state)\nthis:\n  mset xs = mset zs\n  Linorder_Relations.sorted_wrt R zs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "from 1"], ["proof (chain)\npicking this:\n  ys \\<in> permutations_of_set (set xs)", "have \"sorted_wrt R ys\""], ["proof (prove)\nusing this:\n  ys \\<in> permutations_of_set (set xs)\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R ys", "unfolding R_def"], ["proof (prove)\nusing this:\n  ys \\<in> permutations_of_set (set xs)\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt (linorder_of_list ys) ys", "by (intro sorted_wrt_linorder_of_list) (simp_all add: permutations_of_set_def)"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "ultimately"], ["proof (chain)\npicking this:\n  mset xs = mset zs\n  Linorder_Relations.sorted_wrt R zs\n  Linorder_Relations.sorted_wrt R ys", "have \"zs = ys\""], ["proof (prove)\nusing this:\n  mset xs = mset zs\n  Linorder_Relations.sorted_wrt R zs\n  Linorder_Relations.sorted_wrt R ys\n\ngoal (1 subgoal):\n 1. zs = ys", "by (intro sorted_wrt_linorder_unique[OF *]) (simp_all add: mset_ys)"], ["proof (state)\nthis:\n  zs = ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "moreover"], ["proof (state)\nthis:\n  zs = ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "from *"], ["proof (chain)\npicking this:\n  linorder_on (set xs) R", "have \"R \\<in> Rs\""], ["proof (prove)\nusing this:\n  linorder_on (set xs) R\n\ngoal (1 subgoal):\n 1. R \\<in> Rs", "by (simp add: Rs_def)"], ["proof (state)\nthis:\n  R \\<in> Rs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> permutations_of_set (set xs) \\<Longrightarrow>\n       x \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "ultimately"], ["proof (chain)\npicking this:\n  zs = ys\n  R \\<in> Rs", "show ?case"], ["proof (prove)\nusing this:\n  zs = ys\n  R \\<in> Rs\n\ngoal (1 subgoal):\n 1. ys \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "unfolding zs_def"], ["proof (prove)\nusing this:\n  eval_sorter R sorter = ys\n  R \\<in> Rs\n\ngoal (1 subgoal):\n 1. ys \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs", "by blast"], ["proof (state)\nthis:\n  ys \\<in> (\\<lambda>R. eval_sorter R sorter) ` Rs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  permutations_of_set (set xs)\n  \\<subseteq> (\\<lambda>R. eval_sorter R sorter) ` Rs\n\ngoal (2 subgoals):\n 1. fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter\n 2. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "hence \"card (permutations_of_set (set xs)) \\<le> card ((\\<lambda>R. eval_sorter R sorter) ` Rs)\""], ["proof (prove)\nusing this:\n  permutations_of_set (set xs)\n  \\<subseteq> (\\<lambda>R. eval_sorter R sorter) ` Rs\n\ngoal (1 subgoal):\n 1. card (permutations_of_set (set xs))\n    \\<le> card ((\\<lambda>R. eval_sorter R sorter) ` Rs)", "by (intro card_mono finite_imageI fin)"], ["proof (state)\nthis:\n  card (permutations_of_set (set xs))\n  \\<le> card ((\\<lambda>R. eval_sorter R sorter) ` Rs)\n\ngoal (2 subgoals):\n 1. fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter\n 2. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "also"], ["proof (state)\nthis:\n  card (permutations_of_set (set xs))\n  \\<le> card ((\\<lambda>R. eval_sorter R sorter) ` Rs)\n\ngoal (2 subgoals):\n 1. fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter\n 2. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "from fin"], ["proof (chain)\npicking this:\n  finite Rs", "have \"\\<dots> \\<le> 2 ^ count_wc_queries Rs sorter\""], ["proof (prove)\nusing this:\n  finite Rs\n\ngoal (1 subgoal):\n 1. card ((\\<lambda>R. eval_sorter R sorter) ` Rs)\n    \\<le> 2 ^ count_wc_queries Rs sorter", "by (rule card_range_eval_sorter)"], ["proof (state)\nthis:\n  card ((\\<lambda>R. eval_sorter R sorter) ` Rs)\n  \\<le> 2 ^ count_wc_queries Rs sorter\n\ngoal (2 subgoals):\n 1. fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter\n 2. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "finally"], ["proof (chain)\npicking this:\n  fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter", "show *: \"fact (length xs) \\<le> (2 ^ count_wc_queries Rs sorter :: nat)\""], ["proof (prove)\nusing this:\n  fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter\n\ngoal (1 subgoal):\n 1. fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter", "."], ["proof (state)\nthis:\n  fact (length xs) \\<le> 2 ^ count_wc_queries Rs sorter\n\ngoal (1 subgoal):\n 1. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "have \"ln (fact (length xs)) = ln (real (fact (length xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (fact (length xs)) = ln (real (fact (length xs)))", "by simp"], ["proof (state)\nthis:\n  ln (fact (length xs)) = ln (real (fact (length xs)))\n\ngoal (1 subgoal):\n 1. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "also"], ["proof (state)\nthis:\n  ln (fact (length xs)) = ln (real (fact (length xs)))\n\ngoal (1 subgoal):\n 1. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "have \"\\<dots> \\<le> ln (real (2 ^ count_wc_queries Rs sorter))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (real (fact (length xs)))\n    \\<le> ln (real (2 ^ count_wc_queries Rs sorter))", "proof (subst ln_le_cancel_iff)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < real (fact (length xs))\n 2. 0 < real (2 ^ count_wc_queries Rs sorter)\n 3. real (fact (length xs)) \\<le> real (2 ^ count_wc_queries Rs sorter)", "show \"real (fact (length xs)) \\<le> real (2 ^ count_wc_queries Rs sorter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (fact (length xs)) \\<le> real (2 ^ count_wc_queries Rs sorter)", "by (subst of_nat_le_iff) (rule *)"], ["proof (state)\nthis:\n  real (fact (length xs)) \\<le> real (2 ^ count_wc_queries Rs sorter)\n\ngoal (2 subgoals):\n 1. 0 < real (fact (length xs))\n 2. 0 < real (2 ^ count_wc_queries Rs sorter)", "qed simp_all"], ["proof (state)\nthis:\n  ln (real (fact (length xs)))\n  \\<le> ln (real (2 ^ count_wc_queries Rs sorter))\n\ngoal (1 subgoal):\n 1. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "also"], ["proof (state)\nthis:\n  ln (real (fact (length xs)))\n  \\<le> ln (real (2 ^ count_wc_queries Rs sorter))\n\ngoal (1 subgoal):\n 1. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "have \"\\<dots> = real (count_wc_queries Rs sorter) * ln 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (real (2 ^ count_wc_queries Rs sorter)) =\n    real (count_wc_queries Rs sorter) * ln 2", "by (simp add: ln_realpow)"], ["proof (state)\nthis:\n  ln (real (2 ^ count_wc_queries Rs sorter)) =\n  real (count_wc_queries Rs sorter) * ln 2\n\ngoal (1 subgoal):\n 1. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "finally"], ["proof (chain)\npicking this:\n  ln (fact (length xs)) \\<le> real (count_wc_queries Rs sorter) * ln 2", "have \"real (count_wc_queries Rs sorter) \\<ge> ln (fact (length xs)) / ln 2\""], ["proof (prove)\nusing this:\n  ln (fact (length xs)) \\<le> real (count_wc_queries Rs sorter) * ln 2\n\ngoal (1 subgoal):\n 1. ln (fact (length xs)) / ln 2 \\<le> real (count_wc_queries Rs sorter)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  ln (fact (length xs)) / ln 2 \\<le> real (count_wc_queries Rs sorter)\n\ngoal (1 subgoal):\n 1. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "also"], ["proof (state)\nthis:\n  ln (fact (length xs)) / ln 2 \\<le> real (count_wc_queries Rs sorter)\n\ngoal (1 subgoal):\n 1. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "have \"ln (fact (length xs)) / ln 2 = log 2 (fact (length xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ln (fact (length xs)) / ln 2 = log 2 (fact (length xs))", "by (simp add: log_def)"], ["proof (state)\nthis:\n  ln (fact (length xs)) / ln 2 = log 2 (fact (length xs))\n\ngoal (1 subgoal):\n 1. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "finally"], ["proof (chain)\npicking this:\n  log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "show **: \"log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)\""], ["proof (prove)\nusing this:\n  log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)\n\ngoal (1 subgoal):\n 1. log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)", "."], ["proof (state)\nthis:\n  log 2 (fact (length xs)) \\<le> real (count_wc_queries Rs sorter)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Good example for automation. Also, move. *)"], ["", "lemma ln_fact_bigo: \"(\\<lambda>n. ln (fact n) - (ln (2 * pi * n) / 2 + n * ln n - n)) \\<in> O(\\<lambda>n. 1 / n)\"\n  and asymp_equiv_ln_fact [asymp_equiv_intros]: \"(\\<lambda>n. ln (fact n)) \\<sim>[at_top] (\\<lambda>n. n * ln n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (fact n) -\n        (ln (2 * pi * real n) / 2 + real n * ln (real n) - real n))\n    \\<in> O(\\<lambda>x. 1 / real x) &&&\n    (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n.\n        ln (fact n) -\n        (ln (2 * pi * real n) / 2 + real n * ln (real n) - real n))\n    \\<in> O(\\<lambda>x. 1 / real x)\n 2. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "include asymp_equiv_notation"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n.\n        ln (fact n) -\n        (ln (2 * pi * real n) / 2 + real n * ln (real n) - real n))\n    \\<in> O(\\<lambda>x. 1 / real x)\n 2. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "define f where \"f = (\\<lambda>n. ln (2 * pi * real n) / 2 + real n * ln (real n) - real n)\""], ["proof (state)\nthis:\n  f = (\\<lambda>n. ln (2 * pi * real n) / 2 + real n * ln (real n) - real n)\n\ngoal (2 subgoals):\n 1. (\\<lambda>n.\n        ln (fact n) -\n        (ln (2 * pi * real n) / 2 + real n * ln (real n) - real n))\n    \\<in> O(\\<lambda>x. 1 / real x)\n 2. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "have \"eventually (\\<lambda>n. ln (fact n) - f n \\<in> {0..1/(12*real n)}) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ln (fact n) - f n \\<in> {0..1 / (12 * real n)}", "using eventually_gt_at_top[of \"1::nat\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 1) sequentially\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ln (fact n) - f n \\<in> {0..1 / (12 * real n)}", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 < n \\<Longrightarrow>\n       ln (fact n) - f n \\<in> {0..1 / (12 * real n)}", "case (elim n)"], ["proof (state)\nthis:\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       1 < n \\<Longrightarrow>\n       ln (fact n) - f n \\<in> {0..1 / (12 * real n)}", "with ln_fact_bounds[of n]"], ["proof (chain)\npicking this:\n  0 < n \\<Longrightarrow>\n  ln (2 * pi * real n) / 2 + real n * ln (real n) - real n \\<le> ln (fact n)\n  0 < n \\<Longrightarrow>\n  ln (fact n)\n  \\<le> ln (2 * pi * real n) / 2 + real n * ln (real n) - real n +\n        1 / (12 * real n)\n  1 < n", "show ?case"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  ln (2 * pi * real n) / 2 + real n * ln (real n) - real n \\<le> ln (fact n)\n  0 < n \\<Longrightarrow>\n  ln (fact n)\n  \\<le> ln (2 * pi * real n) / 2 + real n * ln (real n) - real n +\n        1 / (12 * real n)\n  1 < n\n\ngoal (1 subgoal):\n 1. ln (fact n) - f n \\<in> {0..1 / (12 * real n)}", "by (simp add: f_def)"], ["proof (state)\nthis:\n  ln (fact n) - f n \\<in> {0..1 / (12 * real n)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     ln (fact n) - f n \\<in> {0..1 / (12 * real n)}\n\ngoal (2 subgoals):\n 1. (\\<lambda>n.\n        ln (fact n) -\n        (ln (2 * pi * real n) / 2 + real n * ln (real n) - real n))\n    \\<in> O(\\<lambda>x. 1 / real x)\n 2. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "hence \"eventually (\\<lambda>n. norm (ln (fact n) - f n) \\<le> (1/12) * norm (1 / real n)) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     ln (fact n) - f n \\<in> {0..1 / (12 * real n)}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       norm (ln (fact n) - f n) \\<le> 1 / 12 * norm (1 / real n)", "using eventually_gt_at_top[of \"0::nat\"]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     ln (fact n) - f n \\<in> {0..1 / (12 * real n)}\n  eventually ((<) 0) sequentially\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       norm (ln (fact n) - f n) \\<le> 1 / 12 * norm (1 / real n)", "by eventually_elim (simp_all add: field_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     norm (ln (fact n) - f n) \\<le> 1 / 12 * norm (1 / real n)\n\ngoal (2 subgoals):\n 1. (\\<lambda>n.\n        ln (fact n) -\n        (ln (2 * pi * real n) / 2 + real n * ln (real n) - real n))\n    \\<in> O(\\<lambda>x. 1 / real x)\n 2. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "thus \"(\\<lambda>n. ln (fact n) - f n) \\<in> O(\\<lambda>n. 1 / real n)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     norm (ln (fact n) - f n) \\<le> 1 / 12 * norm (1 / real n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ln (fact n) - f n) \\<in> O(\\<lambda>n. 1 / real n)", "using bigoI[of \"\\<lambda>n. ln (fact n) - f n\" \"1/12\" \"\\<lambda>n. 1 / real n\"]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     norm (ln (fact n) - f n) \\<le> 1 / 12 * norm (1 / real n)\n  \\<forall>\\<^sub>F x in ?F.\n     norm (ln (fact x) - f x)\n     \\<le> 1 / 12 * norm (1 / real x) \\<Longrightarrow>\n  (\\<lambda>n. ln (fact n) - f n) \\<in> O[?F](\\<lambda>n. 1 / real n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ln (fact n) - f n) \\<in> O(\\<lambda>n. 1 / real n)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. ln (fact n) - f n) \\<in> O(\\<lambda>n. 1 / real n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. ln (fact n) - f n) \\<in> O(\\<lambda>n. 1 / real n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "have \"(\\<lambda>n. 1 / real n) \\<in> o(f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real n) \\<in> o(f)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real n)\n    \\<in> o(\\<lambda>n.\n               ln (2 * pi * real n) / 2 + real n * ln (real n) - real n)", "by (intro smallo_real_nat_transfer) simp"], ["proof (state)\nthis:\n  (\\<lambda>n. 1 / real n) \\<in> o(f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n. ln (fact n) - f n) \\<in> o(f)", "have \"(\\<lambda>n. f n + (ln (fact n) - f n)) \\<sim> f\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. ln (fact n) - f n) \\<in> o(f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f n + (ln (fact n) - f n)) \\<sim>[sequentially] f", "by (subst asymp_equiv_add_right) simp_all"], ["proof (state)\nthis:\n  (\\<lambda>n. f n + (ln (fact n) - f n)) \\<sim>[sequentially] f\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "hence \"(\\<lambda>n. ln (fact n)) \\<sim> f\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. f n + (ln (fact n) - f n)) \\<sim>[sequentially] f\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ln (fact n)) \\<sim>[sequentially] f", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. ln (fact n)) \\<sim>[sequentially] f\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. ln (fact n)) \\<sim>[sequentially] f\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "have \"f \\<sim> (\\<lambda>n. n * ln n + (ln (2*pi*n)/2 - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sim>[sequentially] (\\<lambda>x.\n                               real x * ln (real x) +\n                               (ln (2 * pi * real x) / 2 - real x))", "by (simp add: f_def algebra_simps)"], ["proof (state)\nthis:\n  f \\<sim>[sequentially] (\\<lambda>x.\n                             real x * ln (real x) +\n                             (ln (2 * pi * real x) / 2 - real x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "also"], ["proof (state)\nthis:\n  f \\<sim>[sequentially] (\\<lambda>x.\n                             real x * ln (real x) +\n                             (ln (2 * pi * real x) / 2 - real x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "have \"\\<dots> \\<sim> (\\<lambda>n. n * ln n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real x * ln (real x) +\n        (ln (2 * pi * real x) / 2 -\n         real x)) \\<sim>[sequentially] (\\<lambda>x. real x * ln (real x))", "by (subst asymp_equiv_add_right) auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      real x * ln (real x) +\n      (ln (2 * pi * real x) / 2 -\n       real x)) \\<sim>[sequentially] (\\<lambda>x. real x * ln (real x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>c d.\n              c \\<sim>[sequentially] d \\<Longrightarrow>\n              c \\<sim>[sequentially] d;\n   \\<And>c d.\n      c \\<sim>[sequentially] d \\<Longrightarrow>\n      c \\<sim>[sequentially] d\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>n.\n                        ln (fact\n                             n)) \\<sim>[sequentially] (\\<lambda>a.\n                    real a * ln (real a))", "show \"(\\<lambda>n. ln (fact n)) \\<sim> (\\<lambda>n. n * ln n)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>c d.\n              c \\<sim>[sequentially] d \\<Longrightarrow>\n              c \\<sim>[sequentially] d;\n   \\<And>c d.\n      c \\<sim>[sequentially] d \\<Longrightarrow>\n      c \\<sim>[sequentially] d\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>n.\n                        ln (fact\n                             n)) \\<sim>[sequentially] (\\<lambda>a.\n                    real a * ln (real a))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))", "."], ["proof (state)\nthis:\n  (\\<lambda>n.\n      ln (fact n)) \\<sim>[sequentially] (\\<lambda>n. real n * ln (real n))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  This leads to the following well-known Big-Omega bound on the number of comparisons \n  that a general sorting algorithm has to make:\n\\<close>"], ["", "corollary count_queries_bigomega:\n  fixes sorter :: \"nat \\<Rightarrow> nat sorter\"\n  assumes sorter: \"\\<And>n R. linorder_on {..<n} R \\<Longrightarrow> \n                         is_sorting R [0..<n] (eval_sorter R (sorter n))\"\n  defines \"Rs \\<equiv> \\<lambda>n. {R. linorder_on {..<n} R}\"\n  shows   \"(\\<lambda>n. count_wc_queries (Rs n) (sorter n)) \\<in> \\<Omega>(\\<lambda>n. n * ln n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))\n    \\<in> \\<Omega>(\\<lambda>x. real x * ln (real x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))\n    \\<in> \\<Omega>(\\<lambda>x. real x * ln (real x))", "have \"(\\<lambda>n. n * ln n) \\<in> \\<Theta>(\\<lambda>n. ln (fact n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. real n * ln (real n))\n    \\<in> \\<Theta>(\\<lambda>n. ln (fact n))", "by (subst bigtheta_sym) (intro asymp_equiv_imp_bigtheta asymp_equiv_intros)"], ["proof (state)\nthis:\n  (\\<lambda>n. real n * ln (real n)) \\<in> \\<Theta>(\\<lambda>n. ln (fact n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))\n    \\<in> \\<Omega>(\\<lambda>x. real x * ln (real x))", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. real n * ln (real n)) \\<in> \\<Theta>(\\<lambda>n. ln (fact n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))\n    \\<in> \\<Omega>(\\<lambda>x. real x * ln (real x))", "have \"(\\<lambda>n. ln (fact n)) \\<in> \\<Theta>(\\<lambda>n. log 2 (fact n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. ln (fact n)) \\<in> \\<Theta>(\\<lambda>n. log 2 (fact n))", "by (simp add: log_def)"], ["proof (state)\nthis:\n  (\\<lambda>n. ln (fact n)) \\<in> \\<Theta>(\\<lambda>n. log 2 (fact n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))\n    \\<in> \\<Omega>(\\<lambda>x. real x * ln (real x))", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. ln (fact n)) \\<in> \\<Theta>(\\<lambda>n. log 2 (fact n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))\n    \\<in> \\<Omega>(\\<lambda>x. real x * ln (real x))", "have \"(\\<lambda>n. log 2 (fact n)) \\<in> O(\\<lambda>n. count_wc_queries (Rs n) (sorter n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. log 2 (fact n))\n    \\<in> O(\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))", "proof (intro bigoI[where c = 1] always_eventually allI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm (log 2 (fact x))\n       \\<le> 1 * norm (real (count_wc_queries (Rs x) (sorter x)))", "case (1 n)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm (log 2 (fact x))\n       \\<le> 1 * norm (real (count_wc_queries (Rs x) (sorter x)))", "have \"norm (log 2 (fact n)) = log 2 (fact (length [0..<n]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (log 2 (fact n)) = log 2 (fact (length [0..<n]))", "by simp"], ["proof (state)\nthis:\n  norm (log 2 (fact n)) = log 2 (fact (length [0..<n]))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm (log 2 (fact x))\n       \\<le> 1 * norm (real (count_wc_queries (Rs x) (sorter x)))", "also"], ["proof (state)\nthis:\n  norm (log 2 (fact n)) = log 2 (fact (length [0..<n]))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm (log 2 (fact x))\n       \\<le> 1 * norm (real (count_wc_queries (Rs x) (sorter x)))", "from sorter[of n]"], ["proof (chain)\npicking this:\n  linorder_on {..<n} ?R \\<Longrightarrow>\n  is_sorting ?R [0..<n] (eval_sorter ?R (sorter n))", "have \"\\<dots> \\<le> real (count_wc_queries (Rs n) (sorter n))\""], ["proof (prove)\nusing this:\n  linorder_on {..<n} ?R \\<Longrightarrow>\n  is_sorting ?R [0..<n] (eval_sorter ?R (sorter n))\n\ngoal (1 subgoal):\n 1. log 2 (fact (length [0..<n]))\n    \\<le> real (count_wc_queries (Rs n) (sorter n))", "using count_queries_ge[of \"[0..<n]\" \"sorter n\"]"], ["proof (prove)\nusing this:\n  linorder_on {..<n} ?R \\<Longrightarrow>\n  is_sorting ?R [0..<n] (eval_sorter ?R (sorter n))\n  \\<lbrakk>distinct [0..<n];\n   \\<And>R.\n      linorder_on (set [0..<n]) R \\<Longrightarrow>\n      is_sorting R [0..<n] (eval_sorter R (sorter n))\\<rbrakk>\n  \\<Longrightarrow> log 2 (fact (length [0..<n]))\n                    \\<le> real\n                           (count_wc_queries\n                             {R. linorder_on (set [0..<n]) R} (sorter n))\n\ngoal (1 subgoal):\n 1. log 2 (fact (length [0..<n]))\n    \\<le> real (count_wc_queries (Rs n) (sorter n))", "by (auto simp: Rs_def atLeast0LessThan)"], ["proof (state)\nthis:\n  log 2 (fact (length [0..<n]))\n  \\<le> real (count_wc_queries (Rs n) (sorter n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm (log 2 (fact x))\n       \\<le> 1 * norm (real (count_wc_queries (Rs x) (sorter x)))", "also"], ["proof (state)\nthis:\n  log 2 (fact (length [0..<n]))\n  \\<le> real (count_wc_queries (Rs n) (sorter n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm (log 2 (fact x))\n       \\<le> 1 * norm (real (count_wc_queries (Rs x) (sorter x)))", "have \"\\<dots> = 1 * norm \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (count_wc_queries (Rs n) (sorter n)) =\n    1 * norm (real (count_wc_queries (Rs n) (sorter n)))", "by simp"], ["proof (state)\nthis:\n  real (count_wc_queries (Rs n) (sorter n)) =\n  1 * norm (real (count_wc_queries (Rs n) (sorter n)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm (log 2 (fact x))\n       \\<le> 1 * norm (real (count_wc_queries (Rs x) (sorter x)))", "finally"], ["proof (chain)\npicking this:\n  norm (log 2 (fact n))\n  \\<le> 1 * norm (real (count_wc_queries (Rs n) (sorter n)))", "show ?case"], ["proof (prove)\nusing this:\n  norm (log 2 (fact n))\n  \\<le> 1 * norm (real (count_wc_queries (Rs n) (sorter n)))\n\ngoal (1 subgoal):\n 1. norm (log 2 (fact n))\n    \\<le> 1 * norm (real (count_wc_queries (Rs n) (sorter n)))", "by simp"], ["proof (state)\nthis:\n  norm (log 2 (fact n))\n  \\<le> 1 * norm (real (count_wc_queries (Rs n) (sorter n)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>n. log 2 (fact n))\n  \\<in> O(\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))\n    \\<in> \\<Omega>(\\<lambda>x. real x * ln (real x))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n. real n * ln (real n))\n  \\<in> O(\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. real n * ln (real n))\n  \\<in> O(\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))\n    \\<in> \\<Omega>(\\<lambda>x. real x * ln (real x))", "by (simp add: bigomega_iff_bigo)"], ["proof (state)\nthis:\n  (\\<lambda>x. real (count_wc_queries (Rs x) (sorter x)))\n  \\<in> \\<Omega>(\\<lambda>x. real x * ln (real x))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}