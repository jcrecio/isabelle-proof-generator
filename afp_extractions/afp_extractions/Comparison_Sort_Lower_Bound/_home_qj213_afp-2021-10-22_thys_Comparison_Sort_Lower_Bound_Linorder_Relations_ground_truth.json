{"file_name": "/home/qj213/afp-2021-10-22/thys/Comparison_Sort_Lower_Bound/Linorder_Relations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Comparison_Sort_Lower_Bound", "problem_names": ["lemma distinct_count_atmost_1':\n  \"distinct xs = (\\<forall>a. count (mset xs) a \\<le> 1)\"", "lemma distinct_mset_mono: \n  assumes \"distinct ys\" \"mset xs \\<subseteq># mset ys\"\n  shows   \"distinct xs\"", "lemma mset_eq_imp_distinct_iff:\n  assumes \"mset xs = mset ys\"\n  shows   \"distinct xs \\<longleftrightarrow> distinct ys\"", "lemma total_on_subset: \"total_on B R \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> total_on A R\"", "lemma sorted_wrt_Nil [simp]: \"sorted_wrt R []\"", "lemma sorted_wrt_Cons: \"sorted_wrt R (x # xs) \\<longleftrightarrow> (\\<forall>y\\<in>set xs. (x,y) \\<in> R) \\<and> sorted_wrt R xs\"", "lemma sorted_wrt_singleton [simp]: \"sorted_wrt R [x]\"", "lemma sorted_wrt_many:\n  assumes \"trans R\"\n  shows   \"sorted_wrt R (x # y # xs) \\<longleftrightarrow> (x,y) \\<in> R \\<and> sorted_wrt R (y # xs)\"", "lemma sorted_wrt_imp_le_last:\n  assumes \"sorted_wrt R xs\" \"xs \\<noteq> []\" \"x \\<in> set xs\" \"x \\<noteq> last xs\"\n  shows   \"(x, last xs) \\<in> R\"", "lemma sorted_wrt_append:\n  assumes \"sorted_wrt R xs\" \"sorted_wrt R ys\" \n          \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> (x,y) \\<in> R\" \"trans R\"\n  shows   \"sorted_wrt R (xs @ ys)\"", "lemma sorted_wrt_snoc:\n  assumes \"sorted_wrt R xs\" \"(last xs, y) \\<in> R\" \"trans R\"\n  shows   \"sorted_wrt R (xs @ [y])\"", "lemma sorted_wrt_conv_nth:\n  \"sorted_wrt R xs \\<longleftrightarrow> (\\<forall>i j. i < j \\<and> j < length xs \\<longrightarrow> (xs!i, xs!j) \\<in> R)\"", "lemma linorder_on_cases:\n  assumes \"linorder_on A R\" \"x \\<in> A\" \"y \\<in> A\"\n  shows   \"x = y \\<or> ((x, y) \\<in> R \\<and> (y, x) \\<notin> R) \\<or> ((y, x) \\<in> R \\<and> (x, y) \\<notin> R)\"", "lemma sorted_wrt_linorder_imp_index_le:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\" \"sorted_wrt R xs\" \n          \"x \\<in> set xs\" \"y \\<in> set xs\" \"(x,y) \\<in> R\"\n  shows   \"index xs x \\<le> index xs y\"", "lemma sorted_wrt_linorder_index_le_imp:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\" \"sorted_wrt R xs\" \n          \"x \\<in> set xs\" \"y \\<in> set xs\" \"index xs x \\<le> index xs y\"\n  shows   \"(x,y) \\<in> R\"", "lemma sorted_wrt_linorder_index_le_iff:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\" \"sorted_wrt R xs\" \n          \"x \\<in> set xs\" \"y \\<in> set xs\"\n  shows   \"index xs x \\<le> index xs y \\<longleftrightarrow> (x,y) \\<in> R\"", "lemma sorted_wrt_linorder_index_less_iff:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\" \"sorted_wrt R xs\" \n          \"x \\<in> set xs\" \"y \\<in> set xs\"\n  shows   \"index xs x < index xs y \\<longleftrightarrow> (y,x) \\<notin> R\"", "lemma sorted_wrt_distinct_linorder_nth:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\" \"sorted_wrt R xs\" \"distinct xs\" \n          \"i < length xs\" \"j < length xs\"\n  shows   \"(xs!i, xs!j) \\<in> R \\<longleftrightarrow> i \\<le> j\"", "lemma linorder_linorder_of_list [intro, simp]:\n  assumes \"distinct xs\"\n  shows   \"linorder_on (set xs) (linorder_of_list xs)\"", "lemma sorted_wrt_linorder_of_list [intro, simp]: \n  \"distinct xs \\<Longrightarrow> sorted_wrt (linorder_of_list xs) xs\"", "lemma set_insert_wrt [simp]: \"set (insert_wrt R x xs) = insert x (set xs)\"", "lemma mset_insert_wrt [simp]: \"mset (insert_wrt R x xs) = add_mset x (mset xs)\"", "lemma length_insert_wrt [simp]: \"length (insert_wrt R x xs) = Suc (length xs)\"", "lemma set_insort_wrt [simp]: \"set (insort_wrt R xs) = set xs\"", "lemma mset_insort_wrt [simp]: \"mset (insort_wrt R xs) = mset xs\"", "lemma length_insort_wrt [simp]: \"length (insort_wrt R xs) = length xs\"", "lemma sorted_wrt_insert_wrt [intro]: \n  \"linorder_on A R \\<Longrightarrow> set (x # xs) \\<subseteq> A \\<Longrightarrow> \n     sorted_wrt R xs \\<Longrightarrow> sorted_wrt R (insert_wrt R x xs)\"", "lemma sorted_wrt_insort [intro]:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\"\n  shows   \"sorted_wrt R (insort_wrt R xs)\"", "lemma distinct_insort_wrt [simp]: \"distinct (insort_wrt R xs) \\<longleftrightarrow> distinct xs\"", "lemma sorted_wrt_linorder_unique:\n  assumes \"linorder_on A R\" \"mset xs = mset ys\" \"sorted_wrt R xs\" \"sorted_wrt R ys\"\n  shows   \"xs = ys\"", "lemma mset_remdups: \"mset (remdups xs) = mset_set (set xs)\"", "lemma sorted_wrt_list_set:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\"\n  shows   \"sorted_wrt_list_of_set R (set xs) = insort_wrt R (remdups xs)\"", "lemma linorder_sorted_wrt_exists:\n  assumes \"linorder_on A R\" \"finite B\" \"B \\<subseteq> A\"\n  shows   \"\\<exists>xs. set xs = B \\<and> distinct xs \\<and> sorted_wrt R xs\"", "lemma linorder_sorted_wrt_list_of_set:\n  assumes \"linorder_on A R\" \"finite B\" \"B \\<subseteq> A\"\n  shows   \"set (sorted_wrt_list_of_set R B) = B\" \"distinct (sorted_wrt_list_of_set R B)\"\n          \"sorted_wrt R (sorted_wrt_list_of_set R B)\"", "lemma sorted_wrt_list_of_set_eqI:\n  assumes \"linorder_on B R\" \"A \\<subseteq> B\" \"set xs = A\" \"distinct xs\" \"sorted_wrt R xs\"\n  shows   \"sorted_wrt_list_of_set R A = xs\"", "lemma linorder_rank_le: \n  assumes \"finite A\"\n  shows   \"linorder_rank R A x \\<le> card A\"", "lemma linorder_rank_less:\n  assumes \"finite A\" \"x \\<in> A\"\n  shows   \"linorder_rank R A x < card A\"", "lemma linorder_rank_union:\n  assumes \"finite A\" \"finite B\" \"A \\<inter> B = {}\"\n  shows   \"linorder_rank R (A \\<union> B) x = linorder_rank R A x + linorder_rank R B x\"", "lemma linorder_rank_empty [simp]: \"linorder_rank R {} x = 0\"", "lemma linorder_rank_singleton: \n  \"linorder_rank R {y} x = (if x \\<noteq> y \\<and> (y,x) \\<in> R then 1 else 0)\"", "lemma linorder_rank_insert:\n  assumes \"finite A\" \"y \\<notin> A\"\n  shows   \"linorder_rank R (insert y A) x = \n             (if x \\<noteq> y \\<and> (y,x) \\<in> R then 1 else 0) + linorder_rank R A x\"", "lemma linorder_rank_mono:\n  assumes \"linorder_on B R\" \"finite A\" \"A \\<subseteq> B\" \"(x, y) \\<in> R\"\n  shows   \"linorder_rank R A x \\<le> linorder_rank R A y\"", "lemma linorder_rank_strict_mono:\n  assumes \"linorder_on B R\" \"finite A\" \"A \\<subseteq> B\" \"y \\<in> A\" \"(y, x) \\<in> R\" \"x \\<noteq> y\"\n  shows   \"linorder_rank R A y < linorder_rank R A x\"", "lemma linorder_rank_le_iff:\n  assumes \"linorder_on B R\" \"finite A\" \"A \\<subseteq> B\" \"x \\<in> A\" \"y \\<in> A\"\n  shows   \"linorder_rank R A x \\<le> linorder_rank R A y \\<longleftrightarrow> (x, y) \\<in> R\"", "lemma linorder_rank_eq_iff:\n  assumes \"linorder_on B R\" \"finite A\" \"A \\<subseteq> B\" \"x \\<in> A\" \"y \\<in> A\"\n  shows   \"linorder_rank R A x = linorder_rank R A y \\<longleftrightarrow> x = y\"", "lemma linorder_rank_set_sorted_wrt:\n  assumes \"linorder_on B R\" \"set xs \\<subseteq> B\" \"sorted_wrt R xs\" \"x \\<in> set xs\" \"distinct xs\"\n  shows   \"linorder_rank R (set xs) x = index xs x\"", "lemma bij_betw_linorder_rank:\n  assumes \"linorder_on B R\" \"finite A\" \"A \\<subseteq> B\"\n  shows   \"bij_betw (linorder_rank R A) A {..<card A}\"", "theorem bij_betw_linorder_of_list:\n  assumes \"finite A\"\n  shows   \"bij_betw linorder_of_list (permutations_of_set A) {R. linorder_on A R}\""], "translations": [["", "lemma distinct_count_atmost_1':\n  \"distinct xs = (\\<forall>a. count (mset xs) a \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs = (\\<forall>a. count (mset xs) a \\<le> 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct xs = (\\<forall>a. count (mset xs) a \\<le> 1)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct xs = (\\<forall>a. count (mset xs) a \\<le> 1)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct xs = (\\<forall>a. count (mset xs) a \\<le> 1)", "have \"count (mset xs) x = (if x \\<in> set xs then 1 else 0) \\<longleftrightarrow> count (mset xs) x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (count (mset xs) x = (if x \\<in> set xs then 1 else 0)) =\n    (count (mset xs) x \\<le> 1)", "using count_eq_zero_iff[of \"mset xs\" x]"], ["proof (prove)\nusing this:\n  (count (mset xs) x = 0) = (x \\<notin># mset xs)\n\ngoal (1 subgoal):\n 1. (count (mset xs) x = (if x \\<in> set xs then 1 else 0)) =\n    (count (mset xs) x \\<le> 1)", "by (cases \"count (mset xs) x\") (auto simp del: count_mset_0_iff)"], ["proof (state)\nthis:\n  (count (mset xs) x = (if x \\<in> set xs then 1 else 0)) =\n  (count (mset xs) x \\<le> 1)\n\ngoal (1 subgoal):\n 1. distinct xs = (\\<forall>a. count (mset xs) a \\<le> 1)", "}"], ["proof (state)\nthis:\n  (count (mset xs) ?x2 = (if ?x2 \\<in> set xs then 1 else 0)) =\n  (count (mset xs) ?x2 \\<le> 1)\n\ngoal (1 subgoal):\n 1. distinct xs = (\\<forall>a. count (mset xs) a \\<le> 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (count (mset xs) ?x2 = (if ?x2 \\<in> set xs then 1 else 0)) =\n  (count (mset xs) ?x2 \\<le> 1)\n\ngoal (1 subgoal):\n 1. distinct xs = (\\<forall>a. count (mset xs) a \\<le> 1)", "unfolding distinct_count_atmost_1"], ["proof (prove)\nusing this:\n  (count (mset xs) ?x2 = (if ?x2 \\<in> set xs then 1 else 0)) =\n  (count (mset xs) ?x2 \\<le> 1)\n\ngoal (1 subgoal):\n 1. (\\<forall>a. count (mset xs) a = (if a \\<in> set xs then 1 else 0)) =\n    (\\<forall>a. count (mset xs) a \\<le> 1)", "by blast"], ["proof (state)\nthis:\n  distinct xs = (\\<forall>a. count (mset xs) a \\<le> 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_mset_mono: \n  assumes \"distinct ys\" \"mset xs \\<subseteq># mset ys\"\n  shows   \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs", "unfolding distinct_count_atmost_1'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. count (mset xs) a \\<le> 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. count (mset xs) a \\<le> 1", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. count (mset xs) a \\<le> 1", "from assms(2)"], ["proof (chain)\npicking this:\n  mset xs \\<subseteq># mset ys", "have \"count (mset xs) x \\<le> count (mset ys) x\""], ["proof (prove)\nusing this:\n  mset xs \\<subseteq># mset ys\n\ngoal (1 subgoal):\n 1. count (mset xs) x \\<le> count (mset ys) x", "by (rule mset_subset_eq_count)"], ["proof (state)\nthis:\n  count (mset xs) x \\<le> count (mset ys) x\n\ngoal (1 subgoal):\n 1. \\<And>a. count (mset xs) a \\<le> 1", "also"], ["proof (state)\nthis:\n  count (mset xs) x \\<le> count (mset ys) x\n\ngoal (1 subgoal):\n 1. \\<And>a. count (mset xs) a \\<le> 1", "from assms(1)"], ["proof (chain)\npicking this:\n  distinct ys", "have \"\\<dots> \\<le> 1\""], ["proof (prove)\nusing this:\n  distinct ys\n\ngoal (1 subgoal):\n 1. count (mset ys) x \\<le> 1", "unfolding distinct_count_atmost_1'"], ["proof (prove)\nusing this:\n  \\<forall>a. count (mset ys) a \\<le> 1\n\ngoal (1 subgoal):\n 1. count (mset ys) x \\<le> 1", ".."], ["proof (state)\nthis:\n  count (mset ys) x \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>a. count (mset xs) a \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  count (mset xs) x \\<le> 1", "show \"count (mset xs) x \\<le> 1\""], ["proof (prove)\nusing this:\n  count (mset xs) x \\<le> 1\n\ngoal (1 subgoal):\n 1. count (mset xs) x \\<le> 1", "."], ["proof (state)\nthis:\n  count (mset xs) x \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_eq_imp_distinct_iff:\n  assumes \"mset xs = mset ys\"\n  shows   \"distinct xs \\<longleftrightarrow> distinct ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs = distinct ys", "using assms"], ["proof (prove)\nusing this:\n  mset xs = mset ys\n\ngoal (1 subgoal):\n 1. distinct xs = distinct ys", "by (simp add: distinct_count_atmost_1')"], ["", "lemma total_on_subset: \"total_on B R \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> total_on A R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>total_on B R; A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> total_on A R", "by (auto simp: total_on_def)"], ["", "subsection \\<open>Sortedness w.r.t. a relation\\<close>"], ["", "inductive sorted_wrt :: \"('a \\<times> 'a) set \\<Rightarrow> 'a list \\<Rightarrow> bool\" for R where\n  \"sorted_wrt R []\"\n| \"sorted_wrt R xs \\<Longrightarrow> (\\<And>y. y \\<in> set xs \\<Longrightarrow> (x,y) \\<in> R) \\<Longrightarrow> sorted_wrt R (x # xs)\""], ["", "lemma sorted_wrt_Nil [simp]: \"sorted_wrt R []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R []", "by (rule sorted_wrt.intros)"], ["", "lemma sorted_wrt_Cons: \"sorted_wrt R (x # xs) \\<longleftrightarrow> (\\<forall>y\\<in>set xs. (x,y) \\<in> R) \\<and> sorted_wrt R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (x # xs) =\n    ((\\<forall>y\\<in>set xs. (x, y) \\<in> R) \\<and>\n     Linorder_Relations.sorted_wrt R xs)", "by (auto intro: sorted_wrt.intros elim: sorted_wrt.cases)"], ["", "lemma sorted_wrt_singleton [simp]: \"sorted_wrt R [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R [x]", "by (intro sorted_wrt.intros) simp_all"], ["", "lemma sorted_wrt_many:\n  assumes \"trans R\"\n  shows   \"sorted_wrt R (x # y # xs) \\<longleftrightarrow> (x,y) \\<in> R \\<and> sorted_wrt R (y # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (x # y # xs) =\n    ((x, y) \\<in> R \\<and> Linorder_Relations.sorted_wrt R (y # xs))", "by (force intro: sorted_wrt.intros transD[OF assms] elim: sorted_wrt.cases)"], ["", "lemma sorted_wrt_imp_le_last:\n  assumes \"sorted_wrt R xs\" \"xs \\<noteq> []\" \"x \\<in> set xs\" \"x \\<noteq> last xs\"\n  shows   \"(x, last xs) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, last xs) \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  Linorder_Relations.sorted_wrt R xs\n  xs \\<noteq> []\n  x \\<in> set xs\n  x \\<noteq> last xs\n\ngoal (1 subgoal):\n 1. (x, last xs) \\<in> R", "by induction auto"], ["", "lemma sorted_wrt_append:\n  assumes \"sorted_wrt R xs\" \"sorted_wrt R ys\" \n          \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> (x,y) \\<in> R\" \"trans R\"\n  shows   \"sorted_wrt R (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (xs @ ys)", "using assms"], ["proof (prove)\nusing this:\n  Linorder_Relations.sorted_wrt R xs\n  Linorder_Relations.sorted_wrt R ys\n  \\<lbrakk>?x \\<in> set xs; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> R\n  trans R\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (xs @ ys)", "by (induction xs) (auto simp: sorted_wrt_Cons)"], ["", "lemma sorted_wrt_snoc:\n  assumes \"sorted_wrt R xs\" \"(last xs, y) \\<in> R\" \"trans R\"\n  shows   \"sorted_wrt R (xs @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (xs @ [y])", "using assms(1,2)"], ["proof (prove)\nusing this:\n  Linorder_Relations.sorted_wrt R xs\n  (last xs, y) \\<in> R\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (xs @ [y])", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. (last [], y) \\<in> R \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ([] @ [y])\n 2. \\<And>xs x.\n       \\<lbrakk>Linorder_Relations.sorted_wrt R xs;\n        (last xs, y) \\<in> R \\<Longrightarrow>\n        Linorder_Relations.sorted_wrt R (xs @ [y]);\n        \\<And>y. y \\<in> set xs \\<Longrightarrow> (x, y) \\<in> R;\n        (last (x # xs), y) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "case (2 xs x)"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R xs\n  ?y \\<in> set xs \\<Longrightarrow> (x, ?y) \\<in> R\n  (last xs, y) \\<in> R \\<Longrightarrow>\n  Linorder_Relations.sorted_wrt R (xs @ [y])\n  (last (x # xs), y) \\<in> R\n\ngoal (2 subgoals):\n 1. (last [], y) \\<in> R \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ([] @ [y])\n 2. \\<And>xs x.\n       \\<lbrakk>Linorder_Relations.sorted_wrt R xs;\n        (last xs, y) \\<in> R \\<Longrightarrow>\n        Linorder_Relations.sorted_wrt R (xs @ [y]);\n        \\<And>y. y \\<in> set xs \\<Longrightarrow> (x, y) \\<in> R;\n        (last (x # xs), y) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "with 2"], ["proof (chain)\npicking this:\n  Linorder_Relations.sorted_wrt R xs\n  ?y \\<in> set xs \\<Longrightarrow> (x, ?y) \\<in> R\n  (last xs, y) \\<in> R \\<Longrightarrow>\n  Linorder_Relations.sorted_wrt R (xs @ [y])\n  (last (x # xs), y) \\<in> R\n  xs \\<noteq> []", "have \"(z,y) \\<in> R\" if \"z \\<in> set xs\" for z"], ["proof (prove)\nusing this:\n  Linorder_Relations.sorted_wrt R xs\n  ?y \\<in> set xs \\<Longrightarrow> (x, ?y) \\<in> R\n  (last xs, y) \\<in> R \\<Longrightarrow>\n  Linorder_Relations.sorted_wrt R (xs @ [y])\n  (last (x # xs), y) \\<in> R\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (z, y) \\<in> R", "using that"], ["proof (prove)\nusing this:\n  Linorder_Relations.sorted_wrt R xs\n  ?y \\<in> set xs \\<Longrightarrow> (x, ?y) \\<in> R\n  (last xs, y) \\<in> R \\<Longrightarrow>\n  Linorder_Relations.sorted_wrt R (xs @ [y])\n  (last (x # xs), y) \\<in> R\n  xs \\<noteq> []\n  z \\<in> set xs\n\ngoal (1 subgoal):\n 1. (z, y) \\<in> R", "by (cases \"z = last xs\")\n                    (auto intro: assms transD[OF assms(3), OF sorted_wrt_imp_le_last[OF 2(1)]])"], ["proof (state)\nthis:\n  ?z \\<in> set xs \\<Longrightarrow> (?z, y) \\<in> R\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "from False"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "have *: \"last xs \\<in> set xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. last xs \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  last xs \\<in> set xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "moreover"], ["proof (state)\nthis:\n  last xs \\<in> set xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "from 2 False"], ["proof (chain)\npicking this:\n  Linorder_Relations.sorted_wrt R xs\n  ?y \\<in> set xs \\<Longrightarrow> (x, ?y) \\<in> R\n  (last xs, y) \\<in> R \\<Longrightarrow>\n  Linorder_Relations.sorted_wrt R (xs @ [y])\n  (last (x # xs), y) \\<in> R\n  xs \\<noteq> []", "have \"(x,y) \\<in> R\""], ["proof (prove)\nusing this:\n  Linorder_Relations.sorted_wrt R xs\n  ?y \\<in> set xs \\<Longrightarrow> (x, ?y) \\<in> R\n  (last xs, y) \\<in> R \\<Longrightarrow>\n  Linorder_Relations.sorted_wrt R (xs @ [y])\n  (last (x # xs), y) \\<in> R\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> R", "by (intro transD[OF assms(3) 2(2)[OF *]]) simp"], ["proof (state)\nthis:\n  (x, y) \\<in> R\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "ultimately"], ["proof (chain)\npicking this:\n  last xs \\<in> set xs\n  (x, y) \\<in> R", "show ?thesis"], ["proof (prove)\nusing this:\n  last xs \\<in> set xs\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "using 2 False"], ["proof (prove)\nusing this:\n  last xs \\<in> set xs\n  (x, y) \\<in> R\n  Linorder_Relations.sorted_wrt R xs\n  ?y \\<in> set xs \\<Longrightarrow> (x, ?y) \\<in> R\n  (last xs, y) \\<in> R \\<Longrightarrow>\n  Linorder_Relations.sorted_wrt R (xs @ [y])\n  (last (x # xs), y) \\<in> R\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "by (auto intro!: sorted_wrt.intros)"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R ((x # xs) @ [y])\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ((x # xs) @ [y])", "qed (insert 2, auto intro: sorted_wrt.intros)"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R ((x # xs) @ [y])\n\ngoal (1 subgoal):\n 1. (last [], y) \\<in> R \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ([] @ [y])", "qed simp_all"], ["", "lemma sorted_wrt_conv_nth:\n  \"sorted_wrt R xs \\<longleftrightarrow> (\\<forall>i j. i < j \\<and> j < length xs \\<longrightarrow> (xs!i, xs!j) \\<in> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R xs =\n    (\\<forall>i j.\n        i < j \\<and> j < length xs \\<longrightarrow>\n        (xs ! i, xs ! j) \\<in> R)", "by (induction xs) (auto simp: sorted_wrt_Cons nth_Cons set_conv_nth split: nat.splits)"], ["", "subsection \\<open>Linear orderings\\<close>"], ["", "definition linorder_on :: \"'a set \\<Rightarrow> ('a \\<times> 'a) set \\<Rightarrow> bool\"  where\n  \"linorder_on A R \\<longleftrightarrow> refl_on A R \\<and> antisym R \\<and> trans R \\<and> total_on A R\""], ["", "lemma linorder_on_cases:\n  assumes \"linorder_on A R\" \"x \\<in> A\" \"y \\<in> A\"\n  shows   \"x = y \\<or> ((x, y) \\<in> R \\<and> (y, x) \\<notin> R) \\<or> ((y, x) \\<in> R \\<and> (x, y) \\<notin> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<or>\n    (x, y) \\<in> R \\<and> (y, x) \\<notin> R \\<or>\n    (y, x) \\<in> R \\<and> (x, y) \\<notin> R", "using assms"], ["proof (prove)\nusing this:\n  linorder_on A R\n  x \\<in> A\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. x = y \\<or>\n    (x, y) \\<in> R \\<and> (y, x) \\<notin> R \\<or>\n    (y, x) \\<in> R \\<and> (x, y) \\<notin> R", "by (auto simp: linorder_on_def refl_on_def total_on_def antisym_def)"], ["", "lemma sorted_wrt_linorder_imp_index_le:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\" \"sorted_wrt R xs\" \n          \"x \\<in> set xs\" \"y \\<in> set xs\" \"(x,y) \\<in> R\"\n  shows   \"index xs x \\<le> index xs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "define i j where \"i = index xs x\" and \"j = index xs y\""], ["proof (state)\nthis:\n  i = index xs x\n  j = index xs y\n\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "{"], ["proof (state)\nthis:\n  i = index xs x\n  j = index xs y\n\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "assume \"j < i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "moreover"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "from assms"], ["proof (chain)\npicking this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  y \\<in> set xs\n  (x, y) \\<in> R", "have \"i < length xs\""], ["proof (prove)\nusing this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  y \\<in> set xs\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. i < length xs", "by (simp add: i_def)"], ["proof (state)\nthis:\n  i < length xs\n\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "ultimately"], ["proof (chain)\npicking this:\n  j < i\n  i < length xs", "have \"(xs!j,xs!i) \\<in> R\""], ["proof (prove)\nusing this:\n  j < i\n  i < length xs\n\ngoal (1 subgoal):\n 1. (xs ! j, xs ! i) \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  j < i\n  i < length xs\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  y \\<in> set xs\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. (xs ! j, xs ! i) \\<in> R", "by (auto simp: sorted_wrt_conv_nth)"], ["proof (state)\nthis:\n  (xs ! j, xs ! i) \\<in> R\n\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "with assms"], ["proof (chain)\npicking this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  y \\<in> set xs\n  (x, y) \\<in> R\n  (xs ! j, xs ! i) \\<in> R", "have \"x = y\""], ["proof (prove)\nusing this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  y \\<in> set xs\n  (x, y) \\<in> R\n  (xs ! j, xs ! i) \\<in> R\n\ngoal (1 subgoal):\n 1. x = y", "by (auto simp: linorder_on_def antisym_def i_def j_def)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "}"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "hence \"i \\<le> j \\<or> x = y\""], ["proof (prove)\nusing this:\n  j < i \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<or> x = y", "by linarith"], ["proof (state)\nthis:\n  i \\<le> j \\<or> x = y\n\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> j \\<or> x = y\n\ngoal (1 subgoal):\n 1. index xs x \\<le> index xs y", "by (auto simp: i_def j_def)"], ["proof (state)\nthis:\n  index xs x \\<le> index xs y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_wrt_linorder_index_le_imp:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\" \"sorted_wrt R xs\" \n          \"x \\<in> set xs\" \"y \\<in> set xs\" \"index xs x \\<le> index xs y\"\n  shows   \"(x,y) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> R", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (x, y) \\<in> R\n 2. x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> R", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (x, y) \\<in> R\n 2. x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> R", "define i j where \"i = index xs x\" and \"j = index xs y\""], ["proof (state)\nthis:\n  i = index xs x\n  j = index xs y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (x, y) \\<in> R\n 2. x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> R", "from False and assms"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  y \\<in> set xs\n  index xs x \\<le> index xs y", "have \"i \\<noteq> j\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  y \\<in> set xs\n  index xs x \\<le> index xs y\n\ngoal (1 subgoal):\n 1. i \\<noteq> j", "by (simp add: i_def j_def)"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (x, y) \\<in> R\n 2. x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> R", "with \\<open>index xs x \\<le> index xs y\\<close>"], ["proof (chain)\npicking this:\n  index xs x \\<le> index xs y\n  i \\<noteq> j", "have \"i < j\""], ["proof (prove)\nusing this:\n  index xs x \\<le> index xs y\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i < j", "by (simp add: i_def j_def)"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (x, y) \\<in> R\n 2. x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> R", "moreover"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (x, y) \\<in> R\n 2. x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> R", "from assms"], ["proof (chain)\npicking this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  y \\<in> set xs\n  index xs x \\<le> index xs y", "have \"j < length xs\""], ["proof (prove)\nusing this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  y \\<in> set xs\n  index xs x \\<le> index xs y\n\ngoal (1 subgoal):\n 1. j < length xs", "by (simp add: j_def)"], ["proof (state)\nthis:\n  j < length xs\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (x, y) \\<in> R\n 2. x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> R", "ultimately"], ["proof (chain)\npicking this:\n  i < j\n  j < length xs", "have \"(xs ! i, xs ! j) \\<in> R\""], ["proof (prove)\nusing this:\n  i < j\n  j < length xs\n\ngoal (1 subgoal):\n 1. (xs ! i, xs ! j) \\<in> R", "using assms(3)"], ["proof (prove)\nusing this:\n  i < j\n  j < length xs\n  Linorder_Relations.sorted_wrt R xs\n\ngoal (1 subgoal):\n 1. (xs ! i, xs ! j) \\<in> R", "by (auto simp: sorted_wrt_conv_nth)"], ["proof (state)\nthis:\n  (xs ! i, xs ! j) \\<in> R\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (x, y) \\<in> R\n 2. x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> R", "with assms"], ["proof (chain)\npicking this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  y \\<in> set xs\n  index xs x \\<le> index xs y\n  (xs ! i, xs ! j) \\<in> R", "show ?thesis"], ["proof (prove)\nusing this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  y \\<in> set xs\n  index xs x \\<le> index xs y\n  (xs ! i, xs ! j) \\<in> R\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> R", "by (simp_all add: i_def j_def)"], ["proof (state)\nthis:\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> (x, y) \\<in> R", "qed (insert assms, auto simp: linorder_on_def refl_on_def)"], ["", "lemma sorted_wrt_linorder_index_le_iff:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\" \"sorted_wrt R xs\" \n          \"x \\<in> set xs\" \"y \\<in> set xs\"\n  shows   \"index xs x \\<le> index xs y \\<longleftrightarrow> (x,y) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index xs x \\<le> index xs y) = ((x, y) \\<in> R)", "using sorted_wrt_linorder_index_le_imp[OF assms] sorted_wrt_linorder_imp_index_le[OF assms]"], ["proof (prove)\nusing this:\n  index xs x \\<le> index xs y \\<Longrightarrow> (x, y) \\<in> R\n  (x, y) \\<in> R \\<Longrightarrow> index xs x \\<le> index xs y\n\ngoal (1 subgoal):\n 1. (index xs x \\<le> index xs y) = ((x, y) \\<in> R)", "by blast"], ["", "lemma sorted_wrt_linorder_index_less_iff:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\" \"sorted_wrt R xs\" \n          \"x \\<in> set xs\" \"y \\<in> set xs\"\n  shows   \"index xs x < index xs y \\<longleftrightarrow> (y,x) \\<notin> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index xs x < index xs y) = ((y, x) \\<notin> R)", "by (subst sorted_wrt_linorder_index_le_iff[OF assms(1-3) assms(5,4), symmetric]) auto"], ["", "lemma sorted_wrt_distinct_linorder_nth:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\" \"sorted_wrt R xs\" \"distinct xs\" \n          \"i < length xs\" \"j < length xs\"\n  shows   \"(xs!i, xs!j) \\<in> R \\<longleftrightarrow> i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "proof (cases i j rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. i < j \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n 2. i = j \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n 3. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "case less"], ["proof (state)\nthis:\n  i < j\n\ngoal (3 subgoals):\n 1. i < j \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n 2. i = j \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n 3. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "with assms"], ["proof (chain)\npicking this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  distinct xs\n  i < length xs\n  j < length xs\n  i < j", "show ?thesis"], ["proof (prove)\nusing this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  distinct xs\n  i < length xs\n  j < length xs\n  i < j\n\ngoal (1 subgoal):\n 1. ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "by (simp add: sorted_wrt_conv_nth)"], ["proof (state)\nthis:\n  ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n 2. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n 2. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "case equal"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n 2. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "from assms"], ["proof (chain)\npicking this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  distinct xs\n  i < length xs\n  j < length xs", "have \"xs ! i \\<in> set xs\" \"xs ! j \\<in> set xs\""], ["proof (prove)\nusing this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  distinct xs\n  i < length xs\n  j < length xs\n\ngoal (1 subgoal):\n 1. xs ! i \\<in> set xs &&& xs ! j \\<in> set xs", "by (auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  xs ! i \\<in> set xs\n  xs ! j \\<in> set xs\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n 2. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "with assms(2)"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> A\n  xs ! i \\<in> set xs\n  xs ! j \\<in> set xs", "have \"xs ! i \\<in> A\" \"xs ! j \\<in> A\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> A\n  xs ! i \\<in> set xs\n  xs ! j \\<in> set xs\n\ngoal (1 subgoal):\n 1. xs ! i \\<in> A &&& xs ! j \\<in> A", "by blast+"], ["proof (state)\nthis:\n  xs ! i \\<in> A\n  xs ! j \\<in> A\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n 2. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "with \\<open>linorder_on A R\\<close> and equal"], ["proof (chain)\npicking this:\n  linorder_on A R\n  i = j\n  xs ! i \\<in> A\n  xs ! j \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  linorder_on A R\n  i = j\n  xs ! i \\<in> A\n  xs ! j \\<in> A\n\ngoal (1 subgoal):\n 1. ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "by (simp add: linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "case greater"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "with assms"], ["proof (chain)\npicking this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  distinct xs\n  i < length xs\n  j < length xs\n  j < i", "have \"(xs!j, xs!i) \\<in> R\""], ["proof (prove)\nusing this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  distinct xs\n  i < length xs\n  j < length xs\n  j < i\n\ngoal (1 subgoal):\n 1. (xs ! j, xs ! i) \\<in> R", "by (auto simp add: sorted_wrt_conv_nth)"], ["proof (state)\nthis:\n  (xs ! j, xs ! i) \\<in> R\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "moreover"], ["proof (state)\nthis:\n  (xs ! j, xs ! i) \\<in> R\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "from assms and greater"], ["proof (chain)\npicking this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  distinct xs\n  i < length xs\n  j < length xs\n  j < i", "have \"xs ! i \\<noteq> xs ! j\""], ["proof (prove)\nusing this:\n  linorder_on A R\n  set xs \\<subseteq> A\n  Linorder_Relations.sorted_wrt R xs\n  distinct xs\n  i < length xs\n  j < length xs\n  j < i\n\ngoal (1 subgoal):\n 1. xs ! i \\<noteq> xs ! j", "by (simp add: nth_eq_iff_index_eq)"], ["proof (state)\nthis:\n  xs ! i \\<noteq> xs ! j\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow> ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "ultimately"], ["proof (chain)\npicking this:\n  (xs ! j, xs ! i) \\<in> R\n  xs ! i \\<noteq> xs ! j", "show ?thesis"], ["proof (prove)\nusing this:\n  (xs ! j, xs ! i) \\<in> R\n  xs ! i \\<noteq> xs ! j\n\ngoal (1 subgoal):\n 1. ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "using \\<open>linorder_on A R\\<close> greater"], ["proof (prove)\nusing this:\n  (xs ! j, xs ! i) \\<in> R\n  xs ! i \\<noteq> xs ! j\n  linorder_on A R\n  j < i\n\ngoal (1 subgoal):\n 1. ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)", "by (auto simp: linorder_on_def antisym_def)"], ["proof (state)\nthis:\n  ((xs ! i, xs ! j) \\<in> R) = (i \\<le> j)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Converting a list into a linear ordering\\<close>"], ["", "definition linorder_of_list :: \"'a list \\<Rightarrow> ('a \\<times> 'a) set\" where\n  \"linorder_of_list xs = {(a,b). a \\<in> set xs \\<and> b \\<in> set xs \\<and> index xs a \\<le> index xs b}\""], ["", "lemma linorder_linorder_of_list [intro, simp]:\n  assumes \"distinct xs\"\n  shows   \"linorder_on (set xs) (linorder_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_on (set xs) (linorder_of_list xs)", "unfolding linorder_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on (set xs) (linorder_of_list xs) \\<and>\n    antisym (linorder_of_list xs) \\<and>\n    trans (linorder_of_list xs) \\<and>\n    total_on (set xs) (linorder_of_list xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. refl_on (set xs) (linorder_of_list xs) \\<and>\n    antisym (linorder_of_list xs) \\<and>\n    trans (linorder_of_list xs) \\<and>\n    total_on (set xs) (linorder_of_list xs)", "by (auto simp: refl_on_def antisym_def trans_def total_on_def linorder_of_list_def)"], ["", "lemma sorted_wrt_linorder_of_list [intro, simp]: \n  \"distinct xs \\<Longrightarrow> sorted_wrt (linorder_of_list xs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt (linorder_of_list xs) xs", "by (auto simp: sorted_wrt_conv_nth linorder_of_list_def index_nth_id)"], ["", "subsection \\<open>Insertion sort\\<close>"], ["", "primrec insert_wrt :: \"('a \\<times> 'a) set \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"insert_wrt R x [] = [x]\"\n| \"insert_wrt R x (y # ys) = (if (x, y) \\<in> R then x # y # ys else y # insert_wrt R x ys)\""], ["", "lemma set_insert_wrt [simp]: \"set (insert_wrt R x xs) = insert x (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insert_wrt R x xs) = insert x (set xs)", "by (induction xs) auto"], ["", "lemma mset_insert_wrt [simp]: \"mset (insert_wrt R x xs) = add_mset x (mset xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (insert_wrt R x xs) = add_mset x (mset xs)", "by (induction xs) auto"], ["", "lemma length_insert_wrt [simp]: \"length (insert_wrt R x xs) = Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (insert_wrt R x xs) = Suc (length xs)", "by (induction xs) simp_all"], ["", "definition insort_wrt :: \"('a \\<times> 'a) set \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"insort_wrt R xs = foldr (insert_wrt R) xs []\""], ["", "lemma set_insort_wrt [simp]: \"set (insort_wrt R xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insort_wrt R xs) = set xs", "by (induction xs) (simp_all add: insort_wrt_def)"], ["", "lemma mset_insort_wrt [simp]: \"mset (insort_wrt R xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (insort_wrt R xs) = mset xs", "by (induction xs) (simp_all add: insort_wrt_def)"], ["", "lemma length_insort_wrt [simp]: \"length (insort_wrt R xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (insort_wrt R xs) = length xs", "by (induction xs) (simp_all add: insort_wrt_def)"], ["", "lemma sorted_wrt_insert_wrt [intro]: \n  \"linorder_on A R \\<Longrightarrow> set (x # xs) \\<subseteq> A \\<Longrightarrow> \n     sorted_wrt R xs \\<Longrightarrow> sorted_wrt R (insert_wrt R x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>linorder_on A R; set (x # xs) \\<subseteq> A;\n     Linorder_Relations.sorted_wrt R xs\\<rbrakk>\n    \\<Longrightarrow> Linorder_Relations.sorted_wrt R (insert_wrt R x xs)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>linorder_on A R; set [x] \\<subseteq> A;\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> Linorder_Relations.sorted_wrt R (insert_wrt R x [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>linorder_on A R; set (x # xs) \\<subseteq> A;\n                 Linorder_Relations.sorted_wrt R xs\\<rbrakk>\n                \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                                   (insert_wrt R x xs);\n        linorder_on A R; set (x # a # xs) \\<subseteq> A;\n        Linorder_Relations.sorted_wrt R (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                          (insert_wrt R x (a # xs))", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>linorder_on A R; set (x # ys) \\<subseteq> A;\n   Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n  \\<Longrightarrow> Linorder_Relations.sorted_wrt R (insert_wrt R x ys)\n  linorder_on A R\n  set (x # y # ys) \\<subseteq> A\n  Linorder_Relations.sorted_wrt R (y # ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>linorder_on A R; set [x] \\<subseteq> A;\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> Linorder_Relations.sorted_wrt R (insert_wrt R x [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>linorder_on A R; set (x # xs) \\<subseteq> A;\n                 Linorder_Relations.sorted_wrt R xs\\<rbrakk>\n                \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                                   (insert_wrt R x xs);\n        linorder_on A R; set (x # a # xs) \\<subseteq> A;\n        Linorder_Relations.sorted_wrt R (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                          (insert_wrt R x (a # xs))", "from Cons.prems"], ["proof (chain)\npicking this:\n  linorder_on A R\n  set (x # y # ys) \\<subseteq> A\n  Linorder_Relations.sorted_wrt R (y # ys)", "have \"(x,y) \\<in> R \\<or> (y,x) \\<in> R\""], ["proof (prove)\nusing this:\n  linorder_on A R\n  set (x # y # ys) \\<subseteq> A\n  Linorder_Relations.sorted_wrt R (y # ys)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> R \\<or> (y, x) \\<in> R", "by (cases \"x = y\") (auto simp: linorder_on_def refl_on_def total_on_def)"], ["proof (state)\nthis:\n  (x, y) \\<in> R \\<or> (y, x) \\<in> R\n\ngoal (2 subgoals):\n 1. \\<lbrakk>linorder_on A R; set [x] \\<subseteq> A;\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> Linorder_Relations.sorted_wrt R (insert_wrt R x [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>linorder_on A R; set (x # xs) \\<subseteq> A;\n                 Linorder_Relations.sorted_wrt R xs\\<rbrakk>\n                \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                                   (insert_wrt R x xs);\n        linorder_on A R; set (x # a # xs) \\<subseteq> A;\n        Linorder_Relations.sorted_wrt R (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                          (insert_wrt R x (a # xs))", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>linorder_on A R; set (x # ys) \\<subseteq> A;\n   Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n  \\<Longrightarrow> Linorder_Relations.sorted_wrt R (insert_wrt R x ys)\n  linorder_on A R\n  set (x # y # ys) \\<subseteq> A\n  Linorder_Relations.sorted_wrt R (y # ys)\n  (x, y) \\<in> R \\<or> (y, x) \\<in> R", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>linorder_on A R; set (x # ys) \\<subseteq> A;\n   Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n  \\<Longrightarrow> Linorder_Relations.sorted_wrt R (insert_wrt R x ys)\n  linorder_on A R\n  set (x # y # ys) \\<subseteq> A\n  Linorder_Relations.sorted_wrt R (y # ys)\n  (x, y) \\<in> R \\<or> (y, x) \\<in> R\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (insert_wrt R x (y # ys))", "by (auto simp: sorted_wrt_Cons intro: transD simp: linorder_on_def)"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R (insert_wrt R x (y # ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>linorder_on A R; set [x] \\<subseteq> A;\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> Linorder_Relations.sorted_wrt R (insert_wrt R x [])", "qed auto"], ["", "lemma sorted_wrt_insort [intro]:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\"\n  shows   \"sorted_wrt R (insort_wrt R xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (insort_wrt R xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (insort_wrt R xs)", "from assms"], ["proof (chain)\npicking this:\n  linorder_on A R\n  set xs \\<subseteq> A", "have \"set (insort_wrt R xs) = set xs \\<and> sorted_wrt R (insort_wrt R xs)\""], ["proof (prove)\nusing this:\n  linorder_on A R\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. set (insort_wrt R xs) = set xs \\<and>\n    Linorder_Relations.sorted_wrt R (insort_wrt R xs)", "by (induction xs) (auto simp: insort_wrt_def intro!: sorted_wrt_insert_wrt)"], ["proof (state)\nthis:\n  set (insort_wrt R xs) = set xs \\<and>\n  Linorder_Relations.sorted_wrt R (insort_wrt R xs)\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (insort_wrt R xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (insort_wrt R xs) = set xs \\<and>\n  Linorder_Relations.sorted_wrt R (insort_wrt R xs)\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (insort_wrt R xs)", ".."], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R (insort_wrt R xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_insort_wrt [simp]: \"distinct (insort_wrt R xs) \\<longleftrightarrow> distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (insort_wrt R xs) = distinct xs", "by (simp add: distinct_count_atmost_1)"], ["", "lemma sorted_wrt_linorder_unique:\n  assumes \"linorder_on A R\" \"mset xs = mset ys\" \"sorted_wrt R xs\" \"sorted_wrt R ys\"\n  shows   \"xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = ys", "from \\<open>mset xs = mset ys\\<close>"], ["proof (chain)\npicking this:\n  mset xs = mset ys", "have \"length xs = length ys\""], ["proof (prove)\nusing this:\n  mset xs = mset ys\n\ngoal (1 subgoal):\n 1. length xs = length ys", "by (rule mset_eq_length)"], ["proof (state)\nthis:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. xs = ys", "from this and assms(2-)"], ["proof (chain)\npicking this:\n  length xs = length ys\n  mset xs = mset ys\n  Linorder_Relations.sorted_wrt R xs\n  Linorder_Relations.sorted_wrt R ys", "show ?thesis"], ["proof (prove)\nusing this:\n  length xs = length ys\n  mset xs = mset ys\n  Linorder_Relations.sorted_wrt R xs\n  Linorder_Relations.sorted_wrt R ys\n\ngoal (1 subgoal):\n 1. xs = ys", "proof (induction xs ys rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mset [] = mset []; Linorder_Relations.sorted_wrt R [];\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n         Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        mset (x # xs) = mset (y # ys);\n        Linorder_Relations.sorted_wrt R (x # xs);\n        Linorder_Relations.sorted_wrt R (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n   Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  mset (x # xs) = mset (y # ys)\n  Linorder_Relations.sorted_wrt R (x # xs)\n  Linorder_Relations.sorted_wrt R (y # ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mset [] = mset []; Linorder_Relations.sorted_wrt R [];\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n         Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        mset (x # xs) = mset (y # ys);\n        Linorder_Relations.sorted_wrt R (x # xs);\n        Linorder_Relations.sorted_wrt R (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "have \"set (x # xs) = set_mset (mset (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (x # xs) = set_mset (mset (x # xs))", "by simp"], ["proof (state)\nthis:\n  set (x # xs) = set_mset (mset (x # xs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mset [] = mset []; Linorder_Relations.sorted_wrt R [];\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n         Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        mset (x # xs) = mset (y # ys);\n        Linorder_Relations.sorted_wrt R (x # xs);\n        Linorder_Relations.sorted_wrt R (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "also"], ["proof (state)\nthis:\n  set (x # xs) = set_mset (mset (x # xs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mset [] = mset []; Linorder_Relations.sorted_wrt R [];\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n         Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        mset (x # xs) = mset (y # ys);\n        Linorder_Relations.sorted_wrt R (x # xs);\n        Linorder_Relations.sorted_wrt R (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "have \"mset (x # xs) = mset (y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (x # xs) = mset (y # ys)", "by fact"], ["proof (state)\nthis:\n  mset (x # xs) = mset (y # ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mset [] = mset []; Linorder_Relations.sorted_wrt R [];\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n         Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        mset (x # xs) = mset (y # ys);\n        Linorder_Relations.sorted_wrt R (x # xs);\n        Linorder_Relations.sorted_wrt R (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "also"], ["proof (state)\nthis:\n  mset (x # xs) = mset (y # ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mset [] = mset []; Linorder_Relations.sorted_wrt R [];\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n         Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        mset (x # xs) = mset (y # ys);\n        Linorder_Relations.sorted_wrt R (x # xs);\n        Linorder_Relations.sorted_wrt R (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "have \"set_mset \\<dots> = set (y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (mset (y # ys)) = set (y # ys)", "by simp"], ["proof (state)\nthis:\n  set_mset (mset (y # ys)) = set (y # ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mset [] = mset []; Linorder_Relations.sorted_wrt R [];\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n         Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        mset (x # xs) = mset (y # ys);\n        Linorder_Relations.sorted_wrt R (x # xs);\n        Linorder_Relations.sorted_wrt R (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "finally"], ["proof (chain)\npicking this:\n  set (x # xs) = set (y # ys)", "have eq: \"set (x # xs) = set (y # ys)\""], ["proof (prove)\nusing this:\n  set (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. set (x # xs) = set (y # ys)", "."], ["proof (state)\nthis:\n  set (x # xs) = set (y # ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mset [] = mset []; Linorder_Relations.sorted_wrt R [];\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n         Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        mset (x # xs) = mset (y # ys);\n        Linorder_Relations.sorted_wrt R (x # xs);\n        Linorder_Relations.sorted_wrt R (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "have \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "with eq"], ["proof (chain)\npicking this:\n  set (x # xs) = set (y # ys)\n  x \\<noteq> y", "have \"x \\<in> set ys\" \"y \\<in> set xs\""], ["proof (prove)\nusing this:\n  set (x # xs) = set (y # ys)\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<in> set ys &&& y \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  x \\<in> set ys\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "with Cons.prems and assms(1) and eq"], ["proof (chain)\npicking this:\n  mset (x # xs) = mset (y # ys)\n  Linorder_Relations.sorted_wrt R (x # xs)\n  Linorder_Relations.sorted_wrt R (y # ys)\n  linorder_on A R\n  set (x # xs) = set (y # ys)\n  x \\<in> set ys\n  y \\<in> set xs", "have \"(x, y) \\<in> R\" \"(y, x) \\<in> R\""], ["proof (prove)\nusing this:\n  mset (x # xs) = mset (y # ys)\n  Linorder_Relations.sorted_wrt R (x # xs)\n  Linorder_Relations.sorted_wrt R (y # ys)\n  linorder_on A R\n  set (x # xs) = set (y # ys)\n  x \\<in> set ys\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> R &&& (y, x) \\<in> R", "by (auto simp: sorted_wrt_Cons)"], ["proof (state)\nthis:\n  (x, y) \\<in> R\n  (y, x) \\<in> R\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "with assms(1)"], ["proof (chain)\npicking this:\n  linorder_on A R\n  (x, y) \\<in> R\n  (y, x) \\<in> R", "have \"x = y\""], ["proof (prove)\nusing this:\n  linorder_on A R\n  (x, y) \\<in> R\n  (y, x) \\<in> R\n\ngoal (1 subgoal):\n 1. x = y", "by (auto simp: linorder_on_def antisym_def)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "with \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x = y", "show False"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x = y\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mset [] = mset []; Linorder_Relations.sorted_wrt R [];\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n         Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        mset (x # xs) = mset (y # ys);\n        Linorder_Relations.sorted_wrt R (x # xs);\n        Linorder_Relations.sorted_wrt R (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "with Cons"], ["proof (chain)\npicking this:\n  length xs = length ys\n  \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n   Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  mset (x # xs) = mset (y # ys)\n  Linorder_Relations.sorted_wrt R (x # xs)\n  Linorder_Relations.sorted_wrt R (y # ys)\n  x = y", "show ?case"], ["proof (prove)\nusing this:\n  length xs = length ys\n  \\<lbrakk>mset xs = mset ys; Linorder_Relations.sorted_wrt R xs;\n   Linorder_Relations.sorted_wrt R ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  mset (x # xs) = mset (y # ys)\n  Linorder_Relations.sorted_wrt R (x # xs)\n  Linorder_Relations.sorted_wrt R (y # ys)\n  x = y\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "by (auto simp: sorted_wrt_Cons)"], ["proof (state)\nthis:\n  x # xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mset [] = mset []; Linorder_Relations.sorted_wrt R [];\n     Linorder_Relations.sorted_wrt R []\\<rbrakk>\n    \\<Longrightarrow> [] = []", "qed auto"], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Obtaining a sorted list of a given set\\<close>"], ["", "definition sorted_wrt_list_of_set where\n  \"sorted_wrt_list_of_set R A = \n     (if finite A then (THE xs. set xs = A \\<and> distinct xs \\<and> sorted_wrt R xs) else [])\""], ["", "lemma mset_remdups: \"mset (remdups xs) = mset_set (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (remdups xs) = mset_set (set xs)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. mset (remdups []) = mset_set (set [])\n 2. \\<And>a xs.\n       mset (remdups xs) = mset_set (set xs) \\<Longrightarrow>\n       mset (remdups (a # xs)) = mset_set (set (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  mset (remdups xs) = mset_set (set xs)\n\ngoal (2 subgoals):\n 1. mset (remdups []) = mset_set (set [])\n 2. \\<And>a xs.\n       mset (remdups xs) = mset_set (set xs) \\<Longrightarrow>\n       mset (remdups (a # xs)) = mset_set (set (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  mset (remdups xs) = mset_set (set xs)\n\ngoal (1 subgoal):\n 1. mset (remdups (x # xs)) = mset_set (set (x # xs))", "by (cases \"x \\<in> set xs\") (auto simp: insert_absorb)"], ["proof (state)\nthis:\n  mset (remdups (x # xs)) = mset_set (set (x # xs))\n\ngoal (1 subgoal):\n 1. mset (remdups []) = mset_set (set [])", "qed auto"], ["", "lemma sorted_wrt_list_set:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\"\n  shows   \"sorted_wrt_list_of_set R (set xs) = insort_wrt R (remdups xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt_list_of_set R (set xs) = insort_wrt R (remdups xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt_list_of_set R (set xs) = insort_wrt R (remdups xs)", "have \"sorted_wrt_list_of_set R (set xs) = \n          (THE xsa. set xsa = set xs \\<and> distinct xsa \\<and> sorted_wrt R xsa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt_list_of_set R (set xs) =\n    (THE xsa.\n        set xsa = set xs \\<and>\n        distinct xsa \\<and> Linorder_Relations.sorted_wrt R xsa)", "by (simp add: sorted_wrt_list_of_set_def)"], ["proof (state)\nthis:\n  sorted_wrt_list_of_set R (set xs) =\n  (THE xsa.\n      set xsa = set xs \\<and>\n      distinct xsa \\<and> Linorder_Relations.sorted_wrt R xsa)\n\ngoal (1 subgoal):\n 1. sorted_wrt_list_of_set R (set xs) = insort_wrt R (remdups xs)", "also"], ["proof (state)\nthis:\n  sorted_wrt_list_of_set R (set xs) =\n  (THE xsa.\n      set xsa = set xs \\<and>\n      distinct xsa \\<and> Linorder_Relations.sorted_wrt R xsa)\n\ngoal (1 subgoal):\n 1. sorted_wrt_list_of_set R (set xs) = insort_wrt R (remdups xs)", "have \"\\<dots> = insort_wrt R (remdups xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE xsa.\n        set xsa = set xs \\<and>\n        distinct xsa \\<and> Linorder_Relations.sorted_wrt R xsa) =\n    insort_wrt R (remdups xs)", "proof (rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (insort_wrt R (remdups xs)) = set xs \\<and>\n    distinct (insort_wrt R (remdups xs)) \\<and>\n    Linorder_Relations.sorted_wrt R (insort_wrt R (remdups xs))\n 2. \\<And>xsa.\n       set xsa = set xs \\<and>\n       distinct xsa \\<and>\n       Linorder_Relations.sorted_wrt R xsa \\<Longrightarrow>\n       xsa = insort_wrt R (remdups xs)", "fix xsa"], ["proof (state)\ngoal (2 subgoals):\n 1. set (insort_wrt R (remdups xs)) = set xs \\<and>\n    distinct (insort_wrt R (remdups xs)) \\<and>\n    Linorder_Relations.sorted_wrt R (insort_wrt R (remdups xs))\n 2. \\<And>xsa.\n       set xsa = set xs \\<and>\n       distinct xsa \\<and>\n       Linorder_Relations.sorted_wrt R xsa \\<Longrightarrow>\n       xsa = insort_wrt R (remdups xs)", "assume xsa: \"set xsa = set xs \\<and> distinct xsa \\<and> sorted_wrt R xsa\""], ["proof (state)\nthis:\n  set xsa = set xs \\<and>\n  distinct xsa \\<and> Linorder_Relations.sorted_wrt R xsa\n\ngoal (2 subgoals):\n 1. set (insort_wrt R (remdups xs)) = set xs \\<and>\n    distinct (insort_wrt R (remdups xs)) \\<and>\n    Linorder_Relations.sorted_wrt R (insort_wrt R (remdups xs))\n 2. \\<And>xsa.\n       set xsa = set xs \\<and>\n       distinct xsa \\<and>\n       Linorder_Relations.sorted_wrt R xsa \\<Longrightarrow>\n       xsa = insort_wrt R (remdups xs)", "from xsa"], ["proof (chain)\npicking this:\n  set xsa = set xs \\<and>\n  distinct xsa \\<and> Linorder_Relations.sorted_wrt R xsa", "have \"mset xsa = mset_set (set xsa)\""], ["proof (prove)\nusing this:\n  set xsa = set xs \\<and>\n  distinct xsa \\<and> Linorder_Relations.sorted_wrt R xsa\n\ngoal (1 subgoal):\n 1. mset xsa = mset_set (set xsa)", "by (subst mset_set_set) simp_all"], ["proof (state)\nthis:\n  mset xsa = mset_set (set xsa)\n\ngoal (2 subgoals):\n 1. set (insort_wrt R (remdups xs)) = set xs \\<and>\n    distinct (insort_wrt R (remdups xs)) \\<and>\n    Linorder_Relations.sorted_wrt R (insort_wrt R (remdups xs))\n 2. \\<And>xsa.\n       set xsa = set xs \\<and>\n       distinct xsa \\<and>\n       Linorder_Relations.sorted_wrt R xsa \\<Longrightarrow>\n       xsa = insort_wrt R (remdups xs)", "also"], ["proof (state)\nthis:\n  mset xsa = mset_set (set xsa)\n\ngoal (2 subgoals):\n 1. set (insort_wrt R (remdups xs)) = set xs \\<and>\n    distinct (insort_wrt R (remdups xs)) \\<and>\n    Linorder_Relations.sorted_wrt R (insort_wrt R (remdups xs))\n 2. \\<And>xsa.\n       set xsa = set xs \\<and>\n       distinct xsa \\<and>\n       Linorder_Relations.sorted_wrt R xsa \\<Longrightarrow>\n       xsa = insort_wrt R (remdups xs)", "from xsa"], ["proof (chain)\npicking this:\n  set xsa = set xs \\<and>\n  distinct xsa \\<and> Linorder_Relations.sorted_wrt R xsa", "have \"set xsa = set xs\""], ["proof (prove)\nusing this:\n  set xsa = set xs \\<and>\n  distinct xsa \\<and> Linorder_Relations.sorted_wrt R xsa\n\ngoal (1 subgoal):\n 1. set xsa = set xs", "by simp"], ["proof (state)\nthis:\n  set xsa = set xs\n\ngoal (2 subgoals):\n 1. set (insort_wrt R (remdups xs)) = set xs \\<and>\n    distinct (insort_wrt R (remdups xs)) \\<and>\n    Linorder_Relations.sorted_wrt R (insort_wrt R (remdups xs))\n 2. \\<And>xsa.\n       set xsa = set xs \\<and>\n       distinct xsa \\<and>\n       Linorder_Relations.sorted_wrt R xsa \\<Longrightarrow>\n       xsa = insort_wrt R (remdups xs)", "also"], ["proof (state)\nthis:\n  set xsa = set xs\n\ngoal (2 subgoals):\n 1. set (insort_wrt R (remdups xs)) = set xs \\<and>\n    distinct (insort_wrt R (remdups xs)) \\<and>\n    Linorder_Relations.sorted_wrt R (insort_wrt R (remdups xs))\n 2. \\<And>xsa.\n       set xsa = set xs \\<and>\n       distinct xsa \\<and>\n       Linorder_Relations.sorted_wrt R xsa \\<Longrightarrow>\n       xsa = insort_wrt R (remdups xs)", "have \"mset_set \\<dots> = mset (remdups xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_set (set xs) = mset (remdups xs)", "by (simp add: mset_remdups)"], ["proof (state)\nthis:\n  mset_set (set xs) = mset (remdups xs)\n\ngoal (2 subgoals):\n 1. set (insort_wrt R (remdups xs)) = set xs \\<and>\n    distinct (insort_wrt R (remdups xs)) \\<and>\n    Linorder_Relations.sorted_wrt R (insort_wrt R (remdups xs))\n 2. \\<And>xsa.\n       set xsa = set xs \\<and>\n       distinct xsa \\<and>\n       Linorder_Relations.sorted_wrt R xsa \\<Longrightarrow>\n       xsa = insort_wrt R (remdups xs)", "finally"], ["proof (chain)\npicking this:\n  mset xsa = mset (remdups xs)", "show \"xsa = insort_wrt R (remdups xs)\""], ["proof (prove)\nusing this:\n  mset xsa = mset (remdups xs)\n\ngoal (1 subgoal):\n 1. xsa = insort_wrt R (remdups xs)", "using xsa assms"], ["proof (prove)\nusing this:\n  mset xsa = mset (remdups xs)\n  set xsa = set xs \\<and>\n  distinct xsa \\<and> Linorder_Relations.sorted_wrt R xsa\n  linorder_on A R\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. xsa = insort_wrt R (remdups xs)", "by (intro sorted_wrt_linorder_unique[OF assms(1)])\n         (auto intro!: sorted_wrt_insort)"], ["proof (state)\nthis:\n  xsa = insort_wrt R (remdups xs)\n\ngoal (1 subgoal):\n 1. set (insort_wrt R (remdups xs)) = set xs \\<and>\n    distinct (insort_wrt R (remdups xs)) \\<and>\n    Linorder_Relations.sorted_wrt R (insort_wrt R (remdups xs))", "qed (insert assms, auto intro!: sorted_wrt_insort)"], ["proof (state)\nthis:\n  (THE xsa.\n      set xsa = set xs \\<and>\n      distinct xsa \\<and> Linorder_Relations.sorted_wrt R xsa) =\n  insort_wrt R (remdups xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt_list_of_set R (set xs) = insort_wrt R (remdups xs)", "finally"], ["proof (chain)\npicking this:\n  sorted_wrt_list_of_set R (set xs) = insort_wrt R (remdups xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt_list_of_set R (set xs) = insort_wrt R (remdups xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt_list_of_set R (set xs) = insort_wrt R (remdups xs)", "."], ["proof (state)\nthis:\n  sorted_wrt_list_of_set R (set xs) = insort_wrt R (remdups xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linorder_sorted_wrt_exists:\n  assumes \"linorder_on A R\" \"finite B\" \"B \\<subseteq> A\"\n  shows   \"\\<exists>xs. set xs = B \\<and> distinct xs \\<and> sorted_wrt R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs = B \\<and>\n       distinct xs \\<and> Linorder_Relations.sorted_wrt R xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs = B \\<and>\n       distinct xs \\<and> Linorder_Relations.sorted_wrt R xs", "from \\<open>finite B\\<close>"], ["proof (chain)\npicking this:\n  finite B", "obtain xs where \"set xs = B\" \"distinct xs\""], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>set xs = B; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_distinct_list"], ["proof (prove)\nusing this:\n  finite B\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>set xs = B; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set xs = B\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs = B \\<and>\n       distinct xs \\<and> Linorder_Relations.sorted_wrt R xs", "hence \"set (insort_wrt R xs) = B\" \"distinct (insort_wrt R xs)\""], ["proof (prove)\nusing this:\n  set xs = B\n  distinct xs\n\ngoal (1 subgoal):\n 1. set (insort_wrt R xs) = B &&& distinct (insort_wrt R xs)", "by simp_all"], ["proof (state)\nthis:\n  set (insort_wrt R xs) = B\n  distinct (insort_wrt R xs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs = B \\<and>\n       distinct xs \\<and> Linorder_Relations.sorted_wrt R xs", "moreover"], ["proof (state)\nthis:\n  set (insort_wrt R xs) = B\n  distinct (insort_wrt R xs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs = B \\<and>\n       distinct xs \\<and> Linorder_Relations.sorted_wrt R xs", "have \"sorted_wrt R (insort_wrt R xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (insort_wrt R xs)", "using assms \\<open>set xs = B\\<close>"], ["proof (prove)\nusing this:\n  linorder_on A R\n  finite B\n  B \\<subseteq> A\n  set xs = B\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (insort_wrt R xs)", "by (intro sorted_wrt_insort[OF assms(1)]) auto"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R (insort_wrt R xs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs = B \\<and>\n       distinct xs \\<and> Linorder_Relations.sorted_wrt R xs", "ultimately"], ["proof (chain)\npicking this:\n  set (insort_wrt R xs) = B\n  distinct (insort_wrt R xs)\n  Linorder_Relations.sorted_wrt R (insort_wrt R xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (insort_wrt R xs) = B\n  distinct (insort_wrt R xs)\n  Linorder_Relations.sorted_wrt R (insort_wrt R xs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs = B \\<and>\n       distinct xs \\<and> Linorder_Relations.sorted_wrt R xs", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs = B \\<and> distinct xs \\<and> Linorder_Relations.sorted_wrt R xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linorder_sorted_wrt_list_of_set:\n  assumes \"linorder_on A R\" \"finite B\" \"B \\<subseteq> A\"\n  shows   \"set (sorted_wrt_list_of_set R B) = B\" \"distinct (sorted_wrt_list_of_set R B)\"\n          \"sorted_wrt R (sorted_wrt_list_of_set R B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sorted_wrt_list_of_set R B) = B &&&\n    distinct (sorted_wrt_list_of_set R B) &&&\n    Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R B)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. set (sorted_wrt_list_of_set R B) = B\n 2. distinct (sorted_wrt_list_of_set R B)\n 3. Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R B)", "have \"\\<exists>!xs. set xs = B \\<and> distinct xs \\<and> sorted_wrt R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       set xs = B \\<and>\n       distinct xs \\<and> Linorder_Relations.sorted_wrt R xs", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>xs.\n       set xs = B \\<and>\n       distinct xs \\<and> Linorder_Relations.sorted_wrt R xs\n 2. \\<And>xs y.\n       \\<lbrakk>set xs = B \\<and>\n                distinct xs \\<and> Linorder_Relations.sorted_wrt R xs;\n        set y = B \\<and>\n        distinct y \\<and> Linorder_Relations.sorted_wrt R y\\<rbrakk>\n       \\<Longrightarrow> xs = y", "show \"\\<exists>xs. set xs = B \\<and> distinct xs \\<and> sorted_wrt R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs = B \\<and>\n       distinct xs \\<and> Linorder_Relations.sorted_wrt R xs", "by (rule linorder_sorted_wrt_exists assms)+"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs = B \\<and> distinct xs \\<and> Linorder_Relations.sorted_wrt R xs\n\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>set xs = B \\<and>\n                distinct xs \\<and> Linorder_Relations.sorted_wrt R xs;\n        set y = B \\<and>\n        distinct y \\<and> Linorder_Relations.sorted_wrt R y\\<rbrakk>\n       \\<Longrightarrow> xs = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>set xs = B \\<and>\n                distinct xs \\<and> Linorder_Relations.sorted_wrt R xs;\n        set y = B \\<and>\n        distinct y \\<and> Linorder_Relations.sorted_wrt R y\\<rbrakk>\n       \\<Longrightarrow> xs = y", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>set xs = B \\<and>\n                distinct xs \\<and> Linorder_Relations.sorted_wrt R xs;\n        set y = B \\<and>\n        distinct y \\<and> Linorder_Relations.sorted_wrt R y\\<rbrakk>\n       \\<Longrightarrow> xs = y", "assume \"set xs = B \\<and> distinct xs \\<and> sorted_wrt R xs\" \n                     \"set ys = B \\<and> distinct ys \\<and> sorted_wrt R ys\""], ["proof (state)\nthis:\n  set xs = B \\<and> distinct xs \\<and> Linorder_Relations.sorted_wrt R xs\n  set ys = B \\<and> distinct ys \\<and> Linorder_Relations.sorted_wrt R ys\n\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>set xs = B \\<and>\n                distinct xs \\<and> Linorder_Relations.sorted_wrt R xs;\n        set y = B \\<and>\n        distinct y \\<and> Linorder_Relations.sorted_wrt R y\\<rbrakk>\n       \\<Longrightarrow> xs = y", "thus \"xs = ys\""], ["proof (prove)\nusing this:\n  set xs = B \\<and> distinct xs \\<and> Linorder_Relations.sorted_wrt R xs\n  set ys = B \\<and> distinct ys \\<and> Linorder_Relations.sorted_wrt R ys\n\ngoal (1 subgoal):\n 1. xs = ys", "by (intro sorted_wrt_linorder_unique[OF assms(1)]) (auto simp: set_eq_iff_mset_eq_distinct)"], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!xs.\n     set xs = B \\<and> distinct xs \\<and> Linorder_Relations.sorted_wrt R xs\n\ngoal (3 subgoals):\n 1. set (sorted_wrt_list_of_set R B) = B\n 2. distinct (sorted_wrt_list_of_set R B)\n 3. Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R B)", "from theI'[OF this]"], ["proof (chain)\npicking this:\n  set (THE x.\n          set x = B \\<and>\n          distinct x \\<and> Linorder_Relations.sorted_wrt R x) =\n  B \\<and>\n  distinct\n   (THE x.\n       set x = B \\<and>\n       distinct x \\<and> Linorder_Relations.sorted_wrt R x) \\<and>\n  Linorder_Relations.sorted_wrt R\n   (THE x.\n       set x = B \\<and> distinct x \\<and> Linorder_Relations.sorted_wrt R x)", "show  \"set (sorted_wrt_list_of_set R B) = B\" \n    \"distinct (sorted_wrt_list_of_set R B)\" \"sorted_wrt R (sorted_wrt_list_of_set R B)\""], ["proof (prove)\nusing this:\n  set (THE x.\n          set x = B \\<and>\n          distinct x \\<and> Linorder_Relations.sorted_wrt R x) =\n  B \\<and>\n  distinct\n   (THE x.\n       set x = B \\<and>\n       distinct x \\<and> Linorder_Relations.sorted_wrt R x) \\<and>\n  Linorder_Relations.sorted_wrt R\n   (THE x.\n       set x = B \\<and> distinct x \\<and> Linorder_Relations.sorted_wrt R x)\n\ngoal (1 subgoal):\n 1. set (sorted_wrt_list_of_set R B) = B &&&\n    distinct (sorted_wrt_list_of_set R B) &&&\n    Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R B)", "by (simp_all add: sorted_wrt_list_of_set_def \\<open>finite B\\<close>)"], ["proof (state)\nthis:\n  set (sorted_wrt_list_of_set R B) = B\n  distinct (sorted_wrt_list_of_set R B)\n  Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_wrt_list_of_set_eqI:\n  assumes \"linorder_on B R\" \"A \\<subseteq> B\" \"set xs = A\" \"distinct xs\" \"sorted_wrt R xs\"\n  shows   \"sorted_wrt_list_of_set R A = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt_list_of_set R A = xs", "proof (rule sorted_wrt_linorder_unique)"], ["proof (state)\ngoal (4 subgoals):\n 1. linorder_on ?A ?R\n 2. mset (sorted_wrt_list_of_set R A) = mset xs\n 3. Linorder_Relations.sorted_wrt ?R (sorted_wrt_list_of_set R A)\n 4. Linorder_Relations.sorted_wrt ?R xs", "show \"linorder_on B R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_on B R", "by fact"], ["proof (state)\nthis:\n  linorder_on B R\n\ngoal (3 subgoals):\n 1. mset (sorted_wrt_list_of_set R A) = mset xs\n 2. Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n 3. Linorder_Relations.sorted_wrt R xs", "let ?ys = \"sorted_wrt_list_of_set R A\""], ["proof (state)\ngoal (3 subgoals):\n 1. mset (sorted_wrt_list_of_set R A) = mset xs\n 2. Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n 3. Linorder_Relations.sorted_wrt R xs", "have fin [simp]: \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "by (simp_all add: assms(3) [symmetric])"], ["proof (state)\nthis:\n  finite A\n\ngoal (3 subgoals):\n 1. mset (sorted_wrt_list_of_set R A) = mset xs\n 2. Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n 3. Linorder_Relations.sorted_wrt R xs", "have *: \"distinct ?ys\" \"set ?ys = A\" \"sorted_wrt R ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (sorted_wrt_list_of_set R A) &&&\n    set (sorted_wrt_list_of_set R A) = A &&&\n    Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)", "by (rule linorder_sorted_wrt_list_of_set[OF assms(1)] fin assms)+"], ["proof (state)\nthis:\n  distinct (sorted_wrt_list_of_set R A)\n  set (sorted_wrt_list_of_set R A) = A\n  Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n\ngoal (3 subgoals):\n 1. mset (sorted_wrt_list_of_set R A) = mset xs\n 2. Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n 3. Linorder_Relations.sorted_wrt R xs", "from assms *"], ["proof (chain)\npicking this:\n  linorder_on B R\n  A \\<subseteq> B\n  set xs = A\n  distinct xs\n  Linorder_Relations.sorted_wrt R xs\n  distinct (sorted_wrt_list_of_set R A)\n  set (sorted_wrt_list_of_set R A) = A\n  Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)", "show \"mset ?ys = mset xs\""], ["proof (prove)\nusing this:\n  linorder_on B R\n  A \\<subseteq> B\n  set xs = A\n  distinct xs\n  Linorder_Relations.sorted_wrt R xs\n  distinct (sorted_wrt_list_of_set R A)\n  set (sorted_wrt_list_of_set R A) = A\n  Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n\ngoal (1 subgoal):\n 1. mset (sorted_wrt_list_of_set R A) = mset xs", "by (subst set_eq_iff_mset_eq_distinct [symmetric]) simp_all"], ["proof (state)\nthis:\n  mset (sorted_wrt_list_of_set R A) = mset xs\n\ngoal (2 subgoals):\n 1. Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n 2. Linorder_Relations.sorted_wrt R xs", "show \"sorted_wrt R ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)", "by fact"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R xs", "qed fact+"], ["", "subsection \\<open>Rank of an element in an ordering\\<close>"], ["", "text \\<open>\n  The `rank' of an element in a set w.r.t. an ordering is how many smaller elements exist.\n  This is particularly useful in linear orders, where there exists a unique $n$-th element \n  for every $n$.\n\\<close>"], ["", "definition linorder_rank where\n  \"linorder_rank R A x = card {y\\<in>A-{x}. (y,x) \\<in> R}\""], ["", "lemma linorder_rank_le: \n  assumes \"finite A\"\n  shows   \"linorder_rank R A x \\<le> card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R A x \\<le> card A", "unfolding linorder_rank_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {y \\<in> A - {x}. (y, x) \\<in> R} \\<le> card A", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. card {y \\<in> A - {x}. (y, x) \\<in> R} \\<le> card A", "by (rule card_mono) auto"], ["", "lemma linorder_rank_less:\n  assumes \"finite A\" \"x \\<in> A\"\n  shows   \"linorder_rank R A x < card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R A x < card A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linorder_rank R A x < card A", "have \"linorder_rank R A x \\<le> card (A - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R A x \\<le> card (A - {x})", "unfolding linorder_rank_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {y \\<in> A - {x}. (y, x) \\<in> R} \\<le> card (A - {x})", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. card {y \\<in> A - {x}. (y, x) \\<in> R} \\<le> card (A - {x})", "by (intro card_mono) auto"], ["proof (state)\nthis:\n  linorder_rank R A x \\<le> card (A - {x})\n\ngoal (1 subgoal):\n 1. linorder_rank R A x < card A", "also"], ["proof (state)\nthis:\n  linorder_rank R A x \\<le> card (A - {x})\n\ngoal (1 subgoal):\n 1. linorder_rank R A x < card A", "from assms"], ["proof (chain)\npicking this:\n  finite A\n  x \\<in> A", "have \"\\<dots> < card A\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. card (A - {x}) < card A", "by (intro psubset_card_mono) auto"], ["proof (state)\nthis:\n  card (A - {x}) < card A\n\ngoal (1 subgoal):\n 1. linorder_rank R A x < card A", "finally"], ["proof (chain)\npicking this:\n  linorder_rank R A x < card A", "show ?thesis"], ["proof (prove)\nusing this:\n  linorder_rank R A x < card A\n\ngoal (1 subgoal):\n 1. linorder_rank R A x < card A", "."], ["proof (state)\nthis:\n  linorder_rank R A x < card A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linorder_rank_union:\n  assumes \"finite A\" \"finite B\" \"A \\<inter> B = {}\"\n  shows   \"linorder_rank R (A \\<union> B) x = linorder_rank R A x + linorder_rank R B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R (A \\<union> B) x =\n    linorder_rank R A x + linorder_rank R B x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linorder_rank R (A \\<union> B) x =\n    linorder_rank R A x + linorder_rank R B x", "have \"linorder_rank R (A \\<union> B) x = card {y\\<in>(A\\<union>B)-{x}. (y,x) \\<in> R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R (A \\<union> B) x =\n    card {y \\<in> A \\<union> B - {x}. (y, x) \\<in> R}", "by (simp add: linorder_rank_def)"], ["proof (state)\nthis:\n  linorder_rank R (A \\<union> B) x =\n  card {y \\<in> A \\<union> B - {x}. (y, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. linorder_rank R (A \\<union> B) x =\n    linorder_rank R A x + linorder_rank R B x", "also"], ["proof (state)\nthis:\n  linorder_rank R (A \\<union> B) x =\n  card {y \\<in> A \\<union> B - {x}. (y, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. linorder_rank R (A \\<union> B) x =\n    linorder_rank R A x + linorder_rank R B x", "have \"{y\\<in>(A\\<union>B)-{x}. (y,x) \\<in> R} = {y\\<in>A-{x}. (y,x) \\<in> R} \\<union> {y\\<in>B-{x}. (y,x) \\<in> R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> A \\<union> B - {x}. (y, x) \\<in> R} =\n    {y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n    {y \\<in> B - {x}. (y, x) \\<in> R}", "by blast"], ["proof (state)\nthis:\n  {y \\<in> A \\<union> B - {x}. (y, x) \\<in> R} =\n  {y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n  {y \\<in> B - {x}. (y, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. linorder_rank R (A \\<union> B) x =\n    linorder_rank R A x + linorder_rank R B x", "also"], ["proof (state)\nthis:\n  {y \\<in> A \\<union> B - {x}. (y, x) \\<in> R} =\n  {y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n  {y \\<in> B - {x}. (y, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. linorder_rank R (A \\<union> B) x =\n    linorder_rank R A x + linorder_rank R B x", "have \"card \\<dots> = linorder_rank R A x + linorder_rank R B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n      {y \\<in> B - {x}. (y, x) \\<in> R}) =\n    linorder_rank R A x + linorder_rank R B x", "unfolding linorder_rank_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n      {y \\<in> B - {x}. (y, x) \\<in> R}) =\n    card {y \\<in> A - {x}. (y, x) \\<in> R} +\n    card {y \\<in> B - {x}. (y, x) \\<in> R}", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  finite B\n  A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. card\n     ({y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n      {y \\<in> B - {x}. (y, x) \\<in> R}) =\n    card {y \\<in> A - {x}. (y, x) \\<in> R} +\n    card {y \\<in> B - {x}. (y, x) \\<in> R}", "by (intro card_Un_disjoint) auto"], ["proof (state)\nthis:\n  card\n   ({y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n    {y \\<in> B - {x}. (y, x) \\<in> R}) =\n  linorder_rank R A x + linorder_rank R B x\n\ngoal (1 subgoal):\n 1. linorder_rank R (A \\<union> B) x =\n    linorder_rank R A x + linorder_rank R B x", "finally"], ["proof (chain)\npicking this:\n  linorder_rank R (A \\<union> B) x =\n  linorder_rank R A x + linorder_rank R B x", "show ?thesis"], ["proof (prove)\nusing this:\n  linorder_rank R (A \\<union> B) x =\n  linorder_rank R A x + linorder_rank R B x\n\ngoal (1 subgoal):\n 1. linorder_rank R (A \\<union> B) x =\n    linorder_rank R A x + linorder_rank R B x", "."], ["proof (state)\nthis:\n  linorder_rank R (A \\<union> B) x =\n  linorder_rank R A x + linorder_rank R B x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linorder_rank_empty [simp]: \"linorder_rank R {} x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R {} x = 0", "by (simp add: linorder_rank_def)"], ["", "lemma linorder_rank_singleton: \n  \"linorder_rank R {y} x = (if x \\<noteq> y \\<and> (y,x) \\<in> R then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R {y} x =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linorder_rank R {y} x =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)", "have \"linorder_rank R {y} x = card {z\\<in>{y}-{x}. (z,x) \\<in> R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R {y} x = card {z \\<in> {y} - {x}. (z, x) \\<in> R}", "by (simp add: linorder_rank_def)"], ["proof (state)\nthis:\n  linorder_rank R {y} x = card {z \\<in> {y} - {x}. (z, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. linorder_rank R {y} x =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)", "also"], ["proof (state)\nthis:\n  linorder_rank R {y} x = card {z \\<in> {y} - {x}. (z, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. linorder_rank R {y} x =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)", "have \"{z\\<in>{y}-{x}. (z,x) \\<in> R} = (if x \\<noteq> y \\<and> (y,x) \\<in> R then {y} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {z \\<in> {y} - {x}. (z, x) \\<in> R} =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then {y} else {})", "by auto"], ["proof (state)\nthis:\n  {z \\<in> {y} - {x}. (z, x) \\<in> R} =\n  (if x \\<noteq> y \\<and> (y, x) \\<in> R then {y} else {})\n\ngoal (1 subgoal):\n 1. linorder_rank R {y} x =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)", "also"], ["proof (state)\nthis:\n  {z \\<in> {y} - {x}. (z, x) \\<in> R} =\n  (if x \\<noteq> y \\<and> (y, x) \\<in> R then {y} else {})\n\ngoal (1 subgoal):\n 1. linorder_rank R {y} x =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)", "have \"card \\<dots> = (if x \\<noteq> y \\<and> (y,x) \\<in> R then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (if x \\<noteq> y \\<and> (y, x) \\<in> R then {y} else {}) =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  card (if x \\<noteq> y \\<and> (y, x) \\<in> R then {y} else {}) =\n  (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)\n\ngoal (1 subgoal):\n 1. linorder_rank R {y} x =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  linorder_rank R {y} x =\n  (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  linorder_rank R {y} x =\n  (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)\n\ngoal (1 subgoal):\n 1. linorder_rank R {y} x =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)", "."], ["proof (state)\nthis:\n  linorder_rank R {y} x =\n  (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linorder_rank_insert:\n  assumes \"finite A\" \"y \\<notin> A\"\n  shows   \"linorder_rank R (insert y A) x = \n             (if x \\<noteq> y \\<and> (y,x) \\<in> R then 1 else 0) + linorder_rank R A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R (insert y A) x =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0) +\n    linorder_rank R A x", "using linorder_rank_union[of \"{y}\" A R x] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {y}; finite A; {y} \\<inter> A = {}\\<rbrakk>\n  \\<Longrightarrow> linorder_rank R ({y} \\<union> A) x =\n                    linorder_rank R {y} x + linorder_rank R A x\n  finite A\n  y \\<notin> A\n\ngoal (1 subgoal):\n 1. linorder_rank R (insert y A) x =\n    (if x \\<noteq> y \\<and> (y, x) \\<in> R then 1 else 0) +\n    linorder_rank R A x", "by (auto simp: linorder_rank_singleton)"], ["", "lemma linorder_rank_mono:\n  assumes \"linorder_on B R\" \"finite A\" \"A \\<subseteq> B\" \"(x, y) \\<in> R\"\n  shows   \"linorder_rank R A x \\<le> linorder_rank R A y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R A x \\<le> linorder_rank R A y", "unfolding linorder_rank_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {y \\<in> A - {x}. (y, x) \\<in> R}\n    \\<le> card {ya \\<in> A - {y}. (ya, y) \\<in> R}", "proof (rule card_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {ya \\<in> A - {y}. (ya, y) \\<in> R}\n 2. {y \\<in> A - {x}. (y, x) \\<in> R}\n    \\<subseteq> {ya \\<in> A - {y}. (ya, y) \\<in> R}", "from assms"], ["proof (chain)\npicking this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  (x, y) \\<in> R", "have trans: \"trans R\" and antisym: \"antisym R\""], ["proof (prove)\nusing this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. trans R &&& antisym R", "by (simp_all add: linorder_on_def)"], ["proof (state)\nthis:\n  trans R\n  antisym R\n\ngoal (2 subgoals):\n 1. finite {ya \\<in> A - {y}. (ya, y) \\<in> R}\n 2. {y \\<in> A - {x}. (y, x) \\<in> R}\n    \\<subseteq> {ya \\<in> A - {y}. (ya, y) \\<in> R}", "from assms antisym"], ["proof (chain)\npicking this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  (x, y) \\<in> R\n  antisym R", "show \"{y \\<in> A - {x}. (y, x) \\<in> R} \\<subseteq> {ya \\<in> A - {y}. (ya, y) \\<in> R}\""], ["proof (prove)\nusing this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  (x, y) \\<in> R\n  antisym R\n\ngoal (1 subgoal):\n 1. {y \\<in> A - {x}. (y, x) \\<in> R}\n    \\<subseteq> {ya \\<in> A - {y}. (ya, y) \\<in> R}", "by (auto intro: transD[OF trans] simp: antisym_def)"], ["proof (state)\nthis:\n  {y \\<in> A - {x}. (y, x) \\<in> R}\n  \\<subseteq> {ya \\<in> A - {y}. (ya, y) \\<in> R}\n\ngoal (1 subgoal):\n 1. finite {ya \\<in> A - {y}. (ya, y) \\<in> R}", "qed (insert assms, simp_all)"], ["", "lemma linorder_rank_strict_mono:\n  assumes \"linorder_on B R\" \"finite A\" \"A \\<subseteq> B\" \"y \\<in> A\" \"(y, x) \\<in> R\" \"x \\<noteq> y\"\n  shows   \"linorder_rank R A y < linorder_rank R A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R A y < linorder_rank R A x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linorder_rank R A y < linorder_rank R A x", "from assms(1)"], ["proof (chain)\npicking this:\n  linorder_on B R", "have trans: \"trans R\""], ["proof (prove)\nusing this:\n  linorder_on B R\n\ngoal (1 subgoal):\n 1. trans R", "by (simp add: linorder_on_def)"], ["proof (state)\nthis:\n  trans R\n\ngoal (1 subgoal):\n 1. linorder_rank R A y < linorder_rank R A x", "from assms"], ["proof (chain)\npicking this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  y \\<in> A\n  (y, x) \\<in> R\n  x \\<noteq> y", "have *: \"(x, y) \\<notin> R\""], ["proof (prove)\nusing this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  y \\<in> A\n  (y, x) \\<in> R\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> R", "by (auto simp: linorder_on_def antisym_def)"], ["proof (state)\nthis:\n  (x, y) \\<notin> R\n\ngoal (1 subgoal):\n 1. linorder_rank R A y < linorder_rank R A x", "from this and \\<open>(y,x) \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  (x, y) \\<notin> R\n  (y, x) \\<in> R", "have \"{z\\<in>A-{y}. (z, y) \\<in> R} \\<subseteq> {z\\<in>A-{x}. (z,x) \\<in> R}\""], ["proof (prove)\nusing this:\n  (x, y) \\<notin> R\n  (y, x) \\<in> R\n\ngoal (1 subgoal):\n 1. {z \\<in> A - {y}. (z, y) \\<in> R}\n    \\<subseteq> {z \\<in> A - {x}. (z, x) \\<in> R}", "by (auto intro: transD[OF trans])"], ["proof (state)\nthis:\n  {z \\<in> A - {y}. (z, y) \\<in> R}\n  \\<subseteq> {z \\<in> A - {x}. (z, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. linorder_rank R A y < linorder_rank R A x", "moreover"], ["proof (state)\nthis:\n  {z \\<in> A - {y}. (z, y) \\<in> R}\n  \\<subseteq> {z \\<in> A - {x}. (z, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. linorder_rank R A y < linorder_rank R A x", "from * and assms"], ["proof (chain)\npicking this:\n  (x, y) \\<notin> R\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  y \\<in> A\n  (y, x) \\<in> R\n  x \\<noteq> y", "have \"y \\<notin> {z\\<in>A-{y}. (z, y) \\<in> R}\" \"y \\<in> {z\\<in>A-{x}. (z, x) \\<in> R}\""], ["proof (prove)\nusing this:\n  (x, y) \\<notin> R\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  y \\<in> A\n  (y, x) \\<in> R\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. y \\<notin> {z \\<in> A - {y}. (z, y) \\<in> R} &&&\n    y \\<in> {z \\<in> A - {x}. (z, x) \\<in> R}", "by auto"], ["proof (state)\nthis:\n  y \\<notin> {z \\<in> A - {y}. (z, y) \\<in> R}\n  y \\<in> {z \\<in> A - {x}. (z, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. linorder_rank R A y < linorder_rank R A x", "ultimately"], ["proof (chain)\npicking this:\n  {z \\<in> A - {y}. (z, y) \\<in> R}\n  \\<subseteq> {z \\<in> A - {x}. (z, x) \\<in> R}\n  y \\<notin> {z \\<in> A - {y}. (z, y) \\<in> R}\n  y \\<in> {z \\<in> A - {x}. (z, x) \\<in> R}", "have \"{z\\<in>A-{y}. (z, y) \\<in> R} \\<subset> {z\\<in>A-{x}. (z,x) \\<in> R}\""], ["proof (prove)\nusing this:\n  {z \\<in> A - {y}. (z, y) \\<in> R}\n  \\<subseteq> {z \\<in> A - {x}. (z, x) \\<in> R}\n  y \\<notin> {z \\<in> A - {y}. (z, y) \\<in> R}\n  y \\<in> {z \\<in> A - {x}. (z, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. {z \\<in> A - {y}. (z, y) \\<in> R}\n    \\<subset> {z \\<in> A - {x}. (z, x) \\<in> R}", "by blast"], ["proof (state)\nthis:\n  {z \\<in> A - {y}. (z, y) \\<in> R}\n  \\<subset> {z \\<in> A - {x}. (z, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. linorder_rank R A y < linorder_rank R A x", "thus ?thesis"], ["proof (prove)\nusing this:\n  {z \\<in> A - {y}. (z, y) \\<in> R}\n  \\<subset> {z \\<in> A - {x}. (z, x) \\<in> R}\n\ngoal (1 subgoal):\n 1. linorder_rank R A y < linorder_rank R A x", "using assms"], ["proof (prove)\nusing this:\n  {z \\<in> A - {y}. (z, y) \\<in> R}\n  \\<subset> {z \\<in> A - {x}. (z, x) \\<in> R}\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  y \\<in> A\n  (y, x) \\<in> R\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. linorder_rank R A y < linorder_rank R A x", "unfolding linorder_rank_def"], ["proof (prove)\nusing this:\n  {z \\<in> A - {y}. (z, y) \\<in> R}\n  \\<subset> {z \\<in> A - {x}. (z, x) \\<in> R}\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  y \\<in> A\n  (y, x) \\<in> R\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. card {ya \\<in> A - {y}. (ya, y) \\<in> R}\n    < card {y \\<in> A - {x}. (y, x) \\<in> R}", "by (intro psubset_card_mono) auto"], ["proof (state)\nthis:\n  linorder_rank R A y < linorder_rank R A x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linorder_rank_le_iff:\n  assumes \"linorder_on B R\" \"finite A\" \"A \\<subseteq> B\" \"x \\<in> A\" \"y \\<in> A\"\n  shows   \"linorder_rank R A x \\<le> linorder_rank R A y \\<longleftrightarrow> (x, y) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)\n 2. x \\<noteq> y \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)\n 2. x \\<noteq> y \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "with assms"], ["proof (chain)\npicking this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  x \\<in> A\n  y \\<in> A\n  x = y", "show ?thesis"], ["proof (prove)\nusing this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  x \\<in> A\n  y \\<in> A\n  x = y\n\ngoal (1 subgoal):\n 1. (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "by (auto simp: linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "from assms(1)"], ["proof (chain)\npicking this:\n  linorder_on B R", "have trans: \"trans R\""], ["proof (prove)\nusing this:\n  linorder_on B R\n\ngoal (1 subgoal):\n 1. trans R", "by (simp_all add: linorder_on_def)"], ["proof (state)\nthis:\n  trans R\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "from assms"], ["proof (chain)\npicking this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  x \\<in> A\n  y \\<in> A", "have \"x \\<in> B\" \"y \\<in> B\""], ["proof (prove)\nusing this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  x \\<in> A\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<in> B &&& y \\<in> B", "by auto"], ["proof (state)\nthis:\n  x \\<in> B\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "with \\<open>linorder_on B R\\<close> and False"], ["proof (chain)\npicking this:\n  linorder_on B R\n  x \\<noteq> y\n  x \\<in> B\n  y \\<in> B", "have \"((x,y) \\<in> R \\<and> (y,x) \\<notin> R) \\<or> ((y,x) \\<in> R \\<and> (x,y) \\<notin> R)\""], ["proof (prove)\nusing this:\n  linorder_on B R\n  x \\<noteq> y\n  x \\<in> B\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> R \\<and> (y, x) \\<notin> R \\<or>\n    (y, x) \\<in> R \\<and> (x, y) \\<notin> R", "by (fastforce simp: linorder_on_def antisym_def total_on_def)"], ["proof (state)\nthis:\n  (x, y) \\<in> R \\<and> (y, x) \\<notin> R \\<or>\n  (y, x) \\<in> R \\<and> (x, y) \\<notin> R\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x, y) \\<in> R \\<and> (y, x) \\<notin> R \\<or>\n  (y, x) \\<in> R \\<and> (x, y) \\<notin> R\n\ngoal (1 subgoal):\n 1. (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, y) \\<in> R \\<and> (y, x) \\<notin> R \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)\n 2. (y, x) \\<in> R \\<and> (x, y) \\<notin> R \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "assume \"(x,y) \\<in> R \\<and> (y,x) \\<notin> R\""], ["proof (state)\nthis:\n  (x, y) \\<in> R \\<and> (y, x) \\<notin> R\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> R \\<and> (y, x) \\<notin> R \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)\n 2. (y, x) \\<in> R \\<and> (x, y) \\<notin> R \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "with assms"], ["proof (chain)\npicking this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  x \\<in> A\n  y \\<in> A\n  (x, y) \\<in> R \\<and> (y, x) \\<notin> R", "show ?thesis"], ["proof (prove)\nusing this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  x \\<in> A\n  y \\<in> A\n  (x, y) \\<in> R \\<and> (y, x) \\<notin> R\n\ngoal (1 subgoal):\n 1. (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "by (auto intro!: linorder_rank_mono)"], ["proof (state)\nthis:\n  (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> R \\<and> (x, y) \\<notin> R \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (y, x) \\<in> R \\<and> (x, y) \\<notin> R \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "assume *: \"(y,x) \\<in> R \\<and> (x,y) \\<notin> R\""], ["proof (state)\nthis:\n  (y, x) \\<in> R \\<and> (x, y) \\<notin> R\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> R \\<and> (x, y) \\<notin> R \\<Longrightarrow>\n    (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "with linorder_rank_strict_mono[OF assms(1-3), of y x] assms False"], ["proof (chain)\npicking this:\n  \\<lbrakk>y \\<in> A; (y, x) \\<in> R; x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> linorder_rank R A y < linorder_rank R A x\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n  (y, x) \\<in> R \\<and> (x, y) \\<notin> R", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<in> A; (y, x) \\<in> R; x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> linorder_rank R A y < linorder_rank R A x\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n  (y, x) \\<in> R \\<and> (x, y) \\<notin> R\n\ngoal (1 subgoal):\n 1. (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)", "by auto"], ["proof (state)\nthis:\n  (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linorder_rank_eq_iff:\n  assumes \"linorder_on B R\" \"finite A\" \"A \\<subseteq> B\" \"x \\<in> A\" \"y \\<in> A\"\n  shows   \"linorder_rank R A x = linorder_rank R A y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (linorder_rank R A x = linorder_rank R A y) = (x = y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. linorder_rank R A x = linorder_rank R A y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> linorder_rank R A x = linorder_rank R A y", "assume \"linorder_rank R A x = linorder_rank R A y\""], ["proof (state)\nthis:\n  linorder_rank R A x = linorder_rank R A y\n\ngoal (2 subgoals):\n 1. linorder_rank R A x = linorder_rank R A y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> linorder_rank R A x = linorder_rank R A y", "with linorder_rank_le_iff[OF assms(1-5)] linorder_rank_le_iff[OF assms(1-3) assms(5,4)]"], ["proof (chain)\npicking this:\n  (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)\n  (linorder_rank R A y \\<le> linorder_rank R A x) = ((y, x) \\<in> R)\n  linorder_rank R A x = linorder_rank R A y", "have \"(x, y) \\<in> R\" \"(y, x) \\<in> R\""], ["proof (prove)\nusing this:\n  (linorder_rank R A x \\<le> linorder_rank R A y) = ((x, y) \\<in> R)\n  (linorder_rank R A y \\<le> linorder_rank R A x) = ((y, x) \\<in> R)\n  linorder_rank R A x = linorder_rank R A y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> R &&& (y, x) \\<in> R", "by simp_all"], ["proof (state)\nthis:\n  (x, y) \\<in> R\n  (y, x) \\<in> R\n\ngoal (2 subgoals):\n 1. linorder_rank R A x = linorder_rank R A y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> linorder_rank R A x = linorder_rank R A y", "with assms"], ["proof (chain)\npicking this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  x \\<in> A\n  y \\<in> A\n  (x, y) \\<in> R\n  (y, x) \\<in> R", "show \"x = y\""], ["proof (prove)\nusing this:\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  x \\<in> A\n  y \\<in> A\n  (x, y) \\<in> R\n  (y, x) \\<in> R\n\ngoal (1 subgoal):\n 1. x = y", "by (auto simp: linorder_on_def antisym_def)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> linorder_rank R A x = linorder_rank R A y", "qed simp_all"], ["", "lemma linorder_rank_set_sorted_wrt:\n  assumes \"linorder_on B R\" \"set xs \\<subseteq> B\" \"sorted_wrt R xs\" \"x \\<in> set xs\" \"distinct xs\"\n  shows   \"linorder_rank R (set xs) x = index xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "define j where \"j = index xs x\""], ["proof (state)\nthis:\n  j = index xs x\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "from assms"], ["proof (chain)\npicking this:\n  linorder_on B R\n  set xs \\<subseteq> B\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  distinct xs", "have j: \"j < length xs\""], ["proof (prove)\nusing this:\n  linorder_on B R\n  set xs \\<subseteq> B\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. j < length xs", "by (simp add: j_def)"], ["proof (state)\nthis:\n  j < length xs\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "have *: \"x = y \\<or> ((x, y) \\<in> R \\<and> (y, x) \\<notin> R) \\<or> ((y, x) \\<in> R \\<and> (x, y) \\<notin> R)\" if \"y \\<in> set xs\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<or>\n    (x, y) \\<in> R \\<and> (y, x) \\<notin> R \\<or>\n    (y, x) \\<in> R \\<and> (x, y) \\<notin> R", "using linorder_on_cases[OF assms(1), of x y] assms that"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> B; y \\<in> B\\<rbrakk>\n  \\<Longrightarrow> x = y \\<or>\n                    (x, y) \\<in> R \\<and> (y, x) \\<notin> R \\<or>\n                    (y, x) \\<in> R \\<and> (x, y) \\<notin> R\n  linorder_on B R\n  set xs \\<subseteq> B\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  distinct xs\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. x = y \\<or>\n    (x, y) \\<in> R \\<and> (y, x) \\<notin> R \\<or>\n    (y, x) \\<in> R \\<and> (x, y) \\<notin> R", "by auto"], ["proof (state)\nthis:\n  ?y \\<in> set xs \\<Longrightarrow>\n  x = ?y \\<or>\n  (x, ?y) \\<in> R \\<and> (?y, x) \\<notin> R \\<or>\n  (?y, x) \\<in> R \\<and> (x, ?y) \\<notin> R\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "from assms"], ["proof (chain)\npicking this:\n  linorder_on B R\n  set xs \\<subseteq> B\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  distinct xs", "have \"{y\\<in>set xs-{x}. (y, x) \\<in> R} = {y\\<in>set xs-{x}. index xs y < index xs x}\""], ["proof (prove)\nusing this:\n  linorder_on B R\n  set xs \\<subseteq> B\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. {y \\<in> set xs - {x}. (y, x) \\<in> R} =\n    {y \\<in> set xs - {x}. index xs y < index xs x}", "by (auto simp: sorted_wrt_linorder_index_less_iff[OF assms(1-3)] dest: *)"], ["proof (state)\nthis:\n  {y \\<in> set xs - {x}. (y, x) \\<in> R} =\n  {y \\<in> set xs - {x}. index xs y < index xs x}\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "also"], ["proof (state)\nthis:\n  {y \\<in> set xs - {x}. (y, x) \\<in> R} =\n  {y \\<in> set xs - {x}. index xs y < index xs x}\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "have \"\\<dots> = {y\\<in>set xs. index xs y < j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> set xs - {x}. index xs y < index xs x} =\n    {y \\<in> set xs. index xs y < j}", "by (auto simp: j_def)"], ["proof (state)\nthis:\n  {y \\<in> set xs - {x}. index xs y < index xs x} =\n  {y \\<in> set xs. index xs y < j}\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "also"], ["proof (state)\nthis:\n  {y \\<in> set xs - {x}. index xs y < index xs x} =\n  {y \\<in> set xs. index xs y < j}\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "have \"\\<dots> = (\\<lambda>i. xs ! i) ` {i. i < j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> set xs. index xs y < j} = (!) xs ` {i. i < j}", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set xs; index xs x < j\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (!) xs ` {i. i < j}\n 2. \\<And>x i. i < j \\<Longrightarrow> xs ! i \\<in> set xs\n 3. \\<And>x i. i < j \\<Longrightarrow> index xs (xs ! i) < j", "fix y"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set xs; index xs x < j\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (!) xs ` {i. i < j}\n 2. \\<And>x i. i < j \\<Longrightarrow> xs ! i \\<in> set xs\n 3. \\<And>x i. i < j \\<Longrightarrow> index xs (xs ! i) < j", "assume \"y \\<in> set xs\" \"index xs y < j\""], ["proof (state)\nthis:\n  y \\<in> set xs\n  index xs y < j\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set xs; index xs x < j\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (!) xs ` {i. i < j}\n 2. \\<And>x i. i < j \\<Longrightarrow> xs ! i \\<in> set xs\n 3. \\<And>x i. i < j \\<Longrightarrow> index xs (xs ! i) < j", "moreover"], ["proof (state)\nthis:\n  y \\<in> set xs\n  index xs y < j\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set xs; index xs x < j\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (!) xs ` {i. i < j}\n 2. \\<And>x i. i < j \\<Longrightarrow> xs ! i \\<in> set xs\n 3. \\<And>x i. i < j \\<Longrightarrow> index xs (xs ! i) < j", "from this and j"], ["proof (chain)\npicking this:\n  y \\<in> set xs\n  index xs y < j\n  j < length xs", "have \"y = xs ! index xs y\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  index xs y < j\n  j < length xs\n\ngoal (1 subgoal):\n 1. y = xs ! index xs y", "by simp"], ["proof (state)\nthis:\n  y = xs ! index xs y\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set xs; index xs x < j\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (!) xs ` {i. i < j}\n 2. \\<And>x i. i < j \\<Longrightarrow> xs ! i \\<in> set xs\n 3. \\<And>x i. i < j \\<Longrightarrow> index xs (xs ! i) < j", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> set xs\n  index xs y < j\n  y = xs ! index xs y", "show \"y \\<in> (!) xs ` {i. i < j}\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  index xs y < j\n  y = xs ! index xs y\n\ngoal (1 subgoal):\n 1. y \\<in> (!) xs ` {i. i < j}", "by blast"], ["proof (state)\nthis:\n  y \\<in> (!) xs ` {i. i < j}\n\ngoal (2 subgoals):\n 1. \\<And>x i. i < j \\<Longrightarrow> xs ! i \\<in> set xs\n 2. \\<And>x i. i < j \\<Longrightarrow> index xs (xs ! i) < j", "qed (insert assms j, auto simp: index_nth_id)"], ["proof (state)\nthis:\n  {y \\<in> set xs. index xs y < j} = (!) xs ` {i. i < j}\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "also"], ["proof (state)\nthis:\n  {y \\<in> set xs. index xs y < j} = (!) xs ` {i. i < j}\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "from assms and j"], ["proof (chain)\npicking this:\n  linorder_on B R\n  set xs \\<subseteq> B\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  distinct xs\n  j < length xs", "have \"card \\<dots> = card {i. i < j}\""], ["proof (prove)\nusing this:\n  linorder_on B R\n  set xs \\<subseteq> B\n  Linorder_Relations.sorted_wrt R xs\n  x \\<in> set xs\n  distinct xs\n  j < length xs\n\ngoal (1 subgoal):\n 1. card ((!) xs ` {i. i < j}) = card {i. i < j}", "by (intro card_image) (auto simp: inj_on_def nth_eq_iff_index_eq)"], ["proof (state)\nthis:\n  card ((!) xs ` {i. i < j}) = card {i. i < j}\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "also"], ["proof (state)\nthis:\n  card ((!) xs ` {i. i < j}) = card {i. i < j}\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "have \"\\<dots> = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {i. i < j} = j", "by simp"], ["proof (state)\nthis:\n  card {i. i < j} = j\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "finally"], ["proof (chain)\npicking this:\n  card {y \\<in> set xs - {x}. (y, x) \\<in> R} = j", "show ?thesis"], ["proof (prove)\nusing this:\n  card {y \\<in> set xs - {x}. (y, x) \\<in> R} = j\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "by (simp only: j_def linorder_rank_def)"], ["proof (state)\nthis:\n  linorder_rank R (set xs) x = index xs x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_linorder_rank:\n  assumes \"linorder_on B R\" \"finite A\" \"A \\<subseteq> B\"\n  shows   \"bij_betw (linorder_rank R A) A {..<card A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (linorder_rank R A) A {..<card A}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw (linorder_rank R A) A {..<card A}", "define xs where \"xs = sorted_wrt_list_of_set R A\""], ["proof (state)\nthis:\n  xs = sorted_wrt_list_of_set R A\n\ngoal (1 subgoal):\n 1. bij_betw (linorder_rank R A) A {..<card A}", "note xs = linorder_sorted_wrt_list_of_set[OF assms, folded xs_def]"], ["proof (state)\nthis:\n  set xs = A\n  distinct xs\n  Linorder_Relations.sorted_wrt R xs\n\ngoal (1 subgoal):\n 1. bij_betw (linorder_rank R A) A {..<card A}", "from \\<open>distinct xs\\<close>"], ["proof (chain)\npicking this:\n  distinct xs", "have len_xs: \"length xs = card A\""], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. length xs = card A", "by (subst \\<open>set xs = A\\<close> [symmetric]) (auto simp: distinct_card)"], ["proof (state)\nthis:\n  length xs = card A\n\ngoal (1 subgoal):\n 1. bij_betw (linorder_rank R A) A {..<card A}", "have rank: \"linorder_rank R (set xs) x = index xs x\" if \"x \\<in> A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "using linorder_rank_set_sorted_wrt[OF assms(1), of xs x] assms that xs"], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs \\<subseteq> B; Linorder_Relations.sorted_wrt R xs;\n   x \\<in> set xs; distinct xs\\<rbrakk>\n  \\<Longrightarrow> linorder_rank R (set xs) x = index xs x\n  linorder_on B R\n  finite A\n  A \\<subseteq> B\n  x \\<in> A\n  set xs = A\n  distinct xs\n  Linorder_Relations.sorted_wrt R xs\n\ngoal (1 subgoal):\n 1. linorder_rank R (set xs) x = index xs x", "by simp_all"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> linorder_rank R (set xs) ?x = index xs ?x\n\ngoal (1 subgoal):\n 1. bij_betw (linorder_rank R A) A {..<card A}", "from xs len_xs"], ["proof (chain)\npicking this:\n  set xs = A\n  distinct xs\n  Linorder_Relations.sorted_wrt R xs\n  length xs = card A", "show ?thesis"], ["proof (prove)\nusing this:\n  set xs = A\n  distinct xs\n  Linorder_Relations.sorted_wrt R xs\n  length xs = card A\n\ngoal (1 subgoal):\n 1. bij_betw (linorder_rank R A) A {..<card A}", "by (intro bij_betw_byWitness[where f' = \"\\<lambda>i. xs ! i\"])\n       (auto simp: rank index_nth_id intro!: nth_mem)"], ["proof (state)\nthis:\n  bij_betw (linorder_rank R A) A {..<card A}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The bijection between linear orderings and lists\\<close>"], ["", "theorem bij_betw_linorder_of_list:\n  assumes \"finite A\"\n  shows   \"bij_betw linorder_of_list (permutations_of_set A) {R. linorder_on A R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw linorder_of_list (permutations_of_set A) {R. linorder_on A R}", "proof (intro bij_betw_byWitness[where f' = \"\\<lambda>R. sorted_wrt_list_of_set R A\"] ballI subsetI,\n       goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a.\n       a \\<in> permutations_of_set A \\<Longrightarrow>\n       sorted_wrt_list_of_set (linorder_of_list a) A = a\n 2. \\<And>a'.\n       a' \\<in> {R. linorder_on A R} \\<Longrightarrow>\n       linorder_of_list (sorted_wrt_list_of_set a' A) = a'\n 3. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 4. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "case (1 xs)"], ["proof (state)\nthis:\n  xs \\<in> permutations_of_set A\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       a \\<in> permutations_of_set A \\<Longrightarrow>\n       sorted_wrt_list_of_set (linorder_of_list a) A = a\n 2. \\<And>a'.\n       a' \\<in> {R. linorder_on A R} \\<Longrightarrow>\n       linorder_of_list (sorted_wrt_list_of_set a' A) = a'\n 3. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 4. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "thus ?case"], ["proof (prove)\nusing this:\n  xs \\<in> permutations_of_set A\n\ngoal (1 subgoal):\n 1. sorted_wrt_list_of_set (linorder_of_list xs) A = xs", "by (intro sorted_wrt_list_of_set_eqI) (auto simp: permutations_of_set_def)"], ["proof (state)\nthis:\n  sorted_wrt_list_of_set (linorder_of_list xs) A = xs\n\ngoal (3 subgoals):\n 1. \\<And>a'.\n       a' \\<in> {R. linorder_on A R} \\<Longrightarrow>\n       linorder_of_list (sorted_wrt_list_of_set a' A) = a'\n 2. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 3. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a'.\n       a' \\<in> {R. linorder_on A R} \\<Longrightarrow>\n       linorder_of_list (sorted_wrt_list_of_set a' A) = a'\n 2. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 3. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "case (2 R)"], ["proof (state)\nthis:\n  R \\<in> {R. linorder_on A R}\n\ngoal (3 subgoals):\n 1. \\<And>a'.\n       a' \\<in> {R. linorder_on A R} \\<Longrightarrow>\n       linorder_of_list (sorted_wrt_list_of_set a' A) = a'\n 2. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 3. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "hence R: \"linorder_on A R\""], ["proof (prove)\nusing this:\n  R \\<in> {R. linorder_on A R}\n\ngoal (1 subgoal):\n 1. linorder_on A R", "by simp"], ["proof (state)\nthis:\n  linorder_on A R\n\ngoal (3 subgoals):\n 1. \\<And>a'.\n       a' \\<in> {R. linorder_on A R} \\<Longrightarrow>\n       linorder_of_list (sorted_wrt_list_of_set a' A) = a'\n 2. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 3. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "from R"], ["proof (chain)\npicking this:\n  linorder_on A R", "have in_R: \"x \\<in> A\" \"y \\<in> A\" if \"(x,y) \\<in> R\" for x y"], ["proof (prove)\nusing this:\n  linorder_on A R\n\ngoal (1 subgoal):\n 1. x \\<in> A &&& y \\<in> A", "using that"], ["proof (prove)\nusing this:\n  linorder_on A R\n  (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. x \\<in> A &&& y \\<in> A", "by (auto simp: linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> R \\<Longrightarrow> ?x \\<in> A\n  (?x, ?y) \\<in> R \\<Longrightarrow> ?y \\<in> A\n\ngoal (3 subgoals):\n 1. \\<And>a'.\n       a' \\<in> {R. linorder_on A R} \\<Longrightarrow>\n       linorder_of_list (sorted_wrt_list_of_set a' A) = a'\n 2. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 3. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "let ?xs = \"sorted_wrt_list_of_set R A\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a'.\n       a' \\<in> {R. linorder_on A R} \\<Longrightarrow>\n       linorder_of_list (sorted_wrt_list_of_set a' A) = a'\n 2. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 3. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "have xs: \"distinct ?xs\" \"set ?xs = A\" \"sorted_wrt R ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (sorted_wrt_list_of_set R A) &&&\n    set (sorted_wrt_list_of_set R A) = A &&&\n    Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)", "by (rule linorder_sorted_wrt_list_of_set[OF R] assms order.refl)+"], ["proof (state)\nthis:\n  distinct (sorted_wrt_list_of_set R A)\n  set (sorted_wrt_list_of_set R A) = A\n  Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n\ngoal (3 subgoals):\n 1. \\<And>a'.\n       a' \\<in> {R. linorder_on A R} \\<Longrightarrow>\n       linorder_of_list (sorted_wrt_list_of_set a' A) = a'\n 2. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 3. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (sorted_wrt_list_of_set R A)\n  set (sorted_wrt_list_of_set R A) = A\n  Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n\ngoal (1 subgoal):\n 1. linorder_of_list (sorted_wrt_list_of_set R A) = R", "using sorted_wrt_linorder_index_le_iff[OF R, of ?xs]"], ["proof (prove)\nusing this:\n  distinct (sorted_wrt_list_of_set R A)\n  set (sorted_wrt_list_of_set R A) = A\n  Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n  \\<lbrakk>set (sorted_wrt_list_of_set R A) \\<subseteq> A;\n   Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A);\n   ?x \\<in> set (sorted_wrt_list_of_set R A);\n   ?y \\<in> set (sorted_wrt_list_of_set R A)\\<rbrakk>\n  \\<Longrightarrow> (index (sorted_wrt_list_of_set R A) ?x\n                     \\<le> index (sorted_wrt_list_of_set R A) ?y) =\n                    ((?x, ?y) \\<in> R)\n\ngoal (1 subgoal):\n 1. linorder_of_list (sorted_wrt_list_of_set R A) = R", "by (auto simp: linorder_of_list_def dest: in_R)"], ["proof (state)\nthis:\n  linorder_of_list (sorted_wrt_list_of_set R A) = R\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "case (4 xs)"], ["proof (state)\nthis:\n  xs \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) ` {R. linorder_on A R}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "then"], ["proof (chain)\npicking this:\n  xs \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) ` {R. linorder_on A R}", "obtain R where R: \"linorder_on A R\" and xs [simp]: \"xs = sorted_wrt_list_of_set R A\""], ["proof (prove)\nusing this:\n  xs \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) ` {R. linorder_on A R}\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>linorder_on A R; xs = sorted_wrt_list_of_set R A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  linorder_on A R\n  xs = sorted_wrt_list_of_set R A\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "let ?xs = \"sorted_wrt_list_of_set R A\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "have xs: \"distinct ?xs\" \"set ?xs = A\" \"sorted_wrt R ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (sorted_wrt_list_of_set R A) &&&\n    set (sorted_wrt_list_of_set R A) = A &&&\n    Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)", "by (rule linorder_sorted_wrt_list_of_set[OF R] assms order.refl)+"], ["proof (state)\nthis:\n  distinct (sorted_wrt_list_of_set R A)\n  set (sorted_wrt_list_of_set R A) = A\n  Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>R. sorted_wrt_list_of_set R A) `\n               {R. linorder_on A R} \\<Longrightarrow>\n       x \\<in> permutations_of_set A", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (sorted_wrt_list_of_set R A)\n  set (sorted_wrt_list_of_set R A) = A\n  Linorder_Relations.sorted_wrt R (sorted_wrt_list_of_set R A)\n\ngoal (1 subgoal):\n 1. xs \\<in> permutations_of_set A", "by auto"], ["proof (state)\nthis:\n  xs \\<in> permutations_of_set A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> linorder_of_list ` permutations_of_set A \\<Longrightarrow>\n       x \\<in> {R. linorder_on A R}", "qed (auto simp: permutations_of_set_def)"], ["", "corollary card_finite_linorders:\n  assumes \"finite A\"\n  shows   \"card {R. linorder_on A R} = fact (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {R. linorder_on A R} = fact (card A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card {R. linorder_on A R} = fact (card A)", "have \"card {R. linorder_on A R} = card (permutations_of_set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {R. linorder_on A R} = card (permutations_of_set A)", "by (rule sym, rule bij_betw_same_card [OF bij_betw_linorder_of_list[OF assms]])"], ["proof (state)\nthis:\n  card {R. linorder_on A R} = card (permutations_of_set A)\n\ngoal (1 subgoal):\n 1. card {R. linorder_on A R} = fact (card A)", "also"], ["proof (state)\nthis:\n  card {R. linorder_on A R} = card (permutations_of_set A)\n\ngoal (1 subgoal):\n 1. card {R. linorder_on A R} = fact (card A)", "from assms"], ["proof (chain)\npicking this:\n  finite A", "have \"\\<dots> = fact (card A)\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. card (permutations_of_set A) = fact (card A)", "by (rule card_permutations_of_set)"], ["proof (state)\nthis:\n  card (permutations_of_set A) = fact (card A)\n\ngoal (1 subgoal):\n 1. card {R. linorder_on A R} = fact (card A)", "finally"], ["proof (chain)\npicking this:\n  card {R. linorder_on A R} = fact (card A)", "show ?thesis"], ["proof (prove)\nusing this:\n  card {R. linorder_on A R} = fact (card A)\n\ngoal (1 subgoal):\n 1. card {R. linorder_on A R} = fact (card A)", "."], ["proof (state)\nthis:\n  card {R. linorder_on A R} = fact (card A)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}