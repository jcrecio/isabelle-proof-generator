{"file_name": "/home/qj213/afp-2021-10-22/thys/FinFun/FinFunPred.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FinFun", "problem_names": ["lemma le_finfun_code [code]:\n  \"f \\<le> g \\<longleftrightarrow> finfun_All ((\\<lambda>(x, y). x \\<le> y) \\<circ>$ ($f, g$))\"", "lemma bot_finfun_apply [simp]: \"($) bot = (\\<lambda>_. bot)\"", "lemma top_finfun_apply [simp]: \"($) top = (\\<lambda>_. top)\"", "lemma inf_finfun_apply [simp]: \"($) (inf f g) = inf (($) f) (($) g)\"", "lemma sup_finfun_apply [simp]: \"($) (sup f g) = sup (($) f) (($) g)\"", "lemma minus_finfun_apply [simp]: \"($) (f - g) = ($) f - ($) g\"", "lemma uminus_finfun_apply [simp]: \"($) (- g) = - ($) g\"", "lemma finfun_single_apply [simp]:\n  \"finfun_single x $ y \\<longleftrightarrow> x = y\"", "lemma [iff]:\n  shows finfun_single_neq_bot: \"finfun_single x \\<noteq> bot\" \n  and bot_neq_finfun_single: \"bot \\<noteq> finfun_single x\"", "lemma finfun_leI [intro!]: \"(!!x. A $ x \\<Longrightarrow> B $ x) \\<Longrightarrow> A \\<le> B\"", "lemma finfun_leD [elim]: \"\\<lbrakk> A \\<le> B; A $ x \\<rbrakk> \\<Longrightarrow> B $ x\"", "lemma finfun_Ball_except_const:\n  \"finfun_Ball_except xs (K$ b) P \\<longleftrightarrow> \\<not> b \\<or> set xs = UNIV \\<or> Code.abort (STR ''finfun_ball_except'') (\\<lambda>u. finfun_Ball_except xs (K$ b) P)\"", "lemma finfun_Ball_except_const_finfun_UNIV_code [code]:\n  \"finfun_Ball_except xs (K$ b) P \\<longleftrightarrow> \\<not> b \\<or> is_list_UNIV xs \\<or> Code.abort (STR ''finfun_ball_except'') (\\<lambda>u. finfun_Ball_except xs (K$ b) P)\"", "lemma finfun_Ball_except_update:\n  \"finfun_Ball_except xs (A(a $:= b)) P = ((a \\<in> set xs \\<or> (b \\<longrightarrow> P a)) \\<and> finfun_Ball_except (a # xs) A P)\"", "lemma finfun_Ball_except_update_code [code]:\n  fixes a :: \"'a :: card_UNIV\"\n  shows \"finfun_Ball_except xs (finfun_update_code f a b) P = ((a \\<in> set xs \\<or> (b \\<longrightarrow> P a)) \\<and> finfun_Ball_except (a # xs) f P)\"", "lemma finfun_Ball_code [code]: \"finfun_Ball = finfun_Ball_except []\"", "lemma finfun_Bex_except_const:\n  \"finfun_Bex_except xs (K$ b) P \\<longleftrightarrow> b \\<and> set xs \\<noteq> UNIV \\<and> Code.abort (STR ''finfun_Bex_except'') (\\<lambda>u. finfun_Bex_except xs (K$ b) P)\"", "lemma finfun_Bex_except_const_finfun_UNIV_code [code]:\n  \"finfun_Bex_except xs (K$ b) P \\<longleftrightarrow> b \\<and> \\<not> is_list_UNIV xs \\<and> Code.abort (STR ''finfun_Bex_except'') (\\<lambda>u. finfun_Bex_except xs (K$ b) P)\"", "lemma finfun_Bex_except_update: \n  \"finfun_Bex_except xs (A(a $:= b)) P \\<longleftrightarrow> (a \\<notin> set xs \\<and> b \\<and> P a) \\<or> finfun_Bex_except (a # xs) A P\"", "lemma finfun_Bex_except_update_code [code]:\n  fixes a :: \"'a :: card_UNIV\"\n  shows \"finfun_Bex_except xs (finfun_update_code f a b) P \\<longleftrightarrow> ((a \\<notin> set xs \\<and> b \\<and> P a) \\<or> finfun_Bex_except (a # xs) f P)\"", "lemma finfun_Bex_code [code]: \"finfun_Bex = finfun_Bex_except []\"", "lemma iso_finfun_le [code_unfold]:\n  \"($) A \\<le> ($) B \\<longleftrightarrow> A \\<le> B\"", "lemma iso_finfun_less [code_unfold]:\n  \"($) A < ($) B \\<longleftrightarrow> A < B\"", "lemma iso_finfun_eq [code_unfold]:\n  \"($) A = ($) B \\<longleftrightarrow> A = B\"", "lemma iso_finfun_sup [code_unfold]:\n  \"sup (($) A) (($) B) = ($) (sup A B)\"", "lemma iso_finfun_disj [code_unfold]:\n  \"A $ x \\<or> B $ x \\<longleftrightarrow> sup A B $ x\"", "lemma iso_finfun_inf [code_unfold]:\n  \"inf (($) A) (($) B) = ($) (inf A B)\"", "lemma iso_finfun_conj [code_unfold]:\n  \"A $ x \\<and> B $ x \\<longleftrightarrow> inf A B $ x\"", "lemma iso_finfun_empty_conv [code_unfold]:\n  \"(\\<lambda>_. False) = ($) {}\\<^sub>f\"", "lemma iso_finfun_UNIV_conv [code_unfold]:\n  \"(\\<lambda>_. True) = ($) finfun_UNIV\"", "lemma iso_finfun_upd [code_unfold]:\n  fixes A :: \"'a pred\\<^sub>f\"\n  shows \"(($) A)(x := b) = ($) (A(x $:= b))\"", "lemma iso_finfun_uminus [code_unfold]:\n  fixes A :: \"'a pred\\<^sub>f\"\n  shows \"- ($) A = ($) (- A)\"", "lemma iso_finfun_minus [code_unfold]:\n  fixes A :: \"'a pred\\<^sub>f\"\n  shows \"($) A - ($) B = ($) (A - B)\"", "lemma iso_finfun_Ball_Ball:\n  \"(\\<forall>x. A $ x \\<longrightarrow> P x) \\<longleftrightarrow> finfun_Ball A P\"", "lemma iso_finfun_Bex_Bex:\n  \"(\\<exists>x. A $ x \\<and> P x) \\<longleftrightarrow> finfun_Bex A P\""], "translations": [["", "lemma le_finfun_code [code]:\n  \"f \\<le> g \\<longleftrightarrow> finfun_All ((\\<lambda>(x, y). x \\<le> y) \\<circ>$ ($f, g$))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<le> g) =\n    finfun_All ((\\<lambda>(x, y). x \\<le> y) \\<circ>$ ($f, g$))", "by(simp add: le_finfun_def finfun_All_All o_def)"], ["", "end"], ["", "instance \"finfun\" :: (type, preorder) preorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, preorder_class)", "by(intro_classes)(auto simp add: less_finfun_def le_finfun_def intro: order_trans)"], ["", "instance \"finfun\" :: (type, order) order"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, order_class)", "by(intro_classes)(auto simp add: le_finfun_def order_antisym_conv intro: finfun_ext)"], ["", "instantiation \"finfun\" :: (type, order_bot) order_bot begin"], ["", "definition \"bot = finfun_const bot\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, order_bot_class)", "by(intro_classes)(simp add: bot_finfun_def le_finfun_def)"], ["", "end"], ["", "lemma bot_finfun_apply [simp]: \"($) bot = (\\<lambda>_. bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) bot = (\\<lambda>_. bot)", "by(auto simp add: bot_finfun_def)"], ["", "instantiation \"finfun\" :: (type, order_top) order_top begin"], ["", "definition \"top = finfun_const top\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, order_top_class)", "by(intro_classes)(simp add: top_finfun_def le_finfun_def)"], ["", "end"], ["", "lemma top_finfun_apply [simp]: \"($) top = (\\<lambda>_. top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) top = (\\<lambda>_. top)", "by(auto simp add: top_finfun_def)"], ["", "instantiation \"finfun\" :: (type, inf) inf begin"], ["", "definition [code]: \"inf f g = (\\<lambda>(x, y). inf x y) \\<circ>$ ($f, g$)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, inf_class)", ".."], ["", "end"], ["", "lemma inf_finfun_apply [simp]: \"($) (inf f g) = inf (($) f) (($) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (inf f g) = inf (($) f) (($) g)", "by(auto simp add: inf_finfun_def o_def inf_fun_def)"], ["", "instantiation \"finfun\" :: (type, sup) sup begin"], ["", "definition [code]: \"sup f g = (\\<lambda>(x, y). sup x y) \\<circ>$ ($f, g$)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, sup_class)", ".."], ["", "end"], ["", "lemma sup_finfun_apply [simp]: \"($) (sup f g) = sup (($) f) (($) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (sup f g) = sup (($) f) (($) g)", "by(auto simp add: sup_finfun_def o_def sup_fun_def)"], ["", "instance \"finfun\" :: (type, semilattice_inf) semilattice_inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, semilattice_inf_class)", "by(intro_classes)(simp_all add: inf_finfun_def le_finfun_def)"], ["", "instance \"finfun\" :: (type, semilattice_sup) semilattice_sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, semilattice_sup_class)", "by(intro_classes)(simp_all add: sup_finfun_def le_finfun_def)"], ["", "instance \"finfun\" :: (type, lattice) lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, lattice_class)", ".."], ["", "instance \"finfun\" :: (type, bounded_lattice) bounded_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, bounded_lattice_class)", "by(intro_classes)"], ["", "instance \"finfun\" :: (type, distrib_lattice) distrib_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, distrib_lattice_class)", "by(intro_classes)(simp add: sup_finfun_def inf_finfun_def expand_finfun_eq o_def sup_inf_distrib1)"], ["", "instantiation \"finfun\" :: (type, minus) minus begin"], ["", "definition \"f - g = case_prod (-) \\<circ>$ ($f, g$)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, minus_class)", ".."], ["", "end"], ["", "lemma minus_finfun_apply [simp]: \"($) (f - g) = ($) f - ($) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (f - g) = ($) f - ($) g", "by(simp add: minus_finfun_def o_def fun_diff_def)"], ["", "instantiation \"finfun\" :: (type, uminus) uminus begin"], ["", "definition \"- A = uminus \\<circ>$ A\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, uminus_class)", ".."], ["", "end"], ["", "lemma uminus_finfun_apply [simp]: \"($) (- g) = - ($) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (- g) = - ($) g", "by(simp add: uminus_finfun_def o_def fun_Compl_def)"], ["", "instance \"finfun\" :: (type, boolean_algebra) boolean_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, boolean_algebra_class)", "by(intro_classes)\n  (simp_all add: uminus_finfun_def inf_finfun_def expand_finfun_eq sup_fun_def inf_fun_def fun_Compl_def o_def inf_compl_bot sup_compl_top diff_eq)"], ["", "text \\<open>\n  Replicate predicate operations for FinFuns\n\\<close>"], ["", "abbreviation finfun_empty :: \"'a pred\\<^sub>f\" (\"{}\\<^sub>f\")\nwhere \"{}\\<^sub>f \\<equiv> bot\""], ["", "abbreviation finfun_UNIV :: \"'a pred\\<^sub>f\" \nwhere \"finfun_UNIV \\<equiv> top\""], ["", "definition finfun_single :: \"'a \\<Rightarrow> 'a pred\\<^sub>f\"\nwhere [code]: \"finfun_single x = finfun_empty(x $:= True)\""], ["", "lemma finfun_single_apply [simp]:\n  \"finfun_single x $ y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_single x $ y = (x = y)", "by(simp add: finfun_single_def finfun_upd_apply)"], ["", "lemma [iff]:\n  shows finfun_single_neq_bot: \"finfun_single x \\<noteq> bot\" \n  and bot_neq_finfun_single: \"bot \\<noteq> finfun_single x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_single x \\<noteq> {}\\<^sub>f &&&\n    {}\\<^sub>f \\<noteq> finfun_single x", "by(simp_all add: expand_finfun_eq fun_eq_iff)"], ["", "lemma finfun_leI [intro!]: \"(!!x. A $ x \\<Longrightarrow> B $ x) \\<Longrightarrow> A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. A $ x \\<Longrightarrow> B $ x) \\<Longrightarrow> A \\<le> B", "by(simp add: le_finfun_def)"], ["", "lemma finfun_leD [elim]: \"\\<lbrakk> A \\<le> B; A $ x \\<rbrakk> \\<Longrightarrow> B $ x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<le> B; A $ x\\<rbrakk> \\<Longrightarrow> B $ x", "by(simp add: le_finfun_def)"], ["", "text \\<open>Bounded quantification.\n  Warning: \\<open>finfun_Ball\\<close> and \\<open>finfun_Ex\\<close> may raise an exception, they should not be used for quickcheck\n\\<close>"], ["", "definition finfun_Ball_except :: \"'a list \\<Rightarrow> 'a pred\\<^sub>f \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\"\nwhere [code del]: \"finfun_Ball_except xs A P = (\\<forall>a. A $ a \\<longrightarrow> a \\<in> set xs \\<or> P a)\""], ["", "lemma finfun_Ball_except_const:\n  \"finfun_Ball_except xs (K$ b) P \\<longleftrightarrow> \\<not> b \\<or> set xs = UNIV \\<or> Code.abort (STR ''finfun_ball_except'') (\\<lambda>u. finfun_Ball_except xs (K$ b) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Ball_except xs (K$ b) P =\n    (\\<not> b \\<or>\n     set xs = UNIV \\<or>\n     Code.abort STR ''finfun_ball_except''\n      (\\<lambda>u. finfun_Ball_except xs (K$ b) P))", "by(auto simp add: finfun_Ball_except_def)"], ["", "lemma finfun_Ball_except_const_finfun_UNIV_code [code]:\n  \"finfun_Ball_except xs (K$ b) P \\<longleftrightarrow> \\<not> b \\<or> is_list_UNIV xs \\<or> Code.abort (STR ''finfun_ball_except'') (\\<lambda>u. finfun_Ball_except xs (K$ b) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Ball_except xs (K$ b) P =\n    (\\<not> b \\<or>\n     is_list_UNIV xs \\<or>\n     Code.abort STR ''finfun_ball_except''\n      (\\<lambda>u. finfun_Ball_except xs (K$ b) P))", "by(auto simp add: finfun_Ball_except_def is_list_UNIV_iff)"], ["", "lemma finfun_Ball_except_update:\n  \"finfun_Ball_except xs (A(a $:= b)) P = ((a \\<in> set xs \\<or> (b \\<longrightarrow> P a)) \\<and> finfun_Ball_except (a # xs) A P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Ball_except xs A(a $:= b) P =\n    ((a \\<in> set xs \\<or> (b \\<longrightarrow> P a)) \\<and>\n     finfun_Ball_except (a # xs) A P)", "by(fastforce simp add: finfun_Ball_except_def finfun_upd_apply split: if_split_asm)"], ["", "lemma finfun_Ball_except_update_code [code]:\n  fixes a :: \"'a :: card_UNIV\"\n  shows \"finfun_Ball_except xs (finfun_update_code f a b) P = ((a \\<in> set xs \\<or> (b \\<longrightarrow> P a)) \\<and> finfun_Ball_except (a # xs) f P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Ball_except xs (finfun_update_code f a b) P =\n    ((a \\<in> set xs \\<or> (b \\<longrightarrow> P a)) \\<and>\n     finfun_Ball_except (a # xs) f P)", "by(simp add: finfun_Ball_except_update)"], ["", "definition finfun_Ball :: \"'a pred\\<^sub>f \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\"\nwhere [code del]: \"finfun_Ball A P = Ball {x. A $ x} P\""], ["", "lemma finfun_Ball_code [code]: \"finfun_Ball = finfun_Ball_except []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Ball = finfun_Ball_except []", "by(auto intro!: ext simp add: finfun_Ball_except_def finfun_Ball_def)"], ["", "definition finfun_Bex_except :: \"'a list \\<Rightarrow> 'a pred\\<^sub>f \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\"\nwhere [code del]: \"finfun_Bex_except xs A P = (\\<exists>a. A $ a \\<and> a \\<notin> set xs \\<and> P a)\""], ["", "lemma finfun_Bex_except_const:\n  \"finfun_Bex_except xs (K$ b) P \\<longleftrightarrow> b \\<and> set xs \\<noteq> UNIV \\<and> Code.abort (STR ''finfun_Bex_except'') (\\<lambda>u. finfun_Bex_except xs (K$ b) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Bex_except xs (K$ b) P =\n    (b \\<and>\n     set xs \\<noteq> UNIV \\<and>\n     Code.abort STR ''finfun_Bex_except''\n      (\\<lambda>u. finfun_Bex_except xs (K$ b) P))", "by(auto simp add: finfun_Bex_except_def)"], ["", "lemma finfun_Bex_except_const_finfun_UNIV_code [code]:\n  \"finfun_Bex_except xs (K$ b) P \\<longleftrightarrow> b \\<and> \\<not> is_list_UNIV xs \\<and> Code.abort (STR ''finfun_Bex_except'') (\\<lambda>u. finfun_Bex_except xs (K$ b) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Bex_except xs (K$ b) P =\n    (b \\<and>\n     \\<not> is_list_UNIV xs \\<and>\n     Code.abort STR ''finfun_Bex_except''\n      (\\<lambda>u. finfun_Bex_except xs (K$ b) P))", "by(auto simp add: finfun_Bex_except_def is_list_UNIV_iff)"], ["", "lemma finfun_Bex_except_update: \n  \"finfun_Bex_except xs (A(a $:= b)) P \\<longleftrightarrow> (a \\<notin> set xs \\<and> b \\<and> P a) \\<or> finfun_Bex_except (a # xs) A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Bex_except xs A(a $:= b) P =\n    (a \\<notin> set xs \\<and> b \\<and> P a \\<or>\n     finfun_Bex_except (a # xs) A P)", "by(fastforce simp add: finfun_Bex_except_def finfun_upd_apply dest: bspec split: if_split_asm)"], ["", "lemma finfun_Bex_except_update_code [code]:\n  fixes a :: \"'a :: card_UNIV\"\n  shows \"finfun_Bex_except xs (finfun_update_code f a b) P \\<longleftrightarrow> ((a \\<notin> set xs \\<and> b \\<and> P a) \\<or> finfun_Bex_except (a # xs) f P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Bex_except xs (finfun_update_code f a b) P =\n    (a \\<notin> set xs \\<and> b \\<and> P a \\<or>\n     finfun_Bex_except (a # xs) f P)", "by(simp add: finfun_Bex_except_update)"], ["", "definition finfun_Bex :: \"'a pred\\<^sub>f \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\"\nwhere [code del]: \"finfun_Bex A P = Bex {x. A $ x} P\""], ["", "lemma finfun_Bex_code [code]: \"finfun_Bex = finfun_Bex_except []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Bex = finfun_Bex_except []", "by(auto intro!: ext simp add: finfun_Bex_except_def finfun_Bex_def)"], ["", "text \\<open>Automatically replace predicate operations by finfun predicate operations where possible\\<close>"], ["", "lemma iso_finfun_le [code_unfold]:\n  \"($) A \\<le> ($) B \\<longleftrightarrow> A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (($) A \\<le> ($) B) = (A \\<le> B)", "by (metis le_finfun_def le_funD le_funI)"], ["", "lemma iso_finfun_less [code_unfold]:\n  \"($) A < ($) B \\<longleftrightarrow> A < B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (($) A < ($) B) = (A < B)", "by (metis iso_finfun_le less_finfun_def less_fun_def)"], ["", "lemma iso_finfun_eq [code_unfold]:\n  \"($) A = ($) B \\<longleftrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (($) A = ($) B) = (A = B)", "by(simp only: expand_finfun_eq)"], ["", "lemma iso_finfun_sup [code_unfold]:\n  \"sup (($) A) (($) B) = ($) (sup A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup (($) A) (($) B) = ($) (sup A B)", "by(simp)"], ["", "lemma iso_finfun_disj [code_unfold]:\n  \"A $ x \\<or> B $ x \\<longleftrightarrow> sup A B $ x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A $ x \\<or> B $ x) = sup A B $ x", "by(simp add: sup_fun_def)"], ["", "lemma iso_finfun_inf [code_unfold]:\n  \"inf (($) A) (($) B) = ($) (inf A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf (($) A) (($) B) = ($) (inf A B)", "by(simp)"], ["", "lemma iso_finfun_conj [code_unfold]:\n  \"A $ x \\<and> B $ x \\<longleftrightarrow> inf A B $ x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A $ x \\<and> B $ x) = inf A B $ x", "by(simp add: inf_fun_def)"], ["", "lemma iso_finfun_empty_conv [code_unfold]:\n  \"(\\<lambda>_. False) = ($) {}\\<^sub>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. False) = ($) {}\\<^sub>f", "by simp"], ["", "lemma iso_finfun_UNIV_conv [code_unfold]:\n  \"(\\<lambda>_. True) = ($) finfun_UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. True) = ($) finfun_UNIV", "by simp"], ["", "lemma iso_finfun_upd [code_unfold]:\n  fixes A :: \"'a pred\\<^sub>f\"\n  shows \"(($) A)(x := b) = ($) (A(x $:= b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (($) A)(x := b) = ($) A(x $:= b)", "by(simp add: fun_eq_iff)"], ["", "lemma iso_finfun_uminus [code_unfold]:\n  fixes A :: \"'a pred\\<^sub>f\"\n  shows \"- ($) A = ($) (- A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ($) A = ($) (- A)", "by(simp)"], ["", "lemma iso_finfun_minus [code_unfold]:\n  fixes A :: \"'a pred\\<^sub>f\"\n  shows \"($) A - ($) B = ($) (A - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) A - ($) B = ($) (A - B)", "by(simp)"], ["", "text \\<open>\n  Do not declare the following two theorems as \\<open>[code_unfold]\\<close>,\n  because this causes quickcheck to fail frequently when bounded quantification is used which raises an exception.\n  For code generation, the same problems occur, but then, no randomly generated FinFun is usually around.\n\\<close>"], ["", "lemma iso_finfun_Ball_Ball:\n  \"(\\<forall>x. A $ x \\<longrightarrow> P x) \\<longleftrightarrow> finfun_Ball A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. A $ x \\<longrightarrow> P x) = finfun_Ball A P", "by(simp add: finfun_Ball_def)"], ["", "lemma iso_finfun_Bex_Bex:\n  \"(\\<exists>x. A $ x \\<and> P x) \\<longleftrightarrow> finfun_Bex A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. A $ x \\<and> P x) = finfun_Bex A P", "by(simp add: finfun_Bex_def)"], ["", "text \\<open>Test code setup\\<close>"], ["", "notepad begin"], ["proof (state)", "have \"inf ((\\<lambda>_ :: nat. False)(1 := True, 2 := True)) ((\\<lambda>_. True)(3 := False)) \\<le> \n      sup ((\\<lambda>_. False)(1 := True, 5 := True)) (- ((\\<lambda>_. True)(2 := False, 3 := False)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf ((\\<lambda>_. False)(1 := True, 2 := True))\n     ((\\<lambda>_. True)(3 := False))\n    \\<le> sup ((\\<lambda>_. False)(1 := True, 5 := True))\n           (- (\\<lambda>_. True)(2 := False, 3 := False))", "by eval"], ["proof (state)\nthis:\n  inf ((\\<lambda>_. False)(1 := True, 2 := True))\n   ((\\<lambda>_. True)(3 := False))\n  \\<le> sup ((\\<lambda>_. False)(1 := True, 5 := True))\n         (- (\\<lambda>_. True)(2 := False, 3 := False))", "end"], ["", "declare iso_finfun_Ball_Ball[code_unfold]"], ["", "notepad begin"], ["proof (state)", "have \"(\\<forall>x. ((\\<lambda>_ :: nat. False)(1 := True, 2 := True)) x \\<longrightarrow> x < 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<lambda>_. False)(1 := True, 2 := True)) x \\<longrightarrow> x < 3", "by eval"], ["proof (state)\nthis:\n  \\<forall>x.\n     ((\\<lambda>_. False)(1 := True, 2 := True)) x \\<longrightarrow> x < 3", "end"], ["", "declare iso_finfun_Ball_Ball[code_unfold del]"], ["", "end"]]}