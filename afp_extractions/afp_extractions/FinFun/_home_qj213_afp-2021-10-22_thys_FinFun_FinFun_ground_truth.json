{"file_name": "/home/qj213/afp-2021-10-22/thys/FinFun/FinFun.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FinFun", "problem_names": ["lemma map_default_delete [simp]:\n  \"map_default b (f(a := None)) = (map_default b f)(a := b)\"", "lemma map_default_insert:\n  \"map_default b (f(a \\<mapsto> b')) = (map_default b f)(a := b')\"", "lemma map_default_empty [simp]: \"map_default b Map.empty = (\\<lambda>a. b)\"", "lemma map_default_inject:\n  fixes g g' :: \"'a \\<rightharpoonup> 'b\"\n  assumes infin_eq: \"\\<not> finite (UNIV :: 'a set) \\<or> b = b'\"\n  and fin: \"finite (dom g)\" and b: \"b \\<notin> ran g\"\n  and fin': \"finite (dom g')\" and b': \"b' \\<notin> ran g'\"\n  and eq': \"map_default b g = map_default b' g'\"\n  shows \"b = b'\" \"g = g'\"", "lemma fun_upd_finfun: \"y(a := b) \\<in> finfun \\<longleftrightarrow> y \\<in> finfun\"", "lemma const_finfun: \"(\\<lambda>x. a) \\<in> finfun\"", "lemma finfun_left_compose:\n  assumes \"y \\<in> finfun\"\n  shows \"g \\<circ> y \\<in> finfun\"", "lemma assumes \"y \\<in> finfun\"\n  shows fst_finfun: \"fst \\<circ> y \\<in> finfun\"\n  and snd_finfun: \"snd \\<circ> y \\<in> finfun\"", "lemma map_of_finfun: \"map_of xs \\<in> finfun\"", "lemma Diag_finfun: \"(\\<lambda>x. (f x, g x)) \\<in> finfun \\<longleftrightarrow> f \\<in> finfun \\<and> g \\<in> finfun\"", "lemma finfun_right_compose:\n  assumes g: \"g \\<in> finfun\" and inj: \"inj f\"\n  shows \"g o f \\<in> finfun\"", "lemma finfun_curry:\n  assumes fin: \"f \\<in> finfun\"\n  shows \"curry f \\<in> finfun\" \"curry f a \\<in> finfun\"", "lemmas [simp] =\n  fst_finfun snd_finfun Abs_finfun_inverse\n  finfun_apply_inverse Abs_finfun_inject finfun_apply_inject\n  Diag_finfun finfun_curry", "lemmas [iff] =\n  const_finfun fun_upd_finfun finfun_apply map_of_finfun", "lemmas [intro] =\n  finfun_left_compose fst_finfun snd_finfun", "lemma Abs_finfun_inject_finite:\n  fixes x y :: \"'a \\<Rightarrow> 'b\"\n  assumes fin: \"finite (UNIV :: 'a set)\"\n  shows \"Abs_finfun x = Abs_finfun y \\<longleftrightarrow> x = y\"", "lemma Abs_finfun_inject_finite_class:\n  fixes x y :: \"('a :: finite) \\<Rightarrow> 'b\"\n  shows \"Abs_finfun x = Abs_finfun y \\<longleftrightarrow> x = y\"", "lemma Abs_finfun_inj_finite:\n  assumes fin: \"finite (UNIV :: 'a set)\"\n  shows \"inj (Abs_finfun :: ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow>f 'b)\"", "lemma Abs_finfun_inverse_finite:\n  fixes x :: \"'a \\<Rightarrow> 'b\"\n  assumes fin: \"finite (UNIV :: 'a set)\"\n  shows \"finfun_apply (Abs_finfun x) = x\"", "lemma Abs_finfun_inverse_finite_class:\n  fixes x :: \"('a :: finite) \\<Rightarrow> 'b\"\n  shows \"finfun_apply (Abs_finfun x) = x\"", "lemma finfun_eq_finite_UNIV: \"finite (UNIV :: 'a set) \\<Longrightarrow> (finfun :: ('a \\<Rightarrow> 'b) set) = UNIV\"", "lemma finfun_finite_UNIV_class: \"finfun = (UNIV :: ('a :: finite \\<Rightarrow> 'b) set)\"", "lemma map_default_in_finfun:\n  assumes fin: \"finite (dom f)\"\n  shows \"map_default b f \\<in> finfun\"", "lemma finfun_cases_map_default:\n  obtains b g where \"f = Abs_finfun (map_default b g)\" \"finite (dom g)\" \"b \\<notin> ran g\"", "lemma finfun_update_twist: \"a \\<noteq> a' \\<Longrightarrow> f(a $:= b)(a' $:= b') = f(a' $:= b')(a $:= b)\"", "lemma finfun_update_twice [simp]:\n  \"f(a $:= b)(a $:= b') = f(a $:= b')\"", "lemma finfun_update_const_same: \"(K$ b)(a $:= b) = (K$ b)\"", "lemma finfun_update_const_code [code]:\n  \"(K$ b)(a $:= b') = (if b = b' then (K$ b) else finfun_update_code (K$ b) a b')\"", "lemma finfun_update_update_code [code]:\n  \"(finfun_update_code f a b)(a' $:= b') = (if a = a' then f(a $:= b') else finfun_update_code (f(a' $:= b')) a b)\"", "lemma fold_finfun_update_finite_univ:\n  assumes fin: \"finite (UNIV :: 'a set)\"\n  shows \"Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) (UNIV :: 'a set) = (K$ b')\"", "lemma finfun_default_aux_infinite:\n  fixes f :: \"'a \\<Rightarrow> 'b\"\n  assumes infin: \"\\<not> finite (UNIV :: 'a set)\"\n  and fin: \"finite {a. f a \\<noteq> b}\"\n  shows \"finfun_default_aux f = b\"", "lemma finite_finfun_default_aux:\n  fixes f :: \"'a \\<Rightarrow> 'b\"\n  assumes fin: \"f \\<in> finfun\"\n  shows \"finite {a. f a \\<noteq> finfun_default_aux f}\"", "lemma finfun_default_aux_update_const:\n  fixes f :: \"'a \\<Rightarrow> 'b\"\n  assumes fin: \"f \\<in> finfun\"\n  shows \"finfun_default_aux (f(a := b)) = finfun_default_aux f\"", "lemma finite_finfun_default: \"finite {a. finfun_apply f a \\<noteq> finfun_default f}\"", "lemma finfun_default_const: \"finfun_default ((K$ b) :: 'a \\<Rightarrow>f 'b) = (if finite (UNIV :: 'a set) then undefined else b)\"", "lemma finfun_default_update_const:\n  \"finfun_default (f(a $:= b)) = finfun_default f\"", "lemma finfun_default_const_code [code]:\n  \"finfun_default ((K$ c) :: 'a :: card_UNIV \\<Rightarrow>f 'b) = (if CARD('a) = 0 then c else undefined)\"", "lemma finfun_default_update_code [code]:\n  \"finfun_default (finfun_update_code f a b) = finfun_default f\"", "lemma upd_left_comm: \"comp_fun_commute (\\<lambda>a. upd a (f a))\"", "lemma upd_upd_twice: \"upd a b'' (upd a b' (cnst b)) = upd a b'' (cnst b)\"", "lemma map_default_update_const:\n  assumes fin: \"finite (dom f)\"\n  and anf: \"a \\<notin> dom f\"\n  and fg: \"f \\<subseteq>\\<^sub>m g\"\n  shows \"upd a d  (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)) =\n         Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)\"", "lemma map_default_update_twice:\n  assumes fin: \"finite (dom f)\"\n  and anf: \"a \\<notin> dom f\"\n  and fg: \"f \\<subseteq>\\<^sub>m g\"\n  shows \"upd a d'' (upd a d' (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f))) =\n         upd a d'' (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f))\"", "lemma map_default_eq_id [simp]: \"map_default d ((\\<lambda>a. Some (f a)) |` {a. f a \\<noteq> d}) = f\"", "lemma finite_rec_cong1:\n  assumes f: \"comp_fun_commute f\" and g: \"comp_fun_commute g\"\n  and fin: \"finite A\"\n  and eq: \"\\<And>a. a \\<in> A \\<Longrightarrow> f a = g a\"\n  shows \"Finite_Set.fold f z A = Finite_Set.fold g z A\"", "lemma finfun_rec_upd [simp]:\n  \"finfun_rec cnst upd (f(a' $:= b')) = upd a' b' (finfun_rec cnst upd f)\"", "lemma finfun_rec_const [simp]: \"finfun_rec cnst upd (K$ c) = cnst c\"", "lemma finfun_weak_induct [consumes 0, case_names const update]:\n  assumes const: \"\\<And>b. P (K$ b)\"\n  and update: \"\\<And>f a b. P f \\<Longrightarrow> P (f(a $:= b))\"\n  shows \"P x\"", "lemma finfun_exhaust_disj: \"(\\<exists>b. x = finfun_const b) \\<or> (\\<exists>f a b. x = finfun_update f a b)\"", "lemma finfun_exhaust:\n  obtains b where \"x = (K$ b)\"\n        | f a b where \"x = f(a $:= b)\"", "lemma finfun_rec_unique:\n  fixes f :: \"'a \\<Rightarrow>f 'b \\<Rightarrow> 'c\"\n  assumes c: \"\\<And>c. f (K$ c) = cnst c\"\n  and u: \"\\<And>g a b. f (g(a $:= b)) = upd g a b (f g)\"\n  and c': \"\\<And>c. f' (K$ c) = cnst c\"\n  and u': \"\\<And>g a b. f' (g(a $:= b)) = upd g a b (f' g)\"\n  shows \"f = f'\"", "lemma finfun_apply_def: \"($) = (\\<lambda>f a. finfun_rec (\\<lambda>b. b) (\\<lambda>a' b c. if (a = a') then b else c) f)\"", "lemma finfun_upd_apply: \"f(a $:= b) $ a' = (if a = a' then b else f $ a')\"\n  and finfun_upd_apply_code [code]: \"(finfun_update_code f a b) $ a' = (if a = a' then b else f $ a')\"", "lemma finfun_const_apply [simp, code]: \"(K$ b) $ a = b\"", "lemma finfun_upd_apply_same [simp]:\n  \"f(a $:= b) $ a = b\"", "lemma finfun_upd_apply_other [simp]:\n  \"a \\<noteq> a' \\<Longrightarrow> f(a $:= b) $ a' = f $ a'\"", "lemma finfun_ext: \"(\\<And>a. f $ a = g $ a) \\<Longrightarrow> f = g\"", "lemma expand_finfun_eq: \"(f = g) = (($) f = ($) g)\"", "lemma finfun_upd_triv [simp]: \"f(x $:= f $ x) = f\"", "lemma finfun_const_inject [simp]: \"(K$ b) = (K$ b') \\<equiv> b = b'\"", "lemma finfun_const_eq_update:\n  \"((K$ b) = f(a $:= b')) = (b = b' \\<and> (\\<forall>a'. a \\<noteq> a' \\<longrightarrow> f $ a' = b))\"", "lemma finfun_comp_const [simp, code]:\n  \"g \\<circ>$ (K$ c) = (K$ g c)\"", "lemma finfun_comp_update [simp]: \"g \\<circ>$ (f(a $:= b)) = (g \\<circ>$ f)(a $:= g b)\"\n  and finfun_comp_update_code [code]: \n  \"g \\<circ>$ (finfun_update_code f a b) = finfun_update_code (g \\<circ>$ f) a (g b)\"", "lemma finfun_comp_apply [simp]:\n  \"($) (g \\<circ>$ f) = g \\<circ> ($) f\"", "lemma finfun_comp_comp_collapse [simp]: \"f \\<circ>$ g \\<circ>$ h = (f \\<circ> g) \\<circ>$ h\"", "lemma finfun_comp_const1 [simp]: \"(\\<lambda>x. c) \\<circ>$ f = (K$ c)\"", "lemma finfun_comp_id1 [simp]: \"(\\<lambda>x. x) \\<circ>$ f = f\" \"id \\<circ>$ f = f\"", "lemma finfun_comp_conv_comp: \"g \\<circ>$ f = Abs_finfun (g \\<circ> ($) f)\"", "lemma finfun_comp2_const [code, simp]: \"finfun_comp2 (K$ c) f = (K$ c)\"", "lemma finfun_comp2_update:\n  assumes inj: \"inj f\"\n  shows \"finfun_comp2 (g(b $:= c)) f = (if b \\<in> range f then (finfun_comp2 g f)(inv f b $:= c) else finfun_comp2 g f)\"", "lemma finfun_All_except_const: \"finfun_All_except A (K$ b) \\<longleftrightarrow> b \\<or> set A = UNIV\"", "lemma finfun_All_except_const_finfun_UNIV_code [code]:\n  \"finfun_All_except A (K$ b) = (b \\<or> is_list_UNIV A)\"", "lemma finfun_All_except_update:\n  \"finfun_All_except A f(a $:= b) = ((a \\<in> set A \\<or> b) \\<and> finfun_All_except (a # A) f)\"", "lemma finfun_All_except_update_code [code]:\n  fixes a :: \"'a :: card_UNIV\"\n  shows \"finfun_All_except A (finfun_update_code f a b) = ((a \\<in> set A \\<or> b) \\<and> finfun_All_except (a # A) f)\"", "lemma finfun_All_const [simp]: \"finfun_All (K$ b) = b\"", "lemma finfun_All_update: \"finfun_All f(a $:= b) = (b \\<and> finfun_All_except [a] f)\"", "lemma finfun_All_All: \"finfun_All P = All (($) P)\"", "lemma finfun_Ex_Ex: \"finfun_Ex P = Ex (($) P)\"", "lemma finfun_Ex_const [simp]: \"finfun_Ex (K$ b) = b\"", "lemma finfun_Diag_const1: \"($K$ b, g$) = Pair b \\<circ>$ g\"", "lemma finfun_Diag_const_code [code]:\n  \"($K$ b, K$ c$) = (K$ (b, c))\"\n  \"($K$ b, finfun_update_code g a c$) = finfun_update_code ($K$ b, g$) a (b, c)\"", "lemma finfun_Diag_update1: \"($f(a $:= b), g$) = ($f, g$)(a $:= (b, g $ a))\"\n  and finfun_Diag_update1_code [code]: \"($finfun_update_code f a b, g$) = ($f, g$)(a $:= (b, g $ a))\"", "lemma finfun_Diag_const2: \"($f, K$ c$) = (\\<lambda>b. (b, c)) \\<circ>$ f\"", "lemma finfun_Diag_update2: \"($f, g(a $:= c)$) = ($f, g$)(a $:= (f $ a, c))\"", "lemma finfun_Diag_const_const [simp]: \"($K$ b, K$ c$) = (K$ (b, c))\"", "lemma finfun_Diag_const_update:\n  \"($K$ b, g(a $:= c)$) = ($K$ b, g$)(a $:= (b, c))\"", "lemma finfun_Diag_update_const:\n  \"($f(a $:= b), K$ c$) = ($f, K$ c$)(a $:= (b, c))\"", "lemma finfun_Diag_update_update:\n  \"($f(a $:= b), g(a' $:= c)$) = (if a = a' then ($f, g$)(a $:= (b, c)) else ($f, g$)(a $:= (b, g $ a))(a' $:= (f $ a', c)))\"", "lemma finfun_Diag_apply [simp]: \"($) ($f, g$) = (\\<lambda>x. (f $ x, g $ x))\"", "lemma finfun_Diag_conv_Abs_finfun:\n  \"($f, g$) = Abs_finfun ((\\<lambda>x. (f $ x, g $ x)))\"", "lemma finfun_Diag_eq: \"($f, g$) = ($f', g'$) \\<longleftrightarrow> f = f' \\<and> g = g'\"", "lemma finfun_fst_const: \"finfun_fst (K$ bc) = (K$ fst bc)\"", "lemma finfun_fst_update: \"finfun_fst (f(a $:= bc)) = (finfun_fst f)(a $:= fst bc)\"\n  and finfun_fst_update_code: \"finfun_fst (finfun_update_code f a bc) = (finfun_fst f)(a $:= fst bc)\"", "lemma finfun_fst_comp_conv: \"finfun_fst (f \\<circ>$ g) = (fst \\<circ> f) \\<circ>$ g\"", "lemma finfun_fst_conv [simp]: \"finfun_fst ($f, g$) = f\"", "lemma finfun_fst_conv_Abs_finfun: \"finfun_fst = (\\<lambda>f. Abs_finfun (fst \\<circ> ($) f))\"", "lemma finfun_snd_const: \"finfun_snd (K$ bc) = (K$ snd bc)\"", "lemma finfun_snd_update: \"finfun_snd (f(a $:= bc)) = (finfun_snd f)(a $:= snd bc)\"\n  and finfun_snd_update_code [code]: \"finfun_snd (finfun_update_code f a bc) = (finfun_snd f)(a $:= snd bc)\"", "lemma finfun_snd_comp_conv: \"finfun_snd (f \\<circ>$ g) = (snd \\<circ> f) \\<circ>$ g\"", "lemma finfun_snd_conv [simp]: \"finfun_snd ($f, g$) = g\"", "lemma finfun_snd_conv_Abs_finfun: \"finfun_snd = (\\<lambda>f. Abs_finfun (snd \\<circ> ($) f))\"", "lemma finfun_Diag_collapse [simp]: \"($finfun_fst f, finfun_snd f$) = f\"", "lemma finfun_curry_const [simp, code]: \"finfun_curry (K$ c) = (K$ K$ c)\"", "lemma finfun_curry_update [simp]:\n  \"finfun_curry (f((a, b) $:= c)) = (finfun_curry f)(a $:= (finfun_curry f $ a)(b $:= c))\"\n  and finfun_curry_update_code [code]:\n  \"finfun_curry (finfun_update_code f (a, b) c) = (finfun_curry f)(a $:= (finfun_curry f $ a)(b $:= c))\"", "lemma finfun_Abs_finfun_curry: assumes fin: \"f \\<in> finfun\"\n  shows \"(\\<lambda>a. Abs_finfun (curry f a)) \\<in> finfun\"", "lemma finfun_curry_conv_curry:\n  fixes f :: \"('a \\<times> 'b) \\<Rightarrow>f 'c\"\n  shows \"finfun_curry f = Abs_finfun (\\<lambda>a. Abs_finfun (curry (finfun_apply f) a))\"", "lemma eq_finfun_All_ext: \"(f = g) \\<longleftrightarrow> finfun_All ((\\<lambda>(x, y). x = y) \\<circ>$ ($f, g$))\"", "lemma [code nbe]:\n  \"HOL.equal (f :: _ \\<Rightarrow>f _) f \\<longleftrightarrow> True\"", "lemma finfun_clearjunk_const [code]: \"finfun_clearjunk (K$ b) = (K$ b)\"", "lemma finfun_clearjunk_update [code]: \n  \"finfun_clearjunk (finfun_update_code f a b) = f(a $:= b)\"", "lemma finfun_dom_const:\n  \"finfun_dom ((K$ c) :: 'a \\<Rightarrow>f 'b) = (K$ finite (UNIV :: 'a set) \\<and> c \\<noteq> undefined)\"", "lemma finfun_dom_const_code [code]:\n  \"finfun_dom ((K$ c) :: ('a :: card_UNIV) \\<Rightarrow>f 'b) = \n   (if CARD('a) = 0 then (K$ False) else Code.abort (STR ''finfun_dom called on finite type'') (\\<lambda>_. finfun_dom (K$ c)))\"", "lemma finfun_dom_finfunI: \"(\\<lambda>a. f $ a \\<noteq> finfun_default f) \\<in> finfun\"", "lemma finfun_dom_update [simp]:\n  \"finfun_dom (f(a $:= b)) = (finfun_dom f)(a $:= (b \\<noteq> finfun_default f))\"", "lemma finfun_dom_update_code [code]:\n  \"finfun_dom (finfun_update_code f a b) = finfun_update_code (finfun_dom f) a (b \\<noteq> finfun_default f)\"", "lemma finite_finfun_dom: \"finite {x. finfun_dom f $ x}\"", "lemma set_finfun_to_list [simp]: \"set (finfun_to_list f) = {x. finfun_dom f $ x}\" (is ?thesis1)\n  and sorted_finfun_to_list: \"sorted (finfun_to_list f)\" (is ?thesis2)\n  and distinct_finfun_to_list: \"distinct (finfun_to_list f)\" (is ?thesis3)", "lemma finfun_const_False_conv_bot: \"($) (K$ False) = bot\"", "lemma finfun_const_True_conv_top: \"($) (K$ True) = top\"", "lemma finfun_to_list_const:\n  \"finfun_to_list ((K$ c) :: ('a :: {linorder} \\<Rightarrow>f 'b)) = \n  (if \\<not> finite (UNIV :: 'a set) \\<or> c = undefined then [] else THE xs. set xs = UNIV \\<and> sorted xs \\<and> distinct xs)\"", "lemma finfun_to_list_const_code [code]:\n  \"finfun_to_list ((K$ c) :: ('a :: {linorder, card_UNIV} \\<Rightarrow>f 'b)) =\n   (if CARD('a) = 0 then [] else Code.abort (STR ''finfun_to_list called on finite type'') (\\<lambda>_. finfun_to_list ((K$ c) :: ('a \\<Rightarrow>f 'b))))\"", "lemma remove1_insort_insert_same:\n  \"x \\<notin> set xs \\<Longrightarrow> remove1 x (insort_insert x xs) = xs\"", "lemma finfun_dom_conv:\n  \"finfun_dom f $ x \\<longleftrightarrow> f $ x \\<noteq> finfun_default f\"", "lemma finfun_to_list_update:\n  \"finfun_to_list (f(a $:= b)) = \n  (if b = finfun_default f then List.remove1 a (finfun_to_list f) else List.insort_insert a (finfun_to_list f))\"", "lemma finfun_to_list_update_code [code]:\n  \"finfun_to_list (finfun_update_code f a b) = \n  (if b = finfun_default f then List.remove1 a (finfun_to_list f) else List.insort_insert a (finfun_to_list f))\"", "lemma card_eq_1_iff: \"card A = 1 \\<longleftrightarrow> A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma card_UNIV_finfun: \n  defines \"F == finfun :: ('a \\<Rightarrow> 'b) set\"\n  shows \"CARD('a \\<Rightarrow>f 'b) = (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1 then CARD('b) ^ CARD('a) else 0)\"", "lemma finite_UNIV_finfun:\n  \"finite (UNIV :: ('a \\<Rightarrow>f 'b) set) \\<longleftrightarrow>\n  (finite (UNIV :: 'a set) \\<and> finite (UNIV :: 'b set) \\<or> CARD('b) = 1)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], "translations": [["", "lemma map_default_delete [simp]:\n  \"map_default b (f(a := None)) = (map_default b f)(a := b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_default b (f(a := None)) = (map_default b f)(a := b)", "by(simp add: map_default_def fun_eq_iff)"], ["", "lemma map_default_insert:\n  \"map_default b (f(a \\<mapsto> b')) = (map_default b f)(a := b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_default b (f(a \\<mapsto> b')) = (map_default b f)(a := b')", "by(simp add: map_default_def fun_eq_iff)"], ["", "lemma map_default_empty [simp]: \"map_default b Map.empty = (\\<lambda>a. b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_default b Map.empty = (\\<lambda>a. b)", "by(simp add: fun_eq_iff map_default_def)"], ["", "lemma map_default_inject:\n  fixes g g' :: \"'a \\<rightharpoonup> 'b\"\n  assumes infin_eq: \"\\<not> finite (UNIV :: 'a set) \\<or> b = b'\"\n  and fin: \"finite (dom g)\" and b: \"b \\<notin> ran g\"\n  and fin': \"finite (dom g')\" and b': \"b' \\<notin> ran g'\"\n  and eq': \"map_default b g = map_default b' g'\"\n  shows \"b = b'\" \"g = g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = b' &&& g = g'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. b = b'\n 2. g = g'", "from infin_eq"], ["proof (chain)\npicking this:\n  infinite UNIV \\<or> b = b'", "show bb': \"b = b'\""], ["proof (prove)\nusing this:\n  infinite UNIV \\<or> b = b'\n\ngoal (1 subgoal):\n 1. b = b'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. infinite UNIV \\<Longrightarrow> b = b'\n 2. b = b' \\<Longrightarrow> b = b'", "assume infin: \"\\<not> finite (UNIV :: 'a set)\""], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal (2 subgoals):\n 1. infinite UNIV \\<Longrightarrow> b = b'\n 2. b = b' \\<Longrightarrow> b = b'", "from fin fin'"], ["proof (chain)\npicking this:\n  finite (dom g)\n  finite (dom g')", "have \"finite (dom g \\<union> dom g')\""], ["proof (prove)\nusing this:\n  finite (dom g)\n  finite (dom g')\n\ngoal (1 subgoal):\n 1. finite (dom g \\<union> dom g')", "by auto"], ["proof (state)\nthis:\n  finite (dom g \\<union> dom g')\n\ngoal (2 subgoals):\n 1. infinite UNIV \\<Longrightarrow> b = b'\n 2. b = b' \\<Longrightarrow> b = b'", "with infin"], ["proof (chain)\npicking this:\n  infinite UNIV\n  finite (dom g \\<union> dom g')", "have \"UNIV - (dom g \\<union> dom g') \\<noteq> {}\""], ["proof (prove)\nusing this:\n  infinite UNIV\n  finite (dom g \\<union> dom g')\n\ngoal (1 subgoal):\n 1. UNIV - (dom g \\<union> dom g') \\<noteq> {}", "by(auto dest: finite_subset)"], ["proof (state)\nthis:\n  UNIV - (dom g \\<union> dom g') \\<noteq> {}\n\ngoal (2 subgoals):\n 1. infinite UNIV \\<Longrightarrow> b = b'\n 2. b = b' \\<Longrightarrow> b = b'", "then"], ["proof (chain)\npicking this:\n  UNIV - (dom g \\<union> dom g') \\<noteq> {}", "obtain a where a: \"a \\<notin> dom g \\<union> dom g'\""], ["proof (prove)\nusing this:\n  UNIV - (dom g \\<union> dom g') \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a \\<notin> dom g \\<union> dom g' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<notin> dom g \\<union> dom g'\n\ngoal (2 subgoals):\n 1. infinite UNIV \\<Longrightarrow> b = b'\n 2. b = b' \\<Longrightarrow> b = b'", "hence \"map_default b g a = b\" \"map_default b' g' a = b'\""], ["proof (prove)\nusing this:\n  a \\<notin> dom g \\<union> dom g'\n\ngoal (1 subgoal):\n 1. map_default b g a = b &&& map_default b' g' a = b'", "by(auto simp add: map_default_def)"], ["proof (state)\nthis:\n  map_default b g a = b\n  map_default b' g' a = b'\n\ngoal (2 subgoals):\n 1. infinite UNIV \\<Longrightarrow> b = b'\n 2. b = b' \\<Longrightarrow> b = b'", "with eq'"], ["proof (chain)\npicking this:\n  map_default b g = map_default b' g'\n  map_default b g a = b\n  map_default b' g' a = b'", "show \"b = b'\""], ["proof (prove)\nusing this:\n  map_default b g = map_default b' g'\n  map_default b g a = b\n  map_default b' g' a = b'\n\ngoal (1 subgoal):\n 1. b = b'", "by simp"], ["proof (state)\nthis:\n  b = b'\n\ngoal (1 subgoal):\n 1. b = b' \\<Longrightarrow> b = b'", "qed"], ["proof (state)\nthis:\n  b = b'\n\ngoal (1 subgoal):\n 1. g = g'", "show \"g = g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = g'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x = g' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x = g' x", "show \"g x = g' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x = g' x", "proof(cases \"g x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g x = None \\<Longrightarrow> g x = g' x\n 2. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "case None"], ["proof (state)\nthis:\n  g x = None\n\ngoal (2 subgoals):\n 1. g x = None \\<Longrightarrow> g x = g' x\n 2. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "hence \"map_default b g x = b\""], ["proof (prove)\nusing this:\n  g x = None\n\ngoal (1 subgoal):\n 1. map_default b g x = b", "by(simp add: map_default_def)"], ["proof (state)\nthis:\n  map_default b g x = b\n\ngoal (2 subgoals):\n 1. g x = None \\<Longrightarrow> g x = g' x\n 2. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "with bb' eq'"], ["proof (chain)\npicking this:\n  b = b'\n  map_default b g = map_default b' g'\n  map_default b g x = b", "have \"map_default b' g' x = b'\""], ["proof (prove)\nusing this:\n  b = b'\n  map_default b g = map_default b' g'\n  map_default b g x = b\n\ngoal (1 subgoal):\n 1. map_default b' g' x = b'", "by simp"], ["proof (state)\nthis:\n  map_default b' g' x = b'\n\ngoal (2 subgoals):\n 1. g x = None \\<Longrightarrow> g x = g' x\n 2. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "with b'"], ["proof (chain)\npicking this:\n  b' \\<notin> ran g'\n  map_default b' g' x = b'", "have \"g' x = None\""], ["proof (prove)\nusing this:\n  b' \\<notin> ran g'\n  map_default b' g' x = b'\n\ngoal (1 subgoal):\n 1. g' x = None", "by(simp add: map_default_def ran_def split: option.split_asm)"], ["proof (state)\nthis:\n  g' x = None\n\ngoal (2 subgoals):\n 1. g x = None \\<Longrightarrow> g x = g' x\n 2. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "with None"], ["proof (chain)\npicking this:\n  g x = None\n  g' x = None", "show ?thesis"], ["proof (prove)\nusing this:\n  g x = None\n  g' x = None\n\ngoal (1 subgoal):\n 1. g x = g' x", "by simp"], ["proof (state)\nthis:\n  g x = g' x\n\ngoal (1 subgoal):\n 1. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "case (Some c)"], ["proof (state)\nthis:\n  g x = Some c\n\ngoal (1 subgoal):\n 1. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "with b"], ["proof (chain)\npicking this:\n  b \\<notin> ran g\n  g x = Some c", "have cb: \"c \\<noteq> b\""], ["proof (prove)\nusing this:\n  b \\<notin> ran g\n  g x = Some c\n\ngoal (1 subgoal):\n 1. c \\<noteq> b", "by(auto simp add: ran_def)"], ["proof (state)\nthis:\n  c \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "moreover"], ["proof (state)\nthis:\n  c \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "from Some"], ["proof (chain)\npicking this:\n  g x = Some c", "have \"map_default b g x = c\""], ["proof (prove)\nusing this:\n  g x = Some c\n\ngoal (1 subgoal):\n 1. map_default b g x = c", "by(simp add: map_default_def)"], ["proof (state)\nthis:\n  map_default b g x = c\n\ngoal (1 subgoal):\n 1. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "with eq'"], ["proof (chain)\npicking this:\n  map_default b g = map_default b' g'\n  map_default b g x = c", "have \"map_default b' g' x = c\""], ["proof (prove)\nusing this:\n  map_default b g = map_default b' g'\n  map_default b g x = c\n\ngoal (1 subgoal):\n 1. map_default b' g' x = c", "by simp"], ["proof (state)\nthis:\n  map_default b' g' x = c\n\ngoal (1 subgoal):\n 1. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "ultimately"], ["proof (chain)\npicking this:\n  c \\<noteq> b\n  map_default b' g' x = c", "have \"g' x = Some c\""], ["proof (prove)\nusing this:\n  c \\<noteq> b\n  map_default b' g' x = c\n\ngoal (1 subgoal):\n 1. g' x = Some c", "using b' bb'"], ["proof (prove)\nusing this:\n  c \\<noteq> b\n  map_default b' g' x = c\n  b' \\<notin> ran g'\n  b = b'\n\ngoal (1 subgoal):\n 1. g' x = Some c", "by(auto simp add: map_default_def split: option.splits)"], ["proof (state)\nthis:\n  g' x = Some c\n\ngoal (1 subgoal):\n 1. \\<And>a. g x = Some a \\<Longrightarrow> g x = g' x", "with Some"], ["proof (chain)\npicking this:\n  g x = Some c\n  g' x = Some c", "show ?thesis"], ["proof (prove)\nusing this:\n  g x = Some c\n  g' x = Some c\n\ngoal (1 subgoal):\n 1. g x = g' x", "by simp"], ["proof (state)\nthis:\n  g x = g' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g x = g' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g = g'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The finfun type\\<close>"], ["", "definition \"finfun = {f::'a\\<Rightarrow>'b. \\<exists>b. finite {a. f a \\<noteq> b}}\""], ["", "typedef ('a,'b) finfun  (\"(_ \\<Rightarrow>f /_)\" [22, 21] 21) = \"finfun :: ('a => 'b) set\"\n  morphisms finfun_apply Abs_finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> finfun", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> finfun", "have \"\\<exists>f. finite {x. f x \\<noteq> undefined}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. finite {x. f x \\<noteq> undefined}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. ?f x \\<noteq> undefined}", "show \"finite {x. (\\<lambda>y. undefined) x \\<noteq> undefined}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. undefined \\<noteq> undefined}", "by auto"], ["proof (state)\nthis:\n  finite {x. undefined \\<noteq> undefined}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f. finite {x. f x \\<noteq> undefined}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> finfun", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. finite {x. f x \\<noteq> undefined}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>f. finite {x. f x \\<noteq> undefined}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> finfun", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  \\<exists>f. finite {x. f x \\<noteq> undefined}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> finfun\n\ngoal:\nNo subgoals!", "qed"], ["", "type_notation finfun (\"(_ \\<Rightarrow>f /_)\" [22, 21] 21)"], ["", "setup_lifting type_definition_finfun"], ["", "lemma fun_upd_finfun: \"y(a := b) \\<in> finfun \\<longleftrightarrow> y \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y(a := b) \\<in> finfun) = (y \\<in> finfun)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (y(a := b) \\<in> finfun) = (y \\<in> finfun)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (y(a := b) \\<in> finfun) = (y \\<in> finfun)", "fix b'"], ["proof (state)\ngoal (1 subgoal):\n 1. (y(a := b) \\<in> finfun) = (y \\<in> finfun)", "have \"finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}", "proof(cases \"b = b'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = b' \\<Longrightarrow>\n    finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}\n 2. b \\<noteq> b' \\<Longrightarrow>\n    finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}", "case True"], ["proof (state)\nthis:\n  b = b'\n\ngoal (2 subgoals):\n 1. b = b' \\<Longrightarrow>\n    finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}\n 2. b \\<noteq> b' \\<Longrightarrow>\n    finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}", "hence \"{a'. (y(a := b)) a' \\<noteq> b'} = {a'. y a' \\<noteq> b'} - {a}\""], ["proof (prove)\nusing this:\n  b = b'\n\ngoal (1 subgoal):\n 1. {a'. (y(a := b)) a' \\<noteq> b'} = {a'. y a' \\<noteq> b'} - {a}", "by auto"], ["proof (state)\nthis:\n  {a'. (y(a := b)) a' \\<noteq> b'} = {a'. y a' \\<noteq> b'} - {a}\n\ngoal (2 subgoals):\n 1. b = b' \\<Longrightarrow>\n    finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}\n 2. b \\<noteq> b' \\<Longrightarrow>\n    finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {a'. (y(a := b)) a' \\<noteq> b'} = {a'. y a' \\<noteq> b'} - {a}\n\ngoal (1 subgoal):\n 1. finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}", "by simp"], ["proof (state)\nthis:\n  finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. b \\<noteq> b' \\<Longrightarrow>\n    finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> b' \\<Longrightarrow>\n    finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}", "case False"], ["proof (state)\nthis:\n  b \\<noteq> b'\n\ngoal (1 subgoal):\n 1. b \\<noteq> b' \\<Longrightarrow>\n    finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}", "hence \"{a'. (y(a := b)) a' \\<noteq> b'} = insert a {a'. y a' \\<noteq> b'}\""], ["proof (prove)\nusing this:\n  b \\<noteq> b'\n\ngoal (1 subgoal):\n 1. {a'. (y(a := b)) a' \\<noteq> b'} = insert a {a'. y a' \\<noteq> b'}", "by auto"], ["proof (state)\nthis:\n  {a'. (y(a := b)) a' \\<noteq> b'} = insert a {a'. y a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. b \\<noteq> b' \\<Longrightarrow>\n    finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {a'. (y(a := b)) a' \\<noteq> b'} = insert a {a'. y a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}", "by simp"], ["proof (state)\nthis:\n  finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {a'. (y(a := b)) a' \\<noteq> b'} = finite {a'. y a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. (y(a := b) \\<in> finfun) = (y \\<in> finfun)", "}"], ["proof (state)\nthis:\n  finite {a'. (y(a := b)) a' \\<noteq> ?b'2} =\n  finite {a'. y a' \\<noteq> ?b'2}\n\ngoal (1 subgoal):\n 1. (y(a := b) \\<in> finfun) = (y \\<in> finfun)", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite {a'. (y(a := b)) a' \\<noteq> ?b'2} =\n  finite {a'. y a' \\<noteq> ?b'2}\n\ngoal (1 subgoal):\n 1. (y(a := b) \\<in> finfun) = (y \\<in> finfun)", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  finite {a'. (y(a := b)) a' \\<noteq> ?b'2} =\n  finite {a'. y a' \\<noteq> ?b'2}\n\ngoal (1 subgoal):\n 1. (y(a := b) \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}) =\n    (y \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}})", "by blast"], ["proof (state)\nthis:\n  (y(a := b) \\<in> finfun) = (y \\<in> finfun)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_finfun: \"(\\<lambda>x. a) \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. a) \\<in> finfun", "by(auto simp add: finfun_def)"], ["", "lemma finfun_left_compose:\n  assumes \"y \\<in> finfun\"\n  shows \"g \\<circ> y \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<circ> y \\<in> finfun", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<circ> y \\<in> finfun", "from assms"], ["proof (chain)\npicking this:\n  y \\<in> finfun", "obtain b where \"finite {a. y a \\<noteq> b}\""], ["proof (prove)\nusing this:\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        finite {a. y a \\<noteq> b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  y \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        finite {a. y a \\<noteq> b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. g \\<circ> y \\<in> finfun", "hence \"finite {c. g (y c) \\<noteq> g b}\""], ["proof (prove)\nusing this:\n  finite {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. finite {c. g (y c) \\<noteq> g b}", "proof(induct \"{a. y a \\<noteq> b}\" arbitrary: y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       {} = {a. y a \\<noteq> b} \\<Longrightarrow>\n       finite {c. g (y c) \\<noteq> g b}\n 2. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           F = {a. y a \\<noteq> b} \\<Longrightarrow>\n           finite {c. g (y c) \\<noteq> g b};\n        insert x F = {a. y a \\<noteq> b}\\<rbrakk>\n       \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "case empty"], ["proof (state)\nthis:\n  {} = {a. y a \\<noteq> b}\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       {} = {a. y a \\<noteq> b} \\<Longrightarrow>\n       finite {c. g (y c) \\<noteq> g b}\n 2. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           F = {a. y a \\<noteq> b} \\<Longrightarrow>\n           finite {c. g (y c) \\<noteq> g b};\n        insert x F = {a. y a \\<noteq> b}\\<rbrakk>\n       \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "hence \"y = (\\<lambda>a. b)\""], ["proof (prove)\nusing this:\n  {} = {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. y = (\\<lambda>a. b)", "by(auto)"], ["proof (state)\nthis:\n  y = (\\<lambda>a. b)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       {} = {a. y a \\<noteq> b} \\<Longrightarrow>\n       finite {c. g (y c) \\<noteq> g b}\n 2. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           F = {a. y a \\<noteq> b} \\<Longrightarrow>\n           finite {c. g (y c) \\<noteq> g b};\n        insert x F = {a. y a \\<noteq> b}\\<rbrakk>\n       \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "thus ?case"], ["proof (prove)\nusing this:\n  y = (\\<lambda>a. b)\n\ngoal (1 subgoal):\n 1. finite {c. g (y c) \\<noteq> g b}", "by(simp)"], ["proof (state)\nthis:\n  finite {c. g (y c) \\<noteq> g b}\n\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           F = {a. y a \\<noteq> b} \\<Longrightarrow>\n           finite {c. g (y c) \\<noteq> g b};\n        insert x F = {a. y a \\<noteq> b}\\<rbrakk>\n       \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           F = {a. y a \\<noteq> b} \\<Longrightarrow>\n           finite {c. g (y c) \\<noteq> g b};\n        insert x F = {a. y a \\<noteq> b}\\<rbrakk>\n       \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  F = {a. ?y a \\<noteq> b} \\<Longrightarrow>\n  finite {c. g (?y c) \\<noteq> g b}\n  insert x F = {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           F = {a. y a \\<noteq> b} \\<Longrightarrow>\n           finite {c. g (y c) \\<noteq> g b};\n        insert x F = {a. y a \\<noteq> b}\\<rbrakk>\n       \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "note IH = \\<open>\\<And>y. F = {a. y a \\<noteq> b} \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}\\<close>"], ["proof (state)\nthis:\n  F = {a. ?y a \\<noteq> b} \\<Longrightarrow>\n  finite {c. g (?y c) \\<noteq> g b}\n\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           F = {a. y a \\<noteq> b} \\<Longrightarrow>\n           finite {c. g (y c) \\<noteq> g b};\n        insert x F = {a. y a \\<noteq> b}\\<rbrakk>\n       \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "from \\<open>insert x F = {a. y a \\<noteq> b}\\<close> \\<open>x \\<notin> F\\<close>"], ["proof (chain)\npicking this:\n  insert x F = {a. y a \\<noteq> b}\n  x \\<notin> F", "have F: \"F = {a. (y(x := b)) a \\<noteq> b}\""], ["proof (prove)\nusing this:\n  insert x F = {a. y a \\<noteq> b}\n  x \\<notin> F\n\ngoal (1 subgoal):\n 1. F = {a. (y(x := b)) a \\<noteq> b}", "by(auto)"], ["proof (state)\nthis:\n  F = {a. (y(x := b)) a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           F = {a. y a \\<noteq> b} \\<Longrightarrow>\n           finite {c. g (y c) \\<noteq> g b};\n        insert x F = {a. y a \\<noteq> b}\\<rbrakk>\n       \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {c. g (y c) \\<noteq> g b}", "proof(cases \"g (y x) = g b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g (y x) = g b \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}\n 2. g (y x) \\<noteq> g b \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "case True"], ["proof (state)\nthis:\n  g (y x) = g b\n\ngoal (2 subgoals):\n 1. g (y x) = g b \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}\n 2. g (y x) \\<noteq> g b \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "hence \"{c. g ((y(x := b)) c) \\<noteq> g b} = {c. g (y c) \\<noteq> g b}\""], ["proof (prove)\nusing this:\n  g (y x) = g b\n\ngoal (1 subgoal):\n 1. {c. g ((y(x := b)) c) \\<noteq> g b} = {c. g (y c) \\<noteq> g b}", "by auto"], ["proof (state)\nthis:\n  {c. g ((y(x := b)) c) \\<noteq> g b} = {c. g (y c) \\<noteq> g b}\n\ngoal (2 subgoals):\n 1. g (y x) = g b \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}\n 2. g (y x) \\<noteq> g b \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "with IH[OF F]"], ["proof (chain)\npicking this:\n  finite {c. g ((y(x := b)) c) \\<noteq> g b}\n  {c. g ((y(x := b)) c) \\<noteq> g b} = {c. g (y c) \\<noteq> g b}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {c. g ((y(x := b)) c) \\<noteq> g b}\n  {c. g ((y(x := b)) c) \\<noteq> g b} = {c. g (y c) \\<noteq> g b}\n\ngoal (1 subgoal):\n 1. finite {c. g (y c) \\<noteq> g b}", "by simp"], ["proof (state)\nthis:\n  finite {c. g (y c) \\<noteq> g b}\n\ngoal (1 subgoal):\n 1. g (y x) \\<noteq> g b \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g (y x) \\<noteq> g b \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "case False"], ["proof (state)\nthis:\n  g (y x) \\<noteq> g b\n\ngoal (1 subgoal):\n 1. g (y x) \\<noteq> g b \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "hence \"{c. g (y c) \\<noteq> g b} = insert x {c. g ((y(x := b)) c) \\<noteq> g b}\""], ["proof (prove)\nusing this:\n  g (y x) \\<noteq> g b\n\ngoal (1 subgoal):\n 1. {c. g (y c) \\<noteq> g b} = insert x {c. g ((y(x := b)) c) \\<noteq> g b}", "by auto"], ["proof (state)\nthis:\n  {c. g (y c) \\<noteq> g b} = insert x {c. g ((y(x := b)) c) \\<noteq> g b}\n\ngoal (1 subgoal):\n 1. g (y x) \\<noteq> g b \\<Longrightarrow> finite {c. g (y c) \\<noteq> g b}", "with IH[OF F]"], ["proof (chain)\npicking this:\n  finite {c. g ((y(x := b)) c) \\<noteq> g b}\n  {c. g (y c) \\<noteq> g b} = insert x {c. g ((y(x := b)) c) \\<noteq> g b}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {c. g ((y(x := b)) c) \\<noteq> g b}\n  {c. g (y c) \\<noteq> g b} = insert x {c. g ((y(x := b)) c) \\<noteq> g b}\n\ngoal (1 subgoal):\n 1. finite {c. g (y c) \\<noteq> g b}", "by(simp)"], ["proof (state)\nthis:\n  finite {c. g (y c) \\<noteq> g b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {c. g (y c) \\<noteq> g b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {c. g (y c) \\<noteq> g b}\n\ngoal (1 subgoal):\n 1. g \\<circ> y \\<in> finfun", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite {c. g (y c) \\<noteq> g b}\n\ngoal (1 subgoal):\n 1. g \\<circ> y \\<in> finfun", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  finite {c. g (y c) \\<noteq> g b}\n\ngoal (1 subgoal):\n 1. g \\<circ> y \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}", "by auto"], ["proof (state)\nthis:\n  g \\<circ> y \\<in> finfun\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes \"y \\<in> finfun\"\n  shows fst_finfun: \"fst \\<circ> y \\<in> finfun\"\n  and snd_finfun: \"snd \\<circ> y \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst \\<circ> y \\<in> finfun &&& snd \\<circ> y \\<in> finfun", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. fst \\<circ> y \\<in> finfun\n 2. snd \\<circ> y \\<in> finfun", "from assms"], ["proof (chain)\npicking this:\n  y \\<in> finfun", "obtain b c where bc: \"finite {a. y a \\<noteq> (b, c)}\""], ["proof (prove)\nusing this:\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        finite {a. y a \\<noteq> (b, c)} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  y \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}\n\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        finite {a. y a \\<noteq> (b, c)} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite {a. y a \\<noteq> (b, c)}\n\ngoal (2 subgoals):\n 1. fst \\<circ> y \\<in> finfun\n 2. snd \\<circ> y \\<in> finfun", "have \"{a. fst (y a) \\<noteq> b} \\<subseteq> {a. y a \\<noteq> (b, c)}\"\n    and \"{a. snd (y a) \\<noteq> c} \\<subseteq> {a. y a \\<noteq> (b, c)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. fst (y a) \\<noteq> b} \\<subseteq> {a. y a \\<noteq> (b, c)} &&&\n    {a. snd (y a) \\<noteq> c} \\<subseteq> {a. y a \\<noteq> (b, c)}", "by auto"], ["proof (state)\nthis:\n  {a. fst (y a) \\<noteq> b} \\<subseteq> {a. y a \\<noteq> (b, c)}\n  {a. snd (y a) \\<noteq> c} \\<subseteq> {a. y a \\<noteq> (b, c)}\n\ngoal (2 subgoals):\n 1. fst \\<circ> y \\<in> finfun\n 2. snd \\<circ> y \\<in> finfun", "hence \"finite {a. fst (y a) \\<noteq> b}\" \n    and \"finite {a. snd (y a) \\<noteq> c}\""], ["proof (prove)\nusing this:\n  {a. fst (y a) \\<noteq> b} \\<subseteq> {a. y a \\<noteq> (b, c)}\n  {a. snd (y a) \\<noteq> c} \\<subseteq> {a. y a \\<noteq> (b, c)}\n\ngoal (1 subgoal):\n 1. finite {a. fst (y a) \\<noteq> b} &&& finite {a. snd (y a) \\<noteq> c}", "using bc"], ["proof (prove)\nusing this:\n  {a. fst (y a) \\<noteq> b} \\<subseteq> {a. y a \\<noteq> (b, c)}\n  {a. snd (y a) \\<noteq> c} \\<subseteq> {a. y a \\<noteq> (b, c)}\n  finite {a. y a \\<noteq> (b, c)}\n\ngoal (1 subgoal):\n 1. finite {a. fst (y a) \\<noteq> b} &&& finite {a. snd (y a) \\<noteq> c}", "by(auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite {a. fst (y a) \\<noteq> b}\n  finite {a. snd (y a) \\<noteq> c}\n\ngoal (2 subgoals):\n 1. fst \\<circ> y \\<in> finfun\n 2. snd \\<circ> y \\<in> finfun", "thus \"fst \\<circ> y \\<in> finfun\" \"snd \\<circ> y \\<in> finfun\""], ["proof (prove)\nusing this:\n  finite {a. fst (y a) \\<noteq> b}\n  finite {a. snd (y a) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. fst \\<circ> y \\<in> finfun &&& snd \\<circ> y \\<in> finfun", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  finite {a. fst (y a) \\<noteq> b}\n  finite {a. snd (y a) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. fst \\<circ> y \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}} &&&\n    snd \\<circ> y \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}", "by auto"], ["proof (state)\nthis:\n  fst \\<circ> y \\<in> finfun\n  snd \\<circ> y \\<in> finfun\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_finfun: \"map_of xs \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of xs \\<in> finfun", "unfolding finfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of xs \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}", "by(induct xs)(auto simp add: Collect_neg_eq Collect_conj_eq Collect_imp_eq intro: finite_subset)"], ["", "lemma Diag_finfun: \"(\\<lambda>x. (f x, g x)) \\<in> finfun \\<longleftrightarrow> f \\<in> finfun \\<and> g \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (f x, g x)) \\<in> finfun) =\n    (f \\<in> finfun \\<and> g \\<in> finfun)", "by(auto intro: finite_subset simp add: Collect_neg_eq Collect_imp_eq Collect_conj_eq finfun_def)"], ["", "lemma finfun_right_compose:\n  assumes g: \"g \\<in> finfun\" and inj: \"inj f\"\n  shows \"g o f \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<circ> f \\<in> finfun", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<circ> f \\<in> finfun", "from g"], ["proof (chain)\npicking this:\n  g \\<in> finfun", "obtain b where b: \"finite {a. g a \\<noteq> b}\""], ["proof (prove)\nusing this:\n  g \\<in> finfun\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        finite {a. g a \\<noteq> b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  g \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        finite {a. g a \\<noteq> b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite {a. g a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. g \\<circ> f \\<in> finfun", "moreover"], ["proof (state)\nthis:\n  finite {a. g a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. g \\<circ> f \\<in> finfun", "have \"f ` {a. g (f a) \\<noteq> b} \\<subseteq> {a. g a \\<noteq> b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` {a. g (f a) \\<noteq> b} \\<subseteq> {a. g a \\<noteq> b}", "by auto"], ["proof (state)\nthis:\n  f ` {a. g (f a) \\<noteq> b} \\<subseteq> {a. g a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. g \\<circ> f \\<in> finfun", "moreover"], ["proof (state)\nthis:\n  f ` {a. g (f a) \\<noteq> b} \\<subseteq> {a. g a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. g \\<circ> f \\<in> finfun", "from inj"], ["proof (chain)\npicking this:\n  inj f", "have \"inj_on f {a.  g (f a) \\<noteq> b}\""], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. inj_on f {a. g (f a) \\<noteq> b}", "by(rule subset_inj_on) blast"], ["proof (state)\nthis:\n  inj_on f {a. g (f a) \\<noteq> b}\n\ngoal (1 subgoal):\n 1. g \\<circ> f \\<in> finfun", "ultimately"], ["proof (chain)\npicking this:\n  finite {a. g a \\<noteq> b}\n  f ` {a. g (f a) \\<noteq> b} \\<subseteq> {a. g a \\<noteq> b}\n  inj_on f {a. g (f a) \\<noteq> b}", "have \"finite {a. g (f a) \\<noteq> b}\""], ["proof (prove)\nusing this:\n  finite {a. g a \\<noteq> b}\n  f ` {a. g (f a) \\<noteq> b} \\<subseteq> {a. g a \\<noteq> b}\n  inj_on f {a. g (f a) \\<noteq> b}\n\ngoal (1 subgoal):\n 1. finite {a. g (f a) \\<noteq> b}", "by(blast intro: finite_imageD[where f=f] finite_subset)"], ["proof (state)\nthis:\n  finite {a. g (f a) \\<noteq> b}\n\ngoal (1 subgoal):\n 1. g \\<circ> f \\<in> finfun", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite {a. g (f a) \\<noteq> b}\n\ngoal (1 subgoal):\n 1. g \\<circ> f \\<in> finfun", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  finite {a. g (f a) \\<noteq> b}\n\ngoal (1 subgoal):\n 1. g \\<circ> f \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}", "by auto"], ["proof (state)\nthis:\n  g \\<circ> f \\<in> finfun\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_curry:\n  assumes fin: \"f \\<in> finfun\"\n  shows \"curry f \\<in> finfun\" \"curry f a \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. curry f \\<in> finfun &&& curry f a \\<in> finfun", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. curry f \\<in> finfun\n 2. curry f a \\<in> finfun", "from fin"], ["proof (chain)\npicking this:\n  f \\<in> finfun", "obtain c where c: \"finite {ab. f ab \\<noteq> c}\""], ["proof (prove)\nusing this:\n  f \\<in> finfun\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        finite {ab. f ab \\<noteq> c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  f \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        finite {ab. f ab \\<noteq> c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite {ab. f ab \\<noteq> c}\n\ngoal (2 subgoals):\n 1. curry f \\<in> finfun\n 2. curry f a \\<in> finfun", "moreover"], ["proof (state)\nthis:\n  finite {ab. f ab \\<noteq> c}\n\ngoal (2 subgoals):\n 1. curry f \\<in> finfun\n 2. curry f a \\<in> finfun", "have \"{a. \\<exists>b. f (a, b) \\<noteq> c} = fst ` {ab. f ab \\<noteq> c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. \\<exists>b. f (a, b) \\<noteq> c} = fst ` {ab. f ab \\<noteq> c}", "by(force)"], ["proof (state)\nthis:\n  {a. \\<exists>b. f (a, b) \\<noteq> c} = fst ` {ab. f ab \\<noteq> c}\n\ngoal (2 subgoals):\n 1. curry f \\<in> finfun\n 2. curry f a \\<in> finfun", "hence \"{a. curry f a \\<noteq> (\\<lambda>b. c)} = fst ` {ab. f ab \\<noteq> c}\""], ["proof (prove)\nusing this:\n  {a. \\<exists>b. f (a, b) \\<noteq> c} = fst ` {ab. f ab \\<noteq> c}\n\ngoal (1 subgoal):\n 1. {a. curry f a \\<noteq> (\\<lambda>b. c)} = fst ` {ab. f ab \\<noteq> c}", "by(auto simp add: curry_def fun_eq_iff)"], ["proof (state)\nthis:\n  {a. curry f a \\<noteq> (\\<lambda>b. c)} = fst ` {ab. f ab \\<noteq> c}\n\ngoal (2 subgoals):\n 1. curry f \\<in> finfun\n 2. curry f a \\<in> finfun", "ultimately"], ["proof (chain)\npicking this:\n  finite {ab. f ab \\<noteq> c}\n  {a. curry f a \\<noteq> (\\<lambda>b. c)} = fst ` {ab. f ab \\<noteq> c}", "have \"finite {a. curry f a \\<noteq> (\\<lambda>b. c)}\""], ["proof (prove)\nusing this:\n  finite {ab. f ab \\<noteq> c}\n  {a. curry f a \\<noteq> (\\<lambda>b. c)} = fst ` {ab. f ab \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {a. curry f a \\<noteq> (\\<lambda>b. c)}", "by simp"], ["proof (state)\nthis:\n  finite {a. curry f a \\<noteq> (\\<lambda>b. c)}\n\ngoal (2 subgoals):\n 1. curry f \\<in> finfun\n 2. curry f a \\<in> finfun", "thus \"curry f \\<in> finfun\""], ["proof (prove)\nusing this:\n  finite {a. curry f a \\<noteq> (\\<lambda>b. c)}\n\ngoal (1 subgoal):\n 1. curry f \\<in> finfun", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  finite {a. curry f a \\<noteq> (\\<lambda>b. c)}\n\ngoal (1 subgoal):\n 1. curry f \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}", "by blast"], ["proof (state)\nthis:\n  curry f \\<in> finfun\n\ngoal (1 subgoal):\n 1. curry f a \\<in> finfun", "have \"snd ` {ab. f ab \\<noteq> c} = {b. \\<exists>a. f (a, b) \\<noteq> c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` {ab. f ab \\<noteq> c} = {b. \\<exists>a. f (a, b) \\<noteq> c}", "by(force)"], ["proof (state)\nthis:\n  snd ` {ab. f ab \\<noteq> c} = {b. \\<exists>a. f (a, b) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. curry f a \\<in> finfun", "hence \"{b. f (a, b) \\<noteq> c} \\<subseteq> snd ` {ab. f ab \\<noteq> c}\""], ["proof (prove)\nusing this:\n  snd ` {ab. f ab \\<noteq> c} = {b. \\<exists>a. f (a, b) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. {b. f (a, b) \\<noteq> c} \\<subseteq> snd ` {ab. f ab \\<noteq> c}", "by auto"], ["proof (state)\nthis:\n  {b. f (a, b) \\<noteq> c} \\<subseteq> snd ` {ab. f ab \\<noteq> c}\n\ngoal (1 subgoal):\n 1. curry f a \\<in> finfun", "hence \"finite {b. f (a, b) \\<noteq> c}\""], ["proof (prove)\nusing this:\n  {b. f (a, b) \\<noteq> c} \\<subseteq> snd ` {ab. f ab \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {b. f (a, b) \\<noteq> c}", "by(rule finite_subset)(rule finite_imageI[OF c])"], ["proof (state)\nthis:\n  finite {b. f (a, b) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. curry f a \\<in> finfun", "thus \"curry f a \\<in> finfun\""], ["proof (prove)\nusing this:\n  finite {b. f (a, b) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. curry f a \\<in> finfun", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  finite {b. f (a, b) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. curry f a \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}", "by auto"], ["proof (state)\nthis:\n  curry f a \\<in> finfun\n\ngoal:\nNo subgoals!", "qed"], ["", "bundle finfun\nbegin"], ["", "lemmas [simp] =\n  fst_finfun snd_finfun Abs_finfun_inverse\n  finfun_apply_inverse Abs_finfun_inject finfun_apply_inject\n  Diag_finfun finfun_curry"], ["", "lemmas [iff] =\n  const_finfun fun_upd_finfun finfun_apply map_of_finfun"], ["", "lemmas [intro] =\n  finfun_left_compose fst_finfun snd_finfun"], ["", "end"], ["", "lemma Abs_finfun_inject_finite:\n  fixes x y :: \"'a \\<Rightarrow> 'b\"\n  assumes fin: \"finite (UNIV :: 'a set)\"\n  shows \"Abs_finfun x = Abs_finfun y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_finfun x = Abs_finfun y) = (x = y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Abs_finfun x = Abs_finfun y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> Abs_finfun x = Abs_finfun y", "assume \"Abs_finfun x = Abs_finfun y\""], ["proof (state)\nthis:\n  Abs_finfun x = Abs_finfun y\n\ngoal (2 subgoals):\n 1. Abs_finfun x = Abs_finfun y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> Abs_finfun x = Abs_finfun y", "moreover"], ["proof (state)\nthis:\n  Abs_finfun x = Abs_finfun y\n\ngoal (2 subgoals):\n 1. Abs_finfun x = Abs_finfun y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> Abs_finfun x = Abs_finfun y", "have \"x \\<in> finfun\" \"y \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> finfun &&& y \\<in> finfun", "unfolding finfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}} &&&\n    y \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}", "by(auto intro: finite_subset[OF _ fin])"], ["proof (state)\nthis:\n  x \\<in> finfun\n  y \\<in> finfun\n\ngoal (2 subgoals):\n 1. Abs_finfun x = Abs_finfun y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> Abs_finfun x = Abs_finfun y", "ultimately"], ["proof (chain)\npicking this:\n  Abs_finfun x = Abs_finfun y\n  x \\<in> finfun\n  y \\<in> finfun", "show \"x = y\""], ["proof (prove)\nusing this:\n  Abs_finfun x = Abs_finfun y\n  x \\<in> finfun\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. x = y", "by(simp add: Abs_finfun_inject)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> Abs_finfun x = Abs_finfun y", "qed simp"], ["", "lemma Abs_finfun_inject_finite_class:\n  fixes x y :: \"('a :: finite) \\<Rightarrow> 'b\"\n  shows \"Abs_finfun x = Abs_finfun y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_finfun x = Abs_finfun y) = (x = y)", "using finite_UNIV"], ["proof (prove)\nusing this:\n  finite_UNIV = Phantom(?'a) (finite UNIV)\n\ngoal (1 subgoal):\n 1. (Abs_finfun x = Abs_finfun y) = (x = y)", "by(simp add: Abs_finfun_inject_finite)"], ["", "lemma Abs_finfun_inj_finite:\n  assumes fin: \"finite (UNIV :: 'a set)\"\n  shows \"inj (Abs_finfun :: ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow>f 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj Abs_finfun", "proof(rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        Abs_finfun x = Abs_finfun y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        Abs_finfun x = Abs_finfun y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"Abs_finfun x = Abs_finfun y\""], ["proof (state)\nthis:\n  Abs_finfun x = Abs_finfun y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        Abs_finfun x = Abs_finfun y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  Abs_finfun x = Abs_finfun y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        Abs_finfun x = Abs_finfun y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"x \\<in> finfun\" \"y \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> finfun &&& y \\<in> finfun", "unfolding finfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}} &&&\n    y \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}", "by(auto intro: finite_subset[OF _ fin])"], ["proof (state)\nthis:\n  x \\<in> finfun\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        Abs_finfun x = Abs_finfun y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  Abs_finfun x = Abs_finfun y\n  x \\<in> finfun\n  y \\<in> finfun", "show \"x = y\""], ["proof (prove)\nusing this:\n  Abs_finfun x = Abs_finfun y\n  x \\<in> finfun\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. x = y", "by(simp add: Abs_finfun_inject)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Abs_finfun_inverse_finite:\n  fixes x :: \"'a \\<Rightarrow> 'b\"\n  assumes fin: \"finite (UNIV :: 'a set)\"\n  shows \"finfun_apply (Abs_finfun x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_apply (Abs_finfun x) = x", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_apply (Abs_finfun x) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finfun_apply (Abs_finfun x) = x", "from fin"], ["proof (chain)\npicking this:\n  finite UNIV", "have \"x \\<in> finfun\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. x \\<in> finfun", "by(auto simp add: finfun_def intro: finite_subset)"], ["proof (state)\nthis:\n  x \\<in> finfun\n\ngoal (1 subgoal):\n 1. finfun_apply (Abs_finfun x) = x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> finfun\n\ngoal (1 subgoal):\n 1. finfun_apply (Abs_finfun x) = x", "by simp"], ["proof (state)\nthis:\n  finfun_apply (Abs_finfun x) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Abs_finfun_inverse_finite_class:\n  fixes x :: \"('a :: finite) \\<Rightarrow> 'b\"\n  shows \"finfun_apply (Abs_finfun x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_apply (Abs_finfun x) = x", "using finite_UNIV"], ["proof (prove)\nusing this:\n  finite_UNIV = Phantom(?'a) (finite UNIV)\n\ngoal (1 subgoal):\n 1. finfun_apply (Abs_finfun x) = x", "by(simp add: Abs_finfun_inverse_finite)"], ["", "lemma finfun_eq_finite_UNIV: \"finite (UNIV :: 'a set) \\<Longrightarrow> (finfun :: ('a \\<Rightarrow> 'b) set) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finfun = UNIV", "unfolding finfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow>\n    {f. \\<exists>b. finite {a. f a \\<noteq> b}} = UNIV", "by(auto intro: finite_subset)"], ["", "lemma finfun_finite_UNIV_class: \"finfun = (UNIV :: ('a :: finite \\<Rightarrow> 'b) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun = UNIV", "by(simp add: finfun_eq_finite_UNIV)"], ["", "lemma map_default_in_finfun:\n  assumes fin: \"finite (dom f)\"\n  shows \"map_default b f \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_default b f \\<in> finfun", "unfolding finfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_default b f \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}", "proof(intro CollectI exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {a. map_default b f a \\<noteq> ?b1}", "from fin"], ["proof (chain)\npicking this:\n  finite (dom f)", "show \"finite {a. map_default b f a \\<noteq> b}\""], ["proof (prove)\nusing this:\n  finite (dom f)\n\ngoal (1 subgoal):\n 1. finite {a. map_default b f a \\<noteq> b}", "by(auto simp add: map_default_def dom_def Collect_conj_eq split: option.splits)"], ["proof (state)\nthis:\n  finite {a. map_default b f a \\<noteq> b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_cases_map_default:\n  obtains b g where \"f = Abs_finfun (map_default b g)\" \"finite (dom g)\" \"b \\<notin> ran g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b g.\n        \\<lbrakk>f = Abs_finfun (map_default b g); finite (dom g);\n         b \\<notin> ran g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>b g.\n        \\<lbrakk>f = Abs_finfun (map_default b g); finite (dom g);\n         b \\<notin> ran g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain y where f: \"f = Abs_finfun y\" and y: \"y \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>f = Abs_finfun y; y \\<in> finfun\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases f)"], ["proof (state)\nthis:\n  f = Abs_finfun y\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. (\\<And>b g.\n        \\<lbrakk>f = Abs_finfun (map_default b g); finite (dom g);\n         b \\<notin> ran g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from y"], ["proof (chain)\npicking this:\n  y \\<in> finfun", "obtain b where b: \"finite {a. y a \\<noteq> b}\""], ["proof (prove)\nusing this:\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        finite {a. y a \\<noteq> b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  y \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        finite {a. y a \\<noteq> b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. (\\<And>b g.\n        \\<lbrakk>f = Abs_finfun (map_default b g); finite (dom g);\n         b \\<notin> ran g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?g = \"(\\<lambda>a. if y a = b then None else Some (y a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>b g.\n        \\<lbrakk>f = Abs_finfun (map_default b g); finite (dom g);\n         b \\<notin> ran g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"map_default b ?g = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_default b (\\<lambda>a. if y a = b then None else Some (y a)) = y", "by(simp add: fun_eq_iff map_default_def)"], ["proof (state)\nthis:\n  map_default b (\\<lambda>a. if y a = b then None else Some (y a)) = y\n\ngoal (1 subgoal):\n 1. (\\<And>b g.\n        \\<lbrakk>f = Abs_finfun (map_default b g); finite (dom g);\n         b \\<notin> ran g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with f"], ["proof (chain)\npicking this:\n  f = Abs_finfun y\n  map_default b (\\<lambda>a. if y a = b then None else Some (y a)) = y", "have \"f = Abs_finfun (map_default b ?g)\""], ["proof (prove)\nusing this:\n  f = Abs_finfun y\n  map_default b (\\<lambda>a. if y a = b then None else Some (y a)) = y\n\ngoal (1 subgoal):\n 1. f =\n    Abs_finfun\n     (map_default b (\\<lambda>a. if y a = b then None else Some (y a)))", "by simp"], ["proof (state)\nthis:\n  f =\n  Abs_finfun\n   (map_default b (\\<lambda>a. if y a = b then None else Some (y a)))\n\ngoal (1 subgoal):\n 1. (\\<And>b g.\n        \\<lbrakk>f = Abs_finfun (map_default b g); finite (dom g);\n         b \\<notin> ran g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  f =\n  Abs_finfun\n   (map_default b (\\<lambda>a. if y a = b then None else Some (y a)))\n\ngoal (1 subgoal):\n 1. (\\<And>b g.\n        \\<lbrakk>f = Abs_finfun (map_default b g); finite (dom g);\n         b \\<notin> ran g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from b"], ["proof (chain)\npicking this:\n  finite {a. y a \\<noteq> b}", "have \"finite (dom ?g)\""], ["proof (prove)\nusing this:\n  finite {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. finite (dom (\\<lambda>a. if y a = b then None else Some (y a)))", "by(auto simp add: dom_def)"], ["proof (state)\nthis:\n  finite (dom (\\<lambda>a. if y a = b then None else Some (y a)))\n\ngoal (1 subgoal):\n 1. (\\<And>b g.\n        \\<lbrakk>f = Abs_finfun (map_default b g); finite (dom g);\n         b \\<notin> ran g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  finite (dom (\\<lambda>a. if y a = b then None else Some (y a)))\n\ngoal (1 subgoal):\n 1. (\\<And>b g.\n        \\<lbrakk>f = Abs_finfun (map_default b g); finite (dom g);\n         b \\<notin> ran g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"b \\<notin> ran ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> ran (\\<lambda>a. if y a = b then None else Some (y a))", "by(auto simp add: ran_def)"], ["proof (state)\nthis:\n  b \\<notin> ran (\\<lambda>a. if y a = b then None else Some (y a))\n\ngoal (1 subgoal):\n 1. (\\<And>b g.\n        \\<lbrakk>f = Abs_finfun (map_default b g); finite (dom g);\n         b \\<notin> ran g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  f =\n  Abs_finfun\n   (map_default b (\\<lambda>a. if y a = b then None else Some (y a)))\n  finite (dom (\\<lambda>a. if y a = b then None else Some (y a)))\n  b \\<notin> ran (\\<lambda>a. if y a = b then None else Some (y a))", "show ?thesis"], ["proof (prove)\nusing this:\n  f =\n  Abs_finfun\n   (map_default b (\\<lambda>a. if y a = b then None else Some (y a)))\n  finite (dom (\\<lambda>a. if y a = b then None else Some (y a)))\n  b \\<notin> ran (\\<lambda>a. if y a = b then None else Some (y a))\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Kernel functions for type @{typ \"'a \\<Rightarrow>f 'b\"}\\<close>"], ["", "lift_definition finfun_const :: \"'b \\<Rightarrow> 'a \\<Rightarrow>f 'b\" (\"K$/ _\" [0] 1)\nis \"\\<lambda> b x. b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. (\\<lambda>x. b) \\<in> finfun", "by (rule const_finfun)"], ["", "lift_definition finfun_update :: \"'a \\<Rightarrow>f 'b \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> 'a \\<Rightarrow>f 'b\" (\"_'(_ $:= _')\" [1000,0,0] 1000) is \"fun_upd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun a b.\n       fun \\<in> finfun \\<Longrightarrow> fun(a := b) \\<in> finfun", "by (simp add: fun_upd_finfun)"], ["", "lemma finfun_update_twist: \"a \\<noteq> a' \\<Longrightarrow> f(a $:= b)(a' $:= b') = f(a' $:= b')(a $:= b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> a' \\<Longrightarrow>\n    f(a $:= b)(a' $:= b') = f(a' $:= b')(a $:= b)", "by transfer (simp add: fun_upd_twist)"], ["", "lemma finfun_update_twice [simp]:\n  \"f(a $:= b)(a $:= b') = f(a $:= b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f(a $:= b)(a $:= b') = f(a $:= b')", "by transfer simp"], ["", "lemma finfun_update_const_same: \"(K$ b)(a $:= b) = (K$ b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (K$ b)(a $:= b) = (K$ b)", "by transfer (simp add: fun_eq_iff)"], ["", "subsection \\<open>Code generator setup\\<close>"], ["", "definition finfun_update_code :: \"'a \\<Rightarrow>f 'b \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> 'a \\<Rightarrow>f 'b\"\nwhere [simp, code del]: \"finfun_update_code = finfun_update\""], ["", "code_datatype finfun_const finfun_update_code"], ["", "lemma finfun_update_const_code [code]:\n  \"(K$ b)(a $:= b') = (if b = b' then (K$ b) else finfun_update_code (K$ b) a b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (K$ b)(a $:= b') =\n    (if b = b' then K$ b else finfun_update_code (K$ b) a b')", "by(simp add: finfun_update_const_same)"], ["", "lemma finfun_update_update_code [code]:\n  \"(finfun_update_code f a b)(a' $:= b') = (if a = a' then f(a $:= b') else finfun_update_code (f(a' $:= b')) a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finfun_update_code f a b)(a' $:= b') =\n    (if a = a' then f(a $:= b') else finfun_update_code f(a' $:= b') a b)", "by(simp add: finfun_update_twist)"], ["", "subsection \\<open>Setup for quickcheck\\<close>"], ["", "quickcheck_generator finfun constructors: finfun_update_code, \"finfun_const :: 'b \\<Rightarrow> 'a \\<Rightarrow>f 'b\""], ["", "subsection \\<open>\\<open>finfun_update\\<close> as instance of \\<open>comp_fun_commute\\<close>\\<close>"], ["", "interpretation finfun_update: comp_fun_commute \"\\<lambda>a f. f(a :: 'a $:= b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute (\\<lambda>a f. f(a $:= b'))", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute (\\<lambda>a f. f(a $:= b'))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       (\\<lambda>f. f(y $:= b')) \\<circ> (\\<lambda>f. f(x $:= b')) =\n       (\\<lambda>f. f(x $:= b')) \\<circ> (\\<lambda>f. f(y $:= b'))", "fix a a' :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       (\\<lambda>f. f(y $:= b')) \\<circ> (\\<lambda>f. f(x $:= b')) =\n       (\\<lambda>f. f(x $:= b')) \\<circ> (\\<lambda>f. f(y $:= b'))", "show \"(\\<lambda>f. f(a $:= b')) \\<circ> (\\<lambda>f. f(a' $:= b')) = (\\<lambda>f. f(a' $:= b')) \\<circ> (\\<lambda>f. f(a $:= b'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. f(a $:= b')) \\<circ> (\\<lambda>f. f(a' $:= b')) =\n    (\\<lambda>f. f(a' $:= b')) \\<circ> (\\<lambda>f. f(a $:= b'))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>f. f(a $:= b')) \\<circ> (\\<lambda>f. f(a' $:= b'))) x =\n       ((\\<lambda>f. f(a' $:= b')) \\<circ> (\\<lambda>f. f(a $:= b'))) x", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>f. f(a $:= b')) \\<circ> (\\<lambda>f. f(a' $:= b'))) x =\n       ((\\<lambda>f. f(a' $:= b')) \\<circ> (\\<lambda>f. f(a $:= b'))) x", "have \"(finfun_apply b)(a := b', a' := b') = (finfun_apply b)(a' := b', a := b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finfun_apply b)(a := b', a' := b') = (finfun_apply b)\n    (a' := b', a := b')", "by(cases \"a = a'\")(auto simp add: fun_upd_twist)"], ["proof (state)\nthis:\n  (finfun_apply b)(a := b', a' := b') = (finfun_apply b)(a' := b', a := b')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>f. f(a $:= b')) \\<circ> (\\<lambda>f. f(a' $:= b'))) x =\n       ((\\<lambda>f. f(a' $:= b')) \\<circ> (\\<lambda>f. f(a $:= b'))) x", "then"], ["proof (chain)\npicking this:\n  (finfun_apply b)(a := b', a' := b') = (finfun_apply b)(a' := b', a := b')", "have \"b(a $:= b')(a' $:= b') = b(a' $:= b')(a $:= b')\""], ["proof (prove)\nusing this:\n  (finfun_apply b)(a := b', a' := b') = (finfun_apply b)(a' := b', a := b')\n\ngoal (1 subgoal):\n 1. b(a $:= b')(a' $:= b') = b(a' $:= b')(a $:= b')", "by(auto simp add: finfun_update_def fun_upd_twist)"], ["proof (state)\nthis:\n  b(a $:= b')(a' $:= b') = b(a' $:= b')(a $:= b')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>f. f(a $:= b')) \\<circ> (\\<lambda>f. f(a' $:= b'))) x =\n       ((\\<lambda>f. f(a' $:= b')) \\<circ> (\\<lambda>f. f(a $:= b'))) x", "then"], ["proof (chain)\npicking this:\n  b(a $:= b')(a' $:= b') = b(a' $:= b')(a $:= b')", "show \"((\\<lambda>f. f(a $:= b')) \\<circ> (\\<lambda>f. f(a' $:= b'))) b = ((\\<lambda>f. f(a' $:= b')) \\<circ> (\\<lambda>f. f(a $:= b'))) b\""], ["proof (prove)\nusing this:\n  b(a $:= b')(a' $:= b') = b(a' $:= b')(a $:= b')\n\ngoal (1 subgoal):\n 1. ((\\<lambda>f. f(a $:= b')) \\<circ> (\\<lambda>f. f(a' $:= b'))) b =\n    ((\\<lambda>f. f(a' $:= b')) \\<circ> (\\<lambda>f. f(a $:= b'))) b", "by (simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  ((\\<lambda>f. f(a $:= b')) \\<circ> (\\<lambda>f. f(a' $:= b'))) b =\n  ((\\<lambda>f. f(a' $:= b')) \\<circ> (\\<lambda>f. f(a $:= b'))) b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>f. f(a $:= b')) \\<circ> (\\<lambda>f. f(a' $:= b')) =\n  (\\<lambda>f. f(a' $:= b')) \\<circ> (\\<lambda>f. f(a $:= b'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_finfun_update_finite_univ:\n  assumes fin: \"finite (UNIV :: 'a set)\"\n  shows \"Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) (UNIV :: 'a set) = (K$ b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) UNIV = (K$ b')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) UNIV = (K$ b')", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) UNIV = (K$ b')", "fix A :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) UNIV = (K$ b')", "from fin"], ["proof (chain)\npicking this:\n  finite UNIV", "have \"finite A\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite A", "by(auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) UNIV = (K$ b')", "hence \"Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) A = Abs_finfun (\\<lambda>a. if a \\<in> A then b' else b)\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) A =\n    Abs_finfun (\\<lambda>a. if a \\<in> A then b' else b)", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) {} =\n    Abs_finfun (\\<lambda>a. if a \\<in> {} then b' else b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) F =\n        Abs_finfun (\\<lambda>a. if a \\<in> F then b' else b)\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b)\n                          (insert x F) =\n                         Abs_finfun\n                          (\\<lambda>a. if a \\<in> insert x F then b' else b)", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) F =\n  Abs_finfun (\\<lambda>a. if a \\<in> F then b' else b)\n\ngoal (2 subgoals):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) {} =\n    Abs_finfun (\\<lambda>a. if a \\<in> {} then b' else b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) F =\n        Abs_finfun (\\<lambda>a. if a \\<in> F then b' else b)\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b)\n                          (insert x F) =\n                         Abs_finfun\n                          (\\<lambda>a. if a \\<in> insert x F then b' else b)", "have \"(\\<lambda>a. if a = x then b' else (if a \\<in> F then b' else b)) = (\\<lambda>a. if a = x \\<or> a \\<in> F then b' else b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. if a = x then b' else if a \\<in> F then b' else b) =\n    (\\<lambda>a. if a = x \\<or> a \\<in> F then b' else b)", "by(auto)"], ["proof (state)\nthis:\n  (\\<lambda>a. if a = x then b' else if a \\<in> F then b' else b) =\n  (\\<lambda>a. if a = x \\<or> a \\<in> F then b' else b)\n\ngoal (2 subgoals):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) {} =\n    Abs_finfun (\\<lambda>a. if a \\<in> {} then b' else b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) F =\n        Abs_finfun (\\<lambda>a. if a \\<in> F then b' else b)\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b)\n                          (insert x F) =\n                         Abs_finfun\n                          (\\<lambda>a. if a \\<in> insert x F then b' else b)", "with insert"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) F =\n  Abs_finfun (\\<lambda>a. if a \\<in> F then b' else b)\n  (\\<lambda>a. if a = x then b' else if a \\<in> F then b' else b) =\n  (\\<lambda>a. if a = x \\<or> a \\<in> F then b' else b)", "show ?case"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) F =\n  Abs_finfun (\\<lambda>a. if a \\<in> F then b' else b)\n  (\\<lambda>a. if a = x then b' else if a \\<in> F then b' else b) =\n  (\\<lambda>a. if a = x \\<or> a \\<in> F then b' else b)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) (insert x F) =\n    Abs_finfun (\\<lambda>a. if a \\<in> insert x F then b' else b)", "by(simp add: finfun_const_def fun_upd_def)(simp add: finfun_update_def Abs_finfun_inverse_finite[OF fin] fun_upd_def)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) (insert x F) =\n  Abs_finfun (\\<lambda>a. if a \\<in> insert x F then b' else b)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) {} =\n    Abs_finfun (\\<lambda>a. if a \\<in> {} then b' else b)", "qed(simp add: finfun_const_def)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) A =\n  Abs_finfun (\\<lambda>a. if a \\<in> A then b' else b)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) UNIV = (K$ b')", "}"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) ?A2 =\n  Abs_finfun (\\<lambda>a. if a \\<in> ?A2 then b' else b)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) UNIV = (K$ b')", "thus ?thesis"], ["proof (prove)\nusing this:\n  Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) ?A2 =\n  Abs_finfun (\\<lambda>a. if a \\<in> ?A2 then b' else b)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) UNIV = (K$ b')", "by(simp add: finfun_const_def)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a f. f(a $:= b')) (K$ b) UNIV = (K$ b')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Default value for FinFuns\\<close>"], ["", "definition finfun_default_aux :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'b\"\nwhere [code del]: \"finfun_default_aux f = (if finite (UNIV :: 'a set) then undefined else THE b. finite {a. f a \\<noteq> b})\""], ["", "lemma finfun_default_aux_infinite:\n  fixes f :: \"'a \\<Rightarrow> 'b\"\n  assumes infin: \"\\<not> finite (UNIV :: 'a set)\"\n  and fin: \"finite {a. f a \\<noteq> b}\"\n  shows \"finfun_default_aux f = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_default_aux f = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finfun_default_aux f = b", "let ?B = \"{a. f a \\<noteq> b}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finfun_default_aux f = b", "from fin"], ["proof (chain)\npicking this:\n  finite {a. f a \\<noteq> b}", "have \"(THE b. finite {a. f a \\<noteq> b}) = b\""], ["proof (prove)\nusing this:\n  finite {a. f a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. (THE b. finite {a. f a \\<noteq> b}) = b", "proof(rule the_equality)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ba. finite {a. f a \\<noteq> ba} \\<Longrightarrow> ba = b", "fix b'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ba. finite {a. f a \\<noteq> ba} \\<Longrightarrow> ba = b", "assume \"finite {a. f a \\<noteq> b'}\" (is \"finite ?B'\")"], ["proof (state)\nthis:\n  finite {a. f a \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. \\<And>ba. finite {a. f a \\<noteq> ba} \\<Longrightarrow> ba = b", "with infin fin"], ["proof (chain)\npicking this:\n  infinite UNIV\n  finite {a. f a \\<noteq> b}\n  finite {a. f a \\<noteq> b'}", "have \"UNIV - (?B' \\<union> ?B) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  infinite UNIV\n  finite {a. f a \\<noteq> b}\n  finite {a. f a \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. UNIV - ({a. f a \\<noteq> b'} \\<union> {a. f a \\<noteq> b}) \\<noteq> {}", "by(auto dest: finite_subset)"], ["proof (state)\nthis:\n  UNIV - ({a. f a \\<noteq> b'} \\<union> {a. f a \\<noteq> b}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>ba. finite {a. f a \\<noteq> ba} \\<Longrightarrow> ba = b", "then"], ["proof (chain)\npicking this:\n  UNIV - ({a. f a \\<noteq> b'} \\<union> {a. f a \\<noteq> b}) \\<noteq> {}", "obtain a where a: \"a \\<notin> ?B' \\<union> ?B\""], ["proof (prove)\nusing this:\n  UNIV - ({a. f a \\<noteq> b'} \\<union> {a. f a \\<noteq> b}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a \\<notin> {a. f a \\<noteq> b'} \\<union>\n                   {a. f a \\<noteq> b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<notin> {a. f a \\<noteq> b'} \\<union> {a. f a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. \\<And>ba. finite {a. f a \\<noteq> ba} \\<Longrightarrow> ba = b", "thus \"b' = b\""], ["proof (prove)\nusing this:\n  a \\<notin> {a. f a \\<noteq> b'} \\<union> {a. f a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. b' = b", "by auto"], ["proof (state)\nthis:\n  b' = b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (THE b. finite {a. f a \\<noteq> b}) = b\n\ngoal (1 subgoal):\n 1. finfun_default_aux f = b", "thus ?thesis"], ["proof (prove)\nusing this:\n  (THE b. finite {a. f a \\<noteq> b}) = b\n\ngoal (1 subgoal):\n 1. finfun_default_aux f = b", "using infin"], ["proof (prove)\nusing this:\n  (THE b. finite {a. f a \\<noteq> b}) = b\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. finfun_default_aux f = b", "by(simp add: finfun_default_aux_def)"], ["proof (state)\nthis:\n  finfun_default_aux f = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_finfun_default_aux:\n  fixes f :: \"'a \\<Rightarrow> 'b\"\n  assumes fin: \"f \\<in> finfun\"\n  shows \"finite {a. f a \\<noteq> finfun_default_aux f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a. f a \\<noteq> finfun_default_aux f}", "proof(cases \"finite (UNIV :: 'a set)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow>\n    finite {a. f a \\<noteq> finfun_default_aux f}\n 2. infinite UNIV \\<Longrightarrow>\n    finite {a. f a \\<noteq> finfun_default_aux f}", "case True"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow>\n    finite {a. f a \\<noteq> finfun_default_aux f}\n 2. infinite UNIV \\<Longrightarrow>\n    finite {a. f a \\<noteq> finfun_default_aux f}", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite {a. f a \\<noteq> finfun_default_aux f}", "using fin"], ["proof (prove)\nusing this:\n  finite UNIV\n  f \\<in> finfun\n\ngoal (1 subgoal):\n 1. finite {a. f a \\<noteq> finfun_default_aux f}", "by(auto simp add: finfun_def finfun_default_aux_def intro: finite_subset)"], ["proof (state)\nthis:\n  finite {a. f a \\<noteq> finfun_default_aux f}\n\ngoal (1 subgoal):\n 1. infinite UNIV \\<Longrightarrow>\n    finite {a. f a \\<noteq> finfun_default_aux f}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite UNIV \\<Longrightarrow>\n    finite {a. f a \\<noteq> finfun_default_aux f}", "case False"], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. infinite UNIV \\<Longrightarrow>\n    finite {a. f a \\<noteq> finfun_default_aux f}", "from fin"], ["proof (chain)\npicking this:\n  f \\<in> finfun", "obtain b where b: \"finite {a. f a \\<noteq> b}\" (is \"finite ?B\")"], ["proof (prove)\nusing this:\n  f \\<in> finfun\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        finite {a. f a \\<noteq> b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  f \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        finite {a. f a \\<noteq> b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite {a. f a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. infinite UNIV \\<Longrightarrow>\n    finite {a. f a \\<noteq> finfun_default_aux f}", "with False"], ["proof (chain)\npicking this:\n  infinite UNIV\n  finite {a. f a \\<noteq> b}", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite UNIV\n  finite {a. f a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. finite {a. f a \\<noteq> finfun_default_aux f}", "by(simp add: finfun_default_aux_infinite)"], ["proof (state)\nthis:\n  finite {a. f a \\<noteq> finfun_default_aux f}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_default_aux_update_const:\n  fixes f :: \"'a \\<Rightarrow> 'b\"\n  assumes fin: \"f \\<in> finfun\"\n  shows \"finfun_default_aux (f(a := b)) = finfun_default_aux f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_default_aux (f(a := b)) = finfun_default_aux f", "proof(cases \"finite (UNIV :: 'a set)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow>\n    finfun_default_aux (f(a := b)) = finfun_default_aux f\n 2. infinite UNIV \\<Longrightarrow>\n    finfun_default_aux (f(a := b)) = finfun_default_aux f", "case False"], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow>\n    finfun_default_aux (f(a := b)) = finfun_default_aux f\n 2. infinite UNIV \\<Longrightarrow>\n    finfun_default_aux (f(a := b)) = finfun_default_aux f", "from fin"], ["proof (chain)\npicking this:\n  f \\<in> finfun", "obtain b' where b': \"finite {a. f a \\<noteq> b'}\""], ["proof (prove)\nusing this:\n  f \\<in> finfun\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        finite {a. f a \\<noteq> b'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  f \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        finite {a. f a \\<noteq> b'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite {a. f a \\<noteq> b'}\n\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow>\n    finfun_default_aux (f(a := b)) = finfun_default_aux f\n 2. infinite UNIV \\<Longrightarrow>\n    finfun_default_aux (f(a := b)) = finfun_default_aux f", "hence \"finite {a'. (f(a := b)) a' \\<noteq> b'}\""], ["proof (prove)\nusing this:\n  finite {a. f a \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. finite {a'. (f(a := b)) a' \\<noteq> b'}", "proof(cases \"b = b' \\<and> f a \\<noteq> b'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     b = b' \\<and> f a \\<noteq> b'\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}\n 2. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "case True"], ["proof (state)\nthis:\n  b = b' \\<and> f a \\<noteq> b'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     b = b' \\<and> f a \\<noteq> b'\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}\n 2. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "hence \"{a. f a \\<noteq> b'} = insert a {a'. (f(a := b)) a' \\<noteq> b'}\""], ["proof (prove)\nusing this:\n  b = b' \\<and> f a \\<noteq> b'\n\ngoal (1 subgoal):\n 1. {a. f a \\<noteq> b'} = insert a {a'. (f(a := b)) a' \\<noteq> b'}", "by auto"], ["proof (state)\nthis:\n  {a. f a \\<noteq> b'} = insert a {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     b = b' \\<and> f a \\<noteq> b'\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}\n 2. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {a. f a \\<noteq> b'} = insert a {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. finite {a'. (f(a := b)) a' \\<noteq> b'}", "using b'"], ["proof (prove)\nusing this:\n  {a. f a \\<noteq> b'} = insert a {a'. (f(a := b)) a' \\<noteq> b'}\n  finite {a. f a \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. finite {a'. (f(a := b)) a' \\<noteq> b'}", "by simp"], ["proof (state)\nthis:\n  finite {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "case False"], ["proof (state)\nthis:\n  \\<not> (b = b' \\<and> f a \\<noteq> b')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "moreover"], ["proof (state)\nthis:\n  \\<not> (b = b' \\<and> f a \\<noteq> b')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "{"], ["proof (state)\nthis:\n  \\<not> (b = b' \\<and> f a \\<noteq> b')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "assume \"b \\<noteq> b'\""], ["proof (state)\nthis:\n  b \\<noteq> b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "hence \"{a'. (f(a := b)) a' \\<noteq> b'} = insert a {a. f a \\<noteq> b'}\""], ["proof (prove)\nusing this:\n  b \\<noteq> b'\n\ngoal (1 subgoal):\n 1. {a'. (f(a := b)) a' \\<noteq> b'} = insert a {a. f a \\<noteq> b'}", "by auto"], ["proof (state)\nthis:\n  {a'. (f(a := b)) a' \\<noteq> b'} = insert a {a. f a \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "hence ?thesis"], ["proof (prove)\nusing this:\n  {a'. (f(a := b)) a' \\<noteq> b'} = insert a {a. f a \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. finite {a'. (f(a := b)) a' \\<noteq> b'}", "using b'"], ["proof (prove)\nusing this:\n  {a'. (f(a := b)) a' \\<noteq> b'} = insert a {a. f a \\<noteq> b'}\n  finite {a. f a \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. finite {a'. (f(a := b)) a' \\<noteq> b'}", "by simp"], ["proof (state)\nthis:\n  finite {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "}"], ["proof (state)\nthis:\n  b \\<noteq> b' \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "moreover"], ["proof (state)\nthis:\n  b \\<noteq> b' \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "{"], ["proof (state)\nthis:\n  b \\<noteq> b' \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "assume \"b = b'\" \"f a = b'\""], ["proof (state)\nthis:\n  b = b'\n  f a = b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "hence \"{a'. (f(a := b)) a' \\<noteq> b'} = {a. f a \\<noteq> b'}\""], ["proof (prove)\nusing this:\n  b = b'\n  f a = b'\n\ngoal (1 subgoal):\n 1. {a'. (f(a := b)) a' \\<noteq> b'} = {a. f a \\<noteq> b'}", "by auto"], ["proof (state)\nthis:\n  {a'. (f(a := b)) a' \\<noteq> b'} = {a. f a \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "hence ?thesis"], ["proof (prove)\nusing this:\n  {a'. (f(a := b)) a' \\<noteq> b'} = {a. f a \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. finite {a'. (f(a := b)) a' \\<noteq> b'}", "using b'"], ["proof (prove)\nusing this:\n  {a'. (f(a := b)) a' \\<noteq> b'} = {a. f a \\<noteq> b'}\n  finite {a. f a \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. finite {a'. (f(a := b)) a' \\<noteq> b'}", "by simp"], ["proof (state)\nthis:\n  finite {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>b = b'; f a = b'\\<rbrakk>\n  \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {a. f a \\<noteq> b'};\n     \\<not> (b = b' \\<and> f a \\<noteq> b')\\<rbrakk>\n    \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (b = b' \\<and> f a \\<noteq> b')\n  b \\<noteq> b' \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}\n  \\<lbrakk>b = b'; f a = b'\\<rbrakk>\n  \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (b = b' \\<and> f a \\<noteq> b')\n  b \\<noteq> b' \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}\n  \\<lbrakk>b = b'; f a = b'\\<rbrakk>\n  \\<Longrightarrow> finite {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. finite {a'. (f(a := b)) a' \\<noteq> b'}", "by blast"], ["proof (state)\nthis:\n  finite {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow>\n    finfun_default_aux (f(a := b)) = finfun_default_aux f\n 2. infinite UNIV \\<Longrightarrow>\n    finfun_default_aux (f(a := b)) = finfun_default_aux f", "with False b'"], ["proof (chain)\npicking this:\n  infinite UNIV\n  finite {a. f a \\<noteq> b'}\n  finite {a'. (f(a := b)) a' \\<noteq> b'}", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite UNIV\n  finite {a. f a \\<noteq> b'}\n  finite {a'. (f(a := b)) a' \\<noteq> b'}\n\ngoal (1 subgoal):\n 1. finfun_default_aux (f(a := b)) = finfun_default_aux f", "by(auto simp del: fun_upd_apply simp add: finfun_default_aux_infinite)"], ["proof (state)\nthis:\n  finfun_default_aux (f(a := b)) = finfun_default_aux f\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow>\n    finfun_default_aux (f(a := b)) = finfun_default_aux f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow>\n    finfun_default_aux (f(a := b)) = finfun_default_aux f", "case True"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow>\n    finfun_default_aux (f(a := b)) = finfun_default_aux f", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finfun_default_aux (f(a := b)) = finfun_default_aux f", "by(simp add: finfun_default_aux_def)"], ["proof (state)\nthis:\n  finfun_default_aux (f(a := b)) = finfun_default_aux f\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition finfun_default :: \"'a \\<Rightarrow>f 'b \\<Rightarrow> 'b\"\nis \"finfun_default_aux\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma finite_finfun_default: \"finite {a. finfun_apply f a \\<noteq> finfun_default f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a. finfun_apply f a \\<noteq> finfun_default f}", "by transfer (erule finite_finfun_default_aux)"], ["", "lemma finfun_default_const: \"finfun_default ((K$ b) :: 'a \\<Rightarrow>f 'b) = (if finite (UNIV :: 'a set) then undefined else b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_default (K$ b) = (if finite UNIV then undefined else b)", "by(transfer)(auto simp add: finfun_default_aux_infinite finfun_default_aux_def)"], ["", "lemma finfun_default_update_const:\n  \"finfun_default (f(a $:= b)) = finfun_default f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_default f(a $:= b) = finfun_default f", "by transfer (simp add: finfun_default_aux_update_const)"], ["", "lemma finfun_default_const_code [code]:\n  \"finfun_default ((K$ c) :: 'a :: card_UNIV \\<Rightarrow>f 'b) = (if CARD('a) = 0 then c else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_default (K$ c) = (if CARD('a) = 0 then c else undefined)", "by(simp add: finfun_default_const)"], ["", "lemma finfun_default_update_code [code]:\n  \"finfun_default (finfun_update_code f a b) = finfun_default f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_default (finfun_update_code f a b) = finfun_default f", "by(simp add: finfun_default_update_const)"], ["", "subsection \\<open>Recursion combinator and well-formedness conditions\\<close>"], ["", "definition finfun_rec :: \"('b \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<Rightarrow>f 'b) \\<Rightarrow> 'c\"\nwhere [code del]:\n  \"finfun_rec cnst upd f \\<equiv>\n   let b = finfun_default f;\n       g = THE g. f = Abs_finfun (map_default b g) \\<and> finite (dom g) \\<and> b \\<notin> ran g\n   in Finite_Set.fold (\\<lambda>a. upd a (map_default b g a)) (cnst b) (dom g)\""], ["", "locale finfun_rec_wf_aux =\n  fixes cnst :: \"'b \\<Rightarrow> 'c\"\n  and upd :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'c\"\n  assumes upd_const_same: \"upd a b (cnst b) = cnst b\"\n  and upd_commute: \"a \\<noteq> a' \\<Longrightarrow> upd a b (upd a' b' c) = upd a' b' (upd a b c)\"\n  and upd_idemp: \"b \\<noteq> b' \\<Longrightarrow> upd a b'' (upd a b' (cnst b)) = upd a b'' (cnst b)\"\nbegin"], ["", "lemma upd_left_comm: \"comp_fun_commute (\\<lambda>a. upd a (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute (\\<lambda>a. upd a (f a))", "by(unfold_locales)(auto intro: upd_commute simp add: fun_eq_iff)"], ["", "lemma upd_upd_twice: \"upd a b'' (upd a b' (cnst b)) = upd a b'' (cnst b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd a b'' (upd a b' (cnst b)) = upd a b'' (cnst b)", "by(cases \"b \\<noteq> b'\")(auto simp add: fun_upd_def upd_const_same upd_idemp)"], ["", "lemma map_default_update_const:\n  assumes fin: \"finite (dom f)\"\n  and anf: \"a \\<notin> dom f\"\n  and fg: \"f \\<subseteq>\\<^sub>m g\"\n  shows \"upd a d  (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)) =\n         Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd a d\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f)) =\n    Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. upd a d\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f)) =\n    Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)", "let ?upd = \"\\<lambda>a. upd a (map_default d g a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. upd a d\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f)) =\n    Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)", "let ?fr = \"\\<lambda>A. Finite_Set.fold ?upd (cnst d) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. upd a d\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f)) =\n    Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)", "interpret gwf: comp_fun_commute \"?upd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute (\\<lambda>a. upd a (map_default d g a))", "by(rule upd_left_comm)"], ["proof (state)\ngoal (1 subgoal):\n 1. upd a d\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f)) =\n    Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)", "from fin anf fg"], ["proof (chain)\npicking this:\n  finite (dom f)\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (dom f)\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g\n\ngoal (1 subgoal):\n 1. upd a d\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f)) =\n    Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)", "proof(induct \"dom f\" arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>{} = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)\n 2. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "case empty"], ["proof (state)\nthis:\n  {} = dom f\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>{} = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)\n 2. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "from \\<open>{} = dom f\\<close>"], ["proof (chain)\npicking this:\n  {} = dom f", "have \"f = Map.empty\""], ["proof (prove)\nusing this:\n  {} = dom f\n\ngoal (1 subgoal):\n 1. f = Map.empty", "by(auto simp add: dom_def)"], ["proof (state)\nthis:\n  f = Map.empty\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>{} = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)\n 2. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "thus ?case"], ["proof (prove)\nusing this:\n  f = Map.empty\n\ngoal (1 subgoal):\n 1. upd a d\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f)) =\n    Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)", "by(simp add: finfun_const_def upd_const_same)"], ["proof (state)\nthis:\n  upd a d\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom f)) =\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "case (insert a' A)"], ["proof (state)\nthis:\n  finite A\n  a' \\<notin> A\n  \\<lbrakk>A = dom ?f; a \\<notin> dom ?f; ?f \\<subseteq>\\<^sub>m g\\<rbrakk>\n  \\<Longrightarrow> upd a d\n                     (Finite_Set.fold\n                       (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                       (dom ?f)) =\n                    Finite_Set.fold (\\<lambda>a. upd a (map_default d g a))\n                     (cnst d) (dom ?f)\n  insert a' A = dom f\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "note IH = \\<open>\\<And>f.  \\<lbrakk> A = dom f; a \\<notin> dom f; f \\<subseteq>\\<^sub>m g \\<rbrakk> \\<Longrightarrow> upd a d (?fr (dom f)) = ?fr (dom f)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>A = dom ?f; a \\<notin> dom ?f; ?f \\<subseteq>\\<^sub>m g\\<rbrakk>\n  \\<Longrightarrow> upd a d\n                     (Finite_Set.fold\n                       (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                       (dom ?f)) =\n                    Finite_Set.fold (\\<lambda>a. upd a (map_default d g a))\n                     (cnst d) (dom ?f)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "note fin = \\<open>finite A\\<close>"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "note anf = \\<open>a \\<notin> dom f\\<close>"], ["proof (state)\nthis:\n  a \\<notin> dom f\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "note a'nA = \\<open>a' \\<notin> A\\<close>"], ["proof (state)\nthis:\n  a' \\<notin> A\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "note domf = \\<open>insert a' A = dom f\\<close>"], ["proof (state)\nthis:\n  insert a' A = dom f\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "note fg = \\<open>f \\<subseteq>\\<^sub>m g\\<close>"], ["proof (state)\nthis:\n  f \\<subseteq>\\<^sub>m g\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "from domf"], ["proof (chain)\npicking this:\n  insert a' A = dom f", "obtain b where b: \"f a' = Some b\""], ["proof (prove)\nusing this:\n  insert a' A = dom f\n\ngoal (1 subgoal):\n 1. (\\<And>b. f a' = Some b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f a' = Some b\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "let ?f' = \"f(a' := None)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "have \"upd a d (?fr (insert a' A)) = upd a d (upd a' (map_default d g a') (?fr A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd a d\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (insert a' A)) =\n    upd a d\n     (upd a' (map_default d g a')\n       (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) A))", "by(subst gwf.fold_insert[OF fin a'nA]) rule"], ["proof (state)\nthis:\n  upd a d\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (insert a' A)) =\n  upd a d\n   (upd a' (map_default d g a')\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) A))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "also"], ["proof (state)\nthis:\n  upd a d\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (insert a' A)) =\n  upd a d\n   (upd a' (map_default d g a')\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) A))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "from b fg"], ["proof (chain)\npicking this:\n  f a' = Some b\n  f \\<subseteq>\\<^sub>m g", "have \"g a' = f a'\""], ["proof (prove)\nusing this:\n  f a' = Some b\n  f \\<subseteq>\\<^sub>m g\n\ngoal (1 subgoal):\n 1. g a' = f a'", "by(auto simp add: map_le_def intro: domI dest: bspec)"], ["proof (state)\nthis:\n  g a' = f a'\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "hence ga': \"map_default d g a' = map_default d f a'\""], ["proof (prove)\nusing this:\n  g a' = f a'\n\ngoal (1 subgoal):\n 1. map_default d g a' = map_default d f a'", "by(simp add: map_default_def)"], ["proof (state)\nthis:\n  map_default d g a' = map_default d f a'\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "also"], ["proof (state)\nthis:\n  map_default d g a' = map_default d f a'\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "from anf domf"], ["proof (chain)\npicking this:\n  a \\<notin> dom f\n  insert a' A = dom f", "have \"a \\<noteq> a'\""], ["proof (prove)\nusing this:\n  a \\<notin> dom f\n  insert a' A = dom f\n\ngoal (1 subgoal):\n 1. a \\<noteq> a'", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "note upd_commute[OF this]"], ["proof (state)\nthis:\n  upd a ?b (upd a' ?b' ?c) = upd a' ?b' (upd a ?b ?c)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "also"], ["proof (state)\nthis:\n  upd a ?b (upd a' ?b' ?c) = upd a' ?b' (upd a ?b ?c)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "from domf a'nA anf fg"], ["proof (chain)\npicking this:\n  insert a' A = dom f\n  a' \\<notin> A\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g", "have \"a \\<notin> dom ?f'\" \"?f' \\<subseteq>\\<^sub>m g\" and A: \"A = dom ?f'\""], ["proof (prove)\nusing this:\n  insert a' A = dom f\n  a' \\<notin> A\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g\n\ngoal (1 subgoal):\n 1. (a \\<notin> dom (f(a' := None)) &&&\n     f(a' := None) \\<subseteq>\\<^sub>m g) &&&\n    A = dom (f(a' := None))", "by(auto simp add: ran_def map_le_def)"], ["proof (state)\nthis:\n  a \\<notin> dom (f(a' := None))\n  f(a' := None) \\<subseteq>\\<^sub>m g\n  A = dom (f(a' := None))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "note A"], ["proof (state)\nthis:\n  A = dom (f(a' := None))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "also"], ["proof (state)\nthis:\n  A = dom (f(a' := None))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "note IH[OF A \\<open>a \\<notin> dom ?f'\\<close> \\<open>?f' \\<subseteq>\\<^sub>m g\\<close>]"], ["proof (state)\nthis:\n  upd a d\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom (f(a' := None)))) =\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n   (dom (f(a' := None)))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "also"], ["proof (state)\nthis:\n  upd a d\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom (f(a' := None)))) =\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n   (dom (f(a' := None)))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "have \"upd a' (map_default d f a') (?fr (dom (f(a' := None)))) = ?fr (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd a' (map_default d f a')\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom (f(a' := None)))) =\n    Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)", "unfolding domf[symmetric] gwf.fold_insert[OF fin a'nA] ga'"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd a' (map_default d f a')\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom (f(a' := None)))) =\n    upd a' (map_default d f a')\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) A)", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd a' (map_default d f a')\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom (f(a' := None)))) =\n    upd a' (map_default d f a')\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom (f(a' := None))))", ".."], ["proof (state)\nthis:\n  upd a' (map_default d f a')\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom (f(a' := None)))) =\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "also"], ["proof (state)\nthis:\n  upd a' (map_default d f a')\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom (f(a' := None)))) =\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "have \"insert a' (dom ?f') = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert a' (dom (f(a' := None))) = dom f", "using domf"], ["proof (prove)\nusing this:\n  insert a' A = dom f\n\ngoal (1 subgoal):\n 1. insert a' (dom (f(a' := None))) = dom f", "by auto"], ["proof (state)\nthis:\n  insert a' (dom (f(a' := None))) = dom f\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f)) =\n                             Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f);\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f)) =\n                         Finite_Set.fold\n                          (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                          (dom f)", "finally"], ["proof (chain)\npicking this:\n  upd a d\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom f)) =\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)", "show ?case"], ["proof (prove)\nusing this:\n  upd a d\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom f)) =\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)\n\ngoal (1 subgoal):\n 1. upd a d\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f)) =\n    Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)", "."], ["proof (state)\nthis:\n  upd a d\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom f)) =\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd a d\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom f)) =\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_default_update_twice:\n  assumes fin: \"finite (dom f)\"\n  and anf: \"a \\<notin> dom f\"\n  and fg: \"f \\<subseteq>\\<^sub>m g\"\n  shows \"upd a d'' (upd a d' (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f))) =\n         upd a d'' (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d) (dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd a d''\n     (upd a d'\n       (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n         (dom f))) =\n    upd a d''\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. upd a d''\n     (upd a d'\n       (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n         (dom f))) =\n    upd a d''\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))", "let ?upd = \"\\<lambda>a. upd a (map_default d g a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. upd a d''\n     (upd a d'\n       (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n         (dom f))) =\n    upd a d''\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))", "let ?fr = \"\\<lambda>A. Finite_Set.fold ?upd (cnst d) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. upd a d''\n     (upd a d'\n       (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n         (dom f))) =\n    upd a d''\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))", "interpret gwf: comp_fun_commute \"?upd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute (\\<lambda>a. upd a (map_default d g a))", "by(rule upd_left_comm)"], ["proof (state)\ngoal (1 subgoal):\n 1. upd a d''\n     (upd a d'\n       (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n         (dom f))) =\n    upd a d''\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))", "from fin anf fg"], ["proof (chain)\npicking this:\n  finite (dom f)\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (dom f)\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g\n\ngoal (1 subgoal):\n 1. upd a d''\n     (upd a d'\n       (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n         (dom f))) =\n    upd a d''\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))", "proof(induct \"dom f\" arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>{} = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))\n 2. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "case empty"], ["proof (state)\nthis:\n  {} = dom f\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>{} = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))\n 2. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "from \\<open>{} = dom f\\<close>"], ["proof (chain)\npicking this:\n  {} = dom f", "have \"f = Map.empty\""], ["proof (prove)\nusing this:\n  {} = dom f\n\ngoal (1 subgoal):\n 1. f = Map.empty", "by(auto simp add: dom_def)"], ["proof (state)\nthis:\n  f = Map.empty\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>{} = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))\n 2. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "thus ?case"], ["proof (prove)\nusing this:\n  f = Map.empty\n\ngoal (1 subgoal):\n 1. upd a d''\n     (upd a d'\n       (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n         (dom f))) =\n    upd a d''\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))", "by(auto simp add: finfun_const_def finfun_update_def upd_upd_twice)"], ["proof (state)\nthis:\n  upd a d''\n   (upd a d'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))) =\n  upd a d''\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom f))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "case (insert a' A)"], ["proof (state)\nthis:\n  finite A\n  a' \\<notin> A\n  \\<lbrakk>A = dom ?f; a \\<notin> dom ?f; ?f \\<subseteq>\\<^sub>m g\\<rbrakk>\n  \\<Longrightarrow> upd a d''\n                     (upd a d'\n                       (Finite_Set.fold\n                         (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                         (dom ?f))) =\n                    upd a d''\n                     (Finite_Set.fold\n                       (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                       (dom ?f))\n  insert a' A = dom f\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note IH = \\<open>\\<And>f. \\<lbrakk>A = dom f; a \\<notin> dom f; f \\<subseteq>\\<^sub>m g\\<rbrakk> \\<Longrightarrow> upd a d'' (upd a d' (?fr (dom f))) = upd a d'' (?fr (dom f))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>A = dom ?f; a \\<notin> dom ?f; ?f \\<subseteq>\\<^sub>m g\\<rbrakk>\n  \\<Longrightarrow> upd a d''\n                     (upd a d'\n                       (Finite_Set.fold\n                         (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                         (dom ?f))) =\n                    upd a d''\n                     (Finite_Set.fold\n                       (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                       (dom ?f))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note fin = \\<open>finite A\\<close>"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note anf = \\<open>a \\<notin> dom f\\<close>"], ["proof (state)\nthis:\n  a \\<notin> dom f\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note a'nA = \\<open>a' \\<notin> A\\<close>"], ["proof (state)\nthis:\n  a' \\<notin> A\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note domf = \\<open>insert a' A = dom f\\<close>"], ["proof (state)\nthis:\n  insert a' A = dom f\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note fg = \\<open>f \\<subseteq>\\<^sub>m g\\<close>"], ["proof (state)\nthis:\n  f \\<subseteq>\\<^sub>m g\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "from domf"], ["proof (chain)\npicking this:\n  insert a' A = dom f", "obtain b where b: \"f a' = Some b\""], ["proof (prove)\nusing this:\n  insert a' A = dom f\n\ngoal (1 subgoal):\n 1. (\\<And>b. f a' = Some b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f a' = Some b\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "let ?f' = \"f(a' := None)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "let ?b' = \"case f a' of None \\<Rightarrow> d | Some b \\<Rightarrow> b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "from domf"], ["proof (chain)\npicking this:\n  insert a' A = dom f", "have \"upd a d'' (upd a d' (?fr (dom f))) = upd a d'' (upd a d' (?fr (insert a' A)))\""], ["proof (prove)\nusing this:\n  insert a' A = dom f\n\ngoal (1 subgoal):\n 1. upd a d''\n     (upd a d'\n       (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n         (dom f))) =\n    upd a d''\n     (upd a d'\n       (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n         (insert a' A)))", "by simp"], ["proof (state)\nthis:\n  upd a d''\n   (upd a d'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))) =\n  upd a d''\n   (upd a d'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (insert a' A)))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "also"], ["proof (state)\nthis:\n  upd a d''\n   (upd a d'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))) =\n  upd a d''\n   (upd a d'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (insert a' A)))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note gwf.fold_insert[OF fin a'nA]"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) ?z (insert a' A) =\n  upd a' (map_default d g a')\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) ?z A)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "also"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) ?z (insert a' A) =\n  upd a' (map_default d g a')\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) ?z A)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "from b fg"], ["proof (chain)\npicking this:\n  f a' = Some b\n  f \\<subseteq>\\<^sub>m g", "have \"g a' = f a'\""], ["proof (prove)\nusing this:\n  f a' = Some b\n  f \\<subseteq>\\<^sub>m g\n\ngoal (1 subgoal):\n 1. g a' = f a'", "by(auto simp add: map_le_def intro: domI dest: bspec)"], ["proof (state)\nthis:\n  g a' = f a'\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "hence ga': \"map_default d g a' = map_default d f a'\""], ["proof (prove)\nusing this:\n  g a' = f a'\n\ngoal (1 subgoal):\n 1. map_default d g a' = map_default d f a'", "by(simp add: map_default_def)"], ["proof (state)\nthis:\n  map_default d g a' = map_default d f a'\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "also"], ["proof (state)\nthis:\n  map_default d g a' = map_default d f a'\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "from anf domf"], ["proof (chain)\npicking this:\n  a \\<notin> dom f\n  insert a' A = dom f", "have ana': \"a \\<noteq> a'\""], ["proof (prove)\nusing this:\n  a \\<notin> dom f\n  insert a' A = dom f\n\ngoal (1 subgoal):\n 1. a \\<noteq> a'", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note upd_commute[OF this]"], ["proof (state)\nthis:\n  upd a ?b (upd a' ?b' ?c) = upd a' ?b' (upd a ?b ?c)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "also"], ["proof (state)\nthis:\n  upd a ?b (upd a' ?b' ?c) = upd a' ?b' (upd a ?b ?c)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note upd_commute[OF ana']"], ["proof (state)\nthis:\n  upd a ?b (upd a' ?b' ?c) = upd a' ?b' (upd a ?b ?c)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "also"], ["proof (state)\nthis:\n  upd a ?b (upd a' ?b' ?c) = upd a' ?b' (upd a ?b ?c)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "from domf a'nA anf fg"], ["proof (chain)\npicking this:\n  insert a' A = dom f\n  a' \\<notin> A\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g", "have \"a \\<notin> dom ?f'\" \"?f' \\<subseteq>\\<^sub>m g\" and A: \"A = dom ?f'\""], ["proof (prove)\nusing this:\n  insert a' A = dom f\n  a' \\<notin> A\n  a \\<notin> dom f\n  f \\<subseteq>\\<^sub>m g\n\ngoal (1 subgoal):\n 1. (a \\<notin> dom (f(a' := None)) &&&\n     f(a' := None) \\<subseteq>\\<^sub>m g) &&&\n    A = dom (f(a' := None))", "by(auto simp add: ran_def map_le_def)"], ["proof (state)\nthis:\n  a \\<notin> dom (f(a' := None))\n  f(a' := None) \\<subseteq>\\<^sub>m g\n  A = dom (f(a' := None))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note A"], ["proof (state)\nthis:\n  A = dom (f(a' := None))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "also"], ["proof (state)\nthis:\n  A = dom (f(a' := None))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note IH[OF A \\<open>a \\<notin> dom ?f'\\<close> \\<open>?f' \\<subseteq>\\<^sub>m g\\<close>]"], ["proof (state)\nthis:\n  upd a d''\n   (upd a d'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom (f(a' := None))))) =\n  upd a d''\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom (f(a' := None))))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "also"], ["proof (state)\nthis:\n  upd a d''\n   (upd a d'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom (f(a' := None))))) =\n  upd a d''\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom (f(a' := None))))\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note upd_commute[OF ana'[symmetric]]"], ["proof (state)\nthis:\n  upd a' ?b (upd a ?b' ?c) = upd a ?b' (upd a' ?b ?c)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "also"], ["proof (state)\nthis:\n  upd a' ?b (upd a ?b' ?c) = upd a ?b' (upd a' ?b ?c)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note ga'[symmetric]"], ["proof (state)\nthis:\n  map_default d f a' = map_default d g a'\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "also"], ["proof (state)\nthis:\n  map_default d f a' = map_default d g a'\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note A[symmetric]"], ["proof (state)\nthis:\n  dom (f(a' := None)) = A\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "also"], ["proof (state)\nthis:\n  dom (f(a' := None)) = A\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note gwf.fold_insert[symmetric, OF fin a'nA]"], ["proof (state)\nthis:\n  upd a' (map_default d g a')\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) ?z A) =\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) ?z (insert a' A)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "also"], ["proof (state)\nthis:\n  upd a' (map_default d g a')\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) ?z A) =\n  Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) ?z (insert a' A)\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "note domf"], ["proof (state)\nthis:\n  insert a' A = dom f\n\ngoal (1 subgoal):\n 1. \\<And>x F f.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>f.\n           \\<lbrakk>F = dom f; a \\<notin> dom f;\n            f \\<subseteq>\\<^sub>m g\\<rbrakk>\n           \\<Longrightarrow> upd a d''\n                              (upd a d'\n                                (Finite_Set.fold\n                                  (\\<lambda>a. upd a (map_default d g a))\n                                  (cnst d) (dom f))) =\n                             upd a d''\n                              (Finite_Set.fold\n                                (\\<lambda>a. upd a (map_default d g a))\n                                (cnst d) (dom f));\n        insert x F = dom f; a \\<notin> dom f;\n        f \\<subseteq>\\<^sub>m g\\<rbrakk>\n       \\<Longrightarrow> upd a d''\n                          (upd a d'\n                            (Finite_Set.fold\n                              (\\<lambda>a. upd a (map_default d g a))\n                              (cnst d) (dom f))) =\n                         upd a d''\n                          (Finite_Set.fold\n                            (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n                            (dom f))", "finally"], ["proof (chain)\npicking this:\n  upd a d''\n   (upd a d'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))) =\n  upd a d''\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom f))", "show ?case"], ["proof (prove)\nusing this:\n  upd a d''\n   (upd a d'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))) =\n  upd a d''\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom f))\n\ngoal (1 subgoal):\n 1. upd a d''\n     (upd a d'\n       (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n         (dom f))) =\n    upd a d''\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))", "."], ["proof (state)\nthis:\n  upd a d''\n   (upd a d'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))) =\n  upd a d''\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upd a d''\n   (upd a d'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n       (dom f))) =\n  upd a d''\n   (Finite_Set.fold (\\<lambda>a. upd a (map_default d g a)) (cnst d)\n     (dom f))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_default_eq_id [simp]: \"map_default d ((\\<lambda>a. Some (f a)) |` {a. f a \\<noteq> d}) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_default d ((\\<lambda>a. Some (f a)) |` {a. f a \\<noteq> d}) = f", "by(auto simp add: map_default_def restrict_map_def)"], ["", "lemma finite_rec_cong1:\n  assumes f: \"comp_fun_commute f\" and g: \"comp_fun_commute g\"\n  and fin: \"finite A\"\n  and eq: \"\\<And>a. a \\<in> A \\<Longrightarrow> f a = g a\"\n  shows \"Finite_Set.fold f z A = Finite_Set.fold g z A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "interpret f: comp_fun_commute f"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute f", "by(rule f)"], ["proof (state)\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "interpret g: comp_fun_commute g"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute g", "by(rule g)"], ["proof (state)\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "assume BsubA: \"B \\<subseteq> A\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "with fin"], ["proof (chain)\npicking this:\n  finite A\n  B \\<subseteq> A", "have \"finite B\""], ["proof (prove)\nusing this:\n  finite A\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. finite B", "by(blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite B\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "hence \"B \\<subseteq> A \\<Longrightarrow> Finite_Set.fold f z B = Finite_Set.fold g z B\""], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. B \\<subseteq> A \\<Longrightarrow>\n    Finite_Set.fold f z B = Finite_Set.fold g z B", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<subseteq> A \\<Longrightarrow>\n    Finite_Set.fold f z {} = Finite_Set.fold g z {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> A \\<Longrightarrow>\n        Finite_Set.fold f z F = Finite_Set.fold g z F;\n        insert x F \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f z (insert x F) =\n                         Finite_Set.fold g z (insert x F)", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> A\n\ngoal (2 subgoals):\n 1. {} \\<subseteq> A \\<Longrightarrow>\n    Finite_Set.fold f z {} = Finite_Set.fold g z {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> A \\<Longrightarrow>\n        Finite_Set.fold f z F = Finite_Set.fold g z F;\n        insert x F \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f z (insert x F) =\n                         Finite_Set.fold g z (insert x F)", "thus ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z {} = Finite_Set.fold g z {}", "by simp"], ["proof (state)\nthis:\n  Finite_Set.fold f z {} = Finite_Set.fold g z {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> A \\<Longrightarrow>\n        Finite_Set.fold f z F = Finite_Set.fold g z F;\n        insert x F \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f z (insert x F) =\n                         Finite_Set.fold g z (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> A \\<Longrightarrow>\n        Finite_Set.fold f z F = Finite_Set.fold g z F;\n        insert x F \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f z (insert x F) =\n                         Finite_Set.fold g z (insert x F)", "case (insert a B)"], ["proof (state)\nthis:\n  finite B\n  a \\<notin> B\n  B \\<subseteq> A \\<Longrightarrow>\n  Finite_Set.fold f z B = Finite_Set.fold g z B\n  insert a B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> A \\<Longrightarrow>\n        Finite_Set.fold f z F = Finite_Set.fold g z F;\n        insert x F \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f z (insert x F) =\n                         Finite_Set.fold g z (insert x F)", "note finB = \\<open>finite B\\<close>"], ["proof (state)\nthis:\n  finite B\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> A \\<Longrightarrow>\n        Finite_Set.fold f z F = Finite_Set.fold g z F;\n        insert x F \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f z (insert x F) =\n                         Finite_Set.fold g z (insert x F)", "note anB = \\<open>a \\<notin> B\\<close>"], ["proof (state)\nthis:\n  a \\<notin> B\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> A \\<Longrightarrow>\n        Finite_Set.fold f z F = Finite_Set.fold g z F;\n        insert x F \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f z (insert x F) =\n                         Finite_Set.fold g z (insert x F)", "note sub = \\<open>insert a B \\<subseteq> A\\<close>"], ["proof (state)\nthis:\n  insert a B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> A \\<Longrightarrow>\n        Finite_Set.fold f z F = Finite_Set.fold g z F;\n        insert x F \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f z (insert x F) =\n                         Finite_Set.fold g z (insert x F)", "note IH = \\<open>B \\<subseteq> A \\<Longrightarrow> Finite_Set.fold f z B = Finite_Set.fold g z B\\<close>"], ["proof (state)\nthis:\n  B \\<subseteq> A \\<Longrightarrow>\n  Finite_Set.fold f z B = Finite_Set.fold g z B\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> A \\<Longrightarrow>\n        Finite_Set.fold f z F = Finite_Set.fold g z F;\n        insert x F \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f z (insert x F) =\n                         Finite_Set.fold g z (insert x F)", "from sub anB"], ["proof (chain)\npicking this:\n  insert a B \\<subseteq> A\n  a \\<notin> B", "have BpsubA: \"B \\<subset> A\" and BsubA: \"B \\<subseteq> A\" and aA: \"a \\<in> A\""], ["proof (prove)\nusing this:\n  insert a B \\<subseteq> A\n  a \\<notin> B\n\ngoal (1 subgoal):\n 1. B \\<subset> A &&& B \\<subseteq> A &&& a \\<in> A", "by auto"], ["proof (state)\nthis:\n  B \\<subset> A\n  B \\<subseteq> A\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> A \\<Longrightarrow>\n        Finite_Set.fold f z F = Finite_Set.fold g z F;\n        insert x F \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f z (insert x F) =\n                         Finite_Set.fold g z (insert x F)", "from IH[OF BsubA] eq[OF aA] finB anB"], ["proof (chain)\npicking this:\n  Finite_Set.fold f z B = Finite_Set.fold g z B\n  f a = g a\n  finite B\n  a \\<notin> B", "show ?case"], ["proof (prove)\nusing this:\n  Finite_Set.fold f z B = Finite_Set.fold g z B\n  f a = g a\n  finite B\n  a \\<notin> B\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z (insert a B) = Finite_Set.fold g z (insert a B)", "by(auto)"], ["proof (state)\nthis:\n  Finite_Set.fold f z (insert a B) = Finite_Set.fold g z (insert a B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B \\<subseteq> A \\<Longrightarrow>\n  Finite_Set.fold f z B = Finite_Set.fold g z B\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "with BsubA"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  B \\<subseteq> A \\<Longrightarrow>\n  Finite_Set.fold f z B = Finite_Set.fold g z B", "have \"Finite_Set.fold f z B = Finite_Set.fold g z B\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  B \\<subseteq> A \\<Longrightarrow>\n  Finite_Set.fold f z B = Finite_Set.fold g z B\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z B = Finite_Set.fold g z B", "by blast"], ["proof (state)\nthis:\n  Finite_Set.fold f z B = Finite_Set.fold g z B\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "}"], ["proof (state)\nthis:\n  ?B2 \\<subseteq> A \\<Longrightarrow>\n  Finite_Set.fold f z ?B2 = Finite_Set.fold g z ?B2\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?B2 \\<subseteq> A \\<Longrightarrow>\n  Finite_Set.fold f z ?B2 = Finite_Set.fold g z ?B2\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z A = Finite_Set.fold g z A", "by blast"], ["proof (state)\nthis:\n  Finite_Set.fold f z A = Finite_Set.fold g z A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_rec_upd [simp]:\n  \"finfun_rec cnst upd (f(a' $:= b')) = upd a' b' (finfun_rec cnst upd f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "obtain b where b: \"b = finfun_default f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        b = finfun_default f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b = finfun_default f\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "let ?the = \"\\<lambda>f g. f = Abs_finfun (map_default b g) \\<and> finite (dom g) \\<and> b \\<notin> ran g\""], ["proof (state)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "obtain g where g: \"g = The (?the f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        g =\n        (THE g.\n            f = Abs_finfun (map_default b g) \\<and>\n            finite (dom g) \\<and> b \\<notin> ran g) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g =\n  (THE g.\n      f = Abs_finfun (map_default b g) \\<and>\n      finite (dom g) \\<and> b \\<notin> ran g)\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "obtain y where f: \"f = Abs_finfun y\" and y: \"y \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>f = Abs_finfun y; y \\<in> finfun\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases f)"], ["proof (state)\nthis:\n  f = Abs_finfun y\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "from f y b"], ["proof (chain)\npicking this:\n  f = Abs_finfun y\n  y \\<in> finfun\n  b = finfun_default f", "have bfin: \"finite {a. y a \\<noteq> b}\""], ["proof (prove)\nusing this:\n  f = Abs_finfun y\n  y \\<in> finfun\n  b = finfun_default f\n\ngoal (1 subgoal):\n 1. finite {a. y a \\<noteq> b}", "by(simp add: finfun_default_def finite_finfun_default_aux)"], ["proof (state)\nthis:\n  finite {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "let ?g = \"(\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "from bfin"], ["proof (chain)\npicking this:\n  finite {a. y a \\<noteq> b}", "have fing: \"finite (dom ?g)\""], ["proof (prove)\nusing this:\n  finite {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))", "by auto"], ["proof (state)\nthis:\n  finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have bran: \"b \\<notin> ran ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> ran ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})", "by(auto simp add: ran_def restrict_map_def)"], ["proof (state)\nthis:\n  b \\<notin> ran ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have yg: \"y = map_default b ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})", "by simp"], ["proof (state)\nthis:\n  y = map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have gg: \"g = ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "unfolding g"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE g.\n        f = Abs_finfun (map_default b g) \\<and>\n        finite (dom g) \\<and> b \\<notin> ran g) =\n    (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "proof(rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. f =\n    Abs_finfun\n     (map_default b\n       ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) \\<and>\n    finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) \\<and>\n    b \\<notin> ran ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n 2. \\<And>g.\n       f = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "from f y bfin"], ["proof (chain)\npicking this:\n  f = Abs_finfun y\n  y \\<in> finfun\n  finite {a. y a \\<noteq> b}", "show \"?the f ?g\""], ["proof (prove)\nusing this:\n  f = Abs_finfun y\n  y \\<in> finfun\n  finite {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. f =\n    Abs_finfun\n     (map_default b\n       ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) \\<and>\n    finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) \\<and>\n    b \\<notin> ran ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})", "by(auto)(simp add: restrict_map_def ran_def split: if_split_asm)"], ["proof (state)\nthis:\n  f =\n  Abs_finfun\n   (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) \\<and>\n  finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) \\<and>\n  b \\<notin> ran ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       f = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "fix g'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       f = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "assume \"?the f g'\""], ["proof (state)\nthis:\n  f = Abs_finfun (map_default b g') \\<and>\n  finite (dom g') \\<and> b \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "hence fin': \"finite (dom g')\" and ran': \"b \\<notin> ran g'\"\n      and eq: \"Abs_finfun (map_default b ?g) = Abs_finfun (map_default b g')\""], ["proof (prove)\nusing this:\n  f = Abs_finfun (map_default b g') \\<and>\n  finite (dom g') \\<and> b \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. finite (dom g') &&&\n    b \\<notin> ran g' &&&\n    Abs_finfun\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n    Abs_finfun (map_default b g')", "using f yg"], ["proof (prove)\nusing this:\n  f = Abs_finfun (map_default b g') \\<and>\n  finite (dom g') \\<and> b \\<notin> ran g'\n  f = Abs_finfun y\n  y = map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n\ngoal (1 subgoal):\n 1. finite (dom g') &&&\n    b \\<notin> ran g' &&&\n    Abs_finfun\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n    Abs_finfun (map_default b g')", "by auto"], ["proof (state)\nthis:\n  finite (dom g')\n  b \\<notin> ran g'\n  Abs_finfun\n   (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  Abs_finfun (map_default b g')\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "from fin' fing"], ["proof (chain)\npicking this:\n  finite (dom g')\n  finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))", "have \"map_default b ?g \\<in> finfun\" \"map_default b g' \\<in> finfun\""], ["proof (prove)\nusing this:\n  finite (dom g')\n  finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n    \\<in> finfun &&&\n    map_default b g' \\<in> finfun", "by(blast intro: map_default_in_finfun)+"], ["proof (state)\nthis:\n  map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n  \\<in> finfun\n  map_default b g' \\<in> finfun\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "with eq"], ["proof (chain)\npicking this:\n  Abs_finfun\n   (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  Abs_finfun (map_default b g')\n  map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n  \\<in> finfun\n  map_default b g' \\<in> finfun", "have \"map_default b ?g = map_default b g'\""], ["proof (prove)\nusing this:\n  Abs_finfun\n   (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  Abs_finfun (map_default b g')\n  map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n  \\<in> finfun\n  map_default b g' \\<in> finfun\n\ngoal (1 subgoal):\n 1. map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) =\n    map_default b g'", "by simp"], ["proof (state)\nthis:\n  map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) =\n  map_default b g'\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "with fing bran fin' ran'"], ["proof (chain)\npicking this:\n  finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n  b \\<notin> ran ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n  finite (dom g')\n  b \\<notin> ran g'\n  map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) =\n  map_default b g'", "show \"g' = ?g\""], ["proof (prove)\nusing this:\n  finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n  b \\<notin> ran ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n  finite (dom g')\n  b \\<notin> ran g'\n  map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) =\n  map_default b g'\n\ngoal (1 subgoal):\n 1. g' = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "by(rule map_default_inject[OF disjI2[OF refl], THEN sym])"], ["proof (state)\nthis:\n  g' = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "proof(cases \"b' = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "case True"], ["proof (state)\nthis:\n  b' = b\n\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "note b'b = True"], ["proof (state)\nthis:\n  b' = b\n\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "let ?g' = \"(\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}\""], ["proof (state)\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "from bfin b'b"], ["proof (chain)\npicking this:\n  finite {a. y a \\<noteq> b}\n  b' = b", "have fing': \"finite (dom ?g')\""], ["proof (prove)\nusing this:\n  finite {a. y a \\<noteq> b}\n  b' = b\n\ngoal (1 subgoal):\n 1. finite\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b}))", "by(auto simp add: Collect_conj_eq Collect_imp_eq intro: finite_subset)"], ["proof (state)\nthis:\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have brang': \"b \\<notin> ran ?g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> ran ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                    {a. (y(a' := b)) a \\<noteq> b})", "by(auto simp add: ran_def restrict_map_def)"], ["proof (state)\nthis:\n  b \\<notin> ran ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                  {a. (y(a' := b)) a \\<noteq> b})\n\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "let ?b' = \"\\<lambda>a. case ?g' a of None \\<Rightarrow> b | Some b \\<Rightarrow> b\""], ["proof (state)\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "let ?b = \"map_default b ?g\""], ["proof (state)\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "from upd_left_comm upd_left_comm fing'"], ["proof (chain)\npicking this:\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))", "have \"Finite_Set.fold (\\<lambda>a. upd a (?b' a)) (cnst b) (dom ?g') = Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (dom ?g')\""], ["proof (prove)\nusing this:\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (case ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                 {a. (y(a' := b)) a \\<noteq> b})\n                 a of\n           None \\<Rightarrow> b | Some b \\<Rightarrow> b))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b}))", "by(rule finite_rec_cong1)(auto simp add: restrict_map_def b'b b map_default_def)"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (case ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n               {a. (y(a' := b)) a \\<noteq> b})\n               a of\n         None \\<Rightarrow> b | Some b \\<Rightarrow> b))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b})) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "also"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (case ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n               {a. (y(a' := b)) a \\<noteq> b})\n               a of\n         None \\<Rightarrow> b | Some b \\<Rightarrow> b))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b})) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "interpret gwf: comp_fun_commute \"\\<lambda>a. upd a (?b a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))", "by(rule upd_left_comm)"], ["proof (state)\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have \"Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (dom ?g') = upd a' b' (Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (dom ?g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "proof(cases \"y a' = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y a' = b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n 2. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "case True"], ["proof (state)\nthis:\n  y a' = b\n\ngoal (2 subgoals):\n 1. y a' = b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n 2. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "with b'b"], ["proof (chain)\npicking this:\n  b' = b\n  y a' = b", "have g': \"?g' = ?g\""], ["proof (prove)\nusing this:\n  b' = b\n  y a' = b\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b} =\n    (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "by(auto simp add: restrict_map_def)"], ["proof (state)\nthis:\n  (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b} =\n  (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}\n\ngoal (2 subgoals):\n 1. y a' = b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n 2. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "from True"], ["proof (chain)\npicking this:\n  y a' = b", "have a'ndomg: \"a' \\<notin> dom ?g\""], ["proof (prove)\nusing this:\n  y a' = b\n\ngoal (1 subgoal):\n 1. a' \\<notin> dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})", "by auto"], ["proof (state)\nthis:\n  a' \\<notin> dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n\ngoal (2 subgoals):\n 1. y a' = b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n 2. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "from f b'b b"], ["proof (chain)\npicking this:\n  f = Abs_finfun y\n  b' = b\n  b = finfun_default f", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Abs_finfun y\n  b' = b\n  b = finfun_default f\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "unfolding g'"], ["proof (prove)\nusing this:\n  f = Abs_finfun y\n  b' = b\n  b = finfun_default f\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "by(subst map_default_update_const[OF fing a'ndomg map_le_refl, symmetric]) simp"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b})) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "case False"], ["proof (state)\nthis:\n  y a' \\<noteq> b\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "hence domg: \"dom ?g = insert a' (dom ?g')\""], ["proof (prove)\nusing this:\n  y a' \\<noteq> b\n\ngoal (1 subgoal):\n 1. dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) =\n    insert a'\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b}))", "by auto"], ["proof (state)\nthis:\n  dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) =\n  insert a'\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "from False b'b"], ["proof (chain)\npicking this:\n  y a' \\<noteq> b\n  b' = b", "have a'ndomg': \"a' \\<notin> dom ?g'\""], ["proof (prove)\nusing this:\n  y a' \\<noteq> b\n  b' = b\n\ngoal (1 subgoal):\n 1. a' \\<notin> dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                     {a. (y(a' := b)) a \\<noteq> b})", "by auto"], ["proof (state)\nthis:\n  a' \\<notin> dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                   {a. (y(a' := b)) a \\<noteq> b})\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "have \"Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (insert a' (dom ?g')) = \n            upd a' (?b a') (Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (dom ?g'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b}))) =\n    upd a'\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b})))", "using fing' a'ndomg'"], ["proof (prove)\nusing this:\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n  a' \\<notin> dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                   {a. (y(a' := b)) a \\<noteq> b})\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b}))) =\n    upd a'\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b})))", "unfolding b'b"], ["proof (prove)\nusing this:\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n  a' \\<notin> dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                   {a. (y(a' := b)) a \\<noteq> b})\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b}))) =\n    upd a'\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b})))", "by(rule gwf.fold_insert)"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (insert a'\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b}))) =\n  upd a'\n   (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "hence \"upd a' b (Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (insert a' (dom ?g'))) =\n             upd a' b (upd a' (?b a') (Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (dom ?g')))\""], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (insert a'\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b}))) =\n  upd a'\n   (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})))\n\ngoal (1 subgoal):\n 1. upd a' b\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (insert a'\n         (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n               {a. (y(a' := b)) a \\<noteq> b})))) =\n    upd a' b\n     (upd a'\n       (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n       (Finite_Set.fold\n         (\\<lambda>a.\n             upd a\n              (map_default b\n                ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n         (cnst b)\n         (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n               {a. (y(a' := b)) a \\<noteq> b}))))", "by simp"], ["proof (state)\nthis:\n  upd a' b\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b})))) =\n  upd a' b\n   (upd a'\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b}))))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "also"], ["proof (state)\nthis:\n  upd a' b\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b})))) =\n  upd a' b\n   (upd a'\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b}))))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "from b'b"], ["proof (chain)\npicking this:\n  b' = b", "have g'leg: \"?g' \\<subseteq>\\<^sub>m ?g\""], ["proof (prove)\nusing this:\n  b' = b\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. Some ((y(a' := b)) a)) |`\n    {a. (y(a' := b)) a \\<noteq> b} \\<subseteq>\\<^sub>m\n    (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "by(auto simp add: restrict_map_def map_le_def)"], ["proof (state)\nthis:\n  (\\<lambda>a. Some ((y(a' := b)) a)) |`\n  {a. (y(a' := b)) a \\<noteq> b} \\<subseteq>\\<^sub>m\n  (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "note map_default_update_twice[OF fing' a'ndomg' this, of b \"?b a'\" b]"], ["proof (state)\nthis:\n  upd a' b\n   (upd a'\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b})))) =\n  upd a' b\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "also"], ["proof (state)\nthis:\n  upd a' b\n   (upd a'\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b})))) =\n  upd a' b\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "note map_default_update_const[OF fing' a'ndomg' g'leg, of b]"], ["proof (state)\nthis:\n  upd a' b\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b}))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "finally"], ["proof (chain)\npicking this:\n  upd a' b\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b})))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))", "show ?thesis"], ["proof (prove)\nusing this:\n  upd a' b\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b})))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "unfolding b'b domg[unfolded b'b]"], ["proof (prove)\nusing this:\n  upd a' b\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n             {a. (y(a' := b)) a \\<noteq> b})))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) =\n    upd a' b\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (insert a'\n         (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n               {a. (y(a' := b)) a \\<noteq> b}))))", "by(rule sym)"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b})) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b})) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "also"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b})) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have \"The (?the (f(a' $:= b'))) = ?g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE g.\n        f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n        finite (dom g) \\<and> b \\<notin> ran g) =\n    (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}", "proof(rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. f(a' $:= b') =\n    Abs_finfun\n     (map_default b\n       ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n        {a. (y(a' := b)) a \\<noteq> b})) \\<and>\n    finite\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) \\<and>\n    b \\<notin> ran ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                    {a. (y(a' := b)) a \\<noteq> b})\n 2. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g =\n       (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}", "from f y b b'b brang' fing'"], ["proof (chain)\npicking this:\n  f = Abs_finfun y\n  y \\<in> finfun\n  b = finfun_default f\n  b' = b\n  b \\<notin> ran ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                  {a. (y(a' := b)) a \\<noteq> b})\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))", "show \"?the (f(a' $:= b')) ?g'\""], ["proof (prove)\nusing this:\n  f = Abs_finfun y\n  y \\<in> finfun\n  b = finfun_default f\n  b' = b\n  b \\<notin> ran ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                  {a. (y(a' := b)) a \\<noteq> b})\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. f(a' $:= b') =\n    Abs_finfun\n     (map_default b\n       ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n        {a. (y(a' := b)) a \\<noteq> b})) \\<and>\n    finite\n     (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n           {a. (y(a' := b)) a \\<noteq> b})) \\<and>\n    b \\<notin> ran ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                    {a. (y(a' := b)) a \\<noteq> b})", "by(auto simp del: fun_upd_apply simp add: finfun_update_def)"], ["proof (state)\nthis:\n  f(a' $:= b') =\n  Abs_finfun\n   (map_default b\n     ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n      {a. (y(a' := b)) a \\<noteq> b})) \\<and>\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b})) \\<and>\n  b \\<notin> ran ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                  {a. (y(a' := b)) a \\<noteq> b})\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g =\n       (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g =\n       (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}", "fix g'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g =\n       (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}", "assume \"?the (f(a' $:= b')) g'\""], ["proof (state)\nthis:\n  f(a' $:= b') = Abs_finfun (map_default b g') \\<and>\n  finite (dom g') \\<and> b \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g =\n       (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}", "hence fin': \"finite (dom g')\" and ran': \"b \\<notin> ran g'\"\n        and eq: \"f(a' $:= b') = Abs_finfun (map_default b g')\""], ["proof (prove)\nusing this:\n  f(a' $:= b') = Abs_finfun (map_default b g') \\<and>\n  finite (dom g') \\<and> b \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. finite (dom g') &&&\n    b \\<notin> ran g' &&& f(a' $:= b') = Abs_finfun (map_default b g')", "by(auto simp del: fun_upd_apply)"], ["proof (state)\nthis:\n  finite (dom g')\n  b \\<notin> ran g'\n  f(a' $:= b') = Abs_finfun (map_default b g')\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g =\n       (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}", "from fin' fing'"], ["proof (chain)\npicking this:\n  finite (dom g')\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))", "have \"map_default b g' \\<in> finfun\" \"map_default b ?g' \\<in> finfun\""], ["proof (prove)\nusing this:\n  finite (dom g')\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. map_default b g' \\<in> finfun &&&\n    map_default b\n     ((\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b})\n    \\<in> finfun", "by(blast intro: map_default_in_finfun)+"], ["proof (state)\nthis:\n  map_default b g' \\<in> finfun\n  map_default b\n   ((\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b})\n  \\<in> finfun\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g =\n       (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}", "with eq f b'b b"], ["proof (chain)\npicking this:\n  f(a' $:= b') = Abs_finfun (map_default b g')\n  f = Abs_finfun y\n  b' = b\n  b = finfun_default f\n  map_default b g' \\<in> finfun\n  map_default b\n   ((\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b})\n  \\<in> finfun", "have \"map_default b ?g' = map_default b g'\""], ["proof (prove)\nusing this:\n  f(a' $:= b') = Abs_finfun (map_default b g')\n  f = Abs_finfun y\n  b' = b\n  b = finfun_default f\n  map_default b g' \\<in> finfun\n  map_default b\n   ((\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b})\n  \\<in> finfun\n\ngoal (1 subgoal):\n 1. map_default b\n     ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n      {a. (y(a' := b)) a \\<noteq> b}) =\n    map_default b g'", "by(simp del: fun_upd_apply add: finfun_update_def)"], ["proof (state)\nthis:\n  map_default b\n   ((\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}) =\n  map_default b g'\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g =\n       (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}", "with fing' brang' fin' ran'"], ["proof (chain)\npicking this:\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n  b \\<notin> ran ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                  {a. (y(a' := b)) a \\<noteq> b})\n  finite (dom g')\n  b \\<notin> ran g'\n  map_default b\n   ((\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}) =\n  map_default b g'", "show \"g' = ?g'\""], ["proof (prove)\nusing this:\n  finite\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b}))\n  b \\<notin> ran ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n                  {a. (y(a' := b)) a \\<noteq> b})\n  finite (dom g')\n  b \\<notin> ran g'\n  map_default b\n   ((\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}) =\n  map_default b g'\n\ngoal (1 subgoal):\n 1. g' =\n    (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}", "by(rule map_default_inject[OF disjI2[OF refl], THEN sym])"], ["proof (state)\nthis:\n  g' = (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (THE g.\n      f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n      finite (dom g) \\<and> b \\<notin> ran g) =\n  (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}\n\ngoal (2 subgoals):\n 1. b' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "ultimately"], ["proof (chain)\npicking this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (case ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n               {a. (y(a' := b)) a \\<noteq> b})\n               a of\n         None \\<Rightarrow> b | Some b \\<Rightarrow> b))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b})) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n  (THE g.\n      f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n      finite (dom g) \\<and> b \\<notin> ran g) =\n  (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}", "show ?thesis"], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (case ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n               {a. (y(a' := b)) a \\<noteq> b})\n               a of\n         None \\<Rightarrow> b | Some b \\<Rightarrow> b))\n   (cnst b)\n   (dom ((\\<lambda>a. Some ((y(a' := b)) a)) |`\n         {a. (y(a' := b)) a \\<noteq> b})) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n  (THE g.\n      f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n      finite (dom g) \\<and> b \\<notin> ran g) =\n  (\\<lambda>a. Some ((y(a' := b)) a)) |` {a. (y(a' := b)) a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "unfolding finfun_rec_def Let_def b gg[unfolded g b]"], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (case ((\\<lambda>a. Some ((y(a' := finfun_default f)) a)) |`\n               {a. (y(a' := finfun_default f)) a \\<noteq> finfun_default f})\n               a of\n         None \\<Rightarrow> finfun_default f | Some b \\<Rightarrow> b))\n   (cnst (finfun_default f))\n   (dom ((\\<lambda>a. Some ((y(a' := finfun_default f)) a)) |`\n         {a. (y(a' := finfun_default f)) a \\<noteq> finfun_default f})) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default (finfun_default f)\n            ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> finfun_default f})\n            a))\n     (cnst (finfun_default f))\n     (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> finfun_default f})))\n  (THE g.\n      f(a' $:= b') = Abs_finfun (map_default (finfun_default f) g) \\<and>\n      finite (dom g) \\<and> finfun_default f \\<notin> ran g) =\n  (\\<lambda>a. Some ((y(a' := finfun_default f)) a)) |`\n  {a. (y(a' := finfun_default f)) a \\<noteq> finfun_default f}\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default (finfun_default f(a' $:= b'))\n            (THE g.\n                f(a' $:= b') =\n                Abs_finfun\n                 (map_default (finfun_default f(a' $:= b')) g) \\<and>\n                finite (dom g) \\<and>\n                finfun_default f(a' $:= b') \\<notin> ran g)\n            a))\n     (cnst (finfun_default f(a' $:= b')))\n     (dom (THE g.\n              f(a' $:= b') =\n              Abs_finfun\n               (map_default (finfun_default f(a' $:= b')) g) \\<and>\n              finite (dom g) \\<and>\n              finfun_default f(a' $:= b') \\<notin> ran g)) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default (finfun_default f)\n              ((\\<lambda>a. Some (y a)) |`\n               {a. y a \\<noteq> finfun_default f})\n              a))\n       (cnst (finfun_default f))\n       (dom ((\\<lambda>a. Some (y a)) |`\n             {a. y a \\<noteq> finfun_default f})))", "using bfin b'b b"], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (case ((\\<lambda>a. Some ((y(a' := finfun_default f)) a)) |`\n               {a. (y(a' := finfun_default f)) a \\<noteq> finfun_default f})\n               a of\n         None \\<Rightarrow> finfun_default f | Some b \\<Rightarrow> b))\n   (cnst (finfun_default f))\n   (dom ((\\<lambda>a. Some ((y(a' := finfun_default f)) a)) |`\n         {a. (y(a' := finfun_default f)) a \\<noteq> finfun_default f})) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default (finfun_default f)\n            ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> finfun_default f})\n            a))\n     (cnst (finfun_default f))\n     (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> finfun_default f})))\n  (THE g.\n      f(a' $:= b') = Abs_finfun (map_default (finfun_default f) g) \\<and>\n      finite (dom g) \\<and> finfun_default f \\<notin> ran g) =\n  (\\<lambda>a. Some ((y(a' := finfun_default f)) a)) |`\n  {a. (y(a' := finfun_default f)) a \\<noteq> finfun_default f}\n  finite {a. y a \\<noteq> b}\n  b' = b\n  b = finfun_default f\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default (finfun_default f(a' $:= b'))\n            (THE g.\n                f(a' $:= b') =\n                Abs_finfun\n                 (map_default (finfun_default f(a' $:= b')) g) \\<and>\n                finite (dom g) \\<and>\n                finfun_default f(a' $:= b') \\<notin> ran g)\n            a))\n     (cnst (finfun_default f(a' $:= b')))\n     (dom (THE g.\n              f(a' $:= b') =\n              Abs_finfun\n               (map_default (finfun_default f(a' $:= b')) g) \\<and>\n              finite (dom g) \\<and>\n              finfun_default f(a' $:= b') \\<notin> ran g)) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default (finfun_default f)\n              ((\\<lambda>a. Some (y a)) |`\n               {a. y a \\<noteq> finfun_default f})\n              a))\n       (cnst (finfun_default f))\n       (dom ((\\<lambda>a. Some (y a)) |`\n             {a. y a \\<noteq> finfun_default f})))", "by(simp only: finfun_default_update_const map_default_def)"], ["proof (state)\nthis:\n  finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "case False"], ["proof (state)\nthis:\n  b' \\<noteq> b\n\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "note b'b = this"], ["proof (state)\nthis:\n  b' \\<noteq> b\n\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "let ?g' = \"?g(a' \\<mapsto> b')\""], ["proof (state)\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "let ?b' = \"map_default b ?g'\""], ["proof (state)\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "let ?b = \"map_default b ?g\""], ["proof (state)\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "from fing"], ["proof (chain)\npicking this:\n  finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))", "have fing': \"finite (dom ?g')\""], ["proof (prove)\nusing this:\n  finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. finite\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b')))", "by auto"], ["proof (state)\nthis:\n  finite\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n         b')))\n\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "from bran b'b"], ["proof (chain)\npicking this:\n  b \\<notin> ran ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n  b' \\<noteq> b", "have bnrang': \"b \\<notin> ran ?g'\""], ["proof (prove)\nusing this:\n  b \\<notin> ran ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n  b' \\<noteq> b\n\ngoal (1 subgoal):\n 1. b \\<notin> ran (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \n                    \\<mapsto> b'))", "by(auto simp add: ran_def)"], ["proof (state)\nthis:\n  b \\<notin> ran (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \n                  \\<mapsto> b'))\n\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have ffmg': \"map_default b ?g' = y(a' := b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')) =\n    y(a' := b')", "by(auto simp add: map_default_def restrict_map_def)"], ["proof (state)\nthis:\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')) =\n  y(a' := b')\n\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "with f y"], ["proof (chain)\npicking this:\n  f = Abs_finfun y\n  y \\<in> finfun\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')) =\n  y(a' := b')", "have f_Abs: \"f(a' $:= b') = Abs_finfun (map_default b ?g')\""], ["proof (prove)\nusing this:\n  f = Abs_finfun y\n  y \\<in> finfun\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')) =\n  y(a' := b')\n\ngoal (1 subgoal):\n 1. f(a' $:= b') =\n    Abs_finfun\n     (map_default b\n       (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')))", "by(auto simp add: finfun_update_def)"], ["proof (state)\nthis:\n  f(a' $:= b') =\n  Abs_finfun\n   (map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')))\n\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have g': \"The (?the (f(a' $:= b'))) = ?g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE g.\n        f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n        finite (dom g) \\<and> b \\<notin> ran g) =\n    ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')", "proof (rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. f(a' $:= b') =\n    Abs_finfun\n     (map_default b\n       (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n        b'))) \\<and>\n    finite\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))) \\<and>\n    b \\<notin> ran (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \n                    \\<mapsto> b'))\n 2. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n       b')", "from fing' bnrang' f_Abs"], ["proof (chain)\npicking this:\n  finite\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n         b')))\n  b \\<notin> ran (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \n                  \\<mapsto> b'))\n  f(a' $:= b') =\n  Abs_finfun\n   (map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')))", "show \"?the (f(a' $:= b')) ?g'\""], ["proof (prove)\nusing this:\n  finite\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n         b')))\n  b \\<notin> ran (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \n                  \\<mapsto> b'))\n  f(a' $:= b') =\n  Abs_finfun\n   (map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')))\n\ngoal (1 subgoal):\n 1. f(a' $:= b') =\n    Abs_finfun\n     (map_default b\n       (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n        b'))) \\<and>\n    finite\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))) \\<and>\n    b \\<notin> ran (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \n                    \\<mapsto> b'))", "by(auto simp add: finfun_update_def restrict_map_def)"], ["proof (state)\nthis:\n  f(a' $:= b') =\n  Abs_finfun\n   (map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n      b'))) \\<and>\n  finite\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n         b'))) \\<and>\n  b \\<notin> ran (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \n                  \\<mapsto> b'))\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n       b')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n       b')", "fix g'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n       b')", "assume \"?the (f(a' $:= b')) g'\""], ["proof (state)\nthis:\n  f(a' $:= b') = Abs_finfun (map_default b g') \\<and>\n  finite (dom g') \\<and> b \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n       b')", "hence f': \"f(a' $:= b') = Abs_finfun (map_default b g')\"\n        and fin': \"finite (dom g')\" and brang': \"b \\<notin> ran g'\""], ["proof (prove)\nusing this:\n  f(a' $:= b') = Abs_finfun (map_default b g') \\<and>\n  finite (dom g') \\<and> b \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. f(a' $:= b') = Abs_finfun (map_default b g') &&&\n    finite (dom g') &&& b \\<notin> ran g'", "by auto"], ["proof (state)\nthis:\n  f(a' $:= b') = Abs_finfun (map_default b g')\n  finite (dom g')\n  b \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n       b')", "from fing' fin'"], ["proof (chain)\npicking this:\n  finite\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n         b')))\n  finite (dom g')", "have \"map_default b ?g' \\<in> finfun\" \"map_default b g' \\<in> finfun\""], ["proof (prove)\nusing this:\n  finite\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n         b')))\n  finite (dom g')\n\ngoal (1 subgoal):\n 1. map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))\n    \\<in> finfun &&&\n    map_default b g' \\<in> finfun", "by(auto intro: map_default_in_finfun)"], ["proof (state)\nthis:\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))\n  \\<in> finfun\n  map_default b g' \\<in> finfun\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n       b')", "with f' f_Abs"], ["proof (chain)\npicking this:\n  f(a' $:= b') = Abs_finfun (map_default b g')\n  f(a' $:= b') =\n  Abs_finfun\n   (map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')))\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))\n  \\<in> finfun\n  map_default b g' \\<in> finfun", "have \"map_default b g' = map_default b ?g'\""], ["proof (prove)\nusing this:\n  f(a' $:= b') = Abs_finfun (map_default b g')\n  f(a' $:= b') =\n  Abs_finfun\n   (map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')))\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))\n  \\<in> finfun\n  map_default b g' \\<in> finfun\n\ngoal (1 subgoal):\n 1. map_default b g' =\n    map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))", "by simp"], ["proof (state)\nthis:\n  map_default b g' =\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n       finite (dom g) \\<and> b \\<notin> ran g \\<Longrightarrow>\n       g = ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n       b')", "with fin' brang' fing' bnrang'"], ["proof (chain)\npicking this:\n  finite (dom g')\n  b \\<notin> ran g'\n  finite\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n         b')))\n  b \\<notin> ran (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \n                  \\<mapsto> b'))\n  map_default b g' =\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))", "show \"g' = ?g'\""], ["proof (prove)\nusing this:\n  finite (dom g')\n  b \\<notin> ran g'\n  finite\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n         b')))\n  b \\<notin> ran (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \n                  \\<mapsto> b'))\n  map_default b g' =\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))\n\ngoal (1 subgoal):\n 1. g' = ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')", "by(rule map_default_inject[OF disjI2[OF refl]])"], ["proof (state)\nthis:\n  g' = ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (THE g.\n      f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n      finite (dom g) \\<and> b \\<notin> ran g) =\n  ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')\n\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have dom: \"dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')) = insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n         b')) =\n    insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))", "by auto"], ["proof (state)\nthis:\n  dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')) =\n  insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. b' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "proof(cases \"y a' = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y a' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "case True"], ["proof (state)\nthis:\n  y a' = b\n\ngoal (2 subgoals):\n 1. y a' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "hence a'ndomg: \"a' \\<notin> dom ?g\""], ["proof (prove)\nusing this:\n  y a' = b\n\ngoal (1 subgoal):\n 1. a' \\<notin> dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})", "by auto"], ["proof (state)\nthis:\n  a' \\<notin> dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n\ngoal (2 subgoals):\n 1. y a' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "from f y b'b True"], ["proof (chain)\npicking this:\n  f = Abs_finfun y\n  y \\<in> finfun\n  b' \\<noteq> b\n  y a' = b", "have yff: \"y = map_default b (?g' |` dom ?g)\""], ["proof (prove)\nusing this:\n  f = Abs_finfun y\n  y \\<in> finfun\n  b' \\<noteq> b\n  y a' = b\n\ngoal (1 subgoal):\n 1. y =\n    map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b') |`\n      dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))", "by(auto simp add: restrict_map_def map_default_def intro!: ext)"], ["proof (state)\nthis:\n  y =\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b') |`\n    dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (2 subgoals):\n 1. y a' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "hence f': \"f = Abs_finfun (map_default b (?g' |` dom ?g))\""], ["proof (prove)\nusing this:\n  y =\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b') |`\n    dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. f =\n    Abs_finfun\n     (map_default b\n       (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n        b') |` dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "using f"], ["proof (prove)\nusing this:\n  y =\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b') |`\n    dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n  f = Abs_finfun y\n\ngoal (1 subgoal):\n 1. f =\n    Abs_finfun\n     (map_default b\n       (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n        b') |` dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "by simp"], ["proof (state)\nthis:\n  f =\n  Abs_finfun\n   (map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b') |`\n      dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n\ngoal (2 subgoals):\n 1. y a' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "interpret g'wf: comp_fun_commute \"\\<lambda>a. upd a (?b' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))", "by(rule upd_left_comm)"], ["proof (state)\ngoal (2 subgoals):\n 1. y a' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "from upd_left_comm upd_left_comm fing"], ["proof (chain)\npicking this:\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))", "have \"Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (dom ?g) = Finite_Set.fold (\\<lambda>a. upd a (?b' a)) (cnst b) (dom ?g)\""], ["proof (prove)\nusing this:\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  finite (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))", "by(rule finite_rec_cong1)(auto simp add: restrict_map_def b'b True map_default_def)"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (2 subgoals):\n 1. y a' = b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n 2. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "unfolding finfun_rec_def Let_def finfun_default_update_const b[symmetric]"], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (THE g.\n                f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n                finite (dom g) \\<and> b \\<notin> ran g)\n            a))\n     (cnst b)\n     (dom (THE g.\n              f(a' $:= b') = Abs_finfun (map_default b g) \\<and>\n              finite (dom g) \\<and> b \\<notin> ran g)) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b\n              (THE g.\n                  f = Abs_finfun (map_default b g) \\<and>\n                  finite (dom g) \\<and> b \\<notin> ran g)\n              a))\n       (cnst b)\n       (dom (THE g.\n                f = Abs_finfun (map_default b g) \\<and>\n                finite (dom g) \\<and> b \\<notin> ran g)))", "unfolding g' g[symmetric] gg g'wf.fold_insert[OF fing a'ndomg, of \"cnst b\", folded dom]"], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. upd a'\n     (map_default b\n       (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))\n       a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b\n              (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \n               \\<mapsto> b'))\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "by -(rule arg_cong2[where f=\"upd a'\"], simp_all add: map_default_def)"], ["proof (state)\nthis:\n  finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "case False"], ["proof (state)\nthis:\n  y a' \\<noteq> b\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "hence \"insert a' (dom ?g) = dom ?g\""], ["proof (prove)\nusing this:\n  y a' \\<noteq> b\n\ngoal (1 subgoal):\n 1. insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n    dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})", "by auto"], ["proof (state)\nthis:\n  insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "moreover"], ["proof (state)\nthis:\n  insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "{"], ["proof (state)\nthis:\n  insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "let ?g'' = \"?g(a' := None)\""], ["proof (state)\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "let ?b'' = \"map_default b ?g''\""], ["proof (state)\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "from False"], ["proof (chain)\npicking this:\n  y a' \\<noteq> b", "have domg: \"dom ?g = insert a' (dom ?g'')\""], ["proof (prove)\nusing this:\n  y a' \\<noteq> b\n\ngoal (1 subgoal):\n 1. dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) =\n    insert a'\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None)))", "by auto"], ["proof (state)\nthis:\n  dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) =\n  insert a'\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None)))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "from False"], ["proof (chain)\npicking this:\n  y a' \\<noteq> b", "have a'ndomg'': \"a' \\<notin> dom ?g''\""], ["proof (prove)\nusing this:\n  y a' \\<noteq> b\n\ngoal (1 subgoal):\n 1. a' \\<notin> dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n                     (a' := None))", "by auto"], ["proof (state)\nthis:\n  a' \\<notin> dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n                   (a' := None))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have fing'': \"finite (dom ?g'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None)))", "by(rule finite_subset[OF _ fing]) auto"], ["proof (state)\nthis:\n  finite\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None)))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have bnrang'': \"b \\<notin> ran ?g''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> ran (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n                    (a' := None))", "by(auto simp add: ran_def restrict_map_def)"], ["proof (state)\nthis:\n  b \\<notin> ran (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n                  (a' := None))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "interpret gwf: comp_fun_commute \"\\<lambda>a. upd a (?b a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))", "by(rule upd_left_comm)"], ["proof (state)\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "interpret g'wf: comp_fun_commute \"\\<lambda>a. upd a (?b' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))", "by(rule upd_left_comm)"], ["proof (state)\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have \"upd a' b' (Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (insert a' (dom ?g''))) =\n              upd a' b' (upd a' (?b a') (Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (dom ?g'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (insert a'\n         (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n               (a' := None))))) =\n    upd a' b'\n     (upd a'\n       (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n       (Finite_Set.fold\n         (\\<lambda>a.\n             upd a\n              (map_default b\n                ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n         (cnst b)\n         (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n               (a' := None)))))", "unfolding gwf.fold_insert[OF fing'' a'ndomg''] f"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd a' b'\n     (upd a'\n       (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n       (Finite_Set.fold\n         (\\<lambda>a.\n             upd a\n              (map_default b\n                ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n         (cnst b)\n         (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n               (a' := None))))) =\n    upd a' b'\n     (upd a'\n       (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n       (Finite_Set.fold\n         (\\<lambda>a.\n             upd a\n              (map_default b\n                ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n         (cnst b)\n         (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n               (a' := None)))))", ".."], ["proof (state)\nthis:\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None))))) =\n  upd a' b'\n   (upd a'\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None)))))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "also"], ["proof (state)\nthis:\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None))))) =\n  upd a' b'\n   (upd a'\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None)))))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have g''leg: \"?g |` dom ?g'' \\<subseteq>\\<^sub>m ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b} |`\n    dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n         (a' := None)) \\<subseteq>\\<^sub>m\n    (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}", "by(auto simp add: map_le_def)"], ["proof (state)\nthis:\n  (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b} |`\n  dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n       (a' := None)) \\<subseteq>\\<^sub>m\n  (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have \"dom (?g |` dom ?g'') = dom ?g''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b} |`\n         dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              (a' := None))) =\n    dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))", "by auto"], ["proof (state)\nthis:\n  dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b} |`\n       dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            (a' := None))) =\n  dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "note map_default_update_twice[where d=b and f = \"?g |` dom ?g''\" and a=a' and d'=\"?b a'\" and d''=b' and g=\"?g\",\n                                     unfolded this, OF fing'' a'ndomg'' g''leg]"], ["proof (state)\nthis:\n  upd a' b'\n   (upd a'\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None))))) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "also"], ["proof (state)\nthis:\n  upd a' b'\n   (upd a'\n     (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None))))) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "have b': \"b' = ?b' a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' =\n    map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')) a'", "by(auto simp add: map_default_def)"], ["proof (state)\nthis:\n  b' =\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')) a'\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "from upd_left_comm upd_left_comm fing''"], ["proof (chain)\npicking this:\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  finite\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None)))", "have \"Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (dom ?g'') =\n          Finite_Set.fold (\\<lambda>a. upd a (?b' a)) (cnst b) (dom ?g'')\""], ["proof (prove)\nusing this:\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  comp_fun_commute (\\<lambda>a. upd a (?f a))\n  finite\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None)))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))) =\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))\n     (cnst b)\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None)))", "by(rule finite_rec_cong1)(auto simp add: restrict_map_def b'b map_default_def)"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b)\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None)))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "with b'"], ["proof (chain)\npicking this:\n  b' =\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')) a'\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b)\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None)))", "have \"upd a' b' (Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (dom ?g'')) =\n                     upd a' (?b' a') (Finite_Set.fold (\\<lambda>a. upd a (?b' a)) (cnst b) (dom ?g''))\""], ["proof (prove)\nusing this:\n  b' =\n  map_default b\n   (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b')) a'\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}) a))\n   (cnst b)\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b)\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None)))\n\ngoal (1 subgoal):\n 1. upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None)))) =\n    upd a'\n     (map_default b\n       (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))\n       a')\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b\n              (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \n               \\<mapsto> b'))\n              a))\n       (cnst b)\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None))))", "by simp"], ["proof (state)\nthis:\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n           (a' := None)))) =\n  upd a'\n   (map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))\n     a')\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))\n     (cnst b)\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "also"], ["proof (state)\nthis:\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n           (a' := None)))) =\n  upd a'\n   (map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))\n     a')\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))\n     (cnst b)\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "note g'wf.fold_insert[OF fing'' a'ndomg'', symmetric]"], ["proof (state)\nthis:\n  upd a'\n   (map_default b\n     (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto> b'))\n     a')\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))\n     ?z (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              (a' := None)))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   ?z (insert a'\n        (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              (a' := None))))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "finally"], ["proof (chain)\npicking this:\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None))))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b)\n   (insert a'\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))))", "have \"upd a' b' (Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (dom ?g)) =\n                   Finite_Set.fold (\\<lambda>a. upd a (?b' a)) (cnst b) (dom ?g)\""], ["proof (prove)\nusing this:\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None))))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b)\n   (insert a'\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))))\n\ngoal (1 subgoal):\n 1. upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))) =\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))", "unfolding domg"], ["proof (prove)\nusing this:\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b)\n     (insert a'\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None))))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b)\n   (insert a'\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' := None))))\n\ngoal (1 subgoal):\n 1. upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b)\n       (insert a'\n         (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n               (a' := None))))) =\n    Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))\n     (cnst b)\n     (insert a'\n       (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n             (a' := None))))", "."], ["proof (state)\nthis:\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "}"], ["proof (state)\nthis:\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "ultimately"], ["proof (chain)\npicking this:\n  insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))", "have \"Finite_Set.fold (\\<lambda>a. upd a (?b' a)) (cnst b) (insert a' (dom ?g)) =\n                    upd a' b' (Finite_Set.fold (\\<lambda>a. upd a (?b a)) (cnst b) (dom ?g))\""], ["proof (prove)\nusing this:\n  insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})) =\n  dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))) =\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))\n     (cnst b)\n     (insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))) =\n    upd a' b'\n     (Finite_Set.fold\n       (\\<lambda>a.\n           upd a\n            (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n              a))\n       (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))", "by simp"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b)\n   (insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n\ngoal (1 subgoal):\n 1. y a' \\<noteq> b \\<Longrightarrow>\n    finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b)\n   (insert a' (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}))) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)", "unfolding finfun_rec_def Let_def finfun_default_update_const b[symmetric] g[symmetric] g' dom[symmetric]"], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b)\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n         b'))) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))\n     (cnst b)\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))) =\n    upd a' b'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default b g a)) (cnst b)\n       (dom g))", "using b'b gg"], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       upd a\n        (map_default b\n          (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))\n          a))\n   (cnst b)\n   (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n         b'))) =\n  upd a' b'\n   (Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})\n            a))\n     (cnst b) (dom ((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})))\n  b' \\<noteq> b\n  g = (\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         upd a\n          (map_default b\n            (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n             b'))\n            a))\n     (cnst b)\n     (dom (((\\<lambda>a. Some (y a)) |` {a. y a \\<noteq> b})(a' \\<mapsto>\n           b'))) =\n    upd a' b'\n     (Finite_Set.fold (\\<lambda>a. upd a (map_default b g a)) (cnst b)\n       (dom g))", "by(simp add: map_default_insert)"], ["proof (state)\nthis:\n  finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finfun_rec cnst upd f(a' $:= b') = upd a' b' (finfun_rec cnst upd f)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale finfun_rec_wf = finfun_rec_wf_aux + \n  assumes const_update_all:\n  \"finite (UNIV :: 'a set) \\<Longrightarrow> Finite_Set.fold (\\<lambda>a. upd a b') (cnst b) (UNIV :: 'a set) = cnst b'\"\nbegin"], ["", "lemma finfun_rec_const [simp]: \"finfun_rec cnst upd (K$ c) = cnst c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd (K$ c) = cnst c", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd (K$ c) = cnst c", "proof(cases \"finite (UNIV :: 'a set)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c\n 2. infinite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c", "case False"], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c\n 2. infinite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c", "hence \"finfun_default ((K$ c) :: 'a \\<Rightarrow>f 'b) = c\""], ["proof (prove)\nusing this:\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. finfun_default (K$ c) = c", "by(simp add: finfun_default_const)"], ["proof (state)\nthis:\n  finfun_default (K$ c) = c\n\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c\n 2. infinite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c", "moreover"], ["proof (state)\nthis:\n  finfun_default (K$ c) = c\n\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c\n 2. infinite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c", "have \"(THE g :: 'a \\<rightharpoonup> 'b. (K$ c) = Abs_finfun (map_default c g) \\<and> finite (dom g) \\<and> c \\<notin> ran g) = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE g.\n        (K$ c) = Abs_finfun (map_default c g) \\<and>\n        finite (dom g) \\<and> c \\<notin> ran g) =\n    Map.empty", "proof (rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. (K$ c) = Abs_finfun (map_default c Map.empty) \\<and>\n    finite (dom Map.empty) \\<and> c \\<notin> ran Map.empty\n 2. \\<And>g.\n       (K$ c) = Abs_finfun (map_default c g) \\<and>\n       finite (dom g) \\<and> c \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "show \"(K$ c) = Abs_finfun (map_default c Map.empty) \\<and> finite (dom Map.empty) \\<and> c \\<notin> ran Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (K$ c) = Abs_finfun (map_default c Map.empty) \\<and>\n    finite (dom Map.empty) \\<and> c \\<notin> ran Map.empty", "by(auto simp add: finfun_const_def)"], ["proof (state)\nthis:\n  (K$ c) = Abs_finfun (map_default c Map.empty) \\<and>\n  finite (dom Map.empty) \\<and> c \\<notin> ran Map.empty\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default c g) \\<and>\n       finite (dom g) \\<and> c \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default c g) \\<and>\n       finite (dom g) \\<and> c \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "fix g :: \"'a \\<rightharpoonup> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default c g) \\<and>\n       finite (dom g) \\<and> c \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "assume \"(K$ c) = Abs_finfun (map_default c g) \\<and> finite (dom g) \\<and> c \\<notin> ran g\""], ["proof (state)\nthis:\n  (K$ c) = Abs_finfun (map_default c g) \\<and>\n  finite (dom g) \\<and> c \\<notin> ran g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default c g) \\<and>\n       finite (dom g) \\<and> c \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "hence g: \"(K$ c) = Abs_finfun (map_default c g)\" and fin: \"finite (dom g)\" and ran: \"c \\<notin> ran g\""], ["proof (prove)\nusing this:\n  (K$ c) = Abs_finfun (map_default c g) \\<and>\n  finite (dom g) \\<and> c \\<notin> ran g\n\ngoal (1 subgoal):\n 1. (K$ c) = Abs_finfun (map_default c g) &&&\n    finite (dom g) &&& c \\<notin> ran g", "by blast+"], ["proof (state)\nthis:\n  (K$ c) = Abs_finfun (map_default c g)\n  finite (dom g)\n  c \\<notin> ran g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default c g) \\<and>\n       finite (dom g) \\<and> c \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "from g map_default_in_finfun[OF fin, of c]"], ["proof (chain)\npicking this:\n  (K$ c) = Abs_finfun (map_default c g)\n  map_default c g \\<in> finfun", "have \"map_default c g = (\\<lambda>a. c)\""], ["proof (prove)\nusing this:\n  (K$ c) = Abs_finfun (map_default c g)\n  map_default c g \\<in> finfun\n\ngoal (1 subgoal):\n 1. map_default c g = (\\<lambda>a. c)", "by(simp add: finfun_const_def)"], ["proof (state)\nthis:\n  map_default c g = (\\<lambda>a. c)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default c g) \\<and>\n       finite (dom g) \\<and> c \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "moreover"], ["proof (state)\nthis:\n  map_default c g = (\\<lambda>a. c)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default c g) \\<and>\n       finite (dom g) \\<and> c \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "have \"map_default c Map.empty = (\\<lambda>a. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_default c Map.empty = (\\<lambda>a. c)", "by simp"], ["proof (state)\nthis:\n  map_default c Map.empty = (\\<lambda>a. c)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default c g) \\<and>\n       finite (dom g) \\<and> c \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "ultimately"], ["proof (chain)\npicking this:\n  map_default c g = (\\<lambda>a. c)\n  map_default c Map.empty = (\\<lambda>a. c)", "show \"g = Map.empty\""], ["proof (prove)\nusing this:\n  map_default c g = (\\<lambda>a. c)\n  map_default c Map.empty = (\\<lambda>a. c)\n\ngoal (1 subgoal):\n 1. g = Map.empty", "by-(rule map_default_inject[OF disjI2[OF refl] fin ran], auto)"], ["proof (state)\nthis:\n  g = Map.empty\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (THE g.\n      (K$ c) = Abs_finfun (map_default c g) \\<and>\n      finite (dom g) \\<and> c \\<notin> ran g) =\n  Map.empty\n\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c\n 2. infinite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c", "ultimately"], ["proof (chain)\npicking this:\n  finfun_default (K$ c) = c\n  (THE g.\n      (K$ c) = Abs_finfun (map_default c g) \\<and>\n      finite (dom g) \\<and> c \\<notin> ran g) =\n  Map.empty", "show ?thesis"], ["proof (prove)\nusing this:\n  finfun_default (K$ c) = c\n  (THE g.\n      (K$ c) = Abs_finfun (map_default c g) \\<and>\n      finite (dom g) \\<and> c \\<notin> ran g) =\n  Map.empty\n\ngoal (1 subgoal):\n 1. finfun_rec cnst upd (K$ c) = cnst c", "by(simp add: finfun_rec_def)"], ["proof (state)\nthis:\n  finfun_rec cnst upd (K$ c) = cnst c\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c", "case True"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c", "hence default: \"finfun_default ((K$ c) :: 'a \\<Rightarrow>f 'b) = undefined\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finfun_default (K$ c) = undefined", "by(simp add: finfun_default_const)"], ["proof (state)\nthis:\n  finfun_default (K$ c) = undefined\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c", "let ?the = \"\\<lambda>g :: 'a \\<rightharpoonup> 'b. (K$ c) = Abs_finfun (map_default undefined g) \\<and> finite (dom g) \\<and> undefined \\<notin> ran g\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd (K$ c) = cnst c", "proof(cases \"c = undefined\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = undefined \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c\n 2. c \\<noteq> undefined \\<Longrightarrow>\n    finfun_rec cnst upd (K$ c) = cnst c", "case True"], ["proof (state)\nthis:\n  c = undefined\n\ngoal (2 subgoals):\n 1. c = undefined \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c\n 2. c \\<noteq> undefined \\<Longrightarrow>\n    finfun_rec cnst upd (K$ c) = cnst c", "have the: \"The ?the = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE g.\n        (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n        finite (dom g) \\<and> undefined \\<notin> ran g) =\n    Map.empty", "proof (rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. (K$ c) = Abs_finfun (map_default undefined Map.empty) \\<and>\n    finite (dom Map.empty) \\<and> undefined \\<notin> ran Map.empty\n 2. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "from True"], ["proof (chain)\npicking this:\n  c = undefined", "show \"?the Map.empty\""], ["proof (prove)\nusing this:\n  c = undefined\n\ngoal (1 subgoal):\n 1. (K$ c) = Abs_finfun (map_default undefined Map.empty) \\<and>\n    finite (dom Map.empty) \\<and> undefined \\<notin> ran Map.empty", "by(auto simp add: finfun_const_def)"], ["proof (state)\nthis:\n  (K$ c) = Abs_finfun (map_default undefined Map.empty) \\<and>\n  finite (dom Map.empty) \\<and> undefined \\<notin> ran Map.empty\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "fix g'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "assume \"?the g'\""], ["proof (state)\nthis:\n  (K$ c) = Abs_finfun (map_default undefined g') \\<and>\n  finite (dom g') \\<and> undefined \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "hence fg: \"(K$ c) = Abs_finfun (map_default undefined g')\"\n        and fin: \"finite (dom g')\" and g: \"undefined \\<notin> ran g'\""], ["proof (prove)\nusing this:\n  (K$ c) = Abs_finfun (map_default undefined g') \\<and>\n  finite (dom g') \\<and> undefined \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. (K$ c) = Abs_finfun (map_default undefined g') &&&\n    finite (dom g') &&& undefined \\<notin> ran g'", "by simp_all"], ["proof (state)\nthis:\n  (K$ c) = Abs_finfun (map_default undefined g')\n  finite (dom g')\n  undefined \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "from fin"], ["proof (chain)\npicking this:\n  finite (dom g')", "have \"map_default undefined g' \\<in> finfun\""], ["proof (prove)\nusing this:\n  finite (dom g')\n\ngoal (1 subgoal):\n 1. map_default undefined g' \\<in> finfun", "by(rule map_default_in_finfun)"], ["proof (state)\nthis:\n  map_default undefined g' \\<in> finfun\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "with fg"], ["proof (chain)\npicking this:\n  (K$ c) = Abs_finfun (map_default undefined g')\n  map_default undefined g' \\<in> finfun", "have \"map_default undefined g' = (\\<lambda>a. c)\""], ["proof (prove)\nusing this:\n  (K$ c) = Abs_finfun (map_default undefined g')\n  map_default undefined g' \\<in> finfun\n\ngoal (1 subgoal):\n 1. map_default undefined g' = (\\<lambda>a. c)", "by(auto simp add: finfun_const_def intro: Abs_finfun_inject[THEN iffD1, symmetric])"], ["proof (state)\nthis:\n  map_default undefined g' = (\\<lambda>a. c)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = Map.empty", "with True"], ["proof (chain)\npicking this:\n  c = undefined\n  map_default undefined g' = (\\<lambda>a. c)", "show \"g' = Map.empty\""], ["proof (prove)\nusing this:\n  c = undefined\n  map_default undefined g' = (\\<lambda>a. c)\n\ngoal (1 subgoal):\n 1. g' = Map.empty", "by -(rule map_default_inject(2)[OF _ fin g], auto)"], ["proof (state)\nthis:\n  g' = Map.empty\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (THE g.\n      (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n      finite (dom g) \\<and> undefined \\<notin> ran g) =\n  Map.empty\n\ngoal (2 subgoals):\n 1. c = undefined \\<Longrightarrow> finfun_rec cnst upd (K$ c) = cnst c\n 2. c \\<noteq> undefined \\<Longrightarrow>\n    finfun_rec cnst upd (K$ c) = cnst c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd (K$ c) = cnst c", "unfolding finfun_rec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let b = finfun_default (K$ c);\n         g = THE g.\n                (K$ c) = Abs_finfun (map_default b g) \\<and>\n                finite (dom g) \\<and> b \\<notin> ran g\n     in Finite_Set.fold (\\<lambda>a. upd a (map_default b g a)) (cnst b)\n         (dom g)) =\n    cnst c", "using \\<open>finite UNIV\\<close> True"], ["proof (prove)\nusing this:\n  finite UNIV\n  c = undefined\n\ngoal (1 subgoal):\n 1. (let b = finfun_default (K$ c);\n         g = THE g.\n                (K$ c) = Abs_finfun (map_default b g) \\<and>\n                finite (dom g) \\<and> b \\<notin> ran g\n     in Finite_Set.fold (\\<lambda>a. upd a (map_default b g a)) (cnst b)\n         (dom g)) =\n    cnst c", "unfolding Let_def the default"], ["proof (prove)\nusing this:\n  finite UNIV\n  c = undefined\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a. upd a (map_default undefined Map.empty a))\n     (cnst undefined) (dom Map.empty) =\n    cnst c", "by(simp)"], ["proof (state)\nthis:\n  finfun_rec cnst upd (K$ c) = cnst c\n\ngoal (1 subgoal):\n 1. c \\<noteq> undefined \\<Longrightarrow>\n    finfun_rec cnst upd (K$ c) = cnst c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> undefined \\<Longrightarrow>\n    finfun_rec cnst upd (K$ c) = cnst c", "case False"], ["proof (state)\nthis:\n  c \\<noteq> undefined\n\ngoal (1 subgoal):\n 1. c \\<noteq> undefined \\<Longrightarrow>\n    finfun_rec cnst upd (K$ c) = cnst c", "have the: \"The ?the = (\\<lambda>a :: 'a. Some c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE g.\n        (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n        finite (dom g) \\<and> undefined \\<notin> ran g) =\n    (\\<lambda>a. Some c)", "proof (rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. (K$ c) = Abs_finfun (map_default undefined (\\<lambda>a. Some c)) \\<and>\n    finite (dom (\\<lambda>a. Some c)) \\<and>\n    undefined \\<notin> ran (\\<lambda>a. Some c)\n 2. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some c)", "from False True"], ["proof (chain)\npicking this:\n  c \\<noteq> undefined\n  finite UNIV", "show \"?the (\\<lambda>a :: 'a. Some c)\""], ["proof (prove)\nusing this:\n  c \\<noteq> undefined\n  finite UNIV\n\ngoal (1 subgoal):\n 1. (K$ c) = Abs_finfun (map_default undefined (\\<lambda>a. Some c)) \\<and>\n    finite (dom (\\<lambda>a. Some c)) \\<and>\n    undefined \\<notin> ran (\\<lambda>a. Some c)", "by(auto simp add: map_default_def [abs_def] finfun_const_def dom_def ran_def)"], ["proof (state)\nthis:\n  (K$ c) = Abs_finfun (map_default undefined (\\<lambda>a. Some c)) \\<and>\n  finite (dom (\\<lambda>a. Some c)) \\<and>\n  undefined \\<notin> ran (\\<lambda>a. Some c)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some c)", "fix g' :: \"'a \\<rightharpoonup> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some c)", "assume \"?the g'\""], ["proof (state)\nthis:\n  (K$ c) = Abs_finfun (map_default undefined g') \\<and>\n  finite (dom g') \\<and> undefined \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some c)", "hence fg: \"(K$ c) = Abs_finfun (map_default undefined g')\"\n        and fin: \"finite (dom g')\" and g: \"undefined \\<notin> ran g'\""], ["proof (prove)\nusing this:\n  (K$ c) = Abs_finfun (map_default undefined g') \\<and>\n  finite (dom g') \\<and> undefined \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. (K$ c) = Abs_finfun (map_default undefined g') &&&\n    finite (dom g') &&& undefined \\<notin> ran g'", "by simp_all"], ["proof (state)\nthis:\n  (K$ c) = Abs_finfun (map_default undefined g')\n  finite (dom g')\n  undefined \\<notin> ran g'\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some c)", "from fin"], ["proof (chain)\npicking this:\n  finite (dom g')", "have \"map_default undefined g' \\<in> finfun\""], ["proof (prove)\nusing this:\n  finite (dom g')\n\ngoal (1 subgoal):\n 1. map_default undefined g' \\<in> finfun", "by(rule map_default_in_finfun)"], ["proof (state)\nthis:\n  map_default undefined g' \\<in> finfun\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some c)", "with fg"], ["proof (chain)\npicking this:\n  (K$ c) = Abs_finfun (map_default undefined g')\n  map_default undefined g' \\<in> finfun", "have \"map_default undefined g' = (\\<lambda>a. c)\""], ["proof (prove)\nusing this:\n  (K$ c) = Abs_finfun (map_default undefined g')\n  map_default undefined g' \\<in> finfun\n\ngoal (1 subgoal):\n 1. map_default undefined g' = (\\<lambda>a. c)", "by(auto simp add: finfun_const_def intro: Abs_finfun_inject[THEN iffD1])"], ["proof (state)\nthis:\n  map_default undefined g' = (\\<lambda>a. c)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n       finite (dom g) \\<and> undefined \\<notin> ran g \\<Longrightarrow>\n       g = (\\<lambda>a. Some c)", "with True False"], ["proof (chain)\npicking this:\n  finite UNIV\n  c \\<noteq> undefined\n  map_default undefined g' = (\\<lambda>a. c)", "show \"g' = (\\<lambda>a::'a. Some c)\""], ["proof (prove)\nusing this:\n  finite UNIV\n  c \\<noteq> undefined\n  map_default undefined g' = (\\<lambda>a. c)\n\ngoal (1 subgoal):\n 1. g' = (\\<lambda>a. Some c)", "by - (rule map_default_inject(2)[OF _ fin g],\n          auto simp add: dom_def ran_def map_default_def [abs_def])"], ["proof (state)\nthis:\n  g' = (\\<lambda>a. Some c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (THE g.\n      (K$ c) = Abs_finfun (map_default undefined g) \\<and>\n      finite (dom g) \\<and> undefined \\<notin> ran g) =\n  (\\<lambda>a. Some c)\n\ngoal (1 subgoal):\n 1. c \\<noteq> undefined \\<Longrightarrow>\n    finfun_rec cnst upd (K$ c) = cnst c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec cnst upd (K$ c) = cnst c", "unfolding finfun_rec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let b = finfun_default (K$ c);\n         g = THE g.\n                (K$ c) = Abs_finfun (map_default b g) \\<and>\n                finite (dom g) \\<and> b \\<notin> ran g\n     in Finite_Set.fold (\\<lambda>a. upd a (map_default b g a)) (cnst b)\n         (dom g)) =\n    cnst c", "using True False"], ["proof (prove)\nusing this:\n  finite UNIV\n  c \\<noteq> undefined\n\ngoal (1 subgoal):\n 1. (let b = finfun_default (K$ c);\n         g = THE g.\n                (K$ c) = Abs_finfun (map_default b g) \\<and>\n                finite (dom g) \\<and> b \\<notin> ran g\n     in Finite_Set.fold (\\<lambda>a. upd a (map_default b g a)) (cnst b)\n         (dom g)) =\n    cnst c", "unfolding Let_def the default"], ["proof (prove)\nusing this:\n  finite UNIV\n  c \\<noteq> undefined\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a. upd a (map_default undefined (\\<lambda>a. Some c) a))\n     (cnst undefined) (dom (\\<lambda>a. Some c)) =\n    cnst c", "by(simp add: dom_def map_default_def const_update_all)"], ["proof (state)\nthis:\n  finfun_rec cnst upd (K$ c) = cnst c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finfun_rec cnst upd (K$ c) = cnst c\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Weak induction rule and case analysis for FinFuns\\<close>"], ["", "lemma finfun_weak_induct [consumes 0, case_names const update]:\n  assumes const: \"\\<And>b. P (K$ b)\"\n  and update: \"\\<And>f a b. P f \\<Longrightarrow> P (f(a $:= b))\"\n  shows \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "proof(induct x rule: Abs_finfun_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> finfun \\<Longrightarrow> P (Abs_finfun y)", "case (Abs_finfun y)"], ["proof (state)\nthis:\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> finfun \\<Longrightarrow> P (Abs_finfun y)", "then"], ["proof (chain)\npicking this:\n  y \\<in> finfun", "obtain b where \"finite {a. y a \\<noteq> b}\""], ["proof (prove)\nusing this:\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        finite {a. y a \\<noteq> b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  y \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        finite {a. y a \\<noteq> b} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> finfun \\<Longrightarrow> P (Abs_finfun y)", "thus ?case"], ["proof (prove)\nusing this:\n  finite {a. y a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. P (Abs_finfun y)", "using \\<open>y \\<in> finfun\\<close>"], ["proof (prove)\nusing this:\n  finite {a. y a \\<noteq> b}\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. P (Abs_finfun y)", "proof(induct \"{a. y a \\<noteq> b}\" arbitrary: y rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>{} = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)\n 2. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "case empty"], ["proof (state)\nthis:\n  {} = {a. y a \\<noteq> b}\n  y \\<in> finfun\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>{} = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)\n 2. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "hence \"\\<And>a. y a = b\""], ["proof (prove)\nusing this:\n  {} = {a. y a \\<noteq> b}\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. \\<And>a. y a = b", "by blast"], ["proof (state)\nthis:\n  y ?a = b\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>{} = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)\n 2. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "hence \"y = (\\<lambda>a. b)\""], ["proof (prove)\nusing this:\n  y ?a = b\n\ngoal (1 subgoal):\n 1. y = (\\<lambda>a. b)", "by(auto)"], ["proof (state)\nthis:\n  y = (\\<lambda>a. b)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>{} = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)\n 2. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "hence \"Abs_finfun y = finfun_const b\""], ["proof (prove)\nusing this:\n  y = (\\<lambda>a. b)\n\ngoal (1 subgoal):\n 1. Abs_finfun y = (K$ b)", "unfolding finfun_const_def"], ["proof (prove)\nusing this:\n  y = (\\<lambda>a. b)\n\ngoal (1 subgoal):\n 1. Abs_finfun y = map_fun id Abs_finfun (\\<lambda>b x. b) b", "by simp"], ["proof (state)\nthis:\n  Abs_finfun y = (K$ b)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>{} = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)\n 2. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "thus ?case"], ["proof (prove)\nusing this:\n  Abs_finfun y = (K$ b)\n\ngoal (1 subgoal):\n 1. P (Abs_finfun y)", "by(simp add: const)"], ["proof (state)\nthis:\n  P (Abs_finfun y)\n\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  \\<lbrakk>A = {a. ?y a \\<noteq> b}; ?y \\<in> finfun\\<rbrakk>\n  \\<Longrightarrow> P (Abs_finfun ?y)\n  insert a A = {a. y a \\<noteq> b}\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "note IH = \\<open>\\<And>y. \\<lbrakk> A = {a. y a \\<noteq> b}; y \\<in> finfun  \\<rbrakk> \\<Longrightarrow> P (Abs_finfun y)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>A = {a. ?y a \\<noteq> b}; ?y \\<in> finfun\\<rbrakk>\n  \\<Longrightarrow> P (Abs_finfun ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "note y = \\<open>y \\<in> finfun\\<close>"], ["proof (state)\nthis:\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "with \\<open>insert a A = {a. y a \\<noteq> b}\\<close> \\<open>a \\<notin> A\\<close>"], ["proof (chain)\npicking this:\n  insert a A = {a. y a \\<noteq> b}\n  a \\<notin> A\n  y \\<in> finfun", "have \"A = {a'. (y(a := b)) a' \\<noteq> b}\" \"y(a := b) \\<in> finfun\""], ["proof (prove)\nusing this:\n  insert a A = {a. y a \\<noteq> b}\n  a \\<notin> A\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. A = {a'. (y(a := b)) a' \\<noteq> b} &&& y(a := b) \\<in> finfun", "by auto"], ["proof (state)\nthis:\n  A = {a'. (y(a := b)) a' \\<noteq> b}\n  y(a := b) \\<in> finfun\n\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "from IH[OF this]"], ["proof (chain)\npicking this:\n  P (Abs_finfun (y(a := b)))", "have \"P (finfun_update (Abs_finfun (y(a := b))) a (y a))\""], ["proof (prove)\nusing this:\n  P (Abs_finfun (y(a := b)))\n\ngoal (1 subgoal):\n 1. P (Abs_finfun (y(a := b)))(a $:= y a)", "by(rule update)"], ["proof (state)\nthis:\n  P (Abs_finfun (y(a := b)))(a $:= y a)\n\ngoal (1 subgoal):\n 1. \\<And>x F y.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>y.\n           \\<lbrakk>F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n           \\<Longrightarrow> P (Abs_finfun y);\n        insert x F = {a. y a \\<noteq> b}; y \\<in> finfun\\<rbrakk>\n       \\<Longrightarrow> P (Abs_finfun y)", "thus ?case"], ["proof (prove)\nusing this:\n  P (Abs_finfun (y(a := b)))(a $:= y a)\n\ngoal (1 subgoal):\n 1. P (Abs_finfun y)", "using y"], ["proof (prove)\nusing this:\n  P (Abs_finfun (y(a := b)))(a $:= y a)\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. P (Abs_finfun y)", "unfolding finfun_update_def"], ["proof (prove)\nusing this:\n  P (map_fun finfun_apply (map_fun id (map_fun id Abs_finfun)) fun_upd\n      (Abs_finfun (y(a := b))) a (y a))\n  y \\<in> finfun\n\ngoal (1 subgoal):\n 1. P (Abs_finfun y)", "by simp"], ["proof (state)\nthis:\n  P (Abs_finfun y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (Abs_finfun y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_exhaust_disj: \"(\\<exists>b. x = finfun_const b) \\<or> (\\<exists>f a b. x = finfun_update f a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>b. x = (K$ b)) \\<or> (\\<exists>f a b. x = f(a $:= b))", "by(induct x rule: finfun_weak_induct) blast+"], ["", "lemma finfun_exhaust:\n  obtains b where \"x = (K$ b)\"\n        | f a b where \"x = f(a $:= b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>b. x = (K$ b) \\<Longrightarrow> thesis;\n     \\<And>f a b. x = f(a $:= b) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(atomize_elim)(rule finfun_exhaust_disj)"], ["", "lemma finfun_rec_unique:\n  fixes f :: \"'a \\<Rightarrow>f 'b \\<Rightarrow> 'c\"\n  assumes c: \"\\<And>c. f (K$ c) = cnst c\"\n  and u: \"\\<And>g a b. f (g(a $:= b)) = upd g a b (f g)\"\n  and c': \"\\<And>c. f' (K$ c) = cnst c\"\n  and u': \"\\<And>g a b. f' (g(a $:= b)) = upd g a b (f' g)\"\n  shows \"f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = f' x", "fix g :: \"'a \\<Rightarrow>f 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = f' x", "show \"f g = f' g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f g = f' g", "by(induct g rule: finfun_weak_induct)(auto simp add: c u c' u')"], ["proof (state)\nthis:\n  f g = f' g\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Function application\\<close>"], ["", "notation finfun_apply (infixl \"$\" 999)"], ["", "interpretation finfun_apply_aux: finfun_rec_wf_aux \"\\<lambda>b. b\" \"\\<lambda>a' b c. if (a = a') then b else c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec_wf_aux (\\<lambda>b. b) (\\<lambda>a'. If (a = a'))", "by(unfold_locales) auto"], ["", "interpretation finfun_apply: finfun_rec_wf \"\\<lambda>b. b\" \"\\<lambda>a' b c. if (a = a') then b else c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec_wf (\\<lambda>b. b) (\\<lambda>a'. If (a = a'))", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>aa. If (a = aa) b') b UNIV = b'", "fix b' b :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>aa. If (a = aa) b') b UNIV = b'", "assume fin: \"finite (UNIV :: 'b set)\""], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>aa. If (a = aa) b') b UNIV = b'", "{"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>aa. If (a = aa) b') b UNIV = b'", "fix A :: \"'b set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>aa. If (a = aa) b') b UNIV = b'", "interpret comp_fun_commute \"\\<lambda>a'. If (a = a') b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute (\\<lambda>a'. If (a = a') b')", "by(rule finfun_apply_aux.upd_left_comm)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>aa. If (a = aa) b') b UNIV = b'", "from fin"], ["proof (chain)\npicking this:\n  finite UNIV", "have \"finite A\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite A", "by(auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>aa. If (a = aa) b') b UNIV = b'", "hence \"Finite_Set.fold (\\<lambda>a'. If (a = a') b') b A = (if a \\<in> A then b' else b)\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a'. If (a = a') b') b A =\n    (if a \\<in> A then b' else b)", "by induct auto"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a'. If (a = a') b') b A =\n  (if a \\<in> A then b' else b)\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>aa. If (a = aa) b') b UNIV = b'", "}"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a'. If (a = a') b') b ?A2 =\n  (if a \\<in> ?A2 then b' else b)\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>aa. If (a = aa) b') b UNIV = b'", "from this[of UNIV]"], ["proof (chain)\npicking this:\n  Finite_Set.fold (\\<lambda>a'. If (a = a') b') b UNIV =\n  (if a \\<in> UNIV then b' else b)", "show \"Finite_Set.fold (\\<lambda>a'. If (a = a') b') b UNIV = b'\""], ["proof (prove)\nusing this:\n  Finite_Set.fold (\\<lambda>a'. If (a = a') b') b UNIV =\n  (if a \\<in> UNIV then b' else b)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a'. If (a = a') b') b UNIV = b'", "by simp"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a'. If (a = a') b') b UNIV = b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_apply_def: \"($) = (\\<lambda>f a. finfun_rec (\\<lambda>b. b) (\\<lambda>a' b c. if (a = a') then b else c) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) =\n    (\\<lambda>f a. finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) f)", "proof(rule finfun_rec_unique)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c. ($) (K$ c) = ?cnst c\n 2. \\<And>g a b. ($) g(a $:= b) = ?upd g a b (($) g)\n 3. \\<And>c.\n       (\\<lambda>a.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) (K$ c)) =\n       ?cnst c\n 4. \\<And>g a b.\n       (\\<lambda>aa.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (aa = a'))\n            g(a $:= b)) =\n       ?upd g a b\n        (\\<lambda>a.\n            finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) g)", "fix c"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c. ($) (K$ c) = ?cnst c\n 2. \\<And>g a b. ($) g(a $:= b) = ?upd g a b (($) g)\n 3. \\<And>c.\n       (\\<lambda>a.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) (K$ c)) =\n       ?cnst c\n 4. \\<And>g a b.\n       (\\<lambda>aa.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (aa = a'))\n            g(a $:= b)) =\n       ?upd g a b\n        (\\<lambda>a.\n            finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) g)", "show \"($) (K$ c) = (\\<lambda>a. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (K$ c) = (\\<lambda>a. c)", "by(simp add: finfun_const.rep_eq)"], ["proof (state)\nthis:\n  ($) (K$ c) = (\\<lambda>a. c)\n\ngoal (3 subgoals):\n 1. \\<And>g a b. ($) g(a $:= b) = ?upd g a b (($) g)\n 2. \\<And>c.\n       (\\<lambda>a.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) (K$ c)) =\n       (\\<lambda>a. c)\n 3. \\<And>g a b.\n       (\\<lambda>aa.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (aa = a'))\n            g(a $:= b)) =\n       ?upd g a b\n        (\\<lambda>a.\n            finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) g)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g a b. ($) g(a $:= b) = ?upd g a b (($) g)\n 2. \\<And>c.\n       (\\<lambda>a.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) (K$ c)) =\n       (\\<lambda>a. c)\n 3. \\<And>g a b.\n       (\\<lambda>aa.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (aa = a'))\n            g(a $:= b)) =\n       ?upd g a b\n        (\\<lambda>a.\n            finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) g)", "fix g a b"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g a b. ($) g(a $:= b) = ?upd g a b (($) g)\n 2. \\<And>c.\n       (\\<lambda>a.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) (K$ c)) =\n       (\\<lambda>a. c)\n 3. \\<And>g a b.\n       (\\<lambda>aa.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (aa = a'))\n            g(a $:= b)) =\n       ?upd g a b\n        (\\<lambda>a.\n            finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) g)", "show \"($) g(a $:= b) = (\\<lambda>c. if c = a then b else g $ c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) g(a $:= b) = (\\<lambda>c. if c = a then b else g $ c)", "by(auto simp add: finfun_update_def fun_upd_finfun Abs_finfun_inverse finfun_apply)"], ["proof (state)\nthis:\n  ($) g(a $:= b) = (\\<lambda>c. if c = a then b else g $ c)\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       (\\<lambda>a.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (a = a')) (K$ c)) =\n       (\\<lambda>a. c)\n 2. \\<And>g a b.\n       (\\<lambda>aa.\n           finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (aa = a'))\n            g(a $:= b)) =\n       (\\<lambda>c.\n           if c = a then b\n           else finfun_rec (\\<lambda>b. b) (\\<lambda>a'. If (c = a')) g)", "qed auto"], ["", "lemma finfun_upd_apply: \"f(a $:= b) $ a' = (if a = a' then b else f $ a')\"\n  and finfun_upd_apply_code [code]: \"(finfun_update_code f a b) $ a' = (if a = a' then b else f $ a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f(a $:= b) $ a' = (if a = a' then b else f $ a') &&&\n    finfun_update_code f a b $ a' = (if a = a' then b else f $ a')", "by(simp_all add: finfun_apply_def)"], ["", "lemma finfun_const_apply [simp, code]: \"(K$ b) $ a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (K$ b) $ a = b", "by(simp add: finfun_apply_def)"], ["", "lemma finfun_upd_apply_same [simp]:\n  \"f(a $:= b) $ a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f(a $:= b) $ a = b", "by(simp add: finfun_upd_apply)"], ["", "lemma finfun_upd_apply_other [simp]:\n  \"a \\<noteq> a' \\<Longrightarrow> f(a $:= b) $ a' = f $ a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> a' \\<Longrightarrow> f(a $:= b) $ a' = f $ a'", "by(simp add: finfun_upd_apply)"], ["", "lemma finfun_ext: \"(\\<And>a. f $ a = g $ a) \\<Longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. f $ a = g $ a) \\<Longrightarrow> f = g", "by(auto simp add: finfun_apply_inject[symmetric])"], ["", "lemma expand_finfun_eq: \"(f = g) = (($) f = ($) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = g) = (($) f = ($) g)", "by(auto intro: finfun_ext)"], ["", "lemma finfun_upd_triv [simp]: \"f(x $:= f $ x) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f(x $:= f $ x) = f", "by(simp add: expand_finfun_eq fun_eq_iff finfun_upd_apply)"], ["", "lemma finfun_const_inject [simp]: \"(K$ b) = (K$ b') \\<equiv> b = b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (K$ b) = (K$ b') \\<equiv> b = b'", "by(simp add: expand_finfun_eq fun_eq_iff)"], ["", "lemma finfun_const_eq_update:\n  \"((K$ b) = f(a $:= b')) = (b = b' \\<and> (\\<forall>a'. a \\<noteq> a' \\<longrightarrow> f $ a' = b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((K$ b) = f(a $:= b')) =\n    (b = b' \\<and>\n     (\\<forall>a'. a \\<noteq> a' \\<longrightarrow> f $ a' = b))", "by(auto simp add: expand_finfun_eq fun_eq_iff finfun_upd_apply)"], ["", "subsection \\<open>Function composition\\<close>"], ["", "definition finfun_comp :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'c \\<Rightarrow>f 'a \\<Rightarrow> 'c \\<Rightarrow>f 'b\"  (infixr \"\\<circ>$\" 55)\nwhere [code del]: \"g \\<circ>$ f  = finfun_rec (\\<lambda>b. (K$ g b)) (\\<lambda>a b c. c(a $:= g b)) f\""], ["", "notation (ASCII)\n  finfun_comp (infixr \"o$\" 55)"], ["", "interpretation finfun_comp_aux: finfun_rec_wf_aux \"(\\<lambda>b. (K$ g b))\" \"(\\<lambda>a b c. c(a $:= g b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec_wf_aux (\\<lambda>b. (K$ g b)) (\\<lambda>a b c. c(a $:= g b))", "by(unfold_locales)(auto simp add: finfun_upd_apply intro: finfun_ext)"], ["", "interpretation finfun_comp: finfun_rec_wf \"(\\<lambda>b. (K$ g b))\" \"(\\<lambda>a b c. c(a $:= g b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec_wf (\\<lambda>b. (K$ g b)) (\\<lambda>a b c. c(a $:= g b))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV =\n       (K$ g b')", "fix b' b :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV =\n       (K$ g b')", "assume fin: \"finite (UNIV :: 'c set)\""], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV =\n       (K$ g b')", "{"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV =\n       (K$ g b')", "fix A :: \"'c set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV =\n       (K$ g b')", "from fin"], ["proof (chain)\npicking this:\n  finite UNIV", "have \"finite A\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite A", "by(auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV =\n       (K$ g b')", "hence \"Finite_Set.fold (\\<lambda>(a :: 'c) c. c(a $:= g b')) (K$ g b) A =\n      Abs_finfun (\\<lambda>a. if a \\<in> A then g b' else g b)\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) A =\n    Abs_finfun (\\<lambda>a. if a \\<in> A then g b' else g b)", "by induct (simp_all add: finfun_const_def, auto simp add: finfun_update_def Abs_finfun_inverse_finite fun_upd_def Abs_finfun_inject_finite fun_eq_iff fin)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) A =\n  Abs_finfun (\\<lambda>a. if a \\<in> A then g b' else g b)\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV =\n       (K$ g b')", "}"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) ?A2 =\n  Abs_finfun (\\<lambda>a. if a \\<in> ?A2 then g b' else g b)\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV =\n       (K$ g b')", "from this[of UNIV]"], ["proof (chain)\npicking this:\n  Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV =\n  Abs_finfun (\\<lambda>a. if a \\<in> UNIV then g b' else g b)", "show \"Finite_Set.fold (\\<lambda>(a :: 'c) c. c(a $:= g b')) (K$ g b) UNIV = (K$ g b')\""], ["proof (prove)\nusing this:\n  Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV =\n  Abs_finfun (\\<lambda>a. if a \\<in> UNIV then g b' else g b)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV = (K$ g b')", "by(simp add: finfun_const_def)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a c. c(a $:= g b')) (K$ g b) UNIV = (K$ g b')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_comp_const [simp, code]:\n  \"g \\<circ>$ (K$ c) = (K$ g c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<circ>$ (K$ c) = (K$ g c)", "by(simp add: finfun_comp_def)"], ["", "lemma finfun_comp_update [simp]: \"g \\<circ>$ (f(a $:= b)) = (g \\<circ>$ f)(a $:= g b)\"\n  and finfun_comp_update_code [code]: \n  \"g \\<circ>$ (finfun_update_code f a b) = finfun_update_code (g \\<circ>$ f) a (g b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<circ>$ f(a $:= b) = (g \\<circ>$ f)(a $:= g b) &&&\n    g \\<circ>$ finfun_update_code f a b =\n    finfun_update_code (g \\<circ>$ f) a (g b)", "by(simp_all add: finfun_comp_def)"], ["", "lemma finfun_comp_apply [simp]:\n  \"($) (g \\<circ>$ f) = g \\<circ> ($) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (g \\<circ>$ f) = g \\<circ> ($) f", "by(induct f rule: finfun_weak_induct)(auto simp add: finfun_upd_apply)"], ["", "lemma finfun_comp_comp_collapse [simp]: \"f \\<circ>$ g \\<circ>$ h = (f \\<circ> g) \\<circ>$ h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ>$ g \\<circ>$ h = (f \\<circ> g) \\<circ>$ h", "by(induct h rule: finfun_weak_induct) simp_all"], ["", "lemma finfun_comp_const1 [simp]: \"(\\<lambda>x. c) \\<circ>$ f = (K$ c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. c) \\<circ>$ f = (K$ c)", "by(induct f rule: finfun_weak_induct)(auto intro: finfun_ext simp add: finfun_upd_apply)"], ["", "lemma finfun_comp_id1 [simp]: \"(\\<lambda>x. x) \\<circ>$ f = f\" \"id \\<circ>$ f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x) \\<circ>$ f = f &&& id \\<circ>$ f = f", "by(induct f rule: finfun_weak_induct) auto"], ["", "lemma finfun_comp_conv_comp: \"g \\<circ>$ f = Abs_finfun (g \\<circ> ($) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<circ>$ f = Abs_finfun (g \\<circ> ($) f)", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<circ>$ f = Abs_finfun (g \\<circ> ($) f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<circ>$ f = Abs_finfun (g \\<circ> ($) f)", "have \"(\\<lambda>f. g \\<circ>$ f) = (\\<lambda>f. Abs_finfun (g \\<circ> ($) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<circ>$) g = (\\<lambda>f. Abs_finfun (g \\<circ> ($) f))", "proof(rule finfun_rec_unique)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c. g \\<circ>$ (K$ c) = ?cnst c\n 2. \\<And>ga a b. g \\<circ>$ ga(a $:= b) = ?upd ga a b (g \\<circ>$ ga)\n 3. \\<And>c. Abs_finfun (g \\<circ> ($) (K$ c)) = ?cnst c\n 4. \\<And>ga a b.\n       Abs_finfun (g \\<circ> ($) ga(a $:= b)) =\n       ?upd ga a b (Abs_finfun (g \\<circ> ($) ga))", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c. g \\<circ>$ (K$ c) = ?cnst c\n 2. \\<And>ga a b. g \\<circ>$ ga(a $:= b) = ?upd ga a b (g \\<circ>$ ga)\n 3. \\<And>c. Abs_finfun (g \\<circ> ($) (K$ c)) = ?cnst c\n 4. \\<And>ga a b.\n       Abs_finfun (g \\<circ> ($) ga(a $:= b)) =\n       ?upd ga a b (Abs_finfun (g \\<circ> ($) ga))", "fix c"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c. g \\<circ>$ (K$ c) = ?cnst c\n 2. \\<And>ga a b. g \\<circ>$ ga(a $:= b) = ?upd ga a b (g \\<circ>$ ga)\n 3. \\<And>c. Abs_finfun (g \\<circ> ($) (K$ c)) = ?cnst c\n 4. \\<And>ga a b.\n       Abs_finfun (g \\<circ> ($) ga(a $:= b)) =\n       ?upd ga a b (Abs_finfun (g \\<circ> ($) ga))", "show \"Abs_finfun (g \\<circ> ($) (K$ c)) = (K$ g c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_finfun (g \\<circ> ($) (K$ c)) = (K$ g c)", "by(simp add: finfun_comp_def o_def)(simp add: finfun_const_def)"], ["proof (state)\nthis:\n  Abs_finfun (g \\<circ> ($) (K$ c)) = (K$ g c)\n\ngoal (3 subgoals):\n 1. \\<And>c. g \\<circ>$ (K$ c) = (K$ g c)\n 2. \\<And>ga a b. g \\<circ>$ ga(a $:= b) = ?upd ga a b (g \\<circ>$ ga)\n 3. \\<And>ga a b.\n       Abs_finfun (g \\<circ> ($) ga(a $:= b)) =\n       ?upd ga a b (Abs_finfun (g \\<circ> ($) ga))", "}"], ["proof (state)\nthis:\n  Abs_finfun (g \\<circ> ($) (K$ ?c4)) = (K$ g ?c4)\n\ngoal (3 subgoals):\n 1. \\<And>c. g \\<circ>$ (K$ c) = (K$ g c)\n 2. \\<And>ga a b. g \\<circ>$ ga(a $:= b) = ?upd ga a b (g \\<circ>$ ga)\n 3. \\<And>ga a b.\n       Abs_finfun (g \\<circ> ($) ga(a $:= b)) =\n       ?upd ga a b (Abs_finfun (g \\<circ> ($) ga))", "{"], ["proof (state)\nthis:\n  Abs_finfun (g \\<circ> ($) (K$ ?c4)) = (K$ g ?c4)\n\ngoal (3 subgoals):\n 1. \\<And>c. g \\<circ>$ (K$ c) = (K$ g c)\n 2. \\<And>ga a b. g \\<circ>$ ga(a $:= b) = ?upd ga a b (g \\<circ>$ ga)\n 3. \\<And>ga a b.\n       Abs_finfun (g \\<circ> ($) ga(a $:= b)) =\n       ?upd ga a b (Abs_finfun (g \\<circ> ($) ga))", "fix g' a b"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c. g \\<circ>$ (K$ c) = (K$ g c)\n 2. \\<And>ga a b. g \\<circ>$ ga(a $:= b) = ?upd ga a b (g \\<circ>$ ga)\n 3. \\<And>ga a b.\n       Abs_finfun (g \\<circ> ($) ga(a $:= b)) =\n       ?upd ga a b (Abs_finfun (g \\<circ> ($) ga))", "show \"Abs_finfun (g \\<circ> ($) g'(a $:= b)) = (Abs_finfun (g \\<circ> ($) g'))(a $:= g b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_finfun (g \\<circ> ($) g'(a $:= b)) =\n    (Abs_finfun (g \\<circ> ($) g'))(a $:= g b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Abs_finfun (g \\<circ> ($) g'(a $:= b)) =\n    (Abs_finfun (g \\<circ> ($) g'))(a $:= g b)", "obtain y where y: \"y \\<in> finfun\" and g': \"g' = Abs_finfun y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> finfun; g' = Abs_finfun y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases g')"], ["proof (state)\nthis:\n  y \\<in> finfun\n  g' = Abs_finfun y\n\ngoal (1 subgoal):\n 1. Abs_finfun (g \\<circ> ($) g'(a $:= b)) =\n    (Abs_finfun (g \\<circ> ($) g'))(a $:= g b)", "moreover"], ["proof (state)\nthis:\n  y \\<in> finfun\n  g' = Abs_finfun y\n\ngoal (1 subgoal):\n 1. Abs_finfun (g \\<circ> ($) g'(a $:= b)) =\n    (Abs_finfun (g \\<circ> ($) g'))(a $:= g b)", "from g'"], ["proof (chain)\npicking this:\n  g' = Abs_finfun y", "have \"(g \\<circ> ($) g') \\<in> finfun\""], ["proof (prove)\nusing this:\n  g' = Abs_finfun y\n\ngoal (1 subgoal):\n 1. g \\<circ> ($) g' \\<in> finfun", "by(simp add: finfun_left_compose)"], ["proof (state)\nthis:\n  g \\<circ> ($) g' \\<in> finfun\n\ngoal (1 subgoal):\n 1. Abs_finfun (g \\<circ> ($) g'(a $:= b)) =\n    (Abs_finfun (g \\<circ> ($) g'))(a $:= g b)", "moreover"], ["proof (state)\nthis:\n  g \\<circ> ($) g' \\<in> finfun\n\ngoal (1 subgoal):\n 1. Abs_finfun (g \\<circ> ($) g'(a $:= b)) =\n    (Abs_finfun (g \\<circ> ($) g'))(a $:= g b)", "have \"g \\<circ> y(a := b) = (g \\<circ> y)(a := g b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<circ> y(a := b) = (g \\<circ> y)(a := g b)", "by(auto)"], ["proof (state)\nthis:\n  g \\<circ> y(a := b) = (g \\<circ> y)(a := g b)\n\ngoal (1 subgoal):\n 1. Abs_finfun (g \\<circ> ($) g'(a $:= b)) =\n    (Abs_finfun (g \\<circ> ($) g'))(a $:= g b)", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> finfun\n  g' = Abs_finfun y\n  g \\<circ> ($) g' \\<in> finfun\n  g \\<circ> y(a := b) = (g \\<circ> y)(a := g b)", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> finfun\n  g' = Abs_finfun y\n  g \\<circ> ($) g' \\<in> finfun\n  g \\<circ> y(a := b) = (g \\<circ> y)(a := g b)\n\ngoal (1 subgoal):\n 1. Abs_finfun (g \\<circ> ($) g'(a $:= b)) =\n    (Abs_finfun (g \\<circ> ($) g'))(a $:= g b)", "by(simp add: finfun_comp_def finfun_update_def)"], ["proof (state)\nthis:\n  Abs_finfun (g \\<circ> ($) g'(a $:= b)) =\n  (Abs_finfun (g \\<circ> ($) g'))(a $:= g b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Abs_finfun (g \\<circ> ($) g'(a $:= b)) =\n  (Abs_finfun (g \\<circ> ($) g'))(a $:= g b)\n\ngoal (2 subgoals):\n 1. \\<And>c. g \\<circ>$ (K$ c) = (K$ g c)\n 2. \\<And>ga a b. g \\<circ>$ ga(a $:= b) = (g \\<circ>$ ga)(a $:= g b)", "}"], ["proof (state)\nthis:\n  Abs_finfun (g \\<circ> ($) ?g'2(?a2 $:= ?b2)) =\n  (Abs_finfun (g \\<circ> ($) ?g'2))(?a2 $:= g ?b2)\n\ngoal (2 subgoals):\n 1. \\<And>c. g \\<circ>$ (K$ c) = (K$ g c)\n 2. \\<And>ga a b. g \\<circ>$ ga(a $:= b) = (g \\<circ>$ ga)(a $:= g b)", "qed auto"], ["proof (state)\nthis:\n  (\\<circ>$) g = (\\<lambda>f. Abs_finfun (g \\<circ> ($) f))\n\ngoal (1 subgoal):\n 1. g \\<circ>$ f = Abs_finfun (g \\<circ> ($) f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<circ>$) g = (\\<lambda>f. Abs_finfun (g \\<circ> ($) f))\n\ngoal (1 subgoal):\n 1. g \\<circ>$ f = Abs_finfun (g \\<circ> ($) f)", "by(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  g \\<circ>$ f = Abs_finfun (g \\<circ> ($) f)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition finfun_comp2 :: \"'b \\<Rightarrow>f 'c \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow>f 'c\"  (infixr \"$\\<circ>\" 55)\nwhere [code del]: \"g $\\<circ> f = Abs_finfun (($) g \\<circ> f)\""], ["", "notation (ASCII)\n  finfun_comp2  (infixr \"$o\" 55)"], ["", "lemma finfun_comp2_const [code, simp]: \"finfun_comp2 (K$ c) f = (K$ c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (K$ c) $\\<circ> f = (K$ c)", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. (K$ c) $\\<circ> f = (K$ c)", "by(simp add: finfun_comp2_def finfun_const_def comp_def)"], ["", "lemma finfun_comp2_update:\n  assumes inj: \"inj f\"\n  shows \"finfun_comp2 (g(b $:= c)) f = (if b \\<in> range f then (finfun_comp2 g f)(inv f b $:= c) else finfun_comp2 g f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)", "proof(cases \"b \\<in> range f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> range f \\<Longrightarrow>\n    g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)\n 2. b \\<notin> range f \\<Longrightarrow>\n    g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)", "case True"], ["proof (state)\nthis:\n  b \\<in> range f\n\ngoal (2 subgoals):\n 1. b \\<in> range f \\<Longrightarrow>\n    g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)\n 2. b \\<notin> range f \\<Longrightarrow>\n    g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)", "from inj"], ["proof (chain)\npicking this:\n  inj f", "have \"\\<And>x. (($) g)(f x := c) \\<circ> f = (($) g \\<circ> f)(x := c)\""], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. \\<And>x. (($) g)(f x := c) \\<circ> f = (($) g \\<circ> f)(x := c)", "by(auto intro!: ext dest: injD)"], ["proof (state)\nthis:\n  (($) g)(f ?x := c) \\<circ> f = (($) g \\<circ> f)(?x := c)\n\ngoal (2 subgoals):\n 1. b \\<in> range f \\<Longrightarrow>\n    g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)\n 2. b \\<notin> range f \\<Longrightarrow>\n    g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)", "with inj True"], ["proof (chain)\npicking this:\n  inj f\n  b \\<in> range f\n  (($) g)(f ?x := c) \\<circ> f = (($) g \\<circ> f)(?x := c)", "show ?thesis"], ["proof (prove)\nusing this:\n  inj f\n  b \\<in> range f\n  (($) g)(f ?x := c) \\<circ> f = (($) g \\<circ> f)(?x := c)\n\ngoal (1 subgoal):\n 1. g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)", "by(auto simp add: finfun_comp2_def finfun_update_def finfun_right_compose)"], ["proof (state)\nthis:\n  g(b $:= c) $\\<circ> f =\n  (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c) else g $\\<circ> f)\n\ngoal (1 subgoal):\n 1. b \\<notin> range f \\<Longrightarrow>\n    g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> range f \\<Longrightarrow>\n    g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)", "case False"], ["proof (state)\nthis:\n  b \\<notin> range f\n\ngoal (1 subgoal):\n 1. b \\<notin> range f \\<Longrightarrow>\n    g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)", "hence \"(($) g)(b := c) \\<circ> f = ($) g \\<circ> f\""], ["proof (prove)\nusing this:\n  b \\<notin> range f\n\ngoal (1 subgoal):\n 1. (($) g)(b := c) \\<circ> f = ($) g \\<circ> f", "by(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  (($) g)(b := c) \\<circ> f = ($) g \\<circ> f\n\ngoal (1 subgoal):\n 1. b \\<notin> range f \\<Longrightarrow>\n    g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)", "with False"], ["proof (chain)\npicking this:\n  b \\<notin> range f\n  (($) g)(b := c) \\<circ> f = ($) g \\<circ> f", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<notin> range f\n  (($) g)(b := c) \\<circ> f = ($) g \\<circ> f\n\ngoal (1 subgoal):\n 1. g(b $:= c) $\\<circ> f =\n    (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c)\n     else g $\\<circ> f)", "by(auto simp add: finfun_comp2_def finfun_update_def)"], ["proof (state)\nthis:\n  g(b $:= c) $\\<circ> f =\n  (if b \\<in> range f then (g $\\<circ> f)(inv f b $:= c) else g $\\<circ> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Universal quantification\\<close>"], ["", "definition finfun_All_except :: \"'a list \\<Rightarrow> 'a \\<Rightarrow>f bool \\<Rightarrow> bool\"\nwhere [code del]: \"finfun_All_except A P \\<equiv> \\<forall>a. a \\<in> set A \\<or> P $ a\""], ["", "lemma finfun_All_except_const: \"finfun_All_except A (K$ b) \\<longleftrightarrow> b \\<or> set A = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_All_except A (K$ b) = (b \\<or> set A = UNIV)", "by(auto simp add: finfun_All_except_def)"], ["", "lemma finfun_All_except_const_finfun_UNIV_code [code]:\n  \"finfun_All_except A (K$ b) = (b \\<or> is_list_UNIV A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_All_except A (K$ b) = (b \\<or> is_list_UNIV A)", "by(simp add: finfun_All_except_const is_list_UNIV_iff)"], ["", "lemma finfun_All_except_update:\n  \"finfun_All_except A f(a $:= b) = ((a \\<in> set A \\<or> b) \\<and> finfun_All_except (a # A) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_All_except A f(a $:= b) =\n    ((a \\<in> set A \\<or> b) \\<and> finfun_All_except (a # A) f)", "by(fastforce simp add: finfun_All_except_def finfun_upd_apply)"], ["", "lemma finfun_All_except_update_code [code]:\n  fixes a :: \"'a :: card_UNIV\"\n  shows \"finfun_All_except A (finfun_update_code f a b) = ((a \\<in> set A \\<or> b) \\<and> finfun_All_except (a # A) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_All_except A (finfun_update_code f a b) =\n    ((a \\<in> set A \\<or> b) \\<and> finfun_All_except (a # A) f)", "by(simp add: finfun_All_except_update)"], ["", "definition finfun_All :: \"'a \\<Rightarrow>f bool \\<Rightarrow> bool\"\nwhere \"finfun_All = finfun_All_except []\""], ["", "lemma finfun_All_const [simp]: \"finfun_All (K$ b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_All (K$ b) = b", "by(simp add: finfun_All_def finfun_All_except_def)"], ["", "lemma finfun_All_update: \"finfun_All f(a $:= b) = (b \\<and> finfun_All_except [a] f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_All f(a $:= b) = (b \\<and> finfun_All_except [a] f)", "by(simp add: finfun_All_def finfun_All_except_update)"], ["", "lemma finfun_All_All: \"finfun_All P = All (($) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_All P = All (($) P)", "by(simp add: finfun_All_def finfun_All_except_def)"], ["", "definition finfun_Ex :: \"'a \\<Rightarrow>f bool \\<Rightarrow> bool\"\nwhere \"finfun_Ex P = Not (finfun_All (Not \\<circ>$ P))\""], ["", "lemma finfun_Ex_Ex: \"finfun_Ex P = Ex (($) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Ex P = Ex (($) P)", "unfolding finfun_Ex_def finfun_All_All"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> All (($) (Not \\<circ>$ P))) = Ex (($) P)", "by simp"], ["", "lemma finfun_Ex_const [simp]: \"finfun_Ex (K$ b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_Ex (K$ b) = b", "by(simp add: finfun_Ex_def)"], ["", "subsection \\<open>A diagonal operator for FinFuns\\<close>"], ["", "definition finfun_Diag :: \"'a \\<Rightarrow>f 'b \\<Rightarrow> 'a \\<Rightarrow>f 'c \\<Rightarrow> 'a \\<Rightarrow>f ('b \\<times> 'c)\" (\"(1'($_,/ _$'))\" [0, 0] 1000)\nwhere [code del]: \"($f, g$) = finfun_rec (\\<lambda>b. Pair b \\<circ>$ g) (\\<lambda>a b c. c(a $:= (b, g $ a))) f\""], ["", "interpretation finfun_Diag_aux: finfun_rec_wf_aux \"\\<lambda>b. Pair b \\<circ>$ g\" \"\\<lambda>a b c. c(a $:= (b, g $ a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec_wf_aux (\\<lambda>b. Pair b \\<circ>$ g)\n     (\\<lambda>a b c. c(a $:= (b, g $ a)))", "by(unfold_locales)(simp_all add: expand_finfun_eq fun_eq_iff finfun_upd_apply)"], ["", "interpretation finfun_Diag: finfun_rec_wf \"\\<lambda>b. Pair b \\<circ>$ g\" \"\\<lambda>a b c. c(a $:= (b, g $ a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec_wf (\\<lambda>b. Pair b \\<circ>$ g)\n     (\\<lambda>a b c. c(a $:= (b, g $ a)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a)))\n        (Pair b \\<circ>$ g) UNIV =\n       Pair b' \\<circ>$ g", "fix b' b :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a)))\n        (Pair b \\<circ>$ g) UNIV =\n       Pair b' \\<circ>$ g", "assume fin: \"finite (UNIV :: 'c set)\""], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a)))\n        (Pair b \\<circ>$ g) UNIV =\n       Pair b' \\<circ>$ g", "{"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a)))\n        (Pair b \\<circ>$ g) UNIV =\n       Pair b' \\<circ>$ g", "fix A :: \"'c set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a)))\n        (Pair b \\<circ>$ g) UNIV =\n       Pair b' \\<circ>$ g", "interpret comp_fun_commute \"\\<lambda>a c. c(a $:= (b', g $ a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute (\\<lambda>a c. c(a $:= (b', g $ a)))", "by(rule finfun_Diag_aux.upd_left_comm)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a)))\n        (Pair b \\<circ>$ g) UNIV =\n       Pair b' \\<circ>$ g", "from fin"], ["proof (chain)\npicking this:\n  finite UNIV", "have \"finite A\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite A", "by(auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a)))\n        (Pair b \\<circ>$ g) UNIV =\n       Pair b' \\<circ>$ g", "hence \"Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a))) (Pair b \\<circ>$ g) A =\n      Abs_finfun (\\<lambda>a. (if a \\<in> A then b' else b, g $ a))\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a))) (Pair b \\<circ>$ g)\n     A =\n    Abs_finfun (\\<lambda>a. (if a \\<in> A then b' else b, g $ a))", "by(induct)(simp_all add: finfun_const_def finfun_comp_conv_comp o_def,\n                 auto simp add: finfun_update_def Abs_finfun_inverse_finite fun_upd_def Abs_finfun_inject_finite fun_eq_iff fin)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a))) (Pair b \\<circ>$ g)\n   A =\n  Abs_finfun (\\<lambda>a. (if a \\<in> A then b' else b, g $ a))\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a)))\n        (Pair b \\<circ>$ g) UNIV =\n       Pair b' \\<circ>$ g", "}"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a))) (Pair b \\<circ>$ g)\n   ?A2 =\n  Abs_finfun (\\<lambda>a. (if a \\<in> ?A2 then b' else b, g $ a))\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a)))\n        (Pair b \\<circ>$ g) UNIV =\n       Pair b' \\<circ>$ g", "from this[of UNIV]"], ["proof (chain)\npicking this:\n  Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a))) (Pair b \\<circ>$ g)\n   UNIV =\n  Abs_finfun (\\<lambda>a. (if a \\<in> UNIV then b' else b, g $ a))", "show \"Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a))) (Pair b \\<circ>$ g) UNIV = Pair b' \\<circ>$ g\""], ["proof (prove)\nusing this:\n  Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a))) (Pair b \\<circ>$ g)\n   UNIV =\n  Abs_finfun (\\<lambda>a. (if a \\<in> UNIV then b' else b, g $ a))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a))) (Pair b \\<circ>$ g)\n     UNIV =\n    Pair b' \\<circ>$ g", "by(simp add: finfun_const_def finfun_comp_conv_comp o_def)"], ["proof (state)\nthis:\n  Finite_Set.fold (\\<lambda>a c. c(a $:= (b', g $ a))) (Pair b \\<circ>$ g)\n   UNIV =\n  Pair b' \\<circ>$ g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_Diag_const1: \"($K$ b, g$) = Pair b \\<circ>$ g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($K$ b, g$) = Pair b \\<circ>$ g", "by(simp add: finfun_Diag_def)"], ["", "text \\<open>\n  Do not use @{thm finfun_Diag_const1} for the code generator because @{term \"Pair b\"} is injective, i.e. if @{term g} is free of redundant updates, there is no need to check for redundant updates as is done for @{term \"(\\<circ>$)\"}.\n\\<close>"], ["", "lemma finfun_Diag_const_code [code]:\n  \"($K$ b, K$ c$) = (K$ (b, c))\"\n  \"($K$ b, finfun_update_code g a c$) = finfun_update_code ($K$ b, g$) a (b, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($K$ b, K$ c$) = (K$ (b, c)) &&&\n    ($K$ b, finfun_update_code g a c$) =\n    finfun_update_code ($K$ b, g$) a (b, c)", "by(simp_all add: finfun_Diag_const1)"], ["", "lemma finfun_Diag_update1: \"($f(a $:= b), g$) = ($f, g$)(a $:= (b, g $ a))\"\n  and finfun_Diag_update1_code [code]: \"($finfun_update_code f a b, g$) = ($f, g$)(a $:= (b, g $ a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($f(a $:= b), g$) = ($f, g$)(a $:= (b, g $ a)) &&&\n    ($finfun_update_code f a b, g$) = ($f, g$)(a $:= (b, g $ a))", "by(simp_all add: finfun_Diag_def)"], ["", "lemma finfun_Diag_const2: \"($f, K$ c$) = (\\<lambda>b. (b, c)) \\<circ>$ f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($f, K$ c$) = (\\<lambda>b. (b, c)) \\<circ>$ f", "by(induct f rule: finfun_weak_induct)(auto intro!: finfun_ext simp add: finfun_upd_apply finfun_Diag_const1 finfun_Diag_update1)"], ["", "lemma finfun_Diag_update2: \"($f, g(a $:= c)$) = ($f, g$)(a $:= (f $ a, c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($f, g(a $:= c)$) = ($f, g$)(a $:= (f $ a, c))", "by(induct f rule: finfun_weak_induct)(auto intro!: finfun_ext simp add: finfun_upd_apply finfun_Diag_const1 finfun_Diag_update1)"], ["", "lemma finfun_Diag_const_const [simp]: \"($K$ b, K$ c$) = (K$ (b, c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($K$ b, K$ c$) = (K$ (b, c))", "by(simp add: finfun_Diag_const1)"], ["", "lemma finfun_Diag_const_update:\n  \"($K$ b, g(a $:= c)$) = ($K$ b, g$)(a $:= (b, c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($K$ b, g(a $:= c)$) = ($K$ b, g$)(a $:= (b, c))", "by(simp add: finfun_Diag_const1)"], ["", "lemma finfun_Diag_update_const:\n  \"($f(a $:= b), K$ c$) = ($f, K$ c$)(a $:= (b, c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($f(a $:= b), K$ c$) = ($f, K$ c$)(a $:= (b, c))", "by(simp add: finfun_Diag_def)"], ["", "lemma finfun_Diag_update_update:\n  \"($f(a $:= b), g(a' $:= c)$) = (if a = a' then ($f, g$)(a $:= (b, c)) else ($f, g$)(a $:= (b, g $ a))(a' $:= (f $ a', c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($f(a $:= b), g(a' $:= c)$) =\n    (if a = a' then ($f, g$)(a $:= (b, c))\n     else ($f, g$)(a $:= (b, g $ a))(a' $:= (f $ a', c)))", "by(auto simp add: finfun_Diag_update1 finfun_Diag_update2)"], ["", "lemma finfun_Diag_apply [simp]: \"($) ($f, g$) = (\\<lambda>x. (f $ x, g $ x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) ($f, g$) = (\\<lambda>x. (f $ x, g $ x))", "by(induct f rule: finfun_weak_induct)(auto simp add: finfun_Diag_const1 finfun_Diag_update1 finfun_upd_apply)"], ["", "lemma finfun_Diag_conv_Abs_finfun:\n  \"($f, g$) = Abs_finfun ((\\<lambda>x. (f $ x, g $ x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($f, g$) = Abs_finfun (\\<lambda>x. (f $ x, g $ x))", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($f, g$) = Abs_finfun (\\<lambda>x. (f $ x, g $ x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ($f, g$) = Abs_finfun (\\<lambda>x. (f $ x, g $ x))", "have \"(\\<lambda>f :: 'a \\<Rightarrow>f 'b. ($f, g$)) = (\\<lambda>f. Abs_finfun ((\\<lambda>x. (f $ x, g $ x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. ($f, g$)) =\n    (\\<lambda>f. Abs_finfun (\\<lambda>x. (f $ x, g $ x)))", "proof(rule finfun_rec_unique)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c. ($K$ c, g$) = ?cnst c\n 2. \\<And>ga a b. ($ga(a $:= b), g$) = ?upd ga a b ($ga, g$)\n 3. \\<And>c. Abs_finfun (\\<lambda>x. ((K$ c) $ x, g $ x)) = ?cnst c\n 4. \\<And>ga a b.\n       Abs_finfun (\\<lambda>x. (ga(a $:= b) $ x, g $ x)) =\n       ?upd ga a b (Abs_finfun (\\<lambda>x. (ga $ x, g $ x)))", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c. ($K$ c, g$) = ?cnst c\n 2. \\<And>ga a b. ($ga(a $:= b), g$) = ?upd ga a b ($ga, g$)\n 3. \\<And>c. Abs_finfun (\\<lambda>x. ((K$ c) $ x, g $ x)) = ?cnst c\n 4. \\<And>ga a b.\n       Abs_finfun (\\<lambda>x. (ga(a $:= b) $ x, g $ x)) =\n       ?upd ga a b (Abs_finfun (\\<lambda>x. (ga $ x, g $ x)))", "fix c"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c. ($K$ c, g$) = ?cnst c\n 2. \\<And>ga a b. ($ga(a $:= b), g$) = ?upd ga a b ($ga, g$)\n 3. \\<And>c. Abs_finfun (\\<lambda>x. ((K$ c) $ x, g $ x)) = ?cnst c\n 4. \\<And>ga a b.\n       Abs_finfun (\\<lambda>x. (ga(a $:= b) $ x, g $ x)) =\n       ?upd ga a b (Abs_finfun (\\<lambda>x. (ga $ x, g $ x)))", "show \"Abs_finfun (\\<lambda>x. ((K$ c) $ x, g $ x)) = Pair c \\<circ>$ g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_finfun (\\<lambda>x. ((K$ c) $ x, g $ x)) = Pair c \\<circ>$ g", "by(simp add: finfun_comp_conv_comp o_def finfun_const_def)"], ["proof (state)\nthis:\n  Abs_finfun (\\<lambda>x. ((K$ c) $ x, g $ x)) = Pair c \\<circ>$ g\n\ngoal (3 subgoals):\n 1. \\<And>c. ($K$ c, g$) = Pair c \\<circ>$ g\n 2. \\<And>ga a b. ($ga(a $:= b), g$) = ?upd ga a b ($ga, g$)\n 3. \\<And>ga a b.\n       Abs_finfun (\\<lambda>x. (ga(a $:= b) $ x, g $ x)) =\n       ?upd ga a b (Abs_finfun (\\<lambda>x. (ga $ x, g $ x)))", "}"], ["proof (state)\nthis:\n  Abs_finfun (\\<lambda>x. ((K$ ?c2) $ x, g $ x)) = Pair ?c2 \\<circ>$ g\n\ngoal (3 subgoals):\n 1. \\<And>c. ($K$ c, g$) = Pair c \\<circ>$ g\n 2. \\<And>ga a b. ($ga(a $:= b), g$) = ?upd ga a b ($ga, g$)\n 3. \\<And>ga a b.\n       Abs_finfun (\\<lambda>x. (ga(a $:= b) $ x, g $ x)) =\n       ?upd ga a b (Abs_finfun (\\<lambda>x. (ga $ x, g $ x)))", "{"], ["proof (state)\nthis:\n  Abs_finfun (\\<lambda>x. ((K$ ?c2) $ x, g $ x)) = Pair ?c2 \\<circ>$ g\n\ngoal (3 subgoals):\n 1. \\<And>c. ($K$ c, g$) = Pair c \\<circ>$ g\n 2. \\<And>ga a b. ($ga(a $:= b), g$) = ?upd ga a b ($ga, g$)\n 3. \\<And>ga a b.\n       Abs_finfun (\\<lambda>x. (ga(a $:= b) $ x, g $ x)) =\n       ?upd ga a b (Abs_finfun (\\<lambda>x. (ga $ x, g $ x)))", "fix g' a b"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c. ($K$ c, g$) = Pair c \\<circ>$ g\n 2. \\<And>ga a b. ($ga(a $:= b), g$) = ?upd ga a b ($ga, g$)\n 3. \\<And>ga a b.\n       Abs_finfun (\\<lambda>x. (ga(a $:= b) $ x, g $ x)) =\n       ?upd ga a b (Abs_finfun (\\<lambda>x. (ga $ x, g $ x)))", "show \"Abs_finfun (\\<lambda>x. (g'(a $:= b) $ x, g $ x)) =\n            (Abs_finfun (\\<lambda>x. (g' $ x, g $ x)))(a $:= (b, g $ a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_finfun (\\<lambda>x. (g'(a $:= b) $ x, g $ x)) =\n    (Abs_finfun (\\<lambda>x. (g' $ x, g $ x)))(a $:= (b, g $ a))", "by(auto simp add: finfun_update_def fun_eq_iff simp del: fun_upd_apply) simp"], ["proof (state)\nthis:\n  Abs_finfun (\\<lambda>x. (g'(a $:= b) $ x, g $ x)) =\n  (Abs_finfun (\\<lambda>x. (g' $ x, g $ x)))(a $:= (b, g $ a))\n\ngoal (2 subgoals):\n 1. \\<And>c. ($K$ c, g$) = Pair c \\<circ>$ g\n 2. \\<And>ga a b. ($ga(a $:= b), g$) = ($ga, g$)(a $:= (b, g $ a))", "}"], ["proof (state)\nthis:\n  Abs_finfun (\\<lambda>x. (?g'2(?a2 $:= ?b2) $ x, g $ x)) =\n  (Abs_finfun (\\<lambda>x. (?g'2 $ x, g $ x)))(?a2 $:= (?b2, g $ ?a2))\n\ngoal (2 subgoals):\n 1. \\<And>c. ($K$ c, g$) = Pair c \\<circ>$ g\n 2. \\<And>ga a b. ($ga(a $:= b), g$) = ($ga, g$)(a $:= (b, g $ a))", "qed(simp_all add: finfun_Diag_const1 finfun_Diag_update1)"], ["proof (state)\nthis:\n  (\\<lambda>f. ($f, g$)) =\n  (\\<lambda>f. Abs_finfun (\\<lambda>x. (f $ x, g $ x)))\n\ngoal (1 subgoal):\n 1. ($f, g$) = Abs_finfun (\\<lambda>x. (f $ x, g $ x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>f. ($f, g$)) =\n  (\\<lambda>f. Abs_finfun (\\<lambda>x. (f $ x, g $ x)))\n\ngoal (1 subgoal):\n 1. ($f, g$) = Abs_finfun (\\<lambda>x. (f $ x, g $ x))", "by(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  ($f, g$) = Abs_finfun (\\<lambda>x. (f $ x, g $ x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_Diag_eq: \"($f, g$) = ($f', g'$) \\<longleftrightarrow> f = f' \\<and> g = g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (($f, g$) = ($f', g'$)) = (f = f' \\<and> g = g')", "by(auto simp add: expand_finfun_eq fun_eq_iff)"], ["", "definition finfun_fst :: \"'a \\<Rightarrow>f ('b \\<times> 'c) \\<Rightarrow> 'a \\<Rightarrow>f 'b\"\nwhere [code]: \"finfun_fst f = fst \\<circ>$ f\""], ["", "lemma finfun_fst_const: \"finfun_fst (K$ bc) = (K$ fst bc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_fst (K$ bc) = (K$ fst bc)", "by(simp add: finfun_fst_def)"], ["", "lemma finfun_fst_update: \"finfun_fst (f(a $:= bc)) = (finfun_fst f)(a $:= fst bc)\"\n  and finfun_fst_update_code: \"finfun_fst (finfun_update_code f a bc) = (finfun_fst f)(a $:= fst bc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_fst f(a $:= bc) = (finfun_fst f)(a $:= fst bc) &&&\n    finfun_fst (finfun_update_code f a bc) = (finfun_fst f)(a $:= fst bc)", "by(simp_all add: finfun_fst_def)"], ["", "lemma finfun_fst_comp_conv: \"finfun_fst (f \\<circ>$ g) = (fst \\<circ> f) \\<circ>$ g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_fst (f \\<circ>$ g) = (fst \\<circ> f) \\<circ>$ g", "by(simp add: finfun_fst_def)"], ["", "lemma finfun_fst_conv [simp]: \"finfun_fst ($f, g$) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_fst ($f, g$) = f", "by(induct f rule: finfun_weak_induct)(simp_all add: finfun_Diag_const1 finfun_fst_comp_conv o_def finfun_Diag_update1 finfun_fst_update)"], ["", "lemma finfun_fst_conv_Abs_finfun: \"finfun_fst = (\\<lambda>f. Abs_finfun (fst \\<circ> ($) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_fst = (\\<lambda>f. Abs_finfun (fst \\<circ> ($) f))", "by(simp add: finfun_fst_def [abs_def] finfun_comp_conv_comp)"], ["", "definition finfun_snd :: \"'a \\<Rightarrow>f ('b \\<times> 'c) \\<Rightarrow> 'a \\<Rightarrow>f 'c\"\nwhere [code]: \"finfun_snd f = snd \\<circ>$ f\""], ["", "lemma finfun_snd_const: \"finfun_snd (K$ bc) = (K$ snd bc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_snd (K$ bc) = (K$ snd bc)", "by(simp add: finfun_snd_def)"], ["", "lemma finfun_snd_update: \"finfun_snd (f(a $:= bc)) = (finfun_snd f)(a $:= snd bc)\"\n  and finfun_snd_update_code [code]: \"finfun_snd (finfun_update_code f a bc) = (finfun_snd f)(a $:= snd bc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_snd f(a $:= bc) = (finfun_snd f)(a $:= snd bc) &&&\n    finfun_snd (finfun_update_code f a bc) = (finfun_snd f)(a $:= snd bc)", "by(simp_all add: finfun_snd_def)"], ["", "lemma finfun_snd_comp_conv: \"finfun_snd (f \\<circ>$ g) = (snd \\<circ> f) \\<circ>$ g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_snd (f \\<circ>$ g) = (snd \\<circ> f) \\<circ>$ g", "by(simp add: finfun_snd_def)"], ["", "lemma finfun_snd_conv [simp]: \"finfun_snd ($f, g$) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_snd ($f, g$) = g", "apply(induct f rule: finfun_weak_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. finfun_snd ($K$ b, g$) = g\n 2. \\<And>f a b.\n       finfun_snd ($f, g$) = g \\<Longrightarrow>\n       finfun_snd ($f(a $:= b), g$) = g", "apply(auto simp add: finfun_Diag_const1 finfun_snd_comp_conv o_def finfun_Diag_update1 finfun_snd_update finfun_upd_apply intro: finfun_ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finfun_snd_conv_Abs_finfun: \"finfun_snd = (\\<lambda>f. Abs_finfun (snd \\<circ> ($) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_snd = (\\<lambda>f. Abs_finfun (snd \\<circ> ($) f))", "by(simp add: finfun_snd_def [abs_def] finfun_comp_conv_comp)"], ["", "lemma finfun_Diag_collapse [simp]: \"($finfun_fst f, finfun_snd f$) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($finfun_fst f, finfun_snd f$) = f", "by(induct f rule: finfun_weak_induct)(simp_all add: finfun_fst_const finfun_snd_const finfun_fst_update finfun_snd_update finfun_Diag_update_update)"], ["", "subsection \\<open>Currying for FinFuns\\<close>"], ["", "definition finfun_curry :: \"('a \\<times> 'b) \\<Rightarrow>f 'c \\<Rightarrow> 'a \\<Rightarrow>f 'b \\<Rightarrow>f 'c\"\nwhere [code del]: \"finfun_curry = finfun_rec (finfun_const \\<circ> finfun_const) (\\<lambda>(a, b) c f. f(a $:= (f $ a)(b $:= c)))\""], ["", "interpretation finfun_curry_aux: finfun_rec_wf_aux \"finfun_const \\<circ> finfun_const\" \"\\<lambda>(a, b) c f. f(a $:= (f $ a)(b $:= c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec_wf_aux (finfun_const \\<circ> finfun_const)\n     (\\<lambda>(a, b) c f. f(a $:= (f $ a)(b $:= c)))", "apply(unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (case a of\n        (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n        b ((finfun_const \\<circ> finfun_const) b) =\n       (finfun_const \\<circ> finfun_const) b\n 2. \\<And>a a' b b' c.\n       a \\<noteq> a' \\<Longrightarrow>\n       (case a of\n        (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n        b ((case a' of\n            (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n            b' c) =\n       (case a' of\n        (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n        b' ((case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b c)\n 3. \\<And>b b' a b''.\n       b \\<noteq> b' \\<Longrightarrow>\n       (case a of\n        (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n        b''\n        ((case a of\n          (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n          b' ((finfun_const \\<circ> finfun_const) b)) =\n       (case a of\n        (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n        b'' ((finfun_const \\<circ> finfun_const) b)", "apply(auto simp add: split_def finfun_update_twist finfun_upd_apply split_paired_all finfun_update_const_same)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation finfun_curry: finfun_rec_wf \"finfun_const \\<circ> finfun_const\" \"\\<lambda>(a, b) c f. f(a $:= (f $ a)(b $:= c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_rec_wf (finfun_const \\<circ> finfun_const)\n     (\\<lambda>(a, b) c f. f(a $:= (f $ a)(b $:= c)))", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold\n        (\\<lambda>a.\n            (case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b')\n        ((finfun_const \\<circ> finfun_const) b) UNIV =\n       (finfun_const \\<circ> finfun_const) b'", "fix b' b :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold\n        (\\<lambda>a.\n            (case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b')\n        ((finfun_const \\<circ> finfun_const) b) UNIV =\n       (finfun_const \\<circ> finfun_const) b'", "assume fin: \"finite (UNIV :: ('c \\<times> 'a) set)\""], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold\n        (\\<lambda>a.\n            (case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b')\n        ((finfun_const \\<circ> finfun_const) b) UNIV =\n       (finfun_const \\<circ> finfun_const) b'", "hence fin1: \"finite (UNIV :: 'c set)\" and fin2: \"finite (UNIV :: 'a set)\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV &&& finite UNIV", "unfolding UNIV_Times_UNIV[symmetric]"], ["proof (prove)\nusing this:\n  finite (UNIV \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. finite UNIV &&& finite UNIV", "by(fastforce dest: finite_cartesian_productD1 finite_cartesian_productD2)+"], ["proof (state)\nthis:\n  finite UNIV\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold\n        (\\<lambda>a.\n            (case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b')\n        ((finfun_const \\<circ> finfun_const) b) UNIV =\n       (finfun_const \\<circ> finfun_const) b'", "note [simp] = Abs_finfun_inverse_finite[OF fin] Abs_finfun_inverse_finite[OF fin1] Abs_finfun_inverse_finite[OF fin2]"], ["proof (state)\nthis:\n  ($) (Abs_finfun ?x) = ?x\n  ($) (Abs_finfun ?x) = ?x\n  ($) (Abs_finfun ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold\n        (\\<lambda>a.\n            (case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b')\n        ((finfun_const \\<circ> finfun_const) b) UNIV =\n       (finfun_const \\<circ> finfun_const) b'", "{"], ["proof (state)\nthis:\n  ($) (Abs_finfun ?x) = ?x\n  ($) (Abs_finfun ?x) = ?x\n  ($) (Abs_finfun ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold\n        (\\<lambda>a.\n            (case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b')\n        ((finfun_const \\<circ> finfun_const) b) UNIV =\n       (finfun_const \\<circ> finfun_const) b'", "fix A :: \"('c \\<times> 'a) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold\n        (\\<lambda>a.\n            (case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b')\n        ((finfun_const \\<circ> finfun_const) b) UNIV =\n       (finfun_const \\<circ> finfun_const) b'", "interpret comp_fun_commute \"\\<lambda>a :: 'c \\<times> 'a. (\\<lambda>(a, b) c f. f(a $:= (f $ a)(b $:= c))) a b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute\n     (\\<lambda>a.\n         (case a of\n          (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n          b')", "by(rule finfun_curry_aux.upd_left_comm)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold\n        (\\<lambda>a.\n            (case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b')\n        ((finfun_const \\<circ> finfun_const) b) UNIV =\n       (finfun_const \\<circ> finfun_const) b'", "from fin"], ["proof (chain)\npicking this:\n  finite UNIV", "have \"finite A\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite A", "by(auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold\n        (\\<lambda>a.\n            (case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b')\n        ((finfun_const \\<circ> finfun_const) b) UNIV =\n       (finfun_const \\<circ> finfun_const) b'", "hence \"Finite_Set.fold (\\<lambda>a :: 'c \\<times> 'a. (\\<lambda>(a, b) c f. f(a $:= (f $ a)(b $:= c))) a b') ((finfun_const \\<circ> finfun_const) b) A = Abs_finfun (\\<lambda>a. Abs_finfun (\\<lambda>b''. if (a, b'') \\<in> A then b' else b))\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         (case a of\n          (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n          b')\n     ((finfun_const \\<circ> finfun_const) b) A =\n    Abs_finfun\n     (\\<lambda>a.\n         Abs_finfun (\\<lambda>b''. if (a, b'') \\<in> A then b' else b))", "by induct (simp_all, auto simp add: finfun_update_def finfun_const_def split_def intro!: arg_cong[where f=\"Abs_finfun\"] ext)"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       (case a of\n        (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n        b')\n   ((finfun_const \\<circ> finfun_const) b) A =\n  Abs_finfun\n   (\\<lambda>a.\n       Abs_finfun (\\<lambda>b''. if (a, b'') \\<in> A then b' else b))\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold\n        (\\<lambda>a.\n            (case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b')\n        ((finfun_const \\<circ> finfun_const) b) UNIV =\n       (finfun_const \\<circ> finfun_const) b'", "}"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       (case a of\n        (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n        b')\n   ((finfun_const \\<circ> finfun_const) b) ?A2 =\n  Abs_finfun\n   (\\<lambda>a.\n       Abs_finfun (\\<lambda>b''. if (a, b'') \\<in> ?A2 then b' else b))\n\ngoal (1 subgoal):\n 1. \\<And>b' b.\n       finite UNIV \\<Longrightarrow>\n       Finite_Set.fold\n        (\\<lambda>a.\n            (case a of\n             (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n             b')\n        ((finfun_const \\<circ> finfun_const) b) UNIV =\n       (finfun_const \\<circ> finfun_const) b'", "from this[of UNIV]"], ["proof (chain)\npicking this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       (case a of\n        (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n        b')\n   ((finfun_const \\<circ> finfun_const) b) UNIV =\n  Abs_finfun\n   (\\<lambda>a.\n       Abs_finfun (\\<lambda>b''. if (a, b'') \\<in> UNIV then b' else b))", "show \"Finite_Set.fold (\\<lambda>a :: 'c \\<times> 'a. (\\<lambda>(a, b) c f. f(a $:= (f $ a)(b $:= c))) a b') ((finfun_const \\<circ> finfun_const) b) UNIV = (finfun_const \\<circ> finfun_const) b'\""], ["proof (prove)\nusing this:\n  Finite_Set.fold\n   (\\<lambda>a.\n       (case a of\n        (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n        b')\n   ((finfun_const \\<circ> finfun_const) b) UNIV =\n  Abs_finfun\n   (\\<lambda>a.\n       Abs_finfun (\\<lambda>b''. if (a, b'') \\<in> UNIV then b' else b))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold\n     (\\<lambda>a.\n         (case a of\n          (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n          b')\n     ((finfun_const \\<circ> finfun_const) b) UNIV =\n    (finfun_const \\<circ> finfun_const) b'", "by(simp add: finfun_const_def)"], ["proof (state)\nthis:\n  Finite_Set.fold\n   (\\<lambda>a.\n       (case a of\n        (a, b) \\<Rightarrow> \\<lambda>c f. f(a $:= (f $ a)(b $:= c)))\n        b')\n   ((finfun_const \\<circ> finfun_const) b) UNIV =\n  (finfun_const \\<circ> finfun_const) b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_curry_const [simp, code]: \"finfun_curry (K$ c) = (K$ K$ c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_curry (K$ c) = (K$ K$ c)", "by(simp add: finfun_curry_def)"], ["", "lemma finfun_curry_update [simp]:\n  \"finfun_curry (f((a, b) $:= c)) = (finfun_curry f)(a $:= (finfun_curry f $ a)(b $:= c))\"\n  and finfun_curry_update_code [code]:\n  \"finfun_curry (finfun_update_code f (a, b) c) = (finfun_curry f)(a $:= (finfun_curry f $ a)(b $:= c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_curry f((a, b) $:= c) =\n    (finfun_curry f)(a $:= (finfun_curry f $ a)(b $:= c)) &&&\n    finfun_curry (finfun_update_code f (a, b) c) =\n    (finfun_curry f)(a $:= (finfun_curry f $ a)(b $:= c))", "by(simp_all add: finfun_curry_def)"], ["", "lemma finfun_Abs_finfun_curry: assumes fin: \"f \\<in> finfun\"\n  shows \"(\\<lambda>a. Abs_finfun (curry f a)) \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. Abs_finfun (curry f a)) \\<in> finfun", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. Abs_finfun (curry f a)) \\<in> finfun", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>a. Abs_finfun (curry f a)) \\<in> finfun", "from fin"], ["proof (chain)\npicking this:\n  f \\<in> finfun", "obtain c where c: \"finite {ab. f ab \\<noteq> c}\""], ["proof (prove)\nusing this:\n  f \\<in> finfun\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        finite {ab. f ab \\<noteq> c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  f \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        finite {ab. f ab \\<noteq> c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite {ab. f ab \\<noteq> c}\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. Abs_finfun (curry f a)) \\<in> finfun", "have \"{a. \\<exists>b. f (a, b) \\<noteq> c} = fst ` {ab. f ab \\<noteq> c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. \\<exists>b. f (a, b) \\<noteq> c} = fst ` {ab. f ab \\<noteq> c}", "by(force)"], ["proof (state)\nthis:\n  {a. \\<exists>b. f (a, b) \\<noteq> c} = fst ` {ab. f ab \\<noteq> c}\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. Abs_finfun (curry f a)) \\<in> finfun", "hence \"{a. curry f a \\<noteq> (\\<lambda>x. c)} = fst ` {ab. f ab \\<noteq> c}\""], ["proof (prove)\nusing this:\n  {a. \\<exists>b. f (a, b) \\<noteq> c} = fst ` {ab. f ab \\<noteq> c}\n\ngoal (1 subgoal):\n 1. {a. curry f a \\<noteq> (\\<lambda>x. c)} = fst ` {ab. f ab \\<noteq> c}", "by(auto simp add: curry_def fun_eq_iff)"], ["proof (state)\nthis:\n  {a. curry f a \\<noteq> (\\<lambda>x. c)} = fst ` {ab. f ab \\<noteq> c}\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. Abs_finfun (curry f a)) \\<in> finfun", "with fin c"], ["proof (chain)\npicking this:\n  f \\<in> finfun\n  finite {ab. f ab \\<noteq> c}\n  {a. curry f a \\<noteq> (\\<lambda>x. c)} = fst ` {ab. f ab \\<noteq> c}", "have \"finite {a.  Abs_finfun (curry f a) \\<noteq> (K$ c)}\""], ["proof (prove)\nusing this:\n  f \\<in> finfun\n  finite {ab. f ab \\<noteq> c}\n  {a. curry f a \\<noteq> (\\<lambda>x. c)} = fst ` {ab. f ab \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {a. Abs_finfun (curry f a) \\<noteq> (K$ c)}", "by(simp add: finfun_const_def finfun_curry)"], ["proof (state)\nthis:\n  finite {a. Abs_finfun (curry f a) \\<noteq> (K$ c)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. Abs_finfun (curry f a)) \\<in> finfun", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite {a. Abs_finfun (curry f a) \\<noteq> (K$ c)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. Abs_finfun (curry f a)) \\<in> finfun", "unfolding finfun_def"], ["proof (prove)\nusing this:\n  finite {a. Abs_finfun (curry f a) \\<noteq> (K$ c)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. Abs_finfun (curry f a))\n    \\<in> {f. \\<exists>b. finite {a. f a \\<noteq> b}}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>a. Abs_finfun (curry f a)) \\<in> finfun\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_curry_conv_curry:\n  fixes f :: \"('a \\<times> 'b) \\<Rightarrow>f 'c\"\n  shows \"finfun_curry f = Abs_finfun (\\<lambda>a. Abs_finfun (curry (finfun_apply f) a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_curry f = Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) f) a))", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_curry f = Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) f) a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finfun_curry f = Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) f) a))", "have \"finfun_curry = (\\<lambda>f :: ('a \\<times> 'b) \\<Rightarrow>f 'c. Abs_finfun (\\<lambda>a. Abs_finfun (curry (finfun_apply f) a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_curry =\n    (\\<lambda>f. Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) f) a)))", "proof(rule finfun_rec_unique)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c. finfun_curry (K$ c) = ?cnst c\n 2. \\<And>g a b. finfun_curry g(a $:= b) = ?upd g a b (finfun_curry g)\n 3. \\<And>c.\n       Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) (K$ c)) a)) = ?cnst c\n 4. \\<And>g a b.\n       Abs_finfun (\\<lambda>aa. Abs_finfun (curry (($) g(a $:= b)) aa)) =\n       ?upd g a b (Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) g) a)))", "fix c"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c. finfun_curry (K$ c) = ?cnst c\n 2. \\<And>g a b. finfun_curry g(a $:= b) = ?upd g a b (finfun_curry g)\n 3. \\<And>c.\n       Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) (K$ c)) a)) = ?cnst c\n 4. \\<And>g a b.\n       Abs_finfun (\\<lambda>aa. Abs_finfun (curry (($) g(a $:= b)) aa)) =\n       ?upd g a b (Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) g) a)))", "show \"finfun_curry (K$ c) = (K$ K$ c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_curry (K$ c) = (K$ K$ c)", "by simp"], ["proof (state)\nthis:\n  finfun_curry (K$ c) = (K$ K$ c)\n\ngoal (3 subgoals):\n 1. \\<And>g a b. finfun_curry g(a $:= b) = ?upd g a b (finfun_curry g)\n 2. \\<And>c.\n       Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) (K$ c)) a)) =\n       (K$ K$ c)\n 3. \\<And>g a b.\n       Abs_finfun (\\<lambda>aa. Abs_finfun (curry (($) g(a $:= b)) aa)) =\n       ?upd g a b (Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) g) a)))", "fix f a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g a b. finfun_curry g(a $:= b) = ?upd g a b (finfun_curry g)\n 2. \\<And>c.\n       Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) (K$ c)) a)) =\n       (K$ K$ c)\n 3. \\<And>g a b.\n       Abs_finfun (\\<lambda>aa. Abs_finfun (curry (($) g(a $:= b)) aa)) =\n       ?upd g a b (Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) g) a)))", "show \"finfun_curry (f(a $:= c)) = (finfun_curry f)(fst a $:= (finfun_curry f $ (fst a))(snd a $:= c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_curry f(a $:= c) =\n    (finfun_curry f)(fst a $:= (finfun_curry f $ (fst a))(snd a $:= c))", "by(cases a) simp"], ["proof (state)\nthis:\n  finfun_curry f(a $:= c) =\n  (finfun_curry f)(fst a $:= (finfun_curry f $ (fst a))(snd a $:= c))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) (K$ c)) a)) =\n       (K$ K$ c)\n 2. \\<And>g a b.\n       Abs_finfun (\\<lambda>aa. Abs_finfun (curry (($) g(a $:= b)) aa)) =\n       (Abs_finfun\n         (\\<lambda>a.\n             Abs_finfun\n              (curry (($) g)\n                a)))(fst a $:= (Abs_finfun\n                                 (\\<lambda>a.\n                                     Abs_finfun (curry (($) g) a)) $\n                                (fst a))(snd a $:= b))", "show \"Abs_finfun (\\<lambda>a. Abs_finfun (curry (finfun_apply (K$ c)) a)) = (K$ K$ c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) (K$ c)) a)) = (K$ K$ c)", "by(simp add: finfun_curry_def finfun_const_def curry_def)"], ["proof (state)\nthis:\n  Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) (K$ c)) a)) = (K$ K$ c)\n\ngoal (1 subgoal):\n 1. \\<And>g a b.\n       Abs_finfun (\\<lambda>aa. Abs_finfun (curry (($) g(a $:= b)) aa)) =\n       (Abs_finfun\n         (\\<lambda>a.\n             Abs_finfun\n              (curry (($) g)\n                a)))(fst a $:= (Abs_finfun\n                                 (\\<lambda>a.\n                                     Abs_finfun (curry (($) g) a)) $\n                                (fst a))(snd a $:= b))", "fix g b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g a b.\n       Abs_finfun (\\<lambda>aa. Abs_finfun (curry (($) g(a $:= b)) aa)) =\n       (Abs_finfun\n         (\\<lambda>a.\n             Abs_finfun\n              (curry (($) g)\n                a)))(fst a $:= (Abs_finfun\n                                 (\\<lambda>a.\n                                     Abs_finfun (curry (($) g) a)) $\n                                (fst a))(snd a $:= b))", "show \"Abs_finfun (\\<lambda>aa. Abs_finfun (curry (($) g(a $:= b)) aa)) =\n      (Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) g) a)))(\n      fst a $:= ((Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) g) a))) $ (fst a))(snd a $:= b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_finfun (\\<lambda>aa. Abs_finfun (curry (($) g(a $:= b)) aa)) =\n    (Abs_finfun\n      (\\<lambda>a.\n          Abs_finfun\n           (curry (($) g)\n             a)))(fst a $:= (Abs_finfun\n                              (\\<lambda>a. Abs_finfun (curry (($) g) a)) $\n                             (fst a))(snd a $:= b))", "by(cases a)(auto intro!: ext arg_cong[where f=Abs_finfun] simp add: finfun_curry_def finfun_update_def finfun_Abs_finfun_curry)"], ["proof (state)\nthis:\n  Abs_finfun (\\<lambda>aa. Abs_finfun (curry (($) g(a $:= b)) aa)) =\n  (Abs_finfun\n    (\\<lambda>a.\n        Abs_finfun\n         (curry (($) g)\n           a)))(fst a $:= (Abs_finfun\n                            (\\<lambda>a. Abs_finfun (curry (($) g) a)) $\n                           (fst a))(snd a $:= b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finfun_curry =\n  (\\<lambda>f. Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) f) a)))\n\ngoal (1 subgoal):\n 1. finfun_curry f = Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) f) a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finfun_curry =\n  (\\<lambda>f. Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) f) a)))\n\ngoal (1 subgoal):\n 1. finfun_curry f = Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) f) a))", "by(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  finfun_curry f = Abs_finfun (\\<lambda>a. Abs_finfun (curry (($) f) a))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Executable equality for FinFuns\\<close>"], ["", "lemma eq_finfun_All_ext: \"(f = g) \\<longleftrightarrow> finfun_All ((\\<lambda>(x, y). x = y) \\<circ>$ ($f, g$))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = g) = finfun_All ((\\<lambda>(x, y). x = y) \\<circ>$ ($f, g$))", "by(simp add: expand_finfun_eq fun_eq_iff finfun_All_All o_def)"], ["", "instantiation finfun :: (\"{card_UNIV,equal}\",equal) equal begin"], ["", "definition eq_finfun_def [code]: \"HOL.equal f g \\<longleftrightarrow> finfun_All ((\\<lambda>(x, y). x = y) \\<circ>$ ($f, g$))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, equal_class)", "by(intro_classes)(simp add: eq_finfun_All_ext eq_finfun_def)"], ["", "end"], ["", "lemma [code nbe]:\n  \"HOL.equal (f :: _ \\<Rightarrow>f _) f \\<longleftrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal f f = True", "by (fact equal_refl)"], ["", "subsection \\<open>An operator that explicitly removes all redundant updates in the generated representations\\<close>"], ["", "definition finfun_clearjunk :: \"'a \\<Rightarrow>f 'b \\<Rightarrow> 'a \\<Rightarrow>f 'b\"\nwhere [simp, code del]: \"finfun_clearjunk = id\""], ["", "lemma finfun_clearjunk_const [code]: \"finfun_clearjunk (K$ b) = (K$ b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_clearjunk (K$ b) = (K$ b)", "by simp"], ["", "lemma finfun_clearjunk_update [code]: \n  \"finfun_clearjunk (finfun_update_code f a b) = f(a $:= b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_clearjunk (finfun_update_code f a b) = f(a $:= b)", "by simp"], ["", "subsection \\<open>The domain of a FinFun as a FinFun\\<close>"], ["", "definition finfun_dom :: \"('a \\<Rightarrow>f 'b) \\<Rightarrow> ('a \\<Rightarrow>f bool)\"\nwhere [code del]: \"finfun_dom f = Abs_finfun (\\<lambda>a. f $ a \\<noteq> finfun_default f)\""], ["", "lemma finfun_dom_const:\n  \"finfun_dom ((K$ c) :: 'a \\<Rightarrow>f 'b) = (K$ finite (UNIV :: 'a set) \\<and> c \\<noteq> undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_dom (K$ c) = (K$ finite UNIV \\<and> c \\<noteq> undefined)", "unfolding finfun_dom_def finfun_default_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_finfun\n     (\\<lambda>a.\n         (K$ c) $ a \\<noteq> (if finite UNIV then undefined else c)) =\n    (K$ finite UNIV \\<and> c \\<noteq> undefined)", "by(auto)(simp_all add: finfun_const_def)"], ["", "text \\<open>\n  @{term \"finfun_dom\" } raises an exception when called on a FinFun whose domain is a finite type. \n  For such FinFuns, the default value (and as such the domain) is undefined.\n\\<close>"], ["", "lemma finfun_dom_const_code [code]:\n  \"finfun_dom ((K$ c) :: ('a :: card_UNIV) \\<Rightarrow>f 'b) = \n   (if CARD('a) = 0 then (K$ False) else Code.abort (STR ''finfun_dom called on finite type'') (\\<lambda>_. finfun_dom (K$ c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_dom (K$ c) =\n    (if CARD('a) = 0 then K$ False\n     else Code.abort STR ''finfun_dom called on finite type''\n           (\\<lambda>_. finfun_dom (K$ c)))", "by(simp add: finfun_dom_const card_UNIV card_eq_0_iff)"], ["", "lemma finfun_dom_finfunI: \"(\\<lambda>a. f $ a \\<noteq> finfun_default f) \\<in> finfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. f $ a \\<noteq> finfun_default f) \\<in> finfun", "using finite_finfun_default[of f]"], ["proof (prove)\nusing this:\n  finite {a. f $ a \\<noteq> finfun_default f}\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. f $ a \\<noteq> finfun_default f) \\<in> finfun", "by(simp add: finfun_def exI[where x=False])"], ["", "lemma finfun_dom_update [simp]:\n  \"finfun_dom (f(a $:= b)) = (finfun_dom f)(a $:= (b \\<noteq> finfun_default f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_dom f(a $:= b) =\n    (finfun_dom f)(a $:= b \\<noteq> finfun_default f)", "including finfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_dom f(a $:= b) =\n    (finfun_dom f)(a $:= b \\<noteq> finfun_default f)", "unfolding finfun_dom_def finfun_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_finfun\n     (\\<lambda>aa.\n         map_fun ($) (map_fun id (map_fun id Abs_finfun)) fun_upd f a b $\n         aa \\<noteq>\n         finfun_default\n          (map_fun ($) (map_fun id (map_fun id Abs_finfun)) fun_upd f a\n            b)) =\n    map_fun ($) (map_fun id (map_fun id Abs_finfun)) fun_upd\n     (Abs_finfun (\\<lambda>a. f $ a \\<noteq> finfun_default f)) a\n     (b \\<noteq> finfun_default f)", "apply(simp add: finfun_default_update_const finfun_dom_finfunI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_finfun\n     (\\<lambda>aa.\n         (aa = a \\<longrightarrow>\n          b \\<noteq> finfun_default (Abs_finfun ((($) f)(a := b)))) \\<and>\n         (aa \\<noteq> a \\<longrightarrow>\n          f $ aa \\<noteq> finfun_default (Abs_finfun ((($) f)(a := b))))) =\n    Abs_finfun\n     ((\\<lambda>a. f $ a \\<noteq> finfun_default f)\n      (a := b \\<noteq> finfun_default f))", "apply(fold finfun_update.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_finfun\n     (\\<lambda>aa.\n         (aa = a \\<longrightarrow>\n          b \\<noteq> finfun_default (Abs_finfun (($) f(a $:= b)))) \\<and>\n         (aa \\<noteq> a \\<longrightarrow>\n          f $ aa \\<noteq> finfun_default (Abs_finfun (($) f(a $:= b))))) =\n    Abs_finfun\n     ((\\<lambda>a. f $ a \\<noteq> finfun_default f)\n      (a := b \\<noteq> finfun_default f))", "apply(simp add: finfun_upd_apply fun_eq_iff fun_upd_def finfun_default_update_const)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finfun_dom_update_code [code]:\n  \"finfun_dom (finfun_update_code f a b) = finfun_update_code (finfun_dom f) a (b \\<noteq> finfun_default f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_dom (finfun_update_code f a b) =\n    finfun_update_code (finfun_dom f) a (b \\<noteq> finfun_default f)", "by(simp)"], ["", "lemma finite_finfun_dom: \"finite {x. finfun_dom f $ x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. finfun_dom f $ x}", "proof(induct f rule: finfun_weak_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b. finite {x. finfun_dom (K$ b) $ x}\n 2. \\<And>f a b.\n       finite {x. finfun_dom f $ x} \\<Longrightarrow>\n       finite {x. finfun_dom f(a $:= b) $ x}", "case (const b)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>b. finite {x. finfun_dom (K$ b) $ x}\n 2. \\<And>f a b.\n       finite {x. finfun_dom f $ x} \\<Longrightarrow>\n       finite {x. finfun_dom f(a $:= b) $ x}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. finfun_dom (K$ b) $ x}", "by (cases \"finite (UNIV :: 'a set) \\<and> b \\<noteq> undefined\")\n      (auto simp add: finfun_dom_const UNIV_def [symmetric] Set.empty_def [symmetric])"], ["proof (state)\nthis:\n  finite {x. finfun_dom (K$ b) $ x}\n\ngoal (1 subgoal):\n 1. \\<And>f a b.\n       finite {x. finfun_dom f $ x} \\<Longrightarrow>\n       finite {x. finfun_dom f(a $:= b) $ x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a b.\n       finite {x. finfun_dom f $ x} \\<Longrightarrow>\n       finite {x. finfun_dom f(a $:= b) $ x}", "case (update f a b)"], ["proof (state)\nthis:\n  finite {x. finfun_dom f $ x}\n\ngoal (1 subgoal):\n 1. \\<And>f a b.\n       finite {x. finfun_dom f $ x} \\<Longrightarrow>\n       finite {x. finfun_dom f(a $:= b) $ x}", "have \"{x. finfun_dom f(a $:= b) $ x} =\n    (if b = finfun_default f then {x. finfun_dom f $ x} - {a} else insert a {x. finfun_dom f $ x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. finfun_dom f(a $:= b) $ x} =\n    (if b = finfun_default f then {x. finfun_dom f $ x} - {a}\n     else insert a {x. finfun_dom f $ x})", "by (auto simp add: finfun_upd_apply split: if_split_asm)"], ["proof (state)\nthis:\n  {x. finfun_dom f(a $:= b) $ x} =\n  (if b = finfun_default f then {x. finfun_dom f $ x} - {a}\n   else insert a {x. finfun_dom f $ x})\n\ngoal (1 subgoal):\n 1. \\<And>f a b.\n       finite {x. finfun_dom f $ x} \\<Longrightarrow>\n       finite {x. finfun_dom f(a $:= b) $ x}", "thus ?case"], ["proof (prove)\nusing this:\n  {x. finfun_dom f(a $:= b) $ x} =\n  (if b = finfun_default f then {x. finfun_dom f $ x} - {a}\n   else insert a {x. finfun_dom f $ x})\n\ngoal (1 subgoal):\n 1. finite {x. finfun_dom f(a $:= b) $ x}", "using update"], ["proof (prove)\nusing this:\n  {x. finfun_dom f(a $:= b) $ x} =\n  (if b = finfun_default f then {x. finfun_dom f $ x} - {a}\n   else insert a {x. finfun_dom f $ x})\n  finite {x. finfun_dom f $ x}\n\ngoal (1 subgoal):\n 1. finite {x. finfun_dom f(a $:= b) $ x}", "by simp"], ["proof (state)\nthis:\n  finite {x. finfun_dom f(a $:= b) $ x}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The domain of a FinFun as a sorted list\\<close>"], ["", "definition finfun_to_list :: \"('a :: linorder) \\<Rightarrow>f 'b \\<Rightarrow> 'a list\"\nwhere\n  \"finfun_to_list f = (THE xs. set xs = {x. finfun_dom f $ x} \\<and> sorted xs \\<and> distinct xs)\""], ["", "lemma set_finfun_to_list [simp]: \"set (finfun_to_list f) = {x. finfun_dom f $ x}\" (is ?thesis1)\n  and sorted_finfun_to_list: \"sorted (finfun_to_list f)\" (is ?thesis2)\n  and distinct_finfun_to_list: \"distinct (finfun_to_list f)\" (is ?thesis3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (finfun_to_list f) = {x. finfun_dom f $ x} &&&\n    sorted (finfun_to_list f) &&& distinct (finfun_to_list f)", "proof (atomize (full))"], ["proof (state)\ngoal (1 subgoal):\n 1. set (finfun_to_list f) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (finfun_to_list f) \\<and> distinct (finfun_to_list f)", "show \"?thesis1 \\<and> ?thesis2 \\<and> ?thesis3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (finfun_to_list f) = {x. finfun_dom f $ x} \\<and>\n    sorted (finfun_to_list f) \\<and> distinct (finfun_to_list f)", "unfolding finfun_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (THE xs.\n            set xs = Collect (($) (finfun_dom f)) \\<and>\n            sorted xs \\<and> distinct xs) =\n    {x. finfun_dom f $ x} \\<and>\n    sorted\n     (THE xs.\n         set xs = Collect (($) (finfun_dom f)) \\<and>\n         sorted xs \\<and> distinct xs) \\<and>\n    distinct\n     (THE xs.\n         set xs = Collect (($) (finfun_dom f)) \\<and>\n         sorted xs \\<and> distinct xs)", "by(rule theI')(rule finite_sorted_distinct_unique finite_finfun_dom)+"], ["proof (state)\nthis:\n  set (finfun_to_list f) = {x. finfun_dom f $ x} \\<and>\n  sorted (finfun_to_list f) \\<and> distinct (finfun_to_list f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finfun_const_False_conv_bot: \"($) (K$ False) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (K$ False) = bot", "by auto"], ["", "lemma finfun_const_True_conv_top: \"($) (K$ True) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (K$ True) = top", "by auto"], ["", "lemma finfun_to_list_const:\n  \"finfun_to_list ((K$ c) :: ('a :: {linorder} \\<Rightarrow>f 'b)) = \n  (if \\<not> finite (UNIV :: 'a set) \\<or> c = undefined then [] else THE xs. set xs = UNIV \\<and> sorted xs \\<and> distinct xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_to_list (K$ c) =\n    (if infinite UNIV \\<or> c = undefined then []\n     else THE xs. set xs = UNIV \\<and> sorted xs \\<and> distinct xs)", "by(auto simp add: finfun_to_list_def finfun_const_False_conv_bot finfun_const_True_conv_top finfun_dom_const)"], ["", "lemma finfun_to_list_const_code [code]:\n  \"finfun_to_list ((K$ c) :: ('a :: {linorder, card_UNIV} \\<Rightarrow>f 'b)) =\n   (if CARD('a) = 0 then [] else Code.abort (STR ''finfun_to_list called on finite type'') (\\<lambda>_. finfun_to_list ((K$ c) :: ('a \\<Rightarrow>f 'b))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_to_list (K$ c) =\n    (if CARD('a) = 0 then []\n     else Code.abort STR ''finfun_to_list called on finite type''\n           (\\<lambda>_. finfun_to_list (K$ c)))", "by(auto simp add: finfun_to_list_const card_UNIV card_eq_0_iff)"], ["", "lemma remove1_insort_insert_same:\n  \"x \\<notin> set xs \\<Longrightarrow> remove1 x (insort_insert x xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> remove1 x (insort_insert x xs) = xs", "by (metis insort_insert_insort remove1_insort)"], ["", "lemma finfun_dom_conv:\n  \"finfun_dom f $ x \\<longleftrightarrow> f $ x \\<noteq> finfun_default f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_dom f $ x = (f $ x \\<noteq> finfun_default f)", "by(induct f rule: finfun_weak_induct)(auto simp add: finfun_dom_const finfun_default_const finfun_default_update_const finfun_upd_apply)"], ["", "lemma finfun_to_list_update:\n  \"finfun_to_list (f(a $:= b)) = \n  (if b = finfun_default f then List.remove1 a (finfun_to_list f) else List.insort_insert a (finfun_to_list f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_to_list f(a $:= b) =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "proof(subst finfun_to_list_def, rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (if b = finfun_default f then remove1 a (finfun_to_list f)\n         else insort_insert a (finfun_to_list f)) =\n    Collect (($) (finfun_dom f(a $:= b))) \\<and>\n    sorted\n     (if b = finfun_default f then remove1 a (finfun_to_list f)\n      else insort_insert a (finfun_to_list f)) \\<and>\n    distinct\n     (if b = finfun_default f then remove1 a (finfun_to_list f)\n      else insort_insert a (finfun_to_list f))\n 2. \\<And>xs.\n       set xs = Collect (($) (finfun_dom f(a $:= b))) \\<and>\n       sorted xs \\<and> distinct xs \\<Longrightarrow>\n       xs =\n       (if b = finfun_default f then remove1 a (finfun_to_list f)\n        else insort_insert a (finfun_to_list f))", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. set (if b = finfun_default f then remove1 a (finfun_to_list f)\n         else insort_insert a (finfun_to_list f)) =\n    Collect (($) (finfun_dom f(a $:= b))) \\<and>\n    sorted\n     (if b = finfun_default f then remove1 a (finfun_to_list f)\n      else insort_insert a (finfun_to_list f)) \\<and>\n    distinct\n     (if b = finfun_default f then remove1 a (finfun_to_list f)\n      else insort_insert a (finfun_to_list f))\n 2. \\<And>xs.\n       set xs = Collect (($) (finfun_dom f(a $:= b))) \\<and>\n       sorted xs \\<and> distinct xs \\<Longrightarrow>\n       xs =\n       (if b = finfun_default f then remove1 a (finfun_to_list f)\n        else insort_insert a (finfun_to_list f))", "assume \"set xs = {x. finfun_dom f(a $:= b) $ x} \\<and> sorted xs \\<and> distinct xs\""], ["proof (state)\nthis:\n  set xs = {x. finfun_dom f(a $:= b) $ x} \\<and>\n  sorted xs \\<and> distinct xs\n\ngoal (2 subgoals):\n 1. set (if b = finfun_default f then remove1 a (finfun_to_list f)\n         else insort_insert a (finfun_to_list f)) =\n    Collect (($) (finfun_dom f(a $:= b))) \\<and>\n    sorted\n     (if b = finfun_default f then remove1 a (finfun_to_list f)\n      else insort_insert a (finfun_to_list f)) \\<and>\n    distinct\n     (if b = finfun_default f then remove1 a (finfun_to_list f)\n      else insort_insert a (finfun_to_list f))\n 2. \\<And>xs.\n       set xs = Collect (($) (finfun_dom f(a $:= b))) \\<and>\n       sorted xs \\<and> distinct xs \\<Longrightarrow>\n       xs =\n       (if b = finfun_default f then remove1 a (finfun_to_list f)\n        else insort_insert a (finfun_to_list f))", "hence eq: \"set xs = {x. finfun_dom f(a $:= b) $ x}\"\n    and [simp]: \"sorted xs\" \"distinct xs\""], ["proof (prove)\nusing this:\n  set xs = {x. finfun_dom f(a $:= b) $ x} \\<and>\n  sorted xs \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. set xs = {x. finfun_dom f(a $:= b) $ x} &&& sorted xs &&& distinct xs", "by simp_all"], ["proof (state)\nthis:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n  sorted xs\n  distinct xs\n\ngoal (2 subgoals):\n 1. set (if b = finfun_default f then remove1 a (finfun_to_list f)\n         else insort_insert a (finfun_to_list f)) =\n    Collect (($) (finfun_dom f(a $:= b))) \\<and>\n    sorted\n     (if b = finfun_default f then remove1 a (finfun_to_list f)\n      else insort_insert a (finfun_to_list f)) \\<and>\n    distinct\n     (if b = finfun_default f then remove1 a (finfun_to_list f)\n      else insort_insert a (finfun_to_list f))\n 2. \\<And>xs.\n       set xs = Collect (($) (finfun_dom f(a $:= b))) \\<and>\n       sorted xs \\<and> distinct xs \\<Longrightarrow>\n       xs =\n       (if b = finfun_default f then remove1 a (finfun_to_list f)\n        else insort_insert a (finfun_to_list f))", "show \"xs = (if b = finfun_default f then remove1 a (finfun_to_list f) else insort_insert a (finfun_to_list f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "proof(cases \"b = finfun_default f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = finfun_default f \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))\n 2. b \\<noteq> finfun_default f \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "case [simp]: True"], ["proof (state)\nthis:\n  b = finfun_default f\n\ngoal (2 subgoals):\n 1. b = finfun_default f \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))\n 2. b \\<noteq> finfun_default f \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "proof(cases \"finfun_dom f $ a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))\n 2. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "case True"], ["proof (state)\nthis:\n  finfun_dom f $ a\n\ngoal (2 subgoals):\n 1. finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))\n 2. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "have \"finfun_to_list f = insort_insert a xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_to_list f = insort_insert a xs", "unfolding finfun_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE xs.\n        set xs = Collect (($) (finfun_dom f)) \\<and>\n        sorted xs \\<and> distinct xs) =\n    insort_insert a xs", "proof(rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (insort_insert a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (insort_insert a xs) \\<and> distinct (insort_insert a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = insort_insert a xs", "have \"set (insort_insert a xs) = insert a (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insort_insert a xs) = insert a (set xs)", "by(simp add: set_insort_insert)"], ["proof (state)\nthis:\n  set (insort_insert a xs) = insert a (set xs)\n\ngoal (2 subgoals):\n 1. set (insort_insert a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (insort_insert a xs) \\<and> distinct (insort_insert a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = insort_insert a xs", "also"], ["proof (state)\nthis:\n  set (insort_insert a xs) = insert a (set xs)\n\ngoal (2 subgoals):\n 1. set (insort_insert a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (insort_insert a xs) \\<and> distinct (insort_insert a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = insort_insert a xs", "note eq"], ["proof (state)\nthis:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n\ngoal (2 subgoals):\n 1. set (insort_insert a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (insort_insert a xs) \\<and> distinct (insort_insert a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = insort_insert a xs", "also"], ["proof (state)\nthis:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n\ngoal (2 subgoals):\n 1. set (insort_insert a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (insort_insert a xs) \\<and> distinct (insort_insert a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = insort_insert a xs", "have \"insert a {x. finfun_dom f(a $:= b) $ x} = {x. finfun_dom f $ x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert a {x. finfun_dom f(a $:= b) $ x} = {x. finfun_dom f $ x}", "using True"], ["proof (prove)\nusing this:\n  finfun_dom f $ a\n\ngoal (1 subgoal):\n 1. insert a {x. finfun_dom f(a $:= b) $ x} = {x. finfun_dom f $ x}", "by(auto simp add: finfun_upd_apply split: if_split_asm)"], ["proof (state)\nthis:\n  insert a {x. finfun_dom f(a $:= b) $ x} = {x. finfun_dom f $ x}\n\ngoal (2 subgoals):\n 1. set (insort_insert a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (insort_insert a xs) \\<and> distinct (insort_insert a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = insort_insert a xs", "finally"], ["proof (chain)\npicking this:\n  set (insort_insert a xs) = {x. finfun_dom f $ x}", "show 1: \"set (insort_insert a xs) = {x. finfun_dom f $ x} \\<and> sorted (insort_insert a xs) \\<and> distinct (insort_insert a xs)\""], ["proof (prove)\nusing this:\n  set (insort_insert a xs) = {x. finfun_dom f $ x}\n\ngoal (1 subgoal):\n 1. set (insort_insert a xs) = {x. finfun_dom f $ x} \\<and>\n    sorted (insort_insert a xs) \\<and> distinct (insort_insert a xs)", "by(simp add: sorted_insort_insert distinct_insort_insert)"], ["proof (state)\nthis:\n  set (insort_insert a xs) = {x. finfun_dom f $ x} \\<and>\n  sorted (insort_insert a xs) \\<and> distinct (insort_insert a xs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = insort_insert a xs", "fix xs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = insort_insert a xs", "assume \"set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\""], ["proof (state)\nthis:\n  set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\n\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = insort_insert a xs", "thus \"xs' = insort_insert a xs\""], ["proof (prove)\nusing this:\n  set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\n\ngoal (1 subgoal):\n 1. xs' = insort_insert a xs", "using 1"], ["proof (prove)\nusing this:\n  set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\n  set (insort_insert a xs) = {x. finfun_dom f $ x} \\<and>\n  sorted (insort_insert a xs) \\<and> distinct (insort_insert a xs)\n\ngoal (1 subgoal):\n 1. xs' = insort_insert a xs", "by(auto dest: sorted_distinct_set_unique)"], ["proof (state)\nthis:\n  xs' = insort_insert a xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finfun_to_list f = insort_insert a xs\n\ngoal (2 subgoals):\n 1. finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))\n 2. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "with eq True"], ["proof (chain)\npicking this:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n  finfun_dom f $ a\n  finfun_to_list f = insort_insert a xs", "show ?thesis"], ["proof (prove)\nusing this:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n  finfun_dom f $ a\n  finfun_to_list f = insort_insert a xs\n\ngoal (1 subgoal):\n 1. xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "by(simp add: remove1_insort_insert_same)"], ["proof (state)\nthis:\n  xs =\n  (if b = finfun_default f then remove1 a (finfun_to_list f)\n   else insort_insert a (finfun_to_list f))\n\ngoal (1 subgoal):\n 1. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "case False"], ["proof (state)\nthis:\n  \\<not> finfun_dom f $ a\n\ngoal (1 subgoal):\n 1. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "hence \"f $ a = b\""], ["proof (prove)\nusing this:\n  \\<not> finfun_dom f $ a\n\ngoal (1 subgoal):\n 1. f $ a = b", "by(auto simp add: finfun_dom_conv)"], ["proof (state)\nthis:\n  f $ a = b\n\ngoal (1 subgoal):\n 1. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "hence f: \"f(a $:= b) = f\""], ["proof (prove)\nusing this:\n  f $ a = b\n\ngoal (1 subgoal):\n 1. f(a $:= b) = f", "by(simp add: expand_finfun_eq fun_eq_iff finfun_upd_apply)"], ["proof (state)\nthis:\n  f(a $:= b) = f\n\ngoal (1 subgoal):\n 1. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "from eq"], ["proof (chain)\npicking this:\n  set xs = {x. finfun_dom f(a $:= b) $ x}", "have \"finfun_to_list f = xs\""], ["proof (prove)\nusing this:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n\ngoal (1 subgoal):\n 1. finfun_to_list f = xs", "unfolding f finfun_to_list_def"], ["proof (prove)\nusing this:\n  set xs = {x. finfun_dom f $ x}\n\ngoal (1 subgoal):\n 1. (THE xs.\n        set xs = Collect (($) (finfun_dom f)) \\<and>\n        sorted xs \\<and> distinct xs) =\n    xs", "by(auto elim: sorted_distinct_set_unique intro!: the_equality)"], ["proof (state)\nthis:\n  finfun_to_list f = xs\n\ngoal (1 subgoal):\n 1. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "with eq False"], ["proof (chain)\npicking this:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n  \\<not> finfun_dom f $ a\n  finfun_to_list f = xs", "show ?thesis"], ["proof (prove)\nusing this:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n  \\<not> finfun_dom f $ a\n  finfun_to_list f = xs\n\ngoal (1 subgoal):\n 1. xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "unfolding f"], ["proof (prove)\nusing this:\n  set xs = {x. finfun_dom f $ x}\n  \\<not> finfun_dom f $ a\n  finfun_to_list f = xs\n\ngoal (1 subgoal):\n 1. xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "by(simp add: remove1_idem)"], ["proof (state)\nthis:\n  xs =\n  (if b = finfun_default f then remove1 a (finfun_to_list f)\n   else insort_insert a (finfun_to_list f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs =\n  (if b = finfun_default f then remove1 a (finfun_to_list f)\n   else insort_insert a (finfun_to_list f))\n\ngoal (1 subgoal):\n 1. b \\<noteq> finfun_default f \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> finfun_default f \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "case False"], ["proof (state)\nthis:\n  b \\<noteq> finfun_default f\n\ngoal (1 subgoal):\n 1. b \\<noteq> finfun_default f \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "proof(cases \"finfun_dom f $ a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))\n 2. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "case True"], ["proof (state)\nthis:\n  finfun_dom f $ a\n\ngoal (2 subgoals):\n 1. finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))\n 2. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "have \"finfun_to_list f = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_to_list f = xs", "unfolding finfun_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE xs.\n        set xs = Collect (($) (finfun_dom f)) \\<and>\n        sorted xs \\<and> distinct xs) =\n    xs", "proof(rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. set xs = Collect (($) (finfun_dom f)) \\<and>\n    sorted xs \\<and> distinct xs\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = xs", "have \"finfun_dom f = finfun_dom f(a $:= b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_dom f = finfun_dom f(a $:= b)", "using False True"], ["proof (prove)\nusing this:\n  b \\<noteq> finfun_default f\n  finfun_dom f $ a\n\ngoal (1 subgoal):\n 1. finfun_dom f = finfun_dom f(a $:= b)", "by(simp add: expand_finfun_eq fun_eq_iff finfun_upd_apply)"], ["proof (state)\nthis:\n  finfun_dom f = finfun_dom f(a $:= b)\n\ngoal (2 subgoals):\n 1. set xs = Collect (($) (finfun_dom f)) \\<and>\n    sorted xs \\<and> distinct xs\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = xs", "with eq"], ["proof (chain)\npicking this:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n  finfun_dom f = finfun_dom f(a $:= b)", "show 1: \"set xs = {x. finfun_dom f $ x} \\<and> sorted xs \\<and> distinct xs\""], ["proof (prove)\nusing this:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n  finfun_dom f = finfun_dom f(a $:= b)\n\ngoal (1 subgoal):\n 1. set xs = {x. finfun_dom f $ x} \\<and> sorted xs \\<and> distinct xs", "by(simp del: finfun_dom_update)"], ["proof (state)\nthis:\n  set xs = {x. finfun_dom f $ x} \\<and> sorted xs \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = xs", "fix xs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = xs", "assume \"set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\""], ["proof (state)\nthis:\n  set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\n\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = xs", "thus \"xs' = xs\""], ["proof (prove)\nusing this:\n  set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\n\ngoal (1 subgoal):\n 1. xs' = xs", "using 1"], ["proof (prove)\nusing this:\n  set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\n  set xs = {x. finfun_dom f $ x} \\<and> sorted xs \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. xs' = xs", "by(auto elim: sorted_distinct_set_unique)"], ["proof (state)\nthis:\n  xs' = xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finfun_to_list f = xs\n\ngoal (2 subgoals):\n 1. finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))\n 2. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finfun_to_list f = xs\n\ngoal (1 subgoal):\n 1. xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "using False True eq"], ["proof (prove)\nusing this:\n  finfun_to_list f = xs\n  b \\<noteq> finfun_default f\n  finfun_dom f $ a\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n\ngoal (1 subgoal):\n 1. xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "by(simp add: insort_insert_triv)"], ["proof (state)\nthis:\n  xs =\n  (if b = finfun_default f then remove1 a (finfun_to_list f)\n   else insort_insert a (finfun_to_list f))\n\ngoal (1 subgoal):\n 1. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "case False"], ["proof (state)\nthis:\n  \\<not> finfun_dom f $ a\n\ngoal (1 subgoal):\n 1. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "have \"finfun_to_list f = remove1 a xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_to_list f = remove1 a xs", "unfolding finfun_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE xs.\n        set xs = Collect (($) (finfun_dom f)) \\<and>\n        sorted xs \\<and> distinct xs) =\n    remove1 a xs", "proof(rule the_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (remove1 a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (remove1 a xs) \\<and> distinct (remove1 a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = remove1 a xs", "have \"set (remove1 a xs) = set xs - {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remove1 a xs) = set xs - {a}", "by simp"], ["proof (state)\nthis:\n  set (remove1 a xs) = set xs - {a}\n\ngoal (2 subgoals):\n 1. set (remove1 a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (remove1 a xs) \\<and> distinct (remove1 a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = remove1 a xs", "also"], ["proof (state)\nthis:\n  set (remove1 a xs) = set xs - {a}\n\ngoal (2 subgoals):\n 1. set (remove1 a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (remove1 a xs) \\<and> distinct (remove1 a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = remove1 a xs", "note eq"], ["proof (state)\nthis:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n\ngoal (2 subgoals):\n 1. set (remove1 a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (remove1 a xs) \\<and> distinct (remove1 a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = remove1 a xs", "also"], ["proof (state)\nthis:\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n\ngoal (2 subgoals):\n 1. set (remove1 a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (remove1 a xs) \\<and> distinct (remove1 a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = remove1 a xs", "have \"{x. finfun_dom f(a $:= b) $ x} - {a} = {x. finfun_dom f $ x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. finfun_dom f(a $:= b) $ x} - {a} = {x. finfun_dom f $ x}", "using False"], ["proof (prove)\nusing this:\n  \\<not> finfun_dom f $ a\n\ngoal (1 subgoal):\n 1. {x. finfun_dom f(a $:= b) $ x} - {a} = {x. finfun_dom f $ x}", "by(auto simp add: finfun_upd_apply split: if_split_asm)"], ["proof (state)\nthis:\n  {x. finfun_dom f(a $:= b) $ x} - {a} = {x. finfun_dom f $ x}\n\ngoal (2 subgoals):\n 1. set (remove1 a xs) = Collect (($) (finfun_dom f)) \\<and>\n    sorted (remove1 a xs) \\<and> distinct (remove1 a xs)\n 2. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = remove1 a xs", "finally"], ["proof (chain)\npicking this:\n  set (remove1 a xs) = {x. finfun_dom f $ x}", "show 1: \"set (remove1 a xs) = {x. finfun_dom f $ x} \\<and> sorted (remove1 a xs) \\<and> distinct (remove1 a xs)\""], ["proof (prove)\nusing this:\n  set (remove1 a xs) = {x. finfun_dom f $ x}\n\ngoal (1 subgoal):\n 1. set (remove1 a xs) = {x. finfun_dom f $ x} \\<and>\n    sorted (remove1 a xs) \\<and> distinct (remove1 a xs)", "by(simp add: sorted_remove1)"], ["proof (state)\nthis:\n  set (remove1 a xs) = {x. finfun_dom f $ x} \\<and>\n  sorted (remove1 a xs) \\<and> distinct (remove1 a xs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = remove1 a xs", "fix xs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = remove1 a xs", "assume \"set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\""], ["proof (state)\nthis:\n  set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\n\ngoal (1 subgoal):\n 1. \\<And>xsa.\n       set xsa = Collect (($) (finfun_dom f)) \\<and>\n       sorted xsa \\<and> distinct xsa \\<Longrightarrow>\n       xsa = remove1 a xs", "thus \"xs' = remove1 a xs\""], ["proof (prove)\nusing this:\n  set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\n\ngoal (1 subgoal):\n 1. xs' = remove1 a xs", "using 1"], ["proof (prove)\nusing this:\n  set xs' = {x. finfun_dom f $ x} \\<and> sorted xs' \\<and> distinct xs'\n  set (remove1 a xs) = {x. finfun_dom f $ x} \\<and>\n  sorted (remove1 a xs) \\<and> distinct (remove1 a xs)\n\ngoal (1 subgoal):\n 1. xs' = remove1 a xs", "by(blast intro: sorted_distinct_set_unique)"], ["proof (state)\nthis:\n  xs' = remove1 a xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finfun_to_list f = remove1 a xs\n\ngoal (1 subgoal):\n 1. \\<not> finfun_dom f $ a \\<Longrightarrow>\n    xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finfun_to_list f = remove1 a xs\n\ngoal (1 subgoal):\n 1. xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "using False eq \\<open>b \\<noteq> finfun_default f\\<close>"], ["proof (prove)\nusing this:\n  finfun_to_list f = remove1 a xs\n  \\<not> finfun_dom f $ a\n  set xs = {x. finfun_dom f(a $:= b) $ x}\n  b \\<noteq> finfun_default f\n\ngoal (1 subgoal):\n 1. xs =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "by (simp add: insort_insert_insort insort_remove1)"], ["proof (state)\nthis:\n  xs =\n  (if b = finfun_default f then remove1 a (finfun_to_list f)\n   else insort_insert a (finfun_to_list f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs =\n  (if b = finfun_default f then remove1 a (finfun_to_list f)\n   else insort_insert a (finfun_to_list f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs =\n  (if b = finfun_default f then remove1 a (finfun_to_list f)\n   else insort_insert a (finfun_to_list f))\n\ngoal (1 subgoal):\n 1. set (if b = finfun_default f then remove1 a (finfun_to_list f)\n         else insort_insert a (finfun_to_list f)) =\n    Collect (($) (finfun_dom f(a $:= b))) \\<and>\n    sorted\n     (if b = finfun_default f then remove1 a (finfun_to_list f)\n      else insort_insert a (finfun_to_list f)) \\<and>\n    distinct\n     (if b = finfun_default f then remove1 a (finfun_to_list f)\n      else insort_insert a (finfun_to_list f))", "qed (auto simp add: distinct_finfun_to_list sorted_finfun_to_list sorted_remove1 set_insort_insert sorted_insort_insert distinct_insort_insert finfun_upd_apply split: if_split_asm)"], ["", "lemma finfun_to_list_update_code [code]:\n  \"finfun_to_list (finfun_update_code f a b) = \n  (if b = finfun_default f then List.remove1 a (finfun_to_list f) else List.insort_insert a (finfun_to_list f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finfun_to_list (finfun_update_code f a b) =\n    (if b = finfun_default f then remove1 a (finfun_to_list f)\n     else insort_insert a (finfun_to_list f))", "by(simp add: finfun_to_list_update)"], ["", "text \\<open>More type class instantiations\\<close>"], ["", "lemma card_eq_1_iff: \"card A = 1 \\<longleftrightarrow> A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (card A = 1) =\n    (A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "assume ?lhs"], ["proof (state)\nthis:\n  card A = 1\n\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "moreover"], ["proof (state)\nthis:\n  card A = 1\n\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "{"], ["proof (state)\nthis:\n  card A = 1\n\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "assume A: \"x \\<in> A\" \"y \\<in> A\" and neq: \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "have \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "using \\<open>?lhs\\<close>"], ["proof (prove)\nusing this:\n  card A = 1\n\ngoal (1 subgoal):\n 1. finite A", "by(simp add: card_ge_0_finite)"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "from neq"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have \"2 = card {x, y}\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 2 = card {x, y}", "by simp"], ["proof (state)\nthis:\n  2 = card {x, y}\n\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "also"], ["proof (state)\nthis:\n  2 = card {x, y}\n\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "have \"\\<dots> \\<le> card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x, y} \\<le> card A", "using A \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  finite A\n\ngoal (1 subgoal):\n 1. card {x, y} \\<le> card A", "by(auto intro: card_mono)"], ["proof (state)\nthis:\n  card {x, y} \\<le> card A\n\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "finally"], ["proof (chain)\npicking this:\n  2 \\<le> card A", "have False"], ["proof (prove)\nusing this:\n  2 \\<le> card A\n\ngoal (1 subgoal):\n 1. False", "using \\<open>?lhs\\<close>"], ["proof (prove)\nusing this:\n  2 \\<le> card A\n  card A = 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> A; ?y2 \\<in> A; ?x2 \\<noteq> ?y2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. card A = 1 \\<Longrightarrow>\n    A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n 2. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "ultimately"], ["proof (chain)\npicking this:\n  card A = 1\n  \\<lbrakk>?x2 \\<in> A; ?y2 \\<in> A; ?x2 \\<noteq> ?y2\\<rbrakk>\n  \\<Longrightarrow> False", "show ?rhs"], ["proof (prove)\nusing this:\n  card A = 1\n  \\<lbrakk>?x2 \\<in> A; ?y2 \\<in> A; ?x2 \\<noteq> ?y2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)", "by auto"], ["proof (state)\nthis:\n  A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "assume ?rhs"], ["proof (state)\nthis:\n  A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "hence \"A = {THE x. x \\<in> A}\""], ["proof (prove)\nusing this:\n  A \\<noteq> {} \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y)\n\ngoal (1 subgoal):\n 1. A = {THE x. x \\<in> A}", "by safe (auto intro: theI the_equality[symmetric])"], ["proof (state)\nthis:\n  A = {THE x. x \\<in> A}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "also"], ["proof (state)\nthis:\n  A = {THE x. x \\<in> A}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "have \"card \\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {THE x. x \\<in> A} = 1", "by simp"], ["proof (state)\nthis:\n  card {THE x. x \\<in> A} = 1\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x = y) \\<Longrightarrow>\n    card A = 1", "finally"], ["proof (chain)\npicking this:\n  card A = 1", "show ?lhs"], ["proof (prove)\nusing this:\n  card A = 1\n\ngoal (1 subgoal):\n 1. card A = 1", "."], ["proof (state)\nthis:\n  card A = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_UNIV_finfun: \n  defines \"F == finfun :: ('a \\<Rightarrow> 'b) set\"\n  shows \"CARD('a \\<Rightarrow>f 'b) = (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1 then CARD('b) ^ CARD('a) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "proof(cases \"0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1 \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)\n 2. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "case True"], ["proof (state)\nthis:\n  0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1\n\ngoal (2 subgoals):\n 1. 0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1 \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)\n 2. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "from True"], ["proof (chain)\npicking this:\n  0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1", "have \"F = UNIV\""], ["proof (prove)\nusing this:\n  0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1\n\ngoal (1 subgoal):\n 1. F = UNIV", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < CARD('a) \\<and> 0 < CARD('b) \\<Longrightarrow> F = UNIV\n 2. CARD('b) = 1 \\<Longrightarrow> F = UNIV", "assume b: \"CARD('b) = 1\""], ["proof (state)\nthis:\n  CARD('b) = 1\n\ngoal (2 subgoals):\n 1. 0 < CARD('a) \\<and> 0 < CARD('b) \\<Longrightarrow> F = UNIV\n 2. CARD('b) = 1 \\<Longrightarrow> F = UNIV", "hence \"\\<forall>x :: 'b. x = undefined\""], ["proof (prove)\nusing this:\n  CARD('b) = 1\n\ngoal (1 subgoal):\n 1. \\<forall>x. x = undefined", "by(auto simp add: card_eq_1_iff simp del: One_nat_def)"], ["proof (state)\nthis:\n  \\<forall>x. x = undefined\n\ngoal (2 subgoals):\n 1. 0 < CARD('a) \\<and> 0 < CARD('b) \\<Longrightarrow> F = UNIV\n 2. CARD('b) = 1 \\<Longrightarrow> F = UNIV", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. x = undefined\n\ngoal (1 subgoal):\n 1. F = UNIV", "by(auto simp add: finfun_def F_def intro: exI[where x=undefined])"], ["proof (state)\nthis:\n  F = UNIV\n\ngoal (1 subgoal):\n 1. 0 < CARD('a) \\<and> 0 < CARD('b) \\<Longrightarrow> F = UNIV", "qed(auto simp add: finfun_def card_gt_0_iff F_def intro: finite_subset[where B=UNIV])"], ["proof (state)\nthis:\n  F = UNIV\n\ngoal (2 subgoals):\n 1. 0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1 \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)\n 2. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "moreover"], ["proof (state)\nthis:\n  F = UNIV\n\ngoal (2 subgoals):\n 1. 0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1 \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)\n 2. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "have \"CARD('a \\<Rightarrow>f 'b) = card F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a \\<Rightarrow>f 'b) = card F", "unfolding type_definition.Abs_image[OF type_definition_finfun, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Abs_finfun ` finfun) = card F", "by(auto intro!: card_image inj_onI simp add: Abs_finfun_inject F_def)"], ["proof (state)\nthis:\n  CARD('a \\<Rightarrow>f 'b) = card F\n\ngoal (2 subgoals):\n 1. 0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1 \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)\n 2. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "ultimately"], ["proof (chain)\npicking this:\n  F = UNIV\n  CARD('a \\<Rightarrow>f 'b) = card F", "show ?thesis"], ["proof (prove)\nusing this:\n  F = UNIV\n  CARD('a \\<Rightarrow>f 'b) = card F\n\ngoal (1 subgoal):\n 1. CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "by(simp add: card_fun)"], ["proof (state)\nthis:\n  CARD('a \\<Rightarrow>f 'b) =\n  (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n   then CARD('b) ^ CARD('a) else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1)\n\ngoal (1 subgoal):\n 1. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "hence infinite: \"\\<not> (finite (UNIV :: 'a set) \\<and> finite (UNIV :: 'b set))\"\n    and b: \"CARD('b) \\<noteq> 1\""], ["proof (prove)\nusing this:\n  \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1)\n\ngoal (1 subgoal):\n 1. \\<not> (finite UNIV \\<and> finite UNIV) &&& CARD('b) \\<noteq> 1", "by(simp_all add: card_eq_0_iff)"], ["proof (state)\nthis:\n  \\<not> (finite UNIV \\<and> finite UNIV)\n  CARD('b) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "from b"], ["proof (chain)\npicking this:\n  CARD('b) \\<noteq> 1", "obtain b1 b2 :: 'b where \"b1 \\<noteq> b2\""], ["proof (prove)\nusing this:\n  CARD('b) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (\\<And>b1 b2. b1 \\<noteq> b2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: card_eq_1_iff simp del: One_nat_def)"], ["proof (state)\nthis:\n  b1 \\<noteq> b2\n\ngoal (1 subgoal):\n 1. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "let ?f = \"\\<lambda>a a' :: 'a. if a = a' then b1 else b2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "from infinite"], ["proof (chain)\npicking this:\n  \\<not> (finite UNIV \\<and> finite UNIV)", "have \"\\<not> finite (UNIV :: ('a \\<Rightarrow>f 'b) set)\""], ["proof (prove)\nusing this:\n  \\<not> (finite UNIV \\<and> finite UNIV)\n\ngoal (1 subgoal):\n 1. infinite UNIV", "proof(rule contrapos_nn[OF _ conjI])"], ["proof (state)\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow> finite UNIV\n 2. finite UNIV \\<Longrightarrow> finite UNIV", "assume finite: \"finite (UNIV :: ('a \\<Rightarrow>f 'b) set)\""], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow> finite UNIV\n 2. finite UNIV \\<Longrightarrow> finite UNIV", "hence \"finite F\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite F", "unfolding type_definition.Abs_image[OF type_definition_finfun, symmetric] F_def"], ["proof (prove)\nusing this:\n  finite (Abs_finfun ` finfun)\n\ngoal (1 subgoal):\n 1. finite finfun", "by(rule finite_imageD)(auto intro: inj_onI simp add: Abs_finfun_inject)"], ["proof (state)\nthis:\n  finite F\n\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow> finite UNIV\n 2. finite UNIV \\<Longrightarrow> finite UNIV", "hence \"finite (range ?f)\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite (range (\\<lambda>a a'. if a = a' then b1 else b2))", "by(rule finite_subset[rotated 1])(auto simp add: F_def finfun_def \\<open>b1 \\<noteq> b2\\<close> intro!: exI[where x=b2])"], ["proof (state)\nthis:\n  finite (range (\\<lambda>a a'. if a = a' then b1 else b2))\n\ngoal (2 subgoals):\n 1. finite UNIV \\<Longrightarrow> finite UNIV\n 2. finite UNIV \\<Longrightarrow> finite UNIV", "thus \"finite (UNIV :: 'a set)\""], ["proof (prove)\nusing this:\n  finite (range (\\<lambda>a a'. if a = a' then b1 else b2))\n\ngoal (1 subgoal):\n 1. finite UNIV", "by(rule finite_imageD)(auto intro: inj_onI simp add: fun_eq_iff \\<open>b1 \\<noteq> b2\\<close> split: if_split_asm)"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finite UNIV", "from finite"], ["proof (chain)\npicking this:\n  finite UNIV", "have \"finite (range (\\<lambda>b. ((K$ b) :: 'a \\<Rightarrow>f 'b)))\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite (range finfun_const)", "by(rule finite_subset[rotated 1]) simp"], ["proof (state)\nthis:\n  finite (range finfun_const)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> finite UNIV", "thus \"finite (UNIV :: 'b set)\""], ["proof (prove)\nusing this:\n  finite (range finfun_const)\n\ngoal (1 subgoal):\n 1. finite UNIV", "by(rule finite_imageD)(auto intro!: inj_onI)"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or>\n            CARD('b) = 1) \\<Longrightarrow>\n    CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "with False"], ["proof (chain)\npicking this:\n  \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1)\n  infinite UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1)\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. CARD('a \\<Rightarrow>f 'b) =\n    (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n     then CARD('b) ^ CARD('a) else 0)", "by auto"], ["proof (state)\nthis:\n  CARD('a \\<Rightarrow>f 'b) =\n  (if CARD('a) \\<noteq> 0 \\<and> CARD('b) \\<noteq> 0 \\<or> CARD('b) = 1\n   then CARD('b) ^ CARD('a) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_UNIV_finfun:\n  \"finite (UNIV :: ('a \\<Rightarrow>f 'b) set) \\<longleftrightarrow>\n  (finite (UNIV :: 'a set) \\<and> finite (UNIV :: 'b set) \\<or> CARD('b) = 1)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV = (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV = (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)", "have \"?lhs \\<longleftrightarrow> CARD('a \\<Rightarrow>f 'b) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV = (0 < CARD('a \\<Rightarrow>f 'b))", "by(simp add: card_gt_0_iff)"], ["proof (state)\nthis:\n  finite UNIV = (0 < CARD('a \\<Rightarrow>f 'b))\n\ngoal (1 subgoal):\n 1. finite UNIV = (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)", "also"], ["proof (state)\nthis:\n  finite UNIV = (0 < CARD('a \\<Rightarrow>f 'b))\n\ngoal (1 subgoal):\n 1. finite UNIV = (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)", "have \"\\<dots> \\<longleftrightarrow> CARD('a) > 0 \\<and> CARD('b) > 0 \\<or> CARD('b) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < CARD('a \\<Rightarrow>f 'b)) =\n    (0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1)", "by(simp add: card_UNIV_finfun)"], ["proof (state)\nthis:\n  (0 < CARD('a \\<Rightarrow>f 'b)) =\n  (0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1)\n\ngoal (1 subgoal):\n 1. finite UNIV = (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)", "also"], ["proof (state)\nthis:\n  (0 < CARD('a \\<Rightarrow>f 'b)) =\n  (0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1)\n\ngoal (1 subgoal):\n 1. finite UNIV = (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1) =\n    (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)", "by(simp add: card_gt_0_iff)"], ["proof (state)\nthis:\n  (0 < CARD('a) \\<and> 0 < CARD('b) \\<or> CARD('b) = 1) =\n  (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)\n\ngoal (1 subgoal):\n 1. finite UNIV = (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)", "finally"], ["proof (chain)\npicking this:\n  finite UNIV = (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite UNIV = (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)\n\ngoal (1 subgoal):\n 1. finite UNIV = (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)", "."], ["proof (state)\nthis:\n  finite UNIV = (finite UNIV \\<and> finite UNIV \\<or> CARD('b) = 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation finfun :: (finite_UNIV, card_UNIV) finite_UNIV begin"], ["", "definition \"finite_UNIV = Phantom('a \\<Rightarrow>f 'b)\n  (let cb = of_phantom (card_UNIV :: 'b card_UNIV)\n   in cb = 1 \\<or> of_phantom (finite_UNIV :: 'a finite_UNIV) \\<and> cb \\<noteq> 0)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, finite_UNIV_class)", "by intro_classes (auto simp add: finite_UNIV_finfun_def Let_def card_UNIV finite_UNIV finite_UNIV_finfun card_gt_0_iff)"], ["", "end"], ["", "instantiation finfun :: (card_UNIV, card_UNIV) card_UNIV begin"], ["", "definition \"card_UNIV = Phantom('a \\<Rightarrow>f 'b)\n  (let ca = of_phantom (card_UNIV :: 'a card_UNIV);\n       cb = of_phantom (card_UNIV :: 'b card_UNIV)\n   in if ca \\<noteq> 0 \\<and> cb \\<noteq> 0 \\<or> cb = 1 then cb ^ ca else 0)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>f 'b, card_UNIV_class)", "by intro_classes (simp add: card_UNIV_finfun_def card_UNIV Let_def card_UNIV_finfun)"], ["", "end"], ["", "subsubsection \\<open>Bundles for concrete syntax\\<close>"], ["", "bundle finfun_syntax\nbegin"], ["", "type_notation finfun (\"(_ \\<Rightarrow>f /_)\" [22, 21] 21)"], ["", "notation\n  finfun_const (\"K$/ _\" [0] 1) and\n  finfun_update (\"_'(_ $:= _')\" [1000, 0, 0] 1000) and\n  finfun_apply (infixl \"$\" 999) and\n  finfun_comp (infixr \"\\<circ>$\" 55) and\n  finfun_comp2 (infixr \"$\\<circ>\" 55) and\n  finfun_Diag (\"(1'($_,/ _$'))\" [0, 0] 1000)"], ["", "notation (ASCII)\n  finfun_comp (infixr \"o$\" 55) and\n  finfun_comp2 (infixr \"$o\" 55)"], ["", "end"], ["", "bundle no_finfun_syntax\nbegin"], ["", "no_type_notation\n  finfun (\"(_ \\<Rightarrow>f /_)\" [22, 21] 21)"], ["", "no_notation\n  finfun_const (\"K$/ _\" [0] 1) and\n  finfun_update (\"_'(_ $:= _')\" [1000, 0, 0] 1000) and\n  finfun_apply (infixl \"$\" 999) and\n  finfun_comp (infixr \"\\<circ>$\" 55) and\n  finfun_comp2 (infixr \"$\\<circ>\" 55) and\n  finfun_Diag (\"(1'($_,/ _$'))\" [0, 0] 1000)"], ["", "no_notation (ASCII) \n  finfun_comp (infixr \"o$\" 55) and\n  finfun_comp2 (infixr \"$o\" 55)"], ["", "end"], ["", "unbundle no_finfun_syntax"], ["", "end"]]}