{"file_name": "/home/qj213/afp-2021-10-22/thys/Abortable_Linearizable_Modules/IOA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Abortable_Linearizable_Modules", "problem_names": ["lemma internal_inter_external:\n  assumes \"is_asig sig\"\n  shows \"internals sig \\<inter> externals sig = {}\"", "theorem invariantI:\n  fixes A P\n  assumes \"\\<And> s . s \\<in> start A \\<Longrightarrow> P s\"\n  and \"\\<And> s t a . \\<lbrakk>reachable A s; P s; s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\\<rbrakk> \\<Longrightarrow> P t\"\n  shows \"invariant A P\"", "lemmas asig_simps = hide_asig_def is_asig_def locals_def externals_def actions_def \n  hide_def compatible_def asig_comp_def", "lemmas ioa_simps = rename_def rename_set_def is_trans_def is_ioa_def par_def", "lemma traces_alt:\n  shows \"traces A = {tr . \\<exists> e . is_exec_of A e \n    \\<and> tr = trace (ioa.asig A) e}\"", "lemmas trace_simps = traces_def is_trace_of_def is_schedule_of_def filter_act_def is_exec_of_def\n  trace_def schedule_def", "lemma last_state_reachable:\n  fixes A e\n  assumes \"is_exec_of A e\"\n  shows \"reachable A (last_state e)\"", "lemma trans_from_last_state:\n  assumes \"is_exec_frag_of A e\" and \"(last_state e)\\<midarrow>a\\<midarrow>A\\<longrightarrow>s'\"\n  shows \"is_exec_frag_of A (cons_exec e  (a,s'))\"", "lemma exec_frag_prefix:\n  fixes A p ps\n  assumes \"is_exec_frag_of A (cons_exec e p)\"\n  shows \"is_exec_frag_of A e\"", "lemma trace_same_ext:\n  fixes A B e\n  assumes \"ext A = ext B\"\n  shows \"trace (ioa.asig A) e = trace (ioa.asig B) e\"", "lemma trace_append_is_append_trace:\n  fixes e e' sig\n  shows \"trace sig (append_exec e' e) = trace sig e' @ trace sig e\"", "lemma append_exec_frags_is_exec_frag:\n  fixes e e' A as\n  assumes \"is_exec_frag_of A e\" and \"last_state e = fst e'\" \n  and \"is_exec_frag_of A e'\"\n  shows \"is_exec_frag_of A (append_exec e e')\"", "lemma last_state_of_append:\n  fixes e e'\n  assumes \"fst e' = last_state e\"\n  shows \"last_state (append_exec e e') = last_state e'\""], "translations": [["", "lemma internal_inter_external:\n  assumes \"is_asig sig\"\n  shows \"internals sig \\<inter> externals sig = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. internals sig \\<inter> externals sig = {}", "using assms"], ["proof (prove)\nusing this:\n  is_asig sig\n\ngoal (1 subgoal):\n 1. internals sig \\<inter> externals sig = {}", "by (auto simp add:internals_def externals_def is_asig_def)"], ["", "definition hide_asig where\n  \"hide_asig asig actns \\<equiv>\n    \\<lparr>inputs = inputs asig - actns, outputs = outputs asig - actns, \n      internals = internals asig \\<union>actns\\<rparr>\""], ["", "end"], ["", "subsection \\<open>I/O Automata\\<close>"], ["", "type_synonym\n  ('s,'a) transition = \"'s \\<times> 'a \\<times> 's\""], ["", "record ('s,'a) ioa = \n  asig::\"'a signature\"\n  start::\"'s set\"\n  trans::\"('s,'a)transition set\""], ["", "context IOA \nbegin"], ["", "abbreviation \"act A \\<equiv> actions (asig A)\""], ["", "abbreviation \"ext A \\<equiv> externals (asig A)\""], ["", "abbreviation int where \"int A \\<equiv> internals (asig A)\""], ["", "abbreviation \"inp A \\<equiv> inputs (asig A)\""], ["", "abbreviation \"out A \\<equiv> outputs (asig A)\""], ["", "abbreviation \"local A \\<equiv> locals (asig A)\""], ["", "definition is_ioa::\"('s,'a) ioa \\<Rightarrow> bool\" where\n  \"is_ioa A \\<equiv> is_asig (asig A)\n    \\<and> (\\<forall> triple  \\<in> trans A . (fst o snd) triple \\<in> act A)\""], ["", "definition hide where\n  \"hide A actns \\<equiv> A\\<lparr>asig := hide_asig (asig A) actns\\<rparr>\""], ["", "definition is_trans::\"'s \\<Rightarrow> 'a \\<Rightarrow> ('s,'a)ioa \\<Rightarrow> 's \\<Rightarrow> bool\" where\n  \"is_trans s1 a A s2 \\<equiv> (s1,a,s2) \\<in> trans A\""], ["", "notation\n  is_trans  (\"_ \\<midarrow>_\\<midarrow>_\\<longrightarrow> _\" [81,81,81,81] 100)"], ["", "definition rename_set where\n  \"rename_set A ren \\<equiv> {b. \\<exists> x \\<in> A . ren b = Some x}\""], ["", "definition rename where\n\"rename A ren \\<equiv>\n  \\<lparr>asig = \\<lparr>inputs = rename_set (inp A) ren, \n    outputs = rename_set (out A) ren, \n    internals = rename_set (int A) ren\\<rparr>,\n   start = start A,\n   trans = {tr. \\<exists> x . ren (fst (snd tr)) = Some x \\<and> (fst tr) \\<midarrow>x\\<midarrow>A\\<longrightarrow> (snd (snd tr))}\\<rparr>\""], ["", "text \\<open>Reachable states and invariants\\<close>"], ["", "inductive\n  reachable :: \"('s,'a) ioa \\<Rightarrow> 's \\<Rightarrow> bool\"\n  for A :: \"('s,'a) ioa\"\n  where\n    reachable_0:  \"s \\<in> start A \\<Longrightarrow> reachable A s\"\n  | reachable_n:  \"\\<lbrakk> reachable A s; s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t \\<rbrakk> \\<Longrightarrow> reachable A t\""], ["", "definition invariant where \n  \"invariant A P \\<equiv> (\\<forall> s . reachable A s \\<longrightarrow> P(s))\""], ["", "theorem invariantI:\n  fixes A P\n  assumes \"\\<And> s . s \\<in> start A \\<Longrightarrow> P s\"\n  and \"\\<And> s t a . \\<lbrakk>reachable A s; P s; s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\\<rbrakk> \\<Longrightarrow> P t\"\n  shows \"invariant A P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant A P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant A P", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant A P", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant A P", "assume \"reachable A s\""], ["proof (state)\nthis:\n  reachable A s\n\ngoal (1 subgoal):\n 1. invariant A P", "hence \"P s\""], ["proof (prove)\nusing this:\n  reachable A s\n\ngoal (1 subgoal):\n 1. P s", "proof (induct rule:reachable.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> start A \\<Longrightarrow> P s\n 2. \\<And>s a t.\n       \\<lbrakk>reachable A s; P s;\n        s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\\<rbrakk>\n       \\<Longrightarrow> P t", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> start A \\<Longrightarrow> P s\n 2. \\<And>s a t.\n       \\<lbrakk>reachable A s; P s;\n        s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\\<rbrakk>\n       \\<Longrightarrow> P t", "assume \"s \\<in> start A\""], ["proof (state)\nthis:\n  s \\<in> start A\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> start A \\<Longrightarrow> P s\n 2. \\<And>s a t.\n       \\<lbrakk>reachable A s; P s;\n        s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\\<rbrakk>\n       \\<Longrightarrow> P t", "thus \"P s\""], ["proof (prove)\nusing this:\n  s \\<in> start A\n\ngoal (1 subgoal):\n 1. P s", "using assms(1)"], ["proof (prove)\nusing this:\n  s \\<in> start A\n  ?s \\<in> start A \\<Longrightarrow> P ?s\n\ngoal (1 subgoal):\n 1. P s", "by simp"], ["proof (state)\nthis:\n  P s\n\ngoal (1 subgoal):\n 1. \\<And>s a t.\n       \\<lbrakk>reachable A s; P s;\n        s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\\<rbrakk>\n       \\<Longrightarrow> P t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a t.\n       \\<lbrakk>reachable A s; P s;\n        s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\\<rbrakk>\n       \\<Longrightarrow> P t", "fix a s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a t.\n       \\<lbrakk>reachable A s; P s;\n        s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\\<rbrakk>\n       \\<Longrightarrow> P t", "assume \"reachable A s\" and \"P s\" and \" s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\""], ["proof (state)\nthis:\n  reachable A s\n  P s\n  s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>s a t.\n       \\<lbrakk>reachable A s; P s;\n        s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\\<rbrakk>\n       \\<Longrightarrow> P t", "thus \"P t\""], ["proof (prove)\nusing this:\n  reachable A s\n  P s\n  s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\n\ngoal (1 subgoal):\n 1. P t", "using assms(2)"], ["proof (prove)\nusing this:\n  reachable A s\n  P s\n  s \\<midarrow>a\\<midarrow>A\\<longrightarrow> t\n  \\<lbrakk>reachable A ?s; P ?s;\n   ?s \\<midarrow>?a\\<midarrow>A\\<longrightarrow> ?t\\<rbrakk>\n  \\<Longrightarrow> P ?t\n\ngoal (1 subgoal):\n 1. P t", "by simp"], ["proof (state)\nthis:\n  P t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P s\n\ngoal (1 subgoal):\n 1. invariant A P", "}"], ["proof (state)\nthis:\n  reachable A ?s2 \\<Longrightarrow> P ?s2\n\ngoal (1 subgoal):\n 1. invariant A P", "thus ?thesis"], ["proof (prove)\nusing this:\n  reachable A ?s2 \\<Longrightarrow> P ?s2\n\ngoal (1 subgoal):\n 1. invariant A P", "by (simp add:invariant_def)"], ["proof (state)\nthis:\n  invariant A P\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Composition of Families of I/O Automata\\<close>"], ["", "record ('id, 'a) family =\n  ids :: \"'id set\"\n  memb :: \"'id \\<Rightarrow> 'a\""], ["", "context IOA\nbegin"], ["", "definition is_ioa_fam where\n  \"is_ioa_fam fam \\<equiv> \\<forall> i \\<in> ids fam . is_ioa (memb fam i)\""], ["", "definition compatible2  where\n  \"compatible2 A B \\<equiv>\n   out A \\<inter> out B = {} \\<and>\n   int A \\<inter> act B = {} \\<and>\n   int B \\<inter> act A = {}\""], ["", "definition compatible::\"('id, ('s,'a)ioa) family \\<Rightarrow> bool\" where\n  \"compatible fam \\<equiv> finite (ids fam) \\<and>\n    (\\<forall> i \\<in> ids fam . \\<forall> j \\<in> ids fam . i \\<noteq> j \\<longrightarrow>\n      compatible2 (memb fam i) (memb fam j))\""], ["", "definition asig_comp2 where\n  \"asig_comp2 A B \\<equiv>\n     \\<lparr>inputs = (inputs A \\<union> inputs B) - (outputs A \\<union> outputs B),\n      outputs = outputs A \\<union> outputs B,\n      internals = internals A \\<union> internals B\\<rparr>\""], ["", "definition asig_comp::\"('id, ('s,'a)ioa) family \\<Rightarrow> 'a signature\" where\n  \"asig_comp fam \\<equiv> \n    \\<lparr> inputs = \\<Union>i\\<in>(ids fam). inp (memb fam i) \n        - (\\<Union>i\\<in>(ids fam). out (memb fam i)),\n      outputs = \\<Union>i\\<in>(ids fam). out (memb fam i),\n      internals = \\<Union>i\\<in>(ids fam). int (memb fam i) \\<rparr>\""], ["", "definition par2 (infixr \"\\<parallel>\" 10) where\n  \"A \\<parallel> B \\<equiv>\n      \\<lparr>asig = asig_comp2 (asig A) (asig B),\n       start = {pr. fst pr \\<in> start A \\<and> snd pr \\<in> start B},\n       trans = {tr. \n        let s = fst tr; a = fst (snd tr); t = snd (snd tr)\n        in (a \\<in> act A \\<or> a \\<in> act B)\n           \\<and> (if a \\<in> act A\n              then fst s \\<midarrow>a\\<midarrow>A\\<longrightarrow> fst t\n              else fst s = fst t)\n           \\<and> (if a \\<in> act B\n              then snd s \\<midarrow>a\\<midarrow>B\\<longrightarrow> snd t\n              else snd s = snd t) }\\<rparr>\""], ["", "definition par::\"('id, ('s,'a)ioa) family \\<Rightarrow> ('id \\<Rightarrow> 's,'a)ioa\" where\n  \"par fam \\<equiv> let ids = ids fam; memb = memb fam in\n      \\<lparr> asig = asig_comp fam,\n        start = {s . \\<forall> i\\<in>ids . s i \\<in> start (memb i)},\n        trans = { (s, a, s') . \n          (\\<exists> i\\<in>ids . a \\<in> act (memb i))\n          \\<and> (\\<forall> i\\<in>ids . \n              if a \\<in> act (memb i)\n              then s i \\<midarrow>a\\<midarrow>(memb i)\\<longrightarrow> s' i\n              else s i = (s' i)) } \\<rparr>\""], ["", "lemmas asig_simps = hide_asig_def is_asig_def locals_def externals_def actions_def \n  hide_def compatible_def asig_comp_def"], ["", "lemmas ioa_simps = rename_def rename_set_def is_trans_def is_ioa_def par_def"], ["", "end"], ["", "subsection \\<open>Executions and Traces\\<close>"], ["", "type_synonym\n   ('s,'a)pairs = \"('a\\<times>'s) list\""], ["", "type_synonym\n   ('s,'a)execution = \"'s \\<times> ('s,'a)pairs\""], ["", "type_synonym\n   'a trace = \"'a list\""], ["", "record ('s,'a)execution_module =\n  execs::\"('s,'a)execution set\"\n  asig::\"'a signature\""], ["", "record 'a trace_module =\n  traces::\"'a trace set\"\n  asig::\"'a signature\""], ["", "context IOA\nbegin"], ["", "fun is_exec_frag_of::\"('s,'a)ioa \\<Rightarrow> ('s,'a)execution \\<Rightarrow> bool\" where\n  \"is_exec_frag_of A (s,(ps#p')#p) = \n    (snd p' \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p \\<and> is_exec_frag_of A (s, (ps#p')))\"\n| \"is_exec_frag_of A (s, [p]) = s \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p\"\n| \"is_exec_frag_of A (s, []) = True\""], ["", "definition is_exec_of::\"('s,'a)ioa \\<Rightarrow> ('s,'a)execution \\<Rightarrow> bool\" where\n  \"is_exec_of A e \\<equiv> fst e \\<in> start A \\<and> is_exec_frag_of A e\""], ["", "definition filter_act where\n  \"filter_act \\<equiv> map fst\""], ["", "definition schedule where\n  \"schedule \\<equiv> filter_act o snd\""], ["", "definition trace where\n  \"trace sig \\<equiv> filter (\\<lambda> a . a \\<in> externals sig) o schedule\""], ["", "definition is_schedule_of where\n  \"is_schedule_of A sch \\<equiv>\n     (\\<exists> e . is_exec_of A e \\<and> sch = filter_act (snd e))\""], ["", "definition is_trace_of where\n  \"is_trace_of A tr \\<equiv>\n     (\\<exists> sch . is_schedule_of A sch \\<and> tr = filter (\\<lambda> a. a \\<in> ext A) sch)\""], ["", "definition traces where\n  \"traces A \\<equiv> {tr. is_trace_of A tr}\""], ["", "lemma traces_alt:\n  shows \"traces A = {tr . \\<exists> e . is_exec_of A e \n    \\<and> tr = trace (ioa.asig A) e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "assume a:\"t \\<in> traces A\""], ["proof (state)\nthis:\n  t \\<in> local.traces A\n\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "have \"\\<exists> e . is_exec_of A e \\<and> trace (ioa.asig A) e = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = t", "from a"], ["proof (chain)\npicking this:\n  t \\<in> local.traces A", "obtain sch where 1:\"is_schedule_of A sch\" \n        and 2:\"t = filter (\\<lambda> a. a \\<in> ext A) sch\""], ["proof (prove)\nusing this:\n  t \\<in> local.traces A\n\ngoal (1 subgoal):\n 1. (\\<And>sch.\n        \\<lbrakk>is_schedule_of A sch;\n         t =\n         filter (\\<lambda>a. a \\<in> externals (ioa.asig A)) sch\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:traces_def is_trace_of_def)"], ["proof (state)\nthis:\n  is_schedule_of A sch\n  t = filter (\\<lambda>a. a \\<in> externals (ioa.asig A)) sch\n\ngoal (1 subgoal):\n 1. \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = t", "from 1"], ["proof (chain)\npicking this:\n  is_schedule_of A sch", "obtain e where 3:\"is_exec_of A e\" and 4:\"sch = filter_act (snd e)\""], ["proof (prove)\nusing this:\n  is_schedule_of A sch\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>is_exec_of A e; sch = filter_act (snd e)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:is_schedule_of_def)"], ["proof (state)\nthis:\n  is_exec_of A e\n  sch = filter_act (snd e)\n\ngoal (1 subgoal):\n 1. \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = t", "from 4 and 2"], ["proof (chain)\npicking this:\n  sch = filter_act (snd e)\n  t = filter (\\<lambda>a. a \\<in> externals (ioa.asig A)) sch", "have \"trace (ioa.asig A) e = t\""], ["proof (prove)\nusing this:\n  sch = filter_act (snd e)\n  t = filter (\\<lambda>a. a \\<in> externals (ioa.asig A)) sch\n\ngoal (1 subgoal):\n 1. trace (ioa.asig A) e = t", "by (simp add:trace_def schedule_def)"], ["proof (state)\nthis:\n  trace (ioa.asig A) e = t\n\ngoal (1 subgoal):\n 1. \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = t", "with 3"], ["proof (chain)\npicking this:\n  is_exec_of A e\n  trace (ioa.asig A) e = t", "show ?thesis"], ["proof (prove)\nusing this:\n  is_exec_of A e\n  trace (ioa.asig A) e = t\n\ngoal (1 subgoal):\n 1. \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = t", "by fast"], ["proof (state)\nthis:\n  \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = t\n\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "}"], ["proof (state)\nthis:\n  ?t2 \\<in> local.traces A \\<Longrightarrow>\n  \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = ?t2\n\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "moreover"], ["proof (state)\nthis:\n  ?t2 \\<in> local.traces A \\<Longrightarrow>\n  \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = ?t2\n\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "{"], ["proof (state)\nthis:\n  ?t2 \\<in> local.traces A \\<Longrightarrow>\n  \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = ?t2\n\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "assume \"is_exec_of A e\""], ["proof (state)\nthis:\n  is_exec_of A e\n\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "hence \"trace (ioa.asig A) e \\<in> traces A\""], ["proof (prove)\nusing this:\n  is_exec_of A e\n\ngoal (1 subgoal):\n 1. trace (ioa.asig A) e \\<in> local.traces A", "by (force simp add:trace_def schedule_def traces_def \n          is_trace_of_def is_schedule_of_def is_exec_of_def)"], ["proof (state)\nthis:\n  trace (ioa.asig A) e \\<in> local.traces A\n\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "}"], ["proof (state)\nthis:\n  is_exec_of A ?e2 \\<Longrightarrow>\n  trace (ioa.asig A) ?e2 \\<in> local.traces A\n\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "ultimately"], ["proof (chain)\npicking this:\n  ?t2 \\<in> local.traces A \\<Longrightarrow>\n  \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = ?t2\n  is_exec_of A ?e2 \\<Longrightarrow>\n  trace (ioa.asig A) ?e2 \\<in> local.traces A", "show ?thesis"], ["proof (prove)\nusing this:\n  ?t2 \\<in> local.traces A \\<Longrightarrow>\n  \\<exists>e. is_exec_of A e \\<and> trace (ioa.asig A) e = ?t2\n  is_exec_of A ?e2 \\<Longrightarrow>\n  trace (ioa.asig A) ?e2 \\<in> local.traces A\n\ngoal (1 subgoal):\n 1. local.traces A =\n    {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}", "by blast"], ["proof (state)\nthis:\n  local.traces A =\n  {tr. \\<exists>e. is_exec_of A e \\<and> tr = trace (ioa.asig A) e}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas trace_simps = traces_def is_trace_of_def is_schedule_of_def filter_act_def is_exec_of_def\n  trace_def schedule_def"], ["", "definition proj_trace::\"'a trace \\<Rightarrow> ('a signature) \\<Rightarrow> 'a trace\" (infixr \"\\<bar>\" 12) where\n  \"proj_trace t sig \\<equiv> filter (\\<lambda> a . a \\<in> actions sig) t\""], ["", "definition ioa_implements :: \"('s1,'a)ioa \\<Rightarrow> ('s2,'a)ioa \\<Rightarrow> bool\"   (infixr \"=<|\" 12) where\n  \"A =<| B \\<equiv> inp A = inp B \\<and> out A = out B \\<and> traces A \\<subseteq> traces B\""], ["", "subsection \\<open>Operations on Executions\\<close>"], ["", "definition cons_exec where\n  \"cons_exec e p \\<equiv> (fst e, (snd e)#p)\""], ["", "definition append_exec where\n  \"append_exec e e' \\<equiv> (fst e, (snd e)@(snd e'))\""], ["", "fun last_state where\n  \"last_state (s,[]) = s\"\n| \"last_state (s,ps#p) = snd p\""], ["", "lemma last_state_reachable:\n  fixes A e\n  assumes \"is_exec_of A e\"\n  shows \"reachable A (last_state e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable A (last_state e)", "using assms"], ["proof (prove)\nusing this:\n  is_exec_of A e\n\ngoal (1 subgoal):\n 1. reachable A (last_state e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_exec_of A e \\<Longrightarrow> reachable A (last_state e)", "have \"is_exec_of A e \\<Longrightarrow> reachable A (last_state e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_exec_of A e \\<Longrightarrow> reachable A (last_state e)", "proof (induction \"snd e\" arbitrary: e)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>[] = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)\n 2. \\<And>a x e.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>x = snd e; is_exec_of A e\\<rbrakk>\n                   \\<Longrightarrow> reachable A (last_state e);\n        Cons a x = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)", "case Nil"], ["proof (state)\nthis:\n  [] = snd e\n  is_exec_of A e\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>[] = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)\n 2. \\<And>a x e.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>x = snd e; is_exec_of A e\\<rbrakk>\n                   \\<Longrightarrow> reachable A (last_state e);\n        Cons a x = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)", "from Nil.prems"], ["proof (chain)\npicking this:\n  is_exec_of A e", "have 1:\"fst e \\<in> start A\""], ["proof (prove)\nusing this:\n  is_exec_of A e\n\ngoal (1 subgoal):\n 1. fst e \\<in> start A", "by (simp add:is_exec_of_def)"], ["proof (state)\nthis:\n  fst e \\<in> start A\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>[] = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)\n 2. \\<And>a x e.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>x = snd e; is_exec_of A e\\<rbrakk>\n                   \\<Longrightarrow> reachable A (last_state e);\n        Cons a x = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)", "from Nil.hyps"], ["proof (chain)\npicking this:\n  [] = snd e", "have 2:\"last_state e = fst e\""], ["proof (prove)\nusing this:\n  [] = snd e\n\ngoal (1 subgoal):\n 1. last_state e = fst e", "by (metis last_state.simps(1) surjective_pairing)"], ["proof (state)\nthis:\n  last_state e = fst e\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>[] = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)\n 2. \\<And>a x e.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>x = snd e; is_exec_of A e\\<rbrakk>\n                   \\<Longrightarrow> reachable A (last_state e);\n        Cons a x = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)", "from 1 and 2 and Nil.hyps"], ["proof (chain)\npicking this:\n  fst e \\<in> start A\n  last_state e = fst e\n  [] = snd e", "show ?case"], ["proof (prove)\nusing this:\n  fst e \\<in> start A\n  last_state e = fst e\n  [] = snd e\n\ngoal (1 subgoal):\n 1. reachable A (last_state e)", "by (metis reachable_0)"], ["proof (state)\nthis:\n  reachable A (last_state e)\n\ngoal (1 subgoal):\n 1. \\<And>a x e.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>x = snd e; is_exec_of A e\\<rbrakk>\n                   \\<Longrightarrow> reachable A (last_state e);\n        Cons a x = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x e.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>x = snd e; is_exec_of A e\\<rbrakk>\n                   \\<Longrightarrow> reachable A (last_state e);\n        Cons a x = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)", "case (Cons p ps e)"], ["proof (state)\nthis:\n  \\<lbrakk>ps = snd ?e; is_exec_of A ?e\\<rbrakk>\n  \\<Longrightarrow> reachable A (last_state ?e)\n  Cons p ps = snd e\n  is_exec_of A e\n\ngoal (1 subgoal):\n 1. \\<And>a x e.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>x = snd e; is_exec_of A e\\<rbrakk>\n                   \\<Longrightarrow> reachable A (last_state e);\n        Cons a x = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)", "let ?e' = \"(fst e, ps)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x e.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>x = snd e; is_exec_of A e\\<rbrakk>\n                   \\<Longrightarrow> reachable A (last_state e);\n        Cons a x = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)", "have ih:\"reachable A (last_state ?e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable A (last_state (fst e, ps))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable A (last_state (fst e, ps))", "from Cons.prems and Cons.hyps(2)"], ["proof (chain)\npicking this:\n  is_exec_of A e\n  Cons p ps = snd e", "have \"is_exec_of A ?e'\""], ["proof (prove)\nusing this:\n  is_exec_of A e\n  Cons p ps = snd e\n\ngoal (1 subgoal):\n 1. is_exec_of A (fst e, ps)", "by (simp add:is_exec_of_def)\n          (metis (full_types) IOA.is_exec_frag_of.simps(1) IOA.is_exec_frag_of.simps(3) \n            neq_Nil_conv prod.collapse)"], ["proof (state)\nthis:\n  is_exec_of A (fst e, ps)\n\ngoal (1 subgoal):\n 1. reachable A (last_state (fst e, ps))", "with Cons.hyps(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>ps = snd ?e; is_exec_of A ?e\\<rbrakk>\n  \\<Longrightarrow> reachable A (last_state ?e)\n  is_exec_of A (fst e, ps)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ps = snd ?e; is_exec_of A ?e\\<rbrakk>\n  \\<Longrightarrow> reachable A (last_state ?e)\n  is_exec_of A (fst e, ps)\n\ngoal (1 subgoal):\n 1. reachable A (last_state (fst e, ps))", "by auto"], ["proof (state)\nthis:\n  reachable A (last_state (fst e, ps))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable A (last_state (fst e, ps))\n\ngoal (1 subgoal):\n 1. \\<And>a x e.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>x = snd e; is_exec_of A e\\<rbrakk>\n                   \\<Longrightarrow> reachable A (last_state e);\n        Cons a x = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)", "from Cons.prems and Cons.hyps(2)"], ["proof (chain)\npicking this:\n  is_exec_of A e\n  Cons p ps = snd e", "have \"(last_state ?e')\\<midarrow>(fst p)\\<midarrow>A\\<longrightarrow>(snd p)\""], ["proof (prove)\nusing this:\n  is_exec_of A e\n  Cons p ps = snd e\n\ngoal (1 subgoal):\n 1. last_state\n     (fst e, ps) \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p", "by (simp add:is_exec_of_def) (cases \"(A,fst e,ps#p)\" rule:is_exec_frag_of.cases, auto)"], ["proof (state)\nthis:\n  last_state (fst e, ps) \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p\n\ngoal (1 subgoal):\n 1. \\<And>a x e.\n       \\<lbrakk>\\<And>e.\n                   \\<lbrakk>x = snd e; is_exec_of A e\\<rbrakk>\n                   \\<Longrightarrow> reachable A (last_state e);\n        Cons a x = snd e; is_exec_of A e\\<rbrakk>\n       \\<Longrightarrow> reachable A (last_state e)", "with ih and Cons.hyps(2)"], ["proof (chain)\npicking this:\n  reachable A (last_state (fst e, ps))\n  Cons p ps = snd e\n  last_state (fst e, ps) \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p", "show ?case"], ["proof (prove)\nusing this:\n  reachable A (last_state (fst e, ps))\n  Cons p ps = snd e\n  last_state (fst e, ps) \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p\n\ngoal (1 subgoal):\n 1. reachable A (last_state e)", "by (metis last_state.simps(2) reachable.simps surjective_pairing)"], ["proof (state)\nthis:\n  reachable A (last_state e)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_exec_of A e \\<Longrightarrow> reachable A (last_state e)\n\ngoal (1 subgoal):\n 1. is_exec_of A e \\<Longrightarrow> reachable A (last_state e)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_exec_of A e \\<Longrightarrow> reachable A (last_state e)\n\ngoal (1 subgoal):\n 1. reachable A (last_state e)", "using assms"], ["proof (prove)\nusing this:\n  is_exec_of A e \\<Longrightarrow> reachable A (last_state e)\n  is_exec_of A e\n\ngoal (1 subgoal):\n 1. reachable A (last_state e)", "by fastforce"], ["proof (state)\nthis:\n  reachable A (last_state e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trans_from_last_state:\n  assumes \"is_exec_frag_of A e\" and \"(last_state e)\\<midarrow>a\\<midarrow>A\\<longrightarrow>s'\"\n  shows \"is_exec_frag_of A (cons_exec e  (a,s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_exec_frag_of A (cons_exec e (a, s'))", "using assms"], ["proof (prove)\nusing this:\n  is_exec_frag_of A e\n  last_state e \\<midarrow>a\\<midarrow>A\\<longrightarrow> s'\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A (cons_exec e (a, s'))", "by (cases \"(A, fst e, snd e)\" rule:is_exec_frag_of.cases, auto simp add:cons_exec_def)"], ["", "lemma exec_frag_prefix:\n  fixes A p ps\n  assumes \"is_exec_frag_of A (cons_exec e p)\"\n  shows \"is_exec_frag_of A e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_exec_frag_of A e", "using assms"], ["proof (prove)\nusing this:\n  is_exec_frag_of A (cons_exec e p)\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A e", "by (cases \"(A, fst e, snd e)\" rule:is_exec_frag_of.cases, auto simp add:cons_exec_def)"], ["", "lemma trace_same_ext:\n  fixes A B e\n  assumes \"ext A = ext B\"\n  shows \"trace (ioa.asig A) e = trace (ioa.asig B) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (ioa.asig A) e = trace (ioa.asig B) e", "using assms"], ["proof (prove)\nusing this:\n  externals (ioa.asig A) = externals (ioa.asig B)\n\ngoal (1 subgoal):\n 1. trace (ioa.asig A) e = trace (ioa.asig B) e", "by (auto simp add:trace_def)"], ["", "lemma trace_append_is_append_trace:\n  fixes e e' sig\n  shows \"trace sig (append_exec e' e) = trace sig e' @ trace sig e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace sig (append_exec e' e) = append (trace sig e) (trace sig e')", "by (simp add:append_exec_def trace_def schedule_def filter_act_def)"], ["", "lemma append_exec_frags_is_exec_frag:\n  fixes e e' A as\n  assumes \"is_exec_frag_of A e\" and \"last_state e = fst e'\" \n  and \"is_exec_frag_of A e'\"\n  shows \"is_exec_frag_of A (append_exec e e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_exec_frag_of A (append_exec e e')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_exec_frag_of A (append_exec e e')", "from assms"], ["proof (chain)\npicking this:\n  is_exec_frag_of A e\n  last_state e = fst e'\n  is_exec_frag_of A e'", "show ?thesis"], ["proof (prove)\nusing this:\n  is_exec_frag_of A e\n  last_state e = fst e'\n  is_exec_frag_of A e'\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A (append_exec e e')", "proof (induct \"(fst e',snd e')\" arbitrary:e' rule:is_exec_frag_of.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')\n 2. \\<And>A p e'.\n       \\<lbrakk>[p] = snd e'; is_exec_frag_of A e; last_state e = fst e';\n        is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')\n 3. \\<And>A e'.\n       \\<lbrakk>[] = snd e'; is_exec_frag_of A e; last_state e = fst e';\n        is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "case (3 A)"], ["proof (state)\nthis:\n  [] = snd e'\n  is_exec_frag_of A e\n  last_state e = fst e'\n  is_exec_frag_of A e'\n\ngoal (3 subgoals):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')\n 2. \\<And>A p e'.\n       \\<lbrakk>[p] = snd e'; is_exec_frag_of A e; last_state e = fst e';\n        is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')\n 3. \\<And>A e'.\n       \\<lbrakk>[] = snd e'; is_exec_frag_of A e; last_state e = fst e';\n        is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "from \"3.hyps\" and \"3.prems\"(1)"], ["proof (chain)\npicking this:\n  [] = snd e'\n  is_exec_frag_of A e", "show ?case"], ["proof (prove)\nusing this:\n  [] = snd e'\n  is_exec_frag_of A e\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A (append_exec e e')", "by (simp add:append_exec_def)"], ["proof (state)\nthis:\n  is_exec_frag_of A (append_exec e e')\n\ngoal (2 subgoals):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')\n 2. \\<And>A p e'.\n       \\<lbrakk>[p] = snd e'; is_exec_frag_of A e; last_state e = fst e';\n        is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')\n 2. \\<And>A p e'.\n       \\<lbrakk>[p] = snd e'; is_exec_frag_of A e; last_state e = fst e';\n        is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "case (2 A p)"], ["proof (state)\nthis:\n  [p] = snd e'\n  is_exec_frag_of A e\n  last_state e = fst e'\n  is_exec_frag_of A e'\n\ngoal (2 subgoals):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')\n 2. \\<And>A p e'.\n       \\<lbrakk>[p] = snd e'; is_exec_frag_of A e; last_state e = fst e';\n        is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "have \"last_state e \\<midarrow>(fst p)\\<midarrow>A\\<longrightarrow> snd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_state e \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p", "using \"2.prems\"(2,3) and \"2.hyps\""], ["proof (prove)\nusing this:\n  last_state e = fst e'\n  is_exec_frag_of A e'\n  [p] = snd e'\n\ngoal (1 subgoal):\n 1. last_state e \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p", "by (metis is_exec_frag_of.simps(2) prod.collapse)"], ["proof (state)\nthis:\n  last_state e \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p\n\ngoal (2 subgoals):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')\n 2. \\<And>A p e'.\n       \\<lbrakk>[p] = snd e'; is_exec_frag_of A e; last_state e = fst e';\n        is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "hence \"is_exec_frag_of A (fst e, (snd e)#p)\""], ["proof (prove)\nusing this:\n  last_state e \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A (fst e, Cons p (snd e))", "using \"2.prems\"(1)"], ["proof (prove)\nusing this:\n  last_state e \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p\n  is_exec_frag_of A e\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A (fst e, Cons p (snd e))", "by (metis cons_exec_def prod.collapse trans_from_last_state)"], ["proof (state)\nthis:\n  is_exec_frag_of A (fst e, Cons p (snd e))\n\ngoal (2 subgoals):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')\n 2. \\<And>A p e'.\n       \\<lbrakk>[p] = snd e'; is_exec_frag_of A e; last_state e = fst e';\n        is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "moreover"], ["proof (state)\nthis:\n  is_exec_frag_of A (fst e, Cons p (snd e))\n\ngoal (2 subgoals):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')\n 2. \\<And>A p e'.\n       \\<lbrakk>[p] = snd e'; is_exec_frag_of A e; last_state e = fst e';\n        is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "have \"append_exec e e' = (fst e, (snd e)#p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. append_exec e e' = (fst e, Cons p (snd e))", "using \"2.hyps\""], ["proof (prove)\nusing this:\n  [p] = snd e'\n\ngoal (1 subgoal):\n 1. append_exec e e' = (fst e, Cons p (snd e))", "by (metis append_Cons append_Nil append_exec_def)"], ["proof (state)\nthis:\n  append_exec e e' = (fst e, Cons p (snd e))\n\ngoal (2 subgoals):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')\n 2. \\<And>A p e'.\n       \\<lbrakk>[p] = snd e'; is_exec_frag_of A e; last_state e = fst e';\n        is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "ultimately"], ["proof (chain)\npicking this:\n  is_exec_frag_of A (fst e, Cons p (snd e))\n  append_exec e e' = (fst e, Cons p (snd e))", "show ?case"], ["proof (prove)\nusing this:\n  is_exec_frag_of A (fst e, Cons p (snd e))\n  append_exec e e' = (fst e, Cons p (snd e))\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A (append_exec e e')", "by auto"], ["proof (state)\nthis:\n  is_exec_frag_of A (append_exec e e')\n\ngoal (1 subgoal):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "case (1 A ps p' p e')"], ["proof (state)\nthis:\n  \\<lbrakk>fst e' = fst ?e'; Cons p' ps = snd ?e'; is_exec_frag_of A e;\n   last_state e = fst ?e'; is_exec_frag_of A ?e'\\<rbrakk>\n  \\<Longrightarrow> is_exec_frag_of A (append_exec e ?e')\n  Cons p (Cons p' ps) = snd e'\n  is_exec_frag_of A e\n  last_state e = fst e'\n  is_exec_frag_of A e'\n\ngoal (1 subgoal):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "have \"is_exec_frag_of A (fst e, (snd e)@((ps#p')#p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_exec_frag_of A (fst e, append (Cons p (Cons p' ps)) (snd e))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_exec_frag_of A (fst e, append (Cons p (Cons p' ps)) (snd e))", "have \"is_exec_frag_of A (fst e, (snd e)@(ps#p'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_exec_frag_of A (fst e, append (Cons p' ps) (snd e))", "by (metis \"1.hyps\" \"1.prems\" append_exec_def cons_exec_def \n            exec_frag_prefix fst_conv prod_eqI snd_conv)"], ["proof (state)\nthis:\n  is_exec_frag_of A (fst e, append (Cons p' ps) (snd e))\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A (fst e, append (Cons p (Cons p' ps)) (snd e))", "moreover"], ["proof (state)\nthis:\n  is_exec_frag_of A (fst e, append (Cons p' ps) (snd e))\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A (fst e, append (Cons p (Cons p' ps)) (snd e))", "have \"snd p' \\<midarrow>(fst p)\\<midarrow>A\\<longrightarrow> snd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd p' \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p", "using \"1.prems\"(3) \"1.hyps\"(2)"], ["proof (prove)\nusing this:\n  is_exec_frag_of A e'\n  Cons p (Cons p' ps) = snd e'\n\ngoal (1 subgoal):\n 1. snd p' \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p", "by (metis is_exec_frag_of.simps(1) prod.collapse)"], ["proof (state)\nthis:\n  snd p' \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A (fst e, append (Cons p (Cons p' ps)) (snd e))", "ultimately"], ["proof (chain)\npicking this:\n  is_exec_frag_of A (fst e, append (Cons p' ps) (snd e))\n  snd p' \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p", "show ?thesis"], ["proof (prove)\nusing this:\n  is_exec_frag_of A (fst e, append (Cons p' ps) (snd e))\n  snd p' \\<midarrow>fst p\\<midarrow>A\\<longrightarrow> snd p\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A (fst e, append (Cons p (Cons p' ps)) (snd e))", "by simp"], ["proof (state)\nthis:\n  is_exec_frag_of A (fst e, append (Cons p (Cons p' ps)) (snd e))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_exec_frag_of A (fst e, append (Cons p (Cons p' ps)) (snd e))\n\ngoal (1 subgoal):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "moreover"], ["proof (state)\nthis:\n  is_exec_frag_of A (fst e, append (Cons p (Cons p' ps)) (snd e))\n\ngoal (1 subgoal):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "have \"append_exec e e' = (fst e, (snd e)@((ps#p')#p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. append_exec e e' = (fst e, append (Cons p (Cons p' ps)) (snd e))", "by (metis \"1.hyps\"(2) append_exec_def)"], ["proof (state)\nthis:\n  append_exec e e' = (fst e, append (Cons p (Cons p' ps)) (snd e))\n\ngoal (1 subgoal):\n 1. \\<And>A ps p' p e'.\n       \\<lbrakk>\\<And>e'a.\n                   \\<lbrakk>fst e' = fst e'a; Cons p' ps = snd e'a;\n                    is_exec_frag_of A e; last_state e = fst e'a;\n                    is_exec_frag_of A e'a\\<rbrakk>\n                   \\<Longrightarrow> is_exec_frag_of A (append_exec e e'a);\n        Cons p (Cons p' ps) = snd e'; is_exec_frag_of A e;\n        last_state e = fst e'; is_exec_frag_of A e'\\<rbrakk>\n       \\<Longrightarrow> is_exec_frag_of A (append_exec e e')", "ultimately"], ["proof (chain)\npicking this:\n  is_exec_frag_of A (fst e, append (Cons p (Cons p' ps)) (snd e))\n  append_exec e e' = (fst e, append (Cons p (Cons p' ps)) (snd e))", "show ?case"], ["proof (prove)\nusing this:\n  is_exec_frag_of A (fst e, append (Cons p (Cons p' ps)) (snd e))\n  append_exec e e' = (fst e, append (Cons p (Cons p' ps)) (snd e))\n\ngoal (1 subgoal):\n 1. is_exec_frag_of A (append_exec e e')", "by simp"], ["proof (state)\nthis:\n  is_exec_frag_of A (append_exec e e')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_exec_frag_of A (append_exec e e')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma last_state_of_append:\n  fixes e e'\n  assumes \"fst e' = last_state e\"\n  shows \"last_state (append_exec e e') = last_state e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_state (append_exec e e') = last_state e'", "using assms"], ["proof (prove)\nusing this:\n  fst e' = last_state e\n\ngoal (1 subgoal):\n 1. last_state (append_exec e e') = last_state e'", "by (cases e' rule:last_state.cases, auto simp add:append_exec_def)"], ["", "end"], ["", "end"]]}