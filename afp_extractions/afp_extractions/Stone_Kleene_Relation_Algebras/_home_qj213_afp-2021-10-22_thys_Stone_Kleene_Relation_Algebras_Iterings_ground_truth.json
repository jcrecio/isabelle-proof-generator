{"file_name": "/home/qj213/afp-2021-10-22/thys/Stone_Kleene_Relation_Algebras/Iterings.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stone_Kleene_Relation_Algebras", "problem_names": ["lemma circ_mult_sub:\n  \"1 \\<squnion> x * (y * x)\\<^sup>\\<circ> * y \\<le> (x * y)\\<^sup>\\<circ>\"", "lemma circ_right_unfold_sub:\n  \"1 \\<squnion> x\\<^sup>\\<circ> * x \\<le> x\\<^sup>\\<circ>\"", "lemma circ_zero:\n  \"bot\\<^sup>\\<circ> = 1\"", "lemma circ_increasing:\n  \"x \\<le> x\\<^sup>\\<circ>\"", "lemma circ_reflexive:\n  \"1 \\<le> x\\<^sup>\\<circ>\"", "lemma circ_mult_increasing:\n  \"x \\<le> x * x\\<^sup>\\<circ>\"", "lemma circ_mult_increasing_2:\n  \"x \\<le> x\\<^sup>\\<circ> * x\"", "lemma circ_transitive_equal:\n  \"x\\<^sup>\\<circ> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\"", "lemma circ_circ_circ:\n  \"x\\<^sup>\\<circ>\\<^sup>\\<circ>\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\"", "lemma circ_one:\n  \"1\\<^sup>\\<circ> = 1\\<^sup>\\<circ>\\<^sup>\\<circ>\"", "lemma circ_sup_sub:\n  \"(x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\"", "lemma circ_plus_one:\n  \"x\\<^sup>\\<circ> = 1 \\<squnion> x\\<^sup>\\<circ>\"", "lemma circ_rtc_2:\n  \"1 \\<squnion> x \\<squnion> x\\<^sup>\\<circ> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\"", "lemma mult_zero_circ:\n  \"(x * bot)\\<^sup>\\<circ> = 1 \\<squnion> x * bot\"", "lemma mult_zero_sup_circ:\n  \"(x \\<squnion> y * bot)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * (y * bot)\\<^sup>\\<circ>\"", "lemma circ_plus_sub:\n  \"x\\<^sup>\\<circ> * x \\<le> x * x\\<^sup>\\<circ>\"", "lemma circ_loop_fixpoint:\n  \"y * (y\\<^sup>\\<circ> * z) \\<squnion> z = y\\<^sup>\\<circ> * z\"", "lemma left_plus_below_circ:\n  \"x * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ>\"", "lemma right_plus_below_circ:\n  \"x\\<^sup>\\<circ> * x \\<le> x\\<^sup>\\<circ>\"", "lemma circ_sup_upper_bound:\n  \"x \\<le> z\\<^sup>\\<circ> \\<Longrightarrow> y \\<le> z\\<^sup>\\<circ> \\<Longrightarrow> x \\<squnion> y \\<le> z\\<^sup>\\<circ>\"", "lemma circ_mult_upper_bound:\n  \"x \\<le> z\\<^sup>\\<circ> \\<Longrightarrow> y \\<le> z\\<^sup>\\<circ> \\<Longrightarrow> x * y \\<le> z\\<^sup>\\<circ>\"", "lemma circ_sub_dist:\n  \"x\\<^sup>\\<circ> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\"", "lemma circ_sub_dist_1:\n  \"x \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\"", "lemma circ_sub_dist_2:\n  \"x * y \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\"", "lemma circ_sub_dist_3:\n  \"x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\"", "lemma circ_isotone:\n  \"x \\<le> y \\<Longrightarrow> x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ>\"", "lemma circ_sup_2:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> \\<le> (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\"", "lemma circ_sup_one_left_unfold:\n  \"1 \\<le> x \\<Longrightarrow> x * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\"", "lemma circ_sup_one_right_unfold:\n  \"1 \\<le> x \\<Longrightarrow> x\\<^sup>\\<circ> * x = x\\<^sup>\\<circ>\"", "lemma circ_decompose_4:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * (y\\<^sup>\\<circ> * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\"", "lemma circ_decompose_5:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> = (y\\<^sup>\\<circ> * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\"", "lemma circ_decompose_6:\n  \"x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ> = y\\<^sup>\\<circ> * (x * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\"", "lemma circ_decompose_7:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ> * (x \\<squnion> y)\\<^sup>\\<circ>\"", "lemma circ_decompose_8:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = (x \\<squnion> y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_decompose_9:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ> * (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\"", "lemma circ_decompose_10:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> = (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_back_loop_prefixpoint:\n  \"(z * y\\<^sup>\\<circ>) * y \\<squnion> z \\<le> z * y\\<^sup>\\<circ>\"", "lemma circ_loop_is_fixpoint:\n  \"is_fixpoint (\\<lambda>x . y * x \\<squnion> z) (y\\<^sup>\\<circ> * z)\"", "lemma circ_back_loop_is_prefixpoint:\n  \"is_prefixpoint (\\<lambda>x . x * y \\<squnion> z) (z * y\\<^sup>\\<circ>)\"", "lemma circ_circ_sup:\n  \"(1 \\<squnion> x)\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\"", "lemma circ_circ_mult_sub:\n  \"x\\<^sup>\\<circ> * 1\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ>\\<^sup>\\<circ>\"", "lemma left_plus_circ:\n  \"(x * x\\<^sup>\\<circ>)\\<^sup>\\<circ> = x\\<^sup>\\<circ>\"", "lemma right_plus_circ:\n  \"(x\\<^sup>\\<circ> * x)\\<^sup>\\<circ> = x\\<^sup>\\<circ>\"", "lemma circ_square:\n  \"(x * x)\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ>\"", "lemma circ_mult_sub_sup:\n  \"(x * y)\\<^sup>\\<circ> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\"", "lemma circ_sup_mult_zero:\n  \"x\\<^sup>\\<circ> * y = (x \\<squnion> y * bot)\\<^sup>\\<circ> * y\"", "lemma troeger_1:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * (1 \\<squnion> y * (x \\<squnion> y)\\<^sup>\\<circ>)\"", "lemma troeger_2:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> * z = x\\<^sup>\\<circ> * (y * (x \\<squnion> y)\\<^sup>\\<circ> * z \\<squnion> z)\"", "lemma troeger_3:\n  \"(x \\<squnion> y * bot)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * (1 \\<squnion> y * bot)\"", "lemma circ_sup_sub_sup_one_1:\n  \"x \\<squnion> y \\<le> x\\<^sup>\\<circ> * (1 \\<squnion> y)\"", "lemma circ_sup_sub_sup_one_2:\n  \"x\\<^sup>\\<circ> * (x \\<squnion> y) \\<le> x\\<^sup>\\<circ> * (1 \\<squnion> y)\"", "lemma circ_sup_sub_sup_one:\n  \"x * x\\<^sup>\\<circ> * (x \\<squnion> y) \\<le> x * x\\<^sup>\\<circ> * (1 \\<squnion> y)\"", "lemma circ_square_2:\n  \"(x * x)\\<^sup>\\<circ> * (x \\<squnion> 1) \\<le> x\\<^sup>\\<circ>\"", "lemma circ_extra_circ:\n  \"(y * x\\<^sup>\\<circ>)\\<^sup>\\<circ> = (y * y\\<^sup>\\<circ> * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\"", "lemma circ_circ_sub_mult:\n  \"1\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ>\\<^sup>\\<circ>\"", "lemma circ_decompose_11:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> = (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\"", "lemma circ_mult_below_circ_circ:\n  \"(x * y)\\<^sup>\\<circ> \\<le> (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\"", "lemma circ_top:\n  \"top\\<^sup>\\<circ> = top\"", "lemma circ_right_top:\n  \"x\\<^sup>\\<circ> * top = top\"", "lemma circ_left_top:\n  \"top * x\\<^sup>\\<circ> = top\"", "lemma mult_top_circ:\n  \"(x * top)\\<^sup>\\<circ> = 1 \\<squnion> x * top\"", "lemma mult_zero_sup_circ_2:\n  \"(x \\<squnion> y * bot)\\<^sup>\\<circ> = x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * y * bot\"", "lemma circ_unfold_sum:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * y * (x \\<squnion> y)\\<^sup>\\<circ>\"", "lemma circ_slide_1:\n  \"x * (y * x)\\<^sup>\\<circ> = (x * y)\\<^sup>\\<circ> * x\"", "lemma circ_right_unfold_1:\n  \"1 \\<squnion> x\\<^sup>\\<circ> * x = x\\<^sup>\\<circ>\"", "lemma circ_mult_1:\n  \"(x * y)\\<^sup>\\<circ> = 1 \\<squnion> x * (y * x)\\<^sup>\\<circ> * y\"", "lemma circ_sup_9:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\"", "lemma circ_plus_same:\n  \"x\\<^sup>\\<circ> * x = x * x\\<^sup>\\<circ>\"", "lemma circ_decompose_12:\n  \"x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<le> (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\"", "lemma circ_back_loop_fixpoint:\n  \"(z * y\\<^sup>\\<circ>) * y \\<squnion> z = z * y\\<^sup>\\<circ>\"", "lemma circ_back_loop_is_fixpoint:\n  \"is_fixpoint (\\<lambda>x . x * y \\<squnion> z) (z * y\\<^sup>\\<circ>)\"", "lemma circ_elimination:\n  \"x * y = bot \\<Longrightarrow> x * y\\<^sup>\\<circ> \\<le> x\"", "lemma circ_circ_mult:\n  \"1\\<^sup>\\<circ> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\"", "lemma sub_mult_one_circ:\n  \"x * 1\\<^sup>\\<circ> \\<le> 1\\<^sup>\\<circ> * x\"", "lemma circ_import:\n  assumes \"p \\<le> p * p\"\n      and \"p \\<le> 1\"\n      and \"p * x \\<le> x * p\"\n    shows \"p * x\\<^sup>\\<circ> = p * (p * x)\\<^sup>\\<circ>\"", "lemma circ_simulate_left_1:\n  \"x * z \\<le> z * y \\<Longrightarrow> x\\<^sup>\\<circ> * z \\<le> z * y\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * bot\"", "lemma circ_separate_1:\n  assumes \"y * x \\<le> x * y\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_circ_mult_1:\n  \"x\\<^sup>\\<circ> * 1\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\"", "lemma circ_simulate_1:\n  assumes \"y * x \\<le> x * y\"\n    shows \"y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma atomicity_refinement:\n  assumes \"s = s * q\"\n      and \"x = q * x\"\n      and \"q * b = bot\"\n      and \"r * b \\<le> b * r\"\n      and \"r * l \\<le> l * r\"\n      and \"x * l \\<le> l * x\"\n      and \"b * l \\<le> l * b\"\n      and \"q * l \\<le> l * q\"\n      and \"r\\<^sup>\\<circ> * q \\<le> q * r\\<^sup>\\<circ>\"\n      and \"q \\<le> 1\"\n    shows \"s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q \\<le> s * (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>\"", "lemma circ_right_unfold:\n  \"1 \\<squnion> x\\<^sup>\\<circ> * x = x\\<^sup>\\<circ>\"", "lemma circ_slide:\n  \"x * (y * x)\\<^sup>\\<circ> = (x * y)\\<^sup>\\<circ> * x\"", "lemma circ_simulate_right_plus_1:\n  \"z * x \\<le> y * y\\<^sup>\\<circ> * z \\<Longrightarrow> z * x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * z\"", "lemma circ_simulate_left_plus_1:\n  \"x * z \\<le> z * y\\<^sup>\\<circ> \\<Longrightarrow> x\\<^sup>\\<circ> * z \\<le> z * y\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * bot\"", "lemma circ_simulate_2:\n  \"y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<longleftrightarrow> y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_simulate_absorb:\n  \"y * x \\<le> x \\<Longrightarrow> y\\<^sup>\\<circ> * x \\<le> x \\<squnion> y\\<^sup>\\<circ> * bot\"", "lemma circ_simulate_3:\n  \"y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> \\<Longrightarrow> y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_separate_mult_1:\n  \"y * x \\<le> x * y \\<Longrightarrow> (x * y)\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_separate_unfold:\n  \"(y * x\\<^sup>\\<circ>)\\<^sup>\\<circ> = y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * y * x * x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\"", "lemma separation:\n  assumes \"y * x \\<le> x * y\\<^sup>\\<circ>\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma simulation:\n  \"y * x \\<le> x * y\\<^sup>\\<circ> \\<Longrightarrow> y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_simulate_4:\n  assumes \"y * x \\<le> x * x\\<^sup>\\<circ> * (1 \\<squnion> y)\"\n    shows \"y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_simulate_5:\n  \"y * x \\<le> x * x\\<^sup>\\<circ> * (x \\<squnion> y) \\<Longrightarrow> y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_simulate_6:\n  \"y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow> y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_separate_4:\n  assumes \"y * x \\<le> x * x\\<^sup>\\<circ> * (1 \\<squnion> y)\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_separate_5:\n  \"y * x \\<le> x * x\\<^sup>\\<circ> * (x \\<squnion> y) \\<Longrightarrow> (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma circ_separate_6:\n  \"y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow> (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\"", "lemma L_def:\n  \"L = 1\\<^sup>\\<circ> * bot\"", "lemma one_circ_split:\n  \"1\\<^sup>\\<circ> = L \\<squnion> 1\"", "lemma one_circ_circ_split:\n  \"1\\<^sup>\\<circ>\\<^sup>\\<circ> = L \\<squnion> 1\"", "lemma sub_mult_one_circ:\n  \"x * 1\\<^sup>\\<circ> \\<le> 1\\<^sup>\\<circ> * x\"", "lemma one_circ_mult_split_2:\n  \"1\\<^sup>\\<circ> * x = x * 1\\<^sup>\\<circ> \\<squnion> L\"", "lemma sub_mult_one_circ_split:\n  \"x * 1\\<^sup>\\<circ> \\<le> x \\<squnion> L\"", "lemma sub_mult_one_circ_split_2:\n  \"x * 1\\<^sup>\\<circ> \\<le> x \\<squnion> 1\\<^sup>\\<circ>\"", "lemma L_split:\n  \"x * L \\<le> x * bot \\<squnion> L\"", "lemma L_left_zero:\n  \"L * x = L\"", "lemma one_circ_L:\n  \"1\\<^sup>\\<circ> * L = L\"", "lemma mult_L_circ:\n  \"(x * L)\\<^sup>\\<circ> = 1 \\<squnion> x * L\"", "lemma mult_L_circ_mult:\n  \"(x * L)\\<^sup>\\<circ> * y = y \\<squnion> x * L\"", "lemma circ_L:\n  \"L\\<^sup>\\<circ> = L \\<squnion> 1\"", "lemma L_below_one_circ:\n  \"L \\<le> 1\\<^sup>\\<circ>\"", "lemma circ_circ_mult_1:\n  \"x\\<^sup>\\<circ> * 1\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\"", "lemma circ_circ_mult:\n  \"1\\<^sup>\\<circ> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\"", "lemma circ_circ_split:\n  \"x\\<^sup>\\<circ>\\<^sup>\\<circ> = L \\<squnion> x\\<^sup>\\<circ>\"", "lemma circ_sup_6:\n  \"L \\<squnion> (x \\<squnion> y)\\<^sup>\\<circ> = (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\"", "lemma one_circ_split:\n  \"1\\<^sup>\\<circ> = L \\<squnion> 1\"", "lemma one_circ_mult_split:\n  \"1\\<^sup>\\<circ> * x = L \\<squnion> x\"", "lemma sub_mult_one_circ_split:\n  \"x * 1\\<^sup>\\<circ> \\<le> x \\<squnion> L\"", "lemma sub_mult_one_circ_split_2:\n  \"x * 1\\<^sup>\\<circ> \\<le> x \\<squnion> 1\\<^sup>\\<circ>\"", "lemma L_split:\n  \"x * L \\<le> x * bot \\<squnion> L\"", "lemma circ_left_induct_mult_L:\n  \"L \\<le> x \\<Longrightarrow> x * y \\<le> x \\<Longrightarrow> x * y\\<^sup>\\<circ> \\<le> x\"", "lemma circ_left_induct_mult_iff_L:\n  \"L \\<le> x \\<Longrightarrow> x * y \\<le> x \\<longleftrightarrow> x * y\\<^sup>\\<circ> \\<le> x\"", "lemma circ_left_induct_L:\n  \"L \\<le> x \\<Longrightarrow> x * y \\<squnion> z \\<le> x \\<Longrightarrow> z * y\\<^sup>\\<circ> \\<le> x\""], "translations": [["", "lemma circ_mult_sub:\n  \"1 \\<squnion> x * (y * x)\\<^sup>\\<circ> * y \\<le> (x * y)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rf (x * (y * x)\\<^sup>\\<circ>) y \\<le> (x * y)\\<^sup>\\<circ>", "by (metis sup_right_isotone circ_left_slide circ_left_unfold mult_assoc mult_right_isotone)"], ["", "lemma circ_right_unfold_sub:\n  \"1 \\<squnion> x\\<^sup>\\<circ> * x \\<le> x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rf (x\\<^sup>\\<circ>) x \\<le> x\\<^sup>\\<circ>", "by (metis circ_mult_sub mult_1_left mult_1_right)"], ["", "lemma circ_zero:\n  \"bot\\<^sup>\\<circ> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot\\<^sup>\\<circ> = (1::'a)", "by (metis sup_monoid.add_0_right circ_left_unfold mult_left_zero)"], ["", "lemma circ_increasing:\n  \"x \\<le> x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x\\<^sup>\\<circ>", "by (metis le_supI2 circ_left_unfold circ_right_unfold_sub mult_1_left mult_right_sub_dist_sup_left order_trans)"], ["", "lemma circ_reflexive:\n  \"1 \\<le> x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive (x\\<^sup>\\<circ>)", "by (metis sup_left_divisibility circ_left_unfold)"], ["", "lemma circ_mult_increasing:\n  \"x \\<le> x * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x * x\\<^sup>\\<circ>", "by (metis circ_reflexive mult_right_isotone mult_1_right)"], ["", "lemma circ_mult_increasing_2:\n  \"x \\<le> x\\<^sup>\\<circ> * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x\\<^sup>\\<circ> * x", "by (metis circ_reflexive mult_left_isotone mult_1_left)"], ["", "lemma circ_transitive_equal:\n  \"x\\<^sup>\\<circ> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent (x\\<^sup>\\<circ>)", "by (metis sup_idem circ_sup_1 circ_left_unfold mult_assoc)"], ["", "text \\<open>\nWhile iteration is not idempotent, a fixpoint is reached after applying this operation twice.\nIteration is idempotent for the unit.\n\\<close>"], ["", "lemma circ_circ_circ:\n  \"x\\<^sup>\\<circ>\\<^sup>\\<circ>\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ>\\<^sup>\\<circ>\\<^sup>\\<circ> =\n    x\\<^sup>\\<circ>\\<^sup>\\<circ>", "by (metis sup_idem circ_sup_1 circ_increasing circ_transitive_equal le_iff_sup)"], ["", "lemma circ_one:\n  \"1\\<^sup>\\<circ> = 1\\<^sup>\\<circ>\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> = (1::'a)\\<^sup>\\<circ>\\<^sup>\\<circ>", "by (metis circ_circ_circ circ_zero)"], ["", "lemma circ_sup_sub:\n  \"(x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<circ>", "by (metis circ_sup_1 circ_left_slide)"], ["", "lemma circ_plus_one:\n  \"x\\<^sup>\\<circ> = 1 \\<squnion> x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> = (1::'a) \\<squnion> x\\<^sup>\\<circ>", "by (metis le_iff_sup circ_reflexive)"], ["", "text \\<open>\nIteration satisfies a characteristic property of reflexive transitive closures.\n\\<close>"], ["", "lemma circ_rtc_2:\n  \"1 \\<squnion> x \\<squnion> x\\<^sup>\\<circ> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sf x (x\\<^sup>\\<circ>) = x\\<^sup>\\<circ>", "by (metis sup_assoc circ_increasing circ_plus_one circ_transitive_equal le_iff_sup)"], ["", "lemma mult_zero_circ:\n  \"(x * bot)\\<^sup>\\<circ> = 1 \\<squnion> x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * bot)\\<^sup>\\<circ> = Rf x bot", "by (metis circ_left_unfold mult_assoc mult_left_zero)"], ["", "lemma mult_zero_sup_circ:\n  \"(x \\<squnion> y * bot)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * (y * bot)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y * bot)\\<^sup>\\<circ> =\n    x\\<^sup>\\<circ> * (y * bot)\\<^sup>\\<circ>", "by (metis circ_sup_1 mult_assoc mult_left_zero)"], ["", "lemma circ_plus_sub:\n  \"x\\<^sup>\\<circ> * x \\<le> x * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * x \\<le> x * x\\<^sup>\\<circ>", "by (metis circ_left_slide mult_1_left mult_1_right)"], ["", "lemma circ_loop_fixpoint:\n  \"y * (y\\<^sup>\\<circ> * z) \\<squnion> z = y\\<^sup>\\<circ> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * (y\\<^sup>\\<circ> * z) \\<squnion> z = y\\<^sup>\\<circ> * z", "by (metis sup_commute circ_left_unfold mult_assoc mult_1_left mult_right_dist_sup)"], ["", "lemma left_plus_below_circ:\n  \"x * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ>", "by (metis sup.cobounded2 circ_left_unfold)"], ["", "lemma right_plus_below_circ:\n  \"x\\<^sup>\\<circ> * x \\<le> x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * x \\<le> x\\<^sup>\\<circ>", "using circ_right_unfold_sub"], ["proof (prove)\nusing this:\n  Rf (?x\\<^sup>\\<circ>) ?x \\<le> ?x\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * x \\<le> x\\<^sup>\\<circ>", "by auto"], ["", "lemma circ_sup_upper_bound:\n  \"x \\<le> z\\<^sup>\\<circ> \\<Longrightarrow> y \\<le> z\\<^sup>\\<circ> \\<Longrightarrow> x \\<squnion> y \\<le> z\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> z\\<^sup>\\<circ>; y \\<le> z\\<^sup>\\<circ>\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y \\<le> z\\<^sup>\\<circ>", "by simp"], ["", "lemma circ_mult_upper_bound:\n  \"x \\<le> z\\<^sup>\\<circ> \\<Longrightarrow> y \\<le> z\\<^sup>\\<circ> \\<Longrightarrow> x * y \\<le> z\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> z\\<^sup>\\<circ>; y \\<le> z\\<^sup>\\<circ>\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> z\\<^sup>\\<circ>", "by (metis mult_isotone circ_transitive_equal)"], ["", "lemma circ_sub_dist:\n  \"x\\<^sup>\\<circ> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>", "by (metis circ_sup_sub circ_plus_one mult_1_left mult_right_sub_dist_sup_left order_trans)"], ["", "lemma circ_sub_dist_1:\n  \"x \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> (x \\<squnion> y)\\<^sup>\\<circ>", "using circ_increasing le_supE"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x\\<^sup>\\<circ>\n  \\<lbrakk>?a \\<squnion> ?b \\<le> ?x;\n   \\<lbrakk>?a \\<le> ?x; ?b \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. x \\<le> (x \\<squnion> y)\\<^sup>\\<circ>", "by blast"], ["", "lemma circ_sub_dist_2:\n  \"x * y \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<le> (x \\<squnion> y)\\<^sup>\\<circ>", "by (metis sup_commute circ_mult_upper_bound circ_sub_dist_1)"], ["", "lemma circ_sub_dist_3:\n  \"x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>", "by (metis sup_commute circ_mult_upper_bound circ_sub_dist)"], ["", "lemma circ_isotone:\n  \"x \\<le> y \\<Longrightarrow> x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ>", "by (metis circ_sub_dist le_iff_sup)"], ["", "lemma circ_sup_2:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> \\<le> (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ>\n    \\<le> (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis sup.bounded_iff circ_increasing circ_isotone circ_reflexive mult_isotone mult_1_left mult_1_right)"], ["", "lemma circ_sup_one_left_unfold:\n  \"1 \\<le> x \\<Longrightarrow> x * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive x \\<Longrightarrow> x * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>", "by (metis antisym le_iff_sup mult_1_left mult_right_sub_dist_sup_left left_plus_below_circ)"], ["", "lemma circ_sup_one_right_unfold:\n  \"1 \\<le> x \\<Longrightarrow> x\\<^sup>\\<circ> * x = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive x \\<Longrightarrow> x\\<^sup>\\<circ> * x = x\\<^sup>\\<circ>", "by (metis antisym le_iff_sup mult_left_sub_dist_sup_left mult_1_right right_plus_below_circ)"], ["", "lemma circ_decompose_4:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * (y\\<^sup>\\<circ> * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> =\n    x\\<^sup>\\<circ> * (y\\<^sup>\\<circ> * x\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis sup_assoc sup_commute circ_sup_1 circ_loop_fixpoint circ_plus_one circ_rtc_2 circ_transitive_equal mult_assoc)"], ["", "lemma circ_decompose_5:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> = (y\\<^sup>\\<circ> * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> =\n    (y\\<^sup>\\<circ> * x\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis circ_decompose_4 circ_loop_fixpoint antisym mult_right_sub_dist_sup_right mult_assoc)"], ["", "lemma circ_decompose_6:\n  \"x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ> = y\\<^sup>\\<circ> * (x * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ> =\n    y\\<^sup>\\<circ> * (x * y\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis sup_commute circ_sup_1)"], ["", "lemma circ_decompose_7:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ> * (x \\<squnion> y)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> =\n    x\\<^sup>\\<circ> * y\\<^sup>\\<circ> * (x \\<squnion> y)\\<^sup>\\<circ>", "by (metis circ_sup_1 circ_decompose_6 circ_transitive_equal mult_assoc)"], ["", "lemma circ_decompose_8:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = (x \\<squnion> y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> =\n    (x \\<squnion> y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis antisym eq_refl mult_assoc mult_isotone mult_1_right circ_mult_upper_bound circ_reflexive circ_sub_dist_3)"], ["", "lemma circ_decompose_9:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ> * (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> =\n    x\\<^sup>\\<circ> * y\\<^sup>\\<circ> *\n    (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis circ_decompose_4 mult_assoc)"], ["", "lemma circ_decompose_10:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> = (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> =\n    (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> * x\\<^sup>\\<circ> *\n    y\\<^sup>\\<circ>", "by (metis sup_ge2 circ_loop_fixpoint circ_reflexive circ_sup_one_right_unfold mult_assoc order_trans)"], ["", "lemma circ_back_loop_prefixpoint:\n  \"(z * y\\<^sup>\\<circ>) * y \\<squnion> z \\<le> z * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * y\\<^sup>\\<circ> * y \\<squnion> z \\<le> z * y\\<^sup>\\<circ>", "by (metis sup.bounded_iff circ_left_unfold mult_assoc mult_left_sub_dist_sup_left mult_right_isotone mult_1_right right_plus_below_circ)"], ["", "text \\<open>\nWe obtain the fixpoint and prefixpoint properties of iteration, but not least or greatest fixpoint properties.\n\\<close>"], ["", "lemma circ_loop_is_fixpoint:\n  \"is_fixpoint (\\<lambda>x . y * x \\<squnion> z) (y\\<^sup>\\<circ> * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fixpoint (\\<lambda>x. y * x \\<squnion> z) (y\\<^sup>\\<circ> * z)", "by (metis circ_loop_fixpoint is_fixpoint_def)"], ["", "lemma circ_back_loop_is_prefixpoint:\n  \"is_prefixpoint (\\<lambda>x . x * y \\<squnion> z) (z * y\\<^sup>\\<circ>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefixpoint (\\<lambda>x. x * y \\<squnion> z) (z * y\\<^sup>\\<circ>)", "by (metis circ_back_loop_prefixpoint is_prefixpoint_def)"], ["", "lemma circ_circ_sup:\n  \"(1 \\<squnion> x)\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<squnion> x)\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>", "by (metis sup_commute circ_sup_1 circ_decompose_4 circ_zero mult_1_right)"], ["", "lemma circ_circ_mult_sub:\n  \"x\\<^sup>\\<circ> * 1\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ>\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * (1::'a)\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ>\\<^sup>\\<circ>", "by (metis circ_increasing circ_isotone circ_mult_upper_bound circ_reflexive)"], ["", "lemma left_plus_circ:\n  \"(x * x\\<^sup>\\<circ>)\\<^sup>\\<circ> = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * x\\<^sup>\\<circ>)\\<^sup>\\<circ> = x\\<^sup>\\<circ>", "by (metis circ_left_unfold circ_sup_1 mult_1_right mult_sub_right_one sup.absorb1 mult_assoc)"], ["", "lemma right_plus_circ:\n  \"(x\\<^sup>\\<circ> * x)\\<^sup>\\<circ> = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * x)\\<^sup>\\<circ> = x\\<^sup>\\<circ>", "by (metis sup_commute circ_isotone circ_loop_fixpoint circ_plus_sub circ_sub_dist eq_iff left_plus_circ)"], ["", "lemma circ_square:\n  \"(x * x)\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * x)\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ>", "by (metis circ_increasing circ_isotone left_plus_circ mult_right_isotone)"], ["", "lemma circ_mult_sub_sup:\n  \"(x * y)\\<^sup>\\<circ> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<circ> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>", "by (metis sup_ge1 sup_ge2 circ_isotone circ_square mult_isotone order_trans)"], ["", "lemma circ_sup_mult_zero:\n  \"x\\<^sup>\\<circ> * y = (x \\<squnion> y * bot)\\<^sup>\\<circ> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y = (x \\<squnion> y * bot)\\<^sup>\\<circ> * y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y = (x \\<squnion> y * bot)\\<^sup>\\<circ> * y", "have \"(x \\<squnion> y * bot)\\<^sup>\\<circ> * y = x\\<^sup>\\<circ> * (1 \\<squnion> y * bot) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y * bot)\\<^sup>\\<circ> * y =\n    x\\<^sup>\\<circ> * Rf y bot * y", "by (metis mult_zero_sup_circ mult_zero_circ)"], ["proof (state)\nthis:\n  (x \\<squnion> y * bot)\\<^sup>\\<circ> * y = x\\<^sup>\\<circ> * Rf y bot * y\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y = (x \\<squnion> y * bot)\\<^sup>\\<circ> * y", "also"], ["proof (state)\nthis:\n  (x \\<squnion> y * bot)\\<^sup>\\<circ> * y = x\\<^sup>\\<circ> * Rf y bot * y\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y = (x \\<squnion> y * bot)\\<^sup>\\<circ> * y", "have \"... = x\\<^sup>\\<circ> * (y \\<squnion> y * bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * Rf y bot * y =\n    x\\<^sup>\\<circ> * (y \\<squnion> y * bot)", "by (metis mult_assoc mult_1_left mult_left_zero mult_right_dist_sup)"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> * Rf y bot * y = x\\<^sup>\\<circ> * (y \\<squnion> y * bot)\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y = (x \\<squnion> y * bot)\\<^sup>\\<circ> * y", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> * Rf y bot * y = x\\<^sup>\\<circ> * (y \\<squnion> y * bot)\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y = (x \\<squnion> y * bot)\\<^sup>\\<circ> * y", "have \"... = x\\<^sup>\\<circ> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * (y \\<squnion> y * bot) = x\\<^sup>\\<circ> * y", "by (metis sup_commute le_iff_sup zero_right_mult_decreasing)"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> * (y \\<squnion> y * bot) = x\\<^sup>\\<circ> * y\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y = (x \\<squnion> y * bot)\\<^sup>\\<circ> * y", "finally"], ["proof (chain)\npicking this:\n  (x \\<squnion> y * bot)\\<^sup>\\<circ> * y = x\\<^sup>\\<circ> * y", "show ?thesis"], ["proof (prove)\nusing this:\n  (x \\<squnion> y * bot)\\<^sup>\\<circ> * y = x\\<^sup>\\<circ> * y\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y = (x \\<squnion> y * bot)\\<^sup>\\<circ> * y", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> * y = (x \\<squnion> y * bot)\\<^sup>\\<circ> * y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma troeger_1:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * (1 \\<squnion> y * (x \\<squnion> y)\\<^sup>\\<circ>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> =\n    x\\<^sup>\\<circ> * Rf y ((x \\<squnion> y)\\<^sup>\\<circ>)", "by (metis circ_sup_1 circ_left_unfold mult_assoc)"], ["", "lemma troeger_2:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> * z = x\\<^sup>\\<circ> * (y * (x \\<squnion> y)\\<^sup>\\<circ> * z \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> * z =\n    x\\<^sup>\\<circ> * (y * (x \\<squnion> y)\\<^sup>\\<circ> * z \\<squnion> z)", "by (metis circ_sup_1 circ_loop_fixpoint mult_assoc)"], ["", "lemma troeger_3:\n  \"(x \\<squnion> y * bot)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * (1 \\<squnion> y * bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y * bot)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * Rf y bot", "by (metis mult_zero_sup_circ mult_zero_circ)"], ["", "lemma circ_sup_sub_sup_one_1:\n  \"x \\<squnion> y \\<le> x\\<^sup>\\<circ> * (1 \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<le> x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y)", "by (metis circ_increasing circ_left_unfold mult_1_left mult_1_right mult_left_sub_dist_sup mult_right_sub_dist_sup_left order_trans sup_mono)"], ["", "lemma circ_sup_sub_sup_one_2:\n  \"x\\<^sup>\\<circ> * (x \\<squnion> y) \\<le> x\\<^sup>\\<circ> * (1 \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * (x \\<squnion> y)\n    \\<le> x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y)", "by (metis circ_sup_sub_sup_one_1 circ_transitive_equal mult_assoc mult_right_isotone)"], ["", "lemma circ_sup_sub_sup_one:\n  \"x * x\\<^sup>\\<circ> * (x \\<squnion> y) \\<le> x * x\\<^sup>\\<circ> * (1 \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x\\<^sup>\\<circ> * (x \\<squnion> y)\n    \\<le> x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y)", "by (metis circ_sup_sub_sup_one_2 mult_assoc mult_right_isotone)"], ["", "lemma circ_square_2:\n  \"(x * x)\\<^sup>\\<circ> * (x \\<squnion> 1) \\<le> x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * x)\\<^sup>\\<circ> * (x \\<squnion> (1::'a)) \\<le> x\\<^sup>\\<circ>", "by (metis sup.bounded_iff circ_increasing circ_mult_upper_bound circ_reflexive circ_square)"], ["", "lemma circ_extra_circ:\n  \"(y * x\\<^sup>\\<circ>)\\<^sup>\\<circ> = (y * y\\<^sup>\\<circ> * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ> =\n    (y * y\\<^sup>\\<circ> * x\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis circ_decompose_6 circ_transitive_equal left_plus_circ mult_assoc)"], ["", "lemma circ_circ_sub_mult:\n  \"1\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ>\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ>\\<^sup>\\<circ>", "by (metis circ_increasing circ_isotone circ_mult_upper_bound circ_reflexive)"], ["", "lemma circ_decompose_11:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> = (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> =\n    (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "by (metis circ_decompose_10 circ_decompose_4 circ_decompose_5 circ_decompose_9 left_plus_circ)"], ["", "lemma circ_mult_below_circ_circ:\n  \"(x * y)\\<^sup>\\<circ> \\<le> (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<circ>\n    \\<le> (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "by (metis circ_increasing circ_isotone circ_reflexive dual_order.trans mult_left_isotone mult_right_isotone mult_1_right)"], ["", "(*\nlemma circ_right_unfold: \"1 \\<squnion> x\\<^sup>\\<circ> * x = x\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma circ_mult: \"1 \\<squnion> x * (y * x)\\<^sup>\\<circ> * y = (x * y)\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma circ_slide: \"(x * y)\\<^sup>\\<circ> * x = x * (y * x)\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma circ_plus_same: \"x\\<^sup>\\<circ> * x = x * x\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"1\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * 1\\<^sup>\\<circ>\" nitpick [expect=genuine,card=7] oops\nlemma circ_circ_mult_1: \"x\\<^sup>\\<circ> * 1\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\" nitpick [expect=genuine,card=7] oops\nlemma \"x\\<^sup>\\<circ> * 1\\<^sup>\\<circ> \\<le> 1\\<^sup>\\<circ> * x\\<^sup>\\<circ>\" nitpick [expect=genuine,card=7] oops\nlemma circ_circ_mult: \"1\\<^sup>\\<circ> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\" nitpick [expect=genuine,card=7] oops\nlemma circ_sup: \"(x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> = (x \\<squnion> y)\\<^sup>\\<circ>\" nitpick [expect=genuine,card=8] oops\nlemma circ_unfold_sum: \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * y * (x \\<squnion> y)\\<^sup>\\<circ>\" nitpick [expect=genuine,card=7] oops\n\nlemma mult_zero_sup_circ_2: \"(x \\<squnion> y * bot)\\<^sup>\\<circ> = x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * y * bot\" nitpick [expect=genuine,card=7] oops\nlemma sub_mult_one_circ: \"x * 1\\<^sup>\\<circ> \\<le> 1\\<^sup>\\<circ> * x\" nitpick [expect=genuine] oops\nlemma circ_back_loop_fixpoint: \"(z * y\\<^sup>\\<circ>) * y \\<squnion> z = z * y\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma circ_back_loop_is_fixpoint: \"is_fixpoint (\\<lambda>x . x * y \\<squnion> z) (z * y\\<^sup>\\<circ>)\" nitpick [expect=genuine] oops\nlemma \"x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<le> (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\" nitpick [expect=genuine,card=7] oops\n*)"], ["", "end"], ["", "text \\<open>\nThe next class considers the interaction of iteration with a greatest element.\n\\<close>"], ["", "class bounded_left_conway_semiring = bounded_idempotent_left_semiring + left_conway_semiring\nbegin"], ["", "lemma circ_top:\n  \"top\\<^sup>\\<circ> = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top\\<^sup>\\<circ> = top", "by (simp add: antisym circ_increasing)"], ["", "lemma circ_right_top:\n  \"x\\<^sup>\\<circ> * top = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. times_top_class.total (x\\<^sup>\\<circ>)", "by (metis sup_right_top circ_loop_fixpoint)"], ["", "lemma circ_left_top:\n  \"top * x\\<^sup>\\<circ> = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective (x\\<^sup>\\<circ>)", "by (metis circ_right_top circ_top circ_decompose_11)"], ["", "lemma mult_top_circ:\n  \"(x * top)\\<^sup>\\<circ> = 1 \\<squnion> x * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * top)\\<^sup>\\<circ> = Rf x top", "by (metis circ_left_top circ_left_unfold mult_assoc)"], ["", "end"], ["", "class left_zero_conway_semiring = idempotent_left_zero_semiring + left_conway_semiring\nbegin"], ["", "lemma mult_zero_sup_circ_2:\n  \"(x \\<squnion> y * bot)\\<^sup>\\<circ> = x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * y * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y * bot)\\<^sup>\\<circ> =\n    x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * y * bot", "by (metis mult_assoc mult_left_dist_sup mult_1_right troeger_3)"], ["", "lemma circ_unfold_sum:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * y * (x \\<squnion> y)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> =\n    x\\<^sup>\\<circ> \\<squnion>\n    x\\<^sup>\\<circ> * y * (x \\<squnion> y)\\<^sup>\\<circ>", "by (metis mult_assoc mult_left_dist_sup mult_1_right troeger_1)"], ["", "end"], ["", "text \\<open>\nThe next class assumes the full sliding equation.\n\\<close>"], ["", "class left_conway_semiring_1 = left_conway_semiring +\n  assumes circ_right_slide: \"x * (y * x)\\<^sup>\\<circ> \\<le> (x * y)\\<^sup>\\<circ> * x\"\nbegin"], ["", "lemma circ_slide_1:\n  \"x * (y * x)\\<^sup>\\<circ> = (x * y)\\<^sup>\\<circ> * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y * x)\\<^sup>\\<circ> = (x * y)\\<^sup>\\<circ> * x", "by (metis antisym circ_left_slide circ_right_slide)"], ["", "text \\<open>\nThis implies the full unfold rules and Conway's productstar.\n\\<close>"], ["", "lemma circ_right_unfold_1:\n  \"1 \\<squnion> x\\<^sup>\\<circ> * x = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rf (x\\<^sup>\\<circ>) x = x\\<^sup>\\<circ>", "by (metis circ_left_unfold circ_slide_1 mult_1_left mult_1_right)"], ["", "lemma circ_mult_1:\n  \"(x * y)\\<^sup>\\<circ> = 1 \\<squnion> x * (y * x)\\<^sup>\\<circ> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<circ> = Rf (x * (y * x)\\<^sup>\\<circ>) y", "by (metis circ_left_unfold circ_slide_1 mult_assoc)"], ["", "lemma circ_sup_9:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> =\n    (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "by (metis circ_sup_1 circ_slide_1)"], ["", "lemma circ_plus_same:\n  \"x\\<^sup>\\<circ> * x = x * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * x = x * x\\<^sup>\\<circ>", "by (metis circ_slide_1 mult_1_left mult_1_right)"], ["", "lemma circ_decompose_12:\n  \"x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<le> (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n    \\<le> (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "by (metis circ_sup_9 circ_sub_dist_3)"], ["", "end"], ["", "class left_zero_conway_semiring_1 = left_zero_conway_semiring + left_conway_semiring_1\nbegin"], ["", "lemma circ_back_loop_fixpoint:\n  \"(z * y\\<^sup>\\<circ>) * y \\<squnion> z = z * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * y\\<^sup>\\<circ> * y \\<squnion> z = z * y\\<^sup>\\<circ>", "by (metis sup_commute circ_left_unfold circ_plus_same mult_assoc mult_left_dist_sup mult_1_right)"], ["", "lemma circ_back_loop_is_fixpoint:\n  \"is_fixpoint (\\<lambda>x . x * y \\<squnion> z) (z * y\\<^sup>\\<circ>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fixpoint (\\<lambda>x. x * y \\<squnion> z) (z * y\\<^sup>\\<circ>)", "by (metis circ_back_loop_fixpoint is_fixpoint_def)"], ["", "lemma circ_elimination:\n  \"x * y = bot \\<Longrightarrow> x * y\\<^sup>\\<circ> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = bot \\<Longrightarrow> x * y\\<^sup>\\<circ> \\<le> x", "by (metis sup_monoid.add_0_left circ_back_loop_fixpoint circ_plus_same mult_assoc mult_left_zero order_refl)"], ["", "end"], ["", "subsection \\<open>Iterings\\<close>"], ["", "text \\<open>\nThis section adds simulation axioms to Conway semirings.\nWe consider several classes with increasingly general simulation axioms.\n\\<close>"], ["", "class itering_1 = left_conway_semiring_1 +\n  assumes circ_simulate: \"z * x \\<le> y * z \\<longrightarrow> z * x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * z\"\nbegin"], ["", "lemma circ_circ_mult:\n  \"1\\<^sup>\\<circ> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>", "by (metis antisym circ_circ_sup circ_reflexive circ_simulate circ_sub_dist_3 circ_sup_one_left_unfold circ_transitive_equal mult_1_left order_refl)"], ["", "lemma sub_mult_one_circ:\n  \"x * 1\\<^sup>\\<circ> \\<le> 1\\<^sup>\\<circ> * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a)\\<^sup>\\<circ> \\<le> (1::'a)\\<^sup>\\<circ> * x", "by (metis circ_simulate mult_1_left mult_1_right order_refl)"], ["", "text \\<open>\nThe left simulation axioms is enough to prove a basic import property of tests.\n\\<close>"], ["", "lemma circ_import:\n  assumes \"p \\<le> p * p\"\n      and \"p \\<le> 1\"\n      and \"p * x \\<le> x * p\"\n    shows \"p * x\\<^sup>\\<circ> = p * (p * x)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * x\\<^sup>\\<circ> = p * (p * x)\\<^sup>\\<circ>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p * x\\<^sup>\\<circ> = p * (p * x)\\<^sup>\\<circ>", "have \"p * x \\<le> p * (p * x * p) * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * x \\<le> p * (p * x * p) * p", "by (metis assms coreflexive_transitive eq_iff test_preserves_equation mult_assoc)"], ["proof (state)\nthis:\n  p * x \\<le> p * (p * x * p) * p\n\ngoal (1 subgoal):\n 1. p * x\\<^sup>\\<circ> = p * (p * x)\\<^sup>\\<circ>", "hence \"p * x\\<^sup>\\<circ> \\<le> p * (p * x)\\<^sup>\\<circ>\""], ["proof (prove)\nusing this:\n  p * x \\<le> p * (p * x * p) * p\n\ngoal (1 subgoal):\n 1. p * x\\<^sup>\\<circ> \\<le> p * (p * x)\\<^sup>\\<circ>", "by (metis (no_types) assms circ_simulate circ_slide_1 test_preserves_equation)"], ["proof (state)\nthis:\n  p * x\\<^sup>\\<circ> \\<le> p * (p * x)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. p * x\\<^sup>\\<circ> = p * (p * x)\\<^sup>\\<circ>", "thus ?thesis"], ["proof (prove)\nusing this:\n  p * x\\<^sup>\\<circ> \\<le> p * (p * x)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. p * x\\<^sup>\\<circ> = p * (p * x)\\<^sup>\\<circ>", "by (metis assms(2) circ_isotone mult_left_isotone mult_1_left mult_right_isotone antisym)"], ["proof (state)\nthis:\n  p * x\\<^sup>\\<circ> = p * (p * x)\\<^sup>\\<circ>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\nIncluding generalisations of both simulation axioms allows us to prove separation rules.\n\\<close>"], ["", "class itering_2 = left_conway_semiring_1 +\n  assumes circ_simulate_right: \"z * x \\<le> y * z \\<squnion> w \\<longrightarrow> z * x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * (z \\<squnion> w * x\\<^sup>\\<circ>)\"\n  assumes circ_simulate_left: \"x * z \\<le> z * y \\<squnion> w \\<longrightarrow> x\\<^sup>\\<circ> * z \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>\"\nbegin"], ["", "subclass itering_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.itering_1 circ (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z x y.\n       z * x \\<le> y * z \\<longrightarrow>\n       z * x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * z", "by (metis sup_monoid.add_0_right circ_simulate_right mult_left_zero)"], ["", "lemma circ_simulate_left_1:\n  \"x * z \\<le> z * y \\<Longrightarrow> x\\<^sup>\\<circ> * z \\<le> z * y\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<le> z * y \\<Longrightarrow>\n    x\\<^sup>\\<circ> * z\n    \\<le> z * y\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * bot", "by (metis sup_monoid.add_0_right circ_simulate_left mult_assoc mult_left_zero mult_right_dist_sup)"], ["", "lemma circ_separate_1:\n  assumes \"y * x \\<le> x * y\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "have \"y\\<^sup>\\<circ> * x \\<le> x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\n    \\<le> x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot", "by (metis assms circ_simulate_left_1)"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> * x\n  \\<le> x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "hence \"y\\<^sup>\\<circ> * x * y\\<^sup>\\<circ> \\<le> x * y\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot * y\\<^sup>\\<circ>\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<circ> * x\n  \\<le> x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x * y\\<^sup>\\<circ>\n    \\<le> x * y\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<squnion>\n          y\\<^sup>\\<circ> * bot * y\\<^sup>\\<circ>", "by (metis mult_assoc mult_left_isotone mult_right_dist_sup)"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> * x * y\\<^sup>\\<circ>\n  \\<le> x * y\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<squnion>\n        y\\<^sup>\\<circ> * bot * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> * x * y\\<^sup>\\<circ>\n  \\<le> x * y\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<squnion>\n        y\\<^sup>\\<circ> * bot * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "have \"... = x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<squnion>\n    y\\<^sup>\\<circ> * bot * y\\<^sup>\\<circ> =\n    x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot", "by (metis circ_transitive_equal mult_assoc mult_left_zero)"], ["proof (state)\nthis:\n  x * y\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<squnion>\n  y\\<^sup>\\<circ> * bot * y\\<^sup>\\<circ> =\n  x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "finally"], ["proof (chain)\npicking this:\n  y\\<^sup>\\<circ> * x * y\\<^sup>\\<circ>\n  \\<le> x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot", "have \"y\\<^sup>\\<circ> * (x * y\\<^sup>\\<circ>)\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * (y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot)\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<circ> * x * y\\<^sup>\\<circ>\n  \\<le> x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * (x * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> *\n          (y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot)", "using circ_simulate_right mult_assoc"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<circ> * x * y\\<^sup>\\<circ>\n  \\<le> x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\n  ?z * ?x \\<le> ?y * ?z \\<squnion> ?w \\<longrightarrow>\n  ?z * ?x\\<^sup>\\<circ>\n  \\<le> ?y\\<^sup>\\<circ> * (?z \\<squnion> ?w * ?x\\<^sup>\\<circ>)\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * (x * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> *\n          (y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot)", "by fastforce"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> * (x * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> * (y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot)\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> * (x * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> * (y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot)\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "have \"... = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * (y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot) =\n    x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (simp add: sup_absorb1 zero_right_mult_decreasing)"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> * (y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot) =\n  x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "finally"], ["proof (chain)\npicking this:\n  y\\<^sup>\\<circ> * (x * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "have \"(x \\<squnion> y)\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<circ> * (x * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (simp add: circ_decompose_6 circ_sup_1)"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x \\<squnion> y)\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (simp add: antisym circ_sub_dist_3)"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circ_circ_mult_1:\n  \"x\\<^sup>\\<circ> * 1\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * (1::'a)\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>", "by (metis sup_commute circ_circ_sup circ_separate_1 mult_1_left mult_1_right order_refl)"], ["", "end"], ["", "text \\<open>\nWith distributivity, we also get Back's atomicity refinement theorem.\n\\<close>"], ["", "class itering_3 = itering_2 + left_zero_conway_semiring_1\nbegin"], ["", "lemma circ_simulate_1:\n  assumes \"y * x \\<le> x * y\"\n    shows \"y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "have \"y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y", "by (metis assms circ_simulate)"], ["proof (state)\nthis:\n  y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "hence \"y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\""], ["proof (prove)\nusing this:\n  y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot", "by (metis circ_simulate_left_1)"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis sup_assoc sup_monoid.add_0_right circ_loop_fixpoint mult_assoc mult_left_zero mult_zero_sup_circ_2)"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atomicity_refinement:\n  assumes \"s = s * q\"\n      and \"x = q * x\"\n      and \"q * b = bot\"\n      and \"r * b \\<le> b * r\"\n      and \"r * l \\<le> l * r\"\n      and \"x * l \\<le> l * x\"\n      and \"b * l \\<le> l * b\"\n      and \"q * l \\<le> l * q\"\n      and \"r\\<^sup>\\<circ> * q \\<le> q * r\\<^sup>\\<circ>\"\n      and \"q \\<le> 1\"\n    shows \"s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q \\<le> s * (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "have \"(x \\<squnion> b \\<squnion> r) * l \\<le> l * (x \\<squnion> b \\<squnion> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> b \\<squnion> r) * l\n    \\<le> l * (x \\<squnion> b \\<squnion> r)", "using assms(5-7) mult_left_dist_sup mult_right_dist_sup semiring.add_mono"], ["proof (prove)\nusing this:\n  r * l \\<le> l * r\n  x * l \\<le> l * x\n  b * l \\<le> l * b\n  ?x * (?y \\<squnion> ?z) = ?x * ?y \\<squnion> ?x * ?z\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n  \\<lbrakk>?a \\<le> ?b; ?c \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a \\<squnion> ?c \\<le> ?b \\<squnion> ?d\n\ngoal (1 subgoal):\n 1. (x \\<squnion> b \\<squnion> r) * l\n    \\<le> l * (x \\<squnion> b \\<squnion> r)", "by presburger"], ["proof (state)\nthis:\n  (x \\<squnion> b \\<squnion> r) * l \\<le> l * (x \\<squnion> b \\<squnion> r)\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "hence \"s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q = s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q\""], ["proof (prove)\nusing this:\n  (x \\<squnion> b \\<squnion> r) * l \\<le> l * (x \\<squnion> b \\<squnion> r)\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q =\n    s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q", "by (metis sup_commute circ_separate_1 mult_assoc)"], ["proof (state)\nthis:\n  s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q =\n  s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q =\n  s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "have \"... = s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q * (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q =\n    s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n    (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q =\n    s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n    (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>", "have \"(b \\<squnion> r)\\<^sup>\\<circ> = b\\<^sup>\\<circ> * r\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<squnion> r)\\<^sup>\\<circ> = b\\<^sup>\\<circ> * r\\<^sup>\\<circ>", "by (simp add: assms(4) circ_separate_1)"], ["proof (state)\nthis:\n  (b \\<squnion> r)\\<^sup>\\<circ> = b\\<^sup>\\<circ> * r\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q =\n    s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n    (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>", "hence \"b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * (q * (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ>))\\<^sup>\\<circ> = (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ>\""], ["proof (prove)\nusing this:\n  (b \\<squnion> r)\\<^sup>\\<circ> = b\\<^sup>\\<circ> * r\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n    (q * (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ>))\\<^sup>\\<circ> =\n    (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ>", "by (metis (full_types) assms(2) circ_sup_1 sup_assoc sup_commute mult_assoc)"], ["proof (state)\nthis:\n  b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n  (q * (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ>))\\<^sup>\\<circ> =\n  (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q =\n    s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n    (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>", "thus ?thesis"], ["proof (prove)\nusing this:\n  b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n  (q * (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ>))\\<^sup>\\<circ> =\n  (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q =\n    s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n    (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>", "by (metis circ_slide_1 mult_assoc)"], ["proof (state)\nthis:\n  s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q =\n  s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n  (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q =\n  s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n  (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  s * l\\<^sup>\\<circ> * (x \\<squnion> b \\<squnion> r)\\<^sup>\\<circ> * q =\n  s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n  (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "have \"... \\<le> s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q * (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n    (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>\n    \\<le> s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n          (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis assms(9) circ_isotone mult_assoc mult_right_isotone)"], ["proof (state)\nthis:\n  s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n  (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>\n  \\<le> s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n        (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n  (x * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q)\\<^sup>\\<circ>\n  \\<le> s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n        (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "have \"... \\<le> s * q * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n    (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n    \\<le> s * q * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n          (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis assms(1,10) mult_left_isotone mult_right_isotone mult_1_right)"], ["proof (state)\nthis:\n  s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n  (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n  \\<le> s * q * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n        (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  s * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * q *\n  (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n  \\<le> s * q * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n        (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "have \"... \\<le> s * l\\<^sup>\\<circ> * q * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> * (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s * q * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n    (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n    \\<le> s * l\\<^sup>\\<circ> * q * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n          (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis assms(1,8) circ_simulate mult_assoc mult_left_isotone mult_right_isotone)"], ["proof (state)\nthis:\n  s * q * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n  (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n  \\<le> s * l\\<^sup>\\<circ> * q * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n        (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  s * q * l\\<^sup>\\<circ> * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n  (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n  \\<le> s * l\\<^sup>\\<circ> * q * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n        (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "have \"... \\<le> s * l\\<^sup>\\<circ> * r\\<^sup>\\<circ> * (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s * l\\<^sup>\\<circ> * q * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n    (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n    \\<le> s * l\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n          (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis assms(3,10) sup_monoid.add_0_left circ_back_loop_fixpoint circ_plus_same mult_assoc mult_left_zero mult_left_isotone mult_right_isotone mult_1_right)"], ["proof (state)\nthis:\n  s * l\\<^sup>\\<circ> * q * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n  (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n  \\<le> s * l\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n        (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  s * l\\<^sup>\\<circ> * q * b\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n  (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n  \\<le> s * l\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n        (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "have \"... \\<le> s * (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s * l\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n    (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "by (metis sup_commute circ_sup_1 circ_sub_dist_3 mult_assoc mult_right_isotone)"], ["proof (state)\nthis:\n  s * l\\<^sup>\\<circ> * r\\<^sup>\\<circ> *\n  (x * b\\<^sup>\\<circ> * q * r\\<^sup>\\<circ>)\\<^sup>\\<circ>\n  \\<le> s *\n        (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "finally"], ["proof (chain)\npicking this:\n  s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n  \\<le> s *\n        (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "show ?thesis"], ["proof (prove)\nusing this:\n  s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n  \\<le> s *\n        (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n    \\<le> s *\n          (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>", "."], ["proof (state)\nthis:\n  s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<circ> * q\n  \\<le> s *\n        (x * b\\<^sup>\\<circ> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<circ>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\nThe following class contains the most general simulation axioms we consider.\nThey allow us to prove further separation properties.\n\\<close>"], ["", "class itering = idempotent_left_zero_semiring + circ +\n  assumes circ_sup: \"(x \\<squnion> y)\\<^sup>\\<circ> = (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\"\n  assumes circ_mult: \"(x * y)\\<^sup>\\<circ> = 1 \\<squnion> x * (y * x)\\<^sup>\\<circ> * y\"\n  assumes circ_simulate_right_plus: \"z * x \\<le> y * y\\<^sup>\\<circ> * z \\<squnion> w \\<longrightarrow> z * x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * (z \\<squnion> w * x\\<^sup>\\<circ>)\"\n  assumes circ_simulate_left_plus: \"x * z \\<le> z * y\\<^sup>\\<circ> \\<squnion> w \\<longrightarrow> x\\<^sup>\\<circ> * z \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>\"\nbegin"], ["", "lemma circ_right_unfold:\n  \"1 \\<squnion> x\\<^sup>\\<circ> * x = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rf (x\\<^sup>\\<circ>) x = x\\<^sup>\\<circ>", "by (metis circ_mult mult_1_left mult_1_right)"], ["", "lemma circ_slide:\n  \"x * (y * x)\\<^sup>\\<circ> = (x * y)\\<^sup>\\<circ> * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y * x)\\<^sup>\\<circ> = (x * y)\\<^sup>\\<circ> * x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * (y * x)\\<^sup>\\<circ> = (x * y)\\<^sup>\\<circ> * x", "have \"x * (y * x)\\<^sup>\\<circ> = Rf x (y * 1 \\<squnion> y * (x * (y * x)\\<^sup>\\<circ> * y)) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y * x)\\<^sup>\\<circ> =\n    Rf x (y * (1::'a) \\<squnion> y * (x * (y * x)\\<^sup>\\<circ> * y)) * x", "by (metis (no_types) circ_mult mult_1_left mult_1_right mult_left_dist_sup mult_right_dist_sup mult_assoc)"], ["proof (state)\nthis:\n  x * (y * x)\\<^sup>\\<circ> =\n  Rf x (y * (1::'a) \\<squnion> y * (x * (y * x)\\<^sup>\\<circ> * y)) * x\n\ngoal (1 subgoal):\n 1. x * (y * x)\\<^sup>\\<circ> = (x * y)\\<^sup>\\<circ> * x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x * (y * x)\\<^sup>\\<circ> =\n  Rf x (y * (1::'a) \\<squnion> y * (x * (y * x)\\<^sup>\\<circ> * y)) * x\n\ngoal (1 subgoal):\n 1. x * (y * x)\\<^sup>\\<circ> = (x * y)\\<^sup>\\<circ> * x", "by (metis (no_types) circ_mult mult_1_right mult_left_dist_sup mult_assoc)"], ["proof (state)\nthis:\n  x * (y * x)\\<^sup>\\<circ> = (x * y)\\<^sup>\\<circ> * x\n\ngoal:\nNo subgoals!", "qed"], ["", "subclass itering_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.itering_3 circ (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x. Rf x (x\\<^sup>\\<circ>) = x\\<^sup>\\<circ>\n 2. \\<And>x y. (x * y)\\<^sup>\\<circ> * x \\<le> x * (y * x)\\<^sup>\\<circ>\n 3. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<circ> =\n       x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\n 4. \\<And>x y. x * (y * x)\\<^sup>\\<circ> \\<le> (x * y)\\<^sup>\\<circ> * x\n 5. \\<And>z x y w.\n       z * x \\<le> y * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<circ>\n       \\<le> y\\<^sup>\\<circ> * (z \\<squnion> w * x\\<^sup>\\<circ>)\n 6. \\<And>x z y w.\n       x * z \\<le> z * y \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<circ> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>", "apply (metis circ_mult mult_1_left mult_1_right)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x * y)\\<^sup>\\<circ> * x \\<le> x * (y * x)\\<^sup>\\<circ>\n 2. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<circ> =\n       x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\n 3. \\<And>x y. x * (y * x)\\<^sup>\\<circ> \\<le> (x * y)\\<^sup>\\<circ> * x\n 4. \\<And>z x y w.\n       z * x \\<le> y * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<circ>\n       \\<le> y\\<^sup>\\<circ> * (z \\<squnion> w * x\\<^sup>\\<circ>)\n 5. \\<And>x z y w.\n       x * z \\<le> z * y \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<circ> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>", "apply (metis circ_slide order_refl)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<circ> =\n       x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\n 2. \\<And>x y. x * (y * x)\\<^sup>\\<circ> \\<le> (x * y)\\<^sup>\\<circ> * x\n 3. \\<And>z x y w.\n       z * x \\<le> y * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<circ>\n       \\<le> y\\<^sup>\\<circ> * (z \\<squnion> w * x\\<^sup>\\<circ>)\n 4. \\<And>x z y w.\n       x * z \\<le> z * y \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<circ> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>", "apply (metis circ_sup circ_slide)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. x * (y * x)\\<^sup>\\<circ> \\<le> (x * y)\\<^sup>\\<circ> * x\n 2. \\<And>z x y w.\n       z * x \\<le> y * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<circ>\n       \\<le> y\\<^sup>\\<circ> * (z \\<squnion> w * x\\<^sup>\\<circ>)\n 3. \\<And>x z y w.\n       x * z \\<le> z * y \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<circ> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>", "apply (metis circ_slide order_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z x y w.\n       z * x \\<le> y * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<circ>\n       \\<le> y\\<^sup>\\<circ> * (z \\<squnion> w * x\\<^sup>\\<circ>)\n 2. \\<And>x z y w.\n       x * z \\<le> z * y \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<circ> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>", "apply (metis sup_left_isotone circ_right_unfold mult_left_isotone mult_left_sub_dist_sup_left mult_1_right order_trans circ_simulate_right_plus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z y w.\n       x * z \\<le> z * y \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<circ> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>", "by (metis sup_commute sup_ge1 sup_right_isotone circ_mult mult_right_isotone mult_1_right order_trans circ_simulate_left_plus)"], ["", "lemma circ_simulate_right_plus_1:\n  \"z * x \\<le> y * y\\<^sup>\\<circ> * z \\<Longrightarrow> z * x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x \\<le> y * y\\<^sup>\\<circ> * z \\<Longrightarrow>\n    z * x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * z", "by (metis sup_monoid.add_0_right circ_simulate_right_plus mult_left_zero)"], ["", "lemma circ_simulate_left_plus_1:\n  \"x * z \\<le> z * y\\<^sup>\\<circ> \\<Longrightarrow> x\\<^sup>\\<circ> * z \\<le> z * y\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<le> z * y\\<^sup>\\<circ> \\<Longrightarrow>\n    x\\<^sup>\\<circ> * z\n    \\<le> z * y\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * bot", "by (metis sup_monoid.add_0_right circ_simulate_left_plus mult_assoc mult_left_zero mult_right_dist_sup)"], ["", "lemma circ_simulate_2:\n  \"y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<longleftrightarrow> y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>) =\n    (y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n     \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<Longrightarrow>\n    y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n 2. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<Longrightarrow>\n    y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "apply (metis sup_assoc sup_monoid.add_0_right circ_loop_fixpoint circ_simulate_left_plus_1 mult_assoc mult_left_zero mult_zero_sup_circ_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<Longrightarrow>\n    y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis circ_increasing mult_left_isotone order_trans)"], ["", "lemma circ_simulate_absorb:\n  \"y * x \\<le> x \\<Longrightarrow> y\\<^sup>\\<circ> * x \\<le> x \\<squnion> y\\<^sup>\\<circ> * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<le> x \\<Longrightarrow>\n    y\\<^sup>\\<circ> * x \\<le> x \\<squnion> y\\<^sup>\\<circ> * bot", "by (metis circ_simulate_left_plus_1 circ_zero mult_1_right)"], ["", "lemma circ_simulate_3:\n  \"y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> \\<Longrightarrow> y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> \\<Longrightarrow>\n    y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis sup.bounded_iff circ_reflexive circ_simulate_2 le_iff_sup mult_right_isotone mult_1_right)"], ["", "lemma circ_separate_mult_1:\n  \"y * x \\<le> x * y \\<Longrightarrow> (x * y)\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<le> x * y \\<Longrightarrow>\n    (x * y)\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis circ_mult_sub_sup circ_separate_1)"], ["", "lemma circ_separate_unfold:\n  \"(y * x\\<^sup>\\<circ>)\\<^sup>\\<circ> = y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * y * x * x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ> =\n    y\\<^sup>\\<circ> \\<squnion>\n    y\\<^sup>\\<circ> * y * x * x\\<^sup>\\<circ> *\n    (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis circ_back_loop_fixpoint circ_plus_same circ_unfold_sum sup_commute mult_assoc)"], ["", "lemma separation:\n  assumes \"y * x \\<le> x * y\\<^sup>\\<circ>\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "have \"y\\<^sup>\\<circ> * x * y\\<^sup>\\<circ> \\<le> x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x * y\\<^sup>\\<circ>\n    \\<le> x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot", "by (metis assms circ_simulate_left_plus_1 circ_transitive_equal mult_assoc mult_left_isotone)"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> * x * y\\<^sup>\\<circ>\n  \\<le> x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<circ> * x * y\\<^sup>\\<circ>\n  \\<le> x * y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis sup_commute circ_sup_1 circ_simulate_right circ_sub_dist_3 le_iff_sup mult_assoc mult_left_zero zero_right_mult_decreasing)"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simulation:\n  \"y * x \\<le> x * y\\<^sup>\\<circ> \\<Longrightarrow> y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<le> x * y\\<^sup>\\<circ> \\<Longrightarrow>\n    y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis sup_ge2 circ_isotone circ_mult_upper_bound circ_sub_dist separation)"], ["", "lemma circ_simulate_4:\n  assumes \"y * x \\<le> x * x\\<^sup>\\<circ> * (1 \\<squnion> y)\"\n    shows \"y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "have \"x \\<squnion> (x * x\\<^sup>\\<circ> * x * x \\<squnion> x * x) = x * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> (x * x\\<^sup>\\<circ> * x * x \\<squnion> x * x) =\n    x * x\\<^sup>\\<circ>", "by (metis (no_types) circ_back_loop_fixpoint mult_right_dist_sup sup_commute)"], ["proof (state)\nthis:\n  x \\<squnion> (x * x\\<^sup>\\<circ> * x * x \\<squnion> x * x) =\n  x * x\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "hence \"x \\<le> x * x\\<^sup>\\<circ> * 1 \\<squnion> x * x\\<^sup>\\<circ> * y\""], ["proof (prove)\nusing this:\n  x \\<squnion> (x * x\\<^sup>\\<circ> * x * x \\<squnion> x * x) =\n  x * x\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. x \\<le> x * x\\<^sup>\\<circ> * (1::'a) \\<squnion> x * x\\<^sup>\\<circ> * y", "by (metis mult_1_right sup_assoc sup_ge1)"], ["proof (state)\nthis:\n  x \\<le> x * x\\<^sup>\\<circ> * (1::'a) \\<squnion> x * x\\<^sup>\\<circ> * y\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "hence \"(1 \\<squnion> y) * x \\<le> x * x\\<^sup>\\<circ> * (1 \\<squnion> y)\""], ["proof (prove)\nusing this:\n  x \\<le> x * x\\<^sup>\\<circ> * (1::'a) \\<squnion> x * x\\<^sup>\\<circ> * y\n\ngoal (1 subgoal):\n 1. ((1::'a) \\<squnion> y) * x\n    \\<le> x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y)", "using assms mult_left_dist_sup mult_right_dist_sup"], ["proof (prove)\nusing this:\n  x \\<le> x * x\\<^sup>\\<circ> * (1::'a) \\<squnion> x * x\\<^sup>\\<circ> * y\n  y * x \\<le> x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y)\n  ?x * (?y \\<squnion> ?z) = ?x * ?y \\<squnion> ?x * ?z\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n\ngoal (1 subgoal):\n 1. ((1::'a) \\<squnion> y) * x\n    \\<le> x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y)", "by force"], ["proof (state)\nthis:\n  ((1::'a) \\<squnion> y) * x\n  \\<le> x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y)\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "hence \"y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\nusing this:\n  ((1::'a) \\<squnion> y) * x\n  \\<le> x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y)\n\ngoal (1 subgoal):\n 1. y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis circ_sup_upper_bound circ_increasing circ_reflexive circ_simulate_right_plus_1 mult_right_isotone mult_right_sub_dist_sup_right order_trans)"], ["proof (state)\nthis:\n  y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis circ_simulate_2)"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circ_simulate_5:\n  \"y * x \\<le> x * x\\<^sup>\\<circ> * (x \\<squnion> y) \\<Longrightarrow> y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<le> x * x\\<^sup>\\<circ> * (x \\<squnion> y) \\<Longrightarrow>\n    y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis circ_sup_sub_sup_one circ_simulate_4 order_trans)"], ["", "lemma circ_simulate_6:\n  \"y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow> y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow>\n    y\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis sup_commute circ_back_loop_fixpoint circ_simulate_5 mult_right_sub_dist_sup_left order_trans)"], ["", "lemma circ_separate_4:\n  assumes \"y * x \\<le> x * x\\<^sup>\\<circ> * (1 \\<squnion> y)\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "have \"y * x * x\\<^sup>\\<circ> \\<le> x * x\\<^sup>\\<circ> * (1 \\<squnion> y) * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x * x\\<^sup>\\<circ>\n    \\<le> x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<circ>", "by (simp add: assms mult_left_isotone)"], ["proof (state)\nthis:\n  y * x * x\\<^sup>\\<circ>\n  \\<le> x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  y * x * x\\<^sup>\\<circ>\n  \\<le> x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "have \"... = x * x\\<^sup>\\<circ> \\<squnion> x * x\\<^sup>\\<circ> * y * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<circ> =\n    x * x\\<^sup>\\<circ> \\<squnion> x * x\\<^sup>\\<circ> * y * x\\<^sup>\\<circ>", "by (simp add: circ_transitive_equal mult_left_dist_sup mult_right_dist_sup mult_assoc)"], ["proof (state)\nthis:\n  x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<circ> =\n  x * x\\<^sup>\\<circ> \\<squnion> x * x\\<^sup>\\<circ> * y * x\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  x * x\\<^sup>\\<circ> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<circ> =\n  x * x\\<^sup>\\<circ> \\<squnion> x * x\\<^sup>\\<circ> * y * x\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "have \"... \\<le> x * x\\<^sup>\\<circ> \\<squnion> x * x\\<^sup>\\<circ> * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x\\<^sup>\\<circ> \\<squnion> x * x\\<^sup>\\<circ> * y * x\\<^sup>\\<circ>\n    \\<le> x * x\\<^sup>\\<circ> \\<squnion>\n          x * x\\<^sup>\\<circ> * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis assms sup_right_isotone circ_simulate_2 circ_simulate_4 mult_assoc mult_right_isotone)"], ["proof (state)\nthis:\n  x * x\\<^sup>\\<circ> \\<squnion> x * x\\<^sup>\\<circ> * y * x\\<^sup>\\<circ>\n  \\<le> x * x\\<^sup>\\<circ> \\<squnion>\n        x * x\\<^sup>\\<circ> * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "finally"], ["proof (chain)\npicking this:\n  y * x * x\\<^sup>\\<circ>\n  \\<le> x * x\\<^sup>\\<circ> \\<squnion>\n        x * x\\<^sup>\\<circ> * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "have \"y * x * x\\<^sup>\\<circ> \\<le> x * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\nusing this:\n  y * x * x\\<^sup>\\<circ>\n  \\<le> x * x\\<^sup>\\<circ> \\<squnion>\n        x * x\\<^sup>\\<circ> * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. y * x * x\\<^sup>\\<circ> \\<le> x * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis circ_reflexive circ_transitive_equal le_iff_sup mult_assoc mult_right_isotone mult_1_right)"], ["proof (state)\nthis:\n  y * x * x\\<^sup>\\<circ> \\<le> x * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y * x * x\\<^sup>\\<circ> \\<le> x * x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis circ_sup_1 left_plus_circ mult_assoc separation)"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circ_separate_5:\n  \"y * x \\<le> x * x\\<^sup>\\<circ> * (x \\<squnion> y) \\<Longrightarrow> (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<le> x * x\\<^sup>\\<circ> * (x \\<squnion> y) \\<Longrightarrow>\n    (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis circ_sup_sub_sup_one circ_separate_4 order_trans)"], ["", "lemma circ_separate_6:\n  \"y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow> (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow>\n    (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>", "by (metis sup_commute circ_back_loop_fixpoint circ_separate_5 mult_right_sub_dist_sup_left order_trans)"], ["", "end"], ["", "class bounded_itering = bounded_idempotent_left_zero_semiring + itering\nbegin"], ["", "subclass bounded_left_conway_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_left_conway_semiring circ (1::'a) (*) (\\<squnion>) (\\<le>)\n     (<) bot top", ".."], ["", "(*\nlemma \"1 = x\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"x = x\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"x = x * x\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"x * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"(x * y)\\<^sup>\\<circ> = (x \\<squnion> y)\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"x\\<^sup>\\<circ> * y\\<^sup>\\<circ> = (x \\<squnion> y)\\<^sup>\\<circ>\" nitpick [expect=genuine,card=6] oops\nlemma \"(x \\<squnion> y)\\<^sup>\\<circ> = (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"1 = 1\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\n\nlemma \"1 = (x * bot)\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"1 \\<squnion> x * bot = x\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"x\\<^sup>\\<circ> = x\\<^sup>\\<circ> * 1\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"z \\<squnion> y * x = x \\<longrightarrow> y\\<^sup>\\<circ> * z \\<le> x\" nitpick [expect=genuine] oops\nlemma \"y * x = x \\<longrightarrow> y\\<^sup>\\<circ> * x \\<le> x\" nitpick [expect=genuine] oops\nlemma \"z \\<squnion> x * y = x \\<longrightarrow> z * y\\<^sup>\\<circ> \\<le> x\" nitpick [expect=genuine] oops\nlemma \"x * y = x \\<longrightarrow> x * y\\<^sup>\\<circ> \\<le> x\" nitpick [expect=genuine] oops\nlemma \"x = z \\<squnion> y * x \\<longrightarrow> x \\<le> y\\<^sup>\\<circ> * z\" nitpick [expect=genuine] oops\nlemma \"x = y * x \\<longrightarrow> x \\<le> y\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\nlemma \"x * z = z * y \\<longrightarrow> x\\<^sup>\\<circ> * z \\<le> z * y\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\n\nlemma \"x\\<^sup>\\<circ> = (x * x)\\<^sup>\\<circ> * (x \\<squnion> 1)\" oops\nlemma \"y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<longrightarrow> (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\" oops\nlemma \"y * x \\<le> (1 \\<squnion> x) * y\\<^sup>\\<circ> \\<longrightarrow> (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\" oops\nlemma \"y * x \\<le> x \\<longrightarrow> y\\<^sup>\\<circ> * x \\<le> 1\\<^sup>\\<circ> * x\" oops\n*)"], ["", "end"], ["", "text \\<open>\nWe finally expand Conway semirings and iterings by an element that corresponds to the endless loop.\n\\<close>"], ["", "class L =\n  fixes L :: \"'a\""], ["", "class left_conway_semiring_L = left_conway_semiring + L +\n  assumes one_circ_mult_split: \"1\\<^sup>\\<circ> * x = L \\<squnion> x\"\n  assumes L_split_sup: \"x * (y \\<squnion> L) \\<le> x * y \\<squnion> L\"\nbegin"], ["", "lemma L_def:\n  \"L = 1\\<^sup>\\<circ> * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L = (1::'a)\\<^sup>\\<circ> * bot", "by (metis sup_monoid.add_0_right one_circ_mult_split)"], ["", "lemma one_circ_split:\n  \"1\\<^sup>\\<circ> = L \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> = L \\<squnion> (1::'a)", "by (metis mult_1_right one_circ_mult_split)"], ["", "lemma one_circ_circ_split:\n  \"1\\<^sup>\\<circ>\\<^sup>\\<circ> = L \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ>\\<^sup>\\<circ> = L \\<squnion> (1::'a)", "by (metis circ_one one_circ_split)"], ["", "lemma sub_mult_one_circ:\n  \"x * 1\\<^sup>\\<circ> \\<le> 1\\<^sup>\\<circ> * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a)\\<^sup>\\<circ> \\<le> (1::'a)\\<^sup>\\<circ> * x", "by (metis L_split_sup sup_commute mult_1_right one_circ_mult_split)"], ["", "lemma one_circ_mult_split_2:\n  \"1\\<^sup>\\<circ> * x = x * 1\\<^sup>\\<circ> \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> * x = x * (1::'a)\\<^sup>\\<circ> \\<squnion> L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> * x = x * (1::'a)\\<^sup>\\<circ> \\<squnion> L", "have 1: \"x * 1\\<^sup>\\<circ> \\<le> L \\<squnion> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a)\\<^sup>\\<circ> \\<le> L \\<squnion> x", "using one_circ_mult_split sub_mult_one_circ"], ["proof (prove)\nusing this:\n  (1::'a)\\<^sup>\\<circ> * ?x = L \\<squnion> ?x\n  ?x * (1::'a)\\<^sup>\\<circ> \\<le> (1::'a)\\<^sup>\\<circ> * ?x\n\ngoal (1 subgoal):\n 1. x * (1::'a)\\<^sup>\\<circ> \\<le> L \\<squnion> x", "by presburger"], ["proof (state)\nthis:\n  x * (1::'a)\\<^sup>\\<circ> \\<le> L \\<squnion> x\n\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> * x = x * (1::'a)\\<^sup>\\<circ> \\<squnion> L", "have \"x \\<squnion> x * 1\\<^sup>\\<circ> = x * 1\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> x * (1::'a)\\<^sup>\\<circ> = x * (1::'a)\\<^sup>\\<circ>", "by (meson circ_back_loop_prefixpoint le_iff_sup sup.boundedE)"], ["proof (state)\nthis:\n  x \\<squnion> x * (1::'a)\\<^sup>\\<circ> = x * (1::'a)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> * x = x * (1::'a)\\<^sup>\\<circ> \\<squnion> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<squnion> x * (1::'a)\\<^sup>\\<circ> = x * (1::'a)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> * x = x * (1::'a)\\<^sup>\\<circ> \\<squnion> L", "using 1"], ["proof (prove)\nusing this:\n  x \\<squnion> x * (1::'a)\\<^sup>\\<circ> = x * (1::'a)\\<^sup>\\<circ>\n  x * (1::'a)\\<^sup>\\<circ> \\<le> L \\<squnion> x\n\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> * x = x * (1::'a)\\<^sup>\\<circ> \\<squnion> L", "by (simp add: le_iff_sup one_circ_mult_split sup_assoc sup_commute)"], ["proof (state)\nthis:\n  (1::'a)\\<^sup>\\<circ> * x = x * (1::'a)\\<^sup>\\<circ> \\<squnion> L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sub_mult_one_circ_split:\n  \"x * 1\\<^sup>\\<circ> \\<le> x \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a)\\<^sup>\\<circ> \\<le> x \\<squnion> L", "by (metis sup_commute one_circ_mult_split sub_mult_one_circ)"], ["", "lemma sub_mult_one_circ_split_2:\n  \"x * 1\\<^sup>\\<circ> \\<le> x \\<squnion> 1\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a)\\<^sup>\\<circ> \\<le> x \\<squnion> (1::'a)\\<^sup>\\<circ>", "by (metis L_def sup_right_isotone order_trans sub_mult_one_circ_split zero_right_mult_decreasing)"], ["", "lemma L_split:\n  \"x * L \\<le> x * bot \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * L \\<le> x * bot \\<squnion> L", "by (metis L_split_sup sup_monoid.add_0_left)"], ["", "lemma L_left_zero:\n  \"L * x = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L * x = L", "by (metis L_def mult_assoc mult_left_zero)"], ["", "lemma one_circ_L:\n  \"1\\<^sup>\\<circ> * L = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> * L = L", "by (metis L_def circ_transitive_equal mult_assoc)"], ["", "lemma mult_L_circ:\n  \"(x * L)\\<^sup>\\<circ> = 1 \\<squnion> x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * L)\\<^sup>\\<circ> = Rf x L", "by (metis L_left_zero circ_left_unfold mult_assoc)"], ["", "lemma mult_L_circ_mult:\n  \"(x * L)\\<^sup>\\<circ> * y = y \\<squnion> x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * L)\\<^sup>\\<circ> * y = y \\<squnion> x * L", "by (metis L_left_zero mult_L_circ mult_assoc mult_1_left mult_right_dist_sup)"], ["", "lemma circ_L:\n  \"L\\<^sup>\\<circ> = L \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L\\<^sup>\\<circ> = L \\<squnion> (1::'a)", "by (metis L_left_zero sup_commute circ_left_unfold)"], ["", "lemma L_below_one_circ:\n  \"L \\<le> 1\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<le> (1::'a)\\<^sup>\\<circ>", "by (metis L_def zero_right_mult_decreasing)"], ["", "lemma circ_circ_mult_1:\n  \"x\\<^sup>\\<circ> * 1\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * (1::'a)\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>", "by (metis L_left_zero sup_commute circ_sup_1 circ_circ_sup mult_zero_circ one_circ_split)"], ["", "lemma circ_circ_mult:\n  \"1\\<^sup>\\<circ> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>", "by (metis antisym circ_circ_mult_1 circ_circ_sub_mult sub_mult_one_circ)"], ["", "lemma circ_circ_split:\n  \"x\\<^sup>\\<circ>\\<^sup>\\<circ> = L \\<squnion> x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ>\\<^sup>\\<circ> = L \\<squnion> x\\<^sup>\\<circ>", "by (metis circ_circ_mult one_circ_mult_split)"], ["", "lemma circ_sup_6:\n  \"L \\<squnion> (x \\<squnion> y)\\<^sup>\\<circ> = (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<squnion> (x \\<squnion> y)\\<^sup>\\<circ> =\n    (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis sup_assoc sup_commute circ_sup_1 circ_circ_sup circ_circ_split circ_decompose_4)"], ["", "end"], ["", "class itering_L = itering + L +\n  assumes L_def: \"L = 1\\<^sup>\\<circ> * bot\"\nbegin"], ["", "lemma one_circ_split:\n  \"1\\<^sup>\\<circ> = L \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> = L \\<squnion> (1::'a)", "by (metis L_def sup_commute antisym circ_sup_upper_bound circ_reflexive circ_simulate_absorb mult_1_right order_refl zero_right_mult_decreasing)"], ["", "lemma one_circ_mult_split:\n  \"1\\<^sup>\\<circ> * x = L \\<squnion> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<circ> * x = L \\<squnion> x", "by (metis L_def sup_commute circ_loop_fixpoint mult_assoc mult_left_zero mult_zero_circ one_circ_split)"], ["", "lemma sub_mult_one_circ_split:\n  \"x * 1\\<^sup>\\<circ> \\<le> x \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a)\\<^sup>\\<circ> \\<le> x \\<squnion> L", "by (metis sup_commute one_circ_mult_split sub_mult_one_circ)"], ["", "lemma sub_mult_one_circ_split_2:\n  \"x * 1\\<^sup>\\<circ> \\<le> x \\<squnion> 1\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a)\\<^sup>\\<circ> \\<le> x \\<squnion> (1::'a)\\<^sup>\\<circ>", "by (metis L_def sup_right_isotone order_trans sub_mult_one_circ_split zero_right_mult_decreasing)"], ["", "lemma L_split:\n  \"x * L \\<le> x * bot \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * L \\<le> x * bot \\<squnion> L", "by (metis L_def mult_assoc mult_left_isotone mult_right_dist_sup sub_mult_one_circ_split_2)"], ["", "subclass left_conway_semiring_L"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.left_conway_semiring_L L circ (1::'a) (*) (\\<squnion>) (\\<le>) (<)\n     bot", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. (1::'a)\\<^sup>\\<circ> * x = L \\<squnion> x\n 2. \\<And>x y. x * (y \\<squnion> L) \\<le> x * y \\<squnion> L", "apply (metis L_def sup_commute circ_loop_fixpoint mult_assoc mult_left_zero mult_zero_circ one_circ_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x * (y \\<squnion> L) \\<le> x * y \\<squnion> L", "by (metis sup_commute mult_assoc mult_left_isotone one_circ_mult_split sub_mult_one_circ)"], ["", "lemma circ_left_induct_mult_L:\n  \"L \\<le> x \\<Longrightarrow> x * y \\<le> x \\<Longrightarrow> x * y\\<^sup>\\<circ> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L \\<le> x; x * y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x * y\\<^sup>\\<circ> \\<le> x", "by (metis circ_one circ_simulate le_iff_sup one_circ_mult_split)"], ["", "lemma circ_left_induct_mult_iff_L:\n  \"L \\<le> x \\<Longrightarrow> x * y \\<le> x \\<longleftrightarrow> x * y\\<^sup>\\<circ> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<le> x \\<Longrightarrow>\n    (x * y \\<le> x) = (x * y\\<^sup>\\<circ> \\<le> x)", "by (metis sup.bounded_iff circ_back_loop_fixpoint circ_left_induct_mult_L le_iff_sup)"], ["", "lemma circ_left_induct_L:\n  \"L \\<le> x \\<Longrightarrow> x * y \\<squnion> z \\<le> x \\<Longrightarrow> z * y\\<^sup>\\<circ> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L \\<le> x; x * y \\<squnion> z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> z * y\\<^sup>\\<circ> \\<le> x", "by (metis sup.bounded_iff circ_left_induct_mult_L le_iff_sup mult_right_dist_sup)"], ["", "end"], ["", "end"]]}