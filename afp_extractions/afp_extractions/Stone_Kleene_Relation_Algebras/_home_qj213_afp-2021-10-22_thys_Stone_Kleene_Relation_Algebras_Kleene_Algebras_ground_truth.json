{"file_name": "/home/qj213/afp-2021-10-22/thys/Stone_Kleene_Relation_Algebras/Kleene_Algebras.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stone_Kleene_Relation_Algebras", "problem_names": ["lemma star_left_unfold_equal:\n  \"1 \\<squnion> x * x\\<^sup>\\<star> = x\\<^sup>\\<star>\"", "lemma star_left_slide:\n  \"(x * y)\\<^sup>\\<star> * x \\<le> x * (y * x)\\<^sup>\\<star>\"", "lemma star_isotone:\n  \"x \\<le> y \\<Longrightarrow> x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star>\"", "lemma star_sup_1:\n  \"(x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\"", "lemma star_sub_one:\n  \"x \\<le> 1 \\<Longrightarrow> x\\<^sup>\\<star> = 1\"", "lemma star_one:\n  \"1\\<^sup>\\<star> = 1\"", "lemma star_left_induct_mult:\n  \"x * y \\<le> y \\<Longrightarrow> x\\<^sup>\\<star> * y \\<le> y\"", "lemma star_left_induct_mult_iff:\n  \"x * y \\<le> y \\<longleftrightarrow> x\\<^sup>\\<star> * y \\<le> y\"", "lemma star_involutive:\n  \"x\\<^sup>\\<star> = x\\<^sup>\\<star>\\<^sup>\\<star>\"", "lemma star_sup_one:\n  \"(1 \\<squnion> x)\\<^sup>\\<star> = x\\<^sup>\\<star>\"", "lemma star_plus_loops:\n  \"x\\<^sup>\\<star> \\<squnion> 1 = x\\<^sup>+ \\<squnion> 1\"", "lemma star_left_induct_equal:\n  \"z \\<squnion> x * y = y \\<Longrightarrow> x\\<^sup>\\<star> * z \\<le> y\"", "lemma star_left_induct_mult_equal:\n  \"x * y = y \\<Longrightarrow> x\\<^sup>\\<star> * y \\<le> y\"", "lemma star_star_upper_bound:\n  \"x\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<Longrightarrow> x\\<^sup>\\<star>\\<^sup>\\<star> \\<le> z\\<^sup>\\<star>\"", "lemma star_simulation_left:\n  assumes \"x * z \\<le> z * y\"\n    shows \"x\\<^sup>\\<star> * z \\<le> z * y\\<^sup>\\<star>\"", "lemma quasicomm_1:\n  \"y * x \\<le> x * (x \\<squnion> y)\\<^sup>\\<star> \\<longleftrightarrow> y\\<^sup>\\<star> * x \\<le> x * (x \\<squnion> y)\\<^sup>\\<star>\"", "lemma star_rtc_3:\n  \"1 \\<squnion> x \\<squnion> y * y = y \\<Longrightarrow> x\\<^sup>\\<star> \\<le> y\"", "lemma star_decompose_1:\n  \"(x \\<squnion> y)\\<^sup>\\<star> = (x\\<^sup>\\<star> * y\\<^sup>\\<star>)\\<^sup>\\<star>\"", "lemma star_sum:\n  \"(x \\<squnion> y)\\<^sup>\\<star> = (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\\<^sup>\\<star>\"", "lemma star_decompose_3:\n  \"(x\\<^sup>\\<star> * y\\<^sup>\\<star>)\\<^sup>\\<star> = x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\"", "lemma star_loop_least_fixpoint:\n  \"y * x \\<squnion> z = x \\<Longrightarrow> y\\<^sup>\\<star> * z \\<le> x\"", "lemma star_loop_is_least_fixpoint:\n  \"is_least_fixpoint (\\<lambda>x . y * x \\<squnion> z) (y\\<^sup>\\<star> * z)\"", "lemma star_loop_mu:\n  \"\\<mu> (\\<lambda>x . y * x \\<squnion> z) = y\\<^sup>\\<star> * z\"", "lemma affine_has_least_fixpoint:\n  \"has_least_fixpoint (\\<lambda>x . y * x \\<squnion> z)\"", "lemma star_outer_increasing:\n  \"x \\<le> y\\<^sup>\\<star> * x * y\\<^sup>\\<star>\"", "lemma star_plus:\n  \"y\\<^sup>\\<star> * y = y * y\\<^sup>\\<star>\"", "lemma star_slide:\n  \"(x * y)\\<^sup>\\<star> * x = x * (y * x)\\<^sup>\\<star>\"", "lemma star_simulation_right:\n  assumes \"z * x \\<le> y * z\"\n    shows \"z * x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * z\"", "lemma star_right_induct_mult:\n  \"y * x \\<le> y \\<Longrightarrow> y * x\\<^sup>\\<star> \\<le> y\"", "lemma star_right_induct_mult_iff:\n  \"y * x \\<le> y \\<longleftrightarrow> y * x\\<^sup>\\<star> \\<le> y\"", "lemma star_simulation_right_equal:\n  \"z * x = y * z \\<Longrightarrow> z * x\\<^sup>\\<star> = y\\<^sup>\\<star> * z\"", "lemma star_simulation_star:\n  \"x * y \\<le> y * x \\<Longrightarrow> x\\<^sup>\\<star> * y\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\"", "lemma star_right_induct_equal:\n  \"z \\<squnion> y * x = y \\<Longrightarrow> z * x\\<^sup>\\<star> \\<le> y\"", "lemma star_right_induct_mult_equal:\n  \"y * x = y \\<Longrightarrow> y * x\\<^sup>\\<star> \\<le> y\"", "lemma star_back_loop_least_fixpoint:\n  \"x * y \\<squnion> z = x \\<Longrightarrow> z * y\\<^sup>\\<star> \\<le> x\"", "lemma star_back_loop_is_least_fixpoint:\n  \"is_least_fixpoint (\\<lambda>x . x * y \\<squnion> z) (z * y\\<^sup>\\<star>)\"", "lemma star_back_loop_mu:\n  \"\\<mu> (\\<lambda>x . x * y \\<squnion> z) = z * y\\<^sup>\\<star>\"", "lemma star_square:\n  \"x\\<^sup>\\<star> = (1 \\<squnion> x) * (x * x)\\<^sup>\\<star>\"", "lemma star_square_2:\n  \"x\\<^sup>\\<star> = (x * x)\\<^sup>\\<star> * (x \\<squnion> 1)\"", "lemma star_circ_simulate_right_plus:\n  assumes \"z * x \\<le> y * y\\<^sup>\\<star> * z \\<squnion> w\"\n    shows \"z * x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\"", "lemma transitive_star:\n  \"x * x \\<le> x \\<Longrightarrow> x\\<^sup>\\<star> = 1 \\<squnion> x\"", "lemma star_sup_2:\n  assumes \"x * x \\<le> x\"\n    and \"x * y \\<le> x\"\n  shows \"(x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * (x \\<squnion> 1)\"", "lemma star_star_absorb:\n  \"y\\<^sup>\\<star> * (y\\<^sup>\\<star> * x)\\<^sup>\\<star> * y\\<^sup>\\<star> = (y\\<^sup>\\<star> * x)\\<^sup>\\<star> * y\\<^sup>\\<star>\"", "lemma star_circ_simulate_left_plus:\n  assumes \"x * z \\<le> z * y\\<^sup>\\<star> \\<squnion> w\"\n    shows \"x\\<^sup>\\<star> * z \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\"", "lemma star_one_sup_below:\n  \"x * y\\<^sup>\\<star> * (1 \\<squnion> z) \\<le> x * (y \\<squnion> z)\\<^sup>\\<star>\"", "lemma cancel_separate:\n  assumes \"x * y \\<le> 1\"\n    shows \"x\\<^sup>\\<star> * y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\"", "lemma star_separate:\n  assumes \"x * y = bot\"\n      and \"y * y = bot\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>\"", "lemma star_absorb:\n  \"x * y = bot \\<Longrightarrow> x * y\\<^sup>\\<star> = x\"", "lemma star_separate_2:\n  assumes \"x * z\\<^sup>+ * y = bot\"\n      and \"y * z\\<^sup>+ * y = bot\"\n      and \"z * x = bot\"\n    shows \"(x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * (z * (1 \\<squnion> y * x\\<^sup>\\<star>))\\<^sup>\\<star> = z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star>\"", "lemma cancel_separate_eq:\n  \"x * y \\<le> 1 \\<Longrightarrow> x\\<^sup>\\<star> * y\\<^sup>\\<star> = x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\"", "lemma cancel_separate_1:\n  assumes \"x * y \\<le> 1\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>\"", "lemma plus_sup:\n  \"(x \\<squnion> y)\\<^sup>+ = (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>+ \\<squnion> (x\\<^sup>\\<star> * y)\\<^sup>+\"", "lemma plus_half_bot:\n  \"x * y * x = bot \\<Longrightarrow> (x * y)\\<^sup>+ = x * y\"", "lemma cancel_separate_1_sup:\n  assumes \"x * y \\<le> 1\"\n      and \"y * x \\<le> 1\"\n  shows \"(x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\"", "lemma star_separate_3:\n  assumes \"y * x\\<^sup>\\<star> * y \\<le> y\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\"", "lemma star_below_circ:\n  \"x\\<^sup>\\<star> \\<le> x\\<^sup>\\<circ>\"", "lemma star_zero_below_circ_mult:\n  \"x\\<^sup>\\<star> * bot \\<le> x\\<^sup>\\<circ> * y\"", "lemma star_mult_circ:\n  \"x\\<^sup>\\<star> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\"", "lemma circ_mult_star:\n  \"x\\<^sup>\\<circ> * x\\<^sup>\\<star> = x\\<^sup>\\<circ>\"", "lemma circ_star:\n  \"x\\<^sup>\\<circ>\\<^sup>\\<star> = x\\<^sup>\\<circ>\"", "lemma star_circ:\n  \"x\\<^sup>\\<star>\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\"", "lemma circ_sup_3:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<star> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\"", "lemma circ_isolate:\n  \"x\\<^sup>\\<circ> = x\\<^sup>\\<circ> * bot \\<squnion> x\\<^sup>\\<star>\"", "lemma circ_isolate_mult:\n  \"x\\<^sup>\\<circ> * y = x\\<^sup>\\<circ> * bot \\<squnion> x\\<^sup>\\<star> * y\"", "lemma circ_isolate_mult_sub:\n  \"x\\<^sup>\\<circ> * y \\<le> x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<star> * y\"", "lemma circ_sub_decompose:\n  \"(x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> \\<le> (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\"", "lemma circ_sup_4:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\"", "lemma circ_sup_5:\n  \"(x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> = (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\"", "lemma plus_circ:\n  \"(x\\<^sup>\\<star> * x)\\<^sup>\\<circ> = x\\<^sup>\\<circ>\""], "translations": [["", "lemma star_left_unfold_equal:\n  \"1 \\<squnion> x * x\\<^sup>\\<star> = x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x\\<^sup>+ = x\\<^sup>\\<star>", "by (metis sup_right_isotone antisym mult_right_isotone mult_1_right star_left_induct star_left_unfold)"], ["", "text \\<open>\nThis means that for some properties of Kleene algebras, only one inequality can be derived, as exemplified by the following sliding rule.\n\\<close>"], ["", "lemma star_left_slide:\n  \"(x * y)\\<^sup>\\<star> * x \\<le> x * (y * x)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<star> * x \\<le> x * (y * x)\\<^sup>\\<star>", "by (metis mult_assoc mult_left_sub_dist_sup mult_1_right star_left_induct star_left_unfold_equal)"], ["", "lemma star_isotone:\n  \"x \\<le> y \\<Longrightarrow> x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star>", "by (metis sup_right_isotone mult_left_isotone order_trans star_left_unfold mult_1_right star_left_induct)"], ["", "lemma star_sup_1:\n  \"(x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n 2. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "have \"y * x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star> \\<le> (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y * x\\<^sup>\\<star>)\\<^sup>+ \\<le> (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "using sup_right_divisibility star_left_unfold_equal"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n  (1::'a) \\<squnion> ?x\\<^sup>+ = ?x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (y * x\\<^sup>\\<star>)\\<^sup>+ \\<le> (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  (y * x\\<^sup>\\<star>)\\<^sup>+ \\<le> (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n 2. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  (y * x\\<^sup>\\<star>)\\<^sup>+ \\<le> (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n 2. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "have \"... \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "using mult_left_isotone sup_left_divisibility star_left_unfold_equal"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  (?x \\<le> ?y) = (\\<exists>z. ?x \\<squnion> z = ?y)\n  (1::'a) \\<squnion> ?x\\<^sup>+ = ?x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "by fastforce"], ["proof (state)\nthis:\n  (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n 2. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  (y * x\\<^sup>\\<star>)\\<^sup>+\n  \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "have \"(x \\<squnion> y) * (x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>) \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  (y * x\\<^sup>\\<star>)\\<^sup>+\n  \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y) *\n    (x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>)\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "by (metis le_supI mult_right_dist_sup mult_right_sub_dist_sup_right mult_assoc star_left_unfold_equal)"], ["proof (state)\nthis:\n  (x \\<squnion> y) * (x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n 2. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "hence \"1 \\<squnion> (x \\<squnion> y) * (x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>) \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  (x \\<squnion> y) * (x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. Rf (x \\<squnion> y)\n     (x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>)\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "using reflexive_mult_closed star_left_unfold"], ["proof (prove)\nusing this:\n  (x \\<squnion> y) * (x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n  \\<lbrakk>reflexive ?x; reflexive ?y\\<rbrakk>\n  \\<Longrightarrow> reflexive (?x * ?y)\n  (1::'a) \\<squnion> ?y\\<^sup>+ \\<le> ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. Rf (x \\<squnion> y)\n     (x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>)\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  Rf (x \\<squnion> y)\n   (x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n 2. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "thus \"(x \\<squnion> y)\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  Rf (x \\<squnion> y)\n   (x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "using star_left_induct"], ["proof (prove)\nusing this:\n  Rf (x \\<squnion> y)\n   (x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n  ?z \\<squnion> ?y * ?x \\<le> ?x \\<longrightarrow>\n  ?y\\<^sup>\\<star> * ?z \\<le> ?x\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "by force"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "have \"x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> * (y * (x \\<squnion> y)\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> *\n          (y * (x \\<squnion> y)\\<^sup>\\<star>)\\<^sup>\\<star>", "by (simp add: mult_right_isotone star_isotone)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> * (y * (x \\<squnion> y)\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> * (y * (x \\<squnion> y)\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "have \"... \\<le> x\\<^sup>\\<star> * ((x \\<squnion> y) * (x \\<squnion> y)\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * (x \\<squnion> y)\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>+\\<^sup>\\<star>", "by (simp add: mult_right_isotone mult_right_sub_dist_sup_right star_isotone)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * (y * (x \\<squnion> y)\\<^sup>\\<star>)\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>+\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * (y * (x \\<squnion> y)\\<^sup>\\<star>)\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>+\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "have \"... \\<le> x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>+\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>\\<star>", "using mult_right_isotone star_left_unfold star_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  (1::'a) \\<squnion> ?y\\<^sup>+ \\<le> ?y\\<^sup>\\<star>\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> \\<le> ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>+\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>+\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>+\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "have \"... \\<le> (x \\<squnion> y)\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>+", "by (simp add: mult_left_isotone star_isotone)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>\\<star>\n  \\<le> (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>+\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>\\<star>\n  \\<le> (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>+\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "have \"... \\<le> (x \\<squnion> y)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>+\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "by (metis sup.bounded_iff mult_1_right star_left_induct star_left_unfold)"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<star>\\<^sup>+\n  \\<le> (x \\<squnion> y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n  \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "show \"x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star> \\<le> (x \\<squnion> y)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n  \\<le> (x \\<squnion> y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\n  \\<le> (x \\<squnion> y)\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\nWe now show that left Kleene algebras form iterings.\nA sublocale is used instead of a subclass, because iterings use a different iteration operation.\n\\<close>"], ["", "sublocale left_kleene_algebra < star: left_conway_semiring where circ = star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.left_conway_semiring star (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. (1::'a) \\<squnion> x\\<^sup>+ = x\\<^sup>\\<star>\n 2. \\<And>x y. (x * y)\\<^sup>\\<star> * x \\<le> x * (y * x)\\<^sup>\\<star>\n 3. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<star> =\n       x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "apply (rule star_left_unfold_equal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (x * y)\\<^sup>\\<star> * x \\<le> x * (y * x)\\<^sup>\\<star>\n 2. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<star> =\n       x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "apply (rule star_left_slide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<star> =\n       x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "by (rule star_sup_1)"], ["", "context left_kleene_algebra\nbegin"], ["", "text \\<open>\nA number of lemmas in this class are taken from Georg Struth's Kleene algebra theory \\cite{ArmstrongGomesStruthWeber2016}.\n\\<close>"], ["", "lemma star_sub_one:\n  \"x \\<le> 1 \\<Longrightarrow> x\\<^sup>\\<star> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> x\\<^sup>\\<star> = (1::'a)", "by (metis sup_right_isotone eq_iff le_iff_sup mult_1_right star.circ_plus_one star_left_induct)"], ["", "lemma star_one:\n  \"1\\<^sup>\\<star> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<star> = (1::'a)", "by (simp add: star_sub_one)"], ["", "lemma star_left_induct_mult:\n  \"x * y \\<le> y \\<Longrightarrow> x\\<^sup>\\<star> * y \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<le> y \\<Longrightarrow> x\\<^sup>\\<star> * y \\<le> y", "by (simp add: star_left_induct)"], ["", "lemma star_left_induct_mult_iff:\n  \"x * y \\<le> y \\<longleftrightarrow> x\\<^sup>\\<star> * y \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<le> y) = (x\\<^sup>\\<star> * y \\<le> y)", "using mult_left_isotone order_trans star.circ_increasing star_left_induct_mult"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  ?x \\<le> ?x\\<^sup>\\<star>\n  ?x * ?y \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> * ?y \\<le> ?y\n\ngoal (1 subgoal):\n 1. (x * y \\<le> y) = (x\\<^sup>\\<star> * y \\<le> y)", "by blast"], ["", "lemma star_involutive:\n  \"x\\<^sup>\\<star> = x\\<^sup>\\<star>\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = x\\<^sup>\\<star>\\<^sup>\\<star>", "using star.circ_circ_sup star_sup_1 star_one"], ["proof (prove)\nusing this:\n  ((1::'a) \\<squnion> ?x)\\<^sup>\\<star> = ?x\\<^sup>\\<star>\\<^sup>\\<star>\n  (?x \\<squnion> ?y)\\<^sup>\\<star> =\n  ?x\\<^sup>\\<star> * (?y * ?x\\<^sup>\\<star>)\\<^sup>\\<star>\n  (1::'a)\\<^sup>\\<star> = (1::'a)\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = x\\<^sup>\\<star>\\<^sup>\\<star>", "by auto"], ["", "lemma star_sup_one:\n  \"(1 \\<squnion> x)\\<^sup>\\<star> = x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<squnion> x)\\<^sup>\\<star> = x\\<^sup>\\<star>", "using star.circ_circ_sup star_involutive"], ["proof (prove)\nusing this:\n  ((1::'a) \\<squnion> ?x)\\<^sup>\\<star> = ?x\\<^sup>\\<star>\\<^sup>\\<star>\n  ?x\\<^sup>\\<star> = ?x\\<^sup>\\<star>\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. ((1::'a) \\<squnion> x)\\<^sup>\\<star> = x\\<^sup>\\<star>", "by auto"], ["", "lemma star_plus_loops:\n  \"x\\<^sup>\\<star> \\<squnion> 1 = x\\<^sup>+ \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<squnion> (1::'a) = x\\<^sup>+ \\<squnion> (1::'a)", "using star.circ_plus_one star_left_unfold_equal sup_commute"], ["proof (prove)\nusing this:\n  ?x\\<^sup>\\<star> = (1::'a) \\<squnion> ?x\\<^sup>\\<star>\n  (1::'a) \\<squnion> ?x\\<^sup>+ = ?x\\<^sup>\\<star>\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<squnion> (1::'a) = x\\<^sup>+ \\<squnion> (1::'a)", "by auto"], ["", "lemma star_left_induct_equal:\n  \"z \\<squnion> x * y = y \\<Longrightarrow> x\\<^sup>\\<star> * z \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<squnion> x * y = y \\<Longrightarrow> x\\<^sup>\\<star> * z \\<le> y", "by (simp add: star_left_induct)"], ["", "lemma star_left_induct_mult_equal:\n  \"x * y = y \\<Longrightarrow> x\\<^sup>\\<star> * y \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = y \\<Longrightarrow> x\\<^sup>\\<star> * y \\<le> y", "by (simp add: star_left_induct_mult)"], ["", "lemma star_star_upper_bound:\n  \"x\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<Longrightarrow> x\\<^sup>\\<star>\\<^sup>\\<star> \\<le> z\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<Longrightarrow>\n    x\\<^sup>\\<star>\\<^sup>\\<star> \\<le> z\\<^sup>\\<star>", "using star_involutive"], ["proof (prove)\nusing this:\n  ?x\\<^sup>\\<star> = ?x\\<^sup>\\<star>\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<Longrightarrow>\n    x\\<^sup>\\<star>\\<^sup>\\<star> \\<le> z\\<^sup>\\<star>", "by auto"], ["", "lemma star_simulation_left:\n  assumes \"x * z \\<le> z * y\"\n    shows \"x\\<^sup>\\<star> * z \\<le> z * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z \\<le> z * y\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z \\<le> z * y\\<^sup>\\<star>", "have \"x * z * y\\<^sup>\\<star> \\<le> z * y * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z * y\\<^sup>\\<star> \\<le> z * y * y\\<^sup>\\<star>", "by (simp add: assms mult_left_isotone)"], ["proof (state)\nthis:\n  x * z * y\\<^sup>\\<star> \\<le> z * y * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z \\<le> z * y\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x * z * y\\<^sup>\\<star> \\<le> z * y * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z \\<le> z * y\\<^sup>\\<star>", "have \"... \\<le> z * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * y * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star>", "by (simp add: mult_right_isotone star.left_plus_below_circ mult_assoc)"], ["proof (state)\nthis:\n  z * y * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z \\<le> z * y\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  x * z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star>", "have \"z \\<squnion> x * z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x * z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z \\<squnion> x * z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star>", "using star.circ_back_loop_prefixpoint"], ["proof (prove)\nusing this:\n  x * z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star>\n  ?z * ?y\\<^sup>\\<star> * ?y \\<squnion> ?z \\<le> ?z * ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z \\<squnion> x * z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  z \\<squnion> x * z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z \\<le> z * y\\<^sup>\\<star>", "thus ?thesis"], ["proof (prove)\nusing this:\n  z \\<squnion> x * z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z \\<le> z * y\\<^sup>\\<star>", "by (simp add: star_left_induct mult_assoc)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * z \\<le> z * y\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasicomm_1:\n  \"y * x \\<le> x * (x \\<squnion> y)\\<^sup>\\<star> \\<longleftrightarrow> y\\<^sup>\\<star> * x \\<le> x * (x \\<squnion> y)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y * x \\<le> x * (x \\<squnion> y)\\<^sup>\\<star>) =\n    (y\\<^sup>\\<star> * x \\<le> x * (x \\<squnion> y)\\<^sup>\\<star>)", "by (metis mult_isotone order_refl order_trans star.circ_increasing star_involutive star_simulation_left)"], ["", "lemma star_rtc_3:\n  \"1 \\<squnion> x \\<squnion> y * y = y \\<Longrightarrow> x\\<^sup>\\<star> \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sf x y = y \\<Longrightarrow> x\\<^sup>\\<star> \\<le> y", "by (metis sup.bounded_iff le_iff_sup mult_left_sub_dist_sup_left mult_1_right star_left_induct_mult_iff star.circ_sub_dist)"], ["", "lemma star_decompose_1:\n  \"(x \\<squnion> y)\\<^sup>\\<star> = (x\\<^sup>\\<star> * y\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    (x\\<^sup>\\<star> * y\\<^sup>\\<star>)\\<^sup>\\<star>", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> (x\\<^sup>\\<star> * y\\<^sup>\\<star>)\\<^sup>\\<star>\n 2. (x\\<^sup>\\<star> * y\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "apply (simp add: star.circ_sup_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> * y\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "using star.circ_sub_dist_3 star_isotone star_involutive"], ["proof (prove)\nusing this:\n  ?x\\<^sup>\\<star> * ?y\\<^sup>\\<star> \\<le> (?x \\<squnion> ?y)\\<^sup>\\<star>\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> \\<le> ?y\\<^sup>\\<star>\n  ?x\\<^sup>\\<star> = ?x\\<^sup>\\<star>\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> * y\\<^sup>\\<star>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "by fastforce"], ["", "lemma star_sum:\n  \"(x \\<squnion> y)\\<^sup>\\<star> = (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\\<^sup>\\<star>", "using star_decompose_1 star_involutive"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y)\\<^sup>\\<star> =\n  (?x\\<^sup>\\<star> * ?y\\<^sup>\\<star>)\\<^sup>\\<star>\n  ?x\\<^sup>\\<star> = ?x\\<^sup>\\<star>\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\\<^sup>\\<star>", "by auto"], ["", "lemma star_decompose_3:\n  \"(x\\<^sup>\\<star> * y\\<^sup>\\<star>)\\<^sup>\\<star> = x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> * y\\<^sup>\\<star>)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "using star_sup_1 star_decompose_1"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y)\\<^sup>\\<star> =\n  ?x\\<^sup>\\<star> * (?y * ?x\\<^sup>\\<star>)\\<^sup>\\<star>\n  (?x \\<squnion> ?y)\\<^sup>\\<star> =\n  (?x\\<^sup>\\<star> * ?y\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> * y\\<^sup>\\<star>)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>", "by auto"], ["", "text \\<open>\nIn contrast to iterings, we now obtain that the iteration operation results in least fixpoints.\n\\<close>"], ["", "lemma star_loop_least_fixpoint:\n  \"y * x \\<squnion> z = x \\<Longrightarrow> y\\<^sup>\\<star> * z \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<squnion> z = x \\<Longrightarrow> y\\<^sup>\\<star> * z \\<le> x", "by (simp add: sup_commute star_left_induct_equal)"], ["", "lemma star_loop_is_least_fixpoint:\n  \"is_least_fixpoint (\\<lambda>x . y * x \\<squnion> z) (y\\<^sup>\\<star> * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_least_fixpoint (\\<lambda>x. y * x \\<squnion> z) (y\\<^sup>\\<star> * z)", "by (simp add: is_least_fixpoint_def star.circ_loop_fixpoint star_loop_least_fixpoint)"], ["", "lemma star_loop_mu:\n  \"\\<mu> (\\<lambda>x . y * x \\<squnion> z) = y\\<^sup>\\<star> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> (\\<lambda>x. y * x \\<squnion> z) = y\\<^sup>\\<star> * z", "by (metis least_fixpoint_same star_loop_is_least_fixpoint)"], ["", "lemma affine_has_least_fixpoint:\n  \"has_least_fixpoint (\\<lambda>x . y * x \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_least_fixpoint (\\<lambda>x. y * x \\<squnion> z)", "by (metis has_least_fixpoint_def star_loop_is_least_fixpoint)"], ["", "lemma star_outer_increasing:\n  \"x \\<le> y\\<^sup>\\<star> * x * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y\\<^sup>\\<star> * x * y\\<^sup>\\<star>", "by (metis star.circ_back_loop_prefixpoint star.circ_loop_fixpoint sup.boundedE)"], ["", "(*\nlemma circ_sup: \"(x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<star> = (x \\<squnion> y)\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\nlemma circ_mult: \"1 \\<squnion> x * (y * x)\\<^sup>\\<star> * y = (x * y)\\<^sup>\\<star>\" nitpick [expect=genuine] oops\nlemma circ_plus_same: \"x\\<^sup>\\<star> * x = x * x\\<^sup>\\<star>\" nitpick [expect=genuine] oops\nlemma circ_unfold_sum: \"(x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * (x \\<squnion> y)\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\nlemma mult_zero_sup_circ_2: \"(x \\<squnion> y * bot)\\<^sup>\\<star> = x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * bot\" nitpick [expect=genuine,card=7] oops\nlemma circ_simulate_left: \"x * z \\<le> z * y \\<squnion> w \\<longrightarrow> x\\<^sup>\\<star> * z \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\" nitpick [expect=genuine] oops\nlemma circ_simulate_1: \"y * x \\<le> x * y \\<longrightarrow> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> * y\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\nlemma circ_separate_1: \"y * x \\<le> x * y \\<longrightarrow> (x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> * y\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\nlemma atomicity_refinement: \"s = s * q \\<and> x = q * x \\<and> q * b = bot \\<and> r * b \\<le> b * r \\<and> r * l \\<le> l * r \\<and> x * l \\<le> l * x \\<and> b * l \\<le> l * b \\<and> q * l \\<le> l * q \\<and> r\\<^sup>\\<star> * q \\<le> q * r\\<^sup>\\<star> \\<and> q \\<le> 1 \\<longrightarrow> s * (x \\<squnion> b \\<squnion> r \\<squnion> l)\\<^sup>\\<star> * q \\<le> s * (x * b\\<^sup>\\<star> * q \\<squnion> r \\<squnion> l)\\<^sup>\\<star>\" nitpick [expect=genuine] oops\nlemma circ_simulate_left_plus: \"x * z \\<le> z * y\\<^sup>\\<star> \\<squnion> w \\<longrightarrow> x\\<^sup>\\<star> * z \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\" nitpick [expect=genuine] oops\nlemma circ_separate_unfold: \"(y * x\\<^sup>\\<star>)\\<^sup>\\<star> = y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * y * x * x\\<^sup>\\<star> * (y * x\\<^sup>\\<star>)\\<^sup>\\<star>\" nitpick [expect=genuine] oops\nlemma separation: \"y * x \\<le> x * y\\<^sup>\\<star> \\<longrightarrow> (x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> * y\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\nlemma circ_simulate_4: \"y * x \\<le> x * x\\<^sup>\\<star> * (1 \\<squnion> y) \\<longrightarrow> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> * y\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\nlemma circ_simulate_5: \"y * x \\<le> x * x\\<^sup>\\<star> * (x \\<squnion> y) \\<longrightarrow> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> * y\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\nlemma circ_simulate_6: \"y * x \\<le> x * (x \\<squnion> y) \\<longrightarrow> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> * y\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\nlemma circ_separate_4: \"y * x \\<le> x * x\\<^sup>\\<star> * (1 \\<squnion> y) \\<longrightarrow> (x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> * y\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\nlemma circ_separate_5: \"y * x \\<le> x * x\\<^sup>\\<star> * (x \\<squnion> y) \\<longrightarrow> (x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> * y\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\nlemma circ_separate_6: \"y * x \\<le> x * (x \\<squnion> y) \\<longrightarrow> (x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> * y\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\n*)"], ["", "end"], ["", "text \\<open>\nWe next add the right induction rule, which allows us to strengthen many inequalities of left Kleene algebras to equalities.\n\\<close>"], ["", "class strong_left_kleene_algebra = left_kleene_algebra +\n  assumes star_right_induct: \"z \\<squnion> x * y \\<le> x \\<longrightarrow> z * y\\<^sup>\\<star> \\<le> x\"\nbegin"], ["", "lemma star_plus:\n  \"y\\<^sup>\\<star> * y = y * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * y = y\\<^sup>+", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. y\\<^sup>\\<star> * y \\<le> y\\<^sup>+\n 2. y\\<^sup>+ \\<le> y\\<^sup>\\<star> * y", "show \"y\\<^sup>\\<star> * y \\<le> y * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * y \\<le> y\\<^sup>+", "by (simp add: star.circ_plus_sub)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * y \\<le> y\\<^sup>+\n\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<le> y\\<^sup>\\<star> * y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<le> y\\<^sup>\\<star> * y", "have \"y\\<^sup>\\<star> * y * y \\<le> y\\<^sup>\\<star> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * y * y \\<le> y\\<^sup>\\<star> * y", "by (simp add: mult_left_isotone star.right_plus_below_circ)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * y * y \\<le> y\\<^sup>\\<star> * y\n\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<le> y\\<^sup>\\<star> * y", "hence \"y \\<squnion> y\\<^sup>\\<star> * y * y \\<le> y\\<^sup>\\<star> * y\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> * y * y \\<le> y\\<^sup>\\<star> * y\n\ngoal (1 subgoal):\n 1. y \\<squnion> y\\<^sup>\\<star> * y * y \\<le> y\\<^sup>\\<star> * y", "by (simp add: star.circ_mult_increasing_2)"], ["proof (state)\nthis:\n  y \\<squnion> y\\<^sup>\\<star> * y * y \\<le> y\\<^sup>\\<star> * y\n\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<le> y\\<^sup>\\<star> * y", "thus \"y * y\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * y\""], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>\\<star> * y * y \\<le> y\\<^sup>\\<star> * y\n\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<le> y\\<^sup>\\<star> * y", "using star_right_induct"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>\\<star> * y * y \\<le> y\\<^sup>\\<star> * y\n  ?z \\<squnion> ?x * ?y \\<le> ?x \\<longrightarrow>\n  ?z * ?y\\<^sup>\\<star> \\<le> ?x\n\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<le> y\\<^sup>\\<star> * y", "by blast"], ["proof (state)\nthis:\n  y\\<^sup>+ \\<le> y\\<^sup>\\<star> * y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma star_slide:\n  \"(x * y)\\<^sup>\\<star> * x = x * (y * x)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<star> * x = x * (y * x)\\<^sup>\\<star>", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (x * y)\\<^sup>\\<star> * x \\<le> x * (y * x)\\<^sup>\\<star>\n 2. x * (y * x)\\<^sup>\\<star> \\<le> (x * y)\\<^sup>\\<star> * x", "show \"(x * y)\\<^sup>\\<star> * x \\<le> x * (y * x)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<star> * x \\<le> x * (y * x)\\<^sup>\\<star>", "by (rule star_left_slide)"], ["proof (state)\nthis:\n  (x * y)\\<^sup>\\<star> * x \\<le> x * (y * x)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x * (y * x)\\<^sup>\\<star> \\<le> (x * y)\\<^sup>\\<star> * x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x * (y * x)\\<^sup>\\<star> \\<le> (x * y)\\<^sup>\\<star> * x", "have \"x \\<squnion> (x * y)\\<^sup>\\<star> * x * y * x \\<le> (x * y)\\<^sup>\\<star> * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> (x * y)\\<^sup>\\<star> * x * y * x\n    \\<le> (x * y)\\<^sup>\\<star> * x", "by (metis (full_types) sup.commute eq_refl star.circ_loop_fixpoint mult.assoc star_plus)"], ["proof (state)\nthis:\n  x \\<squnion> (x * y)\\<^sup>\\<star> * x * y * x\n  \\<le> (x * y)\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. x * (y * x)\\<^sup>\\<star> \\<le> (x * y)\\<^sup>\\<star> * x", "thus \"x * (y * x)\\<^sup>\\<star> \\<le> (x * y)\\<^sup>\\<star> * x\""], ["proof (prove)\nusing this:\n  x \\<squnion> (x * y)\\<^sup>\\<star> * x * y * x\n  \\<le> (x * y)\\<^sup>\\<star> * x\n\ngoal (1 subgoal):\n 1. x * (y * x)\\<^sup>\\<star> \\<le> (x * y)\\<^sup>\\<star> * x", "by (simp add: mult_assoc star_right_induct)"], ["proof (state)\nthis:\n  x * (y * x)\\<^sup>\\<star> \\<le> (x * y)\\<^sup>\\<star> * x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma star_simulation_right:\n  assumes \"z * x \\<le> y * z\"\n    shows \"z * x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * z", "have \"y\\<^sup>\\<star> * z * x \\<le> y\\<^sup>\\<star> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * z * x \\<le> y\\<^sup>\\<star> * z", "by (metis assms dual_order.trans mult_isotone mult_left_sub_dist_sup_right star.circ_loop_fixpoint star.circ_transitive_equal sup.cobounded1 mult_assoc)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * z * x \\<le> y\\<^sup>\\<star> * z\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * z", "thus ?thesis"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> * z * x \\<le> y\\<^sup>\\<star> * z\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * z", "by (metis le_supI star.circ_loop_fixpoint star_right_induct sup.cobounded2)"], ["proof (state)\nthis:\n  z * x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\nAgain we inherit results from the itering hierarchy.\n\\<close>"], ["", "sublocale strong_left_kleene_algebra < star: itering_1 where circ = star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.itering_1 star (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x * (y * x)\\<^sup>\\<star> \\<le> (x * y)\\<^sup>\\<star> * x\n 2. \\<And>z x y.\n       z * x \\<le> y * z \\<longrightarrow>\n       z * x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * z", "apply (simp add: star_slide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z x y.\n       z * x \\<le> y * z \\<longrightarrow>\n       z * x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * z", "by (simp add: star_simulation_right)"], ["", "context strong_left_kleene_algebra\nbegin"], ["", "lemma star_right_induct_mult:\n  \"y * x \\<le> y \\<Longrightarrow> y * x\\<^sup>\\<star> \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<le> y \\<Longrightarrow> y * x\\<^sup>\\<star> \\<le> y", "by (simp add: star_right_induct)"], ["", "lemma star_right_induct_mult_iff:\n  \"y * x \\<le> y \\<longleftrightarrow> y * x\\<^sup>\\<star> \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y * x \\<le> y) = (y * x\\<^sup>\\<star> \\<le> y)", "using mult_right_isotone order_trans star.circ_increasing star_right_induct_mult"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  ?x \\<le> ?x\\<^sup>\\<star>\n  ?y * ?x \\<le> ?y \\<Longrightarrow> ?y * ?x\\<^sup>\\<star> \\<le> ?y\n\ngoal (1 subgoal):\n 1. (y * x \\<le> y) = (y * x\\<^sup>\\<star> \\<le> y)", "by blast"], ["", "lemma star_simulation_right_equal:\n  \"z * x = y * z \\<Longrightarrow> z * x\\<^sup>\\<star> = y\\<^sup>\\<star> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x = y * z \\<Longrightarrow>\n    z * x\\<^sup>\\<star> = y\\<^sup>\\<star> * z", "by (metis eq_iff star_simulation_left star_simulation_right)"], ["", "lemma star_simulation_star:\n  \"x * y \\<le> y * x \\<Longrightarrow> x\\<^sup>\\<star> * y\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<le> y * x \\<Longrightarrow>\n    x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>", "by (simp add: star_simulation_left star_simulation_right)"], ["", "lemma star_right_induct_equal:\n  \"z \\<squnion> y * x = y \\<Longrightarrow> z * x\\<^sup>\\<star> \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<squnion> y * x = y \\<Longrightarrow> z * x\\<^sup>\\<star> \\<le> y", "by (simp add: star_right_induct)"], ["", "lemma star_right_induct_mult_equal:\n  \"y * x = y \\<Longrightarrow> y * x\\<^sup>\\<star> \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x = y \\<Longrightarrow> y * x\\<^sup>\\<star> \\<le> y", "by (simp add: star_right_induct_mult)"], ["", "lemma star_back_loop_least_fixpoint:\n  \"x * y \\<squnion> z = x \\<Longrightarrow> z * y\\<^sup>\\<star> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<squnion> z = x \\<Longrightarrow> z * y\\<^sup>\\<star> \\<le> x", "by (simp add: sup_commute star_right_induct_equal)"], ["", "lemma star_back_loop_is_least_fixpoint:\n  \"is_least_fixpoint (\\<lambda>x . x * y \\<squnion> z) (z * y\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_least_fixpoint (\\<lambda>x. x * y \\<squnion> z) (z * y\\<^sup>\\<star>)", "proof (unfold is_least_fixpoint_def, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. z * y\\<^sup>\\<star> * y \\<squnion> z = z * y\\<^sup>\\<star>\n 2. \\<forall>ya.\n       ya * y \\<squnion> z = ya \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> ya", "have \"(z * y\\<^sup>\\<star> * y \\<squnion> z) * y \\<le> z * y\\<^sup>\\<star> * y \\<squnion> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z * y\\<^sup>\\<star> * y \\<squnion> z) * y\n    \\<le> z * y\\<^sup>\\<star> * y \\<squnion> z", "using le_supI1 mult_left_isotone star.circ_back_loop_prefixpoint"], ["proof (prove)\nusing this:\n  ?x \\<le> ?a \\<Longrightarrow> ?x \\<le> ?a \\<squnion> ?b\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  ?z * ?y\\<^sup>\\<star> * ?y \\<squnion> ?z \\<le> ?z * ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (z * y\\<^sup>\\<star> * y \\<squnion> z) * y\n    \\<le> z * y\\<^sup>\\<star> * y \\<squnion> z", "by auto"], ["proof (state)\nthis:\n  (z * y\\<^sup>\\<star> * y \\<squnion> z) * y\n  \\<le> z * y\\<^sup>\\<star> * y \\<squnion> z\n\ngoal (2 subgoals):\n 1. z * y\\<^sup>\\<star> * y \\<squnion> z = z * y\\<^sup>\\<star>\n 2. \\<forall>ya.\n       ya * y \\<squnion> z = ya \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> ya", "hence \"z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star> * y \\<squnion> z\""], ["proof (prove)\nusing this:\n  (z * y\\<^sup>\\<star> * y \\<squnion> z) * y\n  \\<le> z * y\\<^sup>\\<star> * y \\<squnion> z\n\ngoal (1 subgoal):\n 1. z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star> * y \\<squnion> z", "by (simp add: star_right_induct)"], ["proof (state)\nthis:\n  z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star> * y \\<squnion> z\n\ngoal (2 subgoals):\n 1. z * y\\<^sup>\\<star> * y \\<squnion> z = z * y\\<^sup>\\<star>\n 2. \\<forall>ya.\n       ya * y \\<squnion> z = ya \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> ya", "thus \"z * y\\<^sup>\\<star> * y \\<squnion> z = z * y\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star> * y \\<squnion> z\n\ngoal (1 subgoal):\n 1. z * y\\<^sup>\\<star> * y \\<squnion> z = z * y\\<^sup>\\<star>", "using antisym star.circ_back_loop_prefixpoint"], ["proof (prove)\nusing this:\n  z * y\\<^sup>\\<star> \\<le> z * y\\<^sup>\\<star> * y \\<squnion> z\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  ?z * ?y\\<^sup>\\<star> * ?y \\<squnion> ?z \\<le> ?z * ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z * y\\<^sup>\\<star> * y \\<squnion> z = z * y\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  z * y\\<^sup>\\<star> * y \\<squnion> z = z * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<forall>ya.\n       ya * y \\<squnion> z = ya \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> ya", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>ya.\n       ya * y \\<squnion> z = ya \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> ya", "show \"\\<forall>x. x * y \\<squnion> z = x \\<longrightarrow> z * y\\<^sup>\\<star> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x * y \\<squnion> z = x \\<longrightarrow> z * y\\<^sup>\\<star> \\<le> x", "by (simp add: star_back_loop_least_fixpoint)"], ["proof (state)\nthis:\n  \\<forall>x.\n     x * y \\<squnion> z = x \\<longrightarrow> z * y\\<^sup>\\<star> \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma star_back_loop_mu:\n  \"\\<mu> (\\<lambda>x . x * y \\<squnion> z) = z * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> (\\<lambda>x. x * y \\<squnion> z) = z * y\\<^sup>\\<star>", "by (metis least_fixpoint_same star_back_loop_is_least_fixpoint)"], ["", "lemma star_square:\n  \"x\\<^sup>\\<star> = (1 \\<squnion> x) * (x * x)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star>", "let ?f = \"\\<lambda>y . y * x \\<squnion> 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star>", "have 1: \"isotone ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone (\\<lambda>y. y * x \\<squnion> (1::'a))", "by (metis sup_left_isotone isotone_def mult_left_isotone)"], ["proof (state)\nthis:\n  isotone (\\<lambda>y. y * x \\<squnion> (1::'a))\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star>", "have \"?f \\<circ> ?f = (\\<lambda>y . y * (x * x) \\<squnion> (1 \\<squnion> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. y * x \\<squnion> (1::'a)) \\<circ>\n    (\\<lambda>y. y * x \\<squnion> (1::'a)) =\n    (\\<lambda>y. y * (x * x) \\<squnion> ((1::'a) \\<squnion> x))", "by (simp add: sup_assoc sup_commute mult_assoc mult_right_dist_sup o_def)"], ["proof (state)\nthis:\n  (\\<lambda>y. y * x \\<squnion> (1::'a)) \\<circ>\n  (\\<lambda>y. y * x \\<squnion> (1::'a)) =\n  (\\<lambda>y. y * (x * x) \\<squnion> ((1::'a) \\<squnion> x))\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>y. y * x \\<squnion> (1::'a)) \\<circ>\n  (\\<lambda>y. y * x \\<squnion> (1::'a)) =\n  (\\<lambda>y. y * (x * x) \\<squnion> ((1::'a) \\<squnion> x))\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star>", "using 1"], ["proof (prove)\nusing this:\n  (\\<lambda>y. y * x \\<squnion> (1::'a)) \\<circ>\n  (\\<lambda>y. y * x \\<squnion> (1::'a)) =\n  (\\<lambda>y. y * (x * x) \\<squnion> ((1::'a) \\<squnion> x))\n  isotone (\\<lambda>y. y * x \\<squnion> (1::'a))\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star>", "by (metis mu_square mult_left_one star_back_loop_mu has_least_fixpoint_def star_back_loop_is_least_fixpoint)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> = ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma star_square_2:\n  \"x\\<^sup>\\<star> = (x * x)\\<^sup>\\<star> * (x \\<squnion> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = (x * x)\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = (x * x)\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "have \"(1 \\<squnion> x) * (x * x)\\<^sup>\\<star> = (x * x)\\<^sup>\\<star> * 1 \\<squnion> x * (x * x)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star> =\n    (x * x)\\<^sup>\\<star> * (1::'a) \\<squnion> x * (x * x)\\<^sup>\\<star>", "using mult_right_dist_sup"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n\ngoal (1 subgoal):\n 1. ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star> =\n    (x * x)\\<^sup>\\<star> * (1::'a) \\<squnion> x * (x * x)\\<^sup>\\<star>", "by force"], ["proof (state)\nthis:\n  ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star> =\n  (x * x)\\<^sup>\\<star> * (1::'a) \\<squnion> x * (x * x)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = (x * x)\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((1::'a) \\<squnion> x) * (x * x)\\<^sup>\\<star> =\n  (x * x)\\<^sup>\\<star> * (1::'a) \\<squnion> x * (x * x)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> = (x * x)\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "by (metis (no_types) antisym mult_left_sub_dist_sup star.circ_square_2 star_slide sup_commute star_square)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> = (x * x)\\<^sup>\\<star> * (x \\<squnion> (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma star_circ_simulate_right_plus:\n  assumes \"z * x \\<le> y * y\\<^sup>\\<star> * z \\<squnion> w\"\n    shows \"z * x\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "have \"(z \\<squnion> w * x\\<^sup>\\<star>) * x \\<le> z * x \\<squnion> w * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<squnion> w * x\\<^sup>\\<star>) * x\n    \\<le> z * x \\<squnion> w * x\\<^sup>\\<star>", "using mult_right_dist_sup star.circ_back_loop_prefixpoint sup_right_isotone"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n  ?z * ?y\\<^sup>\\<star> * ?y \\<squnion> ?z \\<le> ?z * ?y\\<^sup>\\<star>\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n\ngoal (1 subgoal):\n 1. (z \\<squnion> w * x\\<^sup>\\<star>) * x\n    \\<le> z * x \\<squnion> w * x\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  (z \\<squnion> w * x\\<^sup>\\<star>) * x\n  \\<le> z * x \\<squnion> w * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "also"], ["proof (state)\nthis:\n  (z \\<squnion> w * x\\<^sup>\\<star>) * x\n  \\<le> z * x \\<squnion> w * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "have \"... \\<le> y * y\\<^sup>\\<star> * z \\<squnion> w \\<squnion> w * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x \\<squnion> w * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>+ * z \\<squnion> w \\<squnion> w * x\\<^sup>\\<star>", "using assms sup_left_isotone"], ["proof (prove)\nusing this:\n  z * x \\<le> y\\<^sup>+ * z \\<squnion> w\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> ?z \\<le> ?y \\<squnion> ?z\n\ngoal (1 subgoal):\n 1. z * x \\<squnion> w * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>+ * z \\<squnion> w \\<squnion> w * x\\<^sup>\\<star>", "by blast"], ["proof (state)\nthis:\n  z * x \\<squnion> w * x\\<^sup>\\<star>\n  \\<le> y\\<^sup>+ * z \\<squnion> w \\<squnion> w * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "also"], ["proof (state)\nthis:\n  z * x \\<squnion> w * x\\<^sup>\\<star>\n  \\<le> y\\<^sup>+ * z \\<squnion> w \\<squnion> w * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "have \"... \\<le> y * y\\<^sup>\\<star> * z \\<squnion> w * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>+ * z \\<squnion> w \\<squnion> w * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>+ * z \\<squnion> w * x\\<^sup>\\<star>", "using le_supI1 star.circ_back_loop_prefixpoint sup_commute"], ["proof (prove)\nusing this:\n  ?x \\<le> ?a \\<Longrightarrow> ?x \\<le> ?a \\<squnion> ?b\n  ?z * ?y\\<^sup>\\<star> * ?y \\<squnion> ?z \\<le> ?z * ?y\\<^sup>\\<star>\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (1 subgoal):\n 1. y\\<^sup>+ * z \\<squnion> w \\<squnion> w * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>+ * z \\<squnion> w * x\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  y\\<^sup>+ * z \\<squnion> w \\<squnion> w * x\\<^sup>\\<star>\n  \\<le> y\\<^sup>+ * z \\<squnion> w * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "also"], ["proof (state)\nthis:\n  y\\<^sup>+ * z \\<squnion> w \\<squnion> w * x\\<^sup>\\<star>\n  \\<le> y\\<^sup>+ * z \\<squnion> w * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "have \"... \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>+ * z \\<squnion> w * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "by (metis sup.bounded_iff mult_isotone mult_left_isotone mult_left_one mult_left_sub_dist_sup_left star.circ_reflexive star.left_plus_below_circ)"], ["proof (state)\nthis:\n  y\\<^sup>+ * z \\<squnion> w * x\\<^sup>\\<star>\n  \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "finally"], ["proof (chain)\npicking this:\n  (z \\<squnion> w * x\\<^sup>\\<star>) * x\n  \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "have \"y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>) * x \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\""], ["proof (prove)\nusing this:\n  (z \\<squnion> w * x\\<^sup>\\<star>) * x\n  \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>) * x\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "by (metis mult_assoc mult_right_isotone star.circ_transitive_equal)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>) * x\n  \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>) * x\n  \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)", "by (metis sup.bounded_iff star_right_induct mult_left_sub_dist_sup_left star.circ_loop_fixpoint)"], ["proof (state)\nthis:\n  z * x\\<^sup>\\<star>\n  \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transitive_star:\n  \"x * x \\<le> x \\<Longrightarrow> x\\<^sup>\\<star> = 1 \\<squnion> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> x\\<^sup>\\<star> = (1::'a) \\<squnion> x", "by (metis order.antisym star.circ_mult_increasing_2 star.circ_plus_same star_left_induct_mult star_left_unfold_equal)"], ["", "lemma star_sup_2:\n  assumes \"x * x \\<le> x\"\n    and \"x * y \\<le> x\"\n  shows \"(x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * (x \\<squnion> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "have \"(x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star>", "by (simp add: star.circ_decompose_6 star_sup_1)"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<star> =\n  y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "also"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<star> =\n  y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "have \"... = y\\<^sup>\\<star> * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * x\\<^sup>\\<star>", "using assms(2) dual_order.antisym star.circ_back_loop_prefixpoint star_right_induct_mult"], ["proof (prove)\nusing this:\n  x * y \\<le> x\n  \\<lbrakk>?b \\<le> ?a; ?a \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  ?z * ?y\\<^sup>\\<star> * ?y \\<squnion> ?z \\<le> ?z * ?y\\<^sup>\\<star>\n  ?y * ?x \\<le> ?y \\<Longrightarrow> ?y * ?x\\<^sup>\\<star> \\<le> ?y\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * x\\<^sup>\\<star>", "by fastforce"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star> =\n  y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star> =\n  y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "have \"... = y\\<^sup>\\<star> * (x \\<squnion> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * x\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "by (simp add: assms(1) sup_commute transitive_star)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> =\n  y\\<^sup>\\<star> * (x \\<squnion> (1::'a))\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "finally"], ["proof (chain)\npicking this:\n  (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * (x \\<squnion> (1::'a))\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x \\<squnion> (1::'a))", "."], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * (x \\<squnion> (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma star_circ_simulate_left_plus: \"x * z \\<le> z * y\\<^sup>\\<star> \\<squnion> w \\<longrightarrow> x\\<^sup>\\<star> * z \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\" nitpick [expect=genuine,card=7] oops\n*)"], ["", "end"], ["", "text \\<open>\nThe following class contains a generalisation of Kleene algebras, which lacks the right zero axiom.\n\\<close>"], ["", "class left_zero_kleene_algebra = idempotent_left_zero_semiring + strong_left_kleene_algebra\nbegin"], ["", "lemma star_star_absorb:\n  \"y\\<^sup>\\<star> * (y\\<^sup>\\<star> * x)\\<^sup>\\<star> * y\\<^sup>\\<star> = (y\\<^sup>\\<star> * x)\\<^sup>\\<star> * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * (y\\<^sup>\\<star> * x)\\<^sup>\\<star> *\n    y\\<^sup>\\<star> =\n    (y\\<^sup>\\<star> * x)\\<^sup>\\<star> * y\\<^sup>\\<star>", "by (metis star.circ_transitive_equal star_slide mult_assoc)"], ["", "lemma star_circ_simulate_left_plus:\n  assumes \"x * z \\<le> z * y\\<^sup>\\<star> \\<squnion> w\"\n    shows \"x\\<^sup>\\<star> * z \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "have \"x * (x\\<^sup>\\<star> * (w * y\\<^sup>\\<star>)) \\<le> x\\<^sup>\\<star> * (w * y\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (x\\<^sup>\\<star> * (w * y\\<^sup>\\<star>))\n    \\<le> x\\<^sup>\\<star> * (w * y\\<^sup>\\<star>)", "by (metis (no_types) mult_right_sub_dist_sup_left star.circ_loop_fixpoint mult_assoc)"], ["proof (state)\nthis:\n  x * (x\\<^sup>\\<star> * (w * y\\<^sup>\\<star>))\n  \\<le> x\\<^sup>\\<star> * (w * y\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "hence \"x * ((z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>) \\<le> x * z * y\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x * (x\\<^sup>\\<star> * (w * y\\<^sup>\\<star>))\n  \\<le> x\\<^sup>\\<star> * (w * y\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. x * ((z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>)\n    \\<le> x * z * y\\<^sup>\\<star> \\<squnion>\n          x\\<^sup>\\<star> * w * y\\<^sup>\\<star>", "using mult_left_dist_sup mult_right_dist_sup sup_right_isotone mult_assoc"], ["proof (prove)\nusing this:\n  x * (x\\<^sup>\\<star> * (w * y\\<^sup>\\<star>))\n  \\<le> x\\<^sup>\\<star> * (w * y\\<^sup>\\<star>)\n  ?x * (?y \\<squnion> ?z) = ?x * ?y \\<squnion> ?x * ?z\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. x * ((z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>)\n    \\<le> x * z * y\\<^sup>\\<star> \\<squnion>\n          x\\<^sup>\\<star> * w * y\\<^sup>\\<star>", "by presburger"], ["proof (state)\nthis:\n  x * ((z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>)\n  \\<le> x * z * y\\<^sup>\\<star> \\<squnion>\n        x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x * ((z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>)\n  \\<le> x * z * y\\<^sup>\\<star> \\<squnion>\n        x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "have \"... \\<le> (z * y\\<^sup>\\<star> \\<squnion> w) * y\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z * y\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\n    \\<le> (z * y\\<^sup>\\<star> \\<squnion> w) * y\\<^sup>\\<star> \\<squnion>\n          x\\<^sup>\\<star> * w * y\\<^sup>\\<star>", "using assms mult_isotone semiring.add_right_mono"], ["proof (prove)\nusing this:\n  x * z \\<le> z * y\\<^sup>\\<star> \\<squnion> w\n  \\<lbrakk>?w \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w * ?x \\<le> ?y * ?z\n  ?a \\<le> ?b \\<Longrightarrow> ?a \\<squnion> ?c \\<le> ?b \\<squnion> ?c\n\ngoal (1 subgoal):\n 1. x * z * y\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\n    \\<le> (z * y\\<^sup>\\<star> \\<squnion> w) * y\\<^sup>\\<star> \\<squnion>\n          x\\<^sup>\\<star> * w * y\\<^sup>\\<star>", "by blast"], ["proof (state)\nthis:\n  x * z * y\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\n  \\<le> (z * y\\<^sup>\\<star> \\<squnion> w) * y\\<^sup>\\<star> \\<squnion>\n        x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x * z * y\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\n  \\<le> (z * y\\<^sup>\\<star> \\<squnion> w) * y\\<^sup>\\<star> \\<squnion>\n        x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "have \"... = z * y\\<^sup>\\<star> \\<squnion> w * y\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z * y\\<^sup>\\<star> \\<squnion> w) * y\\<^sup>\\<star> \\<squnion>\n    x\\<^sup>\\<star> * w * y\\<^sup>\\<star> =\n    z * y\\<^sup>\\<star> \\<squnion> w * y\\<^sup>\\<star> \\<squnion>\n    x\\<^sup>\\<star> * w * y\\<^sup>\\<star>", "by (simp add: mult_right_dist_sup star.circ_transitive_equal mult_assoc)"], ["proof (state)\nthis:\n  (z * y\\<^sup>\\<star> \\<squnion> w) * y\\<^sup>\\<star> \\<squnion>\n  x\\<^sup>\\<star> * w * y\\<^sup>\\<star> =\n  z * y\\<^sup>\\<star> \\<squnion> w * y\\<^sup>\\<star> \\<squnion>\n  x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  (z * y\\<^sup>\\<star> \\<squnion> w) * y\\<^sup>\\<star> \\<squnion>\n  x\\<^sup>\\<star> * w * y\\<^sup>\\<star> =\n  z * y\\<^sup>\\<star> \\<squnion> w * y\\<^sup>\\<star> \\<squnion>\n  x\\<^sup>\\<star> * w * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "have \"... = (z \\<squnion> w \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * y\\<^sup>\\<star> \\<squnion> w * y\\<^sup>\\<star> \\<squnion>\n    x\\<^sup>\\<star> * w * y\\<^sup>\\<star> =\n    (z \\<squnion> w \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "by (simp add: mult_right_dist_sup)"], ["proof (state)\nthis:\n  z * y\\<^sup>\\<star> \\<squnion> w * y\\<^sup>\\<star> \\<squnion>\n  x\\<^sup>\\<star> * w * y\\<^sup>\\<star> =\n  (z \\<squnion> w \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z * y\\<^sup>\\<star> \\<squnion> w * y\\<^sup>\\<star> \\<squnion>\n  x\\<^sup>\\<star> * w * y\\<^sup>\\<star> =\n  (z \\<squnion> w \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "have \"... = (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<squnion> w \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star> =\n    (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "by (metis sup_assoc sup_ge2 le_iff_sup star.circ_loop_fixpoint)"], ["proof (state)\nthis:\n  (z \\<squnion> w \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star> =\n  (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  x * ((z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>)\n  \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  x * ((z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>)\n  \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "by (metis sup.bounded_iff mult_left_sub_dist_sup_left mult_1_right star.circ_right_unfold_1 star_left_induct)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * z\n  \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma star_one_sup_below:\n  \"x * y\\<^sup>\\<star> * (1 \\<squnion> z) \\<le> x * (y \\<squnion> z)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y\\<^sup>\\<star> * ((1::'a) \\<squnion> z)\n    \\<le> x * (y \\<squnion> z)\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y\\<^sup>\\<star> * ((1::'a) \\<squnion> z)\n    \\<le> x * (y \\<squnion> z)\\<^sup>\\<star>", "have \"y\\<^sup>\\<star> * z \\<le> (y \\<squnion> z)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * z \\<le> (y \\<squnion> z)\\<^sup>\\<star>", "using sup_ge2 order_trans star.circ_increasing star.circ_mult_upper_bound star.circ_sub_dist"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<squnion> ?y\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  ?x \\<le> ?x\\<^sup>\\<star>\n  \\<lbrakk>?x \\<le> ?z\\<^sup>\\<star>; ?y \\<le> ?z\\<^sup>\\<star>\\<rbrakk>\n  \\<Longrightarrow> ?x * ?y \\<le> ?z\\<^sup>\\<star>\n  ?x\\<^sup>\\<star> \\<le> (?x \\<squnion> ?y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * z \\<le> (y \\<squnion> z)\\<^sup>\\<star>", "by blast"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * z \\<le> (y \\<squnion> z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x * y\\<^sup>\\<star> * ((1::'a) \\<squnion> z)\n    \\<le> x * (y \\<squnion> z)\\<^sup>\\<star>", "hence \"y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * z \\<le> (y \\<squnion> z)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> * z \\<le> (y \\<squnion> z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * z\n    \\<le> (y \\<squnion> z)\\<^sup>\\<star>", "by (simp add: star.circ_sup_upper_bound star.circ_sub_dist)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * z\n  \\<le> (y \\<squnion> z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x * y\\<^sup>\\<star> * ((1::'a) \\<squnion> z)\n    \\<le> x * (y \\<squnion> z)\\<^sup>\\<star>", "hence \"y\\<^sup>\\<star> * (1 \\<squnion> z) \\<le> (y \\<squnion> z)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * z\n  \\<le> (y \\<squnion> z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * ((1::'a) \\<squnion> z)\n    \\<le> (y \\<squnion> z)\\<^sup>\\<star>", "by (simp add: mult_left_dist_sup)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * ((1::'a) \\<squnion> z)\n  \\<le> (y \\<squnion> z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x * y\\<^sup>\\<star> * ((1::'a) \\<squnion> z)\n    \\<le> x * (y \\<squnion> z)\\<^sup>\\<star>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> * ((1::'a) \\<squnion> z)\n  \\<le> (y \\<squnion> z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x * y\\<^sup>\\<star> * ((1::'a) \\<squnion> z)\n    \\<le> x * (y \\<squnion> z)\\<^sup>\\<star>", "by (metis mult_right_isotone mult_assoc)"], ["proof (state)\nthis:\n  x * y\\<^sup>\\<star> * ((1::'a) \\<squnion> z)\n  \\<le> x * (y \\<squnion> z)\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following theorem is similar to the puzzle where persons insert themselves always in the middle between two groups of people in a line.\nHere, however, items in the middle annihilate each other, leaving just one group of items behind.\n\\<close>"], ["", "lemma cancel_separate:\n  assumes \"x * y \\<le> 1\"\n    shows \"x\\<^sup>\\<star> * y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "have \"x * y\\<^sup>\\<star> = x \\<squnion> x * y * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y\\<^sup>\\<star> = x \\<squnion> x * y * y\\<^sup>\\<star>", "by (metis mult_assoc mult_left_dist_sup mult_1_right star_left_unfold_equal)"], ["proof (state)\nthis:\n  x * y\\<^sup>\\<star> = x \\<squnion> x * y * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x * y\\<^sup>\\<star> = x \\<squnion> x * y * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "have \"... \\<le> x \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> x * y * y\\<^sup>\\<star> \\<le> x \\<squnion> y\\<^sup>\\<star>", "by (meson assms dual_order.trans order.refl star.circ_mult_upper_bound star.circ_reflexive sup_right_isotone)"], ["proof (state)\nthis:\n  x \\<squnion> x * y * y\\<^sup>\\<star> \\<le> x \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x \\<squnion> x * y * y\\<^sup>\\<star> \\<le> x \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "have \"... \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "using star.circ_increasing sup_left_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x\\<^sup>\\<star>\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> ?z \\<le> ?y \\<squnion> ?z\n\ngoal (1 subgoal):\n 1. x \\<squnion> y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  x \\<squnion> y\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  x * y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "have 1: \"x * y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x * y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x * y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "."], ["proof (state)\nthis:\n  x * y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "have \"x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>) = x * x\\<^sup>\\<star> \\<squnion> x * y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>) =\n    x\\<^sup>+ \\<squnion> x * y\\<^sup>\\<star>", "by (simp add: mult_left_dist_sup)"], ["proof (state)\nthis:\n  x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>) =\n  x\\<^sup>+ \\<squnion> x * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>) =\n  x\\<^sup>+ \\<squnion> x * y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "have \"... \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>+ \\<squnion> x * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "using 1"], ["proof (prove)\nusing this:\n  x * y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>+ \\<squnion> x * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "by (metis sup.bounded_iff sup_ge1 order_trans star.left_plus_below_circ)"], ["proof (state)\nthis:\n  x\\<^sup>+ \\<squnion> x * y\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "have 2: \"x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>) \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "."], ["proof (state)\nthis:\n  x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "have \"y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "hence \"y\\<^sup>\\<star> \\<squnion> x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>) \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<squnion>\n    x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "using 2 sup.bounded_iff"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n  x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n  (?b \\<squnion> ?c \\<le> ?a) = (?b \\<le> ?a \\<and> ?c \\<le> ?a)\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<squnion>\n    x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "by blast"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<squnion>\n  x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "thus ?thesis"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> \\<squnion>\n  x * (x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>)\n  \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "by (metis star_left_induct)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * y\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma star_separate:\n  assumes \"x * y = bot\"\n      and \"y * y = bot\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "have 1: \"y\\<^sup>\\<star> = 1 \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> = (1::'a) \\<squnion> y", "using assms(2)"], ["proof (prove)\nusing this:\n  y * y = bot\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> = (1::'a) \\<squnion> y", "by (simp add: transitive_star)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> = (1::'a) \\<squnion> y\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "have \"(x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star>", "by (simp add: star.circ_decompose_6 star_sup_1)"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<star> =\n  y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<star> =\n  y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "have \"... = y\\<^sup>\\<star> * (x * (1 \\<squnion> y * y\\<^sup>\\<star>))\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * (x * ((1::'a) \\<squnion> y\\<^sup>+))\\<^sup>\\<star>", "by (simp add: star_left_unfold_equal)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star> =\n  y\\<^sup>\\<star> * (x * ((1::'a) \\<squnion> y\\<^sup>+))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * (x * y\\<^sup>\\<star>)\\<^sup>\\<star> =\n  y\\<^sup>\\<star> * (x * ((1::'a) \\<squnion> y\\<^sup>+))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "have \"... = (1 \\<squnion> y) * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * (x * ((1::'a) \\<squnion> y\\<^sup>+))\\<^sup>\\<star> =\n    ((1::'a) \\<squnion> y) * x\\<^sup>\\<star>", "using 1"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> = (1::'a) \\<squnion> y\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * (x * ((1::'a) \\<squnion> y\\<^sup>+))\\<^sup>\\<star> =\n    ((1::'a) \\<squnion> y) * x\\<^sup>\\<star>", "by (simp add: assms mult_left_dist_sup)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * (x * ((1::'a) \\<squnion> y\\<^sup>+))\\<^sup>\\<star> =\n  ((1::'a) \\<squnion> y) * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * (x * ((1::'a) \\<squnion> y\\<^sup>+))\\<^sup>\\<star> =\n  ((1::'a) \\<squnion> y) * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "have \"... = x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<squnion> y) * x\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "by (simp add: mult_right_dist_sup)"], ["proof (state)\nthis:\n  ((1::'a) \\<squnion> y) * x\\<^sup>\\<star> =\n  x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  (x \\<squnion> y)\\<^sup>\\<star> =\n  x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  (x \\<squnion> y)\\<^sup>\\<star> =\n  x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>", "."], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<star> =\n  x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\nWe can now inherit from the strongest variant of iterings.\n\\<close>"], ["", "sublocale left_zero_kleene_algebra < star: itering where circ = star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.itering star (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<star> =\n       (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<star>\n 2. \\<And>x y. (x * y)\\<^sup>\\<star> = Rf (x * (y * x)\\<^sup>\\<star>) y\n 3. \\<And>z x y w.\n       z * x \\<le> y\\<^sup>+ * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<star>\n       \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\n 4. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<star> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<star> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "apply (metis star.circ_sup_9)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. (x * y)\\<^sup>\\<star> = Rf (x * (y * x)\\<^sup>\\<star>) y\n 2. \\<And>z x y w.\n       z * x \\<le> y\\<^sup>+ * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<star>\n       \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\n 3. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<star> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<star> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "apply (metis star.circ_mult_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z x y w.\n       z * x \\<le> y\\<^sup>+ * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<star>\n       \\<le> y\\<^sup>\\<star> * (z \\<squnion> w * x\\<^sup>\\<star>)\n 2. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<star> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<star> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "apply (simp add: star_circ_simulate_right_plus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<star> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<star> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<star> * w) * y\\<^sup>\\<star>", "by (simp add: star_circ_simulate_left_plus)"], ["", "context left_zero_kleene_algebra\nbegin"], ["", "lemma star_absorb:\n  \"x * y = bot \\<Longrightarrow> x * y\\<^sup>\\<star> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = bot \\<Longrightarrow> x * y\\<^sup>\\<star> = x", "by (metis sup.bounded_iff antisym_conv star.circ_back_loop_prefixpoint star.circ_elimination)"], ["", "lemma star_separate_2:\n  assumes \"x * z\\<^sup>+ * y = bot\"\n      and \"y * z\\<^sup>+ * y = bot\"\n      and \"z * x = bot\"\n    shows \"(x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * (z * (1 \\<squnion> y * x\\<^sup>\\<star>))\\<^sup>\\<star> = z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have 1: \"x\\<^sup>\\<star> * z\\<^sup>+ * y = z\\<^sup>+ * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * z\\<^sup>+ * y = z\\<^sup>+ * y", "by (metis assms mult_assoc mult_1_left mult_left_zero star.circ_zero star_simulation_right_equal)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * z\\<^sup>+ * y = z\\<^sup>+ * y\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have 2: \"z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>+ \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+\n    \\<le> z\\<^sup>\\<star> *\n          (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          z\\<^sup>\\<star>", "by (simp add: mult_right_isotone star.left_plus_below_circ)"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> * y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n    \\<le> z\\<^sup>\\<star> * y * x\\<^sup>\\<star>", "by (metis mult_left_isotone star.left_plus_below_circ star.right_plus_circ star_plus)"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n  \\<le> z\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n  \\<le> z\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"... \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n    \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)", "by (simp add: mult_assoc mult_left_sub_dist_sup_right)"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"... \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)\n    \\<le> z\\<^sup>\\<star> *\n          (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          z\\<^sup>\\<star>", "using sup_right_divisibility star.circ_back_loop_fixpoint"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n  ?z * ?y\\<^sup>\\<star> * ?y \\<squnion> ?z = ?z * ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)\n    \\<le> z\\<^sup>\\<star> *\n          (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          z\\<^sup>\\<star>", "by blast"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>", "have 3: \"z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n    \\<le> z\\<^sup>\\<star> *\n          (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          z\\<^sup>\\<star>", "."], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star> * (z * (1 \\<squnion> y * x\\<^sup>\\<star>)) = z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>+ \\<squnion> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>+ * y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star> *\n    (z * Rf y (x\\<^sup>\\<star>)) =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ *\n    y *\n    x\\<^sup>\\<star>", "by (metis mult_1_right semiring.distrib_left star.circ_plus_same mult_assoc)"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>\\<star> *\n  (z * Rf y (x\\<^sup>\\<star>)) =\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ *\n  y *\n  x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>\\<star> *\n  (z * Rf y (x\\<^sup>\\<star>)) =\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ *\n  y *\n  x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"... = z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>+ \\<squnion> z\\<^sup>\\<star> * (1 \\<squnion> y) * x\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ *\n    y *\n    x\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<star> * z\\<^sup>+ *\n    y *\n    x\\<^sup>\\<star>", "by (simp add: semiring.distrib_right mult_assoc)"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ *\n  y *\n  x\\<^sup>\\<star> =\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<star> * z\\<^sup>+ *\n  y *\n  x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ *\n  y *\n  x\\<^sup>\\<star> =\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<star> * z\\<^sup>+ *\n  y *\n  x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"... = z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>+ \\<squnion> z\\<^sup>\\<star> * (1 \\<squnion> y) * z\\<^sup>+ * y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<star> * z\\<^sup>+ *\n    y *\n    x\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * z\\<^sup>+ * y *\n    x\\<^sup>\\<star>", "using 1"], ["proof (prove)\nusing this:\n  x\\<^sup>\\<star> * z\\<^sup>+ * y = z\\<^sup>+ * y\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<star> * z\\<^sup>+ *\n    y *\n    x\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * z\\<^sup>+ * y *\n    x\\<^sup>\\<star>", "by (simp add: mult_assoc)"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<star> * z\\<^sup>+ *\n  y *\n  x\\<^sup>\\<star> =\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * z\\<^sup>+ * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * x\\<^sup>\\<star> * z\\<^sup>+ *\n  y *\n  x\\<^sup>\\<star> =\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * z\\<^sup>+ * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"... = z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>+ \\<squnion> z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star> \\<squnion> z\\<^sup>\\<star> * y * z\\<^sup>+ * y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * z\\<^sup>+ * y *\n    x\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star> \\<squnion>\n    z\\<^sup>\\<star> * y * z\\<^sup>+ * y * x\\<^sup>\\<star>", "using mult_left_dist_sup mult_right_dist_sup sup_assoc"], ["proof (prove)\nusing this:\n  ?x * (?y \\<squnion> ?z) = ?x * ?y \\<squnion> ?x * ?z\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n  ?x \\<squnion> ?y \\<squnion> ?z = ?x \\<squnion> (?y \\<squnion> ?z)\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * z\\<^sup>+ * y *\n    x\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star> \\<squnion>\n    z\\<^sup>\\<star> * y * z\\<^sup>+ * y * x\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * z\\<^sup>+ * y *\n  x\\<^sup>\\<star> =\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star> \\<squnion>\n  z\\<^sup>\\<star> * y * z\\<^sup>+ * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * ((1::'a) \\<squnion> y) * z\\<^sup>+ * y *\n  x\\<^sup>\\<star> =\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star> \\<squnion>\n  z\\<^sup>\\<star> * y * z\\<^sup>+ * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"... = z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>+ \\<squnion> z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star> \\<squnion>\n    z\\<^sup>\\<star> * y * z\\<^sup>+ * y * x\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>", "by (metis assms(2) mult_left_dist_sup mult_left_zero sup_commute sup_monoid.add_0_left mult_assoc)"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star> \\<squnion>\n  z\\<^sup>\\<star> * y * z\\<^sup>+ * y * x\\<^sup>\\<star> =\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star> \\<squnion>\n  z\\<^sup>\\<star> * y * z\\<^sup>+ * y * x\\<^sup>\\<star> =\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"... \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n    \\<le> z\\<^sup>\\<star> *\n          (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          z\\<^sup>\\<star>", "using 2 3"], ["proof (prove)\nusing this:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>+ \\<squnion>\n    z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n    \\<le> z\\<^sup>\\<star> *\n          (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          z\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>+ \\<squnion>\n  z\\<^sup>\\<star> * z\\<^sup>+ * y * x\\<^sup>\\<star>\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>\\<star> *\n  (z * Rf y (x\\<^sup>\\<star>))\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>", "have \"(x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) \\<squnion> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star> * (z * (1 \\<squnion> y * x\\<^sup>\\<star>)) \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>\\<star> *\n  (z * Rf y (x\\<^sup>\\<star>))\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star> \\<squnion>\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star> *\n    (z * Rf y (x\\<^sup>\\<star>))\n    \\<le> z\\<^sup>\\<star> *\n          (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          z\\<^sup>\\<star>", "by (simp add: star_outer_increasing)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star> \\<squnion>\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>\\<star> *\n  (z * Rf y (x\\<^sup>\\<star>))\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "hence 4: \"(x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * (z * (1 \\<squnion> y * x\\<^sup>\\<star>))\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star> \\<squnion>\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>\\<star> *\n  (z * Rf y (x\\<^sup>\\<star>))\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n    \\<le> z\\<^sup>\\<star> *\n          (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          z\\<^sup>\\<star>", "by (simp add: star_right_induct)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have 5: \"(x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star> \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * (z * (1 \\<squnion> y * x\\<^sup>\\<star>))\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star>\n    \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>", "by (metis sup_ge1 mult_right_isotone mult_1_right star_isotone)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star>\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) = z * x\\<^sup>\\<star> \\<squnion> z * y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) =\n    z * x\\<^sup>\\<star> \\<squnion> z * y * x\\<^sup>\\<star>", "by (simp add: mult_assoc mult_left_dist_sup)"], ["proof (state)\nthis:\n  z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) =\n  z * x\\<^sup>\\<star> \\<squnion> z * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) =\n  z * x\\<^sup>\\<star> \\<squnion> z * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"... = z \\<squnion> z * y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<star> \\<squnion> z * y * x\\<^sup>\\<star> =\n    z \\<squnion> z * y * x\\<^sup>\\<star>", "by (simp add: assms star_absorb)"], ["proof (state)\nthis:\n  z * x\\<^sup>\\<star> \\<squnion> z * y * x\\<^sup>\\<star> =\n  z \\<squnion> z * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z * x\\<^sup>\\<star> \\<squnion> z * y * x\\<^sup>\\<star> =\n  z \\<squnion> z * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"... = z * (1 \\<squnion> y * x\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<squnion> z * y * x\\<^sup>\\<star> = z * Rf y (x\\<^sup>\\<star>)", "by (simp add: mult_assoc mult_left_dist_sup)"], ["proof (state)\nthis:\n  z \\<squnion> z * y * x\\<^sup>\\<star> = z * Rf y (x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z \\<squnion> z * y * x\\<^sup>\\<star> = z * Rf y (x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"... \\<le> (z * (1 \\<squnion> y * x\\<^sup>\\<star>))\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * Rf y (x\\<^sup>\\<star>)\n    \\<le> (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>", "by (simp add: star.circ_increasing)"], ["proof (state)\nthis:\n  z * Rf y (x\\<^sup>\\<star>)\n  \\<le> (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  z * Rf y (x\\<^sup>\\<star>)\n  \\<le> (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "have \"... \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * (z * (1 \\<squnion> y * x\\<^sup>\\<star>))\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n    \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>", "by (metis le_supE mult_right_sub_dist_sup_left star.circ_loop_fixpoint)"], ["proof (state)\nthis:\n  (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>", "have \"z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * (z * (1 \\<squnion> y * x\\<^sup>\\<star>))\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)\n    \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>", "."], ["proof (state)\nthis:\n  z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "hence \"z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * (z * (1 \\<squnion> y * x\\<^sup>\\<star>))\\<^sup>\\<star> \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * (z * (1 \\<squnion> y * x\\<^sup>\\<star>))\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>)\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n    \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>", "by (metis mult_assoc mult_left_isotone star.circ_transitive_equal)"], ["proof (state)\nthis:\n  z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "hence \"z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star> \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * (z * (1 \\<squnion> y * x\\<^sup>\\<star>))\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>\n    \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>", "using 5"], ["proof (prove)\nusing this:\n  z * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n  (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) * z\\<^sup>\\<star>\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>\n    \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n          (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>", "by (metis star_left_induct sup.bounded_iff mult_assoc)"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>\\<star>\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "thus ?thesis"], ["proof (prove)\nusing this:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>\\<star>\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "using 4"], ["proof (prove)\nusing this:\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>\\<star>\n  \\<le> (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n  (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star>\n  \\<le> z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n        z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n    z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n    z\\<^sup>\\<star>", "by (simp add: antisym)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  (z * Rf y (x\\<^sup>\\<star>))\\<^sup>\\<star> =\n  z\\<^sup>\\<star> * (x\\<^sup>\\<star> \\<squnion> y * x\\<^sup>\\<star>) *\n  z\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cancel_separate_eq:\n  \"x * y \\<le> 1 \\<Longrightarrow> x\\<^sup>\\<star> * y\\<^sup>\\<star> = x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (x * y) \\<Longrightarrow>\n    x\\<^sup>\\<star> * y\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "by (metis antisym cancel_separate star.circ_plus_one star.circ_sup_sub_sup_one_1 star_involutive)"], ["", "lemma cancel_separate_1:\n  assumes \"x * y \\<le> 1\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "have \"y\\<^sup>\\<star> * x\\<^sup>\\<star> * y = y\\<^sup>\\<star> * x\\<^sup>\\<star> * x * y \\<squnion> y\\<^sup>\\<star> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * x\\<^sup>\\<star> * y =\n    y\\<^sup>\\<star> * x\\<^sup>\\<star> * x * y \\<squnion> y\\<^sup>\\<star> * y", "by (metis mult_right_dist_sup star.circ_back_loop_fixpoint)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * y =\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * x * y \\<squnion> y\\<^sup>\\<star> * y\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * y =\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * x * y \\<squnion> y\\<^sup>\\<star> * y\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "have \"... \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * x\\<^sup>\\<star> * x * y \\<squnion> y\\<^sup>\\<star> * y\n    \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * y", "by (metis assms semiring.add_right_mono mult_right_isotone mult_1_right mult_assoc)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * x * y \\<squnion> y\\<^sup>\\<star> * y\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * y\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * x * y \\<squnion> y\\<^sup>\\<star> * y\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * y\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "have \"... \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * y\n    \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "using semiring.add_left_mono star.right_plus_below_circ"], ["proof (prove)\nusing this:\n  ?a \\<le> ?b \\<Longrightarrow> ?c \\<squnion> ?a \\<le> ?c \\<squnion> ?b\n  ?x\\<^sup>\\<star> * ?x \\<le> ?x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * y\n    \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * y\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * y\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "have \"... = y\\<^sup>\\<star> * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * x\\<^sup>\\<star>", "by (metis star.circ_back_loop_fixpoint sup.left_idem sup_commute)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> =\n  y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * y\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>", "have \"y\\<^sup>\\<star> * x\\<^sup>\\<star> * y \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * y\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * x\\<^sup>\\<star> * y\n    \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * y\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "hence \"y\\<^sup>\\<star> * x\\<^sup>\\<star> * (x \\<squnion> y) \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> * x \\<squnion> y\\<^sup>\\<star> * x\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * y\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * x\\<^sup>\\<star> * (x \\<squnion> y)\n    \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> * x \\<squnion>\n          y\\<^sup>\\<star> * x\\<^sup>\\<star>", "using mult_left_dist_sup order_lesseq_imp"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * y\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\n  ?x * (?y \\<squnion> ?z) = ?x * ?y \\<squnion> ?x * ?z\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * x\\<^sup>\\<star> * (x \\<squnion> y)\n    \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> * x \\<squnion>\n          y\\<^sup>\\<star> * x\\<^sup>\\<star>", "by fastforce"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * (x \\<squnion> y)\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> * x \\<squnion>\n        y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * (x \\<squnion> y)\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star> * x \\<squnion>\n        y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "have \"... = y\\<^sup>\\<star> * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * x\\<^sup>\\<star> * x \\<squnion>\n    y\\<^sup>\\<star> * x\\<^sup>\\<star> =\n    y\\<^sup>\\<star> * x\\<^sup>\\<star>", "by (metis star.circ_back_loop_fixpoint sup.left_idem)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * x \\<squnion>\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> =\n  y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * (x \\<squnion> y)\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>", "have \"(x \\<squnion> y)\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> * x\\<^sup>\\<star> * (x \\<squnion> y)\n  \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>", "by (metis star.circ_decompose_7 star_right_induct_mult sup_commute)"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x \\<squnion> y)\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "using antisym star.circ_sub_dist_3 sup_commute"], ["proof (prove)\nusing this:\n  (x \\<squnion> y)\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> * x\\<^sup>\\<star>\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  ?x\\<^sup>\\<star> * ?y\\<^sup>\\<star> \\<le> (?x \\<squnion> ?y)\\<^sup>\\<star>\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>", "by fastforce"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> * x\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_sup:\n  \"(x \\<squnion> y)\\<^sup>+ = (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>+ \\<squnion> (x\\<^sup>\\<star> * y)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>+ =\n    (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>+ \\<squnion>\n    (x\\<^sup>\\<star> * y)\\<^sup>+", "by (metis semiring.distrib_left star.circ_sup_9 star_plus mult_assoc)"], ["", "lemma plus_half_bot:\n  \"x * y * x = bot \\<Longrightarrow> (x * y)\\<^sup>+ = x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * x = bot \\<Longrightarrow> (x * y)\\<^sup>+ = x * y", "by (metis star_absorb star_slide mult_assoc)"], ["", "lemma cancel_separate_1_sup:\n  assumes \"x * y \\<le> 1\"\n      and \"y * x \\<le> 1\"\n  shows \"(x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>", "by (simp add: assms cancel_separate_1 cancel_separate_eq sup_commute)"], ["", "text \\<open>Lemma \\<open>star_separate_3\\<close> was contributed by Nicolas Robinson-O'Brien.\\<close>"], ["", "lemma star_separate_3:\n  assumes \"y * x\\<^sup>\\<star> * y \\<le> y\"\n    shows \"(x \\<squnion> y)\\<^sup>\\<star> = x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star> =\n    x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n 2. x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "have \"x\\<^sup>\\<star> * y * (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> * y)\\<^sup>+ * x\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>", "by (metis assms mult_left_isotone mult_right_isotone star_right_induct_mult mult_assoc)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> * y)\\<^sup>+ * x\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n 2. x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "thus \"(x \\<squnion> y)\\<^sup>\\<star> \\<le> x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  (x\\<^sup>\\<star> * y)\\<^sup>+ * x\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<star>\n    \\<le> x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>", "by (metis antisym semiring.add_left_mono star.circ_sup_2 star.circ_sup_sub star.circ_unfold_sum star_decompose_3 star_slide mult_assoc)"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<star>\n  \\<le> x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "show \"x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star> \\<le> (x \\<squnion> y)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "using mult_isotone star.circ_increasing star.circ_sub_dist star.circ_sup_9"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w * ?x \\<le> ?y * ?z\n  ?x \\<le> ?x\\<^sup>\\<star>\n  ?x\\<^sup>\\<star> \\<le> (?x \\<squnion> ?y)\\<^sup>\\<star>\n  (?x \\<squnion> ?y)\\<^sup>\\<star> =\n  (?x\\<^sup>\\<star> * ?y)\\<^sup>\\<star> * ?x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star> * y * x\\<^sup>\\<star>\n  \\<le> (x \\<squnion> y)\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\nA Kleene algebra is obtained by requiring an idempotent semiring.\n\\<close>"], ["", "class kleene_algebra = left_zero_kleene_algebra + idempotent_semiring"], ["", "text \\<open>\nThe following classes are variants of Kleene algebras expanded by an additional iteration operation.\nThis is useful to study the Kleene star in computation models that do not use least fixpoints in the refinement order as the semantics of recursion.\n\\<close>"], ["", "class left_kleene_conway_semiring = left_kleene_algebra + left_conway_semiring\nbegin"], ["", "lemma star_below_circ:\n  \"x\\<^sup>\\<star> \\<le> x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<le> x\\<^sup>\\<circ>", "by (metis circ_left_unfold mult_1_right order_refl star_left_induct)"], ["", "lemma star_zero_below_circ_mult:\n  \"x\\<^sup>\\<star> * bot \\<le> x\\<^sup>\\<circ> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * bot \\<le> x\\<^sup>\\<circ> * y", "by (simp add: mult_isotone star_below_circ)"], ["", "lemma star_mult_circ:\n  \"x\\<^sup>\\<star> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * x\\<^sup>\\<circ> = x\\<^sup>\\<circ>", "by (metis sup_right_divisibility antisym circ_left_unfold star_left_induct_mult star.circ_loop_fixpoint)"], ["", "lemma circ_mult_star:\n  \"x\\<^sup>\\<circ> * x\\<^sup>\\<star> = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * x\\<^sup>\\<star> = x\\<^sup>\\<circ>", "by (metis sup_assoc sup.bounded_iff circ_left_unfold circ_rtc_2 eq_iff left_plus_circ star.circ_sup_sub star.circ_back_loop_prefixpoint star.circ_increasing star_below_circ star_mult_circ star_sup_one)"], ["", "lemma circ_star:\n  \"x\\<^sup>\\<circ>\\<^sup>\\<star> = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ>\\<^sup>\\<star> = x\\<^sup>\\<circ>", "by (metis antisym circ_reflexive circ_transitive_equal star.circ_increasing star.circ_sup_one_right_unfold star_left_induct_mult_equal)"], ["", "lemma star_circ:\n  \"x\\<^sup>\\<star>\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star>\\<^sup>\\<circ> = x\\<^sup>\\<circ>\\<^sup>\\<circ>", "by (metis antisym circ_circ_sup circ_sub_dist le_iff_sup star.circ_rtc_2 star_below_circ)"], ["", "lemma circ_sup_3:\n  \"(x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<star> \\<le> (x \\<squnion> y)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<circ>", "using circ_star circ_sub_dist_3 star_isotone"], ["proof (prove)\nusing this:\n  ?x\\<^sup>\\<circ>\\<^sup>\\<star> = ?x\\<^sup>\\<circ>\n  ?x\\<^sup>\\<circ> * ?y\\<^sup>\\<circ> \\<le> (?x \\<squnion> ?y)\\<^sup>\\<circ>\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> \\<le> ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y\\<^sup>\\<circ>)\\<^sup>\\<star>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<circ>", "by fastforce"], ["", "end"], ["", "class left_zero_kleene_conway_semiring = left_zero_kleene_algebra + itering\nbegin"], ["", "subclass left_kleene_conway_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.left_kleene_conway_semiring circ (1::'a) (*) (\\<squnion>) (\\<le>)\n     (<) bot star", ".."], ["", "lemma circ_isolate:\n  \"x\\<^sup>\\<circ> = x\\<^sup>\\<circ> * bot \\<squnion> x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> = x\\<^sup>\\<circ> * bot \\<squnion> x\\<^sup>\\<star>", "by (metis sup_commute antisym circ_sup_upper_bound circ_mult_star circ_simulate_absorb star.left_plus_below_circ star_below_circ zero_right_mult_decreasing)"], ["", "lemma circ_isolate_mult:\n  \"x\\<^sup>\\<circ> * y = x\\<^sup>\\<circ> * bot \\<squnion> x\\<^sup>\\<star> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y =\n    x\\<^sup>\\<circ> * bot \\<squnion> x\\<^sup>\\<star> * y", "by (metis circ_isolate mult_assoc mult_left_zero mult_right_dist_sup)"], ["", "lemma circ_isolate_mult_sub:\n  \"x\\<^sup>\\<circ> * y \\<le> x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<star> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * y \\<le> x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<star> * y", "by (metis sup_left_isotone circ_isolate_mult zero_right_mult_decreasing)"], ["", "lemma circ_sub_decompose:\n  \"(x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> \\<le> (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ>\n    \\<le> (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ>\n    \\<le> (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "have \"x\\<^sup>\\<star> * y \\<squnion> x\\<^sup>\\<circ> * bot = x\\<^sup>\\<circ> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y \\<squnion> x\\<^sup>\\<circ> * bot =\n    x\\<^sup>\\<circ> * y", "by (metis sup.commute circ_isolate_mult)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * y \\<squnion> x\\<^sup>\\<circ> * bot = x\\<^sup>\\<circ> * y\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ>\n    \\<le> (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "hence \"(x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> = ((x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ>)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x\\<^sup>\\<star> * y \\<squnion> x\\<^sup>\\<circ> * bot = x\\<^sup>\\<circ> * y\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> =\n    ((x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> \\<squnion>\n     x\\<^sup>\\<circ>)\\<^sup>\\<star>", "by (metis circ_star circ_sup_9 circ_sup_mult_zero star_decompose_1)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> =\n  ((x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> \\<squnion>\n   x\\<^sup>\\<circ>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ>\n    \\<le> (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> =\n  ((x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> \\<squnion>\n   x\\<^sup>\\<circ>)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ>\n    \\<le> (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "by (metis circ_star le_iff_sup star.circ_decompose_7 star.circ_unfold_sum)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ>\n  \\<le> (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circ_sup_4:\n  \"(x \\<squnion> y)\\<^sup>\\<circ> = (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<circ> =\n    (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<circ>\n    \\<le> (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n 2. (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<circ>", "apply (metis circ_sup circ_sub_decompose circ_transitive_equal mult_assoc mult_left_isotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<circ>", "by (metis circ_sup circ_isotone mult_left_isotone star_below_circ)"], ["", "lemma circ_sup_5:\n  \"(x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> = (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> =\n    (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "using circ_sup_4 circ_sup_9"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y)\\<^sup>\\<circ> =\n  (?x\\<^sup>\\<star> * ?y)\\<^sup>\\<circ> * ?x\\<^sup>\\<circ>\n  (?x \\<squnion> ?y)\\<^sup>\\<circ> =\n  (?x\\<^sup>\\<circ> * ?y)\\<^sup>\\<circ> * ?x\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ> =\n    (x\\<^sup>\\<star> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>", "by auto"], ["", "lemma plus_circ:\n  \"(x\\<^sup>\\<star> * x)\\<^sup>\\<circ> = x\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> * x)\\<^sup>\\<circ> = x\\<^sup>\\<circ>", "by (metis sup_idem circ_sup_4 circ_decompose_7 circ_star star.circ_decompose_5 star.right_plus_circ)"], ["", "(*\nlemma \"(x\\<^sup>\\<star> * y * x\\<^sup>\\<star>)\\<^sup>\\<circ> = (x\\<^sup>\\<star> * y)\\<^sup>\\<circ>\" nitpick [expect=genuine] oops\n*)"], ["", "end"], ["", "text \\<open>\nThe following classes add a greatest element.\n\\<close>"], ["", "class bounded_left_kleene_algebra = bounded_idempotent_left_semiring + left_kleene_algebra"], ["", "sublocale bounded_left_kleene_algebra < star: bounded_left_conway_semiring where circ = star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_left_conway_semiring star (1::'a) (*) (\\<squnion>) (\\<le>)\n     (<) bot top", ".."], ["", "class bounded_left_zero_kleene_algebra = bounded_idempotent_left_semiring + left_zero_kleene_algebra"], ["", "sublocale bounded_left_zero_kleene_algebra < star: bounded_itering where circ = star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_itering star (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot top", ".."], ["", "class bounded_kleene_algebra = bounded_idempotent_semiring + kleene_algebra"], ["", "sublocale bounded_kleene_algebra < star: bounded_itering where circ = star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_itering star (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot top", ".."], ["", "text \\<open>\nWe conclude with an alternative axiomatisation of Kleene algebras.\n\\<close>"], ["", "class kleene_algebra_var = idempotent_semiring + star +\n  assumes star_left_unfold_var : \"1 \\<squnion> y * y\\<^sup>\\<star> \\<le> y\\<^sup>\\<star>\"\n  assumes star_left_induct_var : \"y * x \\<le> x \\<longrightarrow> y\\<^sup>\\<star> * x \\<le> x\"\n  assumes star_right_induct_var : \"x * y \\<le> x \\<longrightarrow> x * y\\<^sup>\\<star> \\<le> x\"\nbegin"], ["", "subclass kleene_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.kleene_algebra star (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y. Rf y (y\\<^sup>\\<star>) \\<le> y\\<^sup>\\<star>\n 2. \\<And>z y x.\n       z \\<squnion> y * x \\<le> x \\<longrightarrow>\n       y\\<^sup>\\<star> * z \\<le> x\n 3. \\<And>z x y.\n       z \\<squnion> x * y \\<le> x \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> x", "apply (rule star_left_unfold_var)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z y x.\n       z \\<squnion> y * x \\<le> x \\<longrightarrow>\n       y\\<^sup>\\<star> * z \\<le> x\n 2. \\<And>z x y.\n       z \\<squnion> x * y \\<le> x \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> x", "apply (meson sup.bounded_iff mult_right_isotone order_trans star_left_induct_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z x y.\n       z \\<squnion> x * y \\<le> x \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> x", "by (meson sup.bounded_iff mult_left_isotone order_trans star_right_induct_var)"], ["", "end"], ["", "end"]]}