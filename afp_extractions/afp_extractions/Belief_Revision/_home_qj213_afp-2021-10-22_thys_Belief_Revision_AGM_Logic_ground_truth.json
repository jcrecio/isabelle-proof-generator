{"file_name": "/home/qj213/afp-2021-10-22/thys/Belief_Revision/AGM_Logic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Belief_Revision", "problem_names": ["lemma idempotency_L: \\<open>Cn(Cn(A)) = Cn(A)\\<close>", "lemma assumption_L: \\<open>\\<phi> \\<in> A \\<Longrightarrow> A \\<turnstile> \\<phi>\\<close>", "lemma validD_L: \\<open>\\<tturnstile> \\<phi> \\<Longrightarrow> \\<phi> \\<in> Cn(A)\\<close>", "lemma valid_expansion: \\<open>K = Cn(A) \\<Longrightarrow> \\<tturnstile> \\<phi> \\<Longrightarrow> K \\<oplus> \\<phi> = K\\<close>", "lemma transitivity2_L:\n  assumes \\<open>\\<forall>\\<phi> \\<in> B. A \\<turnstile> \\<phi>\\<close>\n      and \\<open>B \\<turnstile> \\<psi>\\<close>\n    shows \\<open>A \\<turnstile> \\<psi>\\<close>", "lemma Cn_same: \\<open>(Cn(A) = Cn(B)) \\<longleftrightarrow> (\\<forall>C. A \\<subseteq> Cn(C) \\<longleftrightarrow> B \\<subseteq> Cn(C))\\<close>", "lemma Cn_union: \\<open>Cn(Cn(A) \\<union> Cn(B)) = Cn(A \\<union> B)\\<close>", "lemma Cn_Union: \\<open>Cn(\\<Union>{Cn(B)|B. P B}) = Cn(\\<Union>{B. P B})\\<close> (is \\<open>?A = ?B\\<close>)", "lemma Cn_inter: \\<open>K = Cn(A) \\<inter> Cn(B) \\<Longrightarrow> K = Cn(K)\\<close>", "lemma Cn_Inter: \\<open>K = \\<Inter>{Cn(B)|B. P B} \\<Longrightarrow> K = Cn(K)\\<close>", "lemma non_consistency:\n  assumes \\<open>A \\<turnstile> .\\<not> p\\<close>\n      and \\<open>A \\<turnstile> p\\<close>\n    shows \\<open>A \\<turnstile> q\\<close>", "lemma imp_PL: \\<open>A \\<turnstile> p .\\<longrightarrow>. q \\<longleftrightarrow> A \\<union> {p} \\<turnstile> q\\<close>", "lemma not_PL: \\<open>A \\<turnstile> .\\<not> p \\<longleftrightarrow> A \\<union> {p} \\<turnstile> \\<bottom>\\<close>", "lemma notnot_PL: \\<open>A \\<turnstile> .\\<not> (.\\<not> p) \\<longleftrightarrow> A \\<turnstile> p\\<close>", "lemma conj_PL: \\<open>A \\<turnstile> p .\\<and>. q \\<longleftrightarrow> (A \\<turnstile> p \\<and> A \\<turnstile> q)\\<close>", "lemma disj_PL: \\<open>A \\<turnstile> p .\\<or>. q \\<longleftrightarrow> A \\<union> {.\\<not> p} \\<turnstile> q\\<close>", "lemma equiv_PL:\\<open>A \\<turnstile> p .\\<longleftrightarrow>. q \\<longleftrightarrow> (A \\<union> {p} \\<turnstile> q \\<and> A \\<union> {q} \\<turnstile> p)\\<close>", "lemma nonemptyCn: \\<open>Cn(A) \\<noteq> {}\\<close>", "lemma Cn_true: \\<open>Cn({\\<top>}) = Cn({})\\<close>", "lemma Cn_false: \\<open>Cn({\\<bottom>}) = UNIV\\<close>", "lemma Cn_imp:     \\<open>A \\<turnstile> (p .\\<longrightarrow>. q) \\<longleftrightarrow> Cn({q}) \\<subseteq> Cn(A \\<union> {p})\\<close> \n  and Cn_imp_bis: \\<open>A \\<turnstile> (p .\\<longrightarrow>. q) \\<longleftrightarrow> Cn(A \\<union> {q}) \\<subseteq> Cn(A \\<union> {p})\\<close>", "lemma Cn_not: \\<open>A \\<turnstile> .\\<not> p \\<longleftrightarrow> Cn(A \\<union> {p}) = UNIV\\<close>", "lemma Cn_conj: \\<open>A \\<turnstile> (p .\\<and>. q) \\<longleftrightarrow> Cn({p}) \\<union> Cn({q}) \\<subseteq> Cn(A)\\<close>", "lemma Cn_conj_bis: \\<open>Cn({p .\\<and>. q}) = Cn({p, q})\\<close>", "lemma Cn_disj:     \\<open>A \\<turnstile> (p .\\<or>. q) \\<longleftrightarrow> Cn({q}) \\<subseteq> Cn(A \\<union> {.\\<not> p})\\<close>\n  and Cn_disj_bis: \\<open>A \\<turnstile> (p .\\<or>. q) \\<longleftrightarrow> Cn(A \\<union> {q}) \\<subseteq> Cn(A \\<union> {.\\<not> p})\\<close>", "lemma Cn_equiv: \\<open>A \\<turnstile> (p .\\<longleftrightarrow>. q) \\<longleftrightarrow> Cn(A \\<union> {p}) = Cn(A \\<union> {q})\\<close>", "lemma consistency: \\<open>Cn({p}) \\<inter> Cn({.\\<not> p}) = Cn({})\\<close>", "lemma Cn_notnot: \\<open>Cn({.\\<not> (.\\<not> \\<phi>)}) = Cn({\\<phi>})\\<close>", "lemma conj_com: \\<open>A \\<turnstile> p .\\<and>. q \\<longleftrightarrow> A \\<turnstile> q .\\<and>. p\\<close>", "lemma conj_com_Cn: \\<open>Cn({p .\\<and>. q}) = Cn({q .\\<and>. p})\\<close>", "lemma disj_com: \\<open>A \\<turnstile> p .\\<or>. q \\<longleftrightarrow> A \\<turnstile> q .\\<or>. p\\<close>", "lemma disj_com_Cn: \\<open>Cn({p .\\<or>. q}) = Cn({q .\\<or>. p})\\<close>", "lemma imp_contrapos: \\<open>A \\<turnstile> p .\\<longrightarrow>. q \\<longleftrightarrow> A \\<turnstile> .\\<not> q .\\<longrightarrow>. .\\<not> p\\<close>", "lemma equiv_negation: \\<open>A \\<turnstile> p .\\<longleftrightarrow>. q \\<longleftrightarrow> A \\<turnstile> .\\<not> p .\\<longleftrightarrow>. .\\<not> q\\<close>", "lemma imp_trans: \\<open>A \\<turnstile> p .\\<longrightarrow>.q \\<Longrightarrow> A \\<turnstile> q .\\<longrightarrow>.r \\<Longrightarrow> A \\<turnstile> p .\\<longrightarrow>.r\\<close>", "lemma imp_recovery0: \\<open>A \\<turnstile> p .\\<or>. (p .\\<longrightarrow>. q)\\<close>", "lemma imp_recovery1: \\<open>A \\<union> {p .\\<longrightarrow>. q} \\<turnstile> p \\<Longrightarrow> A \\<turnstile> p\\<close>", "lemma imp_recovery2: \\<open>A \\<turnstile> p .\\<longrightarrow>. q \\<Longrightarrow> A \\<turnstile> (q .\\<longrightarrow>. p) .\\<longrightarrow>. p \\<Longrightarrow> A \\<turnstile> q\\<close>", "lemma impI2: \\<open>A \\<turnstile> q \\<Longrightarrow> A \\<turnstile> p .\\<longrightarrow>. q\\<close>", "lemma conj_equiv: \\<open>A \\<turnstile> p \\<Longrightarrow> A \\<turnstile> ((p .\\<and>. q) .\\<longleftrightarrow>. q)\\<close>", "lemma conj_imp: \\<open>A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r \\<longleftrightarrow> A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)\\<close>", "lemma conj_not_impE_PL: \\<open>A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r \\<Longrightarrow> A \\<turnstile> (p .\\<and>. .\\<not> q) .\\<longrightarrow>. r \\<Longrightarrow> A \\<turnstile> p .\\<longrightarrow>. r\\<close>", "lemma disj_notE_PL: \\<open>A \\<turnstile> q \\<Longrightarrow> A \\<turnstile> p .\\<or>. .\\<not> q \\<Longrightarrow> A \\<turnstile> p\\<close>", "lemma disj_not_impE_PL: \\<open>A \\<turnstile> (p .\\<or>. q) .\\<longrightarrow>. r \\<Longrightarrow> A \\<turnstile> (p .\\<or>. .\\<not> q) .\\<longrightarrow>. r \\<Longrightarrow> A \\<turnstile> r\\<close>", "lemma imp_conj: \\<open>A \\<turnstile> p .\\<longrightarrow>. q \\<Longrightarrow> A \\<turnstile> r .\\<longrightarrow>. s \\<Longrightarrow> A \\<turnstile> (p .\\<and>. r) .\\<longrightarrow>. (q .\\<and>. s)\\<close>", "lemma conj_overlap: \\<open>A \\<turnstile> (p .\\<and>. q) \\<longleftrightarrow> A \\<turnstile> (p .\\<and>. ((.\\<not> p) .\\<or>. q))\\<close>", "lemma morgan: \\<open>A \\<turnstile> .\\<not> (p .\\<and>. q) \\<longleftrightarrow> A \\<turnstile> (.\\<not> p) .\\<or>. (.\\<not> q)\\<close>", "lemma conj_superexpansion1: \\<open>A \\<turnstile> .\\<not> (p .\\<and>. q) .\\<and>. .\\<not> p \\<longleftrightarrow> A \\<turnstile> .\\<not> p\\<close>", "lemma conj_superexpansion2: \\<open>A \\<turnstile> (p .\\<or>. q) .\\<and>. p \\<longleftrightarrow> A \\<turnstile> p\\<close>", "lemma chain_closure: \\<open>\\<not> \\<tturnstile> \\<phi> \\<Longrightarrow> subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C \\<Longrightarrow> \\<not> \\<Union>C \\<turnstile> \\<phi>\\<close>"], "translations": [["", "lemma idempotency_L: \\<open>Cn(Cn(A)) = Cn(A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn (Cn A) = Cn A", "by (simp add: inclusion_L transitivity_L subset_antisym)"], ["", "lemma assumption_L: \\<open>\\<phi> \\<in> A \\<Longrightarrow> A \\<turnstile> \\<phi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> A \\<Longrightarrow> A \\<turnstile> \\<phi>", "using inclusion_L infer_def"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> Cn ?A\n  ?A \\<turnstile> ?\\<phi> \\<equiv> ?\\<phi> \\<in> Cn ?A\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> A \\<Longrightarrow> A \\<turnstile> \\<phi>", "by blast"], ["", "lemma validD_L: \\<open>\\<tturnstile> \\<phi> \\<Longrightarrow> \\<phi> \\<in> Cn(A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tturnstile> \\<phi> \\<Longrightarrow> \\<phi> \\<in> Cn A", "using monotonicity_L valid_def infer_def"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> ?B \\<Longrightarrow> Cn ?A \\<subseteq> Cn ?B\n  \\<tturnstile> ?\\<phi> \\<equiv> {} \\<turnstile> ?\\<phi>\n  ?A \\<turnstile> ?\\<phi> \\<equiv> ?\\<phi> \\<in> Cn ?A\n\ngoal (1 subgoal):\n 1. \\<tturnstile> \\<phi> \\<Longrightarrow> \\<phi> \\<in> Cn A", "by fastforce"], ["", "lemma valid_expansion: \\<open>K = Cn(A) \\<Longrightarrow> \\<tturnstile> \\<phi> \\<Longrightarrow> K \\<oplus> \\<phi> = K\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>K = Cn A; \\<tturnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> K \\<oplus> \\<phi> = K", "by (simp add: idempotency_L insert_absorb validD_L valid_def expansion_def)"], ["", "lemma transitivity2_L:\n  assumes \\<open>\\<forall>\\<phi> \\<in> B. A \\<turnstile> \\<phi>\\<close>\n      and \\<open>B \\<turnstile> \\<psi>\\<close>\n    shows \\<open>A \\<turnstile> \\<psi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile> \\<psi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<turnstile> \\<psi>", "from assms(1)"], ["proof (chain)\npicking this:\n  \\<forall>\\<phi>\\<in>B. A \\<turnstile> \\<phi>", "have \\<open>B \\<subseteq> Cn(A)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>\\<phi>\\<in>B. A \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. B \\<subseteq> Cn A", "by (simp add: infer_def subsetI)"], ["proof (state)\nthis:\n  B \\<subseteq> Cn A\n\ngoal (1 subgoal):\n 1. A \\<turnstile> \\<psi>", "hence \\<open>Cn(B) \\<subseteq> Cn(A)\\<close>"], ["proof (prove)\nusing this:\n  B \\<subseteq> Cn A\n\ngoal (1 subgoal):\n 1. Cn B \\<subseteq> Cn A", "using idempotency_L monotonicity_L"], ["proof (prove)\nusing this:\n  B \\<subseteq> Cn A\n  Cn (Cn ?A) = Cn ?A\n  ?A \\<subseteq> ?B \\<Longrightarrow> Cn ?A \\<subseteq> Cn ?B\n\ngoal (1 subgoal):\n 1. Cn B \\<subseteq> Cn A", "by blast"], ["proof (state)\nthis:\n  Cn B \\<subseteq> Cn A\n\ngoal (1 subgoal):\n 1. A \\<turnstile> \\<psi>", "moreover"], ["proof (state)\nthis:\n  Cn B \\<subseteq> Cn A\n\ngoal (1 subgoal):\n 1. A \\<turnstile> \\<psi>", "from assms(2)"], ["proof (chain)\npicking this:\n  B \\<turnstile> \\<psi>", "have \\<open>\\<psi> \\<in> Cn(B)\\<close>"], ["proof (prove)\nusing this:\n  B \\<turnstile> \\<psi>\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> Cn B", "by (simp add: infer_def)"], ["proof (state)\nthis:\n  \\<psi> \\<in> Cn B\n\ngoal (1 subgoal):\n 1. A \\<turnstile> \\<psi>", "ultimately"], ["proof (chain)\npicking this:\n  Cn B \\<subseteq> Cn A\n  \\<psi> \\<in> Cn B", "show ?thesis"], ["proof (prove)\nusing this:\n  Cn B \\<subseteq> Cn A\n  \\<psi> \\<in> Cn B\n\ngoal (1 subgoal):\n 1. A \\<turnstile> \\<psi>", "using infer_def"], ["proof (prove)\nusing this:\n  Cn B \\<subseteq> Cn A\n  \\<psi> \\<in> Cn B\n  ?A \\<turnstile> ?\\<phi> \\<equiv> ?\\<phi> \\<in> Cn ?A\n\ngoal (1 subgoal):\n 1. A \\<turnstile> \\<psi>", "by blast"], ["proof (state)\nthis:\n  A \\<turnstile> \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Cn_same: \\<open>(Cn(A) = Cn(B)) \\<longleftrightarrow> (\\<forall>C. A \\<subseteq> Cn(C) \\<longleftrightarrow> B \\<subseteq> Cn(C))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Cn A = Cn B) =\n    (\\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Cn A = Cn B \\<Longrightarrow>\n    \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n 2. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. Cn A = Cn B \\<Longrightarrow>\n    \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n 2. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "assume h:\\<open>Cn(A) = Cn(B)\\<close>"], ["proof (state)\nthis:\n  Cn A = Cn B\n\ngoal (2 subgoals):\n 1. Cn A = Cn B \\<Longrightarrow>\n    \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n 2. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "from h"], ["proof (chain)\npicking this:\n  Cn A = Cn B", "have \\<open>\\<forall>\\<phi> \\<in> B. A \\<turnstile> \\<phi>\\<close>"], ["proof (prove)\nusing this:\n  Cn A = Cn B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<phi>\\<in>B. A \\<turnstile> \\<phi>", "by (simp add: Tarskian_logic.assumption_L Tarskian_logic_axioms infer_def)"], ["proof (state)\nthis:\n  \\<forall>\\<phi>\\<in>B. A \\<turnstile> \\<phi>\n\ngoal (2 subgoals):\n 1. Cn A = Cn B \\<Longrightarrow>\n    \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n 2. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<phi>\\<in>B. A \\<turnstile> \\<phi>\n\ngoal (2 subgoals):\n 1. Cn A = Cn B \\<Longrightarrow>\n    \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n 2. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "from h[symmetric]"], ["proof (chain)\npicking this:\n  Cn B = Cn A", "have \\<open>\\<forall>\\<phi> \\<in> A. B \\<turnstile> \\<phi>\\<close>"], ["proof (prove)\nusing this:\n  Cn B = Cn A\n\ngoal (1 subgoal):\n 1. \\<forall>\\<phi>\\<in>A. B \\<turnstile> \\<phi>", "by (simp add: Tarskian_logic.assumption_L Tarskian_logic_axioms infer_def)"], ["proof (state)\nthis:\n  \\<forall>\\<phi>\\<in>A. B \\<turnstile> \\<phi>\n\ngoal (2 subgoals):\n 1. Cn A = Cn B \\<Longrightarrow>\n    \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n 2. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<phi>\\<in>B. A \\<turnstile> \\<phi>\n  \\<forall>\\<phi>\\<in>A. B \\<turnstile> \\<phi>", "have \\<open>\\<forall>C. A \\<subseteq> Cn(C) \\<longleftrightarrow> B \\<subseteq> Cn(C)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>\\<phi>\\<in>B. A \\<turnstile> \\<phi>\n  \\<forall>\\<phi>\\<in>A. B \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)", "using h idempotency_L inclusion_L monotonicity_L"], ["proof (prove)\nusing this:\n  \\<forall>\\<phi>\\<in>B. A \\<turnstile> \\<phi>\n  \\<forall>\\<phi>\\<in>A. B \\<turnstile> \\<phi>\n  Cn A = Cn B\n  Cn (Cn ?A) = Cn ?A\n  ?A \\<subseteq> Cn ?A\n  ?A \\<subseteq> ?B \\<Longrightarrow> Cn ?A \\<subseteq> Cn ?B\n\ngoal (1 subgoal):\n 1. \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)", "by blast"], ["proof (state)\nthis:\n  \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n\ngoal (2 subgoals):\n 1. Cn A = Cn B \\<Longrightarrow>\n    \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n 2. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "}"], ["proof (state)\nthis:\n  Cn A = Cn B \\<Longrightarrow>\n  \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n\ngoal (2 subgoals):\n 1. Cn A = Cn B \\<Longrightarrow>\n    \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n 2. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "thus \\<open>Cn(A) = Cn(B) \\<Longrightarrow> \\<forall>C. (A \\<subseteq> Cn(C)) = (B \\<subseteq> Cn(C))\\<close>"], ["proof (prove)\nusing this:\n  Cn A = Cn B \\<Longrightarrow>\n  \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n\ngoal (1 subgoal):\n 1. Cn A = Cn B \\<Longrightarrow>\n    \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)", "."], ["proof (state)\nthis:\n  Cn A = Cn B \\<Longrightarrow>\n  \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "assume h:\\<open>\\<forall>C. (A \\<subseteq> Cn(C)) = (B \\<subseteq> Cn(C))\\<close>"], ["proof (state)\nthis:\n  \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "from h"], ["proof (chain)\npicking this:\n  \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)", "have \\<open>(A \\<subseteq> Cn(A)) = (B \\<subseteq> Cn(A))\\<close> and \\<open>(A \\<subseteq> Cn(B)) = (B \\<subseteq> Cn(B))\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C)\n\ngoal (1 subgoal):\n 1. (A \\<subseteq> Cn A) = (B \\<subseteq> Cn A) &&&\n    (A \\<subseteq> Cn B) = (B \\<subseteq> Cn B)", "by simp+"], ["proof (state)\nthis:\n  (A \\<subseteq> Cn A) = (B \\<subseteq> Cn A)\n  (A \\<subseteq> Cn B) = (B \\<subseteq> Cn B)\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "hence \\<open>B \\<subseteq> Cn(A)\\<close> and \\<open>A \\<subseteq> Cn(B)\\<close>"], ["proof (prove)\nusing this:\n  (A \\<subseteq> Cn A) = (B \\<subseteq> Cn A)\n  (A \\<subseteq> Cn B) = (B \\<subseteq> Cn B)\n\ngoal (1 subgoal):\n 1. B \\<subseteq> Cn A &&& A \\<subseteq> Cn B", "by (simp add: inclusion_L)+"], ["proof (state)\nthis:\n  B \\<subseteq> Cn A\n  A \\<subseteq> Cn B\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "hence \\<open>Cn(A) = Cn(B)\\<close>"], ["proof (prove)\nusing this:\n  B \\<subseteq> Cn A\n  A \\<subseteq> Cn B\n\ngoal (1 subgoal):\n 1. Cn A = Cn B", "using idempotency_L monotonicity_L"], ["proof (prove)\nusing this:\n  B \\<subseteq> Cn A\n  A \\<subseteq> Cn B\n  Cn (Cn ?A) = Cn ?A\n  ?A \\<subseteq> ?B \\<Longrightarrow> Cn ?A \\<subseteq> Cn ?B\n\ngoal (1 subgoal):\n 1. Cn A = Cn B", "by blast"], ["proof (state)\nthis:\n  Cn A = Cn B\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "}"], ["proof (state)\nthis:\n  \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n  Cn A = Cn B\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "thus \\<open>(\\<forall>C. (A \\<subseteq> Cn(C)) = (B \\<subseteq> Cn(C))) \\<Longrightarrow> Cn(A) = Cn(B)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n  Cn A = Cn B\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n    Cn A = Cn B", "."], ["proof (state)\nthis:\n  \\<forall>C. (A \\<subseteq> Cn C) = (B \\<subseteq> Cn C) \\<Longrightarrow>\n  Cn A = Cn B\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>\nThe closure of the union of two consequence closures.\n\\<close>"], ["", "lemma Cn_union: \\<open>Cn(Cn(A) \\<union> Cn(B)) = Cn(A \\<union> B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn (Cn A \\<union> Cn B) = Cn (A \\<union> B)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Cn (Cn A \\<union> Cn B) \\<subseteq> Cn (A \\<union> B)\n 2. Cn (A \\<union> B) \\<subseteq> Cn (Cn A \\<union> Cn B)", "have \\<open>Cn(Cn(A) \\<union> Cn(B)) \\<subseteq> Cn(Cn (A \\<union> B))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn (Cn A \\<union> Cn B) \\<subseteq> Cn (Cn (A \\<union> B))", "by (simp add: monotonicity_L)"], ["proof (state)\nthis:\n  Cn (Cn A \\<union> Cn B) \\<subseteq> Cn (Cn (A \\<union> B))\n\ngoal (2 subgoals):\n 1. Cn (Cn A \\<union> Cn B) \\<subseteq> Cn (A \\<union> B)\n 2. Cn (A \\<union> B) \\<subseteq> Cn (Cn A \\<union> Cn B)", "thus \\<open>Cn(Cn(A) \\<union> Cn(B)) \\<subseteq> Cn(A \\<union> B)\\<close>"], ["proof (prove)\nusing this:\n  Cn (Cn A \\<union> Cn B) \\<subseteq> Cn (Cn (A \\<union> B))\n\ngoal (1 subgoal):\n 1. Cn (Cn A \\<union> Cn B) \\<subseteq> Cn (A \\<union> B)", "by (simp add: idempotency_L)"], ["proof (state)\nthis:\n  Cn (Cn A \\<union> Cn B) \\<subseteq> Cn (A \\<union> B)\n\ngoal (1 subgoal):\n 1. Cn (A \\<union> B) \\<subseteq> Cn (Cn A \\<union> Cn B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Cn (A \\<union> B) \\<subseteq> Cn (Cn A \\<union> Cn B)", "have \\<open>(A \\<union> B) \\<subseteq> (Cn(A) \\<union> Cn(B))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> B \\<subseteq> Cn A \\<union> Cn B", "using inclusion_L"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> Cn ?A\n\ngoal (1 subgoal):\n 1. A \\<union> B \\<subseteq> Cn A \\<union> Cn B", "by blast"], ["proof (state)\nthis:\n  A \\<union> B \\<subseteq> Cn A \\<union> Cn B\n\ngoal (1 subgoal):\n 1. Cn (A \\<union> B) \\<subseteq> Cn (Cn A \\<union> Cn B)", "thus \\<open>Cn(A \\<union> B) \\<subseteq> Cn(Cn(A) \\<union> Cn(B))\\<close>"], ["proof (prove)\nusing this:\n  A \\<union> B \\<subseteq> Cn A \\<union> Cn B\n\ngoal (1 subgoal):\n 1. Cn (A \\<union> B) \\<subseteq> Cn (Cn A \\<union> Cn B)", "by (simp add: monotonicity_L)"], ["proof (state)\nthis:\n  Cn (A \\<union> B) \\<subseteq> Cn (Cn A \\<union> Cn B)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>\nThe closure of an infinite union of consequence closures.\n\\<close>"], ["", "lemma Cn_Union: \\<open>Cn(\\<Union>{Cn(B)|B. P B}) = Cn(\\<Union>{B. P B})\\<close> (is \\<open>?A = ?B\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn (\\<Union> {Cn B |B. P B}) = Cn (\\<Union> {B. P B})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Cn (\\<Union> {Cn B |B. P B}) \\<subseteq> Cn (\\<Union> {B. P B})\n 2. Cn (\\<Union> {B. P B}) \\<subseteq> Cn (\\<Union> {Cn B |B. P B})", "have \\<open>?A \\<subseteq> Cn ?B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn (\\<Union> {Cn B |B. P B}) \\<subseteq> Cn (Cn (\\<Union> {B. P B}))", "apply(rule monotonicity_L, rule Union_least, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x B.\n       \\<lbrakk>x \\<in> Cn B; P B\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Cn (\\<Union> (Collect P))", "by (metis Sup_upper in_mono mem_Collect_eq monotonicity_L)"], ["proof (state)\nthis:\n  Cn (\\<Union> {Cn B |B. P B}) \\<subseteq> Cn (Cn (\\<Union> {B. P B}))\n\ngoal (2 subgoals):\n 1. Cn (\\<Union> {Cn B |B. P B}) \\<subseteq> Cn (\\<Union> {B. P B})\n 2. Cn (\\<Union> {B. P B}) \\<subseteq> Cn (\\<Union> {Cn B |B. P B})", "then"], ["proof (chain)\npicking this:\n  Cn (\\<Union> {Cn B |B. P B}) \\<subseteq> Cn (Cn (\\<Union> {B. P B}))", "show \\<open>?A \\<subseteq> ?B\\<close>"], ["proof (prove)\nusing this:\n  Cn (\\<Union> {Cn B |B. P B}) \\<subseteq> Cn (Cn (\\<Union> {B. P B}))\n\ngoal (1 subgoal):\n 1. Cn (\\<Union> {Cn B |B. P B}) \\<subseteq> Cn (\\<Union> {B. P B})", "by (simp add: idempotency_L)"], ["proof (state)\nthis:\n  Cn (\\<Union> {Cn B |B. P B}) \\<subseteq> Cn (\\<Union> {B. P B})\n\ngoal (1 subgoal):\n 1. Cn (\\<Union> {B. P B}) \\<subseteq> Cn (\\<Union> {Cn B |B. P B})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Cn (\\<Union> {B. P B}) \\<subseteq> Cn (\\<Union> {Cn B |B. P B})", "show \\<open>?B \\<subseteq> ?A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn (\\<Union> {B. P B}) \\<subseteq> Cn (\\<Union> {Cn B |B. P B})", "by (metis (mono_tags, lifting) Union_subsetI inclusion_L mem_Collect_eq monotonicity_L)"], ["proof (state)\nthis:\n  Cn (\\<Union> {B. P B}) \\<subseteq> Cn (\\<Union> {Cn B |B. P B})\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>\nThe intersection of two closures is closed.\n\\<close>"], ["", "lemma Cn_inter: \\<open>K = Cn(A) \\<inter> Cn(B) \\<Longrightarrow> K = Cn(K)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K", "fix K"], ["proof (state)\ngoal (1 subgoal):\n 1. K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K", "assume h:\\<open>K = Cn(A) \\<inter> Cn(B)\\<close>"], ["proof (state)\nthis:\n  K = Cn A \\<inter> Cn B\n\ngoal (1 subgoal):\n 1. K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K", "from h"], ["proof (chain)\npicking this:\n  K = Cn A \\<inter> Cn B", "have \\<open>K \\<subseteq> Cn(A)\\<close> and \\<open>K \\<subseteq> Cn(B)\\<close>"], ["proof (prove)\nusing this:\n  K = Cn A \\<inter> Cn B\n\ngoal (1 subgoal):\n 1. K \\<subseteq> Cn A &&& K \\<subseteq> Cn B", "by simp+"], ["proof (state)\nthis:\n  K \\<subseteq> Cn A\n  K \\<subseteq> Cn B\n\ngoal (1 subgoal):\n 1. K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K", "hence \\<open>Cn(K) \\<subseteq> Cn(A)\\<close> and \\<open>Cn(K) \\<subseteq> Cn(B)\\<close>"], ["proof (prove)\nusing this:\n  K \\<subseteq> Cn A\n  K \\<subseteq> Cn B\n\ngoal (1 subgoal):\n 1. Cn K \\<subseteq> Cn A &&& Cn K \\<subseteq> Cn B", "using idempotency_L monotonicity_L"], ["proof (prove)\nusing this:\n  K \\<subseteq> Cn A\n  K \\<subseteq> Cn B\n  Cn (Cn ?A) = Cn ?A\n  ?A \\<subseteq> ?B \\<Longrightarrow> Cn ?A \\<subseteq> Cn ?B\n\ngoal (1 subgoal):\n 1. Cn K \\<subseteq> Cn A &&& Cn K \\<subseteq> Cn B", "by blast+"], ["proof (state)\nthis:\n  Cn K \\<subseteq> Cn A\n  Cn K \\<subseteq> Cn B\n\ngoal (1 subgoal):\n 1. K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K", "hence \\<open>Cn(K) \\<subseteq> Cn(A) \\<inter> Cn(B)\\<close>"], ["proof (prove)\nusing this:\n  Cn K \\<subseteq> Cn A\n  Cn K \\<subseteq> Cn B\n\ngoal (1 subgoal):\n 1. Cn K \\<subseteq> Cn A \\<inter> Cn B", "by simp"], ["proof (state)\nthis:\n  Cn K \\<subseteq> Cn A \\<inter> Cn B\n\ngoal (1 subgoal):\n 1. K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K", "with h"], ["proof (chain)\npicking this:\n  K = Cn A \\<inter> Cn B\n  Cn K \\<subseteq> Cn A \\<inter> Cn B", "have \\<open>K = Cn(K)\\<close>"], ["proof (prove)\nusing this:\n  K = Cn A \\<inter> Cn B\n  Cn K \\<subseteq> Cn A \\<inter> Cn B\n\ngoal (1 subgoal):\n 1. K = Cn K", "by (simp add: inclusion_L subset_antisym)"], ["proof (state)\nthis:\n  K = Cn K\n\ngoal (1 subgoal):\n 1. K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K", "}"], ["proof (state)\nthis:\n  ?Ka2 = Cn A \\<inter> Cn B \\<Longrightarrow> ?Ka2 = Cn ?Ka2\n\ngoal (1 subgoal):\n 1. K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K", "thus \\<open>K = Cn(A) \\<inter> Cn(B) \\<Longrightarrow> K = Cn(K)\\<close>"], ["proof (prove)\nusing this:\n  ?Ka2 = Cn A \\<inter> Cn B \\<Longrightarrow> ?Ka2 = Cn ?Ka2\n\ngoal (1 subgoal):\n 1. K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K", "."], ["proof (state)\nthis:\n  K = Cn A \\<inter> Cn B \\<Longrightarrow> K = Cn K\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>\nAn infinite intersection of closures is closed.\n\\<close>"], ["", "lemma Cn_Inter: \\<open>K = \\<Inter>{Cn(B)|B. P B} \\<Longrightarrow> K = Cn(K)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K", "fix K"], ["proof (state)\ngoal (1 subgoal):\n 1. K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K", "assume h:\\<open>K = \\<Inter>{Cn(B)|B. P B}\\<close>"], ["proof (state)\nthis:\n  K = \\<Inter> {Cn B |B. P B}\n\ngoal (1 subgoal):\n 1. K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K", "from h"], ["proof (chain)\npicking this:\n  K = \\<Inter> {Cn B |B. P B}", "have \\<open>\\<forall>B. P B \\<longrightarrow> K \\<subseteq> Cn(B)\\<close>"], ["proof (prove)\nusing this:\n  K = \\<Inter> {Cn B |B. P B}\n\ngoal (1 subgoal):\n 1. \\<forall>B. P B \\<longrightarrow> K \\<subseteq> Cn B", "by blast"], ["proof (state)\nthis:\n  \\<forall>B. P B \\<longrightarrow> K \\<subseteq> Cn B\n\ngoal (1 subgoal):\n 1. K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K", "hence \\<open>\\<forall>B. P B \\<longrightarrow> Cn(K) \\<subseteq> Cn(B)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>B. P B \\<longrightarrow> K \\<subseteq> Cn B\n\ngoal (1 subgoal):\n 1. \\<forall>B. P B \\<longrightarrow> Cn K \\<subseteq> Cn B", "using idempotency_L monotonicity_L"], ["proof (prove)\nusing this:\n  \\<forall>B. P B \\<longrightarrow> K \\<subseteq> Cn B\n  Cn (Cn ?A) = Cn ?A\n  ?A \\<subseteq> ?B \\<Longrightarrow> Cn ?A \\<subseteq> Cn ?B\n\ngoal (1 subgoal):\n 1. \\<forall>B. P B \\<longrightarrow> Cn K \\<subseteq> Cn B", "by blast"], ["proof (state)\nthis:\n  \\<forall>B. P B \\<longrightarrow> Cn K \\<subseteq> Cn B\n\ngoal (1 subgoal):\n 1. K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K", "hence \\<open>Cn(K) \\<subseteq> \\<Inter>{Cn(B)|B. P B}\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>B. P B \\<longrightarrow> Cn K \\<subseteq> Cn B\n\ngoal (1 subgoal):\n 1. Cn K \\<subseteq> \\<Inter> {Cn B |B. P B}", "by blast"], ["proof (state)\nthis:\n  Cn K \\<subseteq> \\<Inter> {Cn B |B. P B}\n\ngoal (1 subgoal):\n 1. K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K", "with h"], ["proof (chain)\npicking this:\n  K = \\<Inter> {Cn B |B. P B}\n  Cn K \\<subseteq> \\<Inter> {Cn B |B. P B}", "have \\<open>K = Cn(K)\\<close>"], ["proof (prove)\nusing this:\n  K = \\<Inter> {Cn B |B. P B}\n  Cn K \\<subseteq> \\<Inter> {Cn B |B. P B}\n\ngoal (1 subgoal):\n 1. K = Cn K", "by (simp add: inclusion_L subset_antisym)"], ["proof (state)\nthis:\n  K = Cn K\n\ngoal (1 subgoal):\n 1. K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K", "}"], ["proof (state)\nthis:\n  ?Ka2 = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> ?Ka2 = Cn ?Ka2\n\ngoal (1 subgoal):\n 1. K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K", "thus \\<open>K = \\<Inter>{Cn(B)|B. P B} \\<Longrightarrow> K = Cn(K)\\<close>"], ["proof (prove)\nusing this:\n  ?Ka2 = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> ?Ka2 = Cn ?Ka2\n\ngoal (1 subgoal):\n 1. K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K", "."], ["proof (state)\nthis:\n  K = \\<Inter> {Cn B |B. P B} \\<Longrightarrow> K = Cn K\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Supraclassical Logic\\<close>"], ["", "text \\<open>\nA Tarskian logic has only one abstract operator catching the notion of consequence. A basic case of such a logic is a \\<^bold>\\<open>Supraclassical\\<close> logic that \nis a logic with all classical propositional operators (e.g. conjunction (\\<open>\\<and>\\<close>), implication(\\<open>\\<longrightarrow>\\<close>), negation (\\<open>\\<not>\\<close>) \\dots ) together with their classical semantics.\n\nWe define a new locale. In order to distinguish the propositional operators of our supraclassical logic from those of Isabelle/HOL, we use dots (e.g. \\<open>.\\<and>.\\<close> stands for conjunction). \nWe axiomatize the introduction and elimination rules of each operator as it is commonly established in the classical literature. As explained before, \nwe give priority to a complete control of our logic instead of an efficient shallow embedding in Isabelle/HOL.\n\\<close>"], ["", "locale Supraclassical_logic = Tarskian_logic +\n\nfixes true_PL::   \\<open>'a\\<close>             (\\<open>\\<top>\\<close>)\n  and false_PL::  \\<open>'a\\<close>             (\\<open>\\<bottom>\\<close>)\n  and imp_PL::    \\<open>'a \\<Rightarrow> 'a \\<Rightarrow> 'a\\<close> (infix \\<open>.\\<longrightarrow>.\\<close> 55)\n  and not_PL::    \\<open>'a \\<Rightarrow> 'a\\<close>       (\\<open>.\\<not>\\<close>)  \n  and conj_PL::   \\<open>'a \\<Rightarrow> 'a \\<Rightarrow> 'a\\<close> (infix \\<open>.\\<and>.\\<close> 55)\n  and disj_PL::   \\<open>'a \\<Rightarrow> 'a \\<Rightarrow> 'a\\<close> (infix \\<open>.\\<or>.\\<close> 55)\n  and equiv_PL::  \\<open>'a \\<Rightarrow> 'a \\<Rightarrow> 'a\\<close> (infix \\<open>.\\<longleftrightarrow>.\\<close> 55)\n\nassumes true_PL:     \\<open>A \\<turnstile> \\<top>\\<close>\n\n    and false_PL:    \\<open>{\\<bottom>} \\<turnstile> p\\<close>\n\n    and impI_PL:     \\<open>A \\<union> {p} \\<turnstile> q \\<Longrightarrow> A \\<turnstile> (p .\\<longrightarrow>. q)\\<close>\n    and mp_PL:       \\<open>A \\<turnstile> p .\\<longrightarrow>. q \\<Longrightarrow> A \\<turnstile> p \\<Longrightarrow> A \\<turnstile> q\\<close>\n\n    and notI_PL:     \\<open>A \\<turnstile> p .\\<longrightarrow>. \\<bottom> \\<Longrightarrow> A \\<turnstile> .\\<not> p\\<close>\n    and notE_PL:     \\<open>A \\<turnstile> .\\<not> p \\<Longrightarrow> A \\<turnstile> (p .\\<longrightarrow>. \\<bottom>)\\<close>\n\n    and conjI_PL:    \\<open>A \\<turnstile> p \\<Longrightarrow> A \\<turnstile> q \\<Longrightarrow> A \\<turnstile> (p .\\<and>. q)\\<close>\n    and conjE1_PL:   \\<open>A \\<turnstile> p .\\<and>. q \\<Longrightarrow> A \\<turnstile> p\\<close>\n    and conjE2_PL:   \\<open>A \\<turnstile> p .\\<and>. q \\<Longrightarrow> A \\<turnstile> q\\<close>\n\n    and disjI1_PL:   \\<open>A \\<turnstile> p \\<Longrightarrow> A \\<turnstile> (p .\\<or>. q)\\<close>\n    and disjI2_PL:   \\<open>A \\<turnstile> q \\<Longrightarrow> A \\<turnstile> (p .\\<or>. q)\\<close>\n    and disjE_PL:    \\<open>A \\<turnstile> p .\\<or>. q \\<Longrightarrow> A \\<turnstile> p .\\<longrightarrow>. r \\<Longrightarrow> A \\<turnstile> q.\\<longrightarrow>. r \\<Longrightarrow> A \\<turnstile> r\\<close>\n\n    and equivI_PL:   \\<open>A \\<turnstile> p .\\<longrightarrow>. q \\<Longrightarrow> A \\<turnstile> q .\\<longrightarrow>. p \\<Longrightarrow> A \\<turnstile> (p .\\<longleftrightarrow>. q)\\<close>\n    and equivE1_PL:  \\<open>A \\<turnstile> p .\\<longleftrightarrow>. q \\<Longrightarrow> A \\<turnstile> p .\\<longrightarrow>. q\\<close>\n    and equivE2_PL:  \\<open>A \\<turnstile> p .\\<longleftrightarrow>. q \\<Longrightarrow> A \\<turnstile> q .\\<longrightarrow>. p\\<close>\n\n\\<comment> \\<open>non intuitionistic rules\\<close>\n    and absurd_PL:   \\<open>A \\<turnstile> .\\<not> (.\\<not> p) \\<Longrightarrow> A \\<turnstile> p\\<close>\n    and ex_mid_PL:   \\<open>A \\<turnstile> p .\\<or>. (.\\<not> p)\\<close>\n\nbegin"], ["", "text \\<open>In the following, we will first retrieve the classical logic operators semantics coming from previous introduction and elimination rules\\<close>"], ["", "lemma non_consistency:\n  assumes \\<open>A \\<turnstile> .\\<not> p\\<close>\n      and \\<open>A \\<turnstile> p\\<close>\n    shows \\<open>A \\<turnstile> q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile> q", "by (metis assms(1) assms(2) false_PL mp_PL notE_PL singleton_iff transitivity2_L)\n\n\\<comment> \\<open>this direct result brings directly many remarkable properties of implication (i.e. transitivity)\\<close>"], ["", "lemma imp_PL: \\<open>A \\<turnstile> p .\\<longrightarrow>. q \\<longleftrightarrow> A \\<union> {p} \\<turnstile> q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<longrightarrow>. q) =\n    (A \\<union> {p} \\<turnstile> q)", "apply (intro iffI impI_PL)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<turnstile> p .\\<longrightarrow>. q \\<Longrightarrow>\n    A \\<union> {p} \\<turnstile> q\n 2. A \\<union> {p} \\<turnstile> q \\<Longrightarrow>\n    A \\<union> {p} \\<turnstile> q", "apply(rule mp_PL[where p=p], meson UnI1 assumption_L transitivity2_L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<turnstile> p .\\<longrightarrow>. q \\<Longrightarrow>\n    A \\<union> {p} \\<turnstile> p\n 2. A \\<union> {p} \\<turnstile> q \\<Longrightarrow>\n    A \\<union> {p} \\<turnstile> q", "using assumption_L"], ["proof (prove)\nusing this:\n  ?\\<phi> \\<in> ?A \\<Longrightarrow> ?A \\<turnstile> ?\\<phi>\n\ngoal (2 subgoals):\n 1. A \\<turnstile> p .\\<longrightarrow>. q \\<Longrightarrow>\n    A \\<union> {p} \\<turnstile> p\n 2. A \\<union> {p} \\<turnstile> q \\<Longrightarrow>\n    A \\<union> {p} \\<turnstile> q", "by auto"], ["", "lemma not_PL: \\<open>A \\<turnstile> .\\<not> p \\<longleftrightarrow> A \\<union> {p} \\<turnstile> \\<bottom>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> .\\<not> p) = (A \\<union> {p} \\<turnstile> \\<bottom>)", "using notE_PL notI_PL imp_PL"], ["proof (prove)\nusing this:\n  ?A \\<turnstile> .\\<not> ?p \\<Longrightarrow>\n  ?A \\<turnstile> ?p .\\<longrightarrow>. \\<bottom>\n  ?A \\<turnstile> ?p .\\<longrightarrow>. \\<bottom> \\<Longrightarrow>\n  ?A \\<turnstile> .\\<not> ?p\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (?A \\<union> {?p} \\<turnstile> ?q)\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> .\\<not> p) = (A \\<union> {p} \\<turnstile> \\<bottom>)", "by blast\n\n\\<comment> \\<open>Classical logic result\\<close>"], ["", "lemma notnot_PL: \\<open>A \\<turnstile> .\\<not> (.\\<not> p) \\<longleftrightarrow> A \\<turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> .\\<not> (.\\<not> p)) = (A \\<turnstile> p)", "apply(rule iffI, simp add:absurd_PL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile> p \\<Longrightarrow> A \\<turnstile> .\\<not> (.\\<not> p)", "by (meson mp_PL notE_PL Un_upper1 Un_upper2 assumption_L infer_def monotonicity_L not_PL singletonI subsetD)"], ["", "lemma conj_PL: \\<open>A \\<turnstile> p .\\<and>. q \\<longleftrightarrow> (A \\<turnstile> p \\<and> A \\<turnstile> q)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<and>. q) =\n    (A \\<turnstile> p \\<and> A \\<turnstile> q)", "using conjE1_PL conjE2_PL conjI_PL"], ["proof (prove)\nusing this:\n  ?A \\<turnstile> ?p .\\<and>. ?q \\<Longrightarrow> ?A \\<turnstile> ?p\n  ?A \\<turnstile> ?p .\\<and>. ?q \\<Longrightarrow> ?A \\<turnstile> ?q\n  \\<lbrakk>?A \\<turnstile> ?p; ?A \\<turnstile> ?q\\<rbrakk>\n  \\<Longrightarrow> ?A \\<turnstile> ?p .\\<and>. ?q\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<and>. q) =\n    (A \\<turnstile> p \\<and> A \\<turnstile> q)", "by blast"], ["", "lemma disj_PL: \\<open>A \\<turnstile> p .\\<or>. q \\<longleftrightarrow> A \\<union> {.\\<not> p} \\<turnstile> q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<or>. q) = (A \\<union> {.\\<not> p} \\<turnstile> q)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<turnstile> p .\\<or>. q \\<Longrightarrow>\n    A \\<union> {.\\<not> p} \\<turnstile> q\n 2. A \\<union> {.\\<not> p} \\<turnstile> q \\<Longrightarrow>\n    A \\<turnstile> p .\\<or>. q", "assume a:\\<open>A \\<turnstile> p .\\<or>. q\\<close>"], ["proof (state)\nthis:\n  A \\<turnstile> p .\\<or>. q\n\ngoal (2 subgoals):\n 1. A \\<turnstile> p .\\<or>. q \\<Longrightarrow>\n    A \\<union> {.\\<not> p} \\<turnstile> q\n 2. A \\<union> {.\\<not> p} \\<turnstile> q \\<Longrightarrow>\n    A \\<turnstile> p .\\<or>. q", "have b:\\<open>A \\<turnstile> p .\\<longrightarrow>. (.\\<not> p .\\<longrightarrow>. q)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile> p .\\<longrightarrow>. (.\\<not> p .\\<longrightarrow>. q)", "by (intro impI_PL) (meson Un_iff assumption_L insertI1 non_consistency)"], ["proof (state)\nthis:\n  A \\<turnstile> p .\\<longrightarrow>. (.\\<not> p .\\<longrightarrow>. q)\n\ngoal (2 subgoals):\n 1. A \\<turnstile> p .\\<or>. q \\<Longrightarrow>\n    A \\<union> {.\\<not> p} \\<turnstile> q\n 2. A \\<union> {.\\<not> p} \\<turnstile> q \\<Longrightarrow>\n    A \\<turnstile> p .\\<or>. q", "have c:\\<open>A \\<turnstile> q .\\<longrightarrow>. (.\\<not> p .\\<longrightarrow>. q)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile> q .\\<longrightarrow>. (.\\<not> p .\\<longrightarrow>. q)", "by (simp add: assumption_L impI_PL)"], ["proof (state)\nthis:\n  A \\<turnstile> q .\\<longrightarrow>. (.\\<not> p .\\<longrightarrow>. q)\n\ngoal (2 subgoals):\n 1. A \\<turnstile> p .\\<or>. q \\<Longrightarrow>\n    A \\<union> {.\\<not> p} \\<turnstile> q\n 2. A \\<union> {.\\<not> p} \\<turnstile> q \\<Longrightarrow>\n    A \\<turnstile> p .\\<or>. q", "from a b c"], ["proof (chain)\npicking this:\n  A \\<turnstile> p .\\<or>. q\n  A \\<turnstile> p .\\<longrightarrow>. (.\\<not> p .\\<longrightarrow>. q)\n  A \\<turnstile> q .\\<longrightarrow>. (.\\<not> p .\\<longrightarrow>. q)", "have \\<open>A \\<turnstile> .\\<not> p .\\<longrightarrow>. q\\<close>"], ["proof (prove)\nusing this:\n  A \\<turnstile> p .\\<or>. q\n  A \\<turnstile> p .\\<longrightarrow>. (.\\<not> p .\\<longrightarrow>. q)\n  A \\<turnstile> q .\\<longrightarrow>. (.\\<not> p .\\<longrightarrow>. q)\n\ngoal (1 subgoal):\n 1. A \\<turnstile> .\\<not> p .\\<longrightarrow>. q", "by (erule_tac disjE_PL) simp_all"], ["proof (state)\nthis:\n  A \\<turnstile> .\\<not> p .\\<longrightarrow>. q\n\ngoal (2 subgoals):\n 1. A \\<turnstile> p .\\<or>. q \\<Longrightarrow>\n    A \\<union> {.\\<not> p} \\<turnstile> q\n 2. A \\<union> {.\\<not> p} \\<turnstile> q \\<Longrightarrow>\n    A \\<turnstile> p .\\<or>. q", "then"], ["proof (chain)\npicking this:\n  A \\<turnstile> .\\<not> p .\\<longrightarrow>. q", "show \\<open>A \\<union> {.\\<not> p} \\<turnstile> q\\<close>"], ["proof (prove)\nusing this:\n  A \\<turnstile> .\\<not> p .\\<longrightarrow>. q\n\ngoal (1 subgoal):\n 1. A \\<union> {.\\<not> p} \\<turnstile> q", "using imp_PL"], ["proof (prove)\nusing this:\n  A \\<turnstile> .\\<not> p .\\<longrightarrow>. q\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (?A \\<union> {?p} \\<turnstile> ?q)\n\ngoal (1 subgoal):\n 1. A \\<union> {.\\<not> p} \\<turnstile> q", "by blast"], ["proof (state)\nthis:\n  A \\<union> {.\\<not> p} \\<turnstile> q\n\ngoal (1 subgoal):\n 1. A \\<union> {.\\<not> p} \\<turnstile> q \\<Longrightarrow>\n    A \\<turnstile> p .\\<or>. q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<union> {.\\<not> p} \\<turnstile> q \\<Longrightarrow>\n    A \\<turnstile> p .\\<or>. q", "assume a:\\<open>A \\<union> {.\\<not> p} \\<turnstile> q\\<close>"], ["proof (state)\nthis:\n  A \\<union> {.\\<not> p} \\<turnstile> q\n\ngoal (1 subgoal):\n 1. A \\<union> {.\\<not> p} \\<turnstile> q \\<Longrightarrow>\n    A \\<turnstile> p .\\<or>. q", "hence b:\\<open>A \\<turnstile> .\\<not> p .\\<longrightarrow>. q\\<close>"], ["proof (prove)\nusing this:\n  A \\<union> {.\\<not> p} \\<turnstile> q\n\ngoal (1 subgoal):\n 1. A \\<turnstile> .\\<not> p .\\<longrightarrow>. q", "by (simp add: impI_PL)"], ["proof (state)\nthis:\n  A \\<turnstile> .\\<not> p .\\<longrightarrow>. q\n\ngoal (1 subgoal):\n 1. A \\<union> {.\\<not> p} \\<turnstile> q \\<Longrightarrow>\n    A \\<turnstile> p .\\<or>. q", "then"], ["proof (chain)\npicking this:\n  A \\<turnstile> .\\<not> p .\\<longrightarrow>. q", "show \\<open>A \\<turnstile> p .\\<or>. q\\<close>"], ["proof (prove)\nusing this:\n  A \\<turnstile> .\\<not> p .\\<longrightarrow>. q\n\ngoal (1 subgoal):\n 1. A \\<turnstile> p .\\<or>. q", "apply(rule_tac disjE_PL[OF ex_mid_PL, of A p \\<open>p .\\<or>. q\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<turnstile> .\\<not> p .\\<longrightarrow>. q \\<Longrightarrow>\n    A \\<turnstile> p .\\<longrightarrow>. (p .\\<or>. q)\n 2. A \\<turnstile> .\\<not> p .\\<longrightarrow>. q \\<Longrightarrow>\n    A \\<turnstile> .\\<not> p .\\<longrightarrow>. (p .\\<or>. q)", "by (auto simp add: assumption_L disjI2_PL disjI1_PL impI_PL imp_PL)"], ["proof (state)\nthis:\n  A \\<turnstile> p .\\<or>. q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma equiv_PL:\\<open>A \\<turnstile> p .\\<longleftrightarrow>. q \\<longleftrightarrow> (A \\<union> {p} \\<turnstile> q \\<and> A \\<union> {q} \\<turnstile> p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<longleftrightarrow>. q) =\n    (A \\<union> {p} \\<turnstile> q \\<and> A \\<union> {q} \\<turnstile> p)", "using imp_PL equivE1_PL equivE2_PL equivI_PL"], ["proof (prove)\nusing this:\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (?A \\<union> {?p} \\<turnstile> ?q)\n  ?A \\<turnstile> ?p .\\<longleftrightarrow>. ?q \\<Longrightarrow>\n  ?A \\<turnstile> ?p .\\<longrightarrow>. ?q\n  ?A \\<turnstile> ?p .\\<longleftrightarrow>. ?q \\<Longrightarrow>\n  ?A \\<turnstile> ?q .\\<longrightarrow>. ?p\n  \\<lbrakk>?A \\<turnstile> ?p .\\<longrightarrow>. ?q;\n   ?A \\<turnstile> ?q .\\<longrightarrow>. ?p\\<rbrakk>\n  \\<Longrightarrow> ?A \\<turnstile> ?p .\\<longleftrightarrow>. ?q\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<longleftrightarrow>. q) =\n    (A \\<union> {p} \\<turnstile> q \\<and> A \\<union> {q} \\<turnstile> p)", "by blast"], ["", "corollary valid_imp_PL:  \\<open>\\<tturnstile> (p .\\<longrightarrow>. q) = ({p} \\<turnstile> q)\\<close>\n      and valid_not_PL:  \\<open>\\<tturnstile> (.\\<not> p) = ({p} \\<turnstile> \\<bottom>)\\<close>\n      and valid_conj_PL: \\<open>\\<tturnstile> (p .\\<and>. q) = (\\<tturnstile> p \\<and> \\<tturnstile> q)\\<close>\n      and valid_disj_PL: \\<open>\\<tturnstile> (p .\\<or>. q) = ({.\\<not> p} \\<turnstile> q)\\<close>\n      and valid_equiv_PL:\\<open>\\<tturnstile> (p .\\<longleftrightarrow>. q) = ({p} \\<turnstile> q \\<and> {q} \\<turnstile> p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tturnstile> (p .\\<longrightarrow>. q) = ({p} \\<turnstile> q) &&&\n     \\<tturnstile> (.\\<not> p) = ({p} \\<turnstile> \\<bottom>)) &&&\n    \\<tturnstile> (p .\\<and>. q) =\n    (\\<tturnstile> p \\<and> \\<tturnstile> q) &&&\n    \\<tturnstile> (p .\\<or>. q) = ({.\\<not> p} \\<turnstile> q) &&&\n    \\<tturnstile> (p .\\<longleftrightarrow>. q) =\n    ({p} \\<turnstile> q \\<and> {q} \\<turnstile> p)", "using imp_PL not_PL conj_PL disj_PL equiv_PL valid_def"], ["proof (prove)\nusing this:\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (?A \\<union> {?p} \\<turnstile> ?q)\n  (?A \\<turnstile> .\\<not> ?p) = (?A \\<union> {?p} \\<turnstile> \\<bottom>)\n  (?A \\<turnstile> ?p .\\<and>. ?q) =\n  (?A \\<turnstile> ?p \\<and> ?A \\<turnstile> ?q)\n  (?A \\<turnstile> ?p .\\<or>. ?q) =\n  (?A \\<union> {.\\<not> ?p} \\<turnstile> ?q)\n  (?A \\<turnstile> ?p .\\<longleftrightarrow>. ?q) =\n  (?A \\<union> {?p} \\<turnstile> ?q \\<and> ?A \\<union> {?q} \\<turnstile> ?p)\n  \\<tturnstile> ?\\<phi> \\<equiv> {} \\<turnstile> ?\\<phi>\n\ngoal (1 subgoal):\n 1. (\\<tturnstile> (p .\\<longrightarrow>. q) = ({p} \\<turnstile> q) &&&\n     \\<tturnstile> (.\\<not> p) = ({p} \\<turnstile> \\<bottom>)) &&&\n    \\<tturnstile> (p .\\<and>. q) =\n    (\\<tturnstile> p \\<and> \\<tturnstile> q) &&&\n    \\<tturnstile> (p .\\<or>. q) = ({.\\<not> p} \\<turnstile> q) &&&\n    \\<tturnstile> (p .\\<longleftrightarrow>. q) =\n    ({p} \\<turnstile> q \\<and> {q} \\<turnstile> p)", "by auto"], ["", "text\\<open>Second, we will combine each logical operator with the consequence operator \\<open>Cn\\<close>: it is a trick to profit from set theory to get many essential \nlemmas without complex inferences\\<close>"], ["", "declare infer_def[simp]"], ["", "lemma nonemptyCn: \\<open>Cn(A) \\<noteq> {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn A \\<noteq> {}", "using true_PL"], ["proof (prove)\nusing this:\n  ?A \\<turnstile> \\<top>\n\ngoal (1 subgoal):\n 1. Cn A \\<noteq> {}", "by auto"], ["", "lemma Cn_true: \\<open>Cn({\\<top>}) = Cn({})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn {\\<top>} = Cn {}", "using Cn_same true_PL"], ["proof (prove)\nusing this:\n  (Cn ?A = Cn ?B) =\n  (\\<forall>C. (?A \\<subseteq> Cn C) = (?B \\<subseteq> Cn C))\n  ?A \\<turnstile> \\<top>\n\ngoal (1 subgoal):\n 1. Cn {\\<top>} = Cn {}", "by auto"], ["", "lemma Cn_false: \\<open>Cn({\\<bottom>}) = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn {\\<bottom>} = UNIV", "using false_PL"], ["proof (prove)\nusing this:\n  {\\<bottom>} \\<turnstile> ?p\n\ngoal (1 subgoal):\n 1. Cn {\\<bottom>} = UNIV", "by auto"], ["", "lemma Cn_imp:     \\<open>A \\<turnstile> (p .\\<longrightarrow>. q) \\<longleftrightarrow> Cn({q}) \\<subseteq> Cn(A \\<union> {p})\\<close> \n  and Cn_imp_bis: \\<open>A \\<turnstile> (p .\\<longrightarrow>. q) \\<longleftrightarrow> Cn(A \\<union> {q}) \\<subseteq> Cn(A \\<union> {p})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<longrightarrow>. q) =\n    (Cn {q} \\<subseteq> Cn (A \\<union> {p})) &&&\n    (A \\<turnstile> p .\\<longrightarrow>. q) =\n    (Cn (A \\<union> {q}) \\<subseteq> Cn (A \\<union> {p}))", "using Cn_same imp_PL idempotency_L inclusion_L infer_def subset_insertI"], ["proof (prove)\nusing this:\n  (Cn ?A = Cn ?B) =\n  (\\<forall>C. (?A \\<subseteq> Cn C) = (?B \\<subseteq> Cn C))\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (?A \\<union> {?p} \\<turnstile> ?q)\n  Cn (Cn ?A) = Cn ?A\n  ?A \\<subseteq> Cn ?A\n  ?A \\<turnstile> ?\\<phi> \\<equiv> ?\\<phi> \\<in> Cn ?A\n  ?B \\<subseteq> insert ?a ?B\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<longrightarrow>. q) =\n    (Cn {q} \\<subseteq> Cn (A \\<union> {p})) &&&\n    (A \\<turnstile> p .\\<longrightarrow>. q) =\n    (Cn (A \\<union> {q}) \\<subseteq> Cn (A \\<union> {p}))", "by force+"], ["", "lemma Cn_not: \\<open>A \\<turnstile> .\\<not> p \\<longleftrightarrow> Cn(A \\<union> {p}) = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> .\\<not> p) = (Cn (A \\<union> {p}) = UNIV)", "using Cn_false Cn_imp notE_PL not_PL"], ["proof (prove)\nusing this:\n  Cn {\\<bottom>} = UNIV\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (Cn {?q} \\<subseteq> Cn (?A \\<union> {?p}))\n  ?A \\<turnstile> .\\<not> ?p \\<Longrightarrow>\n  ?A \\<turnstile> ?p .\\<longrightarrow>. \\<bottom>\n  (?A \\<turnstile> .\\<not> ?p) = (?A \\<union> {?p} \\<turnstile> \\<bottom>)\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> .\\<not> p) = (Cn (A \\<union> {p}) = UNIV)", "by fastforce"], ["", "lemma Cn_conj: \\<open>A \\<turnstile> (p .\\<and>. q) \\<longleftrightarrow> Cn({p}) \\<union> Cn({q}) \\<subseteq> Cn(A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<and>. q) =\n    (Cn {p} \\<union> Cn {q} \\<subseteq> Cn A)", "apply(intro iffI conjI_PL, frule conjE1_PL, frule conjE2_PL)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<turnstile> p .\\<and>. q; A \\<turnstile> p;\n     A \\<turnstile> q\\<rbrakk>\n    \\<Longrightarrow> Cn {p} \\<union> Cn {q} \\<subseteq> Cn A\n 2. Cn {p} \\<union> Cn {q} \\<subseteq> Cn A \\<Longrightarrow>\n    A \\<turnstile> p\n 3. Cn {p} \\<union> Cn {q} \\<subseteq> Cn A \\<Longrightarrow>\n    A \\<turnstile> q", "using Cn_same Un_insert_right bot.extremum idempotency_L inclusion_L"], ["proof (prove)\nusing this:\n  (Cn ?A = Cn ?B) =\n  (\\<forall>C. (?A \\<subseteq> Cn C) = (?B \\<subseteq> Cn C))\n  ?A \\<union> insert ?a ?B = insert ?a (?A \\<union> ?B)\n  bot \\<le> ?a\n  Cn (Cn ?A) = Cn ?A\n  ?A \\<subseteq> Cn ?A\n\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<turnstile> p .\\<and>. q; A \\<turnstile> p;\n     A \\<turnstile> q\\<rbrakk>\n    \\<Longrightarrow> Cn {p} \\<union> Cn {q} \\<subseteq> Cn A\n 2. Cn {p} \\<union> Cn {q} \\<subseteq> Cn A \\<Longrightarrow>\n    A \\<turnstile> p\n 3. Cn {p} \\<union> Cn {q} \\<subseteq> Cn A \\<Longrightarrow>\n    A \\<turnstile> q", "by auto"], ["", "lemma Cn_conj_bis: \\<open>Cn({p .\\<and>. q}) = Cn({p, q})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn {p .\\<and>. q} = Cn {p, q}", "by (unfold Cn_same)\n     (meson Supraclassical_logic.conj_PL Supraclassical_logic_axioms insert_subset)"], ["", "lemma Cn_disj:     \\<open>A \\<turnstile> (p .\\<or>. q) \\<longleftrightarrow> Cn({q}) \\<subseteq> Cn(A \\<union> {.\\<not> p})\\<close>\n  and Cn_disj_bis: \\<open>A \\<turnstile> (p .\\<or>. q) \\<longleftrightarrow> Cn(A \\<union> {q}) \\<subseteq> Cn(A \\<union> {.\\<not> p})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<or>. q) =\n    (Cn {q} \\<subseteq> Cn (A \\<union> {.\\<not> p})) &&&\n    (A \\<turnstile> p .\\<or>. q) =\n    (Cn (A \\<union> {q}) \\<subseteq> Cn (A \\<union> {.\\<not> p}))", "using disj_PL Cn_same imp_PL idempotency_L inclusion_L infer_def subset_insertI"], ["proof (prove)\nusing this:\n  (?A \\<turnstile> ?p .\\<or>. ?q) =\n  (?A \\<union> {.\\<not> ?p} \\<turnstile> ?q)\n  (Cn ?A = Cn ?B) =\n  (\\<forall>C. (?A \\<subseteq> Cn C) = (?B \\<subseteq> Cn C))\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (?A \\<union> {?p} \\<turnstile> ?q)\n  Cn (Cn ?A) = Cn ?A\n  ?A \\<subseteq> Cn ?A\n  ?A \\<turnstile> ?\\<phi> \\<equiv> ?\\<phi> \\<in> Cn ?A\n  ?B \\<subseteq> insert ?a ?B\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<or>. q) =\n    (Cn {q} \\<subseteq> Cn (A \\<union> {.\\<not> p})) &&&\n    (A \\<turnstile> p .\\<or>. q) =\n    (Cn (A \\<union> {q}) \\<subseteq> Cn (A \\<union> {.\\<not> p}))", "by force+"], ["", "lemma Cn_equiv: \\<open>A \\<turnstile> (p .\\<longleftrightarrow>. q) \\<longleftrightarrow> Cn(A \\<union> {p}) = Cn(A \\<union> {q})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<longleftrightarrow>. q) =\n    (Cn (A \\<union> {p}) = Cn (A \\<union> {q}))", "by (metis Cn_imp_bis equivE1_PL equivE2_PL equivI_PL set_eq_subset)"], ["", "corollary valid_nonemptyCn: \\<open>Cn({}) \\<noteq> {}\\<close>\n      and valid_Cn_imp:     \\<open>\\<tturnstile> (p .\\<longrightarrow>. q) \\<longleftrightarrow> Cn({q}) \\<subseteq> Cn({p})\\<close> \n      and valid_Cn_not:     \\<open>\\<tturnstile> (.\\<not> p) \\<longleftrightarrow> Cn({p}) = UNIV\\<close>\n      and valid_Cn_conj:    \\<open>\\<tturnstile> (p .\\<and>. q) \\<longleftrightarrow> Cn({p}) \\<union> Cn({q}) \\<subseteq> Cn({})\\<close>\n      and valid_Cn_disj:    \\<open>\\<tturnstile> (p .\\<or>. q) \\<longleftrightarrow> Cn({q}) \\<subseteq> Cn({.\\<not> p})\\<close>\n      and valid_Cn_equiv:   \\<open>\\<tturnstile> (p .\\<longleftrightarrow>. q) \\<longleftrightarrow> Cn({p}) = Cn({q})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Cn {} \\<noteq> {} &&&\n     \\<tturnstile> (p .\\<longrightarrow>. q) =\n     (Cn {q} \\<subseteq> Cn {p}) &&&\n     \\<tturnstile> (.\\<not> p) = (Cn {p} = UNIV)) &&&\n    \\<tturnstile> (p .\\<and>. q) =\n    (Cn {p} \\<union> Cn {q} \\<subseteq> Cn {}) &&&\n    \\<tturnstile> (p .\\<or>. q) = (Cn {q} \\<subseteq> Cn {.\\<not> p}) &&&\n    \\<tturnstile> (p .\\<longleftrightarrow>. q) = (Cn {p} = Cn {q})", "using nonemptyCn Cn_imp Cn_not Cn_conj Cn_disj Cn_equiv valid_def"], ["proof (prove)\nusing this:\n  Cn ?A \\<noteq> {}\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (Cn {?q} \\<subseteq> Cn (?A \\<union> {?p}))\n  (?A \\<turnstile> .\\<not> ?p) = (Cn (?A \\<union> {?p}) = UNIV)\n  (?A \\<turnstile> ?p .\\<and>. ?q) =\n  (Cn {?p} \\<union> Cn {?q} \\<subseteq> Cn ?A)\n  (?A \\<turnstile> ?p .\\<or>. ?q) =\n  (Cn {?q} \\<subseteq> Cn (?A \\<union> {.\\<not> ?p}))\n  (?A \\<turnstile> ?p .\\<longleftrightarrow>. ?q) =\n  (Cn (?A \\<union> {?p}) = Cn (?A \\<union> {?q}))\n  \\<tturnstile> ?\\<phi> \\<equiv> {} \\<turnstile> ?\\<phi>\n\ngoal (1 subgoal):\n 1. (Cn {} \\<noteq> {} &&&\n     \\<tturnstile> (p .\\<longrightarrow>. q) =\n     (Cn {q} \\<subseteq> Cn {p}) &&&\n     \\<tturnstile> (.\\<not> p) = (Cn {p} = UNIV)) &&&\n    \\<tturnstile> (p .\\<and>. q) =\n    (Cn {p} \\<union> Cn {q} \\<subseteq> Cn {}) &&&\n    \\<tturnstile> (p .\\<or>. q) = (Cn {q} \\<subseteq> Cn {.\\<not> p}) &&&\n    \\<tturnstile> (p .\\<longleftrightarrow>. q) = (Cn {p} = Cn {q})", "by auto\n\n\\<comment> \\<open>Finally, we group additional lemmas that were essential in further proofs\\<close>"], ["", "lemma consistency: \\<open>Cn({p}) \\<inter> Cn({.\\<not> p}) = Cn({})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn {p} \\<inter> Cn {.\\<not> p} = Cn {}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Cn {p} \\<inter> Cn {.\\<not> p} \\<subseteq> Cn {}\n 2. Cn {} \\<subseteq> Cn {p} \\<inter> Cn {.\\<not> p}", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. Cn {p} \\<inter> Cn {.\\<not> p} \\<subseteq> Cn {}\n 2. Cn {} \\<subseteq> Cn {p} \\<inter> Cn {.\\<not> p}", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. Cn {p} \\<inter> Cn {.\\<not> p} \\<subseteq> Cn {}\n 2. Cn {} \\<subseteq> Cn {p} \\<inter> Cn {.\\<not> p}", "assume \\<open>{p} \\<turnstile> q\\<close> and \\<open>{.\\<not> p} \\<turnstile> q\\<close>"], ["proof (state)\nthis:\n  {p} \\<turnstile> q\n  {.\\<not> p} \\<turnstile> q\n\ngoal (2 subgoals):\n 1. Cn {p} \\<inter> Cn {.\\<not> p} \\<subseteq> Cn {}\n 2. Cn {} \\<subseteq> Cn {p} \\<inter> Cn {.\\<not> p}", "hence \"{} \\<turnstile> p .\\<longrightarrow>. q\" and \"{} \\<turnstile> (.\\<not> p) .\\<longrightarrow>. q\""], ["proof (prove)\nusing this:\n  {p} \\<turnstile> q\n  {.\\<not> p} \\<turnstile> q\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> p .\\<longrightarrow>. q &&&\n    {} \\<turnstile> .\\<not> p .\\<longrightarrow>. q", "using impI_PL"], ["proof (prove)\nusing this:\n  {p} \\<turnstile> q\n  {.\\<not> p} \\<turnstile> q\n  ?A \\<union> {?p} \\<turnstile> ?q \\<Longrightarrow>\n  ?A \\<turnstile> ?p .\\<longrightarrow>. ?q\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> p .\\<longrightarrow>. q &&&\n    {} \\<turnstile> .\\<not> p .\\<longrightarrow>. q", "by auto"], ["proof (state)\nthis:\n  {} \\<turnstile> p .\\<longrightarrow>. q\n  {} \\<turnstile> .\\<not> p .\\<longrightarrow>. q\n\ngoal (2 subgoals):\n 1. Cn {p} \\<inter> Cn {.\\<not> p} \\<subseteq> Cn {}\n 2. Cn {} \\<subseteq> Cn {p} \\<inter> Cn {.\\<not> p}", "hence \\<open>{} \\<turnstile> q\\<close>"], ["proof (prove)\nusing this:\n  {} \\<turnstile> p .\\<longrightarrow>. q\n  {} \\<turnstile> .\\<not> p .\\<longrightarrow>. q\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> q", "using ex_mid_PL"], ["proof (prove)\nusing this:\n  {} \\<turnstile> p .\\<longrightarrow>. q\n  {} \\<turnstile> .\\<not> p .\\<longrightarrow>. q\n  ?A \\<turnstile> ?p .\\<or>. .\\<not> ?p\n\ngoal (1 subgoal):\n 1. {} \\<turnstile> q", "by (rule_tac disjE_PL[where p=p and q=\\<open>.\\<not> p\\<close>]) blast"], ["proof (state)\nthis:\n  {} \\<turnstile> q\n\ngoal (2 subgoals):\n 1. Cn {p} \\<inter> Cn {.\\<not> p} \\<subseteq> Cn {}\n 2. Cn {} \\<subseteq> Cn {p} \\<inter> Cn {.\\<not> p}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>{p} \\<turnstile> ?q2; {.\\<not> p} \\<turnstile> ?q2\\<rbrakk>\n  \\<Longrightarrow> {} \\<turnstile> ?q2\n\ngoal (2 subgoals):\n 1. Cn {p} \\<inter> Cn {.\\<not> p} \\<subseteq> Cn {}\n 2. Cn {} \\<subseteq> Cn {p} \\<inter> Cn {.\\<not> p}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>{p} \\<turnstile> ?q2; {.\\<not> p} \\<turnstile> ?q2\\<rbrakk>\n  \\<Longrightarrow> {} \\<turnstile> ?q2", "show \\<open>Cn({p}) \\<inter> Cn({.\\<not> p}) \\<subseteq> Cn({})\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>{p} \\<turnstile> ?q2; {.\\<not> p} \\<turnstile> ?q2\\<rbrakk>\n  \\<Longrightarrow> {} \\<turnstile> ?q2\n\ngoal (1 subgoal):\n 1. Cn {p} \\<inter> Cn {.\\<not> p} \\<subseteq> Cn {}", "by (simp add: subset_iff)"], ["proof (state)\nthis:\n  Cn {p} \\<inter> Cn {.\\<not> p} \\<subseteq> Cn {}\n\ngoal (1 subgoal):\n 1. Cn {} \\<subseteq> Cn {p} \\<inter> Cn {.\\<not> p}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Cn {} \\<subseteq> Cn {p} \\<inter> Cn {.\\<not> p}", "show \\<open>Cn({}) \\<subseteq> Cn({p}) \\<inter> Cn({.\\<not> p})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn {} \\<subseteq> Cn {p} \\<inter> Cn {.\\<not> p}", "by (simp add: monotonicity_L)"], ["proof (state)\nthis:\n  Cn {} \\<subseteq> Cn {p} \\<inter> Cn {.\\<not> p}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Cn_notnot: \\<open>Cn({.\\<not> (.\\<not> \\<phi>)}) = Cn({\\<phi>})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn {.\\<not> (.\\<not> \\<phi>)} = Cn {\\<phi>}", "by (metis (no_types, hide_lams) notnot_PL valid_Cn_equiv valid_equiv_PL)"], ["", "lemma conj_com: \\<open>A \\<turnstile> p .\\<and>. q \\<longleftrightarrow> A \\<turnstile> q .\\<and>. p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<and>. q) = (A \\<turnstile> q .\\<and>. p)", "using conj_PL"], ["proof (prove)\nusing this:\n  (?A \\<turnstile> ?p .\\<and>. ?q) =\n  (?A \\<turnstile> ?p \\<and> ?A \\<turnstile> ?q)\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<and>. q) = (A \\<turnstile> q .\\<and>. p)", "by auto"], ["", "lemma conj_com_Cn: \\<open>Cn({p .\\<and>. q}) = Cn({q .\\<and>. p})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn {p .\\<and>. q} = Cn {q .\\<and>. p}", "by (simp add: Cn_conj_bis insert_commute)"], ["", "lemma disj_com: \\<open>A \\<turnstile> p .\\<or>. q \\<longleftrightarrow> A \\<turnstile> q .\\<or>. p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<or>. q) = (A \\<turnstile> q .\\<or>. p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<or>. q) = (A \\<turnstile> q .\\<or>. p)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<or>. q) = (A \\<turnstile> q .\\<or>. p)", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<or>. q) = (A \\<turnstile> q .\\<or>. p)", "have \\<open>A \\<turnstile> p .\\<or>. q \\<Longrightarrow> A \\<turnstile> q .\\<or>. p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile> p .\\<or>. q \\<Longrightarrow> A \\<turnstile> q .\\<or>. p", "apply(erule disjE_PL)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<turnstile> p .\\<longrightarrow>. (q .\\<or>. p)\n 2. A \\<turnstile> q .\\<longrightarrow>. (q .\\<or>. p)", "using assumption_L disjI2_PL disjI1_PL impI_PL"], ["proof (prove)\nusing this:\n  ?\\<phi> \\<in> ?A \\<Longrightarrow> ?A \\<turnstile> ?\\<phi>\n  ?A \\<turnstile> ?q \\<Longrightarrow> ?A \\<turnstile> ?p .\\<or>. ?q\n  ?A \\<turnstile> ?p \\<Longrightarrow> ?A \\<turnstile> ?p .\\<or>. ?q\n  ?A \\<union> {?p} \\<turnstile> ?q \\<Longrightarrow>\n  ?A \\<turnstile> ?p .\\<longrightarrow>. ?q\n\ngoal (2 subgoals):\n 1. A \\<turnstile> p .\\<longrightarrow>. (q .\\<or>. p)\n 2. A \\<turnstile> q .\\<longrightarrow>. (q .\\<or>. p)", "by auto"], ["proof (state)\nthis:\n  A \\<turnstile> p .\\<or>. q \\<Longrightarrow> A \\<turnstile> q .\\<or>. p\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<or>. q) = (A \\<turnstile> q .\\<or>. p)", "}"], ["proof (state)\nthis:\n  A \\<turnstile> ?pa2 .\\<or>. ?qa2 \\<Longrightarrow>\n  A \\<turnstile> ?qa2 .\\<or>. ?pa2\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<or>. q) = (A \\<turnstile> q .\\<or>. p)", "then"], ["proof (chain)\npicking this:\n  A \\<turnstile> ?pa2 .\\<or>. ?qa2 \\<Longrightarrow>\n  A \\<turnstile> ?qa2 .\\<or>. ?pa2", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<turnstile> ?pa2 .\\<or>. ?qa2 \\<Longrightarrow>\n  A \\<turnstile> ?qa2 .\\<or>. ?pa2\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<or>. q) = (A \\<turnstile> q .\\<or>. p)", "by auto"], ["proof (state)\nthis:\n  (A \\<turnstile> p .\\<or>. q) = (A \\<turnstile> q .\\<or>. p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma disj_com_Cn: \\<open>Cn({p .\\<or>. q}) = Cn({q .\\<or>. p})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn {p .\\<or>. q} = Cn {q .\\<or>. p}", "unfolding Cn_same"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       ({p .\\<or>. q} \\<subseteq> Cn C) = ({q .\\<or>. p} \\<subseteq> Cn C)", "using disj_com"], ["proof (prove)\nusing this:\n  (?A \\<turnstile> ?p .\\<or>. ?q) = (?A \\<turnstile> ?q .\\<or>. ?p)\n\ngoal (1 subgoal):\n 1. \\<forall>C.\n       ({p .\\<or>. q} \\<subseteq> Cn C) = ({q .\\<or>. p} \\<subseteq> Cn C)", "by simp"], ["", "lemma imp_contrapos: \\<open>A \\<turnstile> p .\\<longrightarrow>. q \\<longleftrightarrow> A \\<turnstile> .\\<not> q .\\<longrightarrow>. .\\<not> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<longrightarrow>. q) =\n    (A \\<turnstile> .\\<not> q .\\<longrightarrow>. .\\<not> p)", "by (metis Cn_not Un_insert_left Un_insert_right imp_PL notnot_PL)"], ["", "lemma equiv_negation: \\<open>A \\<turnstile> p .\\<longleftrightarrow>. q \\<longleftrightarrow> A \\<turnstile> .\\<not> p .\\<longleftrightarrow>. .\\<not> q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<longleftrightarrow>. q) =\n    (A \\<turnstile> .\\<not> p .\\<longleftrightarrow>. .\\<not> q)", "using equivE1_PL equivE2_PL equivI_PL imp_contrapos"], ["proof (prove)\nusing this:\n  ?A \\<turnstile> ?p .\\<longleftrightarrow>. ?q \\<Longrightarrow>\n  ?A \\<turnstile> ?p .\\<longrightarrow>. ?q\n  ?A \\<turnstile> ?p .\\<longleftrightarrow>. ?q \\<Longrightarrow>\n  ?A \\<turnstile> ?q .\\<longrightarrow>. ?p\n  \\<lbrakk>?A \\<turnstile> ?p .\\<longrightarrow>. ?q;\n   ?A \\<turnstile> ?q .\\<longrightarrow>. ?p\\<rbrakk>\n  \\<Longrightarrow> ?A \\<turnstile> ?p .\\<longleftrightarrow>. ?q\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (?A \\<turnstile> .\\<not> ?q .\\<longrightarrow>. .\\<not> ?p)\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<longleftrightarrow>. q) =\n    (A \\<turnstile> .\\<not> p .\\<longleftrightarrow>. .\\<not> q)", "by blast"], ["", "lemma imp_trans: \\<open>A \\<turnstile> p .\\<longrightarrow>.q \\<Longrightarrow> A \\<turnstile> q .\\<longrightarrow>.r \\<Longrightarrow> A \\<turnstile> p .\\<longrightarrow>.r\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> p .\\<longrightarrow>. q;\n     A \\<turnstile> q .\\<longrightarrow>. r\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile> p .\\<longrightarrow>. r", "using Cn_imp_bis"], ["proof (prove)\nusing this:\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (Cn (?A \\<union> {?q}) \\<subseteq> Cn (?A \\<union> {?p}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> p .\\<longrightarrow>. q;\n     A \\<turnstile> q .\\<longrightarrow>. r\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile> p .\\<longrightarrow>. r", "by auto"], ["", "lemma imp_recovery0: \\<open>A \\<turnstile> p .\\<or>. (p .\\<longrightarrow>. q)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile> p .\\<or>. (p .\\<longrightarrow>. q)", "apply(subst disj_PL, subst imp_contrapos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> {.\\<not> p} \\<turnstile>\n    .\\<not> q .\\<longrightarrow>. .\\<not> p", "using assumption_L impI_PL"], ["proof (prove)\nusing this:\n  ?\\<phi> \\<in> ?A \\<Longrightarrow> ?A \\<turnstile> ?\\<phi>\n  ?A \\<union> {?p} \\<turnstile> ?q \\<Longrightarrow>\n  ?A \\<turnstile> ?p .\\<longrightarrow>. ?q\n\ngoal (1 subgoal):\n 1. A \\<union> {.\\<not> p} \\<turnstile>\n    .\\<not> q .\\<longrightarrow>. .\\<not> p", "by auto"], ["", "lemma imp_recovery1: \\<open>A \\<union> {p .\\<longrightarrow>. q} \\<turnstile> p \\<Longrightarrow> A \\<turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> {p .\\<longrightarrow>. q} \\<turnstile> p \\<Longrightarrow>\n    A \\<turnstile> p", "using disjE_PL[OF imp_recovery0, of A p p q] assumption_L imp_PL"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<turnstile> p .\\<longrightarrow>. p;\n   A \\<turnstile> (p .\\<longrightarrow>. q) .\\<longrightarrow>. p\\<rbrakk>\n  \\<Longrightarrow> A \\<turnstile> p\n  ?\\<phi> \\<in> ?A \\<Longrightarrow> ?A \\<turnstile> ?\\<phi>\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (?A \\<union> {?p} \\<turnstile> ?q)\n\ngoal (1 subgoal):\n 1. A \\<union> {p .\\<longrightarrow>. q} \\<turnstile> p \\<Longrightarrow>\n    A \\<turnstile> p", "by auto"], ["", "lemma imp_recovery2: \\<open>A \\<turnstile> p .\\<longrightarrow>. q \\<Longrightarrow> A \\<turnstile> (q .\\<longrightarrow>. p) .\\<longrightarrow>. p \\<Longrightarrow> A \\<turnstile> q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> p .\\<longrightarrow>. q;\n     A \\<turnstile> (q .\\<longrightarrow>. p) .\\<longrightarrow>. p\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile> q", "using imp_PL imp_recovery1 imp_trans"], ["proof (prove)\nusing this:\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (?A \\<union> {?p} \\<turnstile> ?q)\n  ?A \\<union> {?p .\\<longrightarrow>. ?q} \\<turnstile> ?p \\<Longrightarrow>\n  ?A \\<turnstile> ?p\n  \\<lbrakk>?A \\<turnstile> ?p .\\<longrightarrow>. ?q;\n   ?A \\<turnstile> ?q .\\<longrightarrow>. ?r\\<rbrakk>\n  \\<Longrightarrow> ?A \\<turnstile> ?p .\\<longrightarrow>. ?r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> p .\\<longrightarrow>. q;\n     A \\<turnstile> (q .\\<longrightarrow>. p) .\\<longrightarrow>. p\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile> q", "by blast"], ["", "lemma impI2: \\<open>A \\<turnstile> q \\<Longrightarrow> A \\<turnstile> p .\\<longrightarrow>. q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile> q \\<Longrightarrow>\n    A \\<turnstile> p .\\<longrightarrow>. q", "by (meson assumption_L impI_PL in_mono sup_ge1 transitivity2_L)"], ["", "lemma conj_equiv: \\<open>A \\<turnstile> p \\<Longrightarrow> A \\<turnstile> ((p .\\<and>. q) .\\<longleftrightarrow>. q)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile> p \\<Longrightarrow>\n    A \\<turnstile> (p .\\<and>. q) .\\<longleftrightarrow>. q", "by (metis Un_insert_right assumption_L conjE2_PL conjI_PL equiv_PL impI2 imp_PL insertI1 sup_bot.right_neutral)"], ["", "lemma conj_imp: \\<open>A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r \\<longleftrightarrow> A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r) =\n    (A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r \\<Longrightarrow>\n    A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)\n 2. A \\<turnstile>\n    p .\\<longrightarrow>. (q .\\<longrightarrow>. r) \\<Longrightarrow>\n    A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r", "assume \"A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r\""], ["proof (state)\nthis:\n  A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r\n\ngoal (2 subgoals):\n 1. A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r \\<Longrightarrow>\n    A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)\n 2. A \\<turnstile>\n    p .\\<longrightarrow>. (q .\\<longrightarrow>. r) \\<Longrightarrow>\n    A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r", "then"], ["proof (chain)\npicking this:\n  A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r", "have \"Cn (A \\<union> {r}) \\<subseteq> Cn (A \\<union> {p, q})\""], ["proof (prove)\nusing this:\n  A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r\n\ngoal (1 subgoal):\n 1. Cn (A \\<union> {r}) \\<subseteq> Cn (A \\<union> {p, q})", "by (metis (no_types) Cn_conj_bis Cn_imp_bis Cn_union Un_insert_right sup_bot.right_neutral)"], ["proof (state)\nthis:\n  Cn (A \\<union> {r}) \\<subseteq> Cn (A \\<union> {p, q})\n\ngoal (2 subgoals):\n 1. A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r \\<Longrightarrow>\n    A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)\n 2. A \\<turnstile>\n    p .\\<longrightarrow>. (q .\\<longrightarrow>. r) \\<Longrightarrow>\n    A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r", "then"], ["proof (chain)\npicking this:\n  Cn (A \\<union> {r}) \\<subseteq> Cn (A \\<union> {p, q})", "show \\<open>A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)\\<close>"], ["proof (prove)\nusing this:\n  Cn (A \\<union> {r}) \\<subseteq> Cn (A \\<union> {p, q})\n\ngoal (1 subgoal):\n 1. A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)", "by (metis Un_insert_right impI_PL inclusion_L infer_def insert_commute insert_subset subset_eq sup_bot.right_neutral)"], ["proof (state)\nthis:\n  A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\n    p .\\<longrightarrow>. (q .\\<longrightarrow>. r) \\<Longrightarrow>\n    A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<turnstile>\n    p .\\<longrightarrow>. (q .\\<longrightarrow>. r) \\<Longrightarrow>\n    A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r", "assume \"A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)\""], ["proof (state)\nthis:\n  A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\n    p .\\<longrightarrow>. (q .\\<longrightarrow>. r) \\<Longrightarrow>\n    A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r", "then"], ["proof (chain)\npicking this:\n  A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)", "have \"A \\<union> {p} \\<union> {q} \\<turnstile> r\""], ["proof (prove)\nusing this:\n  A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)\n\ngoal (1 subgoal):\n 1. A \\<union> {p} \\<union> {q} \\<turnstile> r", "using imp_PL"], ["proof (prove)\nusing this:\n  A \\<turnstile> p .\\<longrightarrow>. (q .\\<longrightarrow>. r)\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (?A \\<union> {?p} \\<turnstile> ?q)\n\ngoal (1 subgoal):\n 1. A \\<union> {p} \\<union> {q} \\<turnstile> r", "by auto"], ["proof (state)\nthis:\n  A \\<union> {p} \\<union> {q} \\<turnstile> r\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\n    p .\\<longrightarrow>. (q .\\<longrightarrow>. r) \\<Longrightarrow>\n    A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r", "then"], ["proof (chain)\npicking this:\n  A \\<union> {p} \\<union> {q} \\<turnstile> r", "show \"A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r\""], ["proof (prove)\nusing this:\n  A \\<union> {p} \\<union> {q} \\<turnstile> r\n\ngoal (1 subgoal):\n 1. A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r", "by (metis (full_types) Cn_conj_bis Cn_union impI_PL infer_def insert_is_Un sup_assoc)"], ["proof (state)\nthis:\n  A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conj_not_impE_PL: \\<open>A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r \\<Longrightarrow> A \\<turnstile> (p .\\<and>. .\\<not> q) .\\<longrightarrow>. r \\<Longrightarrow> A \\<turnstile> p .\\<longrightarrow>. r\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> (p .\\<and>. q) .\\<longrightarrow>. r;\n     A \\<turnstile> (p .\\<and>. .\\<not> q) .\\<longrightarrow>. r\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile> p .\\<longrightarrow>. r", "by (meson conj_imp disjE_PL ex_mid_PL imp_PL)"], ["", "lemma disj_notE_PL: \\<open>A \\<turnstile> q \\<Longrightarrow> A \\<turnstile> p .\\<or>. .\\<not> q \\<Longrightarrow> A \\<turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> q; A \\<turnstile> p .\\<or>. .\\<not> q\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile> p", "using Cn_imp Cn_imp_bis Cn_not disjE_PL notnot_PL"], ["proof (prove)\nusing this:\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (Cn {?q} \\<subseteq> Cn (?A \\<union> {?p}))\n  (?A \\<turnstile> ?p .\\<longrightarrow>. ?q) =\n  (Cn (?A \\<union> {?q}) \\<subseteq> Cn (?A \\<union> {?p}))\n  (?A \\<turnstile> .\\<not> ?p) = (Cn (?A \\<union> {?p}) = UNIV)\n  \\<lbrakk>?A \\<turnstile> ?p .\\<or>. ?q;\n   ?A \\<turnstile> ?p .\\<longrightarrow>. ?r;\n   ?A \\<turnstile> ?q .\\<longrightarrow>. ?r\\<rbrakk>\n  \\<Longrightarrow> ?A \\<turnstile> ?r\n  (?A \\<turnstile> .\\<not> (.\\<not> ?p)) = (?A \\<turnstile> ?p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> q; A \\<turnstile> p .\\<or>. .\\<not> q\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile> p", "by blast"], ["", "lemma disj_not_impE_PL: \\<open>A \\<turnstile> (p .\\<or>. q) .\\<longrightarrow>. r \\<Longrightarrow> A \\<turnstile> (p .\\<or>. .\\<not> q) .\\<longrightarrow>. r \\<Longrightarrow> A \\<turnstile> r\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> (p .\\<or>. q) .\\<longrightarrow>. r;\n     A \\<turnstile> (p .\\<or>. .\\<not> q) .\\<longrightarrow>. r\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile> r", "by (metis Un_insert_right disjE_PL disj_PL disj_com ex_mid_PL insert_commute sup_bot.right_neutral)"], ["", "lemma imp_conj: \\<open>A \\<turnstile> p .\\<longrightarrow>. q \\<Longrightarrow> A \\<turnstile> r .\\<longrightarrow>. s \\<Longrightarrow> A \\<turnstile> (p .\\<and>. r) .\\<longrightarrow>. (q .\\<and>. s)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> p .\\<longrightarrow>. q;\n     A \\<turnstile> r .\\<longrightarrow>. s\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile>\n                      (p .\\<and>. r) .\\<longrightarrow>. (q .\\<and>. s)", "apply(intro impI_PL conjI_PL, unfold imp_PL[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<turnstile> p .\\<longrightarrow>. q;\n     A \\<turnstile> r .\\<longrightarrow>. s\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile> (p .\\<and>. r) .\\<longrightarrow>. q\n 2. \\<lbrakk>A \\<turnstile> p .\\<longrightarrow>. q;\n     A \\<turnstile> r .\\<longrightarrow>. s\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile> (p .\\<and>. r) .\\<longrightarrow>. s", "by (meson assumption_L conjE1_PL conjE2_PL imp_trans infer_def insertI1 validD_L valid_imp_PL)+"], ["", "lemma conj_overlap: \\<open>A \\<turnstile> (p .\\<and>. q) \\<longleftrightarrow> A \\<turnstile> (p .\\<and>. ((.\\<not> p) .\\<or>. q))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> p .\\<and>. q) =\n    (A \\<turnstile> p .\\<and>. (.\\<not> p .\\<or>. q))", "by (meson conj_PL disjI2_PL disj_com disj_notE_PL)"], ["", "lemma morgan: \\<open>A \\<turnstile> .\\<not> (p .\\<and>. q) \\<longleftrightarrow> A \\<turnstile> (.\\<not> p) .\\<or>. (.\\<not> q)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> .\\<not> (p .\\<and>. q)) =\n    (A \\<turnstile> .\\<not> p .\\<or>. .\\<not> q)", "by (meson conj_imp disj_PL disj_com imp_PL imp_contrapos notE_PL notI_PL)"], ["", "lemma conj_superexpansion1: \\<open>A \\<turnstile> .\\<not> (p .\\<and>. q) .\\<and>. .\\<not> p \\<longleftrightarrow> A \\<turnstile> .\\<not> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> .\\<not> (p .\\<and>. q) .\\<and>. .\\<not> p) =\n    (A \\<turnstile> .\\<not> p)", "using conj_PL disjI1_PL morgan"], ["proof (prove)\nusing this:\n  (?A \\<turnstile> ?p .\\<and>. ?q) =\n  (?A \\<turnstile> ?p \\<and> ?A \\<turnstile> ?q)\n  ?A \\<turnstile> ?p \\<Longrightarrow> ?A \\<turnstile> ?p .\\<or>. ?q\n  (?A \\<turnstile> .\\<not> (?p .\\<and>. ?q)) =\n  (?A \\<turnstile> .\\<not> ?p .\\<or>. .\\<not> ?q)\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> .\\<not> (p .\\<and>. q) .\\<and>. .\\<not> p) =\n    (A \\<turnstile> .\\<not> p)", "by auto"], ["", "lemma conj_superexpansion2: \\<open>A \\<turnstile> (p .\\<or>. q) .\\<and>. p \\<longleftrightarrow> A \\<turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<turnstile> (p .\\<or>. q) .\\<and>. p) = (A \\<turnstile> p)", "using conj_PL disjI1_PL"], ["proof (prove)\nusing this:\n  (?A \\<turnstile> ?p .\\<and>. ?q) =\n  (?A \\<turnstile> ?p \\<and> ?A \\<turnstile> ?q)\n  ?A \\<turnstile> ?p \\<Longrightarrow> ?A \\<turnstile> ?p .\\<or>. ?q\n\ngoal (1 subgoal):\n 1. (A \\<turnstile> (p .\\<or>. q) .\\<and>. p) = (A \\<turnstile> p)", "by auto"], ["", "end"], ["", "subsection \\<open>Compact Logic\\<close>"], ["", "text\\<open>If the logic is compact, which means that any result is based on a finite set of hypothesis\\<close>"], ["", "locale Compact_logic = Tarskian_logic +\n  assumes compactness_L: \\<open>A \\<turnstile> \\<phi> \\<Longrightarrow> (\\<exists>A'. A'\\<subseteq> A \\<and> finite A' \\<and> A'\\<turnstile> \\<phi>)\\<close>\n\nbegin"], ["", "text \\<open>Very important lemma preparing the application of the Zorn's lemma. It states that in a compact logic, we can not deduce \\<open>\\<phi>\\<close>\nif we accumulate an infinity of hypothesis groups which locally do not deduce phi\\<close>"], ["", "lemma chain_closure: \\<open>\\<not> \\<tturnstile> \\<phi> \\<Longrightarrow> subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C \\<Longrightarrow> \\<not> \\<Union>C \\<turnstile> \\<phi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<tturnstile> \\<phi>;\n     subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C\\<rbrakk>\n    \\<Longrightarrow> \\<not> \\<Union> C \\<turnstile> \\<phi>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<tturnstile> \\<phi>;\n     subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C;\n     \\<Union> C \\<turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> False", "assume a:\\<open>subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C\\<close> and b:\\<open>\\<not> \\<tturnstile> \\<phi>\\<close> and \\<open>\\<Union> C \\<turnstile> \\<phi>\\<close>"], ["proof (state)\nthis:\n  subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C\n  \\<not> \\<tturnstile> \\<phi>\n  \\<Union> C \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<tturnstile> \\<phi>;\n     subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C;\n     \\<Union> C \\<turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C\n  \\<not> \\<tturnstile> \\<phi>\n  \\<Union> C \\<turnstile> \\<phi>", "obtain A' where c:\\<open>A'\\<subseteq> \\<Union> C\\<close> and d:\\<open>finite A'\\<close>  and e:\\<open>A' \\<turnstile> \\<phi>\\<close>"], ["proof (prove)\nusing this:\n  subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C\n  \\<not> \\<tturnstile> \\<phi>\n  \\<Union> C \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. (\\<And>A'.\n        \\<lbrakk>A' \\<subseteq> \\<Union> C; finite A';\n         A' \\<turnstile> \\<phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using compactness_L"], ["proof (prove)\nusing this:\n  subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C\n  \\<not> \\<tturnstile> \\<phi>\n  \\<Union> C \\<turnstile> \\<phi>\n  ?A \\<turnstile> ?\\<phi> \\<Longrightarrow>\n  \\<exists>A'\\<subseteq>?A. finite A' \\<and> A' \\<turnstile> ?\\<phi>\n\ngoal (1 subgoal):\n 1. (\\<And>A'.\n        \\<lbrakk>A' \\<subseteq> \\<Union> C; finite A';\n         A' \\<turnstile> \\<phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A' \\<subseteq> \\<Union> C\n  finite A'\n  A' \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<tturnstile> \\<phi>;\n     subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C;\n     \\<Union> C \\<turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> False", "define f where f:\\<open>f \\<equiv> \\<lambda>a. SOME B. B \\<in> C \\<and> a \\<in> B\\<close>"], ["proof (state)\nthis:\n  f \\<equiv> \\<lambda>a. SOME B. B \\<in> C \\<and> a \\<in> B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<tturnstile> \\<phi>;\n     subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C;\n     \\<Union> C \\<turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> False", "have g:\\<open>finite (f ` A')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (f ` A')", "using f d"], ["proof (prove)\nusing this:\n  f \\<equiv> \\<lambda>a. SOME B. B \\<in> C \\<and> a \\<in> B\n  finite A'\n\ngoal (1 subgoal):\n 1. finite (f ` A')", "by simp"], ["proof (state)\nthis:\n  finite (f ` A')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<tturnstile> \\<phi>;\n     subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C;\n     \\<Union> C \\<turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> False", "have h:\\<open>(f ` A') \\<subseteq> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` A' \\<subseteq> C", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. SOME B. B \\<in> C \\<and> a \\<in> B) ` A' \\<subseteq> C", "by auto (metis (mono_tags, lifting) Union_iff c someI_ex subset_eq)"], ["proof (state)\nthis:\n  f ` A' \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<tturnstile> \\<phi>;\n     subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C;\n     \\<Union> C \\<turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> False", "have i:\\<open>subset.chain {B. \\<not> B \\<turnstile> \\<phi>} (f ` A')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subset.chain {B. \\<not> B \\<turnstile> \\<phi>} (f ` A')", "using a h"], ["proof (prove)\nusing this:\n  subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C\n  f ` A' \\<subseteq> C\n\ngoal (1 subgoal):\n 1. subset.chain {B. \\<not> B \\<turnstile> \\<phi>} (f ` A')", "using a h"], ["proof (prove)\nusing this:\n  subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C\n  f ` A' \\<subseteq> C\n  subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C\n  f ` A' \\<subseteq> C\n\ngoal (1 subgoal):\n 1. subset.chain {B. \\<not> B \\<turnstile> \\<phi>} (f ` A')", "by (meson subsetD subset_chain_def subset_trans)"], ["proof (state)\nthis:\n  subset.chain {B. \\<not> B \\<turnstile> \\<phi>} (f ` A')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<tturnstile> \\<phi>;\n     subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C;\n     \\<Union> C \\<turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> False", "have \\<open>A' \\<noteq> {} \\<Longrightarrow> \\<Union> (f ` A') \\<in> {B. \\<not> B \\<turnstile> \\<phi>}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' \\<noteq> {} \\<Longrightarrow>\n    \\<Union> (f ` A') \\<in> {B. \\<not> B \\<turnstile> \\<phi>}", "using g i"], ["proof (prove)\nusing this:\n  finite (f ` A')\n  subset.chain {B. \\<not> B \\<turnstile> \\<phi>} (f ` A')\n\ngoal (1 subgoal):\n 1. A' \\<noteq> {} \\<Longrightarrow>\n    \\<Union> (f ` A') \\<in> {B. \\<not> B \\<turnstile> \\<phi>}", "by (meson Union_in_chain image_is_empty subset_chain_def subset_eq)"], ["proof (state)\nthis:\n  A' \\<noteq> {} \\<Longrightarrow>\n  \\<Union> (f ` A') \\<in> {B. \\<not> B \\<turnstile> \\<phi>}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<tturnstile> \\<phi>;\n     subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C;\n     \\<Union> C \\<turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> False", "hence j:\\<open>A' \\<noteq> {} \\<Longrightarrow> \\<not> \\<Union>(f ` A') \\<turnstile> \\<phi>\\<close>"], ["proof (prove)\nusing this:\n  A' \\<noteq> {} \\<Longrightarrow>\n  \\<Union> (f ` A') \\<in> {B. \\<not> B \\<turnstile> \\<phi>}\n\ngoal (1 subgoal):\n 1. A' \\<noteq> {} \\<Longrightarrow>\n    \\<not> \\<Union> (f ` A') \\<turnstile> \\<phi>", "by simp"], ["proof (state)\nthis:\n  A' \\<noteq> {} \\<Longrightarrow>\n  \\<not> \\<Union> (f ` A') \\<turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<tturnstile> \\<phi>;\n     subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C;\n     \\<Union> C \\<turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> False", "have \\<open>A' \\<subseteq> \\<Union>(f ` A')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' \\<subseteq> \\<Union> (f ` A')", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' \\<subseteq> (\\<Union>a\\<in>A'. SOME B. B \\<in> C \\<and> a \\<in> B)", "by auto (metis (no_types, lifting) Union_iff c someI_ex subset_iff)"], ["proof (state)\nthis:\n  A' \\<subseteq> \\<Union> (f ` A')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<tturnstile> \\<phi>;\n     subset.chain {B. \\<not> B \\<turnstile> \\<phi>} C;\n     \\<Union> C \\<turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> False", "with j e b"], ["proof (chain)\npicking this:\n  A' \\<noteq> {} \\<Longrightarrow>\n  \\<not> \\<Union> (f ` A') \\<turnstile> \\<phi>\n  A' \\<turnstile> \\<phi>\n  \\<not> \\<tturnstile> \\<phi>\n  A' \\<subseteq> \\<Union> (f ` A')", "show False"], ["proof (prove)\nusing this:\n  A' \\<noteq> {} \\<Longrightarrow>\n  \\<not> \\<Union> (f ` A') \\<turnstile> \\<phi>\n  A' \\<turnstile> \\<phi>\n  \\<not> \\<tturnstile> \\<phi>\n  A' \\<subseteq> \\<Union> (f ` A')\n\ngoal (1 subgoal):\n 1. False", "by (metis infer_def monotonicity_L subsetD valid_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}