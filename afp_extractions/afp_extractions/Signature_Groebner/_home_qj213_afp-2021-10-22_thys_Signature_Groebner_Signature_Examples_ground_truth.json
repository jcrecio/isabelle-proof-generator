{"file_name": "/home/qj213/afp-2021-10-22/thys/Signature_Groebner/Signature_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Signature_Groebner", "problem_names": ["lemma hom_grading_varnum_pp: \"hom_grading (varnum_pp::('a::countable, 'b::add_wellorder) pp \\<Rightarrow> nat)\"", "lemma comparator_proj_comp: \"comparator (proj_comp cmp)\"", "lemma nat_term_comp_proj_comp: \"nat_term_comp (proj_comp cmp)\"", "lemma proj_ord_LEX [code]: \"proj_ord LEX = LEX\"", "lemma proj_ord_DRLEX [code]: \"proj_ord DRLEX = DRLEX\"", "lemma proj_ord_DEG [code]: \"proj_ord (DEG to) = DEG (proj_ord to)\"", "lemma proj_ord_POT [code]: \"proj_ord (POT to) = proj_ord to\"", "lemma compute_adds_term_pprod [code]:\n  \"adds_term_pprod u v = (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))\"", "lemma compute_splus_pprod [code]: \"splus_pprod t (s, i) = (t + s, i)\"", "lemma compute_sig_trd_spp_body_pprod [code]:\n  \"sig_trd_spp_body_pprod to bs v (p, r) =\n    (case find_sig_reducer_pprod to bs v (lt_punit (proj_ord to) p) 0 of\n        None   \\<Rightarrow> (tail_punit (proj_ord to) p, plus_monomial_less r (lc_punit (proj_ord to) p) (lt_punit (proj_ord to) p))\n      | Some i \\<Rightarrow> let b = snd (bs ! i) in\n          (tail_punit (proj_ord to) p - monom_mult_punit (lc_punit (proj_ord to) p / lc_punit (proj_ord to) b)\n              (lt_punit (proj_ord to) p - lt_punit (proj_ord to) b) (tail_punit (proj_ord to) b), r))\"", "lemma compute_sig_trd_spp_pprod [code]:\n  \"sig_trd_spp_pprod to bs (v, p) \\<equiv> (v, sig_trd_spp_aux_pprod to bs v (p, change_ord (proj_ord to) 0))\"", "lemmas [code] = conversep_iff", "lemma compute_is_pot_ord [code]:\n  \"is_pot_ord_pprod (LEX::(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order) = False\"\n    (is \"is_pot_ord_pprod ?lex = _\")\n  \"is_pot_ord_pprod (DRLEX::(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order) = False\"\n    (is \"is_pot_ord_pprod ?drlex = _\")\n  \"is_pot_ord_pprod (DEG (to::(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order)) = False\"\n  \"is_pot_ord_pprod (POT (to::(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order)) = True\"", "lemma snd_gb_sig_z_pprod'_eq_gb_sig_z_pprod:\n  \"snd (gb_sig_z_pprod' to (rword_strict to) fs) = snd (gb_sig_z_pprod to rword_strict fs)\"", "lemma gb_sig_pprod'_eq_gb_sig_pprod:\n  \"gb_sig_pprod' to (rword_strict to) fs = gb_sig_pprod to rword_strict fs\"", "lemma\n  \"gb_sig_pprod DRLEX rw_rat_strict_pprod [X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y, X * Y * Z + 2 * Y\\<^sup>2] =\n    [C\\<^sub>0 (3 / 4) * X ^ 3 * Y\\<^sup>2 - 2 * Y ^ 4, - 4 * Y ^ 3 * Z - 3 * X\\<^sup>2 * Y\\<^sup>2, X * Y * Z + 2 * Y\\<^sup>2, X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y]\"", "lemma\n  \"gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod ((cyclic DRLEX 6)::(_ \\<Rightarrow>\\<^sub>0 rat) list) = (155, 8)\"", "lemma\n  \"gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod ((katsura DRLEX 5)::(_ \\<Rightarrow>\\<^sub>0 rat) list) = (29, 0)\"", "lemma\n  \"gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod ((eco DRLEX 8)::(_ \\<Rightarrow>\\<^sub>0 rat) list) = (76, 0)\"", "lemma\n  \"gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod ((noon DRLEX 5)::(_ \\<Rightarrow>\\<^sub>0 rat) list) = (83, 0)\""], "translations": [["", "lemma hom_grading_varnum_pp: \"hom_grading (varnum_pp::('a::countable, 'b::add_wellorder) pp \\<Rightarrow> nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_grading varnum_pp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom_grading varnum_pp", "define f where \"f = (\\<lambda>n t. (except_pp t (- {x. elem_index x < n}))::('a, 'b) pp)\""], ["proof (state)\nthis:\n  f = (\\<lambda>n t. except_pp t (- {x. elem_index x < n}))\n\ngoal (1 subgoal):\n 1. hom_grading varnum_pp", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_grading varnum_pp", "unfolding hom_grading_def hom_grading_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>n.\n          (\\<forall>s t. f n (s + t) = f n s + f n t) \\<and>\n          (\\<forall>t.\n              varnum_pp (f n t) \\<le> n \\<and>\n              (varnum_pp t \\<le> n \\<longrightarrow> f n t = t))", "proof (intro exI allI conjI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n s t. ?f n (s + t) = ?f n s + ?f n t\n 2. \\<And>n t. varnum_pp (?f n t) \\<le> n\n 3. \\<And>n t. varnum_pp t \\<le> n \\<Longrightarrow> ?f n t = t", "fix n s t"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n s t. ?f n (s + t) = ?f n s + ?f n t\n 2. \\<And>n t. varnum_pp (?f n t) \\<le> n\n 3. \\<And>n t. varnum_pp t \\<le> n \\<Longrightarrow> ?f n t = t", "show \"f n (s + t) = f n s + f n t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f n (s + t) = f n s + f n t", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. except_pp (s + t) (- {x. elem_index x < n}) =\n    except_pp s (- {x. elem_index x < n}) +\n    except_pp t (- {x. elem_index x < n})", "by transfer (rule except_plus)"], ["proof (state)\nthis:\n  f n (s + t) = f n s + f n t\n\ngoal (2 subgoals):\n 1. \\<And>n t. varnum_pp (f (?n13 n t) t) \\<le> n\n 2. \\<And>n t. varnum_pp t \\<le> n \\<Longrightarrow> f (?n13 n t) t = t\nflex-flex pairs:\n  \\<lambda>n s. ?n13 n \\<equiv>\\<^sup>? \\<lambda>n s t. ?n13 n (s + t)\n  \\<lambda>n s t. ?n13 n s \\<equiv>\\<^sup>? \\<lambda>n s t. ?n13 n (s + t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n t. varnum_pp (f (?n13 n t) t) \\<le> n\n 2. \\<And>n t. varnum_pp t \\<le> n \\<Longrightarrow> f (?n13 n t) t = t\nflex-flex pairs:\n  \\<lambda>n s. ?n13 n \\<equiv>\\<^sup>? \\<lambda>n s t. ?n13 n (s + t)\n  \\<lambda>n s t. ?n13 n s \\<equiv>\\<^sup>? \\<lambda>n s t. ?n13 n (s + t)", "fix n t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n t. varnum_pp (f (?n13 n t) t) \\<le> n\n 2. \\<And>n t. varnum_pp t \\<le> n \\<Longrightarrow> f (?n13 n t) t = t\nflex-flex pairs:\n  \\<lambda>n s. ?n13 n \\<equiv>\\<^sup>? \\<lambda>n s t. ?n13 n (s + t)\n  \\<lambda>n s t. ?n13 n s \\<equiv>\\<^sup>? \\<lambda>n s t. ?n13 n (s + t)", "show \"varnum_pp (f n t) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. varnum_pp (f n t) \\<le> n", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. varnum_pp (except_pp t (- {x. elem_index x < n})) \\<le> n", "by transfer (simp add: varnum_le_iff keys_except)"], ["proof (state)\nthis:\n  varnum_pp (f n t) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>n t. varnum_pp t \\<le> n \\<Longrightarrow> f n t = t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n t. varnum_pp t \\<le> n \\<Longrightarrow> f n t = t", "fix n t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n t. varnum_pp t \\<le> n \\<Longrightarrow> f n t = t", "show \"varnum_pp t \\<le> n \\<Longrightarrow> f n t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. varnum_pp t \\<le> n \\<Longrightarrow> f n t = t", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. varnum_pp t \\<le> n \\<Longrightarrow>\n    except_pp t (- {x. elem_index x < n}) = t", "by transfer (auto simp: except_id_iff varnum_le_iff)"], ["proof (state)\nthis:\n  varnum_pp t \\<le> n \\<Longrightarrow> f n t = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hom_grading varnum_pp\n\ngoal:\nNo subgoals!", "qed"], ["", "instance pp :: (countable, add_wellorder) quasi_pm_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) pp, quasi_pm_powerprod_class)", "by (standard, intro exI conjI, fact dickson_grading_varnum_pp, fact hom_grading_varnum_pp)"], ["", "subsubsection \\<open>Projections of Term Orders to Orders on Power-Products\\<close>"], ["", "definition proj_comp :: \"(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> ('a, 'b) pp \\<Rightarrow> order\"\n  where \"proj_comp cmp = (\\<lambda>x y. nat_term_compare cmp (x, 0) (y, 0))\""], ["", "definition proj_ord :: \"(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order \\<Rightarrow> ('a, 'b) pp nat_term_order\"\n  where \"proj_ord cmp = Abs_nat_term_order (proj_comp cmp)\""], ["", "text \\<open>In principle, @{const proj_comp} and @{const proj_ord} could be defined more generally on type\n  @{typ \"'a \\<times> nat\"}, but then @{typ 'a} would have to belong to some new type-class which is the\n  intersection of @{class nat_pp_term} and @{class nat_pp_compare} and additionally requires\n  @{prop \"rep_nat_term x = (rep_nat_pp x, 0)\"}.\\<close>"], ["", "lemma comparator_proj_comp: \"comparator (proj_comp cmp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (proj_comp cmp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comparator (proj_comp cmp)", "interpret cmp: comparator \"nat_term_compare cmp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (nat_term_compare cmp)", "by (rule comparator_nat_term_compare)"], ["proof (state)\ngoal (1 subgoal):\n 1. comparator (proj_comp cmp)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (proj_comp cmp)", "unfolding proj_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. nat_term_compare cmp (x, 0) (y, 0))", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       invert_order (nat_term_compare cmp (x, 0) (y, 0)) =\n       nat_term_compare cmp (y, 0) (x, 0)\n 2. \\<And>x y.\n       nat_term_compare cmp (x, 0) (y, 0) = Eq \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>nat_term_compare cmp (x, 0) (y, 0) = Lt;\n        nat_term_compare cmp (y, 0) (z, 0) = Lt\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare cmp (x, 0) (z, 0) = Lt", "fix x y :: \"('a, 'b) pp\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       invert_order (nat_term_compare cmp (x, 0) (y, 0)) =\n       nat_term_compare cmp (y, 0) (x, 0)\n 2. \\<And>x y.\n       nat_term_compare cmp (x, 0) (y, 0) = Eq \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>nat_term_compare cmp (x, 0) (y, 0) = Lt;\n        nat_term_compare cmp (y, 0) (z, 0) = Lt\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare cmp (x, 0) (z, 0) = Lt", "show \"invert_order (nat_term_compare cmp (x, 0) (y, 0)) = nat_term_compare cmp (y, 0) (x, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invert_order (nat_term_compare cmp (x, 0) (y, 0)) =\n    nat_term_compare cmp (y, 0) (x, 0)", "by (simp only: cmp.sym)"], ["proof (state)\nthis:\n  invert_order (nat_term_compare cmp (x, 0) (y, 0)) =\n  nat_term_compare cmp (y, 0) (x, 0)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       nat_term_compare cmp (x, 0) (y, 0) = Eq \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>nat_term_compare cmp (x, 0) (y, 0) = Lt;\n        nat_term_compare cmp (y, 0) (z, 0) = Lt\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare cmp (x, 0) (z, 0) = Lt", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       nat_term_compare cmp (x, 0) (y, 0) = Eq \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>nat_term_compare cmp (x, 0) (y, 0) = Lt;\n        nat_term_compare cmp (y, 0) (z, 0) = Lt\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare cmp (x, 0) (z, 0) = Lt", "fix x y :: \"('a, 'b) pp\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       nat_term_compare cmp (x, 0) (y, 0) = Eq \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>nat_term_compare cmp (x, 0) (y, 0) = Lt;\n        nat_term_compare cmp (y, 0) (z, 0) = Lt\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare cmp (x, 0) (z, 0) = Lt", "assume \"nat_term_compare cmp (x, 0) (y, 0) = Eq\""], ["proof (state)\nthis:\n  nat_term_compare cmp (x, 0) (y, 0) = Eq\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       nat_term_compare cmp (x, 0) (y, 0) = Eq \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>nat_term_compare cmp (x, 0) (y, 0) = Lt;\n        nat_term_compare cmp (y, 0) (z, 0) = Lt\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare cmp (x, 0) (z, 0) = Lt", "hence \"(x, 0) = (y, 0::nat)\""], ["proof (prove)\nusing this:\n  nat_term_compare cmp (x, 0) (y, 0) = Eq\n\ngoal (1 subgoal):\n 1. (x, 0) = (y, 0)", "by (rule cmp.weak_eq)"], ["proof (state)\nthis:\n  (x, 0) = (y, 0)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       nat_term_compare cmp (x, 0) (y, 0) = Eq \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>nat_term_compare cmp (x, 0) (y, 0) = Lt;\n        nat_term_compare cmp (y, 0) (z, 0) = Lt\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare cmp (x, 0) (z, 0) = Lt", "thus \"x = y\""], ["proof (prove)\nusing this:\n  (x, 0) = (y, 0)\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>nat_term_compare cmp (x, 0) (y, 0) = Lt;\n        nat_term_compare cmp (y, 0) (z, 0) = Lt\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare cmp (x, 0) (z, 0) = Lt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>nat_term_compare cmp (x, 0) (y, 0) = Lt;\n        nat_term_compare cmp (y, 0) (z, 0) = Lt\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare cmp (x, 0) (z, 0) = Lt", "fix x y z :: \"('a, 'b) pp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>nat_term_compare cmp (x, 0) (y, 0) = Lt;\n        nat_term_compare cmp (y, 0) (z, 0) = Lt\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare cmp (x, 0) (z, 0) = Lt", "assume \"nat_term_compare cmp (x, 0) (y, 0) = Lt\" and \"nat_term_compare cmp (y, 0) (z, 0) = Lt\""], ["proof (state)\nthis:\n  nat_term_compare cmp (x, 0) (y, 0) = Lt\n  nat_term_compare cmp (y, 0) (z, 0) = Lt\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>nat_term_compare cmp (x, 0) (y, 0) = Lt;\n        nat_term_compare cmp (y, 0) (z, 0) = Lt\\<rbrakk>\n       \\<Longrightarrow> nat_term_compare cmp (x, 0) (z, 0) = Lt", "thus \"nat_term_compare cmp (x, 0) (z, 0) = Lt\""], ["proof (prove)\nusing this:\n  nat_term_compare cmp (x, 0) (y, 0) = Lt\n  nat_term_compare cmp (y, 0) (z, 0) = Lt\n\ngoal (1 subgoal):\n 1. nat_term_compare cmp (x, 0) (z, 0) = Lt", "by (rule cmp.trans)"], ["proof (state)\nthis:\n  nat_term_compare cmp (x, 0) (z, 0) = Lt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comparator (proj_comp cmp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_term_comp_proj_comp: \"nat_term_comp (proj_comp cmp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_comp (proj_comp cmp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_term_comp (proj_comp cmp)", "have 1: \"fst (rep_nat_term (u, i)) = rep_nat_pp u\" for u::\"('a, 'b) pp\" and i::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (rep_nat_term (u, i)) = rep_nat_pp u", "by (simp add: rep_nat_term_prod_def)"], ["proof (state)\nthis:\n  fst (rep_nat_term (?u, ?i)) = rep_nat_pp ?u\n\ngoal (1 subgoal):\n 1. nat_term_comp (proj_comp cmp)", "have 2: \"snd (rep_nat_term (u, i)) = i\" for u::\"('a, 'b) pp\" and i::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rep_nat_term (u, i)) = i", "by (simp add: rep_nat_term_prod_def rep_nat_nat_def)"], ["proof (state)\nthis:\n  snd (rep_nat_term (?u, ?i)) = ?i\n\ngoal (1 subgoal):\n 1. nat_term_comp (proj_comp cmp)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_comp (proj_comp cmp)", "proof (rule nat_term_compI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 3. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "fix u v :: \"('a, 'b) pp\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 3. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "assume a: \"fst (rep_nat_term u) = 0\""], ["proof (state)\nthis:\n  fst (rep_nat_term u) = 0\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 3. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "note nat_term_comp_nat_term_compare"], ["proof (state)\nthis:\n  nat_term_comp (nat_term_compare ?to)\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 3. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "moreover"], ["proof (state)\nthis:\n  nat_term_comp (nat_term_compare ?to)\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 3. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "have \"snd (rep_nat_term (u, 0::nat)) = snd (rep_nat_term (v, 0::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rep_nat_term (u, 0)) = snd (rep_nat_term (v, 0))", "by (simp only: 2)"], ["proof (state)\nthis:\n  snd (rep_nat_term (u, 0)) = snd (rep_nat_term (v, 0))\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 3. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "moreover"], ["proof (state)\nthis:\n  snd (rep_nat_term (u, 0)) = snd (rep_nat_term (v, 0))\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 3. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "from a"], ["proof (chain)\npicking this:\n  fst (rep_nat_term u) = 0", "have \"fst (rep_nat_term (u, 0::nat)) = 0\""], ["proof (prove)\nusing this:\n  fst (rep_nat_term u) = 0\n\ngoal (1 subgoal):\n 1. fst (rep_nat_term (u, 0)) = 0", "by (simp add: 1 rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  fst (rep_nat_term (u, 0)) = 0\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 3. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "ultimately"], ["proof (chain)\npicking this:\n  nat_term_comp (nat_term_compare ?to)\n  snd (rep_nat_term (u, 0)) = snd (rep_nat_term (v, 0))\n  fst (rep_nat_term (u, 0)) = 0", "have \"nat_term_compare cmp (u, 0) (v, 0) \\<noteq> Gt\""], ["proof (prove)\nusing this:\n  nat_term_comp (nat_term_compare ?to)\n  snd (rep_nat_term (u, 0)) = snd (rep_nat_term (v, 0))\n  fst (rep_nat_term (u, 0)) = 0\n\ngoal (1 subgoal):\n 1. nat_term_compare cmp (u, 0) (v, 0) \\<noteq> Gt", "by (rule nat_term_compD1)"], ["proof (state)\nthis:\n  nat_term_compare cmp (u, 0) (v, 0) \\<noteq> Gt\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>snd (rep_nat_term u) = snd (rep_nat_term v);\n        fst (rep_nat_term u) = 0\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v \\<noteq> Gt\n 2. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 3. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 4. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "thus \"proj_comp cmp u v \\<noteq> Gt\""], ["proof (prove)\nusing this:\n  nat_term_compare cmp (u, 0) (v, 0) \\<noteq> Gt\n\ngoal (1 subgoal):\n 1. proj_comp cmp u v \\<noteq> Gt", "by (simp add: proj_comp_def)"], ["proof (state)\nthis:\n  proj_comp cmp u v \\<noteq> Gt\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 2. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 2. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "fix u v :: \"('a, 'b) pp\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 2. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "assume \"snd (rep_nat_term u) < snd (rep_nat_term v)\""], ["proof (state)\nthis:\n  snd (rep_nat_term u) < snd (rep_nat_term v)\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term v);\n        snd (rep_nat_term u) < snd (rep_nat_term v)\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt\n 2. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 3. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "thus \"proj_comp cmp u v = Lt\""], ["proof (prove)\nusing this:\n  snd (rep_nat_term u) < snd (rep_nat_term v)\n\ngoal (1 subgoal):\n 1. proj_comp cmp u v = Lt", "by (simp add: rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  proj_comp cmp u v = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "fix t u v :: \"('a, 'b) pp\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "assume \"proj_comp cmp u v = Lt\""], ["proof (state)\nthis:\n  proj_comp cmp u v = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "hence \"nat_term_compare cmp (u, 0) (v, 0) = Lt\""], ["proof (prove)\nusing this:\n  proj_comp cmp u v = Lt\n\ngoal (1 subgoal):\n 1. nat_term_compare cmp (u, 0) (v, 0) = Lt", "by (simp add: proj_comp_def)"], ["proof (state)\nthis:\n  nat_term_compare cmp (u, 0) (v, 0) = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "with nat_term_comp_nat_term_compare"], ["proof (chain)\npicking this:\n  nat_term_comp (nat_term_compare ?to)\n  nat_term_compare cmp (u, 0) (v, 0) = Lt", "have \"nat_term_compare cmp (splus (t, 0) (u, 0)) (splus (t, 0) (v, 0)) = Lt\""], ["proof (prove)\nusing this:\n  nat_term_comp (nat_term_compare ?to)\n  nat_term_compare cmp (u, 0) (v, 0) = Lt\n\ngoal (1 subgoal):\n 1. nat_term_compare cmp (splus (t, 0) (u, 0)) (splus (t, 0) (v, 0)) = Lt", "by (rule nat_term_compD3)"], ["proof (state)\nthis:\n  nat_term_compare cmp (splus (t, 0) (u, 0)) (splus (t, 0) (v, 0)) = Lt\n\ngoal (2 subgoals):\n 1. \\<And>t u v.\n       proj_comp cmp u v = Lt \\<Longrightarrow>\n       proj_comp cmp (splus t u) (splus t v) = Lt\n 2. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "thus \"proj_comp cmp (splus t u) (splus t v) = Lt\""], ["proof (prove)\nusing this:\n  nat_term_compare cmp (splus (t, 0) (u, 0)) (splus (t, 0) (v, 0)) = Lt\n\ngoal (1 subgoal):\n 1. proj_comp cmp (splus t u) (splus t v) = Lt", "by (simp add: proj_comp_def splus_prod_def pprod.splus_def splus_pp_term)"], ["proof (state)\nthis:\n  proj_comp cmp (splus t u) (splus t v) = Lt\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "fix u v a b :: \"('a, 'b) pp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "assume u: \"fst (rep_nat_term u) = fst (rep_nat_term a)\" and v: \"fst (rep_nat_term v) = fst (rep_nat_term b)\"\n      and a: \"proj_comp cmp a b = Lt\""], ["proof (state)\nthis:\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n  proj_comp cmp a b = Lt\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "note nat_term_comp_nat_term_compare"], ["proof (state)\nthis:\n  nat_term_comp (nat_term_compare ?to)\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "moreover"], ["proof (state)\nthis:\n  nat_term_comp (nat_term_compare ?to)\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "from u"], ["proof (chain)\npicking this:\n  fst (rep_nat_term u) = fst (rep_nat_term a)", "have \"fst (rep_nat_term (u, 0::nat)) = fst (rep_nat_term (a, 0::nat))\""], ["proof (prove)\nusing this:\n  fst (rep_nat_term u) = fst (rep_nat_term a)\n\ngoal (1 subgoal):\n 1. fst (rep_nat_term (u, 0)) = fst (rep_nat_term (a, 0))", "by (simp add: 1 rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  fst (rep_nat_term (u, 0)) = fst (rep_nat_term (a, 0))\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "moreover"], ["proof (state)\nthis:\n  fst (rep_nat_term (u, 0)) = fst (rep_nat_term (a, 0))\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "from v"], ["proof (chain)\npicking this:\n  fst (rep_nat_term v) = fst (rep_nat_term b)", "have \"fst (rep_nat_term (v, 0::nat)) = fst (rep_nat_term (b, 0::nat))\""], ["proof (prove)\nusing this:\n  fst (rep_nat_term v) = fst (rep_nat_term b)\n\ngoal (1 subgoal):\n 1. fst (rep_nat_term (v, 0)) = fst (rep_nat_term (b, 0))", "by (simp add: 1 rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  fst (rep_nat_term (v, 0)) = fst (rep_nat_term (b, 0))\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "moreover"], ["proof (state)\nthis:\n  fst (rep_nat_term (v, 0)) = fst (rep_nat_term (b, 0))\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "have \"snd (rep_nat_term (u, 0::nat)) = snd (rep_nat_term (v, 0::nat))\"\n      and \"snd (rep_nat_term (a, 0::nat)) = snd (rep_nat_term (b, 0::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rep_nat_term (u, 0)) = snd (rep_nat_term (v, 0)) &&&\n    snd (rep_nat_term (a, 0)) = snd (rep_nat_term (b, 0))", "by (simp_all only: 2)"], ["proof (state)\nthis:\n  snd (rep_nat_term (u, 0)) = snd (rep_nat_term (v, 0))\n  snd (rep_nat_term (a, 0)) = snd (rep_nat_term (b, 0))\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "moreover"], ["proof (state)\nthis:\n  snd (rep_nat_term (u, 0)) = snd (rep_nat_term (v, 0))\n  snd (rep_nat_term (a, 0)) = snd (rep_nat_term (b, 0))\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "from a"], ["proof (chain)\npicking this:\n  proj_comp cmp a b = Lt", "have \"nat_term_compare cmp (a, 0) (b, 0) = Lt\""], ["proof (prove)\nusing this:\n  proj_comp cmp a b = Lt\n\ngoal (1 subgoal):\n 1. nat_term_compare cmp (a, 0) (b, 0) = Lt", "by (simp add: proj_comp_def)"], ["proof (state)\nthis:\n  nat_term_compare cmp (a, 0) (b, 0) = Lt\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "ultimately"], ["proof (chain)\npicking this:\n  nat_term_comp (nat_term_compare ?to)\n  fst (rep_nat_term (u, 0)) = fst (rep_nat_term (a, 0))\n  fst (rep_nat_term (v, 0)) = fst (rep_nat_term (b, 0))\n  snd (rep_nat_term (u, 0)) = snd (rep_nat_term (v, 0))\n  snd (rep_nat_term (a, 0)) = snd (rep_nat_term (b, 0))\n  nat_term_compare cmp (a, 0) (b, 0) = Lt", "have \"nat_term_compare cmp (u, 0) (v, 0) = Lt\""], ["proof (prove)\nusing this:\n  nat_term_comp (nat_term_compare ?to)\n  fst (rep_nat_term (u, 0)) = fst (rep_nat_term (a, 0))\n  fst (rep_nat_term (v, 0)) = fst (rep_nat_term (b, 0))\n  snd (rep_nat_term (u, 0)) = snd (rep_nat_term (v, 0))\n  snd (rep_nat_term (a, 0)) = snd (rep_nat_term (b, 0))\n  nat_term_compare cmp (a, 0) (b, 0) = Lt\n\ngoal (1 subgoal):\n 1. nat_term_compare cmp (u, 0) (v, 0) = Lt", "by (rule nat_term_compD4)"], ["proof (state)\nthis:\n  nat_term_compare cmp (u, 0) (v, 0) = Lt\n\ngoal (1 subgoal):\n 1. \\<And>u v a b.\n       \\<lbrakk>fst (rep_nat_term u) = fst (rep_nat_term a);\n        fst (rep_nat_term v) = fst (rep_nat_term b);\n        snd (rep_nat_term u) = snd (rep_nat_term v);\n        snd (rep_nat_term a) = snd (rep_nat_term b);\n        proj_comp cmp a b = Lt\\<rbrakk>\n       \\<Longrightarrow> proj_comp cmp u v = Lt", "thus \"proj_comp cmp u v = Lt\""], ["proof (prove)\nusing this:\n  nat_term_compare cmp (u, 0) (v, 0) = Lt\n\ngoal (1 subgoal):\n 1. proj_comp cmp u v = Lt", "by (simp add: proj_comp_def)"], ["proof (state)\nthis:\n  proj_comp cmp u v = Lt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_term_comp (proj_comp cmp)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary nat_term_compare_proj_ord: \"nat_term_compare (proj_ord cmp) = proj_comp cmp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (proj_ord cmp) = proj_comp cmp", "unfolding proj_ord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (Abs_nat_term_order (proj_comp cmp)) = proj_comp cmp", "using comparator_proj_comp nat_term_comp_proj_comp"], ["proof (prove)\nusing this:\n  comparator (proj_comp ?cmp)\n  nat_term_comp (proj_comp ?cmp)\n\ngoal (1 subgoal):\n 1. nat_term_compare (Abs_nat_term_order (proj_comp cmp)) = proj_comp cmp", "by (rule nat_term_compare_Abs_nat_term_order_id)"], ["", "lemma proj_ord_LEX [code]: \"proj_ord LEX = LEX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_ord Term_Order.LEX = Term_Order.LEX", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_ord Term_Order.LEX = Term_Order.LEX", "have \"nat_term_compare (proj_ord LEX) = nat_term_compare LEX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (proj_ord Term_Order.LEX) =\n    nat_term_compare Term_Order.LEX", "by (auto simp: nat_term_compare_proj_ord nat_term_compare_LEX proj_comp_def lex_comp\n        lex_comp_aux_def rep_nat_term_prod_def rep_nat_term_pp_def intro!: ext split: order.split)"], ["proof (state)\nthis:\n  nat_term_compare (proj_ord Term_Order.LEX) =\n  nat_term_compare Term_Order.LEX\n\ngoal (1 subgoal):\n 1. proj_ord Term_Order.LEX = Term_Order.LEX", "thus ?thesis"], ["proof (prove)\nusing this:\n  nat_term_compare (proj_ord Term_Order.LEX) =\n  nat_term_compare Term_Order.LEX\n\ngoal (1 subgoal):\n 1. proj_ord Term_Order.LEX = Term_Order.LEX", "by (simp only: nat_term_compare_inject)"], ["proof (state)\nthis:\n  proj_ord Term_Order.LEX = Term_Order.LEX\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_ord_DRLEX [code]: \"proj_ord DRLEX = DRLEX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_ord DRLEX = DRLEX", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_ord DRLEX = DRLEX", "have \"nat_term_compare (proj_ord DRLEX) = nat_term_compare DRLEX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (proj_ord DRLEX) = nat_term_compare DRLEX", "by (auto simp: nat_term_compare_proj_ord nat_term_compare_DRLEX proj_comp_def deg_comp pot_comp\n        lex_comp lex_comp_aux_def rep_nat_term_prod_def rep_nat_term_pp_def intro!: ext split: order.split)"], ["proof (state)\nthis:\n  nat_term_compare (proj_ord DRLEX) = nat_term_compare DRLEX\n\ngoal (1 subgoal):\n 1. proj_ord DRLEX = DRLEX", "thus ?thesis"], ["proof (prove)\nusing this:\n  nat_term_compare (proj_ord DRLEX) = nat_term_compare DRLEX\n\ngoal (1 subgoal):\n 1. proj_ord DRLEX = DRLEX", "by (simp only: nat_term_compare_inject)"], ["proof (state)\nthis:\n  proj_ord DRLEX = DRLEX\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_ord_DEG [code]: \"proj_ord (DEG to) = DEG (proj_ord to)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_ord (DEG to) = DEG (proj_ord to)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_ord (DEG to) = DEG (proj_ord to)", "have \"nat_term_compare (proj_ord (DEG to)) = nat_term_compare (DEG (proj_ord to))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (proj_ord (DEG to)) =\n    nat_term_compare (DEG (proj_ord to))", "by (simp add: nat_term_compare_proj_ord nat_term_compare_DEG proj_comp_def deg_comp\n        rep_nat_term_prod_def rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  nat_term_compare (proj_ord (DEG to)) =\n  nat_term_compare (DEG (proj_ord to))\n\ngoal (1 subgoal):\n 1. proj_ord (DEG to) = DEG (proj_ord to)", "thus ?thesis"], ["proof (prove)\nusing this:\n  nat_term_compare (proj_ord (DEG to)) =\n  nat_term_compare (DEG (proj_ord to))\n\ngoal (1 subgoal):\n 1. proj_ord (DEG to) = DEG (proj_ord to)", "by (simp only: nat_term_compare_inject)"], ["proof (state)\nthis:\n  proj_ord (DEG to) = DEG (proj_ord to)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_ord_POT [code]: \"proj_ord (POT to) = proj_ord to\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_ord (POT to) = proj_ord to", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_ord (POT to) = proj_ord to", "have \"nat_term_compare (proj_ord (POT to)) = nat_term_compare (proj_ord to)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_term_compare (proj_ord (POT to)) = nat_term_compare (proj_ord to)", "by (simp add: nat_term_compare_proj_ord nat_term_compare_POT proj_comp_def pot_comp\n        rep_nat_term_prod_def rep_nat_term_pp_def)"], ["proof (state)\nthis:\n  nat_term_compare (proj_ord (POT to)) = nat_term_compare (proj_ord to)\n\ngoal (1 subgoal):\n 1. proj_ord (POT to) = proj_ord to", "thus ?thesis"], ["proof (prove)\nusing this:\n  nat_term_compare (proj_ord (POT to)) = nat_term_compare (proj_ord to)\n\ngoal (1 subgoal):\n 1. proj_ord (POT to) = proj_ord to", "by (simp only: nat_term_compare_inject)"], ["proof (state)\nthis:\n  proj_ord (POT to) = proj_ord to\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Locale Interpretation\\<close>"], ["", "locale qpm_nat_inf_term = gd_nat_term \"\\<lambda>x. x\" \"\\<lambda>x. x\" to\n  for to::\"(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order\"\nbegin"], ["", "sublocale aux: qpm_inf_term \"\\<lambda>x. x\" \"\\<lambda>x. x\"\n        \"le_of_nat_term_order (proj_ord to)\"\n        \"lt_of_nat_term_order (proj_ord to)\"\n        \"le_of_nat_term_order to\"\n        \"lt_of_nat_term_order to\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qpm_inf_term (\\<lambda>x. x) (\\<lambda>x. x)\n     (le_of_nat_term_order (proj_ord to))\n     (lt_of_nat_term_order (proj_ord to)) (le_of_nat_term_order to)\n     (lt_of_nat_term_order to)", "proof intro_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. ordered_powerprod_axioms (le_of_nat_term_order (proj_ord to))\n 2. ordered_term_axioms (\\<lambda>x. x) (\\<lambda>x. x)\n     (le_of_nat_term_order (proj_ord to)) (le_of_nat_term_order to)", "(*\n  show \"class.preorder (le_of_nat_term_order (proj_ord to)) (lt_of_nat_term_order (proj_ord to))\"\n    and \"class.order_axioms (le_of_nat_term_order (proj_ord to))\"\n    and \"class.linorder_axioms (le_of_nat_term_order (proj_ord to))\"\n    using linorder_le_of_nat_term_order[of \"proj_ord to\"] by (simp_all add: class.linorder_def class.order_def)\nnext*)"], ["proof (state)\ngoal (2 subgoals):\n 1. ordered_powerprod_axioms (le_of_nat_term_order (proj_ord to))\n 2. ordered_term_axioms (\\<lambda>x. x) (\\<lambda>x. x)\n     (le_of_nat_term_order (proj_ord to)) (le_of_nat_term_order to)", "show \"ordered_powerprod_axioms (le_of_nat_term_order (proj_ord to))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_powerprod_axioms (le_of_nat_term_order (proj_ord to))", "by (unfold_locales, fact le_of_nat_term_order_zero_min, auto dest: le_of_nat_term_order_plus_monotone simp: ac_simps)"], ["proof (state)\nthis:\n  ordered_powerprod_axioms (le_of_nat_term_order (proj_ord to))\n\ngoal (1 subgoal):\n 1. ordered_term_axioms (\\<lambda>x. x) (\\<lambda>x. x)\n     (le_of_nat_term_order (proj_ord to)) (le_of_nat_term_order to)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ordered_term_axioms (\\<lambda>x. x) (\\<lambda>x. x)\n     (le_of_nat_term_order (proj_ord to)) (le_of_nat_term_order to)", "show \"ordered_term_axioms (\\<lambda>x. x) (\\<lambda>x. x) (le_of_nat_term_order (proj_ord to)) (le_of_nat_term_order to)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term_axioms (\\<lambda>x. x) (\\<lambda>x. x)\n     (le_of_nat_term_order (proj_ord to)) (le_of_nat_term_order to)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v w t.\n       le_of_nat_term_order to v w \\<Longrightarrow>\n       le_of_nat_term_order to (local.splus t v) (local.splus t w)\n 2. \\<And>v w.\n       \\<lbrakk>le_of_nat_term_order (proj_ord to) (pp_of_term v)\n                 (pp_of_term w);\n        component_of_term v \\<le> component_of_term w\\<rbrakk>\n       \\<Longrightarrow> le_of_nat_term_order to v w", "fix v w t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v w t.\n       le_of_nat_term_order to v w \\<Longrightarrow>\n       le_of_nat_term_order to (local.splus t v) (local.splus t w)\n 2. \\<And>v w.\n       \\<lbrakk>le_of_nat_term_order (proj_ord to) (pp_of_term v)\n                 (pp_of_term w);\n        component_of_term v \\<le> component_of_term w\\<rbrakk>\n       \\<Longrightarrow> le_of_nat_term_order to v w", "assume \"le_of_nat_term_order to v w\""], ["proof (state)\nthis:\n  le_of_nat_term_order to v w\n\ngoal (2 subgoals):\n 1. \\<And>v w t.\n       le_of_nat_term_order to v w \\<Longrightarrow>\n       le_of_nat_term_order to (local.splus t v) (local.splus t w)\n 2. \\<And>v w.\n       \\<lbrakk>le_of_nat_term_order (proj_ord to) (pp_of_term v)\n                 (pp_of_term w);\n        component_of_term v \\<le> component_of_term w\\<rbrakk>\n       \\<Longrightarrow> le_of_nat_term_order to v w", "thus \"le_of_nat_term_order to (local.splus t v) (local.splus t w)\""], ["proof (prove)\nusing this:\n  le_of_nat_term_order to v w\n\ngoal (1 subgoal):\n 1. le_of_nat_term_order to (local.splus t v) (local.splus t w)", "by (simp add: le_of_nat_term_order nat_term_compare_splus splus_eq_splus)"], ["proof (state)\nthis:\n  le_of_nat_term_order to (local.splus t v) (local.splus t w)\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>le_of_nat_term_order (proj_ord to) (pp_of_term v)\n                 (pp_of_term w);\n        component_of_term v \\<le> component_of_term w\\<rbrakk>\n       \\<Longrightarrow> le_of_nat_term_order to v w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>le_of_nat_term_order (proj_ord to) (pp_of_term v)\n                 (pp_of_term w);\n        component_of_term v \\<le> component_of_term w\\<rbrakk>\n       \\<Longrightarrow> le_of_nat_term_order to v w", "fix v w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>le_of_nat_term_order (proj_ord to) (pp_of_term v)\n                 (pp_of_term w);\n        component_of_term v \\<le> component_of_term w\\<rbrakk>\n       \\<Longrightarrow> le_of_nat_term_order to v w", "assume \"le_of_nat_term_order (proj_ord to) (pp_of_term v) (pp_of_term w)\"\n      and \"component_of_term v \\<le> component_of_term w\""], ["proof (state)\nthis:\n  le_of_nat_term_order (proj_ord to) (pp_of_term v) (pp_of_term w)\n  component_of_term v \\<le> component_of_term w\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>le_of_nat_term_order (proj_ord to) (pp_of_term v)\n                 (pp_of_term w);\n        component_of_term v \\<le> component_of_term w\\<rbrakk>\n       \\<Longrightarrow> le_of_nat_term_order to v w", "hence \"nat_term_compare to (fst v, 0) (fst w, 0) \\<noteq> Gt\" and \"snd v \\<le> snd w\""], ["proof (prove)\nusing this:\n  le_of_nat_term_order (proj_ord to) (pp_of_term v) (pp_of_term w)\n  component_of_term v \\<le> component_of_term w\n\ngoal (1 subgoal):\n 1. nat_term_compare to (fst v, 0) (fst w, 0) \\<noteq> Gt &&&\n    snd v \\<le> snd w", "by (simp_all add: le_of_nat_term_order nat_term_compare_proj_ord proj_comp_def)"], ["proof (state)\nthis:\n  nat_term_compare to (fst v, 0) (fst w, 0) \\<noteq> Gt\n  snd v \\<le> snd w\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>le_of_nat_term_order (proj_ord to) (pp_of_term v)\n                 (pp_of_term w);\n        component_of_term v \\<le> component_of_term w\\<rbrakk>\n       \\<Longrightarrow> le_of_nat_term_order to v w", "from comparator_nat_term_compare nat_term_comp_nat_term_compare _ _ _ _ this(1)"], ["proof (chain)\npicking this:\n  comparator (nat_term_compare ?to)\n  nat_term_comp (nat_term_compare ?to)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  nat_term_compare to (fst v, 0) (fst w, 0) \\<noteq> Gt", "have \"nat_term_compare to v w \\<noteq> Gt\""], ["proof (prove)\nusing this:\n  comparator (nat_term_compare ?to)\n  nat_term_comp (nat_term_compare ?to)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  nat_term_compare to (fst v, 0) (fst w, 0) \\<noteq> Gt\n\ngoal (1 subgoal):\n 1. nat_term_compare to v w \\<noteq> Gt", "by (rule nat_term_compD4'') (simp_all add: rep_nat_term_prod_def ord_iff[symmetric] \\<open>snd v \\<le> snd w\\<close>)"], ["proof (state)\nthis:\n  nat_term_compare to v w \\<noteq> Gt\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>le_of_nat_term_order (proj_ord to) (pp_of_term v)\n                 (pp_of_term w);\n        component_of_term v \\<le> component_of_term w\\<rbrakk>\n       \\<Longrightarrow> le_of_nat_term_order to v w", "thus \"le_of_nat_term_order to v w\""], ["proof (prove)\nusing this:\n  nat_term_compare to v w \\<noteq> Gt\n\ngoal (1 subgoal):\n 1. le_of_nat_term_order to v w", "by (simp add: le_of_nat_term_order)"], ["proof (state)\nthis:\n  le_of_nat_term_order to v w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ordered_term_axioms (\\<lambda>x. x) (\\<lambda>x. x)\n   (le_of_nat_term_order (proj_ord to)) (le_of_nat_term_order to)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>We must define the following two constants outside the global interpretation, since otherwise\n  their types are too general.\\<close>"], ["", "definition splus_pprod :: \"('a::nat, 'b::nat) pp \\<Rightarrow> _\"\n  where \"splus_pprod = pprod.splus\""], ["", "definition adds_term_pprod :: \"(('a::nat, 'b::nat) pp \\<times> _) \\<Rightarrow> _\"\n  where \"adds_term_pprod = pprod.adds_term\""], ["", "global_interpretation pprod': qpm_nat_inf_term to\n  rewrites \"pprod.pp_of_term = fst\"\n  and \"pprod.component_of_term = snd\"\n  and \"pprod.splus = splus_pprod\"\n  and \"pprod.adds_term = adds_term_pprod\"\n  and \"punit.monom_mult = monom_mult_punit\"\n  and \"pprod'.aux.punit.lt = lt_punit (proj_ord to)\"\n  and \"pprod'.aux.punit.lc = lc_punit (proj_ord to)\"\n  and \"pprod'.aux.punit.tail = tail_punit (proj_ord to)\"\n  for to :: \"(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order\"\n  defines max_pprod = pprod'.ord_term_lin.max\n  and Koszul_syz_sigs_aux_pprod = pprod'.aux.Koszul_syz_sigs_aux\n  and Koszul_syz_sigs_pprod = pprod'.aux.Koszul_syz_sigs\n  and find_sig_reducer_pprod = pprod'.aux.find_sig_reducer\n  and sig_trd_spp_body_pprod = pprod'.aux.sig_trd_spp_body\n  and sig_trd_spp_aux_pprod = pprod'.aux.sig_trd_spp_aux\n  and sig_trd_spp_pprod = pprod'.aux.sig_trd_spp\n  and spair_sigs_spp_pprod = pprod'.aux.spair_sigs_spp\n  and is_pred_syz_pprod = pprod'.aux.is_pred_syz\n  and is_rewritable_spp_pprod = pprod'.aux.is_rewritable_spp\n  and sig_crit_spp_pprod = pprod'.aux.sig_crit_spp\n  and spair_spp_pprod = pprod'.aux.spair_spp\n  and spp_of_pair_pprod = pprod'.aux.spp_of_pair\n  and pair_ord_spp_pprod = pprod'.aux.pair_ord_spp\n  and sig_of_pair_spp_pprod = pprod'.aux.sig_of_pair_spp\n  and new_spairs_spp_pprod = pprod'.aux.new_spairs_spp\n  and is_regular_spair_spp_pprod = pprod'.aux.is_regular_spair_spp\n  and add_spairs_spp_pprod = pprod'.aux.add_spairs_spp\n  and is_pot_ord_pprod = pprod'.is_pot_ord\n  and new_syz_sigs_spp_pprod = pprod'.aux.new_syz_sigs_spp\n  and rb_spp_body_pprod = pprod'.aux.rb_spp_body\n  and rb_spp_aux_pprod = pprod'.aux.rb_spp_aux\n  and gb_sig_z_pprod' = pprod'.aux.gb_sig_z\n  and gb_sig_pprod' = pprod'.aux.gb_sig\n  and rw_rat_strict_pprod = pprod'.aux.rw_rat_strict\n  and rw_add_strict_pprod = pprod'.aux.rw_add_strict"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((qpm_nat_inf_term to &&& pprod.pp_of_term = fst) &&&\n     pprod.component_of_term = snd &&& pprod.splus = splus_pprod) &&&\n    (pprod.adds_term = adds_term_pprod &&&\n     punit.monom_mult = monom_mult_punit) &&&\n    ordered_term.lt fst (le_of_nat_term_order (proj_ord to)) =\n    lt_punit (proj_ord to) &&&\n    ordered_term.lc fst (le_of_nat_term_order (proj_ord to)) =\n    lc_punit (proj_ord to) &&&\n    ordered_term.tail fst (le_of_nat_term_order (proj_ord to)) =\n    tail_punit (proj_ord to)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. qpm_nat_inf_term to", "by (rule qpm_nat_inf_term.intro, fact gd_nat_term_id)"], ["proof (prove)\ngoal (8 subgoals):\n 1. pprod.pp_of_term = fst\n 2. pprod.component_of_term = snd\n 3. pprod.splus = splus_pprod\n 4. pprod.adds_term = adds_term_pprod\n 5. punit.monom_mult = monom_mult_punit\n 6. ordered_term.lt fst (le_of_nat_term_order (proj_ord to)) =\n    lt_punit (proj_ord to)\n 7. ordered_term.lc fst (le_of_nat_term_order (proj_ord to)) =\n    lc_punit (proj_ord to)\n 8. ordered_term.tail fst (le_of_nat_term_order (proj_ord to)) =\n    tail_punit (proj_ord to)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.pp_of_term = fst", "by (fact pprod_pp_of_term)"], ["proof (prove)\ngoal (7 subgoals):\n 1. pprod.component_of_term = snd\n 2. pprod.splus = splus_pprod\n 3. pprod.adds_term = adds_term_pprod\n 4. punit.monom_mult = monom_mult_punit\n 5. ordered_term.lt fst (le_of_nat_term_order (proj_ord to)) =\n    lt_punit (proj_ord to)\n 6. ordered_term.lc fst (le_of_nat_term_order (proj_ord to)) =\n    lc_punit (proj_ord to)\n 7. ordered_term.tail fst (le_of_nat_term_order (proj_ord to)) =\n    tail_punit (proj_ord to)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.component_of_term = snd", "by (fact pprod_component_of_term)"], ["proof (prove)\ngoal (6 subgoals):\n 1. pprod.splus = splus_pprod\n 2. pprod.adds_term = adds_term_pprod\n 3. punit.monom_mult = monom_mult_punit\n 4. ordered_term.lt fst (le_of_nat_term_order (proj_ord to)) =\n    lt_punit (proj_ord to)\n 5. ordered_term.lc fst (le_of_nat_term_order (proj_ord to)) =\n    lc_punit (proj_ord to)\n 6. ordered_term.tail fst (le_of_nat_term_order (proj_ord to)) =\n    tail_punit (proj_ord to)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.splus = splus_pprod", "by (simp only: splus_pprod_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. pprod.adds_term = adds_term_pprod\n 2. punit.monom_mult = monom_mult_punit\n 3. ordered_term.lt fst (le_of_nat_term_order (proj_ord to)) =\n    lt_punit (proj_ord to)\n 4. ordered_term.lc fst (le_of_nat_term_order (proj_ord to)) =\n    lc_punit (proj_ord to)\n 5. ordered_term.tail fst (le_of_nat_term_order (proj_ord to)) =\n    tail_punit (proj_ord to)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.adds_term = adds_term_pprod", "by (simp only: adds_term_pprod_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. punit.monom_mult = monom_mult_punit\n 2. ordered_term.lt fst (le_of_nat_term_order (proj_ord to)) =\n    lt_punit (proj_ord to)\n 3. ordered_term.lc fst (le_of_nat_term_order (proj_ord to)) =\n    lc_punit (proj_ord to)\n 4. ordered_term.tail fst (le_of_nat_term_order (proj_ord to)) =\n    tail_punit (proj_ord to)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult = monom_mult_punit", "by (simp only: monom_mult_punit_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ordered_term.lt fst (le_of_nat_term_order (proj_ord to)) =\n    lt_punit (proj_ord to)\n 2. ordered_term.lc fst (le_of_nat_term_order (proj_ord to)) =\n    lc_punit (proj_ord to)\n 3. ordered_term.tail fst (le_of_nat_term_order (proj_ord to)) =\n    tail_punit (proj_ord to)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.lt fst (le_of_nat_term_order (proj_ord to)) =\n    lt_punit (proj_ord to)", "by (simp only: lt_punit_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ordered_term.lc fst (le_of_nat_term_order (proj_ord to)) =\n    lc_punit (proj_ord to)\n 2. ordered_term.tail fst (le_of_nat_term_order (proj_ord to)) =\n    tail_punit (proj_ord to)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.lc fst (le_of_nat_term_order (proj_ord to)) =\n    lc_punit (proj_ord to)", "by (simp only: lc_punit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.tail fst (le_of_nat_term_order (proj_ord to)) =\n    tail_punit (proj_ord to)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.tail fst (le_of_nat_term_order (proj_ord to)) =\n    tail_punit (proj_ord to)", "by (simp only: tail_punit_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>More Lemmas and Definitions\\<close>"], ["", "lemma compute_adds_term_pprod [code]:\n  \"adds_term_pprod u v = (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adds_term_pprod u v =\n    (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))", "by (simp add: adds_term_pprod_def pprod.adds_term_def adds_pp_add_linorder_def)"], ["", "lemma compute_splus_pprod [code]: \"splus_pprod t (s, i) = (t + s, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splus_pprod t (s, i) = (t + s, i)", "by (simp add: splus_pprod_def pprod.splus_def)"], ["", "lemma compute_sig_trd_spp_body_pprod [code]:\n  \"sig_trd_spp_body_pprod to bs v (p, r) =\n    (case find_sig_reducer_pprod to bs v (lt_punit (proj_ord to) p) 0 of\n        None   \\<Rightarrow> (tail_punit (proj_ord to) p, plus_monomial_less r (lc_punit (proj_ord to) p) (lt_punit (proj_ord to) p))\n      | Some i \\<Rightarrow> let b = snd (bs ! i) in\n          (tail_punit (proj_ord to) p - monom_mult_punit (lc_punit (proj_ord to) p / lc_punit (proj_ord to) b)\n              (lt_punit (proj_ord to) p - lt_punit (proj_ord to) b) (tail_punit (proj_ord to) b), r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sig_trd_spp_body_pprod to bs v (p, r) =\n    (case find_sig_reducer_pprod to bs v (lt_punit (proj_ord to) p) 0 of\n     None \\<Rightarrow>\n       (tail_punit (proj_ord to) p,\n        plus_monomial_less r (lc_punit (proj_ord to) p)\n         (lt_punit (proj_ord to) p))\n     | Some i \\<Rightarrow>\n         let b = snd (bs ! i)\n         in (tail_punit (proj_ord to) p -\n             monom_mult_punit\n              (lc_punit (proj_ord to) p / lc_punit (proj_ord to) b)\n              (lt_punit (proj_ord to) p - lt_punit (proj_ord to) b)\n              (tail_punit (proj_ord to) b),\n             r))", "by (simp add: plus_monomial_less_def split: option.split)"], ["", "lemma compute_sig_trd_spp_pprod [code]:\n  \"sig_trd_spp_pprod to bs (v, p) \\<equiv> (v, sig_trd_spp_aux_pprod to bs v (p, change_ord (proj_ord to) 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sig_trd_spp_pprod to bs (v, p) \\<equiv>\n    (v, sig_trd_spp_aux_pprod to bs v (p, change_ord (proj_ord to) 0))", "by (simp add: change_ord_def)"], ["", "lemmas [code] = conversep_iff"], ["", "lemma compute_is_pot_ord [code]:\n  \"is_pot_ord_pprod (LEX::(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order) = False\"\n    (is \"is_pot_ord_pprod ?lex = _\")\n  \"is_pot_ord_pprod (DRLEX::(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order) = False\"\n    (is \"is_pot_ord_pprod ?drlex = _\")\n  \"is_pot_ord_pprod (DEG (to::(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order)) = False\"\n  \"is_pot_ord_pprod (POT (to::(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order)) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_pot_ord_pprod Term_Order.LEX = False &&&\n     is_pot_ord_pprod DRLEX = False) &&&\n    is_pot_ord_pprod (DEG to) = False &&& is_pot_ord_pprod (POT to) = True", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. is_pot_ord_pprod Term_Order.LEX = False\n 2. is_pot_ord_pprod DRLEX = False\n 3. is_pot_ord_pprod (DEG to) = False\n 4. is_pot_ord_pprod (POT to) = True", "have eq1: \"snd ((Term_Order.of_exps a b i)::('a, 'b) pp \\<times> nat) = i\" for a b and i::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Term_Order.of_exps a b i) = i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (Term_Order.of_exps a b i) = i", "have \"snd ((Term_Order.of_exps a b i)::('a, 'b) pp \\<times> nat) =\n          snd (rep_nat_term ((Term_Order.of_exps a b i)::('a, 'b) pp \\<times> nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Term_Order.of_exps a b i) =\n    snd (rep_nat_term (Term_Order.of_exps a b i))", "by (simp add: rep_nat_term_prod_def rep_nat_nat_def)"], ["proof (state)\nthis:\n  snd (Term_Order.of_exps a b i) =\n  snd (rep_nat_term (Term_Order.of_exps a b i))\n\ngoal (1 subgoal):\n 1. snd (Term_Order.of_exps a b i) = i", "also"], ["proof (state)\nthis:\n  snd (Term_Order.of_exps a b i) =\n  snd (rep_nat_term (Term_Order.of_exps a b i))\n\ngoal (1 subgoal):\n 1. snd (Term_Order.of_exps a b i) = i", "have \"... = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rep_nat_term (Term_Order.of_exps a b i)) = i", "proof (rule snd_of_exps)"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (rep_nat_term ?x) = i", "show \"snd (rep_nat_term (undefined, i)) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rep_nat_term (undefined, i)) = i", "by (simp add: rep_nat_term_prod_def rep_nat_nat_def)"], ["proof (state)\nthis:\n  snd (rep_nat_term (undefined, i)) = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (rep_nat_term (Term_Order.of_exps a b i)) = i\n\ngoal (1 subgoal):\n 1. snd (Term_Order.of_exps a b i) = i", "finally"], ["proof (chain)\npicking this:\n  snd (Term_Order.of_exps a b i) = i", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (Term_Order.of_exps a b i) = i\n\ngoal (1 subgoal):\n 1. snd (Term_Order.of_exps a b i) = i", "."], ["proof (state)\nthis:\n  snd (Term_Order.of_exps a b i) = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (Term_Order.of_exps ?a ?b ?i) = ?i\n\ngoal (4 subgoals):\n 1. is_pot_ord_pprod Term_Order.LEX = False\n 2. is_pot_ord_pprod DRLEX = False\n 3. is_pot_ord_pprod (DEG to) = False\n 4. is_pot_ord_pprod (POT to) = True", "let ?u = \"(Term_Order.of_exps 1 0 0)::('a, 'b) pp \\<times> nat\""], ["proof (state)\ngoal (4 subgoals):\n 1. is_pot_ord_pprod Term_Order.LEX = False\n 2. is_pot_ord_pprod DRLEX = False\n 3. is_pot_ord_pprod (DEG to) = False\n 4. is_pot_ord_pprod (POT to) = True", "let ?v = \"(Term_Order.of_exps 0 0 1)::('a, 'b) pp \\<times> nat\""], ["proof (state)\ngoal (4 subgoals):\n 1. is_pot_ord_pprod Term_Order.LEX = False\n 2. is_pot_ord_pprod DRLEX = False\n 3. is_pot_ord_pprod (DEG to) = False\n 4. is_pot_ord_pprod (POT to) = True", "have \"\\<not> is_pot_ord_pprod ?lex\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_pot_ord_pprod Term_Order.LEX", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. is_pot_ord_pprod Term_Order.LEX \\<Longrightarrow> False", "assume \"is_pot_ord_pprod ?lex\""], ["proof (state)\nthis:\n  is_pot_ord_pprod Term_Order.LEX\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod Term_Order.LEX \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  is_pot_ord_pprod Term_Order.LEX\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod Term_Order.LEX \\<Longrightarrow> False", "have \"le_of_nat_term_order ?lex ?v ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_of_nat_term_order Term_Order.LEX (Term_Order.of_exps 0 0 1)\n     (Term_Order.of_exps 1 0 0)", "by (simp add: le_of_nat_term_order nat_term_compare_LEX lex_comp lex_comp_aux_def\n            comp_of_ord_def lex_pp_of_exps eq_of_exps)"], ["proof (state)\nthis:\n  le_of_nat_term_order Term_Order.LEX (Term_Order.of_exps 0 0 1)\n   (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod Term_Order.LEX \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  is_pot_ord_pprod Term_Order.LEX\n  le_of_nat_term_order Term_Order.LEX (Term_Order.of_exps 0 0 1)\n   (Term_Order.of_exps 1 0 0)", "have \"snd ?v \\<le> snd ?u\""], ["proof (prove)\nusing this:\n  is_pot_ord_pprod Term_Order.LEX\n  le_of_nat_term_order Term_Order.LEX (Term_Order.of_exps 0 0 1)\n   (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. snd (Term_Order.of_exps 0 0 1) \\<le> snd (Term_Order.of_exps 1 0 0)", "by (rule pprod'.is_pot_ordD2)"], ["proof (state)\nthis:\n  snd (Term_Order.of_exps 0 0 1) \\<le> snd (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod Term_Order.LEX \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  snd (Term_Order.of_exps 0 0 1) \\<le> snd (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: eq1)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_pot_ord_pprod Term_Order.LEX\n\ngoal (4 subgoals):\n 1. is_pot_ord_pprod Term_Order.LEX = False\n 2. is_pot_ord_pprod DRLEX = False\n 3. is_pot_ord_pprod (DEG to) = False\n 4. is_pot_ord_pprod (POT to) = True", "thus \"is_pot_ord_pprod ?lex = False\""], ["proof (prove)\nusing this:\n  \\<not> is_pot_ord_pprod Term_Order.LEX\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod Term_Order.LEX = False", "by simp"], ["proof (state)\nthis:\n  is_pot_ord_pprod Term_Order.LEX = False\n\ngoal (3 subgoals):\n 1. is_pot_ord_pprod DRLEX = False\n 2. is_pot_ord_pprod (DEG to) = False\n 3. is_pot_ord_pprod (POT to) = True", "have \"\\<not> is_pot_ord_pprod ?drlex\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_pot_ord_pprod DRLEX", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. is_pot_ord_pprod DRLEX \\<Longrightarrow> False", "assume \"is_pot_ord_pprod ?drlex\""], ["proof (state)\nthis:\n  is_pot_ord_pprod DRLEX\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod DRLEX \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  is_pot_ord_pprod DRLEX\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod DRLEX \\<Longrightarrow> False", "have \"le_of_nat_term_order ?drlex ?v ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_of_nat_term_order DRLEX (Term_Order.of_exps 0 0 1)\n     (Term_Order.of_exps 1 0 0)", "by (simp add: le_of_nat_term_order nat_term_compare_DRLEX deg_comp comparator_of_def)"], ["proof (state)\nthis:\n  le_of_nat_term_order DRLEX (Term_Order.of_exps 0 0 1)\n   (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod DRLEX \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  is_pot_ord_pprod DRLEX\n  le_of_nat_term_order DRLEX (Term_Order.of_exps 0 0 1)\n   (Term_Order.of_exps 1 0 0)", "have \"snd ?v \\<le> snd ?u\""], ["proof (prove)\nusing this:\n  is_pot_ord_pprod DRLEX\n  le_of_nat_term_order DRLEX (Term_Order.of_exps 0 0 1)\n   (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. snd (Term_Order.of_exps 0 0 1) \\<le> snd (Term_Order.of_exps 1 0 0)", "by (rule pprod'.is_pot_ordD2)"], ["proof (state)\nthis:\n  snd (Term_Order.of_exps 0 0 1) \\<le> snd (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod DRLEX \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  snd (Term_Order.of_exps 0 0 1) \\<le> snd (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: eq1)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_pot_ord_pprod DRLEX\n\ngoal (3 subgoals):\n 1. is_pot_ord_pprod DRLEX = False\n 2. is_pot_ord_pprod (DEG to) = False\n 3. is_pot_ord_pprod (POT to) = True", "thus \"is_pot_ord_pprod ?drlex = False\""], ["proof (prove)\nusing this:\n  \\<not> is_pot_ord_pprod DRLEX\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod DRLEX = False", "by simp"], ["proof (state)\nthis:\n  is_pot_ord_pprod DRLEX = False\n\ngoal (2 subgoals):\n 1. is_pot_ord_pprod (DEG to) = False\n 2. is_pot_ord_pprod (POT to) = True", "have \"\\<not> is_pot_ord_pprod (DEG to)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_pot_ord_pprod (DEG to)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. is_pot_ord_pprod (DEG to) \\<Longrightarrow> False", "assume \"is_pot_ord_pprod (DEG to)\""], ["proof (state)\nthis:\n  is_pot_ord_pprod (DEG to)\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod (DEG to) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  is_pot_ord_pprod (DEG to)\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod (DEG to) \\<Longrightarrow> False", "have \"le_of_nat_term_order (DEG to) ?v ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_of_nat_term_order (DEG to) (Term_Order.of_exps 0 0 1)\n     (Term_Order.of_exps 1 0 0)", "by (simp add: le_of_nat_term_order nat_term_compare_DEG deg_comp comparator_of_def)"], ["proof (state)\nthis:\n  le_of_nat_term_order (DEG to) (Term_Order.of_exps 0 0 1)\n   (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod (DEG to) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  is_pot_ord_pprod (DEG to)\n  le_of_nat_term_order (DEG to) (Term_Order.of_exps 0 0 1)\n   (Term_Order.of_exps 1 0 0)", "have \"snd ?v \\<le> snd ?u\""], ["proof (prove)\nusing this:\n  is_pot_ord_pprod (DEG to)\n  le_of_nat_term_order (DEG to) (Term_Order.of_exps 0 0 1)\n   (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. snd (Term_Order.of_exps 0 0 1) \\<le> snd (Term_Order.of_exps 1 0 0)", "by (rule pprod'.is_pot_ordD2)"], ["proof (state)\nthis:\n  snd (Term_Order.of_exps 0 0 1) \\<le> snd (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod (DEG to) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  snd (Term_Order.of_exps 0 0 1) \\<le> snd (Term_Order.of_exps 1 0 0)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: eq1)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_pot_ord_pprod (DEG to)\n\ngoal (2 subgoals):\n 1. is_pot_ord_pprod (DEG to) = False\n 2. is_pot_ord_pprod (POT to) = True", "thus \"is_pot_ord_pprod (DEG to) = False\""], ["proof (prove)\nusing this:\n  \\<not> is_pot_ord_pprod (DEG to)\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod (DEG to) = False", "by simp"], ["proof (state)\nthis:\n  is_pot_ord_pprod (DEG to) = False\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod (POT to) = True", "have \"is_pot_ord_pprod (POT to)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pot_ord_pprod (POT to)", "by (rule pprod'.is_pot_ordI, simp add: lt_of_nat_term_order nat_term_compare_POT pot_comp rep_nat_term_prod_def,\n        simp add: comparator_of_def)"], ["proof (state)\nthis:\n  is_pot_ord_pprod (POT to)\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod (POT to) = True", "thus \"is_pot_ord_pprod (POT to) = True\""], ["proof (prove)\nusing this:\n  is_pot_ord_pprod (POT to)\n\ngoal (1 subgoal):\n 1. is_pot_ord_pprod (POT to) = True", "by simp"], ["proof (state)\nthis:\n  is_pot_ord_pprod (POT to) = True\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary is_pot_ord_POT: \"is_pot_ord_pprod (POT to)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pot_ord_pprod (POT to)", "by (simp only: compute_is_pot_ord)"], ["", "definition \"gb_sig_z_pprod to rword_strict fs \\<equiv>\n                  (let res = gb_sig_z_pprod' to (rword_strict to) (map (change_ord (proj_ord to)) fs) in\n                    (length (fst res), snd res))\""], ["", "definition \"gb_sig_pprod to rword_strict fs \\<equiv> gb_sig_pprod' to (rword_strict to) (map (change_ord (proj_ord to)) fs)\""], ["", "lemma snd_gb_sig_z_pprod'_eq_gb_sig_z_pprod:\n  \"snd (gb_sig_z_pprod' to (rword_strict to) fs) = snd (gb_sig_z_pprod to rword_strict fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (gb_sig_z_pprod' to (rword_strict to) fs) =\n    snd (gb_sig_z_pprod to rword_strict fs)", "by (simp add: gb_sig_z_pprod_def change_ord_def Let_def)"], ["", "lemma gb_sig_pprod'_eq_gb_sig_pprod:\n  \"gb_sig_pprod' to (rword_strict to) fs = gb_sig_pprod to rword_strict fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_sig_pprod' to (rword_strict to) fs = gb_sig_pprod to rword_strict fs", "by (simp add: gb_sig_pprod_def change_ord_def)"], ["", "thm pprod'.aux.gb_sig_isGB[OF pprod'.aux.rw_rat_strict_is_strict_rewrite_ord, simplified gb_sig_pprod'_eq_gb_sig_pprod]"], ["", "thm pprod'.aux.gb_sig_no_zero_red[OF pprod'.aux.rw_rat_strict_is_strict_rewrite_ord is_pot_ord_POT, simplified snd_gb_sig_z_pprod'_eq_gb_sig_z_pprod]"], ["", "subsection \\<open>Computations\\<close>"], ["", "experiment begin"], ["", "interpretation trivariate\\<^sub>0_rat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma\n  \"gb_sig_pprod DRLEX rw_rat_strict_pprod [X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y, X * Y * Z + 2 * Y\\<^sup>2] =\n    [C\\<^sub>0 (3 / 4) * X ^ 3 * Y\\<^sup>2 - 2 * Y ^ 4, - 4 * Y ^ 3 * Z - 3 * X\\<^sup>2 * Y\\<^sup>2, X * Y * Z + 2 * Y\\<^sup>2, X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_sig_pprod DRLEX rw_rat_strict_pprod\n     [(V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3 +\n      3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1,\n      V\\<^sub>0 0 * V\\<^sub>0 1 * V\\<^sub>0 2 + 2 * (V\\<^sub>0 1)\\<^sup>2] =\n    [C\\<^sub>0 (3 / 4) * V\\<^sub>0 0 ^ 3 * (V\\<^sub>0 1)\\<^sup>2 -\n     2 * V\\<^sub>0 1 ^ 4,\n     - 4 * V\\<^sub>0 1 ^ 3 * V\\<^sub>0 2 -\n     3 * (V\\<^sub>0 0)\\<^sup>2 * (V\\<^sub>0 1)\\<^sup>2,\n     V\\<^sub>0 0 * V\\<^sub>0 1 * V\\<^sub>0 2 + 2 * (V\\<^sub>0 1)\\<^sup>2,\n     (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3 +\n     3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1]", "by eval"], ["", "end"], ["", "text \\<open>Recall that the first return value of @{const gb_sig_z_pprod} is the size of the computed\n  Gr\\\"obner basis, and the second return value is the total number of useless zero-reductions:\\<close>"], ["", "lemma\n  \"gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod ((cyclic DRLEX 6)::(_ \\<Rightarrow>\\<^sub>0 rat) list) = (155, 8)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod (cyclic DRLEX 6) =\n    (155, 8)", "by eval"], ["", "lemma\n  \"gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod ((katsura DRLEX 5)::(_ \\<Rightarrow>\\<^sub>0 rat) list) = (29, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod (katsura DRLEX 5) =\n    (29, 0)", "by eval"], ["", "lemma\n  \"gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod ((eco DRLEX 8)::(_ \\<Rightarrow>\\<^sub>0 rat) list) = (76, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod (eco DRLEX 8) = (76, 0)", "by eval"], ["", "lemma\n  \"gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod ((noon DRLEX 5)::(_ \\<Rightarrow>\\<^sub>0 rat) list) = (83, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_sig_z_pprod (POT DRLEX) rw_rat_strict_pprod (noon DRLEX 5) = (83, 0)", "by eval"], ["", "end"], ["", "(* theory *)"]]}