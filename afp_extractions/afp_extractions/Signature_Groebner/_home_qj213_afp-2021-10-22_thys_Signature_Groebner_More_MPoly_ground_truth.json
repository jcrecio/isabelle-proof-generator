{"file_name": "/home/qj213/afp-2021-10-22/thys/Signature_Groebner/More_MPoly.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Signature_Groebner", "problem_names": ["lemma (in comm_powerprod) minus_plus': \"s adds t \\<Longrightarrow> u + (t - s) = (u + t) - s\"", "lemma lcs_alt_2:\n  assumes \"a + x = b + y\"\n  shows \"lcs x y = (b + y) - gcs a b\"", "lemma gcs_minus:\n  assumes \"u adds s\" and \"u adds t\"\n  shows \"gcs (s - u) (t - u) = gcs s t - u\"", "lemma poly_mapping_rangeE:\n  assumes \"c \\<in> Poly_Mapping.range p\"\n  obtains k where \"k \\<in> keys p\" and \"c = lookup p k\"", "lemma poly_mapping_range_nonzero: \"0 \\<notin> Poly_Mapping.range p\"", "lemma (in term_powerprod) Keys_range_vectorize_poly: \"Keys (Poly_Mapping.range (vectorize_poly p)) = pp_of_term ` keys p\"", "lemma lt_lookup_vectorize: \"punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p\"", "lemma lower_higher_zeroI: \"u \\<preceq>\\<^sub>t v \\<Longrightarrow> lower (higher p v) u = 0\"", "lemma lookup_minus_higher: \"lookup (p - higher p v) u = (lookup p u when u \\<preceq>\\<^sub>t v)\"", "lemma keys_minus_higher: \"keys (p - higher p v) = {u \\<in> keys p. u \\<preceq>\\<^sub>t v}\"", "lemma lt_minus_higher: \"v \\<in> keys p \\<Longrightarrow> lt (p - higher p v) = v\"", "lemma lc_minus_higher: \"v \\<in> keys p \\<Longrightarrow> lc (p - higher p v) = lookup p v\"", "lemma tail_minus_higher: \"v \\<in> keys p \\<Longrightarrow> tail (p - higher p v) = lower p v\"", "lemma (in gd_term) dgrad_p_set_closed_mult_scalar:\n  assumes \"dickson_grading d\" and \"p \\<in> punit.dgrad_p_set d m\" and \"r \\<in> dgrad_p_set d m\"\n  shows \"p \\<odot> r \\<in> dgrad_p_set d m\"", "lemma is_regular_sequenceD:\n  \"is_regular_sequence fs \\<Longrightarrow> j < length fs \\<Longrightarrow> q * fs ! j \\<in> ideal (set (take j fs)) \\<Longrightarrow>\n    q \\<in> ideal (set (take j fs))\"", "lemma is_regular_sequence_Nil: \"is_regular_sequence []\"", "lemma is_regular_sequence_snocI:\n  assumes \"\\<And>q. q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\" and \"is_regular_sequence fs\"\n  shows \"is_regular_sequence (fs @ [f])\"", "lemma is_regular_sequence_snocD:\n  assumes \"is_regular_sequence (fs @ [f])\"\n  shows \"\\<And>q. q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\"\n    and \"is_regular_sequence fs\"", "lemma is_regular_sequence_removeAll_zero:\n  assumes \"is_regular_sequence fs\"\n  shows \"is_regular_sequence (removeAll 0 fs)\"", "lemma is_regular_sequence_remdups:\n  assumes \"is_regular_sequence fs\"\n  shows \"is_regular_sequence (rev (remdups (rev fs)))\""], "translations": [["", "lemma (in comm_powerprod) minus_plus': \"s adds t \\<Longrightarrow> u + (t - s) = (u + t) - s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s adds t \\<Longrightarrow> u + (t - s) = u + t - s", "using add_commute minus_plus"], ["proof (prove)\nusing this:\n  ?a + ?b = ?b + ?a\n  ?s adds ?t \\<Longrightarrow> ?t - ?s + ?u = ?t + ?u - ?s\n\ngoal (1 subgoal):\n 1. s adds t \\<Longrightarrow> u + (t - s) = u + t - s", "by auto"], ["", "context ulcs_powerprod\nbegin"], ["", "lemma lcs_alt_2:\n  assumes \"a + x = b + y\"\n  shows \"lcs x y = (b + y) - gcs a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "have \"a + (lcs x y + gcs a b) = lcs (a + x) (a + y) + gcs a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (lcs x y + gcs a b) = lcs (a + x) (a + y) + gcs a b", "by (simp only: lcs_plus_left ac_simps)"], ["proof (state)\nthis:\n  a + (lcs x y + gcs a b) = lcs (a + x) (a + y) + gcs a b\n\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "also"], ["proof (state)\nthis:\n  a + (lcs x y + gcs a b) = lcs (a + x) (a + y) + gcs a b\n\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "have \"... = lcs (b + y) (a + y) + gcs a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs (a + x) (a + y) + gcs a b = lcs (b + y) (a + y) + gcs a b", "by (simp only: assms)"], ["proof (state)\nthis:\n  lcs (a + x) (a + y) + gcs a b = lcs (b + y) (a + y) + gcs a b\n\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "also"], ["proof (state)\nthis:\n  lcs (a + x) (a + y) + gcs a b = lcs (b + y) (a + y) + gcs a b\n\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "have \"... = (lcs a b + y) + gcs a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs (b + y) (a + y) + gcs a b = lcs a b + y + gcs a b", "by (simp only: lcs_plus_right lcs_comm)"], ["proof (state)\nthis:\n  lcs (b + y) (a + y) + gcs a b = lcs a b + y + gcs a b\n\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "also"], ["proof (state)\nthis:\n  lcs (b + y) (a + y) + gcs a b = lcs a b + y + gcs a b\n\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "have \"... = (gcs a b + lcs a b) + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs a b + y + gcs a b = gcs a b + lcs a b + y", "by (simp only: ac_simps)"], ["proof (state)\nthis:\n  lcs a b + y + gcs a b = gcs a b + lcs a b + y\n\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "also"], ["proof (state)\nthis:\n  lcs a b + y + gcs a b = gcs a b + lcs a b + y\n\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "have \"... = a + (b + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs a b + lcs a b + y = a + (b + y)", "by (simp only: gcs_plus_lcs, simp add: ac_simps)"], ["proof (state)\nthis:\n  gcs a b + lcs a b + y = a + (b + y)\n\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "finally"], ["proof (chain)\npicking this:\n  a + (lcs x y + gcs a b) = a + (b + y)", "have \"(lcs x y + gcs a b) - gcs a b = (b + y) - gcs a b\""], ["proof (prove)\nusing this:\n  a + (lcs x y + gcs a b) = a + (b + y)\n\ngoal (1 subgoal):\n 1. lcs x y + gcs a b - gcs a b = b + y - gcs a b", "by simp"], ["proof (state)\nthis:\n  lcs x y + gcs a b - gcs a b = b + y - gcs a b\n\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  lcs x y + gcs a b - gcs a b = b + y - gcs a b\n\ngoal (1 subgoal):\n 1. lcs x y = b + y - gcs a b", "by simp"], ["proof (state)\nthis:\n  lcs x y = b + y - gcs a b\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lcs_alt_1:\n  assumes \"a + x = b + y\"\n  shows \"lcs x y = (a + x) - gcs a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs x y = a + x - gcs a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lcs x y = a + x - gcs a b", "have \"lcs x y = lcs y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs x y = lcs y x", "by (simp only: lcs_comm)"], ["proof (state)\nthis:\n  lcs x y = lcs y x\n\ngoal (1 subgoal):\n 1. lcs x y = a + x - gcs a b", "also"], ["proof (state)\nthis:\n  lcs x y = lcs y x\n\ngoal (1 subgoal):\n 1. lcs x y = a + x - gcs a b", "from assms[symmetric]"], ["proof (chain)\npicking this:\n  b + y = a + x", "have \"... = (a + x) - gcs b a\""], ["proof (prove)\nusing this:\n  b + y = a + x\n\ngoal (1 subgoal):\n 1. lcs y x = a + x - gcs b a", "by (rule lcs_alt_2)"], ["proof (state)\nthis:\n  lcs y x = a + x - gcs b a\n\ngoal (1 subgoal):\n 1. lcs x y = a + x - gcs a b", "also"], ["proof (state)\nthis:\n  lcs y x = a + x - gcs b a\n\ngoal (1 subgoal):\n 1. lcs x y = a + x - gcs a b", "have \"... = (a + x) - gcs a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + x - gcs b a = a + x - gcs a b", "by (simp only: gcs_comm)"], ["proof (state)\nthis:\n  a + x - gcs b a = a + x - gcs a b\n\ngoal (1 subgoal):\n 1. lcs x y = a + x - gcs a b", "finally"], ["proof (chain)\npicking this:\n  lcs x y = a + x - gcs a b", "show ?thesis"], ["proof (prove)\nusing this:\n  lcs x y = a + x - gcs a b\n\ngoal (1 subgoal):\n 1. lcs x y = a + x - gcs a b", "."], ["proof (state)\nthis:\n  lcs x y = a + x - gcs a b\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lcs_minus_1:\n  assumes \"a + x = b + y\"\n  shows \"lcs x y - x = a - gcs a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs x y - x = a - gcs a b", "by (simp add: lcs_alt_1[OF assms] diff_right_commute)"], ["", "corollary lcs_minus_2:\n  assumes \"a + x = b + y\"\n  shows \"lcs x y - y = b - gcs a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcs x y - y = b - gcs a b", "by (simp add: lcs_alt_2[OF assms] diff_right_commute)"], ["", "lemma gcs_minus:\n  assumes \"u adds s\" and \"u adds t\"\n  shows \"gcs (s - u) (t - u) = gcs s t - u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs (s - u) (t - u) = gcs s t - u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcs (s - u) (t - u) = gcs s t - u", "from assms"], ["proof (chain)\npicking this:\n  u adds s\n  u adds t", "have \"gcs s t = gcs ((s - u) + u) ((t - u) + u)\""], ["proof (prove)\nusing this:\n  u adds s\n  u adds t\n\ngoal (1 subgoal):\n 1. gcs s t = gcs (s - u + u) (t - u + u)", "by (simp add: minus_plus)"], ["proof (state)\nthis:\n  gcs s t = gcs (s - u + u) (t - u + u)\n\ngoal (1 subgoal):\n 1. gcs (s - u) (t - u) = gcs s t - u", "also"], ["proof (state)\nthis:\n  gcs s t = gcs (s - u + u) (t - u + u)\n\ngoal (1 subgoal):\n 1. gcs (s - u) (t - u) = gcs s t - u", "have \"... = gcs (s - u) (t - u) + u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs (s - u + u) (t - u + u) = gcs (s - u) (t - u) + u", "by (simp only: gcs_plus_right)"], ["proof (state)\nthis:\n  gcs (s - u + u) (t - u + u) = gcs (s - u) (t - u) + u\n\ngoal (1 subgoal):\n 1. gcs (s - u) (t - u) = gcs s t - u", "finally"], ["proof (chain)\npicking this:\n  gcs s t = gcs (s - u) (t - u) + u", "show ?thesis"], ["proof (prove)\nusing this:\n  gcs s t = gcs (s - u) (t - u) + u\n\ngoal (1 subgoal):\n 1. gcs (s - u) (t - u) = gcs s t - u", "by simp"], ["proof (state)\nthis:\n  gcs (s - u) (t - u) = gcs s t - u\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary gcs_minus_gcs: \"gcs (s - (gcs s t)) (t - (gcs s t)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcs (s - gcs s t) (t - gcs s t) = (0::'a)", "by (simp add: gcs_minus gcs_adds gcs_adds_2)"], ["", "end"], ["", "(* ulcs_powerprod *)"], ["", "subsection \\<open>Miscellaneous\\<close>"], ["", "lemma poly_mapping_rangeE:\n  assumes \"c \\<in> Poly_Mapping.range p\"\n  obtains k where \"k \\<in> keys p\" and \"c = lookup p k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> keys p; c = lookup p k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  c \\<in> Poly_Mapping.range p\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> keys p; c = lookup p k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (transfer, auto)"], ["", "lemma poly_mapping_range_nonzero: \"0 \\<notin> Poly_Mapping.range p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<notin> Poly_Mapping.range p", "by (transfer, auto)"], ["", "lemma (in term_powerprod) Keys_range_vectorize_poly: \"Keys (Poly_Mapping.range (vectorize_poly p)) = pp_of_term ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (Poly_Mapping.range (vectorize_poly p)) = pp_of_term ` keys p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Keys (Poly_Mapping.range (vectorize_poly p))\n    \\<subseteq> pp_of_term ` keys p\n 2. pp_of_term ` keys p\n    \\<subseteq> Keys (Poly_Mapping.range (vectorize_poly p))", "show \"Keys (Poly_Mapping.range (vectorize_poly p)) \\<subseteq> pp_of_term ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (Poly_Mapping.range (vectorize_poly p))\n    \\<subseteq> pp_of_term ` keys p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys\n                (Poly_Mapping.range (vectorize_poly p)) \\<Longrightarrow>\n       x \\<in> pp_of_term ` keys p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys\n                (Poly_Mapping.range (vectorize_poly p)) \\<Longrightarrow>\n       x \\<in> pp_of_term ` keys p", "assume \"t \\<in> Keys (Poly_Mapping.range (vectorize_poly p))\""], ["proof (state)\nthis:\n  t \\<in> Keys (Poly_Mapping.range (vectorize_poly p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys\n                (Poly_Mapping.range (vectorize_poly p)) \\<Longrightarrow>\n       x \\<in> pp_of_term ` keys p", "then"], ["proof (chain)\npicking this:\n  t \\<in> Keys (Poly_Mapping.range (vectorize_poly p))", "obtain q where \"q \\<in> Poly_Mapping.range (vectorize_poly p)\" and \"t \\<in> keys q\""], ["proof (prove)\nusing this:\n  t \\<in> Keys (Poly_Mapping.range (vectorize_poly p))\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> Poly_Mapping.range (vectorize_poly p);\n         t \\<in> keys q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_KeysE)"], ["proof (state)\nthis:\n  q \\<in> Poly_Mapping.range (vectorize_poly p)\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys\n                (Poly_Mapping.range (vectorize_poly p)) \\<Longrightarrow>\n       x \\<in> pp_of_term ` keys p", "from this(1)"], ["proof (chain)\npicking this:\n  q \\<in> Poly_Mapping.range (vectorize_poly p)", "obtain k where q: \"q = lookup (vectorize_poly p) k\""], ["proof (prove)\nusing this:\n  q \\<in> Poly_Mapping.range (vectorize_poly p)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        q = lookup (vectorize_poly p) k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis DiffE imageE range.rep_eq)"], ["proof (state)\nthis:\n  q = lookup (vectorize_poly p) k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys\n                (Poly_Mapping.range (vectorize_poly p)) \\<Longrightarrow>\n       x \\<in> pp_of_term ` keys p", "with \\<open>t \\<in> keys q\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys q\n  q = lookup (vectorize_poly p) k", "have \"term_of_pair (t, k) \\<in> keys p\""], ["proof (prove)\nusing this:\n  t \\<in> keys q\n  q = lookup (vectorize_poly p) k\n\ngoal (1 subgoal):\n 1. term_of_pair (t, k) \\<in> keys p", "by (metis in_keys_iff lookup_proj_poly lookup_vectorize_poly)"], ["proof (state)\nthis:\n  term_of_pair (t, k) \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys\n                (Poly_Mapping.range (vectorize_poly p)) \\<Longrightarrow>\n       x \\<in> pp_of_term ` keys p", "hence \"pp_of_term (term_of_pair (t, k)) \\<in> pp_of_term ` keys p\""], ["proof (prove)\nusing this:\n  term_of_pair (t, k) \\<in> keys p\n\ngoal (1 subgoal):\n 1. pp_of_term (term_of_pair (t, k)) \\<in> pp_of_term ` keys p", "by (rule imageI)"], ["proof (state)\nthis:\n  pp_of_term (term_of_pair (t, k)) \\<in> pp_of_term ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Keys\n                (Poly_Mapping.range (vectorize_poly p)) \\<Longrightarrow>\n       x \\<in> pp_of_term ` keys p", "thus \"t \\<in> pp_of_term ` keys p\""], ["proof (prove)\nusing this:\n  pp_of_term (term_of_pair (t, k)) \\<in> pp_of_term ` keys p\n\ngoal (1 subgoal):\n 1. t \\<in> pp_of_term ` keys p", "by (simp only: pp_of_term_of_pair)"], ["proof (state)\nthis:\n  t \\<in> pp_of_term ` keys p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Keys (Poly_Mapping.range (vectorize_poly p))\n  \\<subseteq> pp_of_term ` keys p\n\ngoal (1 subgoal):\n 1. pp_of_term ` keys p\n    \\<subseteq> Keys (Poly_Mapping.range (vectorize_poly p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pp_of_term ` keys p\n    \\<subseteq> Keys (Poly_Mapping.range (vectorize_poly p))", "show \"pp_of_term ` keys p \\<subseteq> Keys (Poly_Mapping.range (vectorize_poly p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_term ` keys p\n    \\<subseteq> Keys (Poly_Mapping.range (vectorize_poly p))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term ` keys p \\<Longrightarrow>\n       x \\<in> Keys (Poly_Mapping.range (vectorize_poly p))", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term ` keys p \\<Longrightarrow>\n       x \\<in> Keys (Poly_Mapping.range (vectorize_poly p))", "assume \"t \\<in> pp_of_term ` keys p\""], ["proof (state)\nthis:\n  t \\<in> pp_of_term ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term ` keys p \\<Longrightarrow>\n       x \\<in> Keys (Poly_Mapping.range (vectorize_poly p))", "then"], ["proof (chain)\npicking this:\n  t \\<in> pp_of_term ` keys p", "obtain x where \"x \\<in> keys p\" and \"t = pp_of_term x\""], ["proof (prove)\nusing this:\n  t \\<in> pp_of_term ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> keys p; t = pp_of_term x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> keys p\n  t = pp_of_term x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term ` keys p \\<Longrightarrow>\n       x \\<in> Keys (Poly_Mapping.range (vectorize_poly p))", "from this(2)"], ["proof (chain)\npicking this:\n  t = pp_of_term x", "have \"term_of_pair (t, component_of_term x) = x\""], ["proof (prove)\nusing this:\n  t = pp_of_term x\n\ngoal (1 subgoal):\n 1. term_of_pair (t, component_of_term x) = x", "by (simp add: term_of_pair_pair)"], ["proof (state)\nthis:\n  term_of_pair (t, component_of_term x) = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term ` keys p \\<Longrightarrow>\n       x \\<in> Keys (Poly_Mapping.range (vectorize_poly p))", "with \\<open>x \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> keys p\n  term_of_pair (t, component_of_term x) = x", "have \"lookup p (term_of_pair (t, component_of_term x)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> keys p\n  term_of_pair (t, component_of_term x) = x\n\ngoal (1 subgoal):\n 1. lookup p (term_of_pair (t, component_of_term x)) \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup p (term_of_pair (t, component_of_term x)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term ` keys p \\<Longrightarrow>\n       x \\<in> Keys (Poly_Mapping.range (vectorize_poly p))", "hence \"lookup (proj_poly (component_of_term x) p) t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lookup p (term_of_pair (t, component_of_term x)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup (proj_poly (component_of_term x) p) t \\<noteq> (0::'b)", "by (simp add: lookup_proj_poly)"], ["proof (state)\nthis:\n  lookup (proj_poly (component_of_term x) p) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term ` keys p \\<Longrightarrow>\n       x \\<in> Keys (Poly_Mapping.range (vectorize_poly p))", "hence t: \"t \\<in> keys (proj_poly (component_of_term x) p)\""], ["proof (prove)\nusing this:\n  lookup (proj_poly (component_of_term x) p) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (proj_poly (component_of_term x) p)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  t \\<in> keys (proj_poly (component_of_term x) p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term ` keys p \\<Longrightarrow>\n       x \\<in> Keys (Poly_Mapping.range (vectorize_poly p))", "from \\<open>x \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> keys p", "have \"component_of_term x \\<in> keys (vectorize_poly p)\""], ["proof (prove)\nusing this:\n  x \\<in> keys p\n\ngoal (1 subgoal):\n 1. component_of_term x \\<in> keys (vectorize_poly p)", "by (simp add: keys_vectorize_poly)"], ["proof (state)\nthis:\n  component_of_term x \\<in> keys (vectorize_poly p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pp_of_term ` keys p \\<Longrightarrow>\n       x \\<in> Keys (Poly_Mapping.range (vectorize_poly p))", "from t"], ["proof (chain)\npicking this:\n  t \\<in> keys (proj_poly (component_of_term x) p)", "show \"t \\<in> Keys (Poly_Mapping.range (vectorize_poly p))\""], ["proof (prove)\nusing this:\n  t \\<in> keys (proj_poly (component_of_term x) p)\n\ngoal (1 subgoal):\n 1. t \\<in> Keys (Poly_Mapping.range (vectorize_poly p))", "proof (rule in_KeysI)"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_poly (component_of_term x) p\n    \\<in> Poly_Mapping.range (vectorize_poly p)", "have \"proj_poly (component_of_term x) p = lookup (vectorize_poly p) (component_of_term x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly (component_of_term x) p =\n    lookup (vectorize_poly p) (component_of_term x)", "by (simp only: lookup_vectorize_poly)"], ["proof (state)\nthis:\n  proj_poly (component_of_term x) p =\n  lookup (vectorize_poly p) (component_of_term x)\n\ngoal (1 subgoal):\n 1. proj_poly (component_of_term x) p\n    \\<in> Poly_Mapping.range (vectorize_poly p)", "also"], ["proof (state)\nthis:\n  proj_poly (component_of_term x) p =\n  lookup (vectorize_poly p) (component_of_term x)\n\ngoal (1 subgoal):\n 1. proj_poly (component_of_term x) p\n    \\<in> Poly_Mapping.range (vectorize_poly p)", "from \\<open>component_of_term x \\<in> keys (vectorize_poly p)\\<close>"], ["proof (chain)\npicking this:\n  component_of_term x \\<in> keys (vectorize_poly p)", "have \"... \\<in> Poly_Mapping.range (vectorize_poly p)\""], ["proof (prove)\nusing this:\n  component_of_term x \\<in> keys (vectorize_poly p)\n\ngoal (1 subgoal):\n 1. lookup (vectorize_poly p) (component_of_term x)\n    \\<in> Poly_Mapping.range (vectorize_poly p)", "by (rule in_keys_lookup_in_range)"], ["proof (state)\nthis:\n  lookup (vectorize_poly p) (component_of_term x)\n  \\<in> Poly_Mapping.range (vectorize_poly p)\n\ngoal (1 subgoal):\n 1. proj_poly (component_of_term x) p\n    \\<in> Poly_Mapping.range (vectorize_poly p)", "finally"], ["proof (chain)\npicking this:\n  proj_poly (component_of_term x) p\n  \\<in> Poly_Mapping.range (vectorize_poly p)", "show \"proj_poly (component_of_term x) p \\<in> Poly_Mapping.range (vectorize_poly p)\""], ["proof (prove)\nusing this:\n  proj_poly (component_of_term x) p\n  \\<in> Poly_Mapping.range (vectorize_poly p)\n\ngoal (1 subgoal):\n 1. proj_poly (component_of_term x) p\n    \\<in> Poly_Mapping.range (vectorize_poly p)", "."], ["proof (state)\nthis:\n  proj_poly (component_of_term x) p\n  \\<in> Poly_Mapping.range (vectorize_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> Keys (Poly_Mapping.range (vectorize_poly p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pp_of_term ` keys p\n  \\<subseteq> Keys (Poly_Mapping.range (vectorize_poly p))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{const ordered_term.lt} and @{const ordered_term.higher}\\<close>"], ["", "context ordered_term\nbegin"], ["", "lemma lt_lookup_vectorize: \"punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p", "by (simp add: vectorize_zero min_term_def pp_of_term_of_pair)"], ["proof (state)\nthis:\n  punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p", "proof (rule punit.lt_eqI_keys)"], ["proof (state)\ngoal (2 subgoals):\n 1. lp p \\<in> keys (lookup (vectorize_poly p) (component_of_term (lt p)))\n 2. \\<And>u.\n       u \\<in> keys\n                (lookup (vectorize_poly p)\n                  (component_of_term (lt p))) \\<Longrightarrow>\n       u \\<preceq> lp p", "from False"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"lt p \\<in> keys p\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lt p \\<in> keys p", "by (rule lt_in_keys)"], ["proof (state)\nthis:\n  lt p \\<in> keys p\n\ngoal (2 subgoals):\n 1. lp p \\<in> keys (lookup (vectorize_poly p) (component_of_term (lt p)))\n 2. \\<And>u.\n       u \\<in> keys\n                (lookup (vectorize_poly p)\n                  (component_of_term (lt p))) \\<Longrightarrow>\n       u \\<preceq> lp p", "thus \"lp p \\<in> keys (lookup (vectorize_poly p) (component_of_term (lt p)))\""], ["proof (prove)\nusing this:\n  lt p \\<in> keys p\n\ngoal (1 subgoal):\n 1. lp p \\<in> keys (lookup (vectorize_poly p) (component_of_term (lt p)))", "by (simp add: lookup_vectorize_poly keys_proj_poly)"], ["proof (state)\nthis:\n  lp p \\<in> keys (lookup (vectorize_poly p) (component_of_term (lt p)))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (lookup (vectorize_poly p)\n                  (component_of_term (lt p))) \\<Longrightarrow>\n       u \\<preceq> lp p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (lookup (vectorize_poly p)\n                  (component_of_term (lt p))) \\<Longrightarrow>\n       u \\<preceq> lp p", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (lookup (vectorize_poly p)\n                  (component_of_term (lt p))) \\<Longrightarrow>\n       u \\<preceq> lp p", "assume \"t \\<in> keys (lookup (vectorize_poly p) (component_of_term (lt p)))\""], ["proof (state)\nthis:\n  t \\<in> keys (lookup (vectorize_poly p) (component_of_term (lt p)))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (lookup (vectorize_poly p)\n                  (component_of_term (lt p))) \\<Longrightarrow>\n       u \\<preceq> lp p", "also"], ["proof (state)\nthis:\n  t \\<in> keys (lookup (vectorize_poly p) (component_of_term (lt p)))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (lookup (vectorize_poly p)\n                  (component_of_term (lt p))) \\<Longrightarrow>\n       u \\<preceq> lp p", "have \"... = pp_of_term ` {x\\<in>keys p. component_of_term x = component_of_term (lt p)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (lookup (vectorize_poly p) (component_of_term (lt p))) =\n    pp_of_term `\n    {x \\<in> keys p. component_of_term x = component_of_term (lt p)}", "by (simp only: lookup_vectorize_poly keys_proj_poly)"], ["proof (state)\nthis:\n  keys (lookup (vectorize_poly p) (component_of_term (lt p))) =\n  pp_of_term `\n  {x \\<in> keys p. component_of_term x = component_of_term (lt p)}\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (lookup (vectorize_poly p)\n                  (component_of_term (lt p))) \\<Longrightarrow>\n       u \\<preceq> lp p", "finally"], ["proof (chain)\npicking this:\n  t \\<in> pp_of_term `\n          {x \\<in> keys p. component_of_term x = component_of_term (lt p)}", "obtain v where \"v \\<in> keys p\" and 1: \"component_of_term v = component_of_term (lt p)\"\n      and t: \"t = pp_of_term v\""], ["proof (prove)\nusing this:\n  t \\<in> pp_of_term `\n          {x \\<in> keys p. component_of_term x = component_of_term (lt p)}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> keys p;\n         component_of_term v = component_of_term (lt p);\n         t = pp_of_term v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> keys p\n  component_of_term v = component_of_term (lt p)\n  t = pp_of_term v\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (lookup (vectorize_poly p)\n                  (component_of_term (lt p))) \\<Longrightarrow>\n       u \\<preceq> lp p", "from this(1)"], ["proof (chain)\npicking this:\n  v \\<in> keys p", "have \"v \\<preceq>\\<^sub>t lt p\""], ["proof (prove)\nusing this:\n  v \\<in> keys p\n\ngoal (1 subgoal):\n 1. v \\<preceq>\\<^sub>t lt p", "by (rule lt_max_keys)"], ["proof (state)\nthis:\n  v \\<preceq>\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (lookup (vectorize_poly p)\n                  (component_of_term (lt p))) \\<Longrightarrow>\n       u \\<preceq> lp p", "show \"t \\<preceq> lp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<preceq> lp p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> t \\<preceq> lp p \\<Longrightarrow> False", "assume \"\\<not> t \\<preceq> lp p\""], ["proof (state)\nthis:\n  \\<not> t \\<preceq> lp p\n\ngoal (1 subgoal):\n 1. \\<not> t \\<preceq> lp p \\<Longrightarrow> False", "hence \"lp p \\<prec> pp_of_term v\""], ["proof (prove)\nusing this:\n  \\<not> t \\<preceq> lp p\n\ngoal (1 subgoal):\n 1. lp p \\<prec> pp_of_term v", "by (simp add: t)"], ["proof (state)\nthis:\n  lp p \\<prec> pp_of_term v\n\ngoal (1 subgoal):\n 1. \\<not> t \\<preceq> lp p \\<Longrightarrow> False", "hence \"lp p \\<noteq> pp_of_term v\" and \"lp p \\<preceq> pp_of_term v\""], ["proof (prove)\nusing this:\n  lp p \\<prec> pp_of_term v\n\ngoal (1 subgoal):\n 1. lp p \\<noteq> pp_of_term v &&& lp p \\<preceq> pp_of_term v", "by simp_all"], ["proof (state)\nthis:\n  lp p \\<noteq> pp_of_term v\n  lp p \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. \\<not> t \\<preceq> lp p \\<Longrightarrow> False", "note this(2)"], ["proof (state)\nthis:\n  lp p \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. \\<not> t \\<preceq> lp p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  lp p \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. \\<not> t \\<preceq> lp p \\<Longrightarrow> False", "from 1"], ["proof (chain)\npicking this:\n  component_of_term v = component_of_term (lt p)", "have \"component_of_term (lt p) \\<le> component_of_term v\""], ["proof (prove)\nusing this:\n  component_of_term v = component_of_term (lt p)\n\ngoal (1 subgoal):\n 1. component_of_term (lt p) \\<le> component_of_term v", "by simp"], ["proof (state)\nthis:\n  component_of_term (lt p) \\<le> component_of_term v\n\ngoal (1 subgoal):\n 1. \\<not> t \\<preceq> lp p \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  lp p \\<preceq> pp_of_term v\n  component_of_term (lt p) \\<le> component_of_term v", "have \"lt p \\<preceq>\\<^sub>t v\""], ["proof (prove)\nusing this:\n  lp p \\<preceq> pp_of_term v\n  component_of_term (lt p) \\<le> component_of_term v\n\ngoal (1 subgoal):\n 1. lt p \\<preceq>\\<^sub>t v", "by (rule ord_termI)"], ["proof (state)\nthis:\n  lt p \\<preceq>\\<^sub>t v\n\ngoal (1 subgoal):\n 1. \\<not> t \\<preceq> lp p \\<Longrightarrow> False", "with \\<open>v \\<preceq>\\<^sub>t lt p\\<close>"], ["proof (chain)\npicking this:\n  v \\<preceq>\\<^sub>t lt p\n  lt p \\<preceq>\\<^sub>t v", "have \"v = lt p\""], ["proof (prove)\nusing this:\n  v \\<preceq>\\<^sub>t lt p\n  lt p \\<preceq>\\<^sub>t v\n\ngoal (1 subgoal):\n 1. v = lt p", "by (rule ord_term_lin.antisym)"], ["proof (state)\nthis:\n  v = lt p\n\ngoal (1 subgoal):\n 1. \\<not> t \\<preceq> lp p \\<Longrightarrow> False", "with \\<open>lp p \\<noteq> pp_of_term v\\<close>"], ["proof (chain)\npicking this:\n  lp p \\<noteq> pp_of_term v\n  v = lt p", "show False"], ["proof (prove)\nusing this:\n  lp p \\<noteq> pp_of_term v\n  v = lt p\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<preceq> lp p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  punit.lt (lookup (vectorize_poly p) (component_of_term (lt p))) = lp p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lower_higher_zeroI: \"u \\<preceq>\\<^sub>t v \\<Longrightarrow> lower (higher p v) u = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<preceq>\\<^sub>t v \\<Longrightarrow> lower (higher p v) u = 0", "by (simp add: lower_eq_zero_iff lookup_higher_when)"], ["", "lemma lookup_minus_higher: \"lookup (p - higher p v) u = (lookup p u when u \\<preceq>\\<^sub>t v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (p - higher p v) u = (lookup p u when u \\<preceq>\\<^sub>t v)", "by (auto simp: lookup_minus lookup_higher_when when_def)"], ["", "lemma keys_minus_higher: \"keys (p - higher p v) = {u \\<in> keys p. u \\<preceq>\\<^sub>t v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (p - higher p v) = {u \\<in> keys p. u \\<preceq>\\<^sub>t v}", "by (rule set_eqI, simp add: lookup_minus_higher conj_commute flip: lookup_not_eq_zero_eq_in_keys)"], ["", "lemma lt_minus_higher: \"v \\<in> keys p \\<Longrightarrow> lt (p - higher p v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> keys p \\<Longrightarrow> lt (p - higher p v) = v", "by (rule lt_eqI_keys, simp_all add: keys_minus_higher)"], ["", "lemma lc_minus_higher: \"v \\<in> keys p \\<Longrightarrow> lc (p - higher p v) = lookup p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> keys p \\<Longrightarrow> lc (p - higher p v) = lookup p v", "by (simp add: lc_def lt_minus_higher lookup_minus_higher)"], ["", "lemma tail_minus_higher: \"v \\<in> keys p \\<Longrightarrow> tail (p - higher p v) = lower p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> keys p \\<Longrightarrow> tail (p - higher p v) = lower p v", "by (rule poly_mapping_eqI, simp add: lookup_tail_when lt_minus_higher lookup_lower_when lookup_minus_higher cong: when_cong)"], ["", "end"], ["", "(* ordered_term *)"], ["", "subsection \\<open>@{const gd_term.dgrad_p_set}\\<close>"], ["", "lemma (in gd_term) dgrad_p_set_closed_mult_scalar:\n  assumes \"dickson_grading d\" and \"p \\<in> punit.dgrad_p_set d m\" and \"r \\<in> dgrad_p_set d m\"\n  shows \"p \\<odot> r \\<in> dgrad_p_set d m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<odot> r \\<in> dgrad_p_set d m", "proof (rule dgrad_p_setI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p \\<odot> r) \\<Longrightarrow> d (pp_of_term v) \\<le> m", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p \\<odot> r) \\<Longrightarrow> d (pp_of_term v) \\<le> m", "assume \"v \\<in> keys (p \\<odot> r)\""], ["proof (state)\nthis:\n  v \\<in> keys (p \\<odot> r)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p \\<odot> r) \\<Longrightarrow> d (pp_of_term v) \\<le> m", "then"], ["proof (chain)\npicking this:\n  v \\<in> keys (p \\<odot> r)", "obtain t u where \"t \\<in> keys p\" and \"u \\<in> keys r\" and v: \"v = t \\<oplus> u\""], ["proof (prove)\nusing this:\n  v \\<in> keys (p \\<odot> r)\n\ngoal (1 subgoal):\n 1. (\\<And>t u.\n        \\<lbrakk>t \\<in> keys p; u \\<in> keys r; v = t \\<oplus> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_mult_scalarE)"], ["proof (state)\nthis:\n  t \\<in> keys p\n  u \\<in> keys r\n  v = t \\<oplus> u\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p \\<odot> r) \\<Longrightarrow> d (pp_of_term v) \\<le> m", "from assms(2) \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> punit.dgrad_p_set d m\n  t \\<in> keys p", "have \"d t \\<le> m\""], ["proof (prove)\nusing this:\n  p \\<in> punit.dgrad_p_set d m\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. d t \\<le> m", "by (rule punit.dgrad_p_setD[simplified])"], ["proof (state)\nthis:\n  d t \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p \\<odot> r) \\<Longrightarrow> d (pp_of_term v) \\<le> m", "moreover"], ["proof (state)\nthis:\n  d t \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p \\<odot> r) \\<Longrightarrow> d (pp_of_term v) \\<le> m", "from assms(3) \\<open>u \\<in> keys r\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> dgrad_p_set d m\n  u \\<in> keys r", "have \"d (pp_of_term u) \\<le> m\""], ["proof (prove)\nusing this:\n  r \\<in> dgrad_p_set d m\n  u \\<in> keys r\n\ngoal (1 subgoal):\n 1. d (pp_of_term u) \\<le> m", "by (rule dgrad_p_setD)"], ["proof (state)\nthis:\n  d (pp_of_term u) \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p \\<odot> r) \\<Longrightarrow> d (pp_of_term v) \\<le> m", "ultimately"], ["proof (chain)\npicking this:\n  d t \\<le> m\n  d (pp_of_term u) \\<le> m", "have \"d (t + pp_of_term u) \\<le> m\""], ["proof (prove)\nusing this:\n  d t \\<le> m\n  d (pp_of_term u) \\<le> m\n\ngoal (1 subgoal):\n 1. d (t + pp_of_term u) \\<le> m", "using assms(1)"], ["proof (prove)\nusing this:\n  d t \\<le> m\n  d (pp_of_term u) \\<le> m\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. d (t + pp_of_term u) \\<le> m", "by (simp add: dickson_gradingD1)"], ["proof (state)\nthis:\n  d (t + pp_of_term u) \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> keys (p \\<odot> r) \\<Longrightarrow> d (pp_of_term v) \\<le> m", "thus \"d (pp_of_term v) \\<le> m\""], ["proof (prove)\nusing this:\n  d (t + pp_of_term u) \\<le> m\n\ngoal (1 subgoal):\n 1. d (pp_of_term v) \\<le> m", "by (simp only: v pp_of_term_splus)"], ["proof (state)\nthis:\n  d (pp_of_term v) \\<le> m\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Regular Sequences\\<close>"], ["", "definition is_regular_sequence :: \"('a::comm_powerprod \\<Rightarrow>\\<^sub>0 'b::comm_ring_1) list \\<Rightarrow> bool\"\n  where \"is_regular_sequence fs \\<longleftrightarrow> (\\<forall>j<length fs. \\<forall>q. q * fs ! j \\<in> ideal (set (take j fs)) \\<longrightarrow>\n                                                      q \\<in> ideal (set (take j fs)))\""], ["", "lemma is_regular_sequenceD:\n  \"is_regular_sequence fs \\<Longrightarrow> j < length fs \\<Longrightarrow> q * fs ! j \\<in> ideal (set (take j fs)) \\<Longrightarrow>\n    q \\<in> ideal (set (take j fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_regular_sequence fs; j < length fs;\n     q * fs ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n    \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "by (simp add: is_regular_sequence_def)"], ["", "lemma is_regular_sequence_Nil: \"is_regular_sequence []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_regular_sequence []", "by (simp add: is_regular_sequence_def)"], ["", "lemma is_regular_sequence_snocI:\n  assumes \"\\<And>q. q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\" and \"is_regular_sequence fs\"\n  shows \"is_regular_sequence (fs @ [f])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_regular_sequence (fs @ [f])", "proof (simp add: is_regular_sequence_def, intro impI allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < Suc (length fs);\n        q * (fs @ [f]) ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "fix j q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < Suc (length fs);\n        q * (fs @ [f]) ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "assume 1: \"j < Suc (length fs)\" and 2: \"q * (fs @ [f]) ! j \\<in> ideal (set (take j fs))\""], ["proof (state)\nthis:\n  j < Suc (length fs)\n  q * (fs @ [f]) ! j \\<in> ideal (set (take j fs))\n\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < Suc (length fs);\n        q * (fs @ [f]) ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "show \"q \\<in> ideal (set (take j fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> ideal (set (take j fs))", "proof (cases \"j = length fs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))\n 2. j \\<noteq> length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "case True"], ["proof (state)\nthis:\n  j = length fs\n\ngoal (2 subgoals):\n 1. j = length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))\n 2. j \\<noteq> length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "from 2"], ["proof (chain)\npicking this:\n  q * (fs @ [f]) ! j \\<in> ideal (set (take j fs))", "have \"q * f \\<in> ideal (set fs)\""], ["proof (prove)\nusing this:\n  q * (fs @ [f]) ! j \\<in> ideal (set (take j fs))\n\ngoal (1 subgoal):\n 1. q * f \\<in> ideal (set fs)", "by (simp add: True)"], ["proof (state)\nthis:\n  q * f \\<in> ideal (set fs)\n\ngoal (2 subgoals):\n 1. j = length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))\n 2. j \\<noteq> length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "hence \"q \\<in> ideal (set fs)\""], ["proof (prove)\nusing this:\n  q * f \\<in> ideal (set fs)\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (set fs)", "by (rule assms(1))"], ["proof (state)\nthis:\n  q \\<in> ideal (set fs)\n\ngoal (2 subgoals):\n 1. j = length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))\n 2. j \\<noteq> length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> ideal (set fs)\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (set (take j fs))", "by (simp add: True)"], ["proof (state)\nthis:\n  q \\<in> ideal (set (take j fs))\n\ngoal (1 subgoal):\n 1. j \\<noteq> length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "case False"], ["proof (state)\nthis:\n  j \\<noteq> length fs\n\ngoal (1 subgoal):\n 1. j \\<noteq> length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "with 1"], ["proof (chain)\npicking this:\n  j < Suc (length fs)\n  j \\<noteq> length fs", "have \"j < length fs\""], ["proof (prove)\nusing this:\n  j < Suc (length fs)\n  j \\<noteq> length fs\n\ngoal (1 subgoal):\n 1. j < length fs", "by simp"], ["proof (state)\nthis:\n  j < length fs\n\ngoal (1 subgoal):\n 1. j \\<noteq> length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "with 2"], ["proof (chain)\npicking this:\n  q * (fs @ [f]) ! j \\<in> ideal (set (take j fs))\n  j < length fs", "have \"q * fs ! j \\<in> ideal (set (take j fs))\""], ["proof (prove)\nusing this:\n  q * (fs @ [f]) ! j \\<in> ideal (set (take j fs))\n  j < length fs\n\ngoal (1 subgoal):\n 1. q * fs ! j \\<in> ideal (set (take j fs))", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  q * fs ! j \\<in> ideal (set (take j fs))\n\ngoal (1 subgoal):\n 1. j \\<noteq> length fs \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "with assms(2) \\<open>j < length fs\\<close>"], ["proof (chain)\npicking this:\n  is_regular_sequence fs\n  j < length fs\n  q * fs ! j \\<in> ideal (set (take j fs))", "show \"q \\<in> ideal (set (take j fs))\""], ["proof (prove)\nusing this:\n  is_regular_sequence fs\n  j < length fs\n  q * fs ! j \\<in> ideal (set (take j fs))\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (set (take j fs))", "by (rule is_regular_sequenceD)"], ["proof (state)\nthis:\n  q \\<in> ideal (set (take j fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<in> ideal (set (take j fs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_regular_sequence_snocD:\n  assumes \"is_regular_sequence (fs @ [f])\"\n  shows \"\\<And>q. q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\"\n    and \"is_regular_sequence fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q * f \\<in> ideal (set fs) \\<Longrightarrow>\n        q \\<in> ideal (set fs)) &&&\n    is_regular_sequence fs", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\n 2. is_regular_sequence fs", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\n 2. is_regular_sequence fs", "assume 1: \"q * f \\<in> ideal (set fs)\""], ["proof (state)\nthis:\n  q * f \\<in> ideal (set fs)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\n 2. is_regular_sequence fs", "note assms"], ["proof (state)\nthis:\n  is_regular_sequence (fs @ [f])\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\n 2. is_regular_sequence fs", "moreover"], ["proof (state)\nthis:\n  is_regular_sequence (fs @ [f])\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\n 2. is_regular_sequence fs", "have \"length fs < length (fs @ [f])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length fs < length (fs @ [f])", "by simp"], ["proof (state)\nthis:\n  length fs < length (fs @ [f])\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\n 2. is_regular_sequence fs", "moreover"], ["proof (state)\nthis:\n  length fs < length (fs @ [f])\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\n 2. is_regular_sequence fs", "from 1"], ["proof (chain)\npicking this:\n  q * f \\<in> ideal (set fs)", "have \"q * (fs @ [f]) ! (length fs) \\<in> ideal (set (take (length fs) (fs @ [f])))\""], ["proof (prove)\nusing this:\n  q * f \\<in> ideal (set fs)\n\ngoal (1 subgoal):\n 1. q * (fs @ [f]) ! length fs\n    \\<in> ideal (set (take (length fs) (fs @ [f])))", "by simp"], ["proof (state)\nthis:\n  q * (fs @ [f]) ! length fs \\<in> ideal (set (take (length fs) (fs @ [f])))\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\n 2. is_regular_sequence fs", "ultimately"], ["proof (chain)\npicking this:\n  is_regular_sequence (fs @ [f])\n  length fs < length (fs @ [f])\n  q * (fs @ [f]) ! length fs \\<in> ideal (set (take (length fs) (fs @ [f])))", "have \"q \\<in> ideal (set (take (length fs) (fs @ [f])))\""], ["proof (prove)\nusing this:\n  is_regular_sequence (fs @ [f])\n  length fs < length (fs @ [f])\n  q * (fs @ [f]) ! length fs \\<in> ideal (set (take (length fs) (fs @ [f])))\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (set (take (length fs) (fs @ [f])))", "by (rule is_regular_sequenceD)"], ["proof (state)\nthis:\n  q \\<in> ideal (set (take (length fs) (fs @ [f])))\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set fs) \\<Longrightarrow> q \\<in> ideal (set fs)\n 2. is_regular_sequence fs", "thus \"q \\<in> ideal (set fs)\""], ["proof (prove)\nusing this:\n  q \\<in> ideal (set (take (length fs) (fs @ [f])))\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (set fs)", "by simp"], ["proof (state)\nthis:\n  q \\<in> ideal (set fs)\n\ngoal (1 subgoal):\n 1. is_regular_sequence fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_regular_sequence fs", "show \"is_regular_sequence fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_regular_sequence fs", "unfolding is_regular_sequence_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<length fs.\n       \\<forall>q.\n          q * fs ! j \\<in> ideal (set (take j fs)) \\<longrightarrow>\n          q \\<in> ideal (set (take j fs))", "proof (intro impI allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < length fs;\n        q * fs ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "fix j q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < length fs;\n        q * fs ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "assume 1: \"j < length fs\" and 2: \"q * fs ! j \\<in> ideal (set (take j fs))\""], ["proof (state)\nthis:\n  j < length fs\n  q * fs ! j \\<in> ideal (set (take j fs))\n\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < length fs;\n        q * fs ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "note assms"], ["proof (state)\nthis:\n  is_regular_sequence (fs @ [f])\n\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < length fs;\n        q * fs ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "moreover"], ["proof (state)\nthis:\n  is_regular_sequence (fs @ [f])\n\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < length fs;\n        q * fs ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "from 1"], ["proof (chain)\npicking this:\n  j < length fs", "have \"j < length (fs @ [f])\""], ["proof (prove)\nusing this:\n  j < length fs\n\ngoal (1 subgoal):\n 1. j < length (fs @ [f])", "by simp"], ["proof (state)\nthis:\n  j < length (fs @ [f])\n\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < length fs;\n        q * fs ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "moreover"], ["proof (state)\nthis:\n  j < length (fs @ [f])\n\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < length fs;\n        q * fs ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "from 1 2"], ["proof (chain)\npicking this:\n  j < length fs\n  q * fs ! j \\<in> ideal (set (take j fs))", "have \"q * (fs @ [f]) ! j \\<in> ideal (set (take j (fs @ [f])))\""], ["proof (prove)\nusing this:\n  j < length fs\n  q * fs ! j \\<in> ideal (set (take j fs))\n\ngoal (1 subgoal):\n 1. q * (fs @ [f]) ! j \\<in> ideal (set (take j (fs @ [f])))", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  q * (fs @ [f]) ! j \\<in> ideal (set (take j (fs @ [f])))\n\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < length fs;\n        q * fs ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "ultimately"], ["proof (chain)\npicking this:\n  is_regular_sequence (fs @ [f])\n  j < length (fs @ [f])\n  q * (fs @ [f]) ! j \\<in> ideal (set (take j (fs @ [f])))", "have \"q \\<in> ideal (set (take j (fs @ [f])))\""], ["proof (prove)\nusing this:\n  is_regular_sequence (fs @ [f])\n  j < length (fs @ [f])\n  q * (fs @ [f]) ! j \\<in> ideal (set (take j (fs @ [f])))\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (set (take j (fs @ [f])))", "by (rule is_regular_sequenceD)"], ["proof (state)\nthis:\n  q \\<in> ideal (set (take j (fs @ [f])))\n\ngoal (1 subgoal):\n 1. \\<And>j q.\n       \\<lbrakk>j < length fs;\n        q * fs ! j \\<in> ideal (set (take j fs))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ideal (set (take j fs))", "with 1"], ["proof (chain)\npicking this:\n  j < length fs\n  q \\<in> ideal (set (take j (fs @ [f])))", "show \"q \\<in> ideal (set (take j fs))\""], ["proof (prove)\nusing this:\n  j < length fs\n  q \\<in> ideal (set (take j (fs @ [f])))\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (set (take j fs))", "by simp"], ["proof (state)\nthis:\n  q \\<in> ideal (set (take j fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_regular_sequence fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_regular_sequence_removeAll_zero:\n  assumes \"is_regular_sequence fs\"\n  shows \"is_regular_sequence (removeAll 0 fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_regular_sequence (removeAll 0 fs)", "using assms"], ["proof (prove)\nusing this:\n  is_regular_sequence fs\n\ngoal (1 subgoal):\n 1. is_regular_sequence (removeAll 0 fs)", "proof (induct fs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_regular_sequence [] \\<Longrightarrow>\n    is_regular_sequence (removeAll 0 [])\n 2. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (removeAll 0 xs);\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence (removeAll 0 (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  is_regular_sequence []\n\ngoal (2 subgoals):\n 1. is_regular_sequence [] \\<Longrightarrow>\n    is_regular_sequence (removeAll 0 [])\n 2. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (removeAll 0 xs);\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence (removeAll 0 (xs @ [x]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_regular_sequence (removeAll 0 [])", "by (simp add: is_regular_sequence_Nil)"], ["proof (state)\nthis:\n  is_regular_sequence (removeAll 0 [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (removeAll 0 xs);\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence (removeAll 0 (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (removeAll 0 xs);\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence (removeAll 0 (xs @ [x]))", "case (snoc f fs)"], ["proof (state)\nthis:\n  is_regular_sequence fs \\<Longrightarrow>\n  is_regular_sequence (removeAll 0 fs)\n  is_regular_sequence (fs @ [f])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (removeAll 0 xs);\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence (removeAll 0 (xs @ [x]))", "have \"set (removeAll 0 fs) = set fs - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (removeAll 0 fs) = set fs - {0}", "by simp"], ["proof (state)\nthis:\n  set (removeAll 0 fs) = set fs - {0}\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (removeAll 0 xs);\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence (removeAll 0 (xs @ [x]))", "also"], ["proof (state)\nthis:\n  set (removeAll 0 fs) = set fs - {0}\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (removeAll 0 xs);\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence (removeAll 0 (xs @ [x]))", "have \"ideal ... = ideal (set fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (set fs - {0}) = ideal (set fs)", "by (fact ideal.span_Diff_zero)"], ["proof (state)\nthis:\n  ideal (set fs - {0}) = ideal (set fs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (removeAll 0 xs);\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence (removeAll 0 (xs @ [x]))", "finally"], ["proof (chain)\npicking this:\n  ideal (set (removeAll 0 fs)) = ideal (set fs)", "have eq: \"ideal (set (removeAll 0 fs)) = ideal (set fs)\""], ["proof (prove)\nusing this:\n  ideal (set (removeAll 0 fs)) = ideal (set fs)\n\ngoal (1 subgoal):\n 1. ideal (set (removeAll 0 fs)) = ideal (set fs)", "."], ["proof (state)\nthis:\n  ideal (set (removeAll 0 fs)) = ideal (set fs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (removeAll 0 xs);\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence (removeAll 0 (xs @ [x]))", "from snoc(2)"], ["proof (chain)\npicking this:\n  is_regular_sequence (fs @ [f])", "have *: \"is_regular_sequence fs\""], ["proof (prove)\nusing this:\n  is_regular_sequence (fs @ [f])\n\ngoal (1 subgoal):\n 1. is_regular_sequence fs", "by (rule is_regular_sequence_snocD)"], ["proof (state)\nthis:\n  is_regular_sequence fs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (removeAll 0 xs);\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence (removeAll 0 (xs @ [x]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_regular_sequence (removeAll 0 (fs @ [f]))", "proof (simp, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> is_regular_sequence (removeAll 0 fs)\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    is_regular_sequence (removeAll 0 fs @ [f])", "show \"is_regular_sequence (removeAll 0 fs @ [f])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_regular_sequence (removeAll 0 fs @ [f])", "proof (rule is_regular_sequence_snocI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set (removeAll 0 fs)) \\<Longrightarrow>\n       q \\<in> ideal (set (removeAll 0 fs))\n 2. is_regular_sequence (removeAll 0 fs)", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set (removeAll 0 fs)) \\<Longrightarrow>\n       q \\<in> ideal (set (removeAll 0 fs))\n 2. is_regular_sequence (removeAll 0 fs)", "assume \"q * f \\<in> ideal (set (removeAll 0 fs))\""], ["proof (state)\nthis:\n  q * f \\<in> ideal (set (removeAll 0 fs))\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set (removeAll 0 fs)) \\<Longrightarrow>\n       q \\<in> ideal (set (removeAll 0 fs))\n 2. is_regular_sequence (removeAll 0 fs)", "hence \"q * f \\<in> ideal (set fs)\""], ["proof (prove)\nusing this:\n  q * f \\<in> ideal (set (removeAll 0 fs))\n\ngoal (1 subgoal):\n 1. q * f \\<in> ideal (set fs)", "by (simp only: eq)"], ["proof (state)\nthis:\n  q * f \\<in> ideal (set fs)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set (removeAll 0 fs)) \\<Longrightarrow>\n       q \\<in> ideal (set (removeAll 0 fs))\n 2. is_regular_sequence (removeAll 0 fs)", "with snoc(2)"], ["proof (chain)\npicking this:\n  is_regular_sequence (fs @ [f])\n  q * f \\<in> ideal (set fs)", "have \"q \\<in> ideal (set fs)\""], ["proof (prove)\nusing this:\n  is_regular_sequence (fs @ [f])\n  q * f \\<in> ideal (set fs)\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (set fs)", "by (rule is_regular_sequence_snocD)"], ["proof (state)\nthis:\n  q \\<in> ideal (set fs)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set (removeAll 0 fs)) \\<Longrightarrow>\n       q \\<in> ideal (set (removeAll 0 fs))\n 2. is_regular_sequence (removeAll 0 fs)", "thus \"q \\<in> ideal (set (removeAll 0 fs))\""], ["proof (prove)\nusing this:\n  q \\<in> ideal (set fs)\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (set (removeAll 0 fs))", "by (simp only: eq)"], ["proof (state)\nthis:\n  q \\<in> ideal (set (removeAll 0 fs))\n\ngoal (1 subgoal):\n 1. is_regular_sequence (removeAll 0 fs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_regular_sequence (removeAll 0 fs)", "from *"], ["proof (chain)\npicking this:\n  is_regular_sequence fs", "show \"is_regular_sequence (removeAll 0 fs)\""], ["proof (prove)\nusing this:\n  is_regular_sequence fs\n\ngoal (1 subgoal):\n 1. is_regular_sequence (removeAll 0 fs)", "by (rule snoc.hyps)"], ["proof (state)\nthis:\n  is_regular_sequence (removeAll 0 fs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_regular_sequence (removeAll 0 fs @ [f])\n\ngoal (1 subgoal):\n 1. f = 0 \\<Longrightarrow> is_regular_sequence (removeAll 0 fs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f = 0 \\<Longrightarrow> is_regular_sequence (removeAll 0 fs)", "from *"], ["proof (chain)\npicking this:\n  is_regular_sequence fs", "show \"is_regular_sequence (removeAll 0 fs)\""], ["proof (prove)\nusing this:\n  is_regular_sequence fs\n\ngoal (1 subgoal):\n 1. is_regular_sequence (removeAll 0 fs)", "by (rule snoc.hyps)"], ["proof (state)\nthis:\n  is_regular_sequence (removeAll 0 fs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_regular_sequence (removeAll 0 (fs @ [f]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_regular_sequence_remdups:\n  assumes \"is_regular_sequence fs\"\n  shows \"is_regular_sequence (rev (remdups (rev fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_regular_sequence (rev (remdups (rev fs)))", "using assms"], ["proof (prove)\nusing this:\n  is_regular_sequence fs\n\ngoal (1 subgoal):\n 1. is_regular_sequence (rev (remdups (rev fs)))", "proof (induct fs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_regular_sequence [] \\<Longrightarrow>\n    is_regular_sequence (rev (remdups (rev [])))\n 2. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (rev (remdups (rev xs)));\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence\n                          (rev (remdups (rev (xs @ [x]))))", "case Nil"], ["proof (state)\nthis:\n  is_regular_sequence []\n\ngoal (2 subgoals):\n 1. is_regular_sequence [] \\<Longrightarrow>\n    is_regular_sequence (rev (remdups (rev [])))\n 2. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (rev (remdups (rev xs)));\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence\n                          (rev (remdups (rev (xs @ [x]))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_regular_sequence (rev (remdups (rev [])))", "by (simp add: is_regular_sequence_Nil)"], ["proof (state)\nthis:\n  is_regular_sequence (rev (remdups (rev [])))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (rev (remdups (rev xs)));\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence\n                          (rev (remdups (rev (xs @ [x]))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (rev (remdups (rev xs)));\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence\n                          (rev (remdups (rev (xs @ [x]))))", "case (snoc f fs)"], ["proof (state)\nthis:\n  is_regular_sequence fs \\<Longrightarrow>\n  is_regular_sequence (rev (remdups (rev fs)))\n  is_regular_sequence (fs @ [f])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (rev (remdups (rev xs)));\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence\n                          (rev (remdups (rev (xs @ [x]))))", "from snoc(2)"], ["proof (chain)\npicking this:\n  is_regular_sequence (fs @ [f])", "have *: \"is_regular_sequence fs\""], ["proof (prove)\nusing this:\n  is_regular_sequence (fs @ [f])\n\ngoal (1 subgoal):\n 1. is_regular_sequence fs", "by (rule is_regular_sequence_snocD)"], ["proof (state)\nthis:\n  is_regular_sequence fs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>is_regular_sequence xs \\<Longrightarrow>\n                is_regular_sequence (rev (remdups (rev xs)));\n        is_regular_sequence (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> is_regular_sequence\n                          (rev (remdups (rev (xs @ [x]))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_regular_sequence (rev (remdups (rev (fs @ [f]))))", "proof (simp, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> set fs \\<Longrightarrow>\n    is_regular_sequence (rev (remdups (rev fs)))\n 2. f \\<notin> set fs \\<Longrightarrow>\n    is_regular_sequence (rev (remdups (rev fs)) @ [f])", "show \"is_regular_sequence (rev (remdups (rev fs)) @ [f])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_regular_sequence (rev (remdups (rev fs)) @ [f])", "proof (rule is_regular_sequence_snocI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set (rev (remdups (rev fs)))) \\<Longrightarrow>\n       q \\<in> ideal (set (rev (remdups (rev fs))))\n 2. is_regular_sequence (rev (remdups (rev fs)))", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set (rev (remdups (rev fs)))) \\<Longrightarrow>\n       q \\<in> ideal (set (rev (remdups (rev fs))))\n 2. is_regular_sequence (rev (remdups (rev fs)))", "assume \"q * f \\<in> ideal (set (rev (remdups (rev fs))))\""], ["proof (state)\nthis:\n  q * f \\<in> ideal (set (rev (remdups (rev fs))))\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set (rev (remdups (rev fs)))) \\<Longrightarrow>\n       q \\<in> ideal (set (rev (remdups (rev fs))))\n 2. is_regular_sequence (rev (remdups (rev fs)))", "hence \"q * f \\<in> ideal (set fs)\""], ["proof (prove)\nusing this:\n  q * f \\<in> ideal (set (rev (remdups (rev fs))))\n\ngoal (1 subgoal):\n 1. q * f \\<in> ideal (set fs)", "by simp"], ["proof (state)\nthis:\n  q * f \\<in> ideal (set fs)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set (rev (remdups (rev fs)))) \\<Longrightarrow>\n       q \\<in> ideal (set (rev (remdups (rev fs))))\n 2. is_regular_sequence (rev (remdups (rev fs)))", "with snoc(2)"], ["proof (chain)\npicking this:\n  is_regular_sequence (fs @ [f])\n  q * f \\<in> ideal (set fs)", "have \"q \\<in> ideal (set fs)\""], ["proof (prove)\nusing this:\n  is_regular_sequence (fs @ [f])\n  q * f \\<in> ideal (set fs)\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (set fs)", "by (rule is_regular_sequence_snocD)"], ["proof (state)\nthis:\n  q \\<in> ideal (set fs)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q * f \\<in> ideal (set (rev (remdups (rev fs)))) \\<Longrightarrow>\n       q \\<in> ideal (set (rev (remdups (rev fs))))\n 2. is_regular_sequence (rev (remdups (rev fs)))", "thus \"q \\<in> ideal (set (rev (remdups (rev fs))))\""], ["proof (prove)\nusing this:\n  q \\<in> ideal (set fs)\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (set (rev (remdups (rev fs))))", "by simp"], ["proof (state)\nthis:\n  q \\<in> ideal (set (rev (remdups (rev fs))))\n\ngoal (1 subgoal):\n 1. is_regular_sequence (rev (remdups (rev fs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_regular_sequence (rev (remdups (rev fs)))", "from *"], ["proof (chain)\npicking this:\n  is_regular_sequence fs", "show \"is_regular_sequence (rev (remdups (rev fs)))\""], ["proof (prove)\nusing this:\n  is_regular_sequence fs\n\ngoal (1 subgoal):\n 1. is_regular_sequence (rev (remdups (rev fs)))", "by (rule snoc.hyps)"], ["proof (state)\nthis:\n  is_regular_sequence (rev (remdups (rev fs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_regular_sequence (rev (remdups (rev fs)) @ [f])\n\ngoal (1 subgoal):\n 1. f \\<in> set fs \\<Longrightarrow>\n    is_regular_sequence (rev (remdups (rev fs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> set fs \\<Longrightarrow>\n    is_regular_sequence (rev (remdups (rev fs)))", "from *"], ["proof (chain)\npicking this:\n  is_regular_sequence fs", "show \"is_regular_sequence (rev (remdups (rev fs)))\""], ["proof (prove)\nusing this:\n  is_regular_sequence fs\n\ngoal (1 subgoal):\n 1. is_regular_sequence (rev (remdups (rev fs)))", "by (rule snoc.hyps)"], ["proof (state)\nthis:\n  is_regular_sequence (rev (remdups (rev fs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_regular_sequence (rev (remdups (rev (fs @ [f]))))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* theory *)"]]}