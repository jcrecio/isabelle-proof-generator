{"file_name": "/home/qj213/afp-2021-10-22/thys/Signature_Groebner/Prelims.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Signature_Groebner", "problem_names": ["lemma list_seq_length_mono:\n  fixes seq :: \"nat \\<Rightarrow> 'a list\"\n  assumes \"\\<And>i. (\\<exists>x. seq (Suc i) = x # seq i)\" and \"i < j\"\n  shows \"length (seq i) < length (seq j)\"", "lemma list_seq_indexE_length:\n  fixes seq :: \"nat \\<Rightarrow> 'a list\"\n  assumes \"\\<And>i. (\\<exists>x. seq (Suc i) = x # seq i)\"\n  obtains j where \"i < length (seq j)\"", "lemma list_seq_nth:\n  fixes seq :: \"nat \\<Rightarrow> 'a list\"\n  assumes \"\\<And>i. (\\<exists>x. seq (Suc i) = x # seq i)\" and \"i < length (seq j)\" and \"j \\<le> k\"\n  shows \"rev (seq k) ! i = rev (seq j) ! i\"", "lemma filter_merge_wrt_1:\n  assumes \"\\<And>y. y \\<in> set ys \\<Longrightarrow> P y \\<Longrightarrow> False\"\n  shows \"filter P (merge_wrt rel xs ys) = filter P xs\"", "lemma filter_merge_wrt_2:\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> P x \\<Longrightarrow> False\"\n  shows \"filter P (merge_wrt rel xs ys) = filter P ys\"", "lemma length_filter_le_1:\n  assumes \"length (filter P xs) \\<le> 1\" and \"i < length xs\" and \"j < length xs\"\n    and \"P (xs ! i)\" and \"P (xs ! j)\"\n  shows \"i = j\"", "lemma length_filter_eq [simp]: \"length (filter ((=) x) xs) = count_list xs x\"", "lemma nth_in_set_dropI:\n  assumes \"j \\<le> i\" and \"i < length xs\"\n  shows \"xs ! i \\<in> set (drop j xs)\"", "lemma count_list_append [simp]: \"count_list (xs @ ys) a = count_list xs a + count_list ys a\"", "lemma count_list_upt [simp]: \"count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)\"", "lemma sorted_wrt_upt_iff: \"sorted_wrt rel [a..<b] \\<longleftrightarrow> (\\<forall>i j. a \\<le> i \\<longrightarrow> i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)\"", "lemma map_insort_wrt:\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> r2 (f y) (f x) \\<longleftrightarrow> r1 y x\"\n  shows \"map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs)\"", "lemma map_merge_wrt:\n  assumes \"f ` set xs \\<inter> f ` set ys = {}\"\n    and \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> r2 (f x) (f y) \\<longleftrightarrow> r1 x y\"\n  shows \"map f (merge_wrt r1 xs ys) = merge_wrt r2 (map f xs) (map f ys)\"", "lemmas [induct del] = recfun_aux.pinduct", "lemma domI:\n  assumes \"\\<not> Q x \\<Longrightarrow> dom (h x)\"\n  shows \"dom x\"", "lemma domD:\n  assumes \"dom x\" and \"\\<not> Q x\"\n  shows \"dom (h x)\"", "lemma recfun_aux_domI:\n  assumes \"dom x\"\n  shows \"recfun_aux_dom x\"", "lemma recfun_aux_domD:\n  assumes \"recfun_aux_dom x\"\n  shows \"dom x\"", "lemma simps: \"fun x = (if Q x then g x else h' (fun (h x)))\"", "lemma eq_fixpointI: \"\\<not> dom x \\<Longrightarrow> fun x = b\"", "lemma pinduct: \"dom x \\<Longrightarrow> (\\<And>x. dom x \\<Longrightarrow> (\\<not> Q x \\<Longrightarrow> P (h x)) \\<Longrightarrow> P x) \\<Longrightarrow> P x\"", "lemma almost_full_on_Int:\n  assumes \"almost_full_on P1 A1\" and \"almost_full_on P2 A2\"\n  shows \"almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) (A1 \\<inter> A2)\" (is \"almost_full_on ?P ?A\")", "lemma is_le_relI [simp]: \"is_le_rel (=)\" \"is_le_rel (\\<le>)\" \"is_le_rel (<)\"", "lemma is_le_relE:\n  assumes \"is_le_rel rel\"\n  obtains \"rel = (=)\" | \"rel = (\\<le>)\" | \"rel = (<)\"", "lemma is_le_rel_le:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> x \\<le> y\"", "lemma is_le_rel_trans:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> rel y z \\<Longrightarrow> rel x z\"", "lemma is_le_rel_trans_le_left:\n  assumes \"is_le_rel rel\"\n  shows \"x \\<le> y \\<Longrightarrow> rel y z \\<Longrightarrow> x \\<le> z\"", "lemma is_le_rel_trans_le_right:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> z\"", "lemma is_le_rel_trans_less_left:\n  assumes \"is_le_rel rel\"\n  shows \"x < y \\<Longrightarrow> rel y z \\<Longrightarrow> x < z\"", "lemma is_le_rel_trans_less_right:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> y < z \\<Longrightarrow> x < z\"", "lemma is_le_rel_distinct:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> x < y\"", "lemma is_le_rel_antisym:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> rel y x \\<Longrightarrow> x = y\""], "translations": [["", "lemma list_seq_length_mono:\n  fixes seq :: \"nat \\<Rightarrow> 'a list\"\n  assumes \"\\<And>i. (\\<exists>x. seq (Suc i) = x # seq i)\" and \"i < j\"\n  shows \"length (seq i) < length (seq j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (seq i) < length (seq j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (seq i) < length (seq j)", "from assms(2)"], ["proof (chain)\npicking this:\n  i < j", "obtain k where \"j = Suc (i + k)\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. (\\<And>k. j = Suc (i + k) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less_iff_Suc_add"], ["proof (prove)\nusing this:\n  i < j\n  (?m < ?n) = (\\<exists>k. ?n = Suc (?m + k))\n\ngoal (1 subgoal):\n 1. (\\<And>k. j = Suc (i + k) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j = Suc (i + k)\n\ngoal (1 subgoal):\n 1. length (seq i) < length (seq j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (seq i) < length (seq j)", "unfolding \\<open>j = Suc (i + k)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (seq i) < length (seq (Suc (i + k)))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (seq i) < length (seq (Suc (i + 0)))\n 2. \\<And>k.\n       length (seq i) < length (seq (Suc (i + k))) \\<Longrightarrow>\n       length (seq i) < length (seq (Suc (i + Suc k)))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. length (seq i) < length (seq (Suc (i + 0)))\n 2. \\<And>k.\n       length (seq i) < length (seq (Suc (i + k))) \\<Longrightarrow>\n       length (seq i) < length (seq (Suc (i + Suc k)))", "from assms(1)"], ["proof (chain)\npicking this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i", "obtain x where eq: \"seq (Suc i) = x # seq i\""], ["proof (prove)\nusing this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        seq (Suc i) = x # seq i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  seq (Suc i) = x # seq i\n\ngoal (2 subgoals):\n 1. length (seq i) < length (seq (Suc (i + 0)))\n 2. \\<And>k.\n       length (seq i) < length (seq (Suc (i + k))) \\<Longrightarrow>\n       length (seq i) < length (seq (Suc (i + Suc k)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (seq i) < length (seq (Suc (i + 0)))", "by (simp add: eq)"], ["proof (state)\nthis:\n  length (seq i) < length (seq (Suc (i + 0)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       length (seq i) < length (seq (Suc (i + k))) \\<Longrightarrow>\n       length (seq i) < length (seq (Suc (i + Suc k)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       length (seq i) < length (seq (Suc (i + k))) \\<Longrightarrow>\n       length (seq i) < length (seq (Suc (i + Suc k)))", "case (Suc k)"], ["proof (state)\nthis:\n  length (seq i) < length (seq (Suc (i + k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       length (seq i) < length (seq (Suc (i + k))) \\<Longrightarrow>\n       length (seq i) < length (seq (Suc (i + Suc k)))", "from assms(1)"], ["proof (chain)\npicking this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i", "obtain x where \"seq (Suc (i + Suc k)) = x # seq (i + Suc k)\""], ["proof (prove)\nusing this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        seq (Suc (i + Suc k)) = x # seq (i + Suc k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  seq (Suc (i + Suc k)) = x # seq (i + Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       length (seq i) < length (seq (Suc (i + k))) \\<Longrightarrow>\n       length (seq i) < length (seq (Suc (i + Suc k)))", "hence eq: \"seq (Suc (Suc (i + k))) = x # seq (Suc (i + k))\""], ["proof (prove)\nusing this:\n  seq (Suc (i + Suc k)) = x # seq (i + Suc k)\n\ngoal (1 subgoal):\n 1. seq (Suc (Suc (i + k))) = x # seq (Suc (i + k))", "by simp"], ["proof (state)\nthis:\n  seq (Suc (Suc (i + k))) = x # seq (Suc (i + k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       length (seq i) < length (seq (Suc (i + k))) \\<Longrightarrow>\n       length (seq i) < length (seq (Suc (i + Suc k)))", "note Suc"], ["proof (state)\nthis:\n  length (seq i) < length (seq (Suc (i + k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       length (seq i) < length (seq (Suc (i + k))) \\<Longrightarrow>\n       length (seq i) < length (seq (Suc (i + Suc k)))", "also"], ["proof (state)\nthis:\n  length (seq i) < length (seq (Suc (i + k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       length (seq i) < length (seq (Suc (i + k))) \\<Longrightarrow>\n       length (seq i) < length (seq (Suc (i + Suc k)))", "have \"length (seq (Suc (i + k))) < length (seq (Suc (i + Suc k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (seq (Suc (i + k))) < length (seq (Suc (i + Suc k)))", "by (simp add: eq)"], ["proof (state)\nthis:\n  length (seq (Suc (i + k))) < length (seq (Suc (i + Suc k)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       length (seq i) < length (seq (Suc (i + k))) \\<Longrightarrow>\n       length (seq i) < length (seq (Suc (i + Suc k)))", "finally"], ["proof (chain)\npicking this:\n  length (seq i) < length (seq (Suc (i + Suc k)))", "show ?case"], ["proof (prove)\nusing this:\n  length (seq i) < length (seq (Suc (i + Suc k)))\n\ngoal (1 subgoal):\n 1. length (seq i) < length (seq (Suc (i + Suc k)))", "."], ["proof (state)\nthis:\n  length (seq i) < length (seq (Suc (i + Suc k)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (seq i) < length (seq j)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary list_seq_length_mono_weak:\n  fixes seq :: \"nat \\<Rightarrow> 'a list\"\n  assumes \"\\<And>i. (\\<exists>x. seq (Suc i) = x # seq i)\" and \"i \\<le> j\"\n  shows \"length (seq i) \\<le> length (seq j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (seq i) \\<le> length (seq j)", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> length (seq i) \\<le> length (seq j)\n 2. i \\<noteq> j \\<Longrightarrow> length (seq i) \\<le> length (seq j)", "case True"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> length (seq i) \\<le> length (seq j)\n 2. i \\<noteq> j \\<Longrightarrow> length (seq i) \\<le> length (seq j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. length (seq i) \\<le> length (seq j)", "by simp"], ["proof (state)\nthis:\n  length (seq i) \\<le> length (seq j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> length (seq i) \\<le> length (seq j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> length (seq i) \\<le> length (seq j)", "case False"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> length (seq i) \\<le> length (seq j)", "with assms(2)"], ["proof (chain)\npicking this:\n  i \\<le> j\n  i \\<noteq> j", "have \"i < j\""], ["proof (prove)\nusing this:\n  i \\<le> j\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i < j", "by simp"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> length (seq i) \\<le> length (seq j)", "with assms(1)"], ["proof (chain)\npicking this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  i < j", "have \"length (seq i) < length (seq j)\""], ["proof (prove)\nusing this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  i < j\n\ngoal (1 subgoal):\n 1. length (seq i) < length (seq j)", "by (rule list_seq_length_mono)"], ["proof (state)\nthis:\n  length (seq i) < length (seq j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> length (seq i) \\<le> length (seq j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (seq i) < length (seq j)\n\ngoal (1 subgoal):\n 1. length (seq i) \\<le> length (seq j)", "by simp"], ["proof (state)\nthis:\n  length (seq i) \\<le> length (seq j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_seq_indexE_length:\n  fixes seq :: \"nat \\<Rightarrow> 'a list\"\n  assumes \"\\<And>i. (\\<exists>x. seq (Suc i) = x # seq i)\"\n  obtains j where \"i < length (seq j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j. i < length (seq j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct i arbitrary: thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>j.\n           0 < length (seq j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case 0"], ["proof (state)\nthis:\n  0 < length (seq ?j) \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>j.\n           0 < length (seq j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"0 \\<le> length (seq 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> length (seq 0)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> length (seq 0)\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>j.\n           0 < length (seq j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  0 \\<le> length (seq 0)\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>j.\n           0 < length (seq j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from assms lessI"], ["proof (chain)\npicking this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  ?n < Suc ?n", "have \"... < length (seq (Suc 0))\""], ["proof (prove)\nusing this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  ?n < Suc ?n\n\ngoal (1 subgoal):\n 1. length (seq 0) < length (seq (Suc 0))", "by (rule list_seq_length_mono)"], ["proof (state)\nthis:\n  length (seq 0) < length (seq (Suc 0))\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>j.\n           0 < length (seq j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  0 < length (seq (Suc 0))", "show ?case"], ["proof (prove)\nusing this:\n  0 < length (seq (Suc 0))\n\ngoal (1 subgoal):\n 1. thesis", "by (rule 0)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Suc i)"], ["proof (state)\nthis:\n  (\\<And>j. i < length (seq j) \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  Suc i < length (seq ?j) \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain j where \"i < length (seq j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j. i < length (seq j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule Suc(1))"], ["proof (state)\nthis:\n  i < length (seq j)\n\ngoal (1 subgoal):\n 1. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"Suc i \\<le> length (seq j)\""], ["proof (prove)\nusing this:\n  i < length (seq j)\n\ngoal (1 subgoal):\n 1. Suc i \\<le> length (seq j)", "by simp"], ["proof (state)\nthis:\n  Suc i \\<le> length (seq j)\n\ngoal (1 subgoal):\n 1. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  Suc i \\<le> length (seq j)\n\ngoal (1 subgoal):\n 1. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from assms lessI"], ["proof (chain)\npicking this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  ?n < Suc ?n", "have \"... < length (seq (Suc j))\""], ["proof (prove)\nusing this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  ?n < Suc ?n\n\ngoal (1 subgoal):\n 1. length (seq j) < length (seq (Suc j))", "by (rule list_seq_length_mono)"], ["proof (state)\nthis:\n  length (seq j) < length (seq (Suc j))\n\ngoal (1 subgoal):\n 1. \\<And>i thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>j.\n                       i < length (seq j) \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>j. Suc i < length (seq j) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  Suc i < length (seq (Suc j))", "show ?case"], ["proof (prove)\nusing this:\n  Suc i < length (seq (Suc j))\n\ngoal (1 subgoal):\n 1. thesis", "by (rule Suc(2))"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_seq_nth:\n  fixes seq :: \"nat \\<Rightarrow> 'a list\"\n  assumes \"\\<And>i. (\\<exists>x. seq (Suc i) = x # seq i)\" and \"i < length (seq j)\" and \"j \\<le> k\"\n  shows \"rev (seq k) ! i = rev (seq j) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (seq k) ! i = rev (seq j) ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rev (seq k) ! i = rev (seq j) ! i", "from assms(3)"], ["proof (chain)\npicking this:\n  j \\<le> k", "obtain l where \"k = j + l\""], ["proof (prove)\nusing this:\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>l. k = j + l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using nat_le_iff_add"], ["proof (prove)\nusing this:\n  j \\<le> k\n  (?m \\<le> ?n) = (\\<exists>k. ?n = ?m + k)\n\ngoal (1 subgoal):\n 1. (\\<And>l. k = j + l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  k = j + l\n\ngoal (1 subgoal):\n 1. rev (seq k) ! i = rev (seq j) ! i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (seq k) ! i = rev (seq j) ! i", "unfolding \\<open>k = j + l\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (seq (j + l)) ! i = rev (seq j) ! i", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. rev (seq (j + 0)) ! i = rev (seq j) ! i\n 2. \\<And>l.\n       rev (seq (j + l)) ! i = rev (seq j) ! i \\<Longrightarrow>\n       rev (seq (j + Suc l)) ! i = rev (seq j) ! i", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. rev (seq (j + 0)) ! i = rev (seq j) ! i\n 2. \\<And>l.\n       rev (seq (j + l)) ! i = rev (seq j) ! i \\<Longrightarrow>\n       rev (seq (j + Suc l)) ! i = rev (seq j) ! i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (seq (j + 0)) ! i = rev (seq j) ! i", "by simp"], ["proof (state)\nthis:\n  rev (seq (j + 0)) ! i = rev (seq j) ! i\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       rev (seq (j + l)) ! i = rev (seq j) ! i \\<Longrightarrow>\n       rev (seq (j + Suc l)) ! i = rev (seq j) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       rev (seq (j + l)) ! i = rev (seq j) ! i \\<Longrightarrow>\n       rev (seq (j + Suc l)) ! i = rev (seq j) ! i", "case (Suc l)"], ["proof (state)\nthis:\n  rev (seq (j + l)) ! i = rev (seq j) ! i\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       rev (seq (j + l)) ! i = rev (seq j) ! i \\<Longrightarrow>\n       rev (seq (j + Suc l)) ! i = rev (seq j) ! i", "note assms(2)"], ["proof (state)\nthis:\n  i < length (seq j)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       rev (seq (j + l)) ! i = rev (seq j) ! i \\<Longrightarrow>\n       rev (seq (j + Suc l)) ! i = rev (seq j) ! i", "also"], ["proof (state)\nthis:\n  i < length (seq j)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       rev (seq (j + l)) ! i = rev (seq j) ! i \\<Longrightarrow>\n       rev (seq (j + Suc l)) ! i = rev (seq j) ! i", "from assms(1) le_add1"], ["proof (chain)\npicking this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  ?n \\<le> ?n + ?m", "have \"length (seq j) \\<le> length (seq (j + l))\""], ["proof (prove)\nusing this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  ?n \\<le> ?n + ?m\n\ngoal (1 subgoal):\n 1. length (seq j) \\<le> length (seq (j + l))", "by (rule list_seq_length_mono_weak)"], ["proof (state)\nthis:\n  length (seq j) \\<le> length (seq (j + l))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       rev (seq (j + l)) ! i = rev (seq j) ! i \\<Longrightarrow>\n       rev (seq (j + Suc l)) ! i = rev (seq j) ! i", "finally"], ["proof (chain)\npicking this:\n  i < length (seq (j + l))", "have i: \"i < length (seq (j + l))\""], ["proof (prove)\nusing this:\n  i < length (seq (j + l))\n\ngoal (1 subgoal):\n 1. i < length (seq (j + l))", "."], ["proof (state)\nthis:\n  i < length (seq (j + l))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       rev (seq (j + l)) ! i = rev (seq j) ! i \\<Longrightarrow>\n       rev (seq (j + Suc l)) ! i = rev (seq j) ! i", "from assms(1)"], ["proof (chain)\npicking this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i", "obtain x where \"seq (Suc (j + l)) = x # seq (j + l)\""], ["proof (prove)\nusing this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        seq (Suc (j + l)) = x # seq (j + l) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  seq (Suc (j + l)) = x # seq (j + l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       rev (seq (j + l)) ! i = rev (seq j) ! i \\<Longrightarrow>\n       rev (seq (j + Suc l)) ! i = rev (seq j) ! i", "thus ?case"], ["proof (prove)\nusing this:\n  seq (Suc (j + l)) = x # seq (j + l)\n\ngoal (1 subgoal):\n 1. rev (seq (j + Suc l)) ! i = rev (seq j) ! i", "by (simp add: nth_append i Suc)"], ["proof (state)\nthis:\n  rev (seq (j + Suc l)) ! i = rev (seq j) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rev (seq k) ! i = rev (seq j) ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary list_seq_nth':\n  fixes seq :: \"nat \\<Rightarrow> 'a list\"\n  assumes \"\\<And>i. (\\<exists>x. seq (Suc i) = x # seq i)\" and \"i < length (seq j)\" and \"i < length (seq k)\"\n  shows \"rev (seq k) ! i = rev (seq j) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (seq k) ! i = rev (seq j) ! i", "proof (rule linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i\n 2. ?x = ?y \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i\n 3. ?y < ?x \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i", "assume \"j < k\""], ["proof (state)\nthis:\n  j < k\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i\n 2. ?x = ?y \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i\n 3. ?y < ?x \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i", "hence \"j \\<le> k\""], ["proof (prove)\nusing this:\n  j < k\n\ngoal (1 subgoal):\n 1. j \\<le> k", "by simp"], ["proof (state)\nthis:\n  j \\<le> k\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i\n 2. ?x = ?y \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i\n 3. ?y < ?x \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  i < length (seq j)\n  j \\<le> k", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  i < length (seq j)\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. rev (seq k) ! i = rev (seq j) ! i", "by (rule list_seq_nth)"], ["proof (state)\nthis:\n  rev (seq k) ! i = rev (seq j) ! i\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i\n 2. k < j \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i\n 2. k < j \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i", "assume \"k < j\""], ["proof (state)\nthis:\n  k < j\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i\n 2. k < j \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i", "hence \"k \\<le> j\""], ["proof (prove)\nusing this:\n  k < j\n\ngoal (1 subgoal):\n 1. k \\<le> j", "by simp"], ["proof (state)\nthis:\n  k \\<le> j\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i\n 2. k < j \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i", "with assms(1, 3)"], ["proof (chain)\npicking this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  i < length (seq k)\n  k \\<le> j", "have \"rev (seq j) ! i = rev (seq k) ! i\""], ["proof (prove)\nusing this:\n  \\<exists>x. seq (Suc ?i) = x # seq ?i\n  i < length (seq k)\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. rev (seq j) ! i = rev (seq k) ! i", "by (rule list_seq_nth)"], ["proof (state)\nthis:\n  rev (seq j) ! i = rev (seq k) ! i\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i\n 2. k < j \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  rev (seq j) ! i = rev (seq k) ! i\n\ngoal (1 subgoal):\n 1. rev (seq k) ! i = rev (seq j) ! i", "by (rule HOL.sym)"], ["proof (state)\nthis:\n  rev (seq k) ! i = rev (seq j) ! i\n\ngoal (1 subgoal):\n 1. j = k \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j = k \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i", "assume \"j = k\""], ["proof (state)\nthis:\n  j = k\n\ngoal (1 subgoal):\n 1. j = k \\<Longrightarrow> rev (seq k) ! i = rev (seq j) ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  j = k\n\ngoal (1 subgoal):\n 1. rev (seq k) ! i = rev (seq j) ! i", "by simp"], ["proof (state)\nthis:\n  rev (seq k) ! i = rev (seq j) ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const filter}\\<close>"], ["", "lemma filter_merge_wrt_1:\n  assumes \"\\<And>y. y \\<in> set ys \\<Longrightarrow> P y \\<Longrightarrow> False\"\n  shows \"filter P (merge_wrt rel xs ys) = filter P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs ys) = filter P xs", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> set ys; P ?y\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs ys) = filter P xs", "proof (induct rel xs ys rule: merge_wrt.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ xs.\n       (\\<And>y.\n           \\<lbrakk>y \\<in> set []; P y\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt uu_ xs []) = filter P xs\n 2. \\<And>rel v va.\n       (\\<And>y.\n           \\<lbrakk>y \\<in> set (v # va); P y\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt rel [] (v # va)) = filter P []\n 3. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "case (1 rel xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> set []; P ?y\\<rbrakk> \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<And>uu_ xs.\n       (\\<And>y.\n           \\<lbrakk>y \\<in> set []; P y\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt uu_ xs []) = filter P xs\n 2. \\<And>rel v va.\n       (\\<And>y.\n           \\<lbrakk>y \\<in> set (v # va); P y\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt rel [] (v # va)) = filter P []\n 3. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs []) = filter P xs", "by simp"], ["proof (state)\nthis:\n  filter P (merge_wrt rel xs []) = filter P xs\n\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       (\\<And>y.\n           \\<lbrakk>y \\<in> set (v # va); P y\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt rel [] (v # va)) = filter P []\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       (\\<And>y.\n           \\<lbrakk>y \\<in> set (v # va); P y\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt rel [] (v # va)) = filter P []\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "case (2 rel y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> set (y # ys); P ?y\\<rbrakk> \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       (\\<And>y.\n           \\<lbrakk>y \\<in> set (v # va); P y\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt rel [] (v # va)) = filter P []\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "hence \"P y \\<Longrightarrow> False\" and \"\\<And>z. z \\<in> set ys \\<Longrightarrow> P z \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> set (y # ys); P ?y\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (P y \\<Longrightarrow> False) &&&\n    (\\<And>z. \\<lbrakk>z \\<in> set ys; P z\\<rbrakk> \\<Longrightarrow> False)", "by auto"], ["proof (state)\nthis:\n  P y \\<Longrightarrow> False\n  \\<lbrakk>?z \\<in> set ys; P ?z\\<rbrakk> \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       (\\<And>y.\n           \\<lbrakk>y \\<in> set (v # va); P y\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt rel [] (v # va)) = filter P []\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  P y \\<Longrightarrow> False\n  \\<lbrakk>?z \\<in> set ys; P ?z\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel [] (y # ys)) = filter P []", "by (auto simp: filter_empty_conv)"], ["proof (state)\nthis:\n  filter P (merge_wrt rel [] (y # ys)) = filter P []\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "case (3 rel x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>x = y;\n   \\<And>y.\n      \\<lbrakk>y \\<in> set ys; P y\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel xs ys) = filter P xs\n  \\<lbrakk>x \\<noteq> y; rel x y;\n   \\<And>ya.\n      \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n      \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) = filter P xs\n  \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n   \\<And>y.\n      \\<lbrakk>y \\<in> set ys; P y\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) = filter P (x # xs)\n  \\<lbrakk>?y \\<in> set (y # ys); P ?y\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "hence \"\\<not> P y\" and x: \"\\<And>z. z \\<in> set ys \\<Longrightarrow> P z \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x = y;\n   \\<And>y.\n      \\<lbrakk>y \\<in> set ys; P y\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel xs ys) = filter P xs\n  \\<lbrakk>x \\<noteq> y; rel x y;\n   \\<And>ya.\n      \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n      \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) = filter P xs\n  \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n   \\<And>y.\n      \\<lbrakk>y \\<in> set ys; P y\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) = filter P (x # xs)\n  \\<lbrakk>?y \\<in> set (y # ys); P ?y\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> P y &&&\n    (\\<And>z. \\<lbrakk>z \\<in> set ys; P z\\<rbrakk> \\<Longrightarrow> False)", "by auto"], ["proof (state)\nthis:\n  \\<not> P y\n  \\<lbrakk>?z \\<in> set ys; P ?z\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "have a: \"filter P (merge_wrt rel xs ys) = filter P xs\" if \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs ys) = filter P xs", "using that x"], ["proof (prove)\nusing this:\n  x = y\n  \\<lbrakk>?z \\<in> set ys; P ?z\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs ys) = filter P xs", "by (rule 3(1))"], ["proof (state)\nthis:\n  x = y \\<Longrightarrow> filter P (merge_wrt rel xs ys) = filter P xs\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "have b: \"filter P (merge_wrt rel xs (y # ys)) = filter P xs\" if \"x \\<noteq> y\" and \"rel x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs (y # ys)) = filter P xs", "using that 3(4)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  rel x y\n  \\<lbrakk>?y \\<in> set (y # ys); P ?y\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs (y # ys)) = filter P xs", "by (rule 3(2))"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) = filter P xs\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "have c: \"filter P (merge_wrt rel (x # xs) ys) = filter P (x # xs)\" if \"x \\<noteq> y\" and \"\\<not> rel x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel (x # xs) ys) = filter P (x # xs)", "using that x"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<not> rel x y\n  \\<lbrakk>?z \\<in> set ys; P ?z\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel (x # xs) ys) = filter P (x # xs)", "by (rule 3(3))"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) = filter P (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>y.\n                    \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P xs;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>ya.\n            \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P xs;\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>y.\n            \\<lbrakk>y \\<in> set ys; P y\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P (x # xs);\n        \\<And>ya.\n           \\<lbrakk>ya \\<in> set (y # ys); P ya\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (x # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel (x # xs) (y # ys)) = filter P (x # xs)", "by (simp add: a b c \\<open>\\<not> P y\\<close>)"], ["proof (state)\nthis:\n  filter P (merge_wrt rel (x # xs) (y # ys)) = filter P (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_merge_wrt_2:\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> P x \\<Longrightarrow> False\"\n  shows \"filter P (merge_wrt rel xs ys) = filter P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs ys) = filter P ys", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; P ?x\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs ys) = filter P ys", "proof (induct rel xs ys rule: merge_wrt.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ xs.\n       (\\<And>x.\n           \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt uu_ xs []) = filter P []\n 2. \\<And>rel v va.\n       (\\<And>x.\n           \\<lbrakk>x \\<in> set []; P x\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt rel [] (v # va)) = filter P (v # va)\n 3. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "case (1 rel xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs; P ?x\\<rbrakk> \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<And>uu_ xs.\n       (\\<And>x.\n           \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt uu_ xs []) = filter P []\n 2. \\<And>rel v va.\n       (\\<And>x.\n           \\<lbrakk>x \\<in> set []; P x\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt rel [] (v # va)) = filter P (v # va)\n 3. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; P ?x\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs []) = filter P []", "by (auto simp: filter_empty_conv)"], ["proof (state)\nthis:\n  filter P (merge_wrt rel xs []) = filter P []\n\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       (\\<And>x.\n           \\<lbrakk>x \\<in> set []; P x\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt rel [] (v # va)) = filter P (v # va)\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       (\\<And>x.\n           \\<lbrakk>x \\<in> set []; P x\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt rel [] (v # va)) = filter P (v # va)\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "case (2 rel y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set []; P ?x\\<rbrakk> \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       (\\<And>x.\n           \\<lbrakk>x \\<in> set []; P x\\<rbrakk>\n           \\<Longrightarrow> False) \\<Longrightarrow>\n       filter P (merge_wrt rel [] (v # va)) = filter P (v # va)\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel [] (y # ys)) = filter P (y # ys)", "by simp"], ["proof (state)\nthis:\n  filter P (merge_wrt rel [] (y # ys)) = filter P (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "case (3 rel x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>x = y;\n   \\<And>x.\n      \\<lbrakk>x \\<in> set xs; P x\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel xs ys) = filter P ys\n  \\<lbrakk>x \\<noteq> y; rel x y;\n   \\<And>x.\n      \\<lbrakk>x \\<in> set xs; P x\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) = filter P (y # ys)\n  \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n   \\<And>xa.\n      \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n      \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) = filter P ys\n  \\<lbrakk>?x \\<in> set (x # xs); P ?x\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "hence \"\\<not> P x\" and x: \"\\<And>z. z \\<in> set xs \\<Longrightarrow> P z \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x = y;\n   \\<And>x.\n      \\<lbrakk>x \\<in> set xs; P x\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel xs ys) = filter P ys\n  \\<lbrakk>x \\<noteq> y; rel x y;\n   \\<And>x.\n      \\<lbrakk>x \\<in> set xs; P x\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) = filter P (y # ys)\n  \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n   \\<And>xa.\n      \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n      \\<Longrightarrow> False\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) = filter P ys\n  \\<lbrakk>?x \\<in> set (x # xs); P ?x\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> P x &&&\n    (\\<And>z. \\<lbrakk>z \\<in> set xs; P z\\<rbrakk> \\<Longrightarrow> False)", "by auto"], ["proof (state)\nthis:\n  \\<not> P x\n  \\<lbrakk>?z \\<in> set xs; P ?z\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "have a: \"filter P (merge_wrt rel xs ys) = filter P ys\" if \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs ys) = filter P ys", "using that x"], ["proof (prove)\nusing this:\n  x = y\n  \\<lbrakk>?z \\<in> set xs; P ?z\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs ys) = filter P ys", "by (rule 3(1))"], ["proof (state)\nthis:\n  x = y \\<Longrightarrow> filter P (merge_wrt rel xs ys) = filter P ys\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "have b: \"filter P (merge_wrt rel xs (y # ys)) = filter P (y # ys)\" if \"x \\<noteq> y\" and \"rel x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs (y # ys)) = filter P (y # ys)", "using that x"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  rel x y\n  \\<lbrakk>?z \\<in> set xs; P ?z\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel xs (y # ys)) = filter P (y # ys)", "by (rule 3(2))"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<noteq> y; rel x y\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) = filter P (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "have c: \"filter P (merge_wrt rel (x # xs) ys) = filter P ys\" if \"x \\<noteq> y\" and \"\\<not> rel x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel (x # xs) ys) = filter P ys", "using that 3(4)"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<not> rel x y\n  \\<lbrakk>?x \\<in> set (x # xs); P ?x\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel (x # xs) ys) = filter P ys", "by (rule 3(3))"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<noteq> y; \\<not> rel x y\\<rbrakk>\n  \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) = filter P ys\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y;\n                 \\<And>x.\n                    \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                    \\<Longrightarrow> False\\<rbrakk>\n                \\<Longrightarrow> filter P (merge_wrt rel xs ys) =\n                                  filter P ys;\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         \\<And>x.\n            \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel xs (y # ys)) =\n                          filter P (y # ys);\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         \\<And>xa.\n            \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n            \\<Longrightarrow> False\\<rbrakk>\n        \\<Longrightarrow> filter P (merge_wrt rel (x # xs) ys) =\n                          filter P ys;\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set (x # xs); P xa\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> filter P (merge_wrt rel (x # xs) (y # ys)) =\n                         filter P (y # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (merge_wrt rel (x # xs) (y # ys)) = filter P (y # ys)", "by (simp add: a b c \\<open>\\<not> P x\\<close>)"], ["proof (state)\nthis:\n  filter P (merge_wrt rel (x # xs) (y # ys)) = filter P (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_filter_le_1:\n  assumes \"length (filter P xs) \\<le> 1\" and \"i < length xs\" and \"j < length xs\"\n    and \"P (xs ! i)\" and \"P (xs ! j)\"\n  shows \"i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i = j", "have *: thesis if \"a < b\" and \"b < length xs\"\n    and \"\\<And>as bs cs. as @ ((xs ! a) # (bs @ ((xs ! b) # cs))) = xs \\<Longrightarrow> thesis\" for a b thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule that(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. ?as @ xs ! a # ?bs @ xs ! b # ?cs = xs", "from that(1, 2)"], ["proof (chain)\npicking this:\n  a < b\n  b < length xs", "have 1: \"a < length xs\""], ["proof (prove)\nusing this:\n  a < b\n  b < length xs\n\ngoal (1 subgoal):\n 1. a < length xs", "by simp"], ["proof (state)\nthis:\n  a < length xs\n\ngoal (1 subgoal):\n 1. ?as @ xs ! a # ?bs @ xs ! b # ?cs = xs", "with that(1, 2)"], ["proof (chain)\npicking this:\n  a < b\n  b < length xs\n  a < length xs", "have 2: \"b - Suc a < length (drop (Suc a) xs)\""], ["proof (prove)\nusing this:\n  a < b\n  b < length xs\n  a < length xs\n\ngoal (1 subgoal):\n 1. b - Suc a < length (drop (Suc a) xs)", "by simp"], ["proof (state)\nthis:\n  b - Suc a < length (drop (Suc a) xs)\n\ngoal (1 subgoal):\n 1. ?as @ xs ! a # ?bs @ xs ! b # ?cs = xs", "from that(1) \\<open>a < length xs\\<close>"], ["proof (chain)\npicking this:\n  a < b\n  a < length xs", "have eq: \"xs ! b = drop (Suc a) xs ! (b - Suc a)\""], ["proof (prove)\nusing this:\n  a < b\n  a < length xs\n\ngoal (1 subgoal):\n 1. xs ! b = drop (Suc a) xs ! (b - Suc a)", "by simp"], ["proof (state)\nthis:\n  xs ! b = drop (Suc a) xs ! (b - Suc a)\n\ngoal (1 subgoal):\n 1. ?as @ xs ! a # ?bs @ xs ! b # ?cs = xs", "show \"(take a xs) @ ((xs ! a) # ((take (b - Suc a) (drop (Suc a) xs)) @ ((xs ! b) #\n                  drop (Suc (b - Suc a)) (drop (Suc a) xs)))) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take a xs @\n    xs ! a #\n    take (b - Suc a) (drop (Suc a) xs) @\n    xs ! b # drop (Suc (b - Suc a)) (drop (Suc a) xs) =\n    xs", "by (simp only: eq id_take_nth_drop[OF 1, symmetric] id_take_nth_drop[OF 2, symmetric])"], ["proof (state)\nthis:\n  take a xs @\n  xs ! a #\n  take (b - Suc a) (drop (Suc a) xs) @\n  xs ! b # drop (Suc (b - Suc a)) (drop (Suc a) xs) =\n  xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?a < ?b; ?b < length xs;\n   \\<And>as bs cs.\n      as @ xs ! ?a # bs @ xs ! ?b # cs = xs \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. i = j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "proof (rule linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> i = j\n 2. ?x = ?y \\<Longrightarrow> i = j\n 3. ?y < ?x \\<Longrightarrow> i = j", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> i = j\n 2. ?x = ?y \\<Longrightarrow> i = j\n 3. ?y < ?x \\<Longrightarrow> i = j", "then"], ["proof (chain)\npicking this:\n  i < j", "obtain as bs cs where \"as @ ((xs ! i) # (bs @ ((xs ! j) # cs))) = xs\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. (\\<And>as bs cs.\n        as @ xs ! i # bs @ xs ! j # cs = xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  i < j\n  j < length xs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs cs.\n        as @ xs ! i # bs @ xs ! j # cs = xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule *)"], ["proof (state)\nthis:\n  as @ xs ! i # bs @ xs ! j # cs = xs\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> i = j\n 2. ?x = ?y \\<Longrightarrow> i = j\n 3. ?y < ?x \\<Longrightarrow> i = j", "hence \"filter P xs = filter P (as @ ((xs ! i) # (bs @ ((xs ! j) # cs))))\""], ["proof (prove)\nusing this:\n  as @ xs ! i # bs @ xs ! j # cs = xs\n\ngoal (1 subgoal):\n 1. filter P xs = filter P (as @ xs ! i # bs @ xs ! j # cs)", "by simp"], ["proof (state)\nthis:\n  filter P xs = filter P (as @ xs ! i # bs @ xs ! j # cs)\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> i = j\n 2. ?x = ?y \\<Longrightarrow> i = j\n 3. ?y < ?x \\<Longrightarrow> i = j", "also"], ["proof (state)\nthis:\n  filter P xs = filter P (as @ xs ! i # bs @ xs ! j # cs)\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> i = j\n 2. ?x = ?y \\<Longrightarrow> i = j\n 3. ?y < ?x \\<Longrightarrow> i = j", "from assms(4, 5)"], ["proof (chain)\npicking this:\n  P (xs ! i)\n  P (xs ! j)", "have \"... = (filter P as) @ ((xs ! i) # ((filter P bs) @ ((xs ! j) # (filter P cs))))\""], ["proof (prove)\nusing this:\n  P (xs ! i)\n  P (xs ! j)\n\ngoal (1 subgoal):\n 1. filter P (as @ xs ! i # bs @ xs ! j # cs) =\n    filter P as @ xs ! i # filter P bs @ xs ! j # filter P cs", "by simp"], ["proof (state)\nthis:\n  filter P (as @ xs ! i # bs @ xs ! j # cs) =\n  filter P as @ xs ! i # filter P bs @ xs ! j # filter P cs\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> i = j\n 2. ?x = ?y \\<Longrightarrow> i = j\n 3. ?y < ?x \\<Longrightarrow> i = j", "finally"], ["proof (chain)\npicking this:\n  filter P xs = filter P as @ xs ! i # filter P bs @ xs ! j # filter P cs", "have \"\\<not> length (filter P xs) \\<le> 1\""], ["proof (prove)\nusing this:\n  filter P xs = filter P as @ xs ! i # filter P bs @ xs ! j # filter P cs\n\ngoal (1 subgoal):\n 1. \\<not> length (filter P xs) \\<le> 1", "by simp"], ["proof (state)\nthis:\n  \\<not> length (filter P xs) \\<le> 1\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> i = j\n 2. ?x = ?y \\<Longrightarrow> i = j\n 3. ?y < ?x \\<Longrightarrow> i = j", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> length (filter P xs) \\<le> 1\n\ngoal (1 subgoal):\n 1. i = j", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<not> length (filter P xs) \\<le> 1\n  length (filter P xs) \\<le> 1\n\ngoal (1 subgoal):\n 1. i = j", ".."], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> i = j\n 2. j < i \\<Longrightarrow> i = j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> i = j\n 2. j < i \\<Longrightarrow> i = j", "assume \"j < i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> i = j\n 2. j < i \\<Longrightarrow> i = j", "then"], ["proof (chain)\npicking this:\n  j < i", "obtain as bs cs where \"as @ ((xs ! j) # (bs @ ((xs ! i) # cs))) = xs\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. (\\<And>as bs cs.\n        as @ xs ! j # bs @ xs ! i # cs = xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  j < i\n  i < length xs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs cs.\n        as @ xs ! j # bs @ xs ! i # cs = xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule *)"], ["proof (state)\nthis:\n  as @ xs ! j # bs @ xs ! i # cs = xs\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> i = j\n 2. j < i \\<Longrightarrow> i = j", "hence \"filter P xs = filter P (as @ ((xs ! j) # (bs @ ((xs ! i) # cs))))\""], ["proof (prove)\nusing this:\n  as @ xs ! j # bs @ xs ! i # cs = xs\n\ngoal (1 subgoal):\n 1. filter P xs = filter P (as @ xs ! j # bs @ xs ! i # cs)", "by simp"], ["proof (state)\nthis:\n  filter P xs = filter P (as @ xs ! j # bs @ xs ! i # cs)\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> i = j\n 2. j < i \\<Longrightarrow> i = j", "also"], ["proof (state)\nthis:\n  filter P xs = filter P (as @ xs ! j # bs @ xs ! i # cs)\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> i = j\n 2. j < i \\<Longrightarrow> i = j", "from assms(4, 5)"], ["proof (chain)\npicking this:\n  P (xs ! i)\n  P (xs ! j)", "have \"... = (filter P as) @ ((xs ! j) # ((filter P bs) @ ((xs ! i) # (filter P cs))))\""], ["proof (prove)\nusing this:\n  P (xs ! i)\n  P (xs ! j)\n\ngoal (1 subgoal):\n 1. filter P (as @ xs ! j # bs @ xs ! i # cs) =\n    filter P as @ xs ! j # filter P bs @ xs ! i # filter P cs", "by simp"], ["proof (state)\nthis:\n  filter P (as @ xs ! j # bs @ xs ! i # cs) =\n  filter P as @ xs ! j # filter P bs @ xs ! i # filter P cs\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> i = j\n 2. j < i \\<Longrightarrow> i = j", "finally"], ["proof (chain)\npicking this:\n  filter P xs = filter P as @ xs ! j # filter P bs @ xs ! i # filter P cs", "have \"\\<not> length (filter P xs) \\<le> 1\""], ["proof (prove)\nusing this:\n  filter P xs = filter P as @ xs ! j # filter P bs @ xs ! i # filter P cs\n\ngoal (1 subgoal):\n 1. \\<not> length (filter P xs) \\<le> 1", "by simp"], ["proof (state)\nthis:\n  \\<not> length (filter P xs) \\<le> 1\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> i = j\n 2. j < i \\<Longrightarrow> i = j", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> length (filter P xs) \\<le> 1\n\ngoal (1 subgoal):\n 1. i = j", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<not> length (filter P xs) \\<le> 1\n  length (filter P xs) \\<le> 1\n\ngoal (1 subgoal):\n 1. i = j", ".."], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. i = j \\<Longrightarrow> i = j", "qed"], ["proof (state)\nthis:\n  i = j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_filter_eq [simp]: \"length (filter ((=) x) xs) = count_list xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) x) xs) = count_list xs x", "by (induct xs, simp_all)"], ["", "subsubsection \\<open>@{const drop}\\<close>"], ["", "lemma nth_in_set_dropI:\n  assumes \"j \\<le> i\" and \"i < length xs\"\n  shows \"xs ! i \\<in> set (drop j xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! i \\<in> set (drop j xs)", "using assms"], ["proof (prove)\nusing this:\n  j \\<le> i\n  i < length xs\n\ngoal (1 subgoal):\n 1. xs ! i \\<in> set (drop j xs)", "proof (induct xs arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>j \\<le> i; i < length []\\<rbrakk>\n       \\<Longrightarrow> [] ! i \\<in> set (drop j [])\n 2. \\<And>a xs i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>j \\<le> i; i < length xs\\<rbrakk>\n                   \\<Longrightarrow> xs ! i \\<in> set (drop j xs);\n        j \\<le> i; i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (a # xs) ! i \\<in> set (drop j (a # xs))", "case Nil"], ["proof (state)\nthis:\n  j \\<le> i\n  i < length []\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>j \\<le> i; i < length []\\<rbrakk>\n       \\<Longrightarrow> [] ! i \\<in> set (drop j [])\n 2. \\<And>a xs i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>j \\<le> i; i < length xs\\<rbrakk>\n                   \\<Longrightarrow> xs ! i \\<in> set (drop j xs);\n        j \\<le> i; i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (a # xs) ! i \\<in> set (drop j (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  j \\<le> i\n  i < length []\n\ngoal (1 subgoal):\n 1. [] ! i \\<in> set (drop j [])", "by simp"], ["proof (state)\nthis:\n  [] ! i \\<in> set (drop j [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>j \\<le> i; i < length xs\\<rbrakk>\n                   \\<Longrightarrow> xs ! i \\<in> set (drop j xs);\n        j \\<le> i; i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (a # xs) ! i \\<in> set (drop j (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>j \\<le> i; i < length xs\\<rbrakk>\n                   \\<Longrightarrow> xs ! i \\<in> set (drop j xs);\n        j \\<le> i; i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (a # xs) ! i \\<in> set (drop j (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?j \\<le> ?i; ?i < length xs\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i \\<in> set (drop ?j xs)\n  j \\<le> i\n  i < length (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>j \\<le> i; i < length xs\\<rbrakk>\n                   \\<Longrightarrow> xs ! i \\<in> set (drop j xs);\n        j \\<le> i; i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (a # xs) ! i \\<in> set (drop j (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs) ! i \\<in> set (drop j (x # xs))", "proof (cases j)"], ["proof (state)\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> (x # xs) ! i \\<in> set (drop j (x # xs))\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (x # xs) ! i \\<in> set (drop j (x # xs))", "case 0"], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> (x # xs) ! i \\<in> set (drop j (x # xs))\n 2. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (x # xs) ! i \\<in> set (drop j (x # xs))", "with Cons(3)"], ["proof (chain)\npicking this:\n  i < length (x # xs)\n  j = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length (x # xs)\n  j = 0\n\ngoal (1 subgoal):\n 1. (x # xs) ! i \\<in> set (drop j (x # xs))", "by (metis drop0 nth_mem)"], ["proof (state)\nthis:\n  (x # xs) ! i \\<in> set (drop j (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (x # xs) ! i \\<in> set (drop j (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (x # xs) ! i \\<in> set (drop j (x # xs))", "case (Suc j0)"], ["proof (state)\nthis:\n  j = Suc j0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (x # xs) ! i \\<in> set (drop j (x # xs))", "with Cons(2) Suc_le_D"], ["proof (chain)\npicking this:\n  j \\<le> i\n  Suc ?n \\<le> ?m' \\<Longrightarrow> \\<exists>m. ?m' = Suc m\n  j = Suc j0", "obtain i0 where i: \"i = Suc i0\""], ["proof (prove)\nusing this:\n  j \\<le> i\n  Suc ?n \\<le> ?m' \\<Longrightarrow> \\<exists>m. ?m' = Suc m\n  j = Suc j0\n\ngoal (1 subgoal):\n 1. (\\<And>i0. i = Suc i0 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  i = Suc i0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (x # xs) ! i \\<in> set (drop j (x # xs))", "with Cons(2)"], ["proof (chain)\npicking this:\n  j \\<le> i\n  i = Suc i0", "have \"j0 \\<le> i0\""], ["proof (prove)\nusing this:\n  j \\<le> i\n  i = Suc i0\n\ngoal (1 subgoal):\n 1. j0 \\<le> i0", "by (simp add: \\<open>j = Suc j0\\<close>)"], ["proof (state)\nthis:\n  j0 \\<le> i0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (x # xs) ! i \\<in> set (drop j (x # xs))", "moreover"], ["proof (state)\nthis:\n  j0 \\<le> i0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (x # xs) ! i \\<in> set (drop j (x # xs))", "from Cons(3)"], ["proof (chain)\npicking this:\n  i < length (x # xs)", "have \"i0 < length xs\""], ["proof (prove)\nusing this:\n  i < length (x # xs)\n\ngoal (1 subgoal):\n 1. i0 < length xs", "by (simp add: i)"], ["proof (state)\nthis:\n  i0 < length xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (x # xs) ! i \\<in> set (drop j (x # xs))", "ultimately"], ["proof (chain)\npicking this:\n  j0 \\<le> i0\n  i0 < length xs", "have \"xs ! i0 \\<in> set (drop j0 xs)\""], ["proof (prove)\nusing this:\n  j0 \\<le> i0\n  i0 < length xs\n\ngoal (1 subgoal):\n 1. xs ! i0 \\<in> set (drop j0 xs)", "by (rule Cons(1))"], ["proof (state)\nthis:\n  xs ! i0 \\<in> set (drop j0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       j = Suc nat \\<Longrightarrow>\n       (x # xs) ! i \\<in> set (drop j (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs ! i0 \\<in> set (drop j0 xs)\n\ngoal (1 subgoal):\n 1. (x # xs) ! i \\<in> set (drop j (x # xs))", "by (simp add: i \\<open>j = Suc j0\\<close>)"], ["proof (state)\nthis:\n  (x # xs) ! i \\<in> set (drop j (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x # xs) ! i \\<in> set (drop j (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const count_list}\\<close>"], ["", "lemma count_list_append [simp]: \"count_list (xs @ ys) a = count_list xs a + count_list ys a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (xs @ ys) a = count_list xs a + count_list ys a", "by (induct xs, simp_all)"], ["", "lemma count_list_upt [simp]: \"count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)", "proof (cases \"a \\<le> b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)", "case True"], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  a \\<le> b", "obtain k where \"b = a + k\""], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. (\\<And>k. b = a + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using le_Suc_ex"], ["proof (prove)\nusing this:\n  a \\<le> b\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. (\\<And>k. b = a + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  b = a + k\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)", "unfolding \\<open>b = a + k\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list [a..<a + k] x = (if a \\<le> x \\<and> x < a + k then 1 else 0)", "by (induct k, simp_all)"], ["proof (state)\nthis:\n  count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  count_list [a..<b] x = (if a \\<le> x \\<and> x < b then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const sorted_wrt}\\<close>"], ["", "lemma sorted_wrt_upt_iff: \"sorted_wrt rel [a..<b] \\<longleftrightarrow> (\\<forall>i j. a \\<le> i \\<longrightarrow> i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)", "proof (cases \"a \\<le> b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)", "case True"], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)", "then"], ["proof (chain)\npicking this:\n  a \\<le> b", "obtain k where \"b = a + k\""], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. (\\<And>k. b = a + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using le_Suc_ex"], ["proof (prove)\nusing this:\n  a \\<le> b\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. (\\<And>k. b = a + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  b = a + k\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)", "unfolding \\<open>b = a + k\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel [a..<a + k] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < a + k \\<longrightarrow> rel i j)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted_wrt rel [a..<a + 0] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < a + 0 \\<longrightarrow> rel i j)\n 2. \\<And>k.\n       sorted_wrt rel [a..<a + k] =\n       (\\<forall>i j.\n           a \\<le> i \\<longrightarrow>\n           i < j \\<longrightarrow>\n           j < a + k \\<longrightarrow> rel i j) \\<Longrightarrow>\n       sorted_wrt rel [a..<a + Suc k] =\n       (\\<forall>i j.\n           a \\<le> i \\<longrightarrow>\n           i < j \\<longrightarrow> j < a + Suc k \\<longrightarrow> rel i j)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sorted_wrt rel [a..<a + 0] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < a + 0 \\<longrightarrow> rel i j)\n 2. \\<And>k.\n       sorted_wrt rel [a..<a + k] =\n       (\\<forall>i j.\n           a \\<le> i \\<longrightarrow>\n           i < j \\<longrightarrow>\n           j < a + k \\<longrightarrow> rel i j) \\<Longrightarrow>\n       sorted_wrt rel [a..<a + Suc k] =\n       (\\<forall>i j.\n           a \\<le> i \\<longrightarrow>\n           i < j \\<longrightarrow> j < a + Suc k \\<longrightarrow> rel i j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel [a..<a + 0] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < a + 0 \\<longrightarrow> rel i j)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt rel [a..<a + 0] =\n  (\\<forall>i j.\n      a \\<le> i \\<longrightarrow>\n      i < j \\<longrightarrow> j < a + 0 \\<longrightarrow> rel i j)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       sorted_wrt rel [a..<a + k] =\n       (\\<forall>i j.\n           a \\<le> i \\<longrightarrow>\n           i < j \\<longrightarrow>\n           j < a + k \\<longrightarrow> rel i j) \\<Longrightarrow>\n       sorted_wrt rel [a..<a + Suc k] =\n       (\\<forall>i j.\n           a \\<le> i \\<longrightarrow>\n           i < j \\<longrightarrow> j < a + Suc k \\<longrightarrow> rel i j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       sorted_wrt rel [a..<a + k] =\n       (\\<forall>i j.\n           a \\<le> i \\<longrightarrow>\n           i < j \\<longrightarrow>\n           j < a + k \\<longrightarrow> rel i j) \\<Longrightarrow>\n       sorted_wrt rel [a..<a + Suc k] =\n       (\\<forall>i j.\n           a \\<le> i \\<longrightarrow>\n           i < j \\<longrightarrow> j < a + Suc k \\<longrightarrow> rel i j)", "case (Suc k)"], ["proof (state)\nthis:\n  sorted_wrt rel [a..<a + k] =\n  (\\<forall>i j.\n      a \\<le> i \\<longrightarrow>\n      i < j \\<longrightarrow> j < a + k \\<longrightarrow> rel i j)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       sorted_wrt rel [a..<a + k] =\n       (\\<forall>i j.\n           a \\<le> i \\<longrightarrow>\n           i < j \\<longrightarrow>\n           j < a + k \\<longrightarrow> rel i j) \\<Longrightarrow>\n       sorted_wrt rel [a..<a + Suc k] =\n       (\\<forall>i j.\n           a \\<le> i \\<longrightarrow>\n           i < j \\<longrightarrow> j < a + Suc k \\<longrightarrow> rel i j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt rel [a..<a + Suc k] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < a + Suc k \\<longrightarrow> rel i j)", "proof (simp add: sorted_wrt_append Suc, intro iffI allI ballI impI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>(\\<forall>i\\<ge>a.\n                    \\<forall>j>i.\n                       j < a + k \\<longrightarrow> rel i j) \\<and>\n                (\\<forall>x\\<in>{a..<a + k}. rel x (a + k));\n        a \\<le> i; i < j; j < Suc (a + k)\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        a \\<le> i; i < j; j < a + k\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>(\\<forall>i\\<ge>a.\n                    \\<forall>j>i.\n                       j < a + k \\<longrightarrow> rel i j) \\<and>\n                (\\<forall>x\\<in>{a..<a + k}. rel x (a + k));\n        a \\<le> i; i < j; j < Suc (a + k)\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        a \\<le> i; i < j; j < a + k\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "assume \"(\\<forall>i\\<ge>a. \\<forall>j>i. j < a + k \\<longrightarrow> rel i j) \\<and> (\\<forall>x\\<in>{a..<a + k}. rel x (a + k))\""], ["proof (state)\nthis:\n  (\\<forall>i\\<ge>a.\n      \\<forall>j>i. j < a + k \\<longrightarrow> rel i j) \\<and>\n  (\\<forall>x\\<in>{a..<a + k}. rel x (a + k))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>(\\<forall>i\\<ge>a.\n                    \\<forall>j>i.\n                       j < a + k \\<longrightarrow> rel i j) \\<and>\n                (\\<forall>x\\<in>{a..<a + k}. rel x (a + k));\n        a \\<le> i; i < j; j < Suc (a + k)\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        a \\<le> i; i < j; j < a + k\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "hence 1: \"\\<And>i' j'. a \\<le> i' \\<Longrightarrow> i' < j' \\<Longrightarrow> j' < a + k \\<Longrightarrow> rel i' j'\"\n        and 2: \"\\<And>x. a \\<le> x \\<Longrightarrow> x < a + k \\<Longrightarrow> rel x (a + k)\""], ["proof (prove)\nusing this:\n  (\\<forall>i\\<ge>a.\n      \\<forall>j>i. j < a + k \\<longrightarrow> rel i j) \\<and>\n  (\\<forall>x\\<in>{a..<a + k}. rel x (a + k))\n\ngoal (1 subgoal):\n 1. (\\<And>i' j'.\n        \\<lbrakk>a \\<le> i'; i' < j'; j' < a + k\\<rbrakk>\n        \\<Longrightarrow> rel i' j') &&&\n    (\\<And>x.\n        \\<lbrakk>a \\<le> x; x < a + k\\<rbrakk>\n        \\<Longrightarrow> rel x (a + k))", "by simp_all"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<le> ?i'; ?i' < ?j'; ?j' < a + k\\<rbrakk>\n  \\<Longrightarrow> rel ?i' ?j'\n  \\<lbrakk>a \\<le> ?x; ?x < a + k\\<rbrakk> \\<Longrightarrow> rel ?x (a + k)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>(\\<forall>i\\<ge>a.\n                    \\<forall>j>i.\n                       j < a + k \\<longrightarrow> rel i j) \\<and>\n                (\\<forall>x\\<in>{a..<a + k}. rel x (a + k));\n        a \\<le> i; i < j; j < Suc (a + k)\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        a \\<le> i; i < j; j < a + k\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "assume \"a \\<le> i\" and \"i < j\""], ["proof (state)\nthis:\n  a \\<le> i\n  i < j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>(\\<forall>i\\<ge>a.\n                    \\<forall>j>i.\n                       j < a + k \\<longrightarrow> rel i j) \\<and>\n                (\\<forall>x\\<in>{a..<a + k}. rel x (a + k));\n        a \\<le> i; i < j; j < Suc (a + k)\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        a \\<le> i; i < j; j < a + k\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "assume \"j < Suc (a + k)\""], ["proof (state)\nthis:\n  j < Suc (a + k)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>(\\<forall>i\\<ge>a.\n                    \\<forall>j>i.\n                       j < a + k \\<longrightarrow> rel i j) \\<and>\n                (\\<forall>x\\<in>{a..<a + k}. rel x (a + k));\n        a \\<le> i; i < j; j < Suc (a + k)\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        a \\<le> i; i < j; j < a + k\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "hence \"j < a + k \\<or> j = a + k\""], ["proof (prove)\nusing this:\n  j < Suc (a + k)\n\ngoal (1 subgoal):\n 1. j < a + k \\<or> j = a + k", "by auto"], ["proof (state)\nthis:\n  j < a + k \\<or> j = a + k\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>(\\<forall>i\\<ge>a.\n                    \\<forall>j>i.\n                       j < a + k \\<longrightarrow> rel i j) \\<and>\n                (\\<forall>x\\<in>{a..<a + k}. rel x (a + k));\n        a \\<le> i; i < j; j < Suc (a + k)\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        a \\<le> i; i < j; j < a + k\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "thus \"rel i j\""], ["proof (prove)\nusing this:\n  j < a + k \\<or> j = a + k\n\ngoal (1 subgoal):\n 1. rel i j", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. j < a + k \\<Longrightarrow> rel i j\n 2. j = a + k \\<Longrightarrow> rel i j", "assume \"j < a + k\""], ["proof (state)\nthis:\n  j < a + k\n\ngoal (2 subgoals):\n 1. j < a + k \\<Longrightarrow> rel i j\n 2. j = a + k \\<Longrightarrow> rel i j", "with \\<open>a \\<le> i\\<close> \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  a \\<le> i\n  i < j\n  j < a + k", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> i\n  i < j\n  j < a + k\n\ngoal (1 subgoal):\n 1. rel i j", "by (rule 1)"], ["proof (state)\nthis:\n  rel i j\n\ngoal (1 subgoal):\n 1. j = a + k \\<Longrightarrow> rel i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j = a + k \\<Longrightarrow> rel i j", "assume \"j = a + k\""], ["proof (state)\nthis:\n  j = a + k\n\ngoal (1 subgoal):\n 1. j = a + k \\<Longrightarrow> rel i j", "from \\<open>a \\<le> i\\<close> \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  a \\<le> i\n  i < j", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> i\n  i < j\n\ngoal (1 subgoal):\n 1. rel i j", "unfolding \\<open>j = a + k\\<close>"], ["proof (prove)\nusing this:\n  a \\<le> i\n  i < a + k\n\ngoal (1 subgoal):\n 1. rel i (a + k)", "by (rule 2)"], ["proof (state)\nthis:\n  rel i j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel i j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        a \\<le> i; i < j; j < a + k\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        a \\<le> i; i < j; j < a + k\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "fix i j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        a \\<le> i; i < j; j < a + k\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "assume \"\\<forall>i\\<ge>a. \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j\" and \"a \\<le> i\" and \"i < j\" and \"j < a + k\""], ["proof (state)\nthis:\n  \\<forall>i\\<ge>a. \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j\n  a \\<le> i\n  i < j\n  j < a + k\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        a \\<le> i; i < j; j < a + k\\<rbrakk>\n       \\<Longrightarrow> rel i j\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "thus \"rel i j\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<ge>a. \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j\n  a \\<le> i\n  i < j\n  j < a + k\n\ngoal (1 subgoal):\n 1. rel i j", "by simp"], ["proof (state)\nthis:\n  rel i j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "assume \"x \\<in> {a..<a + k}\""], ["proof (state)\nthis:\n  x \\<in> {a..<a + k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "hence \"a \\<le> x\" and \"x < a + k\""], ["proof (prove)\nusing this:\n  x \\<in> {a..<a + k}\n\ngoal (1 subgoal):\n 1. a \\<le> x &&& x < a + k", "by simp_all"], ["proof (state)\nthis:\n  a \\<le> x\n  x < a + k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "moreover"], ["proof (state)\nthis:\n  a \\<le> x\n  x < a + k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "assume \"\\<forall>i\\<ge>a. \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j\""], ["proof (state)\nthis:\n  \\<forall>i\\<ge>a. \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>i\\<ge>a.\n                   \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j;\n        x \\<in> {a..<a + k}\\<rbrakk>\n       \\<Longrightarrow> rel x (a + k)", "ultimately"], ["proof (chain)\npicking this:\n  a \\<le> x\n  x < a + k\n  \\<forall>i\\<ge>a. \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j", "show \"rel x (a + k)\""], ["proof (prove)\nusing this:\n  a \\<le> x\n  x < a + k\n  \\<forall>i\\<ge>a. \\<forall>j>i. j < Suc (a + k) \\<longrightarrow> rel i j\n\ngoal (1 subgoal):\n 1. rel x (a + k)", "by simp"], ["proof (state)\nthis:\n  rel x (a + k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt rel [a..<a + Suc k] =\n  (\\<forall>i j.\n      a \\<le> i \\<longrightarrow>\n      i < j \\<longrightarrow> j < a + Suc k \\<longrightarrow> rel i j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt rel [a..<b] =\n  (\\<forall>i j.\n      a \\<le> i \\<longrightarrow>\n      i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)", "case False"], ["proof (state)\nthis:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. sorted_wrt rel [a..<b] =\n    (\\<forall>i j.\n        a \\<le> i \\<longrightarrow>\n        i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt rel [a..<b] =\n  (\\<forall>i j.\n      a \\<le> i \\<longrightarrow>\n      i < j \\<longrightarrow> j < b \\<longrightarrow> rel i j)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const insort_wrt} and @{const merge_wrt}\\<close>"], ["", "lemma map_insort_wrt:\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> r2 (f y) (f x) \\<longleftrightarrow> r1 y x\"\n  shows \"map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> r2 (f y) (f ?x) = r1 y ?x\n\ngoal (1 subgoal):\n 1. map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n    map f (insort_wrt r1 y []) = insort_wrt r2 (f y) (map f [])\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n                map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           r2 (f y) (f x) = r1 y x\\<rbrakk>\n       \\<Longrightarrow> map f (insort_wrt r1 y (a # xs)) =\n                         insort_wrt r2 (f y) (map f (a # xs))", "case Nil"], ["proof (state)\nthis:\n  ?x \\<in> set [] \\<Longrightarrow> r2 (f y) (f ?x) = r1 y ?x\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow>\n        r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n    map f (insort_wrt r1 y []) = insort_wrt r2 (f y) (map f [])\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n                map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           r2 (f y) (f x) = r1 y x\\<rbrakk>\n       \\<Longrightarrow> map f (insort_wrt r1 y (a # xs)) =\n                         insort_wrt r2 (f y) (map f (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (insort_wrt r1 y []) = insort_wrt r2 (f y) (map f [])", "by simp"], ["proof (state)\nthis:\n  map f (insort_wrt r1 y []) = insort_wrt r2 (f y) (map f [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n                map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           r2 (f y) (f x) = r1 y x\\<rbrakk>\n       \\<Longrightarrow> map f (insort_wrt r1 y (a # xs)) =\n                         insort_wrt r2 (f y) (map f (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n                map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           r2 (f y) (f x) = r1 y x\\<rbrakk>\n       \\<Longrightarrow> map f (insort_wrt r1 y (a # xs)) =\n                         insort_wrt r2 (f y) (map f (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> set xs \\<Longrightarrow>\n      r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n  map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs)\n  ?x \\<in> set (x # xs) \\<Longrightarrow> r2 (f y) (f ?x) = r1 y ?x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n                map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           r2 (f y) (f x) = r1 y x\\<rbrakk>\n       \\<Longrightarrow> map f (insort_wrt r1 y (a # xs)) =\n                         insort_wrt r2 (f y) (map f (a # xs))", "have \"x \\<in> set (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (x # xs)", "by simp"], ["proof (state)\nthis:\n  x \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n                map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           r2 (f y) (f x) = r1 y x\\<rbrakk>\n       \\<Longrightarrow> map f (insort_wrt r1 y (a # xs)) =\n                         insort_wrt r2 (f y) (map f (a # xs))", "hence \"r2 (f y) (f x) = r1 y x\""], ["proof (prove)\nusing this:\n  x \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. r2 (f y) (f x) = r1 y x", "by (rule Cons(2))"], ["proof (state)\nthis:\n  r2 (f y) (f x) = r1 y x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n                map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           r2 (f y) (f x) = r1 y x\\<rbrakk>\n       \\<Longrightarrow> map f (insort_wrt r1 y (a # xs)) =\n                         insort_wrt r2 (f y) (map f (a # xs))", "moreover"], ["proof (state)\nthis:\n  r2 (f y) (f x) = r1 y x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n                map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           r2 (f y) (f x) = r1 y x\\<rbrakk>\n       \\<Longrightarrow> map f (insort_wrt r1 y (a # xs)) =\n                         insort_wrt r2 (f y) (map f (a # xs))", "have \"map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs)", "proof (rule Cons(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> r2 (f y) (f x) = r1 y x", "fix x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> r2 (f y) (f x) = r1 y x", "assume \"x' \\<in> set xs\""], ["proof (state)\nthis:\n  x' \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> r2 (f y) (f x) = r1 y x", "hence \"x' \\<in> set (x # xs)\""], ["proof (prove)\nusing this:\n  x' \\<in> set xs\n\ngoal (1 subgoal):\n 1. x' \\<in> set (x # xs)", "by simp"], ["proof (state)\nthis:\n  x' \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> r2 (f y) (f x) = r1 y x", "thus \"r2 (f y) (f x') = r1 y x'\""], ["proof (prove)\nusing this:\n  x' \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. r2 (f y) (f x') = r1 y x'", "by (rule Cons(2))"], ["proof (state)\nthis:\n  r2 (f y) (f x') = r1 y x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    r2 (f y) (f x) = r1 y x) \\<Longrightarrow>\n                map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           r2 (f y) (f x) = r1 y x\\<rbrakk>\n       \\<Longrightarrow> map f (insort_wrt r1 y (a # xs)) =\n                         insort_wrt r2 (f y) (map f (a # xs))", "ultimately"], ["proof (chain)\npicking this:\n  r2 (f y) (f x) = r1 y x\n  map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs)", "show ?case"], ["proof (prove)\nusing this:\n  r2 (f y) (f x) = r1 y x\n  map f (insort_wrt r1 y xs) = insort_wrt r2 (f y) (map f xs)\n\ngoal (1 subgoal):\n 1. map f (insort_wrt r1 y (x # xs)) = insort_wrt r2 (f y) (map f (x # xs))", "by simp"], ["proof (state)\nthis:\n  map f (insort_wrt r1 y (x # xs)) = insort_wrt r2 (f y) (map f (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_merge_wrt:\n  assumes \"f ` set xs \\<inter> f ` set ys = {}\"\n    and \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> r2 (f x) (f y) \\<longleftrightarrow> r1 x y\"\n  shows \"map f (merge_wrt r1 xs ys) = merge_wrt r2 (map f xs) (map f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (merge_wrt r1 xs ys) = merge_wrt r2 (map f xs) (map f ys)", "using assms"], ["proof (prove)\nusing this:\n  f ` set xs \\<inter> f ` set ys = {}\n  \\<lbrakk>?x \\<in> set xs; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> r2 (f ?x) (f ?y) = r1 ?x ?y\n\ngoal (1 subgoal):\n 1. map f (merge_wrt r1 xs ys) = merge_wrt r2 (map f xs) (map f ys)", "proof (induct r1 xs ys rule: merge_wrt.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ xs.\n       \\<lbrakk>f ` set xs \\<inter> f ` set [] = {};\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set xs; y \\<in> set []\\<rbrakk>\n           \\<Longrightarrow> r2 (f x) (f y) = uu_ x y\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt uu_ xs []) =\n                         merge_wrt r2 (map f xs) (map f [])\n 2. \\<And>rel v va.\n       \\<lbrakk>f ` set [] \\<inter> f ` set (v # va) = {};\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set []; y \\<in> set (v # va)\\<rbrakk>\n           \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel [] (v # va)) =\n                         merge_wrt r2 (map f []) (map f (v # va))\n 3. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "case (1 uu xs)"], ["proof (state)\nthis:\n  f ` set xs \\<inter> f ` set [] = {}\n  \\<lbrakk>?x \\<in> set xs; ?y \\<in> set []\\<rbrakk>\n  \\<Longrightarrow> r2 (f ?x) (f ?y) = uu ?x ?y\n\ngoal (3 subgoals):\n 1. \\<And>uu_ xs.\n       \\<lbrakk>f ` set xs \\<inter> f ` set [] = {};\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set xs; y \\<in> set []\\<rbrakk>\n           \\<Longrightarrow> r2 (f x) (f y) = uu_ x y\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt uu_ xs []) =\n                         merge_wrt r2 (map f xs) (map f [])\n 2. \\<And>rel v va.\n       \\<lbrakk>f ` set [] \\<inter> f ` set (v # va) = {};\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set []; y \\<in> set (v # va)\\<rbrakk>\n           \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel [] (v # va)) =\n                         merge_wrt r2 (map f []) (map f (v # va))\n 3. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (merge_wrt uu xs []) = merge_wrt r2 (map f xs) (map f [])", "by simp"], ["proof (state)\nthis:\n  map f (merge_wrt uu xs []) = merge_wrt r2 (map f xs) (map f [])\n\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       \\<lbrakk>f ` set [] \\<inter> f ` set (v # va) = {};\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set []; y \\<in> set (v # va)\\<rbrakk>\n           \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel [] (v # va)) =\n                         merge_wrt r2 (map f []) (map f (v # va))\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       \\<lbrakk>f ` set [] \\<inter> f ` set (v # va) = {};\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set []; y \\<in> set (v # va)\\<rbrakk>\n           \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel [] (v # va)) =\n                         merge_wrt r2 (map f []) (map f (v # va))\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "case (2 r1 v va)"], ["proof (state)\nthis:\n  f ` set [] \\<inter> f ` set (v # va) = {}\n  \\<lbrakk>?x \\<in> set []; ?y \\<in> set (v # va)\\<rbrakk>\n  \\<Longrightarrow> r2 (f ?x) (f ?y) = r1 ?x ?y\n\ngoal (2 subgoals):\n 1. \\<And>rel v va.\n       \\<lbrakk>f ` set [] \\<inter> f ` set (v # va) = {};\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set []; y \\<in> set (v # va)\\<rbrakk>\n           \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel [] (v # va)) =\n                         merge_wrt r2 (map f []) (map f (v # va))\n 2. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (merge_wrt r1 [] (v # va)) =\n    merge_wrt r2 (map f []) (map f (v # va))", "by simp"], ["proof (state)\nthis:\n  map f (merge_wrt r1 [] (v # va)) =\n  merge_wrt r2 (map f []) (map f (v # va))\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "case (3 r1 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n   \\<And>x y.\n      \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> r2 (f x) (f y) = r1 x y\\<rbrakk>\n  \\<Longrightarrow> map f (merge_wrt r1 xs ys) =\n                    merge_wrt r2 (map f xs) (map f ys)\n  \\<lbrakk>x \\<noteq> y; r1 x y; f ` set xs \\<inter> f ` set (y # ys) = {};\n   \\<And>x ya.\n      \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n      \\<Longrightarrow> r2 (f x) (f ya) = r1 x ya\\<rbrakk>\n  \\<Longrightarrow> map f (merge_wrt r1 xs (y # ys)) =\n                    merge_wrt r2 (map f xs) (map f (y # ys))\n  \\<lbrakk>x \\<noteq> y; \\<not> r1 x y;\n   f ` set (x # xs) \\<inter> f ` set ys = {};\n   \\<And>xa y.\n      \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> r2 (f xa) (f y) = r1 xa y\\<rbrakk>\n  \\<Longrightarrow> map f (merge_wrt r1 (x # xs) ys) =\n                    merge_wrt r2 (map f (x # xs)) (map f ys)\n  f ` set (x # xs) \\<inter> f ` set (y # ys) = {}\n  \\<lbrakk>?x \\<in> set (x # xs); ?y \\<in> set (y # ys)\\<rbrakk>\n  \\<Longrightarrow> r2 (f ?x) (f ?y) = r1 ?x ?y\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "from 3(4)"], ["proof (chain)\npicking this:\n  f ` set (x # xs) \\<inter> f ` set (y # ys) = {}", "have \"f x \\<noteq> f y\" and 1: \"f ` set xs \\<inter> f ` set (y # ys) = {}\"\n    and 2: \"f ` set (x # xs) \\<inter> f ` set ys = {}\""], ["proof (prove)\nusing this:\n  f ` set (x # xs) \\<inter> f ` set (y # ys) = {}\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y &&&\n    f ` set xs \\<inter> f ` set (y # ys) = {} &&&\n    f ` set (x # xs) \\<inter> f ` set ys = {}", "by auto"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n  f ` set xs \\<inter> f ` set (y # ys) = {}\n  f ` set (x # xs) \\<inter> f ` set ys = {}\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "from this(1)"], ["proof (chain)\npicking this:\n  f x \\<noteq> f y", "have \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  f x \\<noteq> f y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "have eq2: \"map f (merge_wrt r1 xs (y # ys)) = merge_wrt r2 (map f xs) (map f (y # ys))\"\n    if \"r1 x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (merge_wrt r1 xs (y # ys)) =\n    merge_wrt r2 (map f xs) (map f (y # ys))", "using \\<open>x \\<noteq> y\\<close> that 1"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  r1 x y\n  f ` set xs \\<inter> f ` set (y # ys) = {}\n\ngoal (1 subgoal):\n 1. map f (merge_wrt r1 xs (y # ys)) =\n    merge_wrt r2 (map f xs) (map f (y # ys))", "proof (rule 3(2))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> r2 (f x) (f ya) = r1 x ya", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> r2 (f x) (f ya) = r1 x ya", "assume \"a \\<in> set xs\""], ["proof (state)\nthis:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> r2 (f x) (f ya) = r1 x ya", "hence \"a \\<in> set (x # xs)\""], ["proof (prove)\nusing this:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<in> set (x # xs)", "by simp"], ["proof (state)\nthis:\n  a \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> r2 (f x) (f ya) = r1 x ya", "moreover"], ["proof (state)\nthis:\n  a \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> r2 (f x) (f ya) = r1 x ya", "assume \"b \\<in> set (y # ys)\""], ["proof (state)\nthis:\n  b \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> r2 (f x) (f ya) = r1 x ya", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> set (x # xs)\n  b \\<in> set (y # ys)", "show \"r2 (f a) (f b) \\<longleftrightarrow> r1 a b\""], ["proof (prove)\nusing this:\n  a \\<in> set (x # xs)\n  b \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. r2 (f a) (f b) = r1 a b", "by (rule 3(5))"], ["proof (state)\nthis:\n  r2 (f a) (f b) = r1 a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r1 x y \\<Longrightarrow>\n  map f (merge_wrt r1 xs (y # ys)) =\n  merge_wrt r2 (map f xs) (map f (y # ys))\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "have eq3: \"map f (merge_wrt r1 (x # xs) ys) = merge_wrt r2 (map f (x # xs)) (map f ys)\"\n    if \"\\<not> r1 x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (merge_wrt r1 (x # xs) ys) =\n    merge_wrt r2 (map f (x # xs)) (map f ys)", "using \\<open>x \\<noteq> y\\<close> that 2"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<not> r1 x y\n  f ` set (x # xs) \\<inter> f ` set ys = {}\n\ngoal (1 subgoal):\n 1. map f (merge_wrt r1 (x # xs) ys) =\n    merge_wrt r2 (map f (x # xs)) (map f ys)", "proof (rule 3(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> r2 (f xa) (f y) = r1 xa y", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> r2 (f xa) (f y) = r1 xa y", "assume \"a \\<in> set (x # xs)\""], ["proof (state)\nthis:\n  a \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> r2 (f xa) (f y) = r1 xa y", "assume \"b \\<in> set ys\""], ["proof (state)\nthis:\n  b \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> r2 (f xa) (f y) = r1 xa y", "hence \"b \\<in> set (y # ys)\""], ["proof (prove)\nusing this:\n  b \\<in> set ys\n\ngoal (1 subgoal):\n 1. b \\<in> set (y # ys)", "by simp"], ["proof (state)\nthis:\n  b \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> r2 (f xa) (f y) = r1 xa y", "with \\<open>a \\<in> set (x # xs)\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> set (x # xs)\n  b \\<in> set (y # ys)", "show \"r2 (f a) (f b) \\<longleftrightarrow> r1 a b\""], ["proof (prove)\nusing this:\n  a \\<in> set (x # xs)\n  b \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. r2 (f a) (f b) = r1 a b", "by (rule 3(5))"], ["proof (state)\nthis:\n  r2 (f a) (f b) = r1 a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> r1 x y \\<Longrightarrow>\n  map f (merge_wrt r1 (x # xs) ys) =\n  merge_wrt r2 (map f (x # xs)) (map f ys)\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "have eq4: \"r2 (f x) (f y) \\<longleftrightarrow> r1 x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2 (f x) (f y) = r1 x y", "by (rule 3(5), simp_all)"], ["proof (state)\nthis:\n  r2 (f x) (f y) = r1 x y\n\ngoal (1 subgoal):\n 1. \\<And>rel x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; f ` set xs \\<inter> f ` set ys = {};\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n                    \\<Longrightarrow> r2 (f x) (f y) = rel x y\\<rbrakk>\n                \\<Longrightarrow> map f (merge_wrt rel xs ys) =\n                                  merge_wrt r2 (map f xs) (map f ys);\n        \\<lbrakk>x \\<noteq> y; rel x y;\n         f ` set xs \\<inter> f ` set (y # ys) = {};\n         \\<And>x ya.\n            \\<lbrakk>x \\<in> set xs; ya \\<in> set (y # ys)\\<rbrakk>\n            \\<Longrightarrow> r2 (f x) (f ya) = rel x ya\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel xs (y # ys)) =\n                          merge_wrt r2 (map f xs) (map f (y # ys));\n        \\<lbrakk>x \\<noteq> y; \\<not> rel x y;\n         f ` set (x # xs) \\<inter> f ` set ys = {};\n         \\<And>xa y.\n            \\<lbrakk>xa \\<in> set (x # xs); y \\<in> set ys\\<rbrakk>\n            \\<Longrightarrow> r2 (f xa) (f y) = rel xa y\\<rbrakk>\n        \\<Longrightarrow> map f (merge_wrt rel (x # xs) ys) =\n                          merge_wrt r2 (map f (x # xs)) (map f ys);\n        f ` set (x # xs) \\<inter> f ` set (y # ys) = {};\n        \\<And>xa ya.\n           \\<lbrakk>xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> r2 (f xa) (f ya) = rel xa ya\\<rbrakk>\n       \\<Longrightarrow> map f (merge_wrt rel (x # xs) (y # ys)) =\n                         merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (merge_wrt r1 (x # xs) (y # ys)) =\n    merge_wrt r2 (map f (x # xs)) (map f (y # ys))", "by (simp add: eq2 eq3 eq4 \\<open>f x \\<noteq> f y\\<close> \\<open>x \\<noteq> y\\<close>)"], ["proof (state)\nthis:\n  map f (merge_wrt r1 (x # xs) (y # ys)) =\n  merge_wrt r2 (map f (x # xs)) (map f (y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Recursive Functions\\<close>"], ["", "locale recursive =\n  fixes h' :: \"'b \\<Rightarrow> 'b\"\n  fixes b :: 'b\n  assumes b_fixpoint: \"h' b = b\"\nbegin"], ["", "context\n  fixes Q :: \"'a \\<Rightarrow> bool\"\n  fixes g :: \"'a \\<Rightarrow> 'b\"\n  fixes h :: \"'a \\<Rightarrow> 'a\"\nbegin"], ["", "function (domintros) recfun_aux :: \"'a \\<Rightarrow> 'b\" where\n  \"recfun_aux x = (if Q x then g x else h' (recfun_aux (h x)))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>xa. x = xa \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>x xa.\n       x = xa \\<Longrightarrow>\n       (if Q x then g x else h' (recfun_aux_sumC (h x))) =\n       (if Q xa then g xa else h' (recfun_aux_sumC (h xa)))", "by pat_completeness auto"], ["", "lemmas [induct del] = recfun_aux.pinduct"], ["", "definition dom :: \"'a \\<Rightarrow> bool\"\n  where \"dom x \\<longleftrightarrow> (\\<exists>k. Q ((h ^^ k) x))\""], ["", "lemma domI:\n  assumes \"\\<not> Q x \\<Longrightarrow> dom (h x)\"\n  shows \"dom x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom x", "proof (cases \"Q x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Q x \\<Longrightarrow> local.dom x\n 2. \\<not> Q x \\<Longrightarrow> local.dom x", "case True"], ["proof (state)\nthis:\n  Q x\n\ngoal (2 subgoals):\n 1. Q x \\<Longrightarrow> local.dom x\n 2. \\<not> Q x \\<Longrightarrow> local.dom x", "hence \"Q ((h ^^ 0) x)\""], ["proof (prove)\nusing this:\n  Q x\n\ngoal (1 subgoal):\n 1. Q ((h ^^ 0) x)", "by simp"], ["proof (state)\nthis:\n  Q ((h ^^ 0) x)\n\ngoal (2 subgoals):\n 1. Q x \\<Longrightarrow> local.dom x\n 2. \\<not> Q x \\<Longrightarrow> local.dom x", "thus ?thesis"], ["proof (prove)\nusing this:\n  Q ((h ^^ 0) x)\n\ngoal (1 subgoal):\n 1. local.dom x", "unfolding dom_def"], ["proof (prove)\nusing this:\n  Q ((h ^^ 0) x)\n\ngoal (1 subgoal):\n 1. \\<exists>k. Q ((h ^^ k) x)", ".."], ["proof (state)\nthis:\n  local.dom x\n\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow> local.dom x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow> local.dom x", "case False"], ["proof (state)\nthis:\n  \\<not> Q x\n\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow> local.dom x", "hence \"dom (h x)\""], ["proof (prove)\nusing this:\n  \\<not> Q x\n\ngoal (1 subgoal):\n 1. local.dom (h x)", "by (rule assms)"], ["proof (state)\nthis:\n  local.dom (h x)\n\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow> local.dom x", "then"], ["proof (chain)\npicking this:\n  local.dom (h x)", "obtain k where \"Q ((h ^^ k) (h x))\""], ["proof (prove)\nusing this:\n  local.dom (h x)\n\ngoal (1 subgoal):\n 1. (\\<And>k. Q ((h ^^ k) (h x)) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dom_def"], ["proof (prove)\nusing this:\n  \\<exists>k. Q ((h ^^ k) (h x))\n\ngoal (1 subgoal):\n 1. (\\<And>k. Q ((h ^^ k) (h x)) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  Q ((h ^^ k) (h x))\n\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow> local.dom x", "hence \"Q ((h ^^ (Suc k)) x)\""], ["proof (prove)\nusing this:\n  Q ((h ^^ k) (h x))\n\ngoal (1 subgoal):\n 1. Q ((h ^^ Suc k) x)", "by (simp add: funpow_swap1)"], ["proof (state)\nthis:\n  Q ((h ^^ Suc k) x)\n\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow> local.dom x", "thus ?thesis"], ["proof (prove)\nusing this:\n  Q ((h ^^ Suc k) x)\n\ngoal (1 subgoal):\n 1. local.dom x", "unfolding dom_def"], ["proof (prove)\nusing this:\n  Q ((h ^^ Suc k) x)\n\ngoal (1 subgoal):\n 1. \\<exists>k. Q ((h ^^ k) x)", ".."], ["proof (state)\nthis:\n  local.dom x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma domD:\n  assumes \"dom x\" and \"\\<not> Q x\"\n  shows \"dom (h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (h x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dom (h x)", "from assms(1)"], ["proof (chain)\npicking this:\n  local.dom x", "obtain k where *: \"Q ((h ^^ k) x)\""], ["proof (prove)\nusing this:\n  local.dom x\n\ngoal (1 subgoal):\n 1. (\\<And>k. Q ((h ^^ k) x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dom_def"], ["proof (prove)\nusing this:\n  \\<exists>k. Q ((h ^^ k) x)\n\ngoal (1 subgoal):\n 1. (\\<And>k. Q ((h ^^ k) x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  Q ((h ^^ k) x)\n\ngoal (1 subgoal):\n 1. local.dom (h x)", "with assms(2)"], ["proof (chain)\npicking this:\n  \\<not> Q x\n  Q ((h ^^ k) x)", "have \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> Q x\n  Q ((h ^^ k) x)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "using funpow_0"], ["proof (prove)\nusing this:\n  \\<not> Q x\n  Q ((h ^^ k) x)\n  (?f ^^ 0) ?x = ?x\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. local.dom (h x)", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "obtain m where \"k = Suc m\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>m. k = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using nat.exhaust"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  \\<lbrakk>?y = 0 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Suc x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>m. k = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  k = Suc m\n\ngoal (1 subgoal):\n 1. local.dom (h x)", "with *"], ["proof (chain)\npicking this:\n  Q ((h ^^ k) x)\n  k = Suc m", "have \"Q ((h ^^ m) (h x))\""], ["proof (prove)\nusing this:\n  Q ((h ^^ k) x)\n  k = Suc m\n\ngoal (1 subgoal):\n 1. Q ((h ^^ m) (h x))", "by (simp add: funpow_swap1)"], ["proof (state)\nthis:\n  Q ((h ^^ m) (h x))\n\ngoal (1 subgoal):\n 1. local.dom (h x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Q ((h ^^ m) (h x))\n\ngoal (1 subgoal):\n 1. local.dom (h x)", "unfolding dom_def"], ["proof (prove)\nusing this:\n  Q ((h ^^ m) (h x))\n\ngoal (1 subgoal):\n 1. \\<exists>k. Q ((h ^^ k) (h x))", ".."], ["proof (state)\nthis:\n  local.dom (h x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma recfun_aux_domI:\n  assumes \"dom x\"\n  shows \"recfun_aux_dom x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfun_aux_dom x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. recfun_aux_dom x", "from assms"], ["proof (chain)\npicking this:\n  local.dom x", "obtain k where \"Q ((h ^^ k) x)\""], ["proof (prove)\nusing this:\n  local.dom x\n\ngoal (1 subgoal):\n 1. (\\<And>k. Q ((h ^^ k) x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dom_def"], ["proof (prove)\nusing this:\n  \\<exists>k. Q ((h ^^ k) x)\n\ngoal (1 subgoal):\n 1. (\\<And>k. Q ((h ^^ k) x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  Q ((h ^^ k) x)\n\ngoal (1 subgoal):\n 1. recfun_aux_dom x", "thus ?thesis"], ["proof (prove)\nusing this:\n  Q ((h ^^ k) x)\n\ngoal (1 subgoal):\n 1. recfun_aux_dom x", "proof (induct k arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. Q ((h ^^ 0) x) \\<Longrightarrow> recfun_aux_dom x\n 2. \\<And>k x.\n       \\<lbrakk>\\<And>x. Q ((h ^^ k) x) \\<Longrightarrow> recfun_aux_dom x;\n        Q ((h ^^ Suc k) x)\\<rbrakk>\n       \\<Longrightarrow> recfun_aux_dom x", "case 0"], ["proof (state)\nthis:\n  Q ((h ^^ 0) x)\n\ngoal (2 subgoals):\n 1. \\<And>x. Q ((h ^^ 0) x) \\<Longrightarrow> recfun_aux_dom x\n 2. \\<And>k x.\n       \\<lbrakk>\\<And>x. Q ((h ^^ k) x) \\<Longrightarrow> recfun_aux_dom x;\n        Q ((h ^^ Suc k) x)\\<rbrakk>\n       \\<Longrightarrow> recfun_aux_dom x", "hence \"Q x\""], ["proof (prove)\nusing this:\n  Q ((h ^^ 0) x)\n\ngoal (1 subgoal):\n 1. Q x", "by simp"], ["proof (state)\nthis:\n  Q x\n\ngoal (2 subgoals):\n 1. \\<And>x. Q ((h ^^ 0) x) \\<Longrightarrow> recfun_aux_dom x\n 2. \\<And>k x.\n       \\<lbrakk>\\<And>x. Q ((h ^^ k) x) \\<Longrightarrow> recfun_aux_dom x;\n        Q ((h ^^ Suc k) x)\\<rbrakk>\n       \\<Longrightarrow> recfun_aux_dom x", "with recfun_aux.domintros"], ["proof (chain)\npicking this:\n  (\\<not> Q ?x \\<Longrightarrow> recfun_aux_dom (h ?x)) \\<Longrightarrow>\n  recfun_aux_dom ?x\n  Q x", "show ?case"], ["proof (prove)\nusing this:\n  (\\<not> Q ?x \\<Longrightarrow> recfun_aux_dom (h ?x)) \\<Longrightarrow>\n  recfun_aux_dom ?x\n  Q x\n\ngoal (1 subgoal):\n 1. recfun_aux_dom x", "by blast"], ["proof (state)\nthis:\n  recfun_aux_dom x\n\ngoal (1 subgoal):\n 1. \\<And>k x.\n       \\<lbrakk>\\<And>x. Q ((h ^^ k) x) \\<Longrightarrow> recfun_aux_dom x;\n        Q ((h ^^ Suc k) x)\\<rbrakk>\n       \\<Longrightarrow> recfun_aux_dom x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k x.\n       \\<lbrakk>\\<And>x. Q ((h ^^ k) x) \\<Longrightarrow> recfun_aux_dom x;\n        Q ((h ^^ Suc k) x)\\<rbrakk>\n       \\<Longrightarrow> recfun_aux_dom x", "case (Suc k)"], ["proof (state)\nthis:\n  Q ((h ^^ k) ?x) \\<Longrightarrow> recfun_aux_dom ?x\n  Q ((h ^^ Suc k) x)\n\ngoal (1 subgoal):\n 1. \\<And>k x.\n       \\<lbrakk>\\<And>x. Q ((h ^^ k) x) \\<Longrightarrow> recfun_aux_dom x;\n        Q ((h ^^ Suc k) x)\\<rbrakk>\n       \\<Longrightarrow> recfun_aux_dom x", "from Suc(2)"], ["proof (chain)\npicking this:\n  Q ((h ^^ Suc k) x)", "have \"Q ((h ^^ k) (h x))\""], ["proof (prove)\nusing this:\n  Q ((h ^^ Suc k) x)\n\ngoal (1 subgoal):\n 1. Q ((h ^^ k) (h x))", "by (simp add: funpow_swap1)"], ["proof (state)\nthis:\n  Q ((h ^^ k) (h x))\n\ngoal (1 subgoal):\n 1. \\<And>k x.\n       \\<lbrakk>\\<And>x. Q ((h ^^ k) x) \\<Longrightarrow> recfun_aux_dom x;\n        Q ((h ^^ Suc k) x)\\<rbrakk>\n       \\<Longrightarrow> recfun_aux_dom x", "hence \"recfun_aux_dom (h x)\""], ["proof (prove)\nusing this:\n  Q ((h ^^ k) (h x))\n\ngoal (1 subgoal):\n 1. recfun_aux_dom (h x)", "by (rule Suc(1))"], ["proof (state)\nthis:\n  recfun_aux_dom (h x)\n\ngoal (1 subgoal):\n 1. \\<And>k x.\n       \\<lbrakk>\\<And>x. Q ((h ^^ k) x) \\<Longrightarrow> recfun_aux_dom x;\n        Q ((h ^^ Suc k) x)\\<rbrakk>\n       \\<Longrightarrow> recfun_aux_dom x", "with recfun_aux.domintros"], ["proof (chain)\npicking this:\n  (\\<not> Q ?x \\<Longrightarrow> recfun_aux_dom (h ?x)) \\<Longrightarrow>\n  recfun_aux_dom ?x\n  recfun_aux_dom (h x)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<not> Q ?x \\<Longrightarrow> recfun_aux_dom (h ?x)) \\<Longrightarrow>\n  recfun_aux_dom ?x\n  recfun_aux_dom (h x)\n\ngoal (1 subgoal):\n 1. recfun_aux_dom x", "by blast"], ["proof (state)\nthis:\n  recfun_aux_dom x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  recfun_aux_dom x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma recfun_aux_domD:\n  assumes \"recfun_aux_dom x\"\n  shows \"dom x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom x", "using assms"], ["proof (prove)\nusing this:\n  recfun_aux_dom x\n\ngoal (1 subgoal):\n 1. local.dom x", "proof (induct x rule: recfun_aux.pinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>recfun_aux_dom x;\n        \\<not> Q x \\<Longrightarrow> local.dom (h x)\\<rbrakk>\n       \\<Longrightarrow> local.dom x", "case (1 x)"], ["proof (state)\nthis:\n  recfun_aux_dom x\n  \\<not> Q x \\<Longrightarrow> local.dom (h x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>recfun_aux_dom x;\n        \\<not> Q x \\<Longrightarrow> local.dom (h x)\\<rbrakk>\n       \\<Longrightarrow> local.dom x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom x", "proof (cases \"Q x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Q x \\<Longrightarrow> local.dom x\n 2. \\<not> Q x \\<Longrightarrow> local.dom x", "case True"], ["proof (state)\nthis:\n  Q x\n\ngoal (2 subgoals):\n 1. Q x \\<Longrightarrow> local.dom x\n 2. \\<not> Q x \\<Longrightarrow> local.dom x", "with domI"], ["proof (chain)\npicking this:\n  (\\<not> Q ?x \\<Longrightarrow> local.dom (h ?x)) \\<Longrightarrow>\n  local.dom ?x\n  Q x", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<not> Q ?x \\<Longrightarrow> local.dom (h ?x)) \\<Longrightarrow>\n  local.dom ?x\n  Q x\n\ngoal (1 subgoal):\n 1. local.dom x", "by blast"], ["proof (state)\nthis:\n  local.dom x\n\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow> local.dom x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow> local.dom x", "case False"], ["proof (state)\nthis:\n  \\<not> Q x\n\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow> local.dom x", "hence \"dom (h x)\""], ["proof (prove)\nusing this:\n  \\<not> Q x\n\ngoal (1 subgoal):\n 1. local.dom (h x)", "by (rule 1(2))"], ["proof (state)\nthis:\n  local.dom (h x)\n\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow> local.dom x", "thus ?thesis"], ["proof (prove)\nusing this:\n  local.dom (h x)\n\ngoal (1 subgoal):\n 1. local.dom x", "using domI"], ["proof (prove)\nusing this:\n  local.dom (h x)\n  (\\<not> Q ?x \\<Longrightarrow> local.dom (h ?x)) \\<Longrightarrow>\n  local.dom ?x\n\ngoal (1 subgoal):\n 1. local.dom x", "by blast"], ["proof (state)\nthis:\n  local.dom x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.dom x\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary recfun_aux_dom_alt: \"recfun_aux_dom = dom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfun_aux_dom = local.dom", "by (auto dest: recfun_aux_domI recfun_aux_domD)"], ["", "definition \"fun\" :: \"'a \\<Rightarrow> 'b\"\n  where \"fun x = (if recfun_aux_dom x then recfun_aux x else b)\""], ["", "lemma simps: \"fun x = (if Q x then g x else h' (fun (h x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun x = (if Q x then g x else h' (fun (h x)))", "proof (cases \"dom x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))\n 2. \\<not> local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "case True"], ["proof (state)\nthis:\n  local.dom x\n\ngoal (2 subgoals):\n 1. local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))\n 2. \\<not> local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "hence dom: \"recfun_aux_dom x\""], ["proof (prove)\nusing this:\n  local.dom x\n\ngoal (1 subgoal):\n 1. recfun_aux_dom x", "by (rule recfun_aux_domI)"], ["proof (state)\nthis:\n  recfun_aux_dom x\n\ngoal (2 subgoals):\n 1. local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))\n 2. \\<not> local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fun x = (if Q x then g x else h' (fun (h x)))", "proof (cases \"Q x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Q x \\<Longrightarrow> fun x = (if Q x then g x else h' (fun (h x)))\n 2. \\<not> Q x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "case True"], ["proof (state)\nthis:\n  Q x\n\ngoal (2 subgoals):\n 1. Q x \\<Longrightarrow> fun x = (if Q x then g x else h' (fun (h x)))\n 2. \\<not> Q x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "with dom"], ["proof (chain)\npicking this:\n  recfun_aux_dom x\n  Q x", "show ?thesis"], ["proof (prove)\nusing this:\n  recfun_aux_dom x\n  Q x\n\ngoal (1 subgoal):\n 1. fun x = (if Q x then g x else h' (fun (h x)))", "by (simp add: fun_def recfun_aux.psimps)"], ["proof (state)\nthis:\n  fun x = (if Q x then g x else h' (fun (h x)))\n\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "case False"], ["proof (state)\nthis:\n  \\<not> Q x\n\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "have \"recfun_aux_dom (h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfun_aux_dom (h x)", "by (rule recfun_aux_domI, rule domD, fact True, fact False)"], ["proof (state)\nthis:\n  recfun_aux_dom (h x)\n\ngoal (1 subgoal):\n 1. \\<not> Q x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  recfun_aux_dom (h x)\n\ngoal (1 subgoal):\n 1. fun x = (if Q x then g x else h' (fun (h x)))", "by (simp add: fun_def dom False recfun_aux.psimps)"], ["proof (state)\nthis:\n  fun x = (if Q x then g x else h' (fun (h x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fun x = (if Q x then g x else h' (fun (h x)))\n\ngoal (1 subgoal):\n 1. \\<not> local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "case False"], ["proof (state)\nthis:\n  \\<not> local.dom x\n\ngoal (1 subgoal):\n 1. \\<not> local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "moreover"], ["proof (state)\nthis:\n  \\<not> local.dom x\n\ngoal (1 subgoal):\n 1. \\<not> local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "have \"\\<not> Q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Q x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Q x \\<Longrightarrow> False", "assume \"Q x\""], ["proof (state)\nthis:\n  Q x\n\ngoal (1 subgoal):\n 1. Q x \\<Longrightarrow> False", "hence \"dom x\""], ["proof (prove)\nusing this:\n  Q x\n\ngoal (1 subgoal):\n 1. local.dom x", "using domI"], ["proof (prove)\nusing this:\n  Q x\n  (\\<not> Q ?x \\<Longrightarrow> local.dom (h ?x)) \\<Longrightarrow>\n  local.dom ?x\n\ngoal (1 subgoal):\n 1. local.dom x", "by blast"], ["proof (state)\nthis:\n  local.dom x\n\ngoal (1 subgoal):\n 1. Q x \\<Longrightarrow> False", "with False"], ["proof (chain)\npicking this:\n  \\<not> local.dom x\n  local.dom x", "show False"], ["proof (prove)\nusing this:\n  \\<not> local.dom x\n  local.dom x\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> Q x\n\ngoal (1 subgoal):\n 1. \\<not> local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "moreover"], ["proof (state)\nthis:\n  \\<not> Q x\n\ngoal (1 subgoal):\n 1. \\<not> local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "have \"\\<not> dom (h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> local.dom (h x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dom (h x) \\<Longrightarrow> False", "assume \"dom (h x)\""], ["proof (state)\nthis:\n  local.dom (h x)\n\ngoal (1 subgoal):\n 1. local.dom (h x) \\<Longrightarrow> False", "hence \"dom x\""], ["proof (prove)\nusing this:\n  local.dom (h x)\n\ngoal (1 subgoal):\n 1. local.dom x", "using domI"], ["proof (prove)\nusing this:\n  local.dom (h x)\n  (\\<not> Q ?x \\<Longrightarrow> local.dom (h ?x)) \\<Longrightarrow>\n  local.dom ?x\n\ngoal (1 subgoal):\n 1. local.dom x", "by blast"], ["proof (state)\nthis:\n  local.dom x\n\ngoal (1 subgoal):\n 1. local.dom (h x) \\<Longrightarrow> False", "with False"], ["proof (chain)\npicking this:\n  \\<not> local.dom x\n  local.dom x", "show False"], ["proof (prove)\nusing this:\n  \\<not> local.dom x\n  local.dom x\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> local.dom (h x)\n\ngoal (1 subgoal):\n 1. \\<not> local.dom x \\<Longrightarrow>\n    fun x = (if Q x then g x else h' (fun (h x)))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> local.dom x\n  \\<not> Q x\n  \\<not> local.dom (h x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> local.dom x\n  \\<not> Q x\n  \\<not> local.dom (h x)\n\ngoal (1 subgoal):\n 1. fun x = (if Q x then g x else h' (fun (h x)))", "by (simp add: recfun_aux_dom_alt fun_def b_fixpoint split del: if_split)"], ["proof (state)\nthis:\n  fun x = (if Q x then g x else h' (fun (h x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_fixpointI: \"\\<not> dom x \\<Longrightarrow> fun x = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> local.dom x \\<Longrightarrow> fun x = b", "by (simp add: fun_def recfun_aux_dom_alt)"], ["", "lemma pinduct: \"dom x \\<Longrightarrow> (\\<And>x. dom x \\<Longrightarrow> (\\<not> Q x \\<Longrightarrow> P (h x)) \\<Longrightarrow> P x) \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.dom x;\n     \\<And>x.\n        \\<lbrakk>local.dom x; \\<not> Q x \\<Longrightarrow> P (h x)\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> P x", "unfolding recfun_aux_dom_alt[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>recfun_aux_dom x;\n     \\<And>x.\n        \\<lbrakk>recfun_aux_dom x;\n         \\<not> Q x \\<Longrightarrow> P (h x)\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> P x", "by (fact recfun_aux.pinduct)"], ["", "end"], ["", "end"], ["", "(* recursive *)"], ["", "interpretation tailrec: recursive \"\\<lambda>x. x\" undefined"], ["proof (prove)\ngoal (1 subgoal):\n 1. recursive (\\<lambda>x. x) undefined", "by (standard, fact refl)"], ["", "subsection \\<open>Binary Relations\\<close>"], ["", "lemma almost_full_on_Int:\n  assumes \"almost_full_on P1 A1\" and \"almost_full_on P2 A2\"\n  shows \"almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) (A1 \\<inter> A2)\" (is \"almost_full_on ?P ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) (A1 \\<inter> A2)", "proof (rule almost_full_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A1 \\<inter> A2 \\<Longrightarrow>\n       good (\\<lambda>x y. P1 x y \\<and> P2 x y) f", "fix f :: \"nat \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A1 \\<inter> A2 \\<Longrightarrow>\n       good (\\<lambda>x y. P1 x y \\<and> P2 x y) f", "assume a: \"\\<forall>i. f i \\<in> ?A\""], ["proof (state)\nthis:\n  \\<forall>i. f i \\<in> A1 \\<inter> A2\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A1 \\<inter> A2 \\<Longrightarrow>\n       good (\\<lambda>x y. P1 x y \\<and> P2 x y) f", "define g where \"g = (\\<lambda>i. (f i, f i))\""], ["proof (state)\nthis:\n  g = (\\<lambda>i. (f i, f i))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A1 \\<inter> A2 \\<Longrightarrow>\n       good (\\<lambda>x y. P1 x y \\<and> P2 x y) f", "from assms"], ["proof (chain)\npicking this:\n  almost_full_on P1 A1\n  almost_full_on P2 A2", "have \"almost_full_on (prod_le P1 P2) (A1 \\<times> A2)\""], ["proof (prove)\nusing this:\n  almost_full_on P1 A1\n  almost_full_on P2 A2\n\ngoal (1 subgoal):\n 1. almost_full_on (prod_le P1 P2) (A1 \\<times> A2)", "by (rule almost_full_on_Sigma)"], ["proof (state)\nthis:\n  almost_full_on (prod_le P1 P2) (A1 \\<times> A2)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A1 \\<inter> A2 \\<Longrightarrow>\n       good (\\<lambda>x y. P1 x y \\<and> P2 x y) f", "moreover"], ["proof (state)\nthis:\n  almost_full_on (prod_le P1 P2) (A1 \\<times> A2)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A1 \\<inter> A2 \\<Longrightarrow>\n       good (\\<lambda>x y. P1 x y \\<and> P2 x y) f", "from a"], ["proof (chain)\npicking this:\n  \\<forall>i. f i \\<in> A1 \\<inter> A2", "have \"\\<And>i. g i \\<in> A1 \\<times> A2\""], ["proof (prove)\nusing this:\n  \\<forall>i. f i \\<in> A1 \\<inter> A2\n\ngoal (1 subgoal):\n 1. \\<And>i. g i \\<in> A1 \\<times> A2", "by (simp add: g_def)"], ["proof (state)\nthis:\n  g ?i \\<in> A1 \\<times> A2\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A1 \\<inter> A2 \\<Longrightarrow>\n       good (\\<lambda>x y. P1 x y \\<and> P2 x y) f", "ultimately"], ["proof (chain)\npicking this:\n  almost_full_on (prod_le P1 P2) (A1 \\<times> A2)\n  g ?i \\<in> A1 \\<times> A2", "obtain i j where \"i < j\" and \"prod_le P1 P2 (g i) (g j)\""], ["proof (prove)\nusing this:\n  almost_full_on (prod_le P1 P2) (A1 \\<times> A2)\n  g ?i \\<in> A1 \\<times> A2\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; prod_le P1 P2 (g i) (g j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule almost_full_onD)"], ["proof (state)\nthis:\n  i < j\n  prod_le P1 P2 (g i) (g j)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A1 \\<inter> A2 \\<Longrightarrow>\n       good (\\<lambda>x y. P1 x y \\<and> P2 x y) f", "from this(2)"], ["proof (chain)\npicking this:\n  prod_le P1 P2 (g i) (g j)", "have \"?P (f i) (f j)\""], ["proof (prove)\nusing this:\n  prod_le P1 P2 (g i) (g j)\n\ngoal (1 subgoal):\n 1. P1 (f i) (f j) \\<and> P2 (f i) (f j)", "by (simp add: g_def prod_le_def)"], ["proof (state)\nthis:\n  P1 (f i) (f j) \\<and> P2 (f i) (f j)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A1 \\<inter> A2 \\<Longrightarrow>\n       good (\\<lambda>x y. P1 x y \\<and> P2 x y) f", "with \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  i < j\n  P1 (f i) (f j) \\<and> P2 (f i) (f j)", "show \"good ?P f\""], ["proof (prove)\nusing this:\n  i < j\n  P1 (f i) (f j) \\<and> P2 (f i) (f j)\n\ngoal (1 subgoal):\n 1. good (\\<lambda>x y. P1 x y \\<and> P2 x y) f", "by (rule goodI)"], ["proof (state)\nthis:\n  good (\\<lambda>x y. P1 x y \\<and> P2 x y) f\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary almost_full_on_same:\n  assumes \"almost_full_on P1 A\" and \"almost_full_on P2 A\"\n  shows \"almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) A", "from assms"], ["proof (chain)\npicking this:\n  almost_full_on P1 A\n  almost_full_on P2 A", "have \"almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) (A \\<inter> A)\""], ["proof (prove)\nusing this:\n  almost_full_on P1 A\n  almost_full_on P2 A\n\ngoal (1 subgoal):\n 1. almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) (A \\<inter> A)", "by (rule almost_full_on_Int)"], ["proof (state)\nthis:\n  almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) (A \\<inter> A)\n\ngoal (1 subgoal):\n 1. almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) A", "thus ?thesis"], ["proof (prove)\nusing this:\n  almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) (A \\<inter> A)\n\ngoal (1 subgoal):\n 1. almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) A", "by simp"], ["proof (state)\nthis:\n  almost_full_on (\\<lambda>x y. P1 x y \\<and> P2 x y) A\n\ngoal:\nNo subgoals!", "qed"], ["", "context ord\nbegin"], ["", "definition is_le_rel :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  where \"is_le_rel rel = (rel = (=) \\<or> rel = (\\<le>) \\<or> rel = (<))\""], ["", "lemma is_le_relI [simp]: \"is_le_rel (=)\" \"is_le_rel (\\<le>)\" \"is_le_rel (<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_le_rel (=) &&& is_le_rel (\\<le>) &&& is_le_rel (<)", "by (simp_all add: is_le_rel_def)"], ["", "lemma is_le_relE:\n  assumes \"is_le_rel rel\"\n  obtains \"rel = (=)\" | \"rel = (\\<le>)\" | \"rel = (<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel = (=) \\<Longrightarrow> thesis;\n     rel = (\\<le>) \\<Longrightarrow> thesis;\n     rel = (<) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  is_le_rel rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rel = (=) \\<Longrightarrow> thesis;\n     rel = (\\<le>) \\<Longrightarrow> thesis;\n     rel = (<) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding is_le_rel_def"], ["proof (prove)\nusing this:\n  rel = (=) \\<or> rel = (\\<le>) \\<or> rel = (<)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rel = (=) \\<Longrightarrow> thesis;\n     rel = (\\<le>) \\<Longrightarrow> thesis;\n     rel = (<) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["", "end"], ["", "(* ord *)"], ["", "context preorder\nbegin"], ["", "lemma is_le_rel_le:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel x y \\<Longrightarrow> x \\<le> y", "using assms"], ["proof (prove)\nusing this:\n  is_le_rel rel\n\ngoal (1 subgoal):\n 1. rel x y \\<Longrightarrow> x \\<le> y", "by (rule is_le_relE, auto dest: less_imp_le)"], ["", "lemma is_le_rel_trans:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> rel y z \\<Longrightarrow> rel x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel x y; rel y z\\<rbrakk> \\<Longrightarrow> rel x z", "using assms"], ["proof (prove)\nusing this:\n  is_le_rel rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rel x y; rel y z\\<rbrakk> \\<Longrightarrow> rel x z", "by (rule is_le_relE, auto dest: order_trans less_trans)"], ["", "lemma is_le_rel_trans_le_left:\n  assumes \"is_le_rel rel\"\n  shows \"x \\<le> y \\<Longrightarrow> rel y z \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; rel y z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "using assms"], ["proof (prove)\nusing this:\n  is_le_rel rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; rel y z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "by (rule is_le_relE, auto dest: order_trans le_less_trans less_imp_le)"], ["", "lemma is_le_rel_trans_le_right:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel x y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "using assms"], ["proof (prove)\nusing this:\n  is_le_rel rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rel x y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "by (rule is_le_relE, auto dest: order_trans less_le_trans less_imp_le)"], ["", "lemma is_le_rel_trans_less_left:\n  assumes \"is_le_rel rel\"\n  shows \"x < y \\<Longrightarrow> rel y z \\<Longrightarrow> x < z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; rel y z\\<rbrakk> \\<Longrightarrow> x < z", "using assms"], ["proof (prove)\nusing this:\n  is_le_rel rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; rel y z\\<rbrakk> \\<Longrightarrow> x < z", "by (rule is_le_relE, auto dest: less_le_trans less_imp_le)"], ["", "lemma is_le_rel_trans_less_right:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> y < z \\<Longrightarrow> x < z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel x y; y < z\\<rbrakk> \\<Longrightarrow> x < z", "using assms"], ["proof (prove)\nusing this:\n  is_le_rel rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rel x y; y < z\\<rbrakk> \\<Longrightarrow> x < z", "by (rule is_le_relE, auto dest: le_less_trans less_imp_le)"], ["", "end"], ["", "(* preorder *)"], ["", "context order\nbegin"], ["", "lemma is_le_rel_distinct:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel x y; x \\<noteq> y\\<rbrakk> \\<Longrightarrow> x < y", "using assms"], ["proof (prove)\nusing this:\n  is_le_rel rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rel x y; x \\<noteq> y\\<rbrakk> \\<Longrightarrow> x < y", "by (rule is_le_relE, auto)"], ["", "lemma is_le_rel_antisym:\n  assumes \"is_le_rel rel\"\n  shows \"rel x y \\<Longrightarrow> rel y x \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel x y; rel y x\\<rbrakk> \\<Longrightarrow> x = y", "using assms"], ["proof (prove)\nusing this:\n  is_le_rel rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rel x y; rel y x\\<rbrakk> \\<Longrightarrow> x = y", "by (rule is_le_relE, auto)"], ["", "end"], ["", "(* order *)"], ["", "end"], ["", "(* theory *)"]]}