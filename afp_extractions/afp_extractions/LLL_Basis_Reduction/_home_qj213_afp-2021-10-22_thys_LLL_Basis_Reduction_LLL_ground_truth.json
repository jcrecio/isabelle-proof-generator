{"file_name": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction/LLL.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction", "problem_names": ["lemma LLL_inv_wD: assumes \"LLL_invariant_weak fs\"\n  shows \n  \"lin_indep fs\" \n  \"length (RAT fs) = m\" \n  \"set fs \\<subseteq> carrier_vec n\"\n  \"\\<And> i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n\" \n  \"\\<And> i. i < m \\<Longrightarrow> gso fs i \\<in> carrier_vec n\" \n  \"length fs = m\"\n  \"lattice_of fs = L\"", "lemma LLL_inv_wI: assumes  \n  \"set fs \\<subseteq> carrier_vec n\"\n  \"length fs = m\"\n  \"lattice_of fs = L\" \n  \"lin_indep fs\" \nshows \"LLL_invariant_weak fs\"", "lemma LLL_inv_imp_w: \"LLL_invariant upw i fs \\<Longrightarrow> LLL_invariant_weak fs\"", "lemma LLL_invD: assumes \"LLL_invariant upw i fs\"\n  shows \n  \"lin_indep fs\" \n  \"length (RAT fs) = m\" \n  \"set fs \\<subseteq> carrier_vec n\"\n  \"\\<And> i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n\" \n  \"\\<And> i. i < m \\<Longrightarrow> gso fs i \\<in> carrier_vec n\" \n  \"length fs = m\"\n  \"lattice_of fs = L\" \n  \"weakly_reduced fs i\"\n  \"i \\<le> m\"\n  \"reduced fs i\" \n  \"upw \\<or> \\<mu>_small fs i\"", "lemma LLL_invI: assumes  \n  \"set fs \\<subseteq> carrier_vec n\"\n  \"length fs = m\"\n  \"lattice_of fs = L\" \n  \"i \\<le> m\"\n  \"lin_indep fs\" \n  \"reduced fs i\" \n  \"upw \\<or> \\<mu>_small fs i\" \nshows \"LLL_invariant upw i fs\"", "lemma gso_cong: assumes \"\\<And> i. i \\<le> x \\<Longrightarrow> f1 ! i = f2 ! i\"\n   \"x < length f1\" \"x < length f2\" \n  shows \"gso f1 x = gso f2 x\"", "lemma \\<mu>_cong: assumes \"\\<And> k. j < i \\<Longrightarrow> k \\<le> j \\<Longrightarrow> f1 ! k = f2 ! k\"\n  and i: \"i < length f1\" \"i < length f2\" \n  and \"j < i \\<Longrightarrow> f1 ! i = f2 ! i\" \n  shows \"\\<mu> f1 i j = \\<mu> f2 i j\"", "lemma Gramian_determinant:\n  assumes k: \"k \\<le> m\" \nshows \"of_int (gs.Gramian_determinant fs k) = (\\<Prod> j<k. sq_norm (gso fs j))\" (is ?g1)\n  \"gs.Gramian_determinant fs k > 0\" (is ?g2)", "lemma LLL_d_pos [intro]: assumes k: \"k \\<le> m\" \nshows \"d fs k > 0\"", "lemma LLL_d_Suc: assumes k: \"k < m\" \nshows \"of_int (d fs (Suc k)) = sq_norm (gso fs k) * of_int (d fs k)\"", "lemma LLL_D_pos:\n  shows \"D fs > 0\"", "lemma increase_i:\n  assumes Linv: \"LLL_invariant upw i fs\"\n  assumes i: \"i < m\" \n  and upw: \"upw \\<Longrightarrow> i = 0\" \n  and red_i: \"i \\<noteq> 0 \\<Longrightarrow> sq_norm (gso fs (i - 1)) \\<le> \\<alpha> * sq_norm (gso fs i)\"\nshows \"LLL_invariant True (Suc i) fs\" \"LLL_measure i fs > LLL_measure (Suc i) fs\"", "lemma basis_reduction_add_row_main: assumes Linv: \"LLL_invariant_weak fs\"\n  and i: \"i < m\"  and j: \"j < i\" \n  and fs': \"fs' = fs[ i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]\" \nshows \"LLL_invariant_weak fs'\" \n  \"LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\"\n  \"c = round (\\<mu> fs i j) \\<Longrightarrow> \\<mu>_small_row i fs (Suc j) \\<Longrightarrow> \\<mu>_small_row i fs' j\" (* mu-value at position i j gets small *)\n  \"c = round (\\<mu> fs i j) \\<Longrightarrow> abs (\\<mu> fs' i j) \\<le> 1/2\" (* mu-value at position i j gets small *)\n  \"LLL_measure i fs' = LLL_measure i fs\" \n  (* new values of gso: no change *)\n  \"\\<And> i. i < m \\<Longrightarrow> gso fs' i = gso fs i\" \n  (* new values of mu *)\n  \"\\<And> i' j'. i' < m \\<Longrightarrow> j' < m \\<Longrightarrow>       \n     \\<mu> fs' i' j' = (if i' = i \\<and> j' \\<le> j then \\<mu> fs i j' - of_int c * \\<mu> fs j j' else \\<mu> fs i' j')\"\n  (* new values of d *)\n  \"\\<And> ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii\"", "lemma basis_reduction_add_row_main_0: assumes Linv: \"LLL_invariant_weak fs\"\n  and i: \"i < m\"  and j: \"j < i\" \n  and 0: \"round (\\<mu> fs i j) = 0\" \n  and mu_small: \"\\<mu>_small_row i fs (Suc j)\"\nshows \"\\<mu>_small_row i fs j\" (is ?g1)", "lemma \\<mu>_small_row_refl: \"\\<mu>_small_row i fs i\"", "lemma basis_reduction_add_row_done: assumes Linv: \"LLL_invariant True i fs\"\n  and i: \"i < m\" \n  and mu_small: \"\\<mu>_small_row i fs 0\" \nshows \"LLL_invariant False i fs\"", "lemma d_swap_unchanged: assumes len: \"length F1 = m\" \n  and i0: \"i \\<noteq> 0\" and i: \"i < m\" and ki: \"k \\<noteq> i\" and km: \"k \\<le> m\"   \n  and swap: \"F2 = F1[i := F1 ! (i - 1), i - 1 := F1 ! i]\"\nshows \"d F1 k = d F2 k\"", "lemma \\<alpha>0: \"\\<alpha> > 0\" \"\\<alpha> \\<noteq> 0\"", "lemma fs_init: \"set fs_init \\<subseteq> carrier_vec n\"", "lemma reduction: \"0 < reduction\" \"reduction \\<le> 1\" \n  \"\\<alpha> > 4/3 \\<Longrightarrow> reduction < 1\" \n  \"\\<alpha> = 4/3 \\<Longrightarrow> reduction = 1\"", "lemma base: \"\\<alpha> > 4/3 \\<Longrightarrow> base > 1\"", "lemma basis_reduction_swap_main: assumes Linvw: \"LLL_invariant_weak fs\"\n  and small: \"LLL_invariant False i fs \\<or> abs (\\<mu> fs i (i - 1)) \\<le> 1/2\" \n  and i: \"i < m\"\n  and i0: \"i \\<noteq> 0\" \n  and norm_ineq: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\" \n  and fs'_def: \"fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]\" \nshows \"LLL_invariant_weak fs'\" \n  and \"LLL_invariant False i fs \\<Longrightarrow> LLL_invariant False (i - 1) fs'\" \n  and \"LLL_measure i fs > LLL_measure (i - 1) fs'\" \n  (* new values of gso *)\n  and \"\\<And> k. k < m \\<Longrightarrow> gso fs' k = (if k = i - 1 then\n         gso fs i + \\<mu> fs i (i - 1) \\<cdot>\\<^sub>v gso fs (i - 1) \n      else if k = i then\n         gso fs (i - 1) - (RAT fs ! (i - 1) \\<bullet> gso fs' (i - 1) / sq_norm (gso fs' (i - 1))) \\<cdot>\\<^sub>v gso fs' (i - 1)\n      else gso fs k)\" (is \"\\<And> k. _ \\<Longrightarrow> _ = ?newg k\")\n  (* new values of norms of gso *)\n  and \"\\<And> k. k < m \\<Longrightarrow> sq_norm (gso fs' k) = (if k = i - 1 then\n          sq_norm (gso fs i) + (\\<mu> fs i (i - 1) * \\<mu> fs i (i - 1)) * sq_norm (gso fs (i - 1))\n      else if k = i then\n         sq_norm (gso fs i) * sq_norm (gso fs (i - 1)) / sq_norm (gso fs' (i - 1))\n      else sq_norm (gso fs k))\" (is \"\\<And> k. _ \\<Longrightarrow> _ = ?new_norm k\")\n  (* new values of \\<mu>-values *)\n  and \"\\<And> ii j. ii < m \\<Longrightarrow> j < ii \\<Longrightarrow> \\<mu> fs' ii j = (\n        if ii = i - 1 then \n           \\<mu> fs i j\n        else if ii = i then \n          if j = i - 1 then \n             \\<mu> fs i (i - 1) * sq_norm (gso fs (i - 1)) / sq_norm (gso fs' (i - 1))\n          else \n             \\<mu> fs (i - 1) j\n        else if ii > i \\<and> j = i then\n           \\<mu> fs ii (i - 1) - \\<mu> fs i (i - 1) * \\<mu> fs ii i\n        else if ii > i \\<and> j = i - 1 then \n           \\<mu> fs ii (i - 1) * \\<mu> fs' i (i - 1) + \\<mu> fs ii i * sq_norm (gso fs i) / sq_norm (gso fs' (i - 1))\n        else \\<mu> fs ii j)\" (is \"\\<And> ii j. _ \\<Longrightarrow> _ \\<Longrightarrow> _ = ?new_mu ii j\")\n  (* new d-values *)\n  and \"\\<And> ii. ii \\<le> m \\<Longrightarrow> of_int (d fs' ii) = (if ii = i then \n       sq_norm (gso fs' (i - 1)) / sq_norm (gso fs (i - 1)) * of_int (d fs i)\n       else of_int (d fs ii))\"", "lemma LLL_inv_initial_state: \"LLL_invariant True 0 fs_init\"", "lemma LLL_inv_m_imp_reduced: assumes \"LLL_invariant True m fs\" \n  shows \"reduced fs m\"", "lemma basis_reduction_short_vector: assumes LLL_inv: \"LLL_invariant True m fs\" \n  and v: \"v = hd fs\" \n  and m0: \"m \\<noteq> 0\"\nshows \"v \\<in> carrier_vec n\"\n  \"v \\<in> L - {0\\<^sub>v n}\"  \n  \"h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow> rat_of_int (sq_norm v) \\<le> \\<alpha> ^ (m - 1) * rat_of_int (sq_norm h)\" \n  \"v \\<noteq> 0\\<^sub>v j\"", "lemma LLL_mu_d_Z: assumes inv: \"LLL_invariant_weak fs\" \n  and j: \"j \\<le> ii\" and ii: \"ii < m\" \nshows \"of_int (d fs (Suc j)) * \\<mu> fs ii j \\<in> \\<int>\"", "lemma LLL_inv_N_pos: assumes m: \"m \\<noteq> 0\" \nshows \"N > 0\"", "lemma d_approx_main: assumes i: \"ii \\<le> m\" \"m \\<noteq> 0\" \nshows \"rat_of_int (d fs ii) \\<le> rat_of_nat (N^ii)\"", "lemma d_approx: assumes i: \"ii < m\"  \n  shows \"rat_of_int (d fs ii) \\<le> rat_of_nat (N^ii)\"", "lemma d_bound: assumes i: \"ii < m\" \n  shows \"d fs ii \\<le> N^ii\"", "lemma D_approx: \"D fs \\<le> N ^ (m * m)\"", "lemma LLL_measure_approx: assumes \"\\<alpha> > 4/3\" \"m \\<noteq> 0\" \nshows \"LLL_measure i fs \\<le> m + 2 * m * m * log base N\"", "lemma g_bound_fs_init: \"g_bound fs_init\"", "lemma LLL_measure_approx_fs_init: \n  \"LLL_invariant upw i fs_init \\<Longrightarrow> 4 / 3 < \\<alpha> \\<Longrightarrow> m \\<noteq> 0 \\<Longrightarrow> \n  real (LLL_measure i fs_init) \\<le> real m + real (2 * m * m) * log base (real N)\"", "lemma N_le_MMn: assumes m0: \"m \\<noteq> 0\" \n  shows \"N \\<le> nat M * nat M * n\"", "lemma basis_reduction_add_rows_loop: assumes \n  inv: \"LLL_invariant True i fs\" \n  and mu_small: \"\\<mu>_small_row i fs j\"\n  and res: \"basis_reduction_add_rows_loop i fs j = fs'\" \n  and i: \"i < m\" \n  and j: \"j \\<le> i\" \nshows \"LLL_invariant False i fs'\" \"LLL_measure i fs' = LLL_measure i fs\"", "lemma basis_reduction_add_rows: assumes \n  inv: \"LLL_invariant upw i fs\" \n  and res: \"basis_reduction_add_rows upw i fs = fs'\" \n  and i: \"i < m\" \nshows \"LLL_invariant False i fs'\" \"LLL_measure i fs' = LLL_measure i fs\"", "lemma basis_reduction_swap: assumes \n  inv: \"LLL_invariant False i fs\" \n  and res: \"basis_reduction_swap i fs = (upw',i',fs')\" \n  and cond: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\" \n  and i: \"i < m\" \"i \\<noteq> 0\" \nshows \"LLL_invariant upw' i' fs'\" (is ?g1)\n  \"LLL_measure i' fs' < LLL_measure i fs\" (is ?g2)", "lemma basis_reduction_step: assumes \n  inv: \"LLL_invariant upw i fs\" \n  and res: \"basis_reduction_step upw i fs = (upw',i',fs')\" \n  and i: \"i < m\" \nshows \"LLL_invariant upw' i' fs'\" \"LLL_measure i' fs' < LLL_measure i fs\"", "lemma basis_reduction_main: assumes \"LLL_invariant upw i fs\" \n  and res: \"basis_reduction_main (upw,i,fs) = fs'\" \nshows \"LLL_invariant True m fs'\"", "lemma reduce_basis_inv: assumes res: \"reduce_basis = fs\" \n  shows \"LLL_invariant True m fs\"", "lemma reduce_basis: assumes res: \"reduce_basis = fs\"\n  shows \"lattice_of fs = L\" \n  \"reduced fs m\" \n  \"lin_indep fs\" \n  \"length fs = m\"", "lemma short_vector: assumes res: \"short_vector = v\" \n  and m0: \"m \\<noteq> 0\"\nshows \"v \\<in> carrier_vec n\"\n  \"v \\<in> L - {0\\<^sub>v n}\"  \n  \"h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow> rat_of_int (sq_norm v) \\<le> \\<alpha> ^ (m - 1) * rat_of_int (sq_norm h)\" \n  \"v \\<noteq> 0\\<^sub>v j\""], "translations": [["", "lemma LLL_inv_wD: assumes \"LLL_invariant_weak fs\"\n  shows \n  \"lin_indep fs\" \n  \"length (RAT fs) = m\" \n  \"set fs \\<subseteq> carrier_vec n\"\n  \"\\<And> i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n\" \n  \"\\<And> i. i < m \\<Longrightarrow> gso fs i \\<in> carrier_vec n\" \n  \"length fs = m\"\n  \"lattice_of fs = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gs.lin_indpt_list (map of_int_hom.vec_hom fs) &&&\n     length (map of_int_hom.vec_hom fs) = m &&&\n     set fs \\<subseteq> carrier_vec n) &&&\n    ((\\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n) &&&\n     (\\<And>i.\n         i < m \\<Longrightarrow>\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i \\<in> Rn)) &&&\n    length fs = m &&& lattice_of fs = L", "proof (atomize (full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n     length (map of_int_hom.vec_hom fs) = m \\<and>\n     set fs \\<subseteq> carrier_vec n) \\<and>\n    ((\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n     (\\<forall>i<m.\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n         \\<in> Rn)) \\<and>\n    length fs = m \\<and> lattice_of fs = L", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n     length (map of_int_hom.vec_hom fs) = m \\<and>\n     set fs \\<subseteq> carrier_vec n) \\<and>\n    ((\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n     (\\<forall>i<m.\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n         \\<in> Rn)) \\<and>\n    length fs = m \\<and> lattice_of fs = L", "interpret gs': gram_schmidt_fs_lin_indpt n \"RAT fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_lin_indpt n (map of_int_hom.vec_hom fs)", "by (standard) (use assms LLL_invariant_weak_def gs.lin_indpt_list_def in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. (gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n     length (map of_int_hom.vec_hom fs) = m \\<and>\n     set fs \\<subseteq> carrier_vec n) \\<and>\n    ((\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n     (\\<forall>i<m. gs'.gso i \\<in> Rn)) \\<and>\n    length fs = m \\<and> lattice_of fs = L", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n     length (map of_int_hom.vec_hom fs) = m \\<and>\n     set fs \\<subseteq> carrier_vec n) \\<and>\n    ((\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n     (\\<forall>i<m. gs'.gso i \\<in> Rn)) \\<and>\n    length fs = m \\<and> lattice_of fs = L", "using assms gs'.fs_carrier gs'.f_carrier gs'.gso_carrier"], ["proof (prove)\nusing this:\n  LLL_invariant_weak fs\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i \\<in> Rn\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs'.gso ?i \\<in> Rn\n\ngoal (1 subgoal):\n 1. (gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n     length (map of_int_hom.vec_hom fs) = m \\<and>\n     set fs \\<subseteq> carrier_vec n) \\<and>\n    ((\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n     (\\<forall>i<m. gs'.gso i \\<in> Rn)) \\<and>\n    length fs = m \\<and> lattice_of fs = L", "by (auto simp add: LLL_invariant_weak_def gram_schmidt_fs.reduced_def)"], ["proof (state)\nthis:\n  (gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n   length (map of_int_hom.vec_hom fs) = m \\<and>\n   set fs \\<subseteq> carrier_vec n) \\<and>\n  ((\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n   (\\<forall>i<m. gs'.gso i \\<in> Rn)) \\<and>\n  length fs = m \\<and> lattice_of fs = L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_inv_wI: assumes  \n  \"set fs \\<subseteq> carrier_vec n\"\n  \"length fs = m\"\n  \"lattice_of fs = L\" \n  \"lin_indep fs\" \nshows \"LLL_invariant_weak fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant_weak fs", "unfolding LLL_invariant_weak_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n    lattice_of fs = L \\<and> length fs = m", "using assms"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  length fs = m\n  lattice_of fs = L\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n    lattice_of fs = L \\<and> length fs = m", "by auto"], ["", "definition LLL_invariant :: \"bool \\<Rightarrow> nat \\<Rightarrow> int vec list \\<Rightarrow> bool\" where \n  \"LLL_invariant upw i fs = ( \n    gs.lin_indpt_list (RAT fs) \\<and> \n    lattice_of fs = L \\<and>\n    reduced fs i \\<and>\n    i \\<le> m \\<and> \n    length fs = m \\<and>\n    (upw \\<or> \\<mu>_small fs i)    \n  )\""], ["", "lemma LLL_inv_imp_w: \"LLL_invariant upw i fs \\<Longrightarrow> LLL_invariant_weak fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant upw i fs \\<Longrightarrow> LLL_invariant_weak fs", "unfolding LLL_invariant_def LLL_invariant_weak_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n    lattice_of fs = L \\<and>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i \\<and>\n    i \\<le> m \\<and>\n    length fs = m \\<and> (upw \\<or> \\<mu>_small fs i) \\<Longrightarrow>\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n    lattice_of fs = L \\<and> length fs = m", "by blast"], ["", "lemma LLL_invD: assumes \"LLL_invariant upw i fs\"\n  shows \n  \"lin_indep fs\" \n  \"length (RAT fs) = m\" \n  \"set fs \\<subseteq> carrier_vec n\"\n  \"\\<And> i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n\" \n  \"\\<And> i. i < m \\<Longrightarrow> gso fs i \\<in> carrier_vec n\" \n  \"length fs = m\"\n  \"lattice_of fs = L\" \n  \"weakly_reduced fs i\"\n  \"i \\<le> m\"\n  \"reduced fs i\" \n  \"upw \\<or> \\<mu>_small fs i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((gs.lin_indpt_list (map of_int_hom.vec_hom fs) &&&\n      length (map of_int_hom.vec_hom fs) = m) &&&\n     set fs \\<subseteq> carrier_vec n &&&\n     (\\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n) &&&\n     (\\<And>i.\n         i < m \\<Longrightarrow>\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i \\<in> Rn)) &&&\n    (length fs = m &&&\n     lattice_of fs = L &&&\n     gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n      i) &&&\n    i \\<le> m &&&\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i &&&\n    upw \\<or> \\<mu>_small fs i", "proof (atomize (full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. ((gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n      length (map of_int_hom.vec_hom fs) = m) \\<and>\n     set fs \\<subseteq> carrier_vec n \\<and>\n     (\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n     (\\<forall>i<m.\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n         \\<in> Rn)) \\<and>\n    (length fs = m \\<and>\n     lattice_of fs = L \\<and>\n     gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n      i) \\<and>\n    i \\<le> m \\<and>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i \\<and>\n    (upw \\<or> \\<mu>_small fs i)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. ((gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n      length (map of_int_hom.vec_hom fs) = m) \\<and>\n     set fs \\<subseteq> carrier_vec n \\<and>\n     (\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n     (\\<forall>i<m.\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n         \\<in> Rn)) \\<and>\n    (length fs = m \\<and>\n     lattice_of fs = L \\<and>\n     gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n      i) \\<and>\n    i \\<le> m \\<and>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i \\<and>\n    (upw \\<or> \\<mu>_small fs i)", "interpret gs': gram_schmidt_fs_lin_indpt n \"RAT fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_lin_indpt n (map of_int_hom.vec_hom fs)", "by (standard) (use assms LLL_invariant_def gs.lin_indpt_list_def in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. ((gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n      length (map of_int_hom.vec_hom fs) = m) \\<and>\n     set fs \\<subseteq> carrier_vec n \\<and>\n     (\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n     (\\<forall>i<m. gs'.gso i \\<in> Rn)) \\<and>\n    (length fs = m \\<and>\n     lattice_of fs = L \\<and> gs'.weakly_reduced \\<alpha> i) \\<and>\n    i \\<le> m \\<and>\n    gs'.reduced \\<alpha> i \\<and> (upw \\<or> \\<mu>_small fs i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n      length (map of_int_hom.vec_hom fs) = m) \\<and>\n     set fs \\<subseteq> carrier_vec n \\<and>\n     (\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n     (\\<forall>i<m. gs'.gso i \\<in> Rn)) \\<and>\n    (length fs = m \\<and>\n     lattice_of fs = L \\<and> gs'.weakly_reduced \\<alpha> i) \\<and>\n    i \\<le> m \\<and>\n    gs'.reduced \\<alpha> i \\<and> (upw \\<or> \\<mu>_small fs i)", "using assms gs'.fs_carrier gs'.f_carrier gs'.gso_carrier"], ["proof (prove)\nusing this:\n  LLL_invariant upw i fs\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i \\<in> Rn\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs'.gso ?i \\<in> Rn\n\ngoal (1 subgoal):\n 1. ((gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n      length (map of_int_hom.vec_hom fs) = m) \\<and>\n     set fs \\<subseteq> carrier_vec n \\<and>\n     (\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n     (\\<forall>i<m. gs'.gso i \\<in> Rn)) \\<and>\n    (length fs = m \\<and>\n     lattice_of fs = L \\<and> gs'.weakly_reduced \\<alpha> i) \\<and>\n    i \\<le> m \\<and>\n    gs'.reduced \\<alpha> i \\<and> (upw \\<or> \\<mu>_small fs i)", "by (auto simp add: LLL_invariant_def gram_schmidt_fs.reduced_def)"], ["proof (state)\nthis:\n  ((gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n    length (map of_int_hom.vec_hom fs) = m) \\<and>\n   set fs \\<subseteq> carrier_vec n \\<and>\n   (\\<forall>i<m. fs ! i \\<in> carrier_vec n) \\<and>\n   (\\<forall>i<m. gs'.gso i \\<in> Rn)) \\<and>\n  (length fs = m \\<and>\n   lattice_of fs = L \\<and> gs'.weakly_reduced \\<alpha> i) \\<and>\n  i \\<le> m \\<and>\n  gs'.reduced \\<alpha> i \\<and> (upw \\<or> \\<mu>_small fs i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_invI: assumes  \n  \"set fs \\<subseteq> carrier_vec n\"\n  \"length fs = m\"\n  \"lattice_of fs = L\" \n  \"i \\<le> m\"\n  \"lin_indep fs\" \n  \"reduced fs i\" \n  \"upw \\<or> \\<mu>_small fs i\" \nshows \"LLL_invariant upw i fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant upw i fs", "unfolding LLL_invariant_def Let_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n    lattice_of fs = L \\<and>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i \\<and>\n    i \\<le> m \\<and> length fs = m \\<and> (upw \\<or> \\<mu>_small fs i)", "using assms"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  length fs = m\n  lattice_of fs = L\n  i \\<le> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n    lattice_of fs = L \\<and>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i \\<and>\n    i \\<le> m \\<and> length fs = m \\<and> (upw \\<or> \\<mu>_small fs i)", "by auto"], ["", "end"], ["", "locale fs_int' =\n  fixes n m fs_init fs \n  assumes LLL_inv: \"LLL.LLL_invariant_weak n m fs_init fs\""], ["", "sublocale fs_int' \\<subseteq> fs_int_indpt"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int_indpt n fs", "using LLL_inv"], ["proof (prove)\nusing this:\n  LLL.LLL_invariant_weak n m fs_init fs\n\ngoal (1 subgoal):\n 1. fs_int_indpt n fs", "unfolding LLL.LLL_invariant_weak_def"], ["proof (prove)\nusing this:\n  cof_vec_space.lin_indpt_list n (map of_int_hom.vec_hom fs) \\<and>\n  vec_module.lattice_of n fs = LLL.L n fs_init \\<and> length fs = m\n\ngoal (1 subgoal):\n 1. fs_int_indpt n fs", "by (unfold_locales) blast"], ["", "context LLL\nbegin"], ["", "lemma gso_cong: assumes \"\\<And> i. i \\<le> x \\<Longrightarrow> f1 ! i = f2 ! i\"\n   \"x < length f1\" \"x < length f2\" \n  shows \"gso f1 x = gso f2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.gso n (map of_int_hom.vec_hom f1) x =\n    gram_schmidt_fs.gso n (map of_int_hom.vec_hom f2) x", "by (rule gs.gso_cong, insert assms, auto)"], ["", "lemma \\<mu>_cong: assumes \"\\<And> k. j < i \\<Longrightarrow> k \\<le> j \\<Longrightarrow> f1 ! k = f2 ! k\"\n  and i: \"i < length f1\" \"i < length f2\" \n  and \"j < i \\<Longrightarrow> f1 ! i = f2 ! i\" \n  shows \"\\<mu> f1 i j = \\<mu> f2 i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom f1) i j =\n    gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom f2) i j", "by (rule gs.\\<mu>_cong, insert assms, auto)"], ["", "definition reduction where \"reduction = (4+\\<alpha>)/(4*\\<alpha>)\""], ["", "definition d :: \"int vec list \\<Rightarrow> nat \\<Rightarrow> int\" where \"d fs k = gs.Gramian_determinant fs k\""], ["", "definition D :: \"int vec list \\<Rightarrow> nat\" where \"D fs = nat (\\<Prod> i < m. d fs i)\""], ["", "definition \"d\\<mu> gs i j = int_of_rat (of_int (d gs (Suc j)) * \\<mu> gs i j)\""], ["", "definition logD :: \"int vec list \\<Rightarrow> nat\"\n  where \"logD fs = (if \\<alpha> = 4/3 then (D fs) else nat (floor (log (1 / of_rat reduction) (D fs))))\""], ["", "definition LLL_measure :: \"nat \\<Rightarrow> int vec list \\<Rightarrow> nat\" where \n  \"LLL_measure i fs = (2 * logD fs + m - i)\""], ["", "context\n  fixes fs\n  assumes Linv: \"LLL_invariant_weak fs\"\nbegin"], ["", "interpretation fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by (standard) (use Linv in auto)"], ["", "lemma Gramian_determinant:\n  assumes k: \"k \\<le> m\" \nshows \"of_int (gs.Gramian_determinant fs k) = (\\<Prod> j<k. sq_norm (gso fs j))\" (is ?g1)\n  \"gs.Gramian_determinant fs k > 0\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs k) =\n    (\\<Prod>j<k. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) &&&\n    0 < gs.Gramian_determinant fs k", "using assms fs.Gramian_determinant LLL_inv_wD[OF Linv]"], ["proof (prove)\nusing this:\n  k \\<le> m\n  ?k \\<le> length fs \\<Longrightarrow>\n  rat_of_int (gs.Gramian_determinant fs ?k) =\n  (\\<Prod>j<?k. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n  ?k \\<le> length fs \\<Longrightarrow> 0 < gs.Gramian_determinant fs ?k\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs k) =\n    (\\<Prod>j<k. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) &&&\n    0 < gs.Gramian_determinant fs k", "by auto"], ["", "lemma LLL_d_pos [intro]: assumes k: \"k \\<le> m\" \nshows \"d fs k > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d fs k", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < gs.Gramian_determinant fs k", "using fs.Gramian_determinant k LLL_inv_wD[OF Linv]"], ["proof (prove)\nusing this:\n  ?k \\<le> length fs \\<Longrightarrow>\n  rat_of_int (gs.Gramian_determinant fs ?k) =\n  (\\<Prod>j<?k. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n  ?k \\<le> length fs \\<Longrightarrow> 0 < gs.Gramian_determinant fs ?k\n  k \\<le> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. 0 < gs.Gramian_determinant fs k", "by auto"], ["", "lemma LLL_d_Suc: assumes k: \"k < m\" \nshows \"of_int (d fs (Suc k)) = sq_norm (gso fs k) * of_int (d fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) =\n    \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k)", "using assms fs.fs_int_d_Suc  LLL_inv_wD[OF Linv]"], ["proof (prove)\nusing this:\n  k < m\n  ?k < length fs \\<Longrightarrow>\n  rat_of_int (fs.d fs (Suc ?k)) =\n  \\<parallel>fs.gs.gso ?k\\<parallel>\\<^sup>2 * rat_of_int (fs.d fs ?k)\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) =\n    \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k)", "unfolding fs.d_def d_def"], ["proof (prove)\nusing this:\n  k < m\n  ?k < length fs \\<Longrightarrow>\n  rat_of_int (gs.Gramian_determinant fs (Suc ?k)) =\n  \\<parallel>fs.gs.gso ?k\\<parallel>\\<^sup>2 *\n  rat_of_int (gs.Gramian_determinant fs ?k)\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs (Suc k)) =\n    \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 *\n    rat_of_int (gs.Gramian_determinant fs k)", "by auto"], ["", "lemma LLL_D_pos:\n  shows \"D fs > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < D fs", "using fs.fs_int_D_pos LLL_inv_wD[OF Linv]"], ["proof (prove)\nusing this:\n  0 < fs.D fs\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. 0 < D fs", "unfolding D_def fs.D_def fs.d_def d_def"], ["proof (prove)\nusing this:\n  0 < nat (prod (gs.Gramian_determinant fs) {..<length fs})\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. 0 < nat (prod (gs.Gramian_determinant fs) {..<m})", "by auto"], ["", "end"], ["", "text \\<open>Condition when we can increase the value of $i$\\<close>"], ["", "lemma increase_i:\n  assumes Linv: \"LLL_invariant upw i fs\"\n  assumes i: \"i < m\" \n  and upw: \"upw \\<Longrightarrow> i = 0\" \n  and red_i: \"i \\<noteq> 0 \\<Longrightarrow> sq_norm (gso fs (i - 1)) \\<le> \\<alpha> * sq_norm (gso fs i)\"\nshows \"LLL_invariant True (Suc i) fs\" \"LLL_measure i fs > LLL_measure (Suc i) fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True (Suc i) fs &&&\n    LLL_measure (Suc i) fs < LLL_measure i fs", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_invariant True (Suc i) fs\n 2. LLL_measure (Suc i) fs < LLL_measure i fs", "note inv = LLL_invD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i\n\ngoal (2 subgoals):\n 1. LLL_invariant True (Suc i) fs\n 2. LLL_measure (Suc i) fs < LLL_measure i fs", "from inv(8,10)"], ["proof (chain)\npicking this:\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i", "have red: \"weakly_reduced fs i\" \n    and sred: \"reduced fs i\""], ["proof (prove)\nusing this:\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n     i &&&\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i", "by (auto)"], ["proof (state)\nthis:\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n\ngoal (2 subgoals):\n 1. LLL_invariant True (Suc i) fs\n 2. LLL_measure (Suc i) fs < LLL_measure i fs", "from red red_i i"], ["proof (chain)\npicking this:\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<noteq> 0 \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    i\\<parallel>\\<^sup>2\n  i < m", "have red: \"weakly_reduced fs (Suc i)\""], ["proof (prove)\nusing this:\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<noteq> 0 \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    i\\<parallel>\\<^sup>2\n  i < m\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n     (Suc i)", "unfolding gram_schmidt_fs.weakly_reduced_def"], ["proof (prove)\nusing this:\n  \\<forall>ia.\n     Suc ia < i \\<longrightarrow>\n     \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                 ia\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> *\n           \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                       (Suc ia)\\<parallel>\\<^sup>2\n  i \\<noteq> 0 \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    i\\<parallel>\\<^sup>2\n  i < m\n\ngoal (1 subgoal):\n 1. \\<forall>ia.\n       Suc ia < Suc i \\<longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                   ia\\<parallel>\\<^sup>2\n       \\<le> \\<alpha> *\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         (Suc ia)\\<parallel>\\<^sup>2", "by (intro allI impI, rename_tac ii, case_tac \"Suc ii = i\", auto)"], ["proof (state)\nthis:\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n   (Suc i)\n\ngoal (2 subgoals):\n 1. LLL_invariant True (Suc i) fs\n 2. LLL_measure (Suc i) fs < LLL_measure i fs", "from inv(11) upw"], ["proof (chain)\npicking this:\n  upw \\<or> \\<mu>_small fs i\n  upw \\<Longrightarrow> i = 0", "have sred_i: \"\\<And> j. j < i \\<Longrightarrow> \\<bar>\\<mu> fs i j\\<bar> \\<le> 1 / 2\""], ["proof (prove)\nusing this:\n  upw \\<or> \\<mu>_small fs i\n  upw \\<Longrightarrow> i = 0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < i \\<Longrightarrow>\n       \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n       \\<le> 1 / 2", "unfolding \\<mu>_small_def"], ["proof (prove)\nusing this:\n  upw \\<or>\n  (\\<forall>j<i.\n      \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n      \\<le> 1 / 2)\n  upw \\<Longrightarrow> i = 0\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < i \\<Longrightarrow>\n       \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n       \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  ?j1 < i \\<Longrightarrow>\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i ?j1\\<bar>\n  \\<le> 1 / 2\n\ngoal (2 subgoals):\n 1. LLL_invariant True (Suc i) fs\n 2. LLL_measure (Suc i) fs < LLL_measure i fs", "from sred sred_i"], ["proof (chain)\npicking this:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  ?j1 < i \\<Longrightarrow>\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i ?j1\\<bar>\n  \\<le> 1 / 2", "have sred: \"reduced fs (Suc i)\""], ["proof (prove)\nusing this:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  ?j1 < i \\<Longrightarrow>\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i ?j1\\<bar>\n  \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> (Suc i)", "unfolding gram_schmidt_fs.reduced_def"], ["proof (prove)\nusing this:\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n   i \\<and>\n  (\\<forall>ia j.\n      ia < i \\<longrightarrow>\n      j < ia \\<longrightarrow>\n      \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ia j\\<bar>\n      \\<le> 1 / 2)\n  ?j1 < i \\<Longrightarrow>\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i ?j1\\<bar>\n  \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n     (Suc i) \\<and>\n    (\\<forall>ia j.\n        ia < Suc i \\<longrightarrow>\n        j < ia \\<longrightarrow>\n        \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ia j\\<bar>\n        \\<le> 1 / 2)", "by (intro conjI[OF red] allI impI, rename_tac ii j, case_tac \"ii = i\", auto)"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> (Suc i)\n\ngoal (2 subgoals):\n 1. LLL_invariant True (Suc i) fs\n 2. LLL_measure (Suc i) fs < LLL_measure i fs", "show \"LLL_invariant True (Suc i) fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True (Suc i) fs", "by (intro LLL_invI, insert inv red sred i, auto)"], ["proof (state)\nthis:\n  LLL_invariant True (Suc i) fs\n\ngoal (1 subgoal):\n 1. LLL_measure (Suc i) fs < LLL_measure i fs", "show \"LLL_measure i fs > LLL_measure (Suc i) fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_measure (Suc i) fs < LLL_measure i fs", "unfolding LLL_measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * logD fs + m - Suc i < 2 * logD fs + m - i", "using i"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. 2 * logD fs + m - Suc i < 2 * logD fs + m - i", "by auto"], ["proof (state)\nthis:\n  LLL_measure (Suc i) fs < LLL_measure i fs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Standard addition step which makes $\\mu_{i,j}$ small\\<close>"], ["", "definition \"\\<mu>_small_row i fs j = (\\<forall> j'. j \\<le> j' \\<longrightarrow> j' < i \\<longrightarrow> abs (\\<mu> fs i j') \\<le> inverse 2)\""], ["", "lemma basis_reduction_add_row_main: assumes Linv: \"LLL_invariant_weak fs\"\n  and i: \"i < m\"  and j: \"j < i\" \n  and fs': \"fs' = fs[ i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]\" \nshows \"LLL_invariant_weak fs'\" \n  \"LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\"\n  \"c = round (\\<mu> fs i j) \\<Longrightarrow> \\<mu>_small_row i fs (Suc j) \\<Longrightarrow> \\<mu>_small_row i fs' j\" (* mu-value at position i j gets small *)\n  \"c = round (\\<mu> fs i j) \\<Longrightarrow> abs (\\<mu> fs' i j) \\<le> 1/2\" (* mu-value at position i j gets small *)\n  \"LLL_measure i fs' = LLL_measure i fs\" \n  (* new values of gso: no change *)\n  \"\\<And> i. i < m \\<Longrightarrow> gso fs' i = gso fs i\" \n  (* new values of mu *)\n  \"\\<And> i' j'. i' < m \\<Longrightarrow> j' < m \\<Longrightarrow>       \n     \\<mu> fs' i' j' = (if i' = i \\<and> j' \\<le> j then \\<mu> fs i j' - of_int c * \\<mu> fs j j' else \\<mu> fs i' j')\"\n  (* new values of d *)\n  \"\\<And> ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((LLL_invariant_weak fs' &&&\n      (LLL_invariant True i fs \\<Longrightarrow>\n       LLL_invariant True i fs')) &&&\n     (\\<lbrakk>c =\n               round\n                (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n       \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n      \\<Longrightarrow> \\<mu>_small_row i fs' j) &&&\n     (c =\n      round\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n         j) \\<Longrightarrow>\n      \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n      \\<le> 1 / 2)) &&&\n    (LLL_measure i fs' = LLL_measure i fs &&&\n     (\\<And>i.\n         i < m \\<Longrightarrow>\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i)) &&&\n    (\\<And>i' j'.\n        \\<lbrakk>i' < m; j' < m\\<rbrakk>\n        \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs') i' j' =\n                          (if i' = i \\<and> j' \\<le> j\n                           then gram_schmidt_fs.\\<mu> n\n                                 (map of_int_hom.vec_hom fs) i j' -\n                                rat_of_int c *\n                                gram_schmidt_fs.\\<mu> n\n                                 (map of_int_hom.vec_hom fs) j j'\n                           else gram_schmidt_fs.\\<mu> n\n                                 (map of_int_hom.vec_hom fs) i' j')) &&&\n    (\\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii)", "proof -"], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "define bnd :: rat where bnd: \"bnd = 4 ^ (m - 1 - Suc j) * of_nat (N ^ (m - 1) * m)\""], ["proof (state)\nthis:\n  bnd = 4 ^ (m - 1 - Suc j) * rat_of_nat (N ^ (m - 1) * m)\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "define M where \"M = map (\\<lambda>i. map (\\<mu> fs i) [0..<m]) [0..<m]\""], ["proof (state)\nthis:\n  M =\n  map (\\<lambda>i.\n          map (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i)\n           [0..<m])\n   [0..<m]\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "note inv = LLL_inv_wD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "note Gr = inv(1)"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have ji: \"j \\<le> i\" \"j < m\" and jstrict: \"j < i\" \n    and add: \"set fs \\<subseteq> carrier_vec n\" \"i < length fs\" \"j < length fs\" \"i \\<noteq> j\" \n    and len: \"length fs = m\" \n    and indep: \"lin_indep fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((j \\<le> i &&& j < m) &&& j < i) &&&\n    ((set fs \\<subseteq> carrier_vec n &&& i < length fs) &&&\n     j < length fs &&& i \\<noteq> j) &&&\n    length fs = m &&& gs.lin_indpt_list (map of_int_hom.vec_hom fs)", "using inv j i"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  j < i\n  i < m\n\ngoal (1 subgoal):\n 1. ((j \\<le> i &&& j < m) &&& j < i) &&&\n    ((set fs \\<subseteq> carrier_vec n &&& i < length fs) &&&\n     j < length fs &&& i \\<noteq> j) &&&\n    length fs = m &&& gs.lin_indpt_list (map of_int_hom.vec_hom fs)", "by auto"], ["proof (state)\nthis:\n  j \\<le> i\n  j < m\n  j < i\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  length fs = m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?R = rat_of_int"], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?RV = \"map_vec ?R\""], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from inv i j"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  i < m\n  j < i", "have Fij: \"fs ! i \\<in> carrier_vec n\" \"fs ! j \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n &&& fs ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  fs ! i \\<in> carrier_vec n\n  fs ! j \\<in> carrier_vec n\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?x = \"fs ! i - c \\<cdot>\\<^sub>v fs ! j\""], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?g = \"gso fs\""], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?g' = \"gso fs'\""], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?mu = \"\\<mu> fs\""], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?mu' = \"\\<mu> fs'\""], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from inv j i"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  j < i\n  i < m", "have Fi:\"\\<And> i. i < length (RAT fs) \\<Longrightarrow> (RAT fs) ! i \\<in> carrier_vec n\"\n    and gs_carr: \"?g j \\<in> carrier_vec n\"\n                \"?g i \\<in> carrier_vec n\"\n                \"\\<And> i. i < j \\<Longrightarrow> ?g i \\<in> carrier_vec n\"\n                \"\\<And> j. j < i \\<Longrightarrow> ?g j \\<in> carrier_vec n\" \n    and len': \"length (RAT fs) = m\"\n    and add':\"set (map ?RV fs) \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  j < i\n  i < m\n\ngoal (1 subgoal):\n 1. ((\\<And>i.\n         i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n         map of_int_hom.vec_hom fs ! i \\<in> Rn) &&&\n     (gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) j \\<in> Rn &&&\n      gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i \\<in> Rn) &&&\n     (\\<And>i.\n         i < j \\<Longrightarrow>\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i \\<in> Rn) &&&\n     (\\<And>j.\n         j < i \\<Longrightarrow>\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) j \\<in> Rn)) &&&\n    length (map of_int_hom.vec_hom fs) = m &&&\n    set (map of_int_hom.vec_hom fs) \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  ?i1 < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i1 \\<in> Rn\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) j \\<in> Rn\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i \\<in> Rn\n  ?i1 < j \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i1 \\<in> Rn\n  ?j1 < i \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?j1 \\<in> Rn\n  length (map of_int_hom.vec_hom fs) = m\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have RAT_F1: \"RAT fs' = (RAT fs)[i := (RAT fs) ! i - ?R c \\<cdot>\\<^sub>v (RAT fs) ! j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' = (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j]", "unfolding fs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j]", "proof (rule nth_equalityI[rule_format], goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. length\n     (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j])) =\n    length\n     ((map of_int_hom.vec_hom fs)\n      [i := map of_int_hom.vec_hom fs ! i -\n            rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j])\n 2. \\<And>ia.\n       ia < length\n             (map of_int_hom.vec_hom\n               (fs[i := fs ! i -\n                        c \\<cdot>\\<^sub>v fs ! j])) \\<Longrightarrow>\n       map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n       ia =\n       (map of_int_hom.vec_hom fs)\n       [i := map of_int_hom.vec_hom fs ! i -\n             rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n       ia", "case (2 k)"], ["proof (state)\nthis:\n  k < length\n       (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]))\n\ngoal (2 subgoals):\n 1. length\n     (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j])) =\n    length\n     ((map of_int_hom.vec_hom fs)\n      [i := map of_int_hom.vec_hom fs ! i -\n            rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j])\n 2. \\<And>ia.\n       ia < length\n             (map of_int_hom.vec_hom\n               (fs[i := fs ! i -\n                        c \\<cdot>\\<^sub>v fs ! j])) \\<Longrightarrow>\n       map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n       ia =\n       (map of_int_hom.vec_hom fs)\n       [i := map of_int_hom.vec_hom fs ! i -\n             rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n       ia", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "proof (cases \"k = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow>\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k\n 2. k \\<noteq> i \\<Longrightarrow>\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> i\n\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow>\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k\n 2. k \\<noteq> i \\<Longrightarrow>\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "using 2"], ["proof (prove)\nusing this:\n  k \\<noteq> i\n  k < length\n       (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]))\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) ! k =\n  (map of_int_hom.vec_hom fs)\n  [i := map of_int_hom.vec_hom fs ! i -\n        rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n  k\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow>\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow>\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "case True"], ["proof (state)\nthis:\n  k = i\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow>\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "hence \"?thesis = (?RV (fs ! i - c \\<cdot>\\<^sub>v fs ! j) =\n          ?RV (fs ! i) - ?R c \\<cdot>\\<^sub>v ?RV (fs ! j))\""], ["proof (prove)\nusing this:\n  k = i\n\ngoal (1 subgoal):\n 1. (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n     k =\n     (map of_int_hom.vec_hom fs)\n     [i := map of_int_hom.vec_hom fs ! i -\n           rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n     k) =\n    (of_int_hom.vec_hom (fs ! i - c \\<cdot>\\<^sub>v fs ! j) =\n     of_int_hom.vec_hom (fs ! i) -\n     rat_of_int c \\<cdot>\\<^sub>v of_int_hom.vec_hom (fs ! j))", "using 2 add"], ["proof (prove)\nusing this:\n  k = i\n  k < length\n       (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]))\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n     k =\n     (map of_int_hom.vec_hom fs)\n     [i := map of_int_hom.vec_hom fs ! i -\n           rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n     k) =\n    (of_int_hom.vec_hom (fs ! i - c \\<cdot>\\<^sub>v fs ! j) =\n     of_int_hom.vec_hom (fs ! i) -\n     rat_of_int c \\<cdot>\\<^sub>v of_int_hom.vec_hom (fs ! j))", "by auto"], ["proof (state)\nthis:\n  (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) ! k =\n   (map of_int_hom.vec_hom fs)\n   [i := map of_int_hom.vec_hom fs ! i -\n         rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n   k) =\n  (of_int_hom.vec_hom (fs ! i - c \\<cdot>\\<^sub>v fs ! j) =\n   of_int_hom.vec_hom (fs ! i) -\n   rat_of_int c \\<cdot>\\<^sub>v of_int_hom.vec_hom (fs ! j))\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow>\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "also"], ["proof (state)\nthis:\n  (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) ! k =\n   (map of_int_hom.vec_hom fs)\n   [i := map of_int_hom.vec_hom fs ! i -\n         rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n   k) =\n  (of_int_hom.vec_hom (fs ! i - c \\<cdot>\\<^sub>v fs ! j) =\n   of_int_hom.vec_hom (fs ! i) -\n   rat_of_int c \\<cdot>\\<^sub>v of_int_hom.vec_hom (fs ! j))\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow>\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! i - c \\<cdot>\\<^sub>v fs ! j) =\n    of_int_hom.vec_hom (fs ! i) -\n    rat_of_int c \\<cdot>\\<^sub>v of_int_hom.vec_hom (fs ! j)", "by (rule eq_vecI, insert Fij, auto)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs ! i - c \\<cdot>\\<^sub>v fs ! j) =\n  of_int_hom.vec_hom (fs ! i) -\n  rat_of_int c \\<cdot>\\<^sub>v of_int_hom.vec_hom (fs ! j)\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow>\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "finally"], ["proof (chain)\npicking this:\n  (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) ! k =\n   (map of_int_hom.vec_hom fs)\n   [i := map of_int_hom.vec_hom fs ! i -\n         rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n   k) =\n  (of_int_hom.vec_hom (fs ! i) -\n   rat_of_int c \\<cdot>\\<^sub>v of_int_hom.vec_hom (fs ! j) =\n   of_int_hom.vec_hom (fs ! i) -\n   rat_of_int c \\<cdot>\\<^sub>v of_int_hom.vec_hom (fs ! j))", "show ?thesis"], ["proof (prove)\nusing this:\n  (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) ! k =\n   (map of_int_hom.vec_hom fs)\n   [i := map of_int_hom.vec_hom fs ! i -\n         rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n   k) =\n  (of_int_hom.vec_hom (fs ! i) -\n   rat_of_int c \\<cdot>\\<^sub>v of_int_hom.vec_hom (fs ! j) =\n   of_int_hom.vec_hom (fs ! i) -\n   rat_of_int c \\<cdot>\\<^sub>v of_int_hom.vec_hom (fs ! j))\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) !\n    k =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    k", "by simp"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) ! k =\n  (map of_int_hom.vec_hom fs)\n  [i := map of_int_hom.vec_hom fs ! i -\n        rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n  k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) ! k =\n  (map of_int_hom.vec_hom fs)\n  [i := map of_int_hom.vec_hom fs ! i -\n        rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n  k\n\ngoal (1 subgoal):\n 1. length\n     (map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j])) =\n    length\n     ((map of_int_hom.vec_hom fs)\n      [i := map of_int_hom.vec_hom fs ! i -\n            rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j])", "qed auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' = (map of_int_hom.vec_hom fs)\n  [i := map of_int_hom.vec_hom fs ! i -\n        rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j]\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "hence RAT_F1_i:\"RAT fs' ! i = (RAT fs) ! i - ?R c \\<cdot>\\<^sub>v (RAT fs) ! j\" (is \"_ = _ - ?mui\")"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' = (map of_int_hom.vec_hom fs)\n  [i := map of_int_hom.vec_hom fs ! i -\n        rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j]\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i =\n    map of_int_hom.vec_hom fs ! i -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j", "using i len"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' = (map of_int_hom.vec_hom fs)\n  [i := map of_int_hom.vec_hom fs ! i -\n        rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j]\n  i < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i =\n    map of_int_hom.vec_hom fs ! i -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i =\n  map of_int_hom.vec_hom fs ! i -\n  rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have uminus: \"fs ! i - c \\<cdot>\\<^sub>v fs ! j = fs ! i + -c \\<cdot>\\<^sub>v fs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i - c \\<cdot>\\<^sub>v fs ! j = fs ! i + - c \\<cdot>\\<^sub>v fs ! j", "by (subst minus_add_uminus_vec, insert Fij, auto)"], ["proof (state)\nthis:\n  fs ! i - c \\<cdot>\\<^sub>v fs ! j = fs ! i + - c \\<cdot>\\<^sub>v fs ! j\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"lattice_of fs' = lattice_of fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of fs' = lattice_of fs", "unfolding fs' uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of (fs[i := fs ! i + - c \\<cdot>\\<^sub>v fs ! j]) =\n    lattice_of fs", "by (rule lattice_of_add[OF add, of _ \"- c\"], auto)"], ["proof (state)\nthis:\n  lattice_of fs' = lattice_of fs\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "with inv"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  lattice_of fs' = lattice_of fs", "have lattice: \"lattice_of fs' = L\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  lattice_of fs' = lattice_of fs\n\ngoal (1 subgoal):\n 1. lattice_of fs' = L", "by auto"], ["proof (state)\nthis:\n  lattice_of fs' = L\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from add len"], ["proof (chain)\npicking this:\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  length fs = m", "have \"k < length fs \\<Longrightarrow> \\<not> k \\<noteq> i \\<Longrightarrow> fs' ! k \\<in> carrier_vec n\" for k"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  length fs = m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length fs; \\<not> k \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> fs' ! k \\<in> carrier_vec n", "unfolding fs'"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  length fs = m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length fs; \\<not> k \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j] ! k\n                      \\<in> carrier_vec n", "by (metis (no_types, lifting) nth_list_update nth_mem subset_eq carrier_dim_vec index_minus_vec(2) \n        index_smult_vec(2))"], ["proof (state)\nthis:\n  \\<lbrakk>?k1 < length fs; \\<not> ?k1 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> fs' ! ?k1 \\<in> carrier_vec n\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "hence \"k < length fs \\<Longrightarrow> fs' ! k \\<in> carrier_vec n\" for k"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k1 < length fs; \\<not> ?k1 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> fs' ! ?k1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. k < length fs \\<Longrightarrow> fs' ! k \\<in> carrier_vec n", "unfolding fs'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k1 < length fs; \\<not> ?k1 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j] ! ?k1\n                    \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. k < length fs \\<Longrightarrow>\n    fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j] ! k \\<in> carrier_vec n", "using add len"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k1 < length fs; \\<not> ?k1 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j] ! ?k1\n                    \\<in> carrier_vec n\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  length fs = m\n\ngoal (1 subgoal):\n 1. k < length fs \\<Longrightarrow>\n    fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j] ! k \\<in> carrier_vec n", "by (cases \"k \\<noteq> i\",auto)"], ["proof (state)\nthis:\n  ?k1 < length fs \\<Longrightarrow> fs' ! ?k1 \\<in> carrier_vec n\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "with len"], ["proof (chain)\npicking this:\n  length fs = m\n  ?k1 < length fs \\<Longrightarrow> fs' ! ?k1 \\<in> carrier_vec n", "have F1: \"set fs' \\<subseteq> carrier_vec n\" \"length fs' = m\""], ["proof (prove)\nusing this:\n  length fs = m\n  ?k1 < length fs \\<Longrightarrow> fs' ! ?k1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set fs' \\<subseteq> carrier_vec n &&& length fs' = m", "unfolding fs'"], ["proof (prove)\nusing this:\n  length fs = m\n  ?k1 < length fs \\<Longrightarrow>\n  fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j] ! ?k1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j])\n    \\<subseteq> carrier_vec n &&&\n    length (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]) = m", "by (auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  set fs' \\<subseteq> carrier_vec n\n  length fs' = m\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "hence F1': \"length (RAT fs') = m\" \"SRAT fs' \\<subseteq> Rn\""], ["proof (prove)\nusing this:\n  set fs' \\<subseteq> carrier_vec n\n  length fs' = m\n\ngoal (1 subgoal):\n 1. length (map of_int_hom.vec_hom fs') = m &&&\n    set (map of_int_hom.vec_hom fs') \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  length (map of_int_hom.vec_hom fs') = m\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from indep"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)", "have dist: \"distinct (RAT fs)\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. distinct (map of_int_hom.vec_hom fs)", "by (auto simp: gs.lin_indpt_list_def)"], ["proof (state)\nthis:\n  distinct (map of_int_hom.vec_hom fs)\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have Fij': \"(RAT fs) ! i \\<in> Rn\" \"(RAT fs) ! j \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i \\<in> Rn &&&\n    map of_int_hom.vec_hom fs ! j \\<in> Rn", "using add'[unfolded set_conv_nth] i \\<open>j < m\\<close> len"], ["proof (prove)\nusing this:\n  {map of_int_hom.vec_hom fs ! i |i. i < length (map of_int_hom.vec_hom fs)}\n  \\<subseteq> Rn\n  i < m\n  j < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i \\<in> Rn &&&\n    map of_int_hom.vec_hom fs ! j \\<in> Rn", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i \\<in> Rn\n  map of_int_hom.vec_hom fs ! j \\<in> Rn\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have uminus': \"(RAT fs) ! i - ?R c \\<cdot>\\<^sub>v (RAT fs) ! j = (RAT fs) ! i + - ?R c \\<cdot>\\<^sub>v (RAT fs) ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j =\n    map of_int_hom.vec_hom fs ! i +\n    - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j", "by (subst minus_add_uminus_vec[where n = n], insert Fij', auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i -\n  rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j =\n  map of_int_hom.vec_hom fs ! i +\n  - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have span_F_F1: \"gs.span (SRAT fs) = gs.span (SRAT fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (set (map of_int_hom.vec_hom fs)) =\n    gs.span (set (map of_int_hom.vec_hom fs'))", "unfolding RAT_F1 uminus'"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (set (map of_int_hom.vec_hom fs)) =\n    gs.span\n     (set ((map of_int_hom.vec_hom fs)\n           [i := map of_int_hom.vec_hom fs ! i +\n                 - rat_of_int c \\<cdot>\\<^sub>v\n                 map of_int_hom.vec_hom fs ! j]))", "by (rule gs.add_vec_span, insert len add, auto)"], ["proof (state)\nthis:\n  gs.span (set (map of_int_hom.vec_hom fs)) =\n  gs.span (set (map of_int_hom.vec_hom fs'))\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have **: \"?RV (fs ! i) + - ?R c \\<cdot>\\<^sub>v (RAT fs) ! j =  ?RV (fs ! i - c \\<cdot>\\<^sub>v fs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! i) +\n    - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j =\n    of_int_hom.vec_hom (fs ! i - c \\<cdot>\\<^sub>v fs ! j)", "by (rule eq_vecI, insert Fij len i j, auto)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs ! i) +\n  - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j =\n  of_int_hom.vec_hom (fs ! i - c \\<cdot>\\<^sub>v fs ! j)\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from i j len"], ["proof (chain)\npicking this:\n  i < m\n  j < i\n  length fs = m", "have \"j < length (RAT fs)\" \"i < length (RAT fs)\" \"i \\<noteq> j\""], ["proof (prove)\nusing this:\n  i < m\n  j < i\n  length fs = m\n\ngoal (1 subgoal):\n 1. j < length (map of_int_hom.vec_hom fs) &&&\n    i < length (map of_int_hom.vec_hom fs) &&& i \\<noteq> j", "by auto"], ["proof (state)\nthis:\n  j < length (map of_int_hom.vec_hom fs)\n  i < length (map of_int_hom.vec_hom fs)\n  i \\<noteq> j\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from gs.lin_indpt_list_add_vec[OF this indep, of \"- of_int c\"]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list\n   ((map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i +\n          - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j])", "have \"gs.lin_indpt_list ((RAT fs) [i := (RAT fs) ! i + - ?R c \\<cdot>\\<^sub>v (RAT fs) ! j])\" (is \"gs.lin_indpt_list ?F1\")"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list\n   ((map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i +\n          - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j])\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list\n     ((map of_int_hom.vec_hom fs)\n      [i := map of_int_hom.vec_hom fs ! i +\n            - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j])", "."], ["proof (state)\nthis:\n  gs.lin_indpt_list\n   ((map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i +\n          - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j])\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  gs.lin_indpt_list\n   ((map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i +\n          - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j])\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"?F1 = RAT fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i +\n          - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] =\n    map of_int_hom.vec_hom fs'", "unfolding fs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i +\n          - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] =\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j])", "using i len Fij' **"], ["proof (prove)\nusing this:\n  i < m\n  length fs = m\n  map of_int_hom.vec_hom fs ! i \\<in> Rn\n  map of_int_hom.vec_hom fs ! j \\<in> Rn\n  of_int_hom.vec_hom (fs ! i) +\n  - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j =\n  of_int_hom.vec_hom (fs ! i - c \\<cdot>\\<^sub>v fs ! j)\n\ngoal (1 subgoal):\n 1. (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i +\n          - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] =\n    map of_int_hom.vec_hom (fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j])", "by (auto simp: map_update)"], ["proof (state)\nthis:\n  (map of_int_hom.vec_hom fs)\n  [i := map of_int_hom.vec_hom fs ! i +\n        - rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] =\n  map of_int_hom.vec_hom fs'\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "finally"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')", "have indep_F1: \"lin_indep fs'\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs')", "."], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have conn1: \"set (RAT fs) \\<subseteq> carrier_vec n\"  \"length (RAT fs) = m\" \"distinct (RAT fs)\"\n    \"gs.lin_indpt (set (RAT fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs) \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs) = m) &&&\n    distinct (map of_int_hom.vec_hom fs) &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs))", "using inv"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs) \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs) = m) &&&\n    distinct (map of_int_hom.vec_hom fs) &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs))", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs) \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs) = m) &&&\n    distinct (map of_int_hom.vec_hom fs) &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs))", "by auto"], ["proof (state)\nthis:\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs) = m\n  distinct (map of_int_hom.vec_hom fs)\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have conn2: \"set (RAT fs') \\<subseteq> carrier_vec n\"  \"length (RAT fs') = m\" \"distinct (RAT fs')\"\n    \"gs.lin_indpt (set (RAT fs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs') \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs') = m) &&&\n    distinct (map of_int_hom.vec_hom fs') &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs'))", "using indep_F1 F1'"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs') \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs') = m) &&&\n    distinct (map of_int_hom.vec_hom fs') &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs'))", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs') \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n  length (map of_int_hom.vec_hom fs') = m\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs') \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs') = m) &&&\n    distinct (map of_int_hom.vec_hom fs') &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs'))", "by auto"], ["proof (state)\nthis:\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c =\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c =\n    round\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n       j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i =\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j' -\n                               rat_of_int c *\n                               gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) j j'\n                          else gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "interpret gs1: gram_schmidt_fs_lin_indpt n \"RAT fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_lin_indpt n (map of_int_hom.vec_hom fs)", "by (standard) (use inv gs.lin_indpt_list_def in auto)"], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i.\n       i < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "interpret gs2: gram_schmidt_fs_lin_indpt n \"RAT fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_lin_indpt n (map of_int_hom.vec_hom fs')", "by (standard) (use indep_F1 F1' gs.lin_indpt_list_def in auto)"], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?G = \"map ?g [0 ..< m]\""], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?G' = \"map ?g' [0 ..< m]\""], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from gs1.span_gso gs2.span_gso gs1.gso_carrier gs2.gso_carrier conn1 conn2 span_F_F1 len"], ["proof (chain)\npicking this:\n  gs.span (gs1.gso ` {0..<length (map of_int_hom.vec_hom fs)}) =\n  gs.span (set (map of_int_hom.vec_hom fs))\n  gs.span (gs2.gso ` {0..<length (map of_int_hom.vec_hom fs')}) =\n  gs.span (set (map of_int_hom.vec_hom fs'))\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs1.gso ?i \\<in> Rn\n  ?i < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  gs2.gso ?i \\<in> Rn\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs) = m\n  distinct (map of_int_hom.vec_hom fs)\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n  gs.span (set (map of_int_hom.vec_hom fs)) =\n  gs.span (set (map of_int_hom.vec_hom fs'))\n  length fs = m", "have span_G_G1: \"gs.span (set ?G) = gs.span (set ?G')\"\n   and lenG: \"length ?G = m\" \n   and Gi: \"i < length ?G \\<Longrightarrow> ?G ! i \\<in> Rn\"\n   and G1i: \"i < length ?G' \\<Longrightarrow> ?G' ! i \\<in> Rn\" for i"], ["proof (prove)\nusing this:\n  gs.span (gs1.gso ` {0..<length (map of_int_hom.vec_hom fs)}) =\n  gs.span (set (map of_int_hom.vec_hom fs))\n  gs.span (gs2.gso ` {0..<length (map of_int_hom.vec_hom fs')}) =\n  gs.span (set (map of_int_hom.vec_hom fs'))\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs1.gso ?i \\<in> Rn\n  ?i < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  gs2.gso ?i \\<in> Rn\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs) = m\n  distinct (map of_int_hom.vec_hom fs)\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n  gs.span (set (map of_int_hom.vec_hom fs)) =\n  gs.span (set (map of_int_hom.vec_hom fs'))\n  length fs = m\n\ngoal (1 subgoal):\n 1. (gs.span (set (map gs1.gso [0..<m])) =\n     gs.span (set (map gs2.gso [0..<m])) &&&\n     length (map gs1.gso [0..<m]) = m) &&&\n    (i < length (map gs1.gso [0..<m]) \\<Longrightarrow>\n     map gs1.gso [0..<m] ! i \\<in> Rn) &&&\n    (i < length (map gs2.gso [0..<m]) \\<Longrightarrow>\n     map gs2.gso [0..<m] ! i \\<in> Rn)", "by auto"], ["proof (state)\nthis:\n  gs.span (set (map gs1.gso [0..<m])) = gs.span (set (map gs2.gso [0..<m]))\n  length (map gs1.gso [0..<m]) = m\n  ?i1 < length (map gs1.gso [0..<m]) \\<Longrightarrow>\n  map gs1.gso [0..<m] ! ?i1 \\<in> Rn\n  ?i1 < length (map gs2.gso [0..<m]) \\<Longrightarrow>\n  map gs2.gso [0..<m] ! ?i1 \\<in> Rn\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have eq: \"x \\<noteq> i \\<Longrightarrow> RAT fs' ! x = (RAT fs) ! x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> i \\<Longrightarrow>\n    map of_int_hom.vec_hom fs' ! x = map of_int_hom.vec_hom fs ! x", "unfolding RAT_F1"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> i \\<Longrightarrow>\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! i -\n          rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j] !\n    x =\n    map of_int_hom.vec_hom fs ! x", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<noteq> i \\<Longrightarrow>\n  map of_int_hom.vec_hom fs' ! ?x1 = map of_int_hom.vec_hom fs ! ?x1\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "hence eq_part: \"x < i \\<Longrightarrow> ?g' x = ?g x\" for x"], ["proof (prove)\nusing this:\n  ?x1 \\<noteq> i \\<Longrightarrow>\n  map of_int_hom.vec_hom fs' ! ?x1 = map of_int_hom.vec_hom fs ! ?x1\n\ngoal (1 subgoal):\n 1. x < i \\<Longrightarrow> gs2.gso x = gs1.gso x", "by (intro gs.gso_cong, insert len, auto)"], ["proof (state)\nthis:\n  ?x1 < i \\<Longrightarrow> gs2.gso ?x1 = gs1.gso ?x1\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have G: \"i < m \\<Longrightarrow> (RAT fs) ! i \\<in> Rn\"\n       \"i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i < m \\<Longrightarrow> map of_int_hom.vec_hom fs ! i \\<in> Rn) &&&\n    (i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n)", "by(insert add len', auto)"], ["proof (state)\nthis:\n  ?i1 < m \\<Longrightarrow> map of_int_hom.vec_hom fs ! ?i1 \\<in> Rn\n  ?i1 < m \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "note carr1[intro] = this[OF i] this[OF ji(2)]"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i \\<in> Rn\n  fs ! i \\<in> carrier_vec n\n  map of_int_hom.vec_hom fs ! j \\<in> Rn\n  fs ! j \\<in> carrier_vec n\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"x < m \\<Longrightarrow> ?g x \\<in> Rn\" \n       \"x < m \\<Longrightarrow> ?g' x \\<in> Rn\"\n       \"x < m \\<Longrightarrow> dim_vec (gso fs x) = n\"\n       \"x < m \\<Longrightarrow> dim_vec (gso fs' x) = n\"\n       for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x < m \\<Longrightarrow> gs1.gso x \\<in> Rn) &&&\n     (x < m \\<Longrightarrow> gs2.gso x \\<in> Rn)) &&&\n    (x < m \\<Longrightarrow> dim_vec (gs1.gso x) = n) &&&\n    (x < m \\<Longrightarrow> dim_vec (gs2.gso x) = n)", "using inv G1i"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  ?i1 < length (map gs2.gso [0..<m]) \\<Longrightarrow>\n  map gs2.gso [0..<m] ! ?i1 \\<in> Rn\n\ngoal (1 subgoal):\n 1. ((x < m \\<Longrightarrow> gs1.gso x \\<in> Rn) &&&\n     (x < m \\<Longrightarrow> gs2.gso x \\<in> Rn)) &&&\n    (x < m \\<Longrightarrow> dim_vec (gs1.gso x) = n) &&&\n    (x < m \\<Longrightarrow> dim_vec (gs2.gso x) = n)", "by (auto simp:o_def Gi G1i)"], ["proof (state)\nthis:\n  ?x1 < m \\<Longrightarrow> gs1.gso ?x1 \\<in> Rn\n  ?x1 < m \\<Longrightarrow> gs2.gso ?x1 \\<in> Rn\n  ?x1 < m \\<Longrightarrow> dim_vec (gs1.gso ?x1) = n\n  ?x1 < m \\<Longrightarrow> dim_vec (gs2.gso ?x1) = n\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "hence carr2[intro!]:\"?g i \\<in> Rn\" \"?g' i \\<in> Rn\"\n                 \"?g ` {0..<i} \\<subseteq> Rn\"\n                 \"?g ` {0..<Suc i} \\<subseteq> Rn\""], ["proof (prove)\nusing this:\n  ?x1 < m \\<Longrightarrow> gs1.gso ?x1 \\<in> Rn\n  ?x1 < m \\<Longrightarrow> gs2.gso ?x1 \\<in> Rn\n  ?x1 < m \\<Longrightarrow> dim_vec (gs1.gso ?x1) = n\n  ?x1 < m \\<Longrightarrow> dim_vec (gs2.gso ?x1) = n\n\ngoal (1 subgoal):\n 1. (gs1.gso i \\<in> Rn &&& gs2.gso i \\<in> Rn) &&&\n    gs1.gso ` {0..<i} \\<subseteq> Rn &&&\n    gs1.gso ` {0..<Suc i} \\<subseteq> Rn", "using i"], ["proof (prove)\nusing this:\n  ?x1 < m \\<Longrightarrow> gs1.gso ?x1 \\<in> Rn\n  ?x1 < m \\<Longrightarrow> gs2.gso ?x1 \\<in> Rn\n  ?x1 < m \\<Longrightarrow> dim_vec (gs1.gso ?x1) = n\n  ?x1 < m \\<Longrightarrow> dim_vec (gs2.gso ?x1) = n\n  i < m\n\ngoal (1 subgoal):\n 1. (gs1.gso i \\<in> Rn &&& gs2.gso i \\<in> Rn) &&&\n    gs1.gso ` {0..<i} \\<subseteq> Rn &&&\n    gs1.gso ` {0..<Suc i} \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  gs1.gso i \\<in> Rn\n  gs2.gso i \\<in> Rn\n  gs1.gso ` {0..<i} \\<subseteq> Rn\n  gs1.gso ` {0..<Suc i} \\<subseteq> Rn\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have F1_RV: \"?RV (fs' ! i) = RAT fs' ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs' ! i) = map of_int_hom.vec_hom fs' ! i", "using i F1"], ["proof (prove)\nusing this:\n  i < m\n  set fs' \\<subseteq> carrier_vec n\n  length fs' = m\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs' ! i) = map of_int_hom.vec_hom fs' ! i", "by auto"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs' ! i) = map of_int_hom.vec_hom fs' ! i\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have F_RV: \"?RV (fs ! i) = (RAT fs) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! i) = map of_int_hom.vec_hom fs ! i", "using i len"], ["proof (prove)\nusing this:\n  i < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! i) = map of_int_hom.vec_hom fs ! i", "by auto"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs ! i) = map of_int_hom.vec_hom fs ! i\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from eq_part"], ["proof (chain)\npicking this:\n  ?x1 < i \\<Longrightarrow> gs2.gso ?x1 = gs1.gso ?x1", "have span_G1_G: \"gs.span (?g' ` {0..<i}) = gs.span (?g ` {0..<i})\" (is \"?ls = ?rs\")"], ["proof (prove)\nusing this:\n  ?x1 < i \\<Longrightarrow> gs2.gso ?x1 = gs1.gso ?x1\n\ngoal (1 subgoal):\n 1. gs.span (gs2.gso ` {0..<i}) = gs.span (gs1.gso ` {0..<i})", "apply(intro cong[OF refl[of \"gs.span\"]],rule image_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x. x < i \\<Longrightarrow> gs2.gso x = gs1.gso x;\n        x \\<in> {0..<i}\\<rbrakk>\n       \\<Longrightarrow> x < i", "using eq"], ["proof (prove)\nusing this:\n  ?x1 \\<noteq> i \\<Longrightarrow>\n  map of_int_hom.vec_hom fs' ! ?x1 = map of_int_hom.vec_hom fs ! ?x1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x. x < i \\<Longrightarrow> gs2.gso x = gs1.gso x;\n        x \\<in> {0..<i}\\<rbrakk>\n       \\<Longrightarrow> x < i", "by auto"], ["proof (state)\nthis:\n  gs.span (gs2.gso ` {0..<i}) = gs.span (gs1.gso ` {0..<i})\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"(RAT fs') ! i - ?g' i = ((RAT fs) ! i - ?g' i) - ?mui\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i - gs2.gso i =\n    map of_int_hom.vec_hom fs ! i - gs2.gso i -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j", "unfolding RAT_F1_i"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j -\n    gs2.gso i =\n    map of_int_hom.vec_hom fs ! i - gs2.gso i -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j", "using carr1 carr2"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs ! i \\<in> Rn\n  fs ! i \\<in> carrier_vec n\n  map of_int_hom.vec_hom fs ! j \\<in> Rn\n  fs ! j \\<in> carrier_vec n\n  gs1.gso i \\<in> Rn\n  gs2.gso i \\<in> Rn\n  gs1.gso ` {0..<i} \\<subseteq> Rn\n  gs1.gso ` {0..<Suc i} \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j -\n    gs2.gso i =\n    map of_int_hom.vec_hom fs ! i - gs2.gso i -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j", "by (intro eq_vecI, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i - gs2.gso i =\n  map of_int_hom.vec_hom fs ! i - gs2.gso i -\n  rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "hence in1:\"((RAT fs) ! i - ?g' i) - ?mui \\<in> ?rs\""], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' ! i - gs2.gso i =\n  map of_int_hom.vec_hom fs ! i - gs2.gso i -\n  rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i - gs2.gso i -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n    \\<in> gs.span (gs1.gso ` {0..<i})", "using gs2.oc_projection_exist[of i] conn2 i"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' ! i - gs2.gso i =\n  map of_int_hom.vec_hom fs ! i - gs2.gso i -\n  rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n  i < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  map of_int_hom.vec_hom fs' ! i - gs2.gso i\n  \\<in> gs.span (gs2.gso ` {0..<i})\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n  i < m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i - gs2.gso i -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n    \\<in> gs.span (gs1.gso ` {0..<i})", "unfolding span_G1_G"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs' ! i - gs2.gso i =\n  map of_int_hom.vec_hom fs ! i - gs2.gso i -\n  rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n  i < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  map of_int_hom.vec_hom fs' ! i - gs2.gso i\n  \\<in> gs.span (gs1.gso ` {0..<i})\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n  i < m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i - gs2.gso i -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n    \\<in> gs.span (gs1.gso ` {0..<i})", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i - gs2.gso i -\n  rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n  \\<in> gs.span (gs1.gso ` {0..<i})\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from \\<open>j < i\\<close>"], ["proof (chain)\npicking this:\n  j < i", "have Gj_mem: \"(RAT fs) ! j \\<in> (\\<lambda> x. ((RAT fs) ! x)) ` {0 ..< i}\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! j\n    \\<in> (!) (map of_int_hom.vec_hom fs) ` {0..<i}", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! j\n  \\<in> (!) (map of_int_hom.vec_hom fs) ` {0..<i}\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have id1: \"set (take i (RAT fs)) = (\\<lambda>x. ?RV (fs ! x)) ` {0..<i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take i (map of_int_hom.vec_hom fs)) =\n    (\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i}", "using \\<open>i < m\\<close> len"], ["proof (prove)\nusing this:\n  i < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. set (take i (map of_int_hom.vec_hom fs)) =\n    (\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i}", "by (subst nth_image[symmetric], force+)"], ["proof (state)\nthis:\n  set (take i (map of_int_hom.vec_hom fs)) =\n  (\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i}\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"(RAT fs) ! j \\<in> ?rs \\<longleftrightarrow> (RAT fs) ! j \\<in> gs.span ((\\<lambda>x. ?RV (fs ! x)) ` {0..<i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map of_int_hom.vec_hom fs ! j \\<in> gs.span (gs1.gso ` {0..<i})) =\n    (map of_int_hom.vec_hom fs ! j\n     \\<in> gs.span ((\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i}))", "using gs1.partial_span  \\<open>i < m\\<close> id1 inv"], ["proof (prove)\nusing this:\n  ?i \\<le> length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs.span (gs1.gso ` {0..<?i}) =\n  gs.span (set (take ?i (map of_int_hom.vec_hom fs)))\n  i < m\n  set (take i (map of_int_hom.vec_hom fs)) =\n  (\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i}\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. (map of_int_hom.vec_hom fs ! j \\<in> gs.span (gs1.gso ` {0..<i})) =\n    (map of_int_hom.vec_hom fs ! j\n     \\<in> gs.span ((\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i}))", "by auto"], ["proof (state)\nthis:\n  (map of_int_hom.vec_hom fs ! j \\<in> gs.span (gs1.gso ` {0..<i})) =\n  (map of_int_hom.vec_hom fs ! j\n   \\<in> gs.span ((\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i}))\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  (map of_int_hom.vec_hom fs ! j \\<in> gs.span (gs1.gso ` {0..<i})) =\n  (map of_int_hom.vec_hom fs ! j\n   \\<in> gs.span ((\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i}))\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"(\\<lambda>x. ?RV (fs ! x)) ` {0..<i} = (\\<lambda>x. ((RAT fs) ! x)) ` {0..<i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<i}", "using \\<open>i < m\\<close> len"], ["proof (prove)\nusing this:\n  i < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<i}", "by force"], ["proof (state)\nthis:\n  (\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i} =\n  (!) (map of_int_hom.vec_hom fs) ` {0..<i}\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. of_int_hom.vec_hom (fs ! x)) ` {0..<i} =\n  (!) (map of_int_hom.vec_hom fs) ` {0..<i}\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"(RAT fs) ! j \\<in> gs.span \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! j\n    \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i})", "by (rule gs.span_mem[OF _ Gj_mem], insert \\<open>i < m\\<close> G, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! j\n  \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i})\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "finally"], ["proof (chain)\npicking this:\n  map of_int_hom.vec_hom fs ! j \\<in> gs.span (gs1.gso ` {0..<i})", "have \"(RAT fs) ! j \\<in> ?rs\""], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs ! j \\<in> gs.span (gs1.gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! j \\<in> gs.span (gs1.gso ` {0..<i})", "."], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! j \\<in> gs.span (gs1.gso ` {0..<i})\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "hence in2:\"?mui \\<in> ?rs\""], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs ! j \\<in> gs.span (gs1.gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n    \\<in> gs.span (gs1.gso ` {0..<i})", "apply(intro gs.prod_in_span)"], ["proof (prove)\ngoal (3 subgoals):\n 1. map of_int_hom.vec_hom fs ! j\n    \\<in> gs.span (gs1.gso ` {0..<i}) \\<Longrightarrow>\n    map of_int_hom.vec_hom fs ! j \\<in> Rn\n 2. map of_int_hom.vec_hom fs ! j\n    \\<in> gs.span (gs1.gso ` {0..<i}) \\<Longrightarrow>\n    gs1.gso ` {0..<i} \\<subseteq> Rn\n 3. map of_int_hom.vec_hom fs ! j\n    \\<in> gs.span (gs1.gso ` {0..<i}) \\<Longrightarrow>\n    rat_of_int c = 0 \\<or>\n    map of_int_hom.vec_hom fs ! j \\<in> gs.span (gs1.gso ` {0..<i})", "by force+"], ["proof (state)\nthis:\n  rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j\n  \\<in> gs.span (gs1.gso ` {0..<i})\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have ineq:\"((RAT fs) ! i - ?g' i) + ?mui - ?mui = ((RAT fs) ! i - ?g' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i - gs2.gso i +\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j =\n    map of_int_hom.vec_hom fs ! i - gs2.gso i", "using carr1 carr2"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs ! i \\<in> Rn\n  fs ! i \\<in> carrier_vec n\n  map of_int_hom.vec_hom fs ! j \\<in> Rn\n  fs ! j \\<in> carrier_vec n\n  gs1.gso i \\<in> Rn\n  gs2.gso i \\<in> Rn\n  gs1.gso ` {0..<i} \\<subseteq> Rn\n  gs1.gso ` {0..<Suc i} \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i - gs2.gso i +\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j -\n    rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j =\n    map of_int_hom.vec_hom fs ! i - gs2.gso i", "by (intro eq_vecI, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i - gs2.gso i +\n  rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j -\n  rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j =\n  map of_int_hom.vec_hom fs ! i - gs2.gso i\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have cong': \"A = B \\<Longrightarrow> A \\<in> C \\<Longrightarrow> B \\<in> C\" for A B :: \"'a vec\" and C"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A = B; A \\<in> C\\<rbrakk> \\<Longrightarrow> B \\<in> C", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?A2 = ?B2; ?A2 \\<in> ?C2\\<rbrakk> \\<Longrightarrow> ?B2 \\<in> ?C2\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have *: \"?g ` {0..<i} \\<subseteq> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs1.gso ` {0..<i} \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  gs1.gso ` {0..<i} \\<subseteq> Rn\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have in_span: \"(RAT fs) ! i - ?g' i \\<in> ?rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i - gs2.gso i\n    \\<in> gs.span (gs1.gso ` {0..<i})", "by (rule cong'[OF eq_vecI gs.span_add1[OF * in1 in2,unfolded ineq]], insert carr1 carr2, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i - gs2.gso i\n  \\<in> gs.span (gs1.gso ` {0..<i})\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "{"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i - gs2.gso i\n  \\<in> gs.span (gs1.gso ` {0..<i})\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "fix x"], ["proof (state)\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "assume x:\"x < i\""], ["proof (state)\nthis:\n  x < i\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "hence \"x < m\" \"i \\<noteq> x\""], ["proof (prove)\nusing this:\n  x < i\n\ngoal (1 subgoal):\n 1. x < m &&& i \\<noteq> x", "using i"], ["proof (prove)\nusing this:\n  x < i\n  i < m\n\ngoal (1 subgoal):\n 1. x < m &&& i \\<noteq> x", "by auto"], ["proof (state)\nthis:\n  x < m\n  i \\<noteq> x\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from gs2.orthogonal this inv assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length (map of_int_hom.vec_hom fs');\n   ?j < length (map of_int_hom.vec_hom fs'); ?i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> gs2.gso ?i \\<bullet> gs2.gso ?j = 0\n  x < m\n  i \\<noteq> x\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  LLL_invariant_weak fs\n  i < m\n  j < i\n  fs' = fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]", "have \"?g' i \\<bullet> ?g' x = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length (map of_int_hom.vec_hom fs');\n   ?j < length (map of_int_hom.vec_hom fs'); ?i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> gs2.gso ?i \\<bullet> gs2.gso ?j = 0\n  x < m\n  i \\<noteq> x\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  LLL_invariant_weak fs\n  i < m\n  j < i\n  fs' = fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]\n\ngoal (1 subgoal):\n 1. gs2.gso i \\<bullet> gs2.gso x = 0", "by auto"], ["proof (state)\nthis:\n  gs2.gso i \\<bullet> gs2.gso x = 0\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "}"], ["proof (state)\nthis:\n  ?x4 < i \\<Longrightarrow> gs2.gso i \\<bullet> gs2.gso ?x4 = 0\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "hence G1_G: \"?g' i = ?g i\""], ["proof (prove)\nusing this:\n  ?x4 < i \\<Longrightarrow> gs2.gso i \\<bullet> gs2.gso ?x4 = 0\n\ngoal (1 subgoal):\n 1. gs2.gso i = gs1.gso i", "by (intro gs1.oc_projection_unique) (use inv i eq_part in_span in auto)"], ["proof (state)\nthis:\n  gs2.gso i = gs1.gso i\n\ngoal (8 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i. i < m \\<Longrightarrow> gs2.gso i = gs1.gso i\n 7. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 8. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "show eq_fs:\"x < m \\<Longrightarrow> ?g' x = ?g x\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < m \\<Longrightarrow> gs2.gso x = gs1.gso x", "proof(induct x rule:nat_less_induct[rule_format])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>ma.\n                   \\<lbrakk>ma < n; ma < m\\<rbrakk>\n                   \\<Longrightarrow> gs2.gso ma = gs1.gso ma;\n        n < m\\<rbrakk>\n       \\<Longrightarrow> gs2.gso n = gs1.gso n", "case (1 x)"], ["proof (state)\nthis:\n  \\<lbrakk>?m2 < x; ?m2 < m\\<rbrakk>\n  \\<Longrightarrow> gs2.gso ?m2 = gs1.gso ?m2\n  x < m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>ma.\n                   \\<lbrakk>ma < n; ma < m\\<rbrakk>\n                   \\<Longrightarrow> gs2.gso ma = gs1.gso ma;\n        n < m\\<rbrakk>\n       \\<Longrightarrow> gs2.gso n = gs1.gso n", "hence ind: \"m < x \\<Longrightarrow> ?g' m = ?g m\"\n       for m"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m2 < x; ?m2 < m\\<rbrakk>\n  \\<Longrightarrow> gs2.gso ?m2 = gs1.gso ?m2\n  x < m\n\ngoal (1 subgoal):\n 1. m < x \\<Longrightarrow> gs2.gso m = gs1.gso m", "by auto"], ["proof (state)\nthis:\n  ?m2 < x \\<Longrightarrow> gs2.gso ?m2 = gs1.gso ?m2\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>ma.\n                   \\<lbrakk>ma < n; ma < m\\<rbrakk>\n                   \\<Longrightarrow> gs2.gso ma = gs1.gso ma;\n        n < m\\<rbrakk>\n       \\<Longrightarrow> gs2.gso n = gs1.gso n", "{"], ["proof (state)\nthis:\n  ?m2 < x \\<Longrightarrow> gs2.gso ?m2 = gs1.gso ?m2\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>ma.\n                   \\<lbrakk>ma < n; ma < m\\<rbrakk>\n                   \\<Longrightarrow> gs2.gso ma = gs1.gso ma;\n        n < m\\<rbrakk>\n       \\<Longrightarrow> gs2.gso n = gs1.gso n", "assume \"x > i\""], ["proof (state)\nthis:\n  i < x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>ma.\n                   \\<lbrakk>ma < n; ma < m\\<rbrakk>\n                   \\<Longrightarrow> gs2.gso ma = gs1.gso ma;\n        n < m\\<rbrakk>\n       \\<Longrightarrow> gs2.gso n = gs1.gso n", "hence ?case"], ["proof (prove)\nusing this:\n  i < x\n\ngoal (1 subgoal):\n 1. gs2.gso x = gs1.gso x", "unfolding gs2.gso.simps[of x] gs1.gso.simps[of x]"], ["proof (prove)\nusing this:\n  i < x\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! x +\n    gs.M.sumlist\n     (map (\\<lambda>j. - gs2.\\<mu> x j \\<cdot>\\<^sub>v gs2.gso j) [0..<x]) =\n    map of_int_hom.vec_hom fs ! x +\n    gs.M.sumlist\n     (map (\\<lambda>j. - gs1.\\<mu> x j \\<cdot>\\<^sub>v gs1.gso j) [0..<x])", "unfolding gs1.\\<mu>.simps gs2.\\<mu>.simps"], ["proof (prove)\nusing this:\n  i < x\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! x +\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              - (if j < x\n                 then map of_int_hom.vec_hom fs' ! x \\<bullet> gs2.gso j /\n                      \\<parallel>gs2.gso j\\<parallel>\\<^sup>2\n                 else if x = j then 1 else 0) \\<cdot>\\<^sub>v\n              gs2.gso j)\n       [0..<x]) =\n    map of_int_hom.vec_hom fs ! x +\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              - (if j < x\n                 then map of_int_hom.vec_hom fs ! x \\<bullet> gs1.gso j /\n                      \\<parallel>gs1.gso j\\<parallel>\\<^sup>2\n                 else if x = j then 1 else 0) \\<cdot>\\<^sub>v\n              gs1.gso j)\n       [0..<x])", "using ind eq"], ["proof (prove)\nusing this:\n  i < x\n  ?m2 < x \\<Longrightarrow> gs2.gso ?m2 = gs1.gso ?m2\n  ?x1 \\<noteq> i \\<Longrightarrow>\n  map of_int_hom.vec_hom fs' ! ?x1 = map of_int_hom.vec_hom fs ! ?x1\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! x +\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              - (if j < x\n                 then map of_int_hom.vec_hom fs' ! x \\<bullet> gs2.gso j /\n                      \\<parallel>gs2.gso j\\<parallel>\\<^sup>2\n                 else if x = j then 1 else 0) \\<cdot>\\<^sub>v\n              gs2.gso j)\n       [0..<x]) =\n    map of_int_hom.vec_hom fs ! x +\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              - (if j < x\n                 then map of_int_hom.vec_hom fs ! x \\<bullet> gs1.gso j /\n                      \\<parallel>gs1.gso j\\<parallel>\\<^sup>2\n                 else if x = j then 1 else 0) \\<cdot>\\<^sub>v\n              gs1.gso j)\n       [0..<x])", "by (auto intro: cong[OF _ cong[OF refl[of \"gs.sumlist\"]]])"], ["proof (state)\nthis:\n  gs2.gso x = gs1.gso x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>ma.\n                   \\<lbrakk>ma < n; ma < m\\<rbrakk>\n                   \\<Longrightarrow> gs2.gso ma = gs1.gso ma;\n        n < m\\<rbrakk>\n       \\<Longrightarrow> gs2.gso n = gs1.gso n", "}"], ["proof (state)\nthis:\n  i < x \\<Longrightarrow> gs2.gso x = gs1.gso x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>ma.\n                   \\<lbrakk>ma < n; ma < m\\<rbrakk>\n                   \\<Longrightarrow> gs2.gso ma = gs1.gso ma;\n        n < m\\<rbrakk>\n       \\<Longrightarrow> gs2.gso n = gs1.gso n", "note eq_rest = this"], ["proof (state)\nthis:\n  i < x \\<Longrightarrow> gs2.gso x = gs1.gso x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>ma.\n                   \\<lbrakk>ma < n; ma < m\\<rbrakk>\n                   \\<Longrightarrow> gs2.gso ma = gs1.gso ma;\n        n < m\\<rbrakk>\n       \\<Longrightarrow> gs2.gso n = gs1.gso n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso x = gs1.gso x", "by (rule linorder_class.linorder_cases[of x i],insert G1_G eq_part eq_rest,auto)"], ["proof (state)\nthis:\n  gs2.gso x = gs1.gso x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x2 < m \\<Longrightarrow> gs2.gso ?x2 = gs1.gso ?x2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "hence Hs:\"?G' = ?G\""], ["proof (prove)\nusing this:\n  ?x2 < m \\<Longrightarrow> gs2.gso ?x2 = gs1.gso ?x2\n\ngoal (1 subgoal):\n 1. map gs2.gso [0..<m] = map gs1.gso [0..<m]", "by (auto simp:o_def)"], ["proof (state)\nthis:\n  map gs2.gso [0..<m] = map gs1.gso [0..<m]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have red: \"weakly_reduced fs i \\<Longrightarrow> weakly_reduced fs' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs1.weakly_reduced \\<alpha> i \\<Longrightarrow>\n    gs2.weakly_reduced \\<alpha> i", "using eq_fs \\<open>i < m\\<close>"], ["proof (prove)\nusing this:\n  ?x2 < m \\<Longrightarrow> gs2.gso ?x2 = gs1.gso ?x2\n  i < m\n\ngoal (1 subgoal):\n 1. gs1.weakly_reduced \\<alpha> i \\<Longrightarrow>\n    gs2.weakly_reduced \\<alpha> i", "unfolding gram_schmidt_fs.weakly_reduced_def"], ["proof (prove)\nusing this:\n  ?x2 < m \\<Longrightarrow> gs2.gso ?x2 = gs1.gso ?x2\n  i < m\n\ngoal (1 subgoal):\n 1. \\<forall>ia.\n       Suc ia < i \\<longrightarrow>\n       \\<parallel>gs1.gso ia\\<parallel>\\<^sup>2\n       \\<le> \\<alpha> *\n             \\<parallel>gs1.gso\n                         (Suc ia)\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    \\<forall>ia.\n       Suc ia < i \\<longrightarrow>\n       \\<parallel>gs2.gso ia\\<parallel>\\<^sup>2\n       \\<le> \\<alpha> * \\<parallel>gs2.gso (Suc ia)\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  gs1.weakly_reduced \\<alpha> i \\<Longrightarrow>\n  gs2.weakly_reduced \\<alpha> i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?Mi = \"M ! i ! j\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have Gjn: \"dim_vec (fs ! j) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (fs ! j) = n", "using Fij(2) carrier_vecD"], ["proof (prove)\nusing this:\n  fs ! j \\<in> carrier_vec n\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> dim_vec ?v = ?n\n\ngoal (1 subgoal):\n 1. dim_vec (fs ! j) = n", "by blast"], ["proof (state)\nthis:\n  dim_vec (fs ! j) = n\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "define E where \"E = addrow_mat m (- ?R c) i j\""], ["proof (state)\nthis:\n  E = addrow_mat m (- rat_of_int c) i j\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "define M' where \"M' = gs1.M m\""], ["proof (state)\nthis:\n  M' = gs1.M m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "define N' where \"N' = gs2.M m\""], ["proof (state)\nthis:\n  N' = gs2.M m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have E: \"E \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<in> carrier_mat m m", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat m (- rat_of_int c) i j \\<in> carrier_mat m m", "by simp"], ["proof (state)\nthis:\n  E \\<in> carrier_mat m m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have M: \"M' \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M' \\<in> carrier_mat m m", "unfolding gs1.M_def M'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat m m (\\<lambda>(x, y). gs1.\\<mu> x y) \\<in> carrier_mat m m", "by auto"], ["proof (state)\nthis:\n  M' \\<in> carrier_mat m m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have N: \"N' \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N' \\<in> carrier_mat m m", "unfolding gs2.M_def N'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat m m (\\<lambda>(x, y). gs2.\\<mu> x y) \\<in> carrier_mat m m", "by auto"], ["proof (state)\nthis:\n  N' \\<in> carrier_mat m m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?mat = \"mat_of_rows n\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "let ?GsM = \"?mat ?G\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have Gs: \"?GsM \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n (map gs1.gso [0..<m]) \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  mat_of_rows n (map gs1.gso [0..<m]) \\<in> carrier_mat m n\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "hence GsT: \"?GsM\\<^sup>T \\<in> carrier_mat n m\""], ["proof (prove)\nusing this:\n  mat_of_rows n (map gs1.gso [0..<m]) \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T \\<in> carrier_mat n m", "by auto"], ["proof (state)\nthis:\n  (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T \\<in> carrier_mat n m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have Gnn: \"?mat (RAT fs) \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n (map of_int_hom.vec_hom fs) \\<in> carrier_mat m n", "unfolding mat_of_rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length (map of_int_hom.vec_hom fs)) n\n     (\\<lambda>(i, y). map of_int_hom.vec_hom fs ! i $ y)\n    \\<in> carrier_mat m n", "using len"], ["proof (prove)\nusing this:\n  length fs = m\n\ngoal (1 subgoal):\n 1. mat (length (map of_int_hom.vec_hom fs)) n\n     (\\<lambda>(i, y). map of_int_hom.vec_hom fs ! i $ y)\n    \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  mat_of_rows n (map of_int_hom.vec_hom fs) \\<in> carrier_mat m n\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"?mat (RAT fs') = addrow (- ?R c) i j (?mat (RAT fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n (map of_int_hom.vec_hom fs') =\n    addrow (- rat_of_int c) i j (mat_of_rows n (map of_int_hom.vec_hom fs))", "unfolding RAT_F1"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n\n     ((map of_int_hom.vec_hom fs)\n      [i := map of_int_hom.vec_hom fs ! i -\n            rat_of_int c \\<cdot>\\<^sub>v map of_int_hom.vec_hom fs ! j]) =\n    addrow (- rat_of_int c) i j (mat_of_rows n (map of_int_hom.vec_hom fs))", "by (rule eq_matI, insert Gjn ji(2), auto simp: len mat_of_rows_def)"], ["proof (state)\nthis:\n  mat_of_rows n (map of_int_hom.vec_hom fs') =\n  addrow (- rat_of_int c) i j (mat_of_rows n (map of_int_hom.vec_hom fs))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  mat_of_rows n (map of_int_hom.vec_hom fs') =\n  addrow (- rat_of_int c) i j (mat_of_rows n (map of_int_hom.vec_hom fs))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"\\<dots> = E * ?mat (RAT fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow (- rat_of_int c) i j\n     (mat_of_rows n (map of_int_hom.vec_hom fs)) =\n    E * mat_of_rows n (map of_int_hom.vec_hom fs)", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow (- rat_of_int c) i j\n     (mat_of_rows n (map of_int_hom.vec_hom fs)) =\n    addrow_mat m (- rat_of_int c) i j *\n    mat_of_rows n (map of_int_hom.vec_hom fs)", "by (rule addrow_mat, insert j i, auto simp: mat_of_rows_def len)"], ["proof (state)\nthis:\n  addrow (- rat_of_int c) i j (mat_of_rows n (map of_int_hom.vec_hom fs)) =\n  E * mat_of_rows n (map of_int_hom.vec_hom fs)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "finally"], ["proof (chain)\npicking this:\n  mat_of_rows n (map of_int_hom.vec_hom fs') =\n  E * mat_of_rows n (map of_int_hom.vec_hom fs)", "have HEG: \"?mat (RAT fs') = E * ?mat (RAT fs)\""], ["proof (prove)\nusing this:\n  mat_of_rows n (map of_int_hom.vec_hom fs') =\n  E * mat_of_rows n (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. mat_of_rows n (map of_int_hom.vec_hom fs') =\n    E * mat_of_rows n (map of_int_hom.vec_hom fs)", "."], ["proof (state)\nthis:\n  mat_of_rows n (map of_int_hom.vec_hom fs') =\n  E * mat_of_rows n (map of_int_hom.vec_hom fs)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "(* lemma 16.12(i), part 1 *)"], ["proof (state)\nthis:\n  mat_of_rows n (map of_int_hom.vec_hom fs') =\n  E * mat_of_rows n (map of_int_hom.vec_hom fs)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"(E * M') * ?mat ?G = E * (M' * ?mat ?G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E * M' * mat_of_rows n (map gs1.gso [0..<m]) =\n    E * (M' * mat_of_rows n (map gs1.gso [0..<m]))", "by (rule assoc_mult_mat[OF E M Gs])"], ["proof (state)\nthis:\n  E * M' * mat_of_rows n (map gs1.gso [0..<m]) =\n  E * (M' * mat_of_rows n (map gs1.gso [0..<m]))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  E * M' * mat_of_rows n (map gs1.gso [0..<m]) =\n  E * (M' * mat_of_rows n (map gs1.gso [0..<m]))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"M' * ?GsM = ?mat (RAT fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M' * mat_of_rows n (map gs1.gso [0..<m]) =\n    mat_of_rows n (map of_int_hom.vec_hom fs)", "using gs1.matrix_equality conn1 M'_def"], ["proof (prove)\nusing this:\n  mat_of_rows n (map of_int_hom.vec_hom fs) =\n  gs1.M (length (map of_int_hom.vec_hom fs)) *\n  mat_of_rows n (map gs1.gso [0..<length (map of_int_hom.vec_hom fs)])\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs) = m\n  distinct (map of_int_hom.vec_hom fs)\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n  M' = gs1.M m\n\ngoal (1 subgoal):\n 1. M' * mat_of_rows n (map gs1.gso [0..<m]) =\n    mat_of_rows n (map of_int_hom.vec_hom fs)", "by simp"], ["proof (state)\nthis:\n  M' * mat_of_rows n (map gs1.gso [0..<m]) =\n  mat_of_rows n (map of_int_hom.vec_hom fs)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  M' * mat_of_rows n (map gs1.gso [0..<m]) =\n  mat_of_rows n (map of_int_hom.vec_hom fs)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"E * \\<dots> = ?mat (RAT fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E * mat_of_rows n (map of_int_hom.vec_hom fs) =\n    mat_of_rows n (map of_int_hom.vec_hom fs')", "unfolding HEG"], ["proof (prove)\ngoal (1 subgoal):\n 1. E * mat_of_rows n (map of_int_hom.vec_hom fs) =\n    E * mat_of_rows n (map of_int_hom.vec_hom fs)", ".."], ["proof (state)\nthis:\n  E * mat_of_rows n (map of_int_hom.vec_hom fs) =\n  mat_of_rows n (map of_int_hom.vec_hom fs')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  E * mat_of_rows n (map of_int_hom.vec_hom fs) =\n  mat_of_rows n (map of_int_hom.vec_hom fs')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"\\<dots> = N' * ?mat ?G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n (map of_int_hom.vec_hom fs') =\n    N' * mat_of_rows n (map gs2.gso [0..<m])", "using gs2.matrix_equality conn2"], ["proof (prove)\nusing this:\n  mat_of_rows n (map of_int_hom.vec_hom fs') =\n  gs2.M (length (map of_int_hom.vec_hom fs')) *\n  mat_of_rows n (map gs2.gso [0..<length (map of_int_hom.vec_hom fs')])\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n\ngoal (1 subgoal):\n 1. mat_of_rows n (map of_int_hom.vec_hom fs') =\n    N' * mat_of_rows n (map gs2.gso [0..<m])", "unfolding N'_def"], ["proof (prove)\nusing this:\n  mat_of_rows n (map of_int_hom.vec_hom fs') =\n  gs2.M (length (map of_int_hom.vec_hom fs')) *\n  mat_of_rows n (map gs2.gso [0..<length (map of_int_hom.vec_hom fs')])\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n\ngoal (1 subgoal):\n 1. mat_of_rows n (map of_int_hom.vec_hom fs') =\n    gs2.M m * mat_of_rows n (map gs2.gso [0..<m])", "by simp"], ["proof (state)\nthis:\n  mat_of_rows n (map of_int_hom.vec_hom fs') =\n  N' * mat_of_rows n (map gs2.gso [0..<m])\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  mat_of_rows n (map of_int_hom.vec_hom fs') =\n  N' * mat_of_rows n (map gs2.gso [0..<m])\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"?mat ?G' = ?GsM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n (map gs2.gso [0..<m]) =\n    mat_of_rows n (map gs1.gso [0..<m])", "unfolding Hs"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n (map gs1.gso [0..<m]) =\n    mat_of_rows n (map gs1.gso [0..<m])", ".."], ["proof (state)\nthis:\n  mat_of_rows n (map gs2.gso [0..<m]) = mat_of_rows n (map gs1.gso [0..<m])\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "finally"], ["proof (chain)\npicking this:\n  E * M' * mat_of_rows n (map gs1.gso [0..<m]) =\n  N' * mat_of_rows n (map gs1.gso [0..<m])", "have \"(E * M') * ?GsM = N' * ?GsM\""], ["proof (prove)\nusing this:\n  E * M' * mat_of_rows n (map gs1.gso [0..<m]) =\n  N' * mat_of_rows n (map gs1.gso [0..<m])\n\ngoal (1 subgoal):\n 1. E * M' * mat_of_rows n (map gs1.gso [0..<m]) =\n    N' * mat_of_rows n (map gs1.gso [0..<m])", "."], ["proof (state)\nthis:\n  E * M' * mat_of_rows n (map gs1.gso [0..<m]) =\n  N' * mat_of_rows n (map gs1.gso [0..<m])\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from arg_cong[OF this, of \"\\<lambda> x. x * ?GsM\\<^sup>T\"] E M N"], ["proof (chain)\npicking this:\n  E * M' * mat_of_rows n (map gs1.gso [0..<m]) *\n  (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T =\n  N' * mat_of_rows n (map gs1.gso [0..<m]) *\n  (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T\n  E \\<in> carrier_mat m m\n  M' \\<in> carrier_mat m m\n  N' \\<in> carrier_mat m m", "have EMN: \"(E * M') * (?GsM * ?GsM\\<^sup>T) = N' * (?GsM * ?GsM\\<^sup>T)\""], ["proof (prove)\nusing this:\n  E * M' * mat_of_rows n (map gs1.gso [0..<m]) *\n  (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T =\n  N' * mat_of_rows n (map gs1.gso [0..<m]) *\n  (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T\n  E \\<in> carrier_mat m m\n  M' \\<in> carrier_mat m m\n  N' \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. E * M' *\n    (mat_of_rows n (map gs1.gso [0..<m]) *\n     (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T) =\n    N' *\n    (mat_of_rows n (map gs1.gso [0..<m]) *\n     (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T)", "by (subst (1 2) assoc_mult_mat[OF _ Gs GsT, of _ m, symmetric], auto)"], ["proof (state)\nthis:\n  E * M' *\n  (mat_of_rows n (map gs1.gso [0..<m]) *\n   (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T) =\n  N' *\n  (mat_of_rows n (map gs1.gso [0..<m]) *\n   (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"det (?GsM * ?GsM\\<^sup>T) = gs.Gramian_determinant ?G m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n (map gs1.gso [0..<m]) *\n         (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T) =\n    gs.Gramian_determinant (map gs1.gso [0..<m]) m", "unfolding gs.Gramian_determinant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n (map gs1.gso [0..<m]) *\n         (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T) =\n    det (gs.Gramian_matrix (map gs1.gso [0..<m]) m)", "by (subst gs.Gramian_matrix_alt_def, auto simp: Let_def)"], ["proof (state)\nthis:\n  det (mat_of_rows n (map gs1.gso [0..<m]) *\n       (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T) =\n  gs.Gramian_determinant (map gs1.gso [0..<m]) m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  det (mat_of_rows n (map gs1.gso [0..<m]) *\n       (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T) =\n  gs.Gramian_determinant (map gs1.gso [0..<m]) m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"\\<dots> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < gs.Gramian_determinant (map gs1.gso [0..<m]) m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < gs.Gramian_determinant (map gs1.gso [0..<m]) m", "have 1: \"gs.lin_indpt_list ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map gs1.gso [0..<m])", "using conn1 gs1.orthogonal_gso gs1.gso_carrier"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs) = m\n  distinct (map of_int_hom.vec_hom fs)\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n  orthogonal (map gs1.gso [0..<length (map of_int_hom.vec_hom fs)])\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs1.gso ?i \\<in> Rn\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map gs1.gso [0..<m])", "by (intro gs.orthogonal_imp_lin_indpt_list) (auto)"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map gs1.gso [0..<m])\n\ngoal (1 subgoal):\n 1. 0 < gs.Gramian_determinant (map gs1.gso [0..<m]) m", "interpret G: gram_schmidt_fs_lin_indpt n ?G"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_lin_indpt n (map gs1.gso [0..<m])", "by  (standard) (use 1 gs.lin_indpt_list_def in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < G.d m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < G.d m", "by (intro G.Gramian_determinant) auto"], ["proof (state)\nthis:\n  0 < G.d m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < gs.Gramian_determinant (map gs1.gso [0..<m]) m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "finally"], ["proof (chain)\npicking this:\n  0 < det (mat_of_rows n (map gs1.gso [0..<m]) *\n           (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T)", "have \"det (?GsM * ?GsM\\<^sup>T) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < det (mat_of_rows n (map gs1.gso [0..<m]) *\n           (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n (map gs1.gso [0..<m]) *\n         (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T) \\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  det (mat_of_rows n (map gs1.gso [0..<m]) *\n       (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T) \\<noteq>\n  0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from vec_space.det_nonzero_congruence[OF EMN this _ _ N] Gs E M"], ["proof (chain)\npicking this:\n  \\<lbrakk>mat_of_rows n (map gs1.gso [0..<m]) *\n           (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T\n           \\<in> carrier_mat m m;\n   E * M' \\<in> carrier_mat m m\\<rbrakk>\n  \\<Longrightarrow> E * M' = N'\n  mat_of_rows n (map gs1.gso [0..<m]) \\<in> carrier_mat m n\n  E \\<in> carrier_mat m m\n  M' \\<in> carrier_mat m m", "have EMN: \"E * M' = N'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>mat_of_rows n (map gs1.gso [0..<m]) *\n           (mat_of_rows n (map gs1.gso [0..<m]))\\<^sup>T\n           \\<in> carrier_mat m m;\n   E * M' \\<in> carrier_mat m m\\<rbrakk>\n  \\<Longrightarrow> E * M' = N'\n  mat_of_rows n (map gs1.gso [0..<m]) \\<in> carrier_mat m n\n  E \\<in> carrier_mat m m\n  M' \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. E * M' = N'", "by auto"], ["proof (state)\nthis:\n  E * M' = N'\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "(* lemma 16.12(i), part 2 *)"], ["proof (state)\nthis:\n  E * M' = N'\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "{"], ["proof (state)\nthis:\n  E * M' = N'\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "fix i' j'"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "assume ij: \"i' < m\" \"j' < m\" and choice: \"i' \\<noteq> i \\<or> j < j'\""], ["proof (state)\nthis:\n  i' < m\n  j' < m\n  i' \\<noteq> i \\<or> j < j'\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"?mu' i' j' \n      = N' $$ (i',j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.\\<mu> i' j' = N' $$ (i', j')", "using ij F1"], ["proof (prove)\nusing this:\n  i' < m\n  j' < m\n  set fs' \\<subseteq> carrier_vec n\n  length fs' = m\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> i' j' = N' $$ (i', j')", "unfolding N'_def gs2.M_def"], ["proof (prove)\nusing this:\n  i' < m\n  j' < m\n  set fs' \\<subseteq> carrier_vec n\n  length fs' = m\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> i' j' = mat m m (\\<lambda>(x, y). gs2.\\<mu> x y) $$ (i', j')", "by auto"], ["proof (state)\nthis:\n  gs2.\\<mu> i' j' = N' $$ (i', j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  gs2.\\<mu> i' j' = N' $$ (i', j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"\\<dots> = addrow (- ?R c) i j M' $$ (i',j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N' $$ (i', j') = addrow (- rat_of_int c) i j M' $$ (i', j')", "unfolding EMN[symmetric] E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (addrow_mat m (- rat_of_int c) i j * M') $$ (i', j') =\n    addrow (- rat_of_int c) i j M' $$ (i', j')", "by (subst addrow_mat[OF M], insert ji, auto)"], ["proof (state)\nthis:\n  N' $$ (i', j') = addrow (- rat_of_int c) i j M' $$ (i', j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  N' $$ (i', j') = addrow (- rat_of_int c) i j M' $$ (i', j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"\\<dots> = (if i = i' then - ?R c * M' $$ (j, j') + M' $$ (i', j') else M' $$ (i', j'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow (- rat_of_int c) i j M' $$ (i', j') =\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j'))", "by (rule index_mat_addrow, insert ij M, auto)"], ["proof (state)\nthis:\n  addrow (- rat_of_int c) i j M' $$ (i', j') =\n  (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n   else M' $$ (i', j'))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  addrow (- rat_of_int c) i j M' $$ (i', j') =\n  (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n   else M' $$ (i', j'))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"\\<dots> = M' $$ (i', j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')", "proof (cases \"i = i'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')\n 2. i \\<noteq> i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')", "case True"], ["proof (state)\nthis:\n  i = i'\n\ngoal (2 subgoals):\n 1. i = i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')\n 2. i \\<noteq> i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')", "with choice"], ["proof (chain)\npicking this:\n  i' \\<noteq> i \\<or> j < j'\n  i = i'", "have jj: \"j < j'\""], ["proof (prove)\nusing this:\n  i' \\<noteq> i \\<or> j < j'\n  i = i'\n\ngoal (1 subgoal):\n 1. j < j'", "by auto"], ["proof (state)\nthis:\n  j < j'\n\ngoal (2 subgoals):\n 1. i = i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')\n 2. i \\<noteq> i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')", "have \"M' $$ (j, j') = ?mu j j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M' $$ (j, j') = gs1.\\<mu> j j'", "using ij ji len"], ["proof (prove)\nusing this:\n  i' < m\n  j' < m\n  j \\<le> i\n  j < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. M' $$ (j, j') = gs1.\\<mu> j j'", "unfolding M'_def gs1.M_def"], ["proof (prove)\nusing this:\n  i' < m\n  j' < m\n  j \\<le> i\n  j < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. mat m m (\\<lambda>(x, y). gs1.\\<mu> x y) $$ (j, j') = gs1.\\<mu> j j'", "by auto"], ["proof (state)\nthis:\n  M' $$ (j, j') = gs1.\\<mu> j j'\n\ngoal (2 subgoals):\n 1. i = i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')\n 2. i \\<noteq> i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')", "also"], ["proof (state)\nthis:\n  M' $$ (j, j') = gs1.\\<mu> j j'\n\ngoal (2 subgoals):\n 1. i = i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')\n 2. i \\<noteq> i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs1.\\<mu> j j' = 0", "unfolding gs1.\\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j' < j\n     then map of_int_hom.vec_hom fs ! j \\<bullet> gs1.gso j' /\n          \\<parallel>gs1.gso j'\\<parallel>\\<^sup>2\n     else if j = j' then 1 else 0) =\n    0", "using jj"], ["proof (prove)\nusing this:\n  j < j'\n\ngoal (1 subgoal):\n 1. (if j' < j\n     then map of_int_hom.vec_hom fs ! j \\<bullet> gs1.gso j' /\n          \\<parallel>gs1.gso j'\\<parallel>\\<^sup>2\n     else if j = j' then 1 else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  gs1.\\<mu> j j' = 0\n\ngoal (2 subgoals):\n 1. i = i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')\n 2. i \\<noteq> i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')", "finally"], ["proof (chain)\npicking this:\n  M' $$ (j, j') = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  M' $$ (j, j') = 0\n\ngoal (1 subgoal):\n 1. (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')", "using True"], ["proof (prove)\nusing this:\n  M' $$ (j, j') = 0\n  i = i'\n\ngoal (1 subgoal):\n 1. (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')", "by auto"], ["proof (state)\nthis:\n  (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n   else M' $$ (i', j')) =\n  M' $$ (i', j')\n\ngoal (1 subgoal):\n 1. i \\<noteq> i' \\<Longrightarrow>\n    (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n     else M' $$ (i', j')) =\n    M' $$ (i', j')", "qed auto"], ["proof (state)\nthis:\n  (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n   else M' $$ (i', j')) =\n  M' $$ (i', j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  (if i = i' then - rat_of_int c * M' $$ (j, j') + M' $$ (i', j')\n   else M' $$ (i', j')) =\n  M' $$ (i', j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"\\<dots> = ?mu i' j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M' $$ (i', j') = gs1.\\<mu> i' j'", "using ij len"], ["proof (prove)\nusing this:\n  i' < m\n  j' < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. M' $$ (i', j') = gs1.\\<mu> i' j'", "unfolding M'_def gs1.M_def"], ["proof (prove)\nusing this:\n  i' < m\n  j' < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. mat m m (\\<lambda>(x, y). gs1.\\<mu> x y) $$ (i', j') = gs1.\\<mu> i' j'", "by auto"], ["proof (state)\nthis:\n  M' $$ (i', j') = gs1.\\<mu> i' j'\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  M' $$ (i', j') = gs1.\\<mu> i' j'\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "note calculation"], ["proof (state)\nthis:\n  gs2.\\<mu> i' j' = gs1.\\<mu> i' j'\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i'5 < m; ?j'5 < m; ?i'5 \\<noteq> i \\<or> j < ?j'5\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?i'5 ?j'5 = gs1.\\<mu> ?i'5 ?j'5\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "note mu_no_change = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i'5 < m; ?j'5 < m; ?i'5 \\<noteq> i \\<or> j < ?j'5\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?i'5 ?j'5 = gs1.\\<mu> ?i'5 ?j'5\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i'5 < m; ?j'5 < m; ?i'5 \\<noteq> i \\<or> j < ?j'5\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?i'5 ?j'5 = gs1.\\<mu> ?i'5 ?j'5\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "fix j'"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "assume jj': \"j' \\<le> j\""], ["proof (state)\nthis:\n  j' \\<le> j\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "with j i"], ["proof (chain)\npicking this:\n  j < i\n  i < m\n  j' \\<le> j", "have j': \"j' < m\""], ["proof (prove)\nusing this:\n  j < i\n  i < m\n  j' \\<le> j\n\ngoal (1 subgoal):\n 1. j' < m", "by auto"], ["proof (state)\nthis:\n  j' < m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"?mu' i j' \n      = N' $$ (i,j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.\\<mu> i j' = N' $$ (i, j')", "using jj' j i F1"], ["proof (prove)\nusing this:\n  j' \\<le> j\n  j < i\n  i < m\n  set fs' \\<subseteq> carrier_vec n\n  length fs' = m\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> i j' = N' $$ (i, j')", "unfolding N'_def gs2.M_def"], ["proof (prove)\nusing this:\n  j' \\<le> j\n  j < i\n  i < m\n  set fs' \\<subseteq> carrier_vec n\n  length fs' = m\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> i j' = mat m m (\\<lambda>(x, y). gs2.\\<mu> x y) $$ (i, j')", "by auto"], ["proof (state)\nthis:\n  gs2.\\<mu> i j' = N' $$ (i, j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  gs2.\\<mu> i j' = N' $$ (i, j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"\\<dots> = addrow (- ?R c) i j M' $$ (i,j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N' $$ (i, j') = addrow (- rat_of_int c) i j M' $$ (i, j')", "unfolding EMN[symmetric] E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (addrow_mat m (- rat_of_int c) i j * M') $$ (i, j') =\n    addrow (- rat_of_int c) i j M' $$ (i, j')", "by (subst addrow_mat[OF M], insert ji, auto)"], ["proof (state)\nthis:\n  N' $$ (i, j') = addrow (- rat_of_int c) i j M' $$ (i, j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  N' $$ (i, j') = addrow (- rat_of_int c) i j M' $$ (i, j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"\\<dots> = - ?R c * M' $$ (j, j') + M' $$ (i, j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow (- rat_of_int c) i j M' $$ (i, j') =\n    - rat_of_int c * M' $$ (j, j') + M' $$ (i, j')", "by (rule index_mat_addrow, insert j' i M, auto)"], ["proof (state)\nthis:\n  addrow (- rat_of_int c) i j M' $$ (i, j') =\n  - rat_of_int c * M' $$ (j, j') + M' $$ (i, j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  addrow (- rat_of_int c) i j M' $$ (i, j') =\n  - rat_of_int c * M' $$ (j, j') + M' $$ (i, j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"\\<dots> = M' $$ (i, j') - ?R c * M' $$ (j, j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - rat_of_int c * M' $$ (j, j') + M' $$ (i, j') =\n    M' $$ (i, j') - rat_of_int c * M' $$ (j, j')", "by simp"], ["proof (state)\nthis:\n  - rat_of_int c * M' $$ (j, j') + M' $$ (i, j') =\n  M' $$ (i, j') - rat_of_int c * M' $$ (j, j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  - rat_of_int c * M' $$ (j, j') + M' $$ (i, j') =\n  M' $$ (i, j') - rat_of_int c * M' $$ (j, j')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"M' $$ (i, j') = ?mu i j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M' $$ (i, j') = gs1.\\<mu> i j'", "using i j' len"], ["proof (prove)\nusing this:\n  i < m\n  j' < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. M' $$ (i, j') = gs1.\\<mu> i j'", "unfolding M'_def gs1.M_def"], ["proof (prove)\nusing this:\n  i < m\n  j' < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. mat m m (\\<lambda>(x, y). gs1.\\<mu> x y) $$ (i, j') = gs1.\\<mu> i j'", "by auto"], ["proof (state)\nthis:\n  M' $$ (i, j') = gs1.\\<mu> i j'\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "also"], ["proof (state)\nthis:\n  M' $$ (i, j') = gs1.\\<mu> i j'\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"M' $$ (j, j') = ?mu j j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M' $$ (j, j') = gs1.\\<mu> j j'", "using i j j' len"], ["proof (prove)\nusing this:\n  i < m\n  j < i\n  j' < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. M' $$ (j, j') = gs1.\\<mu> j j'", "unfolding M'_def gs1.M_def"], ["proof (prove)\nusing this:\n  i < m\n  j < i\n  j' < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. mat m m (\\<lambda>(x, y). gs1.\\<mu> x y) $$ (j, j') = gs1.\\<mu> j j'", "by auto"], ["proof (state)\nthis:\n  M' $$ (j, j') = gs1.\\<mu> j j'\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "finally"], ["proof (chain)\npicking this:\n  gs2.\\<mu> i j' = gs1.\\<mu> i j' - rat_of_int c * gs1.\\<mu> j j'", "have \"?mu' i j' = ?mu i j' - ?R c * ?mu j j'\""], ["proof (prove)\nusing this:\n  gs2.\\<mu> i j' = gs1.\\<mu> i j' - rat_of_int c * gs1.\\<mu> j j'\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> i j' = gs1.\\<mu> i j' - rat_of_int c * gs1.\\<mu> j j'", "by auto"], ["proof (state)\nthis:\n  gs2.\\<mu> i j' = gs1.\\<mu> i j' - rat_of_int c * gs1.\\<mu> j j'\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "}"], ["proof (state)\nthis:\n  ?j'5 \\<le> j \\<Longrightarrow>\n  gs2.\\<mu> i ?j'5 = gs1.\\<mu> i ?j'5 - rat_of_int c * gs1.\\<mu> j ?j'5\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "note mu_change = this"], ["proof (state)\nthis:\n  ?j'5 \\<le> j \\<Longrightarrow>\n  gs2.\\<mu> i ?j'5 = gs1.\\<mu> i ?j'5 - rat_of_int c * gs1.\\<mu> j ?j'5\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < m\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> i' j' =\n                         (if i' = i \\<and> j' \\<le> j\n                          then gs1.\\<mu> i j' -\n                               rat_of_int c * gs1.\\<mu> j j'\n                          else gs1.\\<mu> i' j')\n 7. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "show mu_update: \"i' < m \\<Longrightarrow> j' < m \\<Longrightarrow> \n    ?mu' i' j' = (if i' = i \\<and> j' \\<le> j then ?mu i j' - ?R c * ?mu j j' else ?mu i' j')\" \n    for i' j'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gs2.\\<mu> i' j' =\n                      (if i' = i \\<and> j' \\<le> j\n                       then gs1.\\<mu> i j' - rat_of_int c * gs1.\\<mu> j j'\n                       else gs1.\\<mu> i' j')", "using mu_change[of j'] mu_no_change[of i' j']"], ["proof (prove)\nusing this:\n  j' \\<le> j \\<Longrightarrow>\n  gs2.\\<mu> i j' = gs1.\\<mu> i j' - rat_of_int c * gs1.\\<mu> j j'\n  \\<lbrakk>i' < m; j' < m; i' \\<noteq> i \\<or> j < j'\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> i' j' = gs1.\\<mu> i' j'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i' < m; j' < m\\<rbrakk>\n    \\<Longrightarrow> gs2.\\<mu> i' j' =\n                      (if i' = i \\<and> j' \\<le> j\n                       then gs1.\\<mu> i j' - rat_of_int c * gs1.\\<mu> j j'\n                       else gs1.\\<mu> i' j')", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i'3 < m; ?j'3 < m\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?i'3 ?j'3 =\n                    (if ?i'3 = i \\<and> ?j'3 \\<le> j\n                     then gs1.\\<mu> i ?j'3 - rat_of_int c * gs1.\\<mu> j ?j'3\n                     else gs1.\\<mu> ?i'3 ?j'3)\n\ngoal (6 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i'3 < m; ?j'3 < m\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?i'3 ?j'3 =\n                    (if ?i'3 = i \\<and> ?j'3 \\<le> j\n                     then gs1.\\<mu> i ?j'3 - rat_of_int c * gs1.\\<mu> j ?j'3\n                     else gs1.\\<mu> ?i'3 ?j'3)\n\ngoal (6 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "assume \"LLL_invariant True i fs\""], ["proof (state)\nthis:\n  LLL_invariant True i fs\n\ngoal (6 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from LLL_invD[OF this]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gs1.weakly_reduced \\<alpha> i\n  i \\<le> m\n  gs1.reduced \\<alpha> i\n  True \\<or> \\<mu>_small fs i", "have \"weakly_reduced fs i\" and sred: \"reduced fs i\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gs1.weakly_reduced \\<alpha> i\n  i \\<le> m\n  gs1.reduced \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. gs1.weakly_reduced \\<alpha> i &&& gs1.reduced \\<alpha> i", "by auto"], ["proof (state)\nthis:\n  gs1.weakly_reduced \\<alpha> i\n  gs1.reduced \\<alpha> i\n\ngoal (6 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from red[OF this(1)]"], ["proof (chain)\npicking this:\n  gs2.weakly_reduced \\<alpha> i", "have red: \"weakly_reduced fs' i\""], ["proof (prove)\nusing this:\n  gs2.weakly_reduced \\<alpha> i\n\ngoal (1 subgoal):\n 1. gs2.weakly_reduced \\<alpha> i", "."], ["proof (state)\nthis:\n  gs2.weakly_reduced \\<alpha> i\n\ngoal (6 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have sred: \"reduced fs' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.reduced \\<alpha> i", "unfolding gram_schmidt_fs.reduced_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.weakly_reduced \\<alpha> i \\<and>\n    (\\<forall>ia j.\n        ia < i \\<longrightarrow>\n        j < ia \\<longrightarrow> \\<bar>gs2.\\<mu> ia j\\<bar> \\<le> 1 / 2)", "proof (intro conjI[OF red] impI allI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < i; j < ia\\<rbrakk>\n       \\<Longrightarrow> \\<bar>gs2.\\<mu> ia j\\<bar> \\<le> 1 / 2", "case (1 i' j)"], ["proof (state)\nthis:\n  i' < i\n  j < i'\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < i; j < ia\\<rbrakk>\n       \\<Longrightarrow> \\<bar>gs2.\\<mu> ia j\\<bar> \\<le> 1 / 2", "with mu_no_change[of i' j] sred[unfolded gram_schmidt_fs.reduced_def, THEN conjunct2, rule_format, of i' j] i"], ["proof (chain)\npicking this:\n  \\<lbrakk>i' < m; j < m; i' \\<noteq> i \\<or> j < j\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> i' j = gs1.\\<mu> i' j\n  \\<lbrakk>i' < i; j < i'\\<rbrakk>\n  \\<Longrightarrow> \\<bar>gs1.\\<mu> i' j\\<bar> \\<le> 1 / 2\n  i < m\n  i' < i\n  j < i'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>i' < m; j < m; i' \\<noteq> i \\<or> j < j\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> i' j = gs1.\\<mu> i' j\n  \\<lbrakk>i' < i; j < i'\\<rbrakk>\n  \\<Longrightarrow> \\<bar>gs1.\\<mu> i' j\\<bar> \\<le> 1 / 2\n  i < m\n  i' < i\n  j < i'\n\ngoal (1 subgoal):\n 1. \\<bar>gs2.\\<mu> i' j\\<bar> \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>gs2.\\<mu> i' j\\<bar> \\<le> 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs2.reduced \\<alpha> i\n\ngoal (6 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n 3. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 4. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 5. LLL_measure i fs' = LLL_measure i fs\n 6. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "show \"LLL_invariant True i fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True i fs'", "by (intro LLL_invI[OF F1 lattice \\<open>i \\<le> m\\<close> indep_F1 sred], auto)"], ["proof (state)\nthis:\n  LLL_invariant True i fs'\n\ngoal (5 subgoals):\n 1. LLL_invariant_weak fs'\n 2. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 3. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 4. LLL_measure i fs' = LLL_measure i fs\n 5. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "}"], ["proof (state)\nthis:\n  LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n\ngoal (5 subgoals):\n 1. LLL_invariant_weak fs'\n 2. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 3. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 4. LLL_measure i fs' = LLL_measure i fs\n 5. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "show Linv': \"LLL_invariant_weak fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant_weak fs'", "by (intro LLL_inv_wI[OF F1 lattice indep_F1])"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n\ngoal (4 subgoals):\n 1. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 2. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 3. LLL_measure i fs' = LLL_measure i fs\n 4. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have mudiff:\"?mu i j - of_int c = ?mu' i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs1.\\<mu> i j - rat_of_int c = gs2.\\<mu> i j", "by (subst mu_change, auto simp: gs1.\\<mu>.simps)"], ["proof (state)\nthis:\n  gs1.\\<mu> i j - rat_of_int c = gs2.\\<mu> i j\n\ngoal (4 subgoals):\n 1. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 2. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 3. LLL_measure i fs' = LLL_measure i fs\n 4. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have lin_indpt_list_fs: \"gs.lin_indpt_list (RAT fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs')", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map of_int_hom.vec_hom fs') \\<subseteq> Rn \\<and>\n    distinct (map of_int_hom.vec_hom fs') \\<and>\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs'))", "using conn2"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n\ngoal (1 subgoal):\n 1. set (map of_int_hom.vec_hom fs') \\<subseteq> Rn \\<and>\n    distinct (map of_int_hom.vec_hom fs') \\<and>\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs'))", "by auto"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n\ngoal (4 subgoals):\n 1. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 2. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 3. LLL_measure i fs' = LLL_measure i fs\n 4. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "{"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n\ngoal (4 subgoals):\n 1. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 2. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 3. LLL_measure i fs' = LLL_measure i fs\n 4. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "assume c: \"c = round (\\<mu> fs i j)\""], ["proof (state)\nthis:\n  c = round (gs1.\\<mu> i j)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 2. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 3. LLL_measure i fs' = LLL_measure i fs\n 4. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have small: \"abs (?mu i j - of_int c) \\<le> inverse 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gs1.\\<mu> i j - rat_of_int c\\<bar> \\<le> inverse 2", "unfolding j c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gs1.\\<mu> i j - rat_of_int (round (gs1.\\<mu> i j))\\<bar>\n    \\<le> inverse 2", "using of_int_round_abs_le"], ["proof (prove)\nusing this:\n  \\<bar>of_int (round ?x) - ?x\\<bar> \\<le> (1::?'a) / (2::?'a)\n\ngoal (1 subgoal):\n 1. \\<bar>gs1.\\<mu> i j - rat_of_int (round (gs1.\\<mu> i j))\\<bar>\n    \\<le> inverse 2", "by (auto simp add: abs_minus_commute)"], ["proof (state)\nthis:\n  \\<bar>gs1.\\<mu> i j - rat_of_int c\\<bar> \\<le> inverse 2\n\ngoal (4 subgoals):\n 1. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 2. c = round (gs1.\\<mu> i j) \\<Longrightarrow>\n    \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n 3. LLL_measure i fs' = LLL_measure i fs\n 4. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "from this[unfolded mudiff]"], ["proof (chain)\npicking this:\n  \\<bar>gs2.\\<mu> i j\\<bar> \\<le> inverse 2", "show mu'_2: \"abs (?mu' i j) \\<le> 1 / 2\""], ["proof (prove)\nusing this:\n  \\<bar>gs2.\\<mu> i j\\<bar> \\<le> inverse 2\n\ngoal (1 subgoal):\n 1. \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2", "by simp"], ["proof (state)\nthis:\n  \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n\ngoal (3 subgoals):\n 1. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 2. LLL_measure i fs' = LLL_measure i fs\n 3. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "assume mu_small: \"\\<mu>_small_row i fs (Suc j)\""], ["proof (state)\nthis:\n  \\<mu>_small_row i fs (Suc j)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>c = round (gs1.\\<mu> i j);\n     \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n    \\<Longrightarrow> \\<mu>_small_row i fs' j\n 2. LLL_measure i fs' = LLL_measure i fs\n 3. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "show \"\\<mu>_small_row i fs' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>_small_row i fs' j", "unfolding \\<mu>_small_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j'\\<ge>j.\n       j' < i \\<longrightarrow> \\<bar>gs2.\\<mu> i j'\\<bar> \\<le> inverse 2", "proof (intro allI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j'.\n       j \\<le> j' \\<longrightarrow>\n       j' < i \\<longrightarrow> \\<bar>gs2.\\<mu> i j'\\<bar> \\<le> inverse 2", "case (1 j')"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>j'.\n       j \\<le> j' \\<longrightarrow>\n       j' < i \\<longrightarrow> \\<bar>gs2.\\<mu> i j'\\<bar> \\<le> inverse 2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> j' \\<longrightarrow>\n    j' < i \\<longrightarrow> \\<bar>gs2.\\<mu> i j'\\<bar> \\<le> inverse 2", "using mu'_2 mu_small[unfolded \\<mu>_small_row_def, rule_format, of j']"], ["proof (prove)\nusing this:\n  \\<bar>gs2.\\<mu> i j\\<bar> \\<le> 1 / 2\n  \\<lbrakk>Suc j \\<le> j'; j' < i\\<rbrakk>\n  \\<Longrightarrow> \\<bar>gs1.\\<mu> i j'\\<bar> \\<le> inverse 2\n\ngoal (1 subgoal):\n 1. j \\<le> j' \\<longrightarrow>\n    j' < i \\<longrightarrow> \\<bar>gs2.\\<mu> i j'\\<bar> \\<le> inverse 2", "by (cases \"j' > j\", insert mu_update[of i j'] i, auto)"], ["proof (state)\nthis:\n  j \\<le> j' \\<longrightarrow>\n  j' < i \\<longrightarrow> \\<bar>gs2.\\<mu> i j'\\<bar> \\<le> inverse 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<mu>_small_row i fs' j\n\ngoal (2 subgoals):\n 1. LLL_measure i fs' = LLL_measure i fs\n 2. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "}"], ["proof (state)\nthis:\n  \\<lbrakk>c = round (gs1.\\<mu> i j); \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i fs' j\n\ngoal (2 subgoals):\n 1. LLL_measure i fs' = LLL_measure i fs\n 2. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "{"], ["proof (state)\nthis:\n  \\<lbrakk>c = round (gs1.\\<mu> i j); \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i fs' j\n\ngoal (2 subgoals):\n 1. LLL_measure i fs' = LLL_measure i fs\n 2. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_measure i fs' = LLL_measure i fs\n 2. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "assume i: \"i \\<le> m\""], ["proof (state)\nthis:\n  i \\<le> m\n\ngoal (2 subgoals):\n 1. LLL_measure i fs' = LLL_measure i fs\n 2. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "have \"rat_of_int (d fs' i) = of_int (d fs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' i) = rat_of_int (d fs i)", "unfolding d_def Gramian_determinant(1)[OF Linv i] Gramian_determinant(1)[OF Linv' i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2) =\n    (\\<Prod>j<i. \\<parallel>gs1.gso j\\<parallel>\\<^sup>2)", "by (rule prod.cong[OF refl], subst eq_fs, insert i, auto)"], ["proof (state)\nthis:\n  rat_of_int (d fs' i) = rat_of_int (d fs i)\n\ngoal (2 subgoals):\n 1. LLL_measure i fs' = LLL_measure i fs\n 2. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "thus \"d fs' i = d fs i\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs' i) = rat_of_int (d fs i)\n\ngoal (1 subgoal):\n 1. d fs' i = d fs i", "by simp"], ["proof (state)\nthis:\n  d fs' i = d fs i\n\ngoal (1 subgoal):\n 1. LLL_measure i fs' = LLL_measure i fs", "}"], ["proof (state)\nthis:\n  ?ia5 \\<le> m \\<Longrightarrow> d fs' ?ia5 = d fs ?ia5\n\ngoal (1 subgoal):\n 1. LLL_measure i fs' = LLL_measure i fs", "note d = this"], ["proof (state)\nthis:\n  ?ia5 \\<le> m \\<Longrightarrow> d fs' ?ia5 = d fs ?ia5\n\ngoal (1 subgoal):\n 1. LLL_measure i fs' = LLL_measure i fs", "have D: \"D fs' = D fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D fs' = D fs", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (prod (d fs') {..<m}) = nat (prod (d fs) {..<m})", "by (rule arg_cong[of _ _ nat], rule prod.cong[OF refl], auto simp: d)"], ["proof (state)\nthis:\n  D fs' = D fs\n\ngoal (1 subgoal):\n 1. LLL_measure i fs' = LLL_measure i fs", "show \"LLL_measure i fs' = LLL_measure i fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_measure i fs' = LLL_measure i fs", "unfolding LLL_measure_def logD_def D"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    (if \\<alpha> = 4 / 3 then D fs\n     else nat \\<lfloor>log (1 / real_of_rat reduction)\n                        (real (D fs))\\<rfloor>) +\n    m -\n    i =\n    2 *\n    (if \\<alpha> = 4 / 3 then D fs\n     else nat \\<lfloor>log (1 / real_of_rat reduction)\n                        (real (D fs))\\<rfloor>) +\n    m -\n    i", ".."], ["proof (state)\nthis:\n  LLL_measure i fs' = LLL_measure i fs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Addition step which can be skipped since $\\mu$-value is already small\\<close>"], ["", "lemma basis_reduction_add_row_main_0: assumes Linv: \"LLL_invariant_weak fs\"\n  and i: \"i < m\"  and j: \"j < i\" \n  and 0: \"round (\\<mu> fs i j) = 0\" \n  and mu_small: \"\\<mu>_small_row i fs (Suc j)\"\nshows \"\\<mu>_small_row i fs j\" (is ?g1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>_small_row i fs j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu>_small_row i fs j", "note inv = LLL_inv_wD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. \\<mu>_small_row i fs j", "from inv(5)[OF i] inv(5)[of j] i j"], ["proof (chain)\npicking this:\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i \\<in> Rn\n  j < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) j \\<in> Rn\n  i < m\n  j < i", "have id: \"fs[i := fs ! i - 0 \\<cdot>\\<^sub>v fs ! j] = fs\""], ["proof (prove)\nusing this:\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i \\<in> Rn\n  j < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) j \\<in> Rn\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. fs[i := fs ! i - 0 \\<cdot>\\<^sub>v fs ! j] = fs", "by (intro nth_equalityI, insert inv i, auto)"], ["proof (state)\nthis:\n  fs[i := fs ! i - 0 \\<cdot>\\<^sub>v fs ! j] = fs\n\ngoal (1 subgoal):\n 1. \\<mu>_small_row i fs j", "show ?g1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>_small_row i fs j", "using basis_reduction_add_row_main[OF Linv i j _, of fs] 0 id mu_small"], ["proof (prove)\nusing this:\n  fs = fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j] \\<Longrightarrow>\n  LLL_invariant_weak fs\n  \\<lbrakk>fs = fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j];\n   LLL_invariant True i fs\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant True i fs\n  \\<lbrakk>fs = fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j];\n   ?c = round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n   \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i fs j\n  \\<lbrakk>fs = fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j];\n   ?c =\n   round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<rbrakk>\n  \\<Longrightarrow> \\<bar>gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) i j\\<bar>\n                    \\<le> 1 / 2\n  fs = fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j] \\<Longrightarrow>\n  LLL_measure i fs = LLL_measure i fs\n  \\<lbrakk>fs = fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]; ?i < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i =\n                    gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i\n  \\<lbrakk>fs = fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]; ?i' < m;\n   ?j' < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ?i'\n                     ?j' =\n                    (if ?i' = i \\<and> ?j' \\<le> j\n                     then gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) i ?j' -\n                          rat_of_int ?c *\n                          gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) j ?j'\n                     else gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) ?i' ?j')\n  \\<lbrakk>fs = fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j];\n   ?ii \\<le> m\\<rbrakk>\n  \\<Longrightarrow> d fs ?ii = d fs ?ii\n  round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) = 0\n  fs[i := fs ! i - 0 \\<cdot>\\<^sub>v fs ! j] = fs\n  \\<mu>_small_row i fs (Suc j)\n\ngoal (1 subgoal):\n 1. \\<mu>_small_row i fs j", "by auto"], ["proof (state)\nthis:\n  \\<mu>_small_row i fs j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<mu>_small_row_refl: \"\\<mu>_small_row i fs i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>_small_row i fs i", "unfolding \\<mu>_small_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j'\\<ge>i.\n       j' < i \\<longrightarrow>\n       \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j'\\<bar>\n       \\<le> inverse 2", "by auto"], ["", "lemma basis_reduction_add_row_done: assumes Linv: \"LLL_invariant True i fs\"\n  and i: \"i < m\" \n  and mu_small: \"\\<mu>_small_row i fs 0\" \nshows \"LLL_invariant False i fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant False i fs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_invariant False i fs", "note inv = LLL_invD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs", "from mu_small"], ["proof (chain)\npicking this:\n  \\<mu>_small_row i fs 0", "have mu_small: \"\\<mu>_small fs i\""], ["proof (prove)\nusing this:\n  \\<mu>_small_row i fs 0\n\ngoal (1 subgoal):\n 1. \\<mu>_small fs i", "unfolding \\<mu>_small_row_def \\<mu>_small_def"], ["proof (prove)\nusing this:\n  \\<forall>j'\\<ge>0.\n     j' < i \\<longrightarrow>\n     \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j'\\<bar>\n     \\<le> inverse 2\n\ngoal (1 subgoal):\n 1. \\<forall>j<i.\n       \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n       \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant False i fs", "using i mu_small"], ["proof (prove)\nusing this:\n  i < m\n  \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs", "by (intro LLL_invI[OF inv(3,6,7,9,1,10)], auto)"], ["proof (state)\nthis:\n  LLL_invariant False i fs\n\ngoal:\nNo subgoals!", "qed"], ["", "(* lemma 16.16 (ii), one case *)"], ["", "lemma d_swap_unchanged: assumes len: \"length F1 = m\" \n  and i0: \"i \\<noteq> 0\" and i: \"i < m\" and ki: \"k \\<noteq> i\" and km: \"k \\<le> m\"   \n  and swap: \"F2 = F1[i := F1 ! (i - 1), i - 1 := F1 ! i]\"\nshows \"d F1 k = d F2 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "let ?F1_M = \"mat k n (\\<lambda>(i, y). F1 ! i $ y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "let ?F2_M = \"mat k n (\\<lambda>(i, y). F2 ! i $ y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "have \"\\<exists> P. P \\<in> carrier_mat k k \\<and> det P \\<in> {-1, 1} \\<and> ?F2_M = P * ?F1_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "assume ki: \"k < i\""], ["proof (state)\nthis:\n  k < i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "hence H: \"?F2_M = ?F1_M\""], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n    mat k n (\\<lambda>(i, y). F1 ! i $ y)", "unfolding swap"], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. mat k n\n     (\\<lambda>(ia, y). F1[i := F1 ! (i - 1), i - 1 := F1 ! i] ! ia $ y) =\n    mat k n (\\<lambda>(i, y). F1 ! i $ y)", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n  mat k n (\\<lambda>(i, y). F1 ! i $ y)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "let ?P = \"1\\<^sub>m k\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "have \"?P \\<in> carrier_mat k k\" \"det ?P \\<in> {-1, 1}\" \"?F2_M = ?P * ?F1_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m k \\<in> carrier_mat k k &&&\n    det (1\\<^sub>m k) \\<in> {- (1::'b), 1::'b} &&&\n    mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n    1\\<^sub>m k * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "unfolding H"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m k \\<in> carrier_mat k k &&&\n    det (1\\<^sub>m k) \\<in> {- (1::'b), 1::'b} &&&\n    mat k n (\\<lambda>(i, y). F1 ! i $ y) =\n    1\\<^sub>m k * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m k \\<in> carrier_mat k k\n  det (1\\<^sub>m k) \\<in> {- (1::?'b2), 1::?'b2}\n  mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n  1\\<^sub>m k * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  1\\<^sub>m k \\<in> carrier_mat k k\n  det (1\\<^sub>m k) \\<in> {- (1::?'b2), 1::?'b2}\n  mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n  1\\<^sub>m k * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "by blast"], ["proof (state)\nthis:\n  \\<exists>P.\n     P \\<in> carrier_mat k k \\<and>\n     det P \\<in> {- 1, 1} \\<and>\n     mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n     P * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "assume \"\\<not> k < i\""], ["proof (state)\nthis:\n  \\<not> k < i\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "with ki"], ["proof (chain)\npicking this:\n  k \\<noteq> i\n  \\<not> k < i", "have ki: \"k > i\""], ["proof (prove)\nusing this:\n  k \\<noteq> i\n  \\<not> k < i\n\ngoal (1 subgoal):\n 1. i < k", "by auto"], ["proof (state)\nthis:\n  i < k\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "let ?P = \"swaprows_mat k i (i - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "from i0 ki"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  i < k", "have neq: \"i \\<noteq> i - 1\" and kmi: \"i - 1 < k\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  i < k\n\ngoal (1 subgoal):\n 1. i \\<noteq> i - 1 &&& i - 1 < k", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> i - 1\n  i - 1 < k\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "have *: \"?P \\<in> carrier_mat k k\" \"det ?P \\<in> {-1, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat k i (i - 1) \\<in> carrier_mat k k &&&\n    det (swaprows_mat k i (i - 1)) \\<in> {- (1::'b), 1::'b}", "using det_swaprows_mat[OF ki kmi neq] ki"], ["proof (prove)\nusing this:\n  det (swaprows_mat k i (i - 1)) = - (1::?'a)\n  i < k\n\ngoal (1 subgoal):\n 1. swaprows_mat k i (i - 1) \\<in> carrier_mat k k &&&\n    det (swaprows_mat k i (i - 1)) \\<in> {- (1::'b), 1::'b}", "by auto"], ["proof (state)\nthis:\n  swaprows_mat k i (i - 1) \\<in> carrier_mat k k\n  det (swaprows_mat k i (i - 1)) \\<in> {- (1::?'b3), 1::?'b3}\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "from i len"], ["proof (chain)\npicking this:\n  i < m\n  length F1 = m", "have iH: \"i < length F1\" \"i - 1 < length F1\""], ["proof (prove)\nusing this:\n  i < m\n  length F1 = m\n\ngoal (1 subgoal):\n 1. i < length F1 &&& i - 1 < length F1", "by auto"], ["proof (state)\nthis:\n  i < length F1\n  i - 1 < length F1\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "have \"?P * ?F1_M = swaprows i (i - 1) ?F1_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat k i (i - 1) * mat k n (\\<lambda>(i, y). F1 ! i $ y) =\n    swaprows i (i - 1) (mat k n (\\<lambda>(i, y). F1 ! i $ y))", "by (subst swaprows_mat[OF _ ki kmi], auto)"], ["proof (state)\nthis:\n  swaprows_mat k i (i - 1) * mat k n (\\<lambda>(i, y). F1 ! i $ y) =\n  swaprows i (i - 1) (mat k n (\\<lambda>(i, y). F1 ! i $ y))\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "also"], ["proof (state)\nthis:\n  swaprows_mat k i (i - 1) * mat k n (\\<lambda>(i, y). F1 ! i $ y) =\n  swaprows i (i - 1) (mat k n (\\<lambda>(i, y). F1 ! i $ y))\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "have \"\\<dots> = ?F2_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows i (i - 1) (mat k n (\\<lambda>(i, y). F1 ! i $ y)) =\n    mat k n (\\<lambda>(i, y). F2 ! i $ y)", "unfolding swap"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows i (i - 1) (mat k n (\\<lambda>(i, y). F1 ! i $ y)) =\n    mat k n\n     (\\<lambda>(ia, y). F1[i := F1 ! (i - 1), i - 1 := F1 ! i] ! ia $ y)", "by (intro eq_matI, rename_tac ii jj, \n          case_tac \"ii = i\", (insert iH, simp add: nth_list_update)[1],\n          case_tac \"ii = i - 1\", insert iH neq ki, auto simp: nth_list_update)"], ["proof (state)\nthis:\n  swaprows i (i - 1) (mat k n (\\<lambda>(i, y). F1 ! i $ y)) =\n  mat k n (\\<lambda>(i, y). F2 ! i $ y)\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "finally"], ["proof (chain)\npicking this:\n  swaprows_mat k i (i - 1) * mat k n (\\<lambda>(i, y). F1 ! i $ y) =\n  mat k n (\\<lambda>(i, y). F2 ! i $ y)", "show ?thesis"], ["proof (prove)\nusing this:\n  swaprows_mat k i (i - 1) * mat k n (\\<lambda>(i, y). F1 ! i $ y) =\n  mat k n (\\<lambda>(i, y). F2 ! i $ y)\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "using *"], ["proof (prove)\nusing this:\n  swaprows_mat k i (i - 1) * mat k n (\\<lambda>(i, y). F1 ! i $ y) =\n  mat k n (\\<lambda>(i, y). F2 ! i $ y)\n  swaprows_mat k i (i - 1) \\<in> carrier_mat k k\n  det (swaprows_mat k i (i - 1)) \\<in> {- (1::?'b3), 1::?'b3}\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       P \\<in> carrier_mat k k \\<and>\n       det P \\<in> {- 1, 1} \\<and>\n       mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n       P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "by metis"], ["proof (state)\nthis:\n  \\<exists>P.\n     P \\<in> carrier_mat k k \\<and>\n     det P \\<in> {- 1, 1} \\<and>\n     mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n     P * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P.\n     P \\<in> carrier_mat k k \\<and>\n     det P \\<in> {- 1, 1} \\<and>\n     mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n     P * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "then"], ["proof (chain)\npicking this:\n  \\<exists>P.\n     P \\<in> carrier_mat k k \\<and>\n     det P \\<in> {- 1, 1} \\<and>\n     mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n     P * mat k n (\\<lambda>(i, y). F1 ! i $ y)", "obtain P where P: \"P \\<in> carrier_mat k k\" and detP: \"det P \\<in> {-1, 1}\" and H': \"?F2_M = P * ?F1_M\""], ["proof (prove)\nusing this:\n  \\<exists>P.\n     P \\<in> carrier_mat k k \\<and>\n     det P \\<in> {- 1, 1} \\<and>\n     mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n     P * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> carrier_mat k k; det P \\<in> {- 1, 1};\n         mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n         P * mat k n (\\<lambda>(i, y). F1 ! i $ y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat k k\n  det P \\<in> {- 1, 1}\n  mat k n (\\<lambda>(i, y). F2 ! i $ y) =\n  P * mat k n (\\<lambda>(i, y). F1 ! i $ y)\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "have \"d F2 k = det (gs.Gramian_matrix F2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d F2 k = det (gs.Gramian_matrix F2 k)", "unfolding d_def gs.Gramian_determinant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (gs.Gramian_matrix F2 k) = det (gs.Gramian_matrix F2 k)", "by simp"], ["proof (state)\nthis:\n  d F2 k = det (gs.Gramian_matrix F2 k)\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "also"], ["proof (state)\nthis:\n  d F2 k = det (gs.Gramian_matrix F2 k)\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "have \"\\<dots> = det (?F2_M * ?F2_M\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (gs.Gramian_matrix F2 k) =\n    det (mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n         (mat k n (\\<lambda>(i, y). F2 ! i $ y))\\<^sup>T)", "unfolding gs.Gramian_matrix_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n         (mat k n (\\<lambda>(i, y). F2 ! i $ y))\\<^sup>T) =\n    det (mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n         (mat k n (\\<lambda>(i, y). F2 ! i $ y))\\<^sup>T)", "by simp"], ["proof (state)\nthis:\n  det (gs.Gramian_matrix F2 k) =\n  det (mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n       (mat k n (\\<lambda>(i, y). F2 ! i $ y))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "also"], ["proof (state)\nthis:\n  det (gs.Gramian_matrix F2 k) =\n  det (mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n       (mat k n (\\<lambda>(i, y). F2 ! i $ y))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "have \"?F2_M * ?F2_M\\<^sup>T = ?F2_M * (?F1_M\\<^sup>T * P\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n    (mat k n (\\<lambda>(i, y). F2 ! i $ y))\\<^sup>T =\n    mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n    ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T)", "unfolding H'"], ["proof (prove)\ngoal (1 subgoal):\n 1. P * mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n    (P * mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T =\n    P * mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n    ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T)", "by (subst transpose_mult[OF P], auto)"], ["proof (state)\nthis:\n  mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n  (mat k n (\\<lambda>(i, y). F2 ! i $ y))\\<^sup>T =\n  mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n  ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T)\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "also"], ["proof (state)\nthis:\n  mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n  (mat k n (\\<lambda>(i, y). F2 ! i $ y))\\<^sup>T =\n  mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n  ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T)\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "have \"\\<dots> = P * (?F1_M * (?F1_M\\<^sup>T * P\\<^sup>T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n    ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T) =\n    P *\n    (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n     ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T))", "unfolding H'"], ["proof (prove)\ngoal (1 subgoal):\n 1. P * mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n    ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T) =\n    P *\n    (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n     ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T))", "by (subst assoc_mult_mat[OF P], auto)"], ["proof (state)\nthis:\n  mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n  ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T) =\n  P *\n  (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n   ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T))\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "also"], ["proof (state)\nthis:\n  mat k n (\\<lambda>(i, y). F2 ! i $ y) *\n  ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T) =\n  P *\n  (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n   ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T))\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "have \"det \\<dots> = det P * det (?F1_M * (?F1_M\\<^sup>T * P\\<^sup>T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (P *\n         (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n          ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T))) =\n    det P *\n    det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n         ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T))", "by (rule det_mult[OF P], insert P, auto)"], ["proof (state)\nthis:\n  det (P *\n       (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n        ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T))) =\n  det P *\n  det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n       ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T))\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "also"], ["proof (state)\nthis:\n  det (P *\n       (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n        ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T))) =\n  det P *\n  det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n       ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T))\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "have \"?F1_M * (?F1_M\\<^sup>T * P\\<^sup>T) = (?F1_M * ?F1_M\\<^sup>T) * P\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n    ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T) =\n    mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n    (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T *\n    P\\<^sup>T", "by (subst assoc_mult_mat, insert P, auto)"], ["proof (state)\nthis:\n  mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n  ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T) =\n  mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n  (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T *\n  P\\<^sup>T\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "also"], ["proof (state)\nthis:\n  mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n  ((mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T * P\\<^sup>T) =\n  mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n  (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T *\n  P\\<^sup>T\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "have \"det \\<dots> = det (?F1_M * ?F1_M\\<^sup>T) * det P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n         (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T *\n         P\\<^sup>T) =\n    det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n         (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T) *\n    det P", "by (subst det_mult, insert P, auto simp: det_transpose)"], ["proof (state)\nthis:\n  det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n       (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T *\n       P\\<^sup>T) =\n  det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n       (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T) *\n  det P\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "also"], ["proof (state)\nthis:\n  det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n       (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T *\n       P\\<^sup>T) =\n  det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n       (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T) *\n  det P\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "have \"det (?F1_M * ?F1_M\\<^sup>T) = det (gs.Gramian_matrix F1 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n         (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T) =\n    det (gs.Gramian_matrix F1 k)", "unfolding gs.Gramian_matrix_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n         (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T) =\n    det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n         (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T)", "by simp"], ["proof (state)\nthis:\n  det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n       (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T) =\n  det (gs.Gramian_matrix F1 k)\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "also"], ["proof (state)\nthis:\n  det (mat k n (\\<lambda>(i, y). F1 ! i $ y) *\n       (mat k n (\\<lambda>(i, y). F1 ! i $ y))\\<^sup>T) =\n  det (gs.Gramian_matrix F1 k)\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "have \"\\<dots> = d F1 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (gs.Gramian_matrix F1 k) = d F1 k", "unfolding d_def gs.Gramian_determinant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (gs.Gramian_matrix F1 k) = det (gs.Gramian_matrix F1 k)", "by simp"], ["proof (state)\nthis:\n  det (gs.Gramian_matrix F1 k) = d F1 k\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "finally"], ["proof (chain)\npicking this:\n  d F2 k = det P * (d F1 k * det P)", "have \"d F2 k = (det P * det P) * d F1 k\""], ["proof (prove)\nusing this:\n  d F2 k = det P * (d F1 k * det P)\n\ngoal (1 subgoal):\n 1. d F2 k = det P * det P * d F1 k", "by simp"], ["proof (state)\nthis:\n  d F2 k = det P * det P * d F1 k\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "also"], ["proof (state)\nthis:\n  d F2 k = det P * det P * d F1 k\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "have \"det P * det P = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det P * det P = 1", "using detP"], ["proof (prove)\nusing this:\n  det P \\<in> {- 1, 1}\n\ngoal (1 subgoal):\n 1. det P * det P = 1", "by auto"], ["proof (state)\nthis:\n  det P * det P = 1\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "finally"], ["proof (chain)\npicking this:\n  d F2 k = 1 * d F1 k", "show \"d F1 k = d F2 k\""], ["proof (prove)\nusing this:\n  d F2 k = 1 * d F1 k\n\ngoal (1 subgoal):\n 1. d F1 k = d F2 k", "by simp"], ["proof (state)\nthis:\n  d F1 k = d F2 k\n\ngoal:\nNo subgoals!", "qed"], ["", "definition base where \"base = real_of_rat ((4 * \\<alpha>) / (4 + \\<alpha>))\""], ["", "definition g_bound :: \"int vec list \\<Rightarrow> bool\" where \n  \"g_bound fs = (\\<forall> i < m. sq_norm (gso fs i) \\<le> of_nat N)\""], ["", "end"], ["", "locale LLL_with_assms = LLL + \n  assumes \\<alpha>: \"\\<alpha> \\<ge> 4/3\"\n    and lin_dep: \"lin_indep fs_init\" \n    and len: \"length fs_init = m\" \nbegin"], ["", "lemma \\<alpha>0: \"\\<alpha> > 0\" \"\\<alpha> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<alpha> &&& \\<alpha> \\<noteq> 0", "using \\<alpha>"], ["proof (prove)\nusing this:\n  4 / 3 \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. 0 < \\<alpha> &&& \\<alpha> \\<noteq> 0", "by auto"], ["", "lemma fs_init: \"set fs_init \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set fs_init \\<subseteq> carrier_vec n", "using lin_dep[unfolded gs.lin_indpt_list_def]"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs_init) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n\ngoal (1 subgoal):\n 1. set fs_init \\<subseteq> carrier_vec n", "by auto"], ["", "lemma reduction: \"0 < reduction\" \"reduction \\<le> 1\" \n  \"\\<alpha> > 4/3 \\<Longrightarrow> reduction < 1\" \n  \"\\<alpha> = 4/3 \\<Longrightarrow> reduction = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < reduction &&& reduction \\<le> 1) &&&\n    (4 / 3 < \\<alpha> \\<Longrightarrow> reduction < 1) &&&\n    (\\<alpha> = 4 / 3 \\<Longrightarrow> reduction = 1)", "using \\<alpha>"], ["proof (prove)\nusing this:\n  4 / 3 \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. (0 < reduction &&& reduction \\<le> 1) &&&\n    (4 / 3 < \\<alpha> \\<Longrightarrow> reduction < 1) &&&\n    (\\<alpha> = 4 / 3 \\<Longrightarrow> reduction = 1)", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  4 / 3 \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. (0 < (4 + \\<alpha>) / (4 * \\<alpha>) &&&\n     (4 + \\<alpha>) / (4 * \\<alpha>) \\<le> 1) &&&\n    (4 / 3 < \\<alpha> \\<Longrightarrow>\n     (4 + \\<alpha>) / (4 * \\<alpha>) < 1) &&&\n    (\\<alpha> = 4 / 3 \\<Longrightarrow> (4 + \\<alpha>) / (4 * \\<alpha>) = 1)", "by auto"], ["", "lemma base: \"\\<alpha> > 4/3 \\<Longrightarrow> base > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 / 3 < \\<alpha> \\<Longrightarrow> 1 < base", "using reduction(1,3)"], ["proof (prove)\nusing this:\n  0 < reduction\n  4 / 3 < \\<alpha> \\<Longrightarrow> reduction < 1\n\ngoal (1 subgoal):\n 1. 4 / 3 < \\<alpha> \\<Longrightarrow> 1 < base", "unfolding reduction_def base_def"], ["proof (prove)\nusing this:\n  0 < (4 + \\<alpha>) / (4 * \\<alpha>)\n  4 / 3 < \\<alpha> \\<Longrightarrow> (4 + \\<alpha>) / (4 * \\<alpha>) < 1\n\ngoal (1 subgoal):\n 1. 4 / 3 < \\<alpha> \\<Longrightarrow>\n    1 < real_of_rat (4 * \\<alpha> / (4 + \\<alpha>))", "by auto"], ["", "lemma basis_reduction_swap_main: assumes Linvw: \"LLL_invariant_weak fs\"\n  and small: \"LLL_invariant False i fs \\<or> abs (\\<mu> fs i (i - 1)) \\<le> 1/2\" \n  and i: \"i < m\"\n  and i0: \"i \\<noteq> 0\" \n  and norm_ineq: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\" \n  and fs'_def: \"fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]\" \nshows \"LLL_invariant_weak fs'\" \n  and \"LLL_invariant False i fs \\<Longrightarrow> LLL_invariant False (i - 1) fs'\" \n  and \"LLL_measure i fs > LLL_measure (i - 1) fs'\" \n  (* new values of gso *)\n  and \"\\<And> k. k < m \\<Longrightarrow> gso fs' k = (if k = i - 1 then\n         gso fs i + \\<mu> fs i (i - 1) \\<cdot>\\<^sub>v gso fs (i - 1) \n      else if k = i then\n         gso fs (i - 1) - (RAT fs ! (i - 1) \\<bullet> gso fs' (i - 1) / sq_norm (gso fs' (i - 1))) \\<cdot>\\<^sub>v gso fs' (i - 1)\n      else gso fs k)\" (is \"\\<And> k. _ \\<Longrightarrow> _ = ?newg k\")\n  (* new values of norms of gso *)\n  and \"\\<And> k. k < m \\<Longrightarrow> sq_norm (gso fs' k) = (if k = i - 1 then\n          sq_norm (gso fs i) + (\\<mu> fs i (i - 1) * \\<mu> fs i (i - 1)) * sq_norm (gso fs (i - 1))\n      else if k = i then\n         sq_norm (gso fs i) * sq_norm (gso fs (i - 1)) / sq_norm (gso fs' (i - 1))\n      else sq_norm (gso fs k))\" (is \"\\<And> k. _ \\<Longrightarrow> _ = ?new_norm k\")\n  (* new values of \\<mu>-values *)\n  and \"\\<And> ii j. ii < m \\<Longrightarrow> j < ii \\<Longrightarrow> \\<mu> fs' ii j = (\n        if ii = i - 1 then \n           \\<mu> fs i j\n        else if ii = i then \n          if j = i - 1 then \n             \\<mu> fs i (i - 1) * sq_norm (gso fs (i - 1)) / sq_norm (gso fs' (i - 1))\n          else \n             \\<mu> fs (i - 1) j\n        else if ii > i \\<and> j = i then\n           \\<mu> fs ii (i - 1) - \\<mu> fs i (i - 1) * \\<mu> fs ii i\n        else if ii > i \\<and> j = i - 1 then \n           \\<mu> fs ii (i - 1) * \\<mu> fs' i (i - 1) + \\<mu> fs ii i * sq_norm (gso fs i) / sq_norm (gso fs' (i - 1))\n        else \\<mu> fs ii j)\" (is \"\\<And> ii j. _ \\<Longrightarrow> _ \\<Longrightarrow> _ = ?new_mu ii j\")\n  (* new d-values *)\n  and \"\\<And> ii. ii \\<le> m \\<Longrightarrow> of_int (d fs' ii) = (if ii = i then \n       sq_norm (gso fs' (i - 1)) / sq_norm (gso fs (i - 1)) * of_int (d fs i)\n       else of_int (d fs ii))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LLL_invariant_weak fs' &&&\n     (LLL_invariant False i fs \\<Longrightarrow>\n      LLL_invariant False (i - 1) fs') &&&\n     LLL_measure (i - 1) fs' < LLL_measure i fs) &&&\n    ((\\<And>k.\n         k < m \\<Longrightarrow>\n         gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n         (if k = i - 1\n          then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i +\n               gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                (i - 1) \\<cdot>\\<^sub>v\n               gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (i - 1)\n          else if k = i\n               then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     (i - 1) -\n                    map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                    gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                     (i - 1) /\n                    \\<parallel>gram_schmidt_fs.gso n\n                                (map of_int_hom.vec_hom fs')\n                                (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                    gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                     (i - 1)\n               else gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     k)) &&&\n     (\\<And>k.\n         k < m \\<Longrightarrow>\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                     k\\<parallel>\\<^sup>2 =\n         (if k = i - 1\n          then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                           i\\<parallel>\\<^sup>2 +\n               gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                (i - 1) *\n               gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                (i - 1) *\n               \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                           (i - 1)\\<parallel>\\<^sup>2\n          else if k = i\n               then \\<parallel>gram_schmidt_fs.gso n\n                                (map of_int_hom.vec_hom fs)\n                                i\\<parallel>\\<^sup>2 *\n                    \\<parallel>gram_schmidt_fs.gso n\n                                (map of_int_hom.vec_hom fs)\n                                (i - 1)\\<parallel>\\<^sup>2 /\n                    \\<parallel>gram_schmidt_fs.gso n\n                                (map of_int_hom.vec_hom fs')\n                                (i - 1)\\<parallel>\\<^sup>2\n               else \\<parallel>gram_schmidt_fs.gso n\n                                (map of_int_hom.vec_hom fs)\n                                k\\<parallel>\\<^sup>2))) &&&\n    (\\<And>ii j.\n        \\<lbrakk>ii < m; j < ii\\<rbrakk>\n        \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs') ii j =\n                          (if ii = i - 1\n                           then gram_schmidt_fs.\\<mu> n\n                                 (map of_int_hom.vec_hom fs) i j\n                           else if ii = i\n                                then if j = i - 1\n                                     then gram_schmidt_fs.\\<mu> n\n     (map of_int_hom.vec_hom fs) i (i - 1) *\n    \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                (i - 1)\\<parallel>\\<^sup>2\n                                     else gram_schmidt_fs.\\<mu> n\n     (map of_int_hom.vec_hom fs) (i - 1) j\n                                else if i < ii \\<and> j = i\n                                     then gram_schmidt_fs.\\<mu> n\n     (map of_int_hom.vec_hom fs) ii (i - 1) -\n    gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n    gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii i\n                                     else if i < ii \\<and> j = i - 1\n    then gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii (i - 1) *\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n         gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii i *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     i\\<parallel>\\<^sup>2 /\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                     (i - 1)\\<parallel>\\<^sup>2\n    else gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii j)) &&&\n    (\\<And>ii.\n        ii \\<le> m \\<Longrightarrow>\n        rat_of_int (d fs' ii) =\n        (if ii = i\n         then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                          (i - 1)\\<parallel>\\<^sup>2 /\n              \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                          (i - 1)\\<parallel>\\<^sup>2 *\n              rat_of_int (d fs i)\n         else rat_of_int (d fs ii)))", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i +\n             gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n              (i - 1) \\<cdot>\\<^sub>v\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (i - 1)\n        else if k = i\n             then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                   (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         i\\<parallel>\\<^sup>2 +\n             gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n             gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs)\n                              i\\<parallel>\\<^sup>2 *\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs)\n                              (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs)\n                              k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) i (i - 1) *\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ii (i - 1) -\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii i\n                                    else if i < ii \\<and> j = i - 1\n   then gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii i *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note inv = LLL_inv_wD[OF Linvw]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i +\n             gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n              (i - 1) \\<cdot>\\<^sub>v\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (i - 1)\n        else if k = i\n             then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                   (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         i\\<parallel>\\<^sup>2 +\n             gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n             gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs)\n                              i\\<parallel>\\<^sup>2 *\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs)\n                              (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs)\n                              k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1\n                          then gram_schmidt_fs.\\<mu> n\n                                (map of_int_hom.vec_hom fs) i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) i (i - 1) *\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ii (i - 1) -\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii i\n                                    else if i < ii \\<and> j = i - 1\n   then gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii i *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "interpret fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by (standard) (use Linvw in auto)"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?mu1 = \"\\<mu> fs\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?mu2 = \"\\<mu> fs'\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?g1 = \"gso fs\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?g2 = \"gso fs'\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have m12: \"\\<bar>?mu1 i (i - 1)\\<bar> \\<le> inverse 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2", "using small"], ["proof (prove)\nusing this:\n  LLL_invariant False i fs \\<or>\n  \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_invariant False i fs \\<Longrightarrow>\n    \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2\n 2. \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> 1 / 2 \\<Longrightarrow>\n    \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2", "assume \"LLL_invariant False i fs\""], ["proof (state)\nthis:\n  LLL_invariant False i fs\n\ngoal (2 subgoals):\n 1. LLL_invariant False i fs \\<Longrightarrow>\n    \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2\n 2. \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> 1 / 2 \\<Longrightarrow>\n    \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2", "from LLL_invD(11)[OF this] i0"], ["proof (chain)\npicking this:\n  False \\<or> \\<mu>_small fs i\n  i \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  False \\<or> \\<mu>_small fs i\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2", "unfolding \\<mu>_small_def"], ["proof (prove)\nusing this:\n  False \\<or> (\\<forall>j<i. \\<bar>fs.gs.\\<mu> i j\\<bar> \\<le> 1 / 2)\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> 1 / 2 \\<Longrightarrow>\n    \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2", "qed auto"], ["proof (state)\nthis:\n  \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note d = d_def"], ["proof (state)\nthis:\n  d ?fs ?k = gs.Gramian_determinant ?fs ?k\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note Gd = Gramian_determinant(1)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_invariant_weak ?fs; ?k \\<le> m\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (gs.Gramian_determinant ?fs ?k) =\n                    (\\<Prod>j<?k.\n                        \\<parallel>gram_schmidt_fs.gso n\n                                    (map of_int_hom.vec_hom ?fs)\n                                    j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note Gd12 = Gd[OF Linvw]"], ["proof (state)\nthis:\n  ?k \\<le> m \\<Longrightarrow>\n  rat_of_int (gs.Gramian_determinant fs ?k) =\n  (\\<Prod>j<?k. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?x = \"?g1 (i - 1)\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?y = \"?g1 i\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?cond = \"\\<alpha> * sq_norm ?y < sq_norm ?x\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from inv"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L", "have len: \"length fs = m\" and HC: \"set fs \\<subseteq> carrier_vec n\" \n    and L: \"lattice_of fs = L\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. length fs = m &&& set fs \\<subseteq> carrier_vec n &&& lattice_of fs = L", "using i"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  i < m\n\ngoal (1 subgoal):\n 1. length fs = m &&& set fs \\<subseteq> carrier_vec n &&& lattice_of fs = L", "by auto"], ["proof (state)\nthis:\n  length fs = m\n  set fs \\<subseteq> carrier_vec n\n  lattice_of fs = L\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from i0 inv i"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  i < m", "have swap: \"set fs \\<subseteq> carrier_vec n\" \"i < length fs\" \"i - 1 < length fs\" \"i \\<noteq> i - 1\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  i < m\n\ngoal (1 subgoal):\n 1. (set fs \\<subseteq> carrier_vec n &&& i < length fs) &&&\n    i - 1 < length fs &&& i \\<noteq> i - 1", "unfolding Let_def"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  i < m\n\ngoal (1 subgoal):\n 1. (set fs \\<subseteq> carrier_vec n &&& i < length fs) &&&\n    i - 1 < length fs &&& i \\<noteq> i - 1", "by auto"], ["proof (state)\nthis:\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  i - 1 < length fs\n  i \\<noteq> i - 1\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have RAT_fs': \"RAT fs' = (RAT fs)[i := (RAT fs) ! (i - 1), i - 1 := (RAT fs) ! i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' = (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! (i - 1),\n     i - 1 := map of_int_hom.vec_hom fs ! i]", "unfolding fs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! (i - 1),\n     i - 1 := map of_int_hom.vec_hom fs ! i]", "using swap"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  i - 1 < length fs\n  i \\<noteq> i - 1\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) =\n    (map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! (i - 1),\n     i - 1 := map of_int_hom.vec_hom fs ! i]", "by (intro nth_equalityI, auto simp: nth_list_update)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' = (map of_int_hom.vec_hom fs)\n  [i := map of_int_hom.vec_hom fs ! (i - 1),\n   i - 1 := map of_int_hom.vec_hom fs ! i]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have span': \"gs.span (SRAT fs) = gs.span (SRAT fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (set (map of_int_hom.vec_hom fs)) =\n    gs.span (set (map of_int_hom.vec_hom fs'))", "unfolding fs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (set (map of_int_hom.vec_hom fs)) =\n    gs.span\n     (set (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])))", "by (rule arg_cong[of _ _ gs.span], insert swap, auto)"], ["proof (state)\nthis:\n  gs.span (set (map of_int_hom.vec_hom fs)) =\n  gs.span (set (map of_int_hom.vec_hom fs'))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have lfs': \"lattice_of fs' = lattice_of fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of fs' = lattice_of fs", "unfolding fs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of (fs[i := fs ! (i - 1), i - 1 := fs ! i]) = lattice_of fs", "by (rule lattice_of_swap[OF swap refl])"], ["proof (state)\nthis:\n  lattice_of fs' = lattice_of fs\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "with inv"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  lattice_of fs' = lattice_of fs", "have lattice: \"lattice_of fs' = L\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  lattice_of fs' = lattice_of fs\n\ngoal (1 subgoal):\n 1. lattice_of fs' = L", "by auto"], ["proof (state)\nthis:\n  lattice_of fs' = L\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have len': \"length fs' = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length fs' = m", "using inv"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. length fs' = m", "unfolding fs'_def"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. length (fs[i := fs ! (i - 1), i - 1 := fs ! i]) = m", "by auto"], ["proof (state)\nthis:\n  length fs' = m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have fs': \"set fs' \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set fs' \\<subseteq> carrier_vec n", "using swap"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  i - 1 < length fs\n  i \\<noteq> i - 1\n\ngoal (1 subgoal):\n 1. set fs' \\<subseteq> carrier_vec n", "unfolding fs'_def set_conv_nth"], ["proof (prove)\nusing this:\n  {fs ! i |i. i < length fs} \\<subseteq> carrier_vec n\n  i < length fs\n  i - 1 < length fs\n  i \\<noteq> i - 1\n\ngoal (1 subgoal):\n 1. {fs[i := fs ! (i - 1), i - 1 := fs ! i] ! ia |ia.\n     ia < length (fs[i := fs ! (i - 1), i - 1 := fs ! i])}\n    \\<subseteq> carrier_vec n", "by (auto, rename_tac k, case_tac \"k = i\", force, case_tac \"k = i - 1\", auto)"], ["proof (state)\nthis:\n  set fs' \\<subseteq> carrier_vec n\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?rv = \"map_vec rat_of_int\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from inv(1)"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)", "have indepH: \"lin_indep fs\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs)", "."], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from i i0 len"], ["proof (chain)\npicking this:\n  i < m\n  i \\<noteq> 0\n  length fs = m", "have \"i < length (RAT fs)\" \"i - 1 < length (RAT fs)\""], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n  length fs = m\n\ngoal (1 subgoal):\n 1. i < length (map of_int_hom.vec_hom fs) &&&\n    i - 1 < length (map of_int_hom.vec_hom fs)", "by auto"], ["proof (state)\nthis:\n  i < length (map of_int_hom.vec_hom fs)\n  i - 1 < length (map of_int_hom.vec_hom fs)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "with distinct_swap[OF this] len"], ["proof (chain)\npicking this:\n  distinct\n   ((map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! (i - 1),\n     i - 1 := map of_int_hom.vec_hom fs ! i]) =\n  distinct (map of_int_hom.vec_hom fs)\n  length fs = m\n  i < length (map of_int_hom.vec_hom fs)\n  i - 1 < length (map of_int_hom.vec_hom fs)", "have \"distinct (RAT fs') = distinct (RAT fs)\""], ["proof (prove)\nusing this:\n  distinct\n   ((map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! (i - 1),\n     i - 1 := map of_int_hom.vec_hom fs ! i]) =\n  distinct (map of_int_hom.vec_hom fs)\n  length fs = m\n  i < length (map of_int_hom.vec_hom fs)\n  i - 1 < length (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. distinct (map of_int_hom.vec_hom fs') =\n    distinct (map of_int_hom.vec_hom fs)", "unfolding RAT_fs'"], ["proof (prove)\nusing this:\n  distinct\n   ((map of_int_hom.vec_hom fs)\n    [i := map of_int_hom.vec_hom fs ! (i - 1),\n     i - 1 := map of_int_hom.vec_hom fs ! i]) =\n  distinct (map of_int_hom.vec_hom fs)\n  length fs = m\n  i < length (map of_int_hom.vec_hom fs)\n  i - 1 < length (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. distinct\n     ((map of_int_hom.vec_hom fs)\n      [i := map of_int_hom.vec_hom fs ! (i - 1),\n       i - 1 := map of_int_hom.vec_hom fs ! i]) =\n    distinct (map of_int_hom.vec_hom fs)", "by (auto simp: map_update)"], ["proof (state)\nthis:\n  distinct (map of_int_hom.vec_hom fs') =\n  distinct (map of_int_hom.vec_hom fs)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "with len' fs' span' indepH"], ["proof (chain)\npicking this:\n  length fs' = m\n  set fs' \\<subseteq> carrier_vec n\n  gs.span (set (map of_int_hom.vec_hom fs)) =\n  gs.span (set (map of_int_hom.vec_hom fs'))\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  distinct (map of_int_hom.vec_hom fs') =\n  distinct (map of_int_hom.vec_hom fs)", "have indepH': \"lin_indep fs'\""], ["proof (prove)\nusing this:\n  length fs' = m\n  set fs' \\<subseteq> carrier_vec n\n  gs.span (set (map of_int_hom.vec_hom fs)) =\n  gs.span (set (map of_int_hom.vec_hom fs'))\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  distinct (map of_int_hom.vec_hom fs') =\n  distinct (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs')", "unfolding fs'_def"], ["proof (prove)\nusing this:\n  length (fs[i := fs ! (i - 1), i - 1 := fs ! i]) = m\n  set (fs[i := fs ! (i - 1), i - 1 := fs ! i]) \\<subseteq> carrier_vec n\n  gs.span (set (map of_int_hom.vec_hom fs)) =\n  gs.span\n   (set (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])))\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  distinct\n   (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) =\n  distinct (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]))", "using i i0"], ["proof (prove)\nusing this:\n  length (fs[i := fs ! (i - 1), i - 1 := fs ! i]) = m\n  set (fs[i := fs ! (i - 1), i - 1 := fs ! i]) \\<subseteq> carrier_vec n\n  gs.span (set (map of_int_hom.vec_hom fs)) =\n  gs.span\n   (set (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])))\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  distinct\n   (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) =\n  distinct (map of_int_hom.vec_hom fs)\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]))", "by (auto simp: gs.lin_indpt_list_def)"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have lenR': \"length (RAT fs') = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map of_int_hom.vec_hom fs') = m", "using len'"], ["proof (prove)\nusing this:\n  length fs' = m\n\ngoal (1 subgoal):\n 1. length (map of_int_hom.vec_hom fs') = m", "by auto"], ["proof (state)\nthis:\n  length (map of_int_hom.vec_hom fs') = m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have conn1: \"set (RAT fs) \\<subseteq> carrier_vec n\"  \"length (RAT fs) = m\" \"distinct (RAT fs)\"\n    \"gs.lin_indpt (set (RAT fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs) \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs) = m) &&&\n    distinct (map of_int_hom.vec_hom fs) &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs))", "using inv"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs) \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs) = m) &&&\n    distinct (map of_int_hom.vec_hom fs) &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs))", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs) \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs) = m) &&&\n    distinct (map of_int_hom.vec_hom fs) &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs))", "by auto"], ["proof (state)\nthis:\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs) = m\n  distinct (map of_int_hom.vec_hom fs)\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have conn2: \"set (RAT fs') \\<subseteq> carrier_vec n\"  \"length (RAT fs') = m\" \"distinct (RAT fs')\"\n    \"gs.lin_indpt (set (RAT fs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs') \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs') = m) &&&\n    distinct (map of_int_hom.vec_hom fs') &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs'))", "using indepH' lenR'"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs') \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs') = m) &&&\n    distinct (map of_int_hom.vec_hom fs') &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs'))", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs') \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n  length (map of_int_hom.vec_hom fs') = m\n\ngoal (1 subgoal):\n 1. (set (map of_int_hom.vec_hom fs') \\<subseteq> Rn &&&\n     length (map of_int_hom.vec_hom fs') = m) &&&\n    distinct (map of_int_hom.vec_hom fs') &&&\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs'))", "by auto"], ["proof (state)\nthis:\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   (i - 1) /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gram_schmidt_fs.gso n\n                              (map of_int_hom.vec_hom fs')\n                              (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                          (map of_int_hom.vec_hom fs') ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "interpret gs2: gram_schmidt_fs_lin_indpt n \"RAT fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_lin_indpt n (map of_int_hom.vec_hom fs')", "by (standard) (use indepH' lenR' gs.lin_indpt_list_def in auto)"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have fs'_fs: \"k < i - 1 \\<Longrightarrow> fs' ! k = fs ! k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < i - 1 \\<Longrightarrow> fs' ! k = fs ! k", "unfolding fs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < i - 1 \\<Longrightarrow>\n    fs[i := fs ! (i - 1), i - 1 := fs ! i] ! k = fs ! k", "by auto"], ["proof (state)\nthis:\n  ?k1 < i - 1 \\<Longrightarrow> fs' ! ?k1 = fs ! ?k1\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  ?k1 < i - 1 \\<Longrightarrow> fs' ! ?k1 = fs ! ?k1\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "fix k"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume ki: \"k < i - 1\""], ["proof (state)\nthis:\n  k < i - 1\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "with i"], ["proof (chain)\npicking this:\n  i < m\n  k < i - 1", "have kn: \"k < m\""], ["proof (prove)\nusing this:\n  i < m\n  k < i - 1\n\ngoal (1 subgoal):\n 1. k < m", "by simp"], ["proof (state)\nthis:\n  k < m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?g2 k = ?g1 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso k = fs.gs.gso k", "by (rule gs.gso_cong, insert ki kn len, auto simp: fs'_def)"], ["proof (state)\nthis:\n  gs2.gso k = fs.gs.gso k\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  ?k3 < i - 1 \\<Longrightarrow> gs2.gso ?k3 = fs.gs.gso ?k3\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note G2_G = this"], ["proof (state)\nthis:\n  ?k3 < i - 1 \\<Longrightarrow> gs2.gso ?k3 = fs.gs.gso ?k3\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have take_eq: \"take (Suc i - 1 - 1) fs' = take (Suc i - 1 - 1) fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc i - 1 - 1) fs' = take (Suc i - 1 - 1) fs", "by (intro nth_equalityI, insert len len' i swap(2-), auto intro!: fs'_fs)"], ["proof (state)\nthis:\n  take (Suc i - 1 - 1) fs' = take (Suc i - 1 - 1) fs\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have i1n: \"i - 1 < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - 1 < m", "using i"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. i - 1 < m", "by auto"], ["proof (state)\nthis:\n  i - 1 < m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?R = rat_of_int"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?RV = \"map_vec ?R\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?f1 = \"\\<lambda> i. RAT fs ! i\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?f2 = \"\\<lambda> i. RAT fs' ! i\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?n1 = \"\\<lambda> i. sq_norm (?g1 i)\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?n2 = \"\\<lambda> i. sq_norm (?g2 i)\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have heq:\"fs ! (i - 1) = fs' ! i\" \"take (i-1) fs = take (i-1) fs'\"\n           \"?f2 (i - 1) = ?f1 i\" \"?f2 i = ?f1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! (i - 1) = fs' ! i &&& take (i - 1) fs = take (i - 1) fs') &&&\n    map of_int_hom.vec_hom fs' ! (i - 1) = map of_int_hom.vec_hom fs ! i &&&\n    map of_int_hom.vec_hom fs' ! i = map of_int_hom.vec_hom fs ! (i - 1)", "unfolding fs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! (i - 1) = fs[i := fs ! (i - 1), i - 1 := fs ! i] ! i &&&\n     take (i - 1) fs =\n     take (i - 1) (fs[i := fs ! (i - 1), i - 1 := fs ! i])) &&&\n    map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) !\n    (i - 1) =\n    map of_int_hom.vec_hom fs ! i &&&\n    map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) ! i =\n    map of_int_hom.vec_hom fs ! (i - 1)", "using i len i0"], ["proof (prove)\nusing this:\n  i < m\n  length fs = m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (fs ! (i - 1) = fs[i := fs ! (i - 1), i - 1 := fs ! i] ! i &&&\n     take (i - 1) fs =\n     take (i - 1) (fs[i := fs ! (i - 1), i - 1 := fs ! i])) &&&\n    map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) !\n    (i - 1) =\n    map of_int_hom.vec_hom fs ! i &&&\n    map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) ! i =\n    map of_int_hom.vec_hom fs ! (i - 1)", "by auto"], ["proof (state)\nthis:\n  fs ! (i - 1) = fs' ! i\n  take (i - 1) fs = take (i - 1) fs'\n  map of_int_hom.vec_hom fs' ! (i - 1) = map of_int_hom.vec_hom fs ! i\n  map of_int_hom.vec_hom fs' ! i = map of_int_hom.vec_hom fs ! (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have norm_pos2: \"j < m \\<Longrightarrow> ?n2 j > 0\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < m \\<Longrightarrow> 0 < \\<parallel>gs2.gso j\\<parallel>\\<^sup>2", "using gs2.sq_norm_pos len'"], ["proof (prove)\nusing this:\n  ?j < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  0 < \\<parallel>gs2.gso ?j\\<parallel>\\<^sup>2\n  length fs' = m\n\ngoal (1 subgoal):\n 1. j < m \\<Longrightarrow> 0 < \\<parallel>gs2.gso j\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  ?j1 < m \\<Longrightarrow> 0 < \\<parallel>gs2.gso ?j1\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have norm_pos1: \"j < m \\<Longrightarrow> ?n1 j > 0\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < m \\<Longrightarrow> 0 < \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2", "using fs.gs.sq_norm_pos inv"], ["proof (prove)\nusing this:\n  ?j < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  0 < \\<parallel>fs.gs.gso ?j\\<parallel>\\<^sup>2\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. j < m \\<Longrightarrow> 0 < \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  ?j1 < m \\<Longrightarrow> 0 < \\<parallel>fs.gs.gso ?j1\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have norm_zero2: \"j < m \\<Longrightarrow> ?n2 j \\<noteq> 0\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < m \\<Longrightarrow>\n    \\<parallel>gs2.gso j\\<parallel>\\<^sup>2 \\<noteq> 0", "using norm_pos2[of j]"], ["proof (prove)\nusing this:\n  j < m \\<Longrightarrow> 0 < \\<parallel>gs2.gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. j < m \\<Longrightarrow>\n    \\<parallel>gs2.gso j\\<parallel>\\<^sup>2 \\<noteq> 0", "by linarith"], ["proof (state)\nthis:\n  ?j1 < m \\<Longrightarrow>\n  \\<parallel>gs2.gso ?j1\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have norm_zero1: \"j < m \\<Longrightarrow> ?n1 j \\<noteq> 0\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < m \\<Longrightarrow>\n    \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2 \\<noteq> 0", "using norm_pos1[of j]"], ["proof (prove)\nusing this:\n  j < m \\<Longrightarrow> 0 < \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. j < m \\<Longrightarrow>\n    \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2 \\<noteq> 0", "by linarith"], ["proof (state)\nthis:\n  ?j1 < m \\<Longrightarrow>\n  \\<parallel>fs.gs.gso ?j1\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have gs: \"\\<And> j. j < m \\<Longrightarrow> ?g1 j \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. j < m \\<Longrightarrow> fs.gs.gso j \\<in> Rn", "using inv"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. \\<And>j. j < m \\<Longrightarrow> fs.gs.gso j \\<in> Rn", "by blast"], ["proof (state)\nthis:\n  ?j1 < m \\<Longrightarrow> fs.gs.gso ?j1 \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have gs2: \"\\<And> j. j < m \\<Longrightarrow> ?g2 j \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. j < m \\<Longrightarrow> gs2.gso j \\<in> Rn", "using fs.gs.gso_carrier conn2"], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  fs.gs.gso ?i \\<in> Rn\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n\ngoal (1 subgoal):\n 1. \\<And>j. j < m \\<Longrightarrow> gs2.gso j \\<in> Rn", "by auto"], ["proof (state)\nthis:\n  ?j1 < m \\<Longrightarrow> gs2.gso ?j1 \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have g: \"\\<And> j. j < m \\<Longrightarrow> ?f1 j \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. j < m \\<Longrightarrow> map of_int_hom.vec_hom fs ! j \\<in> Rn", "using inv"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. \\<And>j. j < m \\<Longrightarrow> map of_int_hom.vec_hom fs ! j \\<in> Rn", "by auto"], ["proof (state)\nthis:\n  ?j1 < m \\<Longrightarrow> map of_int_hom.vec_hom fs ! ?j1 \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have g2: \"\\<And> j. j < m \\<Longrightarrow> ?f2 j \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. j < m \\<Longrightarrow> map of_int_hom.vec_hom fs' ! j \\<in> Rn", "using gs2.f_carrier conn2"], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  map of_int_hom.vec_hom fs' ! ?i \\<in> Rn\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n\ngoal (1 subgoal):\n 1. \\<And>j. j < m \\<Longrightarrow> map of_int_hom.vec_hom fs' ! j \\<in> Rn", "by blast"], ["proof (state)\nthis:\n  ?j1 < m \\<Longrightarrow> map of_int_hom.vec_hom fs' ! ?j1 \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?fs1 = \"?f1 ` {0..< (i - 1)}\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have G: \"?fs1 \\<subseteq> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1} \\<subseteq> Rn", "using g i"], ["proof (prove)\nusing this:\n  ?j1 < m \\<Longrightarrow> map of_int_hom.vec_hom fs ! ?j1 \\<in> Rn\n  i < m\n\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1} \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1} \\<subseteq> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?gs1 = \"?g1 ` {0..< (i - 1)}\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have G': \"?gs1 \\<subseteq> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso ` {0..<i - 1} \\<subseteq> Rn", "using gs i"], ["proof (prove)\nusing this:\n  ?j1 < m \\<Longrightarrow> fs.gs.gso ?j1 \\<in> Rn\n  i < m\n\ngoal (1 subgoal):\n 1. fs.gs.gso ` {0..<i - 1} \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  fs.gs.gso ` {0..<i - 1} \\<subseteq> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?S = \"gs.span ?fs1\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?S' = \"gs.span ?gs1\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have S'S: \"?S' = ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (fs.gs.gso ` {0..<i - 1}) =\n    gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})", "by (rule fs.gs.partial_span', insert conn1 i, auto)"], ["proof (state)\nthis:\n  gs.span (fs.gs.gso ` {0..<i - 1}) =\n  gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"gs.is_oc_projection (?g2 (i - 1)) (gs.span (?g2 ` {0..< (i - 1)})) (?f2 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.is_oc_projection (gs2.gso (i - 1)) (gs.span (gs2.gso ` {0..<i - 1}))\n     (map of_int_hom.vec_hom fs' ! (i - 1))", "using i len'"], ["proof (prove)\nusing this:\n  i < m\n  length fs' = m\n\ngoal (1 subgoal):\n 1. gs.is_oc_projection (gs2.gso (i - 1)) (gs.span (gs2.gso ` {0..<i - 1}))\n     (map of_int_hom.vec_hom fs' ! (i - 1))", "by (intro  gs2.gso_oc_projection_span(2)) auto"], ["proof (state)\nthis:\n  gs.is_oc_projection (gs2.gso (i - 1)) (gs.span (gs2.gso ` {0..<i - 1}))\n   (map of_int_hom.vec_hom fs' ! (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs.is_oc_projection (gs2.gso (i - 1)) (gs.span (gs2.gso ` {0..<i - 1}))\n   (map of_int_hom.vec_hom fs' ! (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f2 (i - 1) = ?f1 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! (i - 1) = map of_int_hom.vec_hom fs ! i", "unfolding fs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) !\n    (i - 1) =\n    map of_int_hom.vec_hom fs ! i", "using len i"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) !\n    (i - 1) =\n    map of_int_hom.vec_hom fs ! i", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! (i - 1) = map of_int_hom.vec_hom fs ! i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! (i - 1) = map of_int_hom.vec_hom fs ! i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"gs.span (?g2 ` {0 ..< (i - 1)}) = gs.span (?f2 ` {0 ..< (i - 1)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (gs2.gso ` {0..<i - 1}) =\n    gs.span ((!) (map of_int_hom.vec_hom fs') ` {0..<i - 1})", "using i len'"], ["proof (prove)\nusing this:\n  i < m\n  length fs' = m\n\ngoal (1 subgoal):\n 1. gs.span (gs2.gso ` {0..<i - 1}) =\n    gs.span ((!) (map of_int_hom.vec_hom fs') ` {0..<i - 1})", "by (intro gs2.partial_span') auto"], ["proof (state)\nthis:\n  gs.span (gs2.gso ` {0..<i - 1}) =\n  gs.span ((!) (map of_int_hom.vec_hom fs') ` {0..<i - 1})\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs.span (gs2.gso ` {0..<i - 1}) =\n  gs.span ((!) (map of_int_hom.vec_hom fs') ` {0..<i - 1})\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f2 ` {0 ..< (i - 1)} = ?fs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom fs') ` {0..<i - 1} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}", "by (rule image_cong[OF refl], insert len i, auto simp: fs'_def)"], ["proof (state)\nthis:\n  (!) (map of_int_hom.vec_hom fs') ` {0..<i - 1} =\n  (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  gs.is_oc_projection (gs2.gso (i - 1))\n   (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n   (map of_int_hom.vec_hom fs ! i)", "have claim1: \"gs.is_oc_projection (?g2 (i - 1)) ?S (?f1 i)\""], ["proof (prove)\nusing this:\n  gs.is_oc_projection (gs2.gso (i - 1))\n   (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n   (map of_int_hom.vec_hom fs ! i)\n\ngoal (1 subgoal):\n 1. gs.is_oc_projection (gs2.gso (i - 1))\n     (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n     (map of_int_hom.vec_hom fs ! i)", "."], ["proof (state)\nthis:\n  gs.is_oc_projection (gs2.gso (i - 1))\n   (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n   (map of_int_hom.vec_hom fs ! i)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have list_id: \"[0..<Suc (i - 1)] = [0..< i - 1] @ [i - 1]\" \n    \"[0..< Suc i] = [0..< i] @ [i]\" \"map f [x] = [f x]\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (i - 1)] = [0..<i - 1] @ [i - 1] &&&\n    [0..<Suc i] = [0..<i] @ [i] &&& map f [x] = [f x]", "using i"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. [0..<Suc (i - 1)] = [0..<i - 1] @ [i - 1] &&&\n    [0..<Suc i] = [0..<i] @ [i] &&& map f [x] = [f x]", "by auto"], ["proof (state)\nthis:\n  [0..<Suc (i - 1)] = [0..<i - 1] @ [i - 1]\n  [0..<Suc i] = [0..<i] @ [i]\n  map ?f2 [?x2] = [?f2 ?x2]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* f1i_sum is claim 2 *)"], ["proof (state)\nthis:\n  [0..<Suc (i - 1)] = [0..<i - 1] @ [i - 1]\n  [0..<Suc i] = [0..<i] @ [i]\n  map ?f2 [?x2] = [?f2 ?x2]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have f1i_sum: \"?f1 i = gs.sumlist (map (\\<lambda>j. ?mu1 i j \\<cdot>\\<^sub>v ?g1 j) [0 ..< i]) + ?g1 i\" (is \"_ = ?sum + _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i]) +\n    fs.gs.gso i", "apply(subst fs.gs.fi_is_sum_of_mu_gso, insert len i, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length fs = m; i < m\\<rbrakk>\n    \\<Longrightarrow> gs.M.sumlist\n                       (map (\\<lambda>j.\n                                fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n                         [0..<Suc i]) =\n                      gs.M.sumlist\n                       (map (\\<lambda>j.\n                                fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n                         [0..<i]) +\n                      fs.gs.gso i", "unfolding map_append list_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length fs = m; i < m\\<rbrakk>\n    \\<Longrightarrow> gs.M.sumlist\n                       (map (\\<lambda>j.\n                                fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n                         [0..<i] @\n                        [fs.gs.\\<mu> i i \\<cdot>\\<^sub>v fs.gs.gso i]) =\n                      gs.M.sumlist\n                       (map (\\<lambda>j.\n                                fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n                         [0..<i]) +\n                      fs.gs.gso i", "by (subst gs.M.sumlist_snoc, insert i gs conn1, auto simp: fs.gs.\\<mu>.simps)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i]) +\n  fs.gs.gso i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have f1im1_sum: \"?f1 (i - 1) = gs.sumlist (map (\\<lambda>j. ?mu1 (i - 1) j \\<cdot>\\<^sub>v ?g1 j) [0..<i - 1]) + ?g1 (i - 1)\" (is \"_ = ?sum1 + _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1]) +\n    fs.gs.gso (i - 1)", "apply(subst fs.gs.fi_is_sum_of_mu_gso, insert len i, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length fs = m; i < m\\<rbrakk>\n    \\<Longrightarrow> gs.M.sumlist\n                       (map (\\<lambda>j.\n                                fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v\n                                fs.gs.gso j)\n                         [0..<Suc (i - 1)]) =\n                      gs.M.sumlist\n                       (map (\\<lambda>j.\n                                fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v\n                                fs.gs.gso j)\n                         [0..<i - 1]) +\n                      fs.gs.gso (i - 1)", "unfolding map_append list_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length fs = m; i < m\\<rbrakk>\n    \\<Longrightarrow> gs.M.sumlist\n                       (map (\\<lambda>j.\n                                fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v\n                                fs.gs.gso j)\n                         [0..<i - 1] @\n                        [fs.gs.\\<mu> (i - 1) (i - 1) \\<cdot>\\<^sub>v\n                         fs.gs.gso (i - 1)]) =\n                      gs.M.sumlist\n                       (map (\\<lambda>j.\n                                fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v\n                                fs.gs.gso j)\n                         [0..<i - 1]) +\n                      fs.gs.gso (i - 1)", "by (subst gs.M.sumlist_snoc, insert i gs, auto simp: fs.gs.\\<mu>.simps)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1]) +\n  fs.gs.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have sum: \"?sum \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i])\n    \\<in> Rn", "by (rule gs.sumlist_carrier, insert gs i, auto)"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i])\n  \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have sum1: \"?sum1 \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1])\n    \\<in> Rn", "by (rule gs.sumlist_carrier, insert gs i, auto)"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])\n  \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from gs.span_closed[OF G]"], ["proof (chain)\npicking this:\n  ?v \\<in> gs.span\n            ((!) (map of_int_hom.vec_hom fs) `\n             {0..<i - 1}) \\<Longrightarrow>\n  ?v \\<in> Rn", "have S: \"?S \\<subseteq> Rn\""], ["proof (prove)\nusing this:\n  ?v \\<in> gs.span\n            ((!) (map of_int_hom.vec_hom fs) `\n             {0..<i - 1}) \\<Longrightarrow>\n  ?v \\<in> Rn\n\ngoal (1 subgoal):\n 1. gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}) \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}) \\<subseteq> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from gs i"], ["proof (chain)\npicking this:\n  ?j1 < m \\<Longrightarrow> fs.gs.gso ?j1 \\<in> Rn\n  i < m", "have gs': \"\\<And> j. j < i - 1 \\<Longrightarrow> ?g1 j \\<in> Rn\" and gsi: \"?g1 (i - 1) \\<in> Rn\""], ["proof (prove)\nusing this:\n  ?j1 < m \\<Longrightarrow> fs.gs.gso ?j1 \\<in> Rn\n  i < m\n\ngoal (1 subgoal):\n 1. (\\<And>j. j < i - 1 \\<Longrightarrow> fs.gs.gso j \\<in> Rn) &&&\n    fs.gs.gso (i - 1) \\<in> Rn", "by auto"], ["proof (state)\nthis:\n  ?j2 < i - 1 \\<Longrightarrow> fs.gs.gso ?j2 \\<in> Rn\n  fs.gs.gso (i - 1) \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"[0 ..< i] = [0 ..< Suc (i - 1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<i] = [0..<Suc (i - 1)]", "using i0"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [0..<i] = [0..<Suc (i - 1)]", "by simp"], ["proof (state)\nthis:\n  [0..<i] = [0..<Suc (i - 1)]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  [0..<i] = [0..<Suc (i - 1)]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = [0 ..< i - 1] @ [i - 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (i - 1)] = [0..<i - 1] @ [i - 1]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (i - 1)] = [0..<i - 1] @ [i - 1]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  [0..<i] = [0..<i - 1] @ [i - 1]", "have list: \"[0 ..< i] = [0 ..< i - 1] @ [i - 1]\""], ["proof (prove)\nusing this:\n  [0..<i] = [0..<i - 1] @ [i - 1]\n\ngoal (1 subgoal):\n 1. [0..<i] = [0..<i - 1] @ [i - 1]", "."], ["proof (state)\nthis:\n  [0..<i] = [0..<i - 1] @ [i - 1]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  [0..<i] = [0..<i - 1] @ [i - 1]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* d does not change for k \\<noteq> i *)"], ["proof (state)\nthis:\n  [0..<i] = [0..<i - 1] @ [i - 1]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "fix k"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume kn: \"k \\<le> m\" and ki: \"k \\<noteq> i\""], ["proof (state)\nthis:\n  k \\<le> m\n  k \\<noteq> i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from d_swap_unchanged[OF len i0 i ki kn fs'_def]"], ["proof (chain)\npicking this:\n  d fs k = d fs' k", "have \"d fs k = d fs' k\""], ["proof (prove)\nusing this:\n  d fs k = d fs' k\n\ngoal (1 subgoal):\n 1. d fs k = d fs' k", "by simp"], ["proof (state)\nthis:\n  d fs k = d fs' k\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 \\<le> m; ?k4 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> d fs ?k4 = d fs' ?k4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note d = this"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 \\<le> m; ?k4 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> d fs ?k4 = d fs' ?k4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* new value of g (i-1) *)"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 \\<le> m; ?k4 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> d fs ?k4 = d fs' ?k4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have g2_im1: \"?g2 (i - 1) = ?g1 i + ?mu1 i (i - 1) \\<cdot>\\<^sub>v ?g1 (i - 1)\" (is \"_ = _ + ?mu_f1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso (i - 1) =\n    fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)", "proof (rule gs.is_oc_projection_eq[OF  claim1 _ S g[OF i]])"], ["proof (state)\ngoal (1 subgoal):\n 1. gs.is_oc_projection\n     (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n     (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n     (map of_int_hom.vec_hom fs ! i)", "show \"gs.is_oc_projection (?g1 i + ?mu_f1) ?S (?f1 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.is_oc_projection\n     (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n     (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n     (map of_int_hom.vec_hom fs ! i)", "unfolding gs.is_oc_projection_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n    \\<in> Rn \\<and>\n    map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span\n           (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})) \\<and>\n    (\\<forall>u.\n        u \\<in> gs.span\n                 ((!) (map of_int_hom.vec_hom fs) `\n                  {0..<i - 1}) \\<longrightarrow>\n        (fs.gs.gso i +\n         fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n        u =\n        0)", "proof (intro conjI allI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n    \\<in> Rn\n 2. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 3. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "let ?sum' = \"gs.sumlist (map (\\<lambda>j. ?mu1 i j \\<cdot>\\<^sub>v ?g1 j) [0 ..< i - 1])\""], ["proof (state)\ngoal (3 subgoals):\n 1. fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n    \\<in> Rn\n 2. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 3. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "have sum': \"?sum' \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1])\n    \\<in> Rn", "by (rule gs.sumlist_carrier, insert gs i, auto)"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])\n  \\<in> Rn\n\ngoal (3 subgoals):\n 1. fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n    \\<in> Rn\n 2. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 3. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "show inRn: \"(?g1 i + ?mu_f1) \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n    \\<in> Rn", "using gs[OF i] gsi i"], ["proof (prove)\nusing this:\n  fs.gs.gso i \\<in> Rn\n  fs.gs.gso (i - 1) \\<in> Rn\n  i < m\n\ngoal (1 subgoal):\n 1. fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n    \\<in> Rn", "by auto"], ["proof (state)\nthis:\n  fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n  \\<in> Rn\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "have carr: \"?sum \\<in> Rn\" \"?g1 i \\<in> Rn\" \"?mu_f1 \\<in> Rn\" \"?sum' \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gs.M.sumlist\n      (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n        [0..<i])\n     \\<in> Rn &&&\n     fs.gs.gso i \\<in> Rn) &&&\n    fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1) \\<in> Rn &&&\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1])\n    \\<in> Rn", "using sum' sum gs[OF i] gsi i"], ["proof (prove)\nusing this:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])\n  \\<in> Rn\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i])\n  \\<in> Rn\n  fs.gs.gso i \\<in> Rn\n  fs.gs.gso (i - 1) \\<in> Rn\n  i < m\n\ngoal (1 subgoal):\n 1. (gs.M.sumlist\n      (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n        [0..<i])\n     \\<in> Rn &&&\n     fs.gs.gso i \\<in> Rn) &&&\n    fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1) \\<in> Rn &&&\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1])\n    \\<in> Rn", "by auto"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i])\n  \\<in> Rn\n  fs.gs.gso i \\<in> Rn\n  fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1) \\<in> Rn\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])\n  \\<in> Rn\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "have \"?f1 i - (?g1 i + ?mu_f1) = (?sum + ?g1 i) - (?g1 i + ?mu_f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i]) +\n    fs.gs.gso i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "unfolding f1i_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i]) +\n    fs.gs.gso i -\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i]) +\n    fs.gs.gso i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "by simp"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i -\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i]) +\n  fs.gs.gso i -\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i -\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i]) +\n  fs.gs.gso i -\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "have \"\\<dots> = ?sum - ?mu_f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i]) +\n    fs.gs.gso i -\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i]) -\n    fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)", "using carr"], ["proof (prove)\nusing this:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i])\n  \\<in> Rn\n  fs.gs.gso i \\<in> Rn\n  fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1) \\<in> Rn\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])\n  \\<in> Rn\n\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i]) +\n    fs.gs.gso i -\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i]) -\n    fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)", "by auto"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i]) +\n  fs.gs.gso i -\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i]) -\n  fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "also"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i]) +\n  fs.gs.gso i -\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i]) -\n  fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "have \"?sum = gs.sumlist (map (\\<lambda>j. ?mu1 i j \\<cdot>\\<^sub>v ?g1 j) [0 ..< i - 1] @ [?mu_f1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i]) =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1] @\n      [fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)])", "unfolding list"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       ([0..<i - 1] @ [i - 1])) =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1] @\n      [fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)])", "by simp"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i]) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1] @\n    [fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)])\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "also"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j) [0..<i]) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1] @\n    [fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)])\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "have \"\\<dots> = ?sum' + ?mu_f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1] @\n      [fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)]) =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1]) +\n    fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)", "by (subst gs.sumlist_append, insert gs' gsi, auto)"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1] @\n    [fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)]) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1]) +\n  fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "also"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1] @\n    [fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)]) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1]) +\n  fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "have \"\\<dots> - ?mu_f1 = ?sum'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1]) +\n    fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1) -\n    fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1) =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1])", "using sum' gsi"], ["proof (prove)\nusing this:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])\n  \\<in> Rn\n  fs.gs.gso (i - 1) \\<in> Rn\n\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1]) +\n    fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1) -\n    fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1) =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1])", "by auto"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1]) +\n  fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1) -\n  fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "finally"], ["proof (chain)\npicking this:\n  map of_int_hom.vec_hom fs ! i -\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])", "have id: \"?f1 i - (?g1 i + ?mu_f1) = ?sum'\""], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs ! i -\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1])", "."], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i -\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  gs.M.sumlist\n   (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])\n\ngoal (2 subgoals):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n 2. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "show \"?f1 i - (?g1 i + ?mu_f1) \\<in> gs.span ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i -\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n    \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))", "unfolding id gs.span_span[OF G]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1])\n    \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})", "proof (rule gs.sumlist_in_span[OF G])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>j.\n                            fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n                     [0..<i - 1]) \\<Longrightarrow>\n       x \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>j.\n                            fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n                     [0..<i - 1]) \\<Longrightarrow>\n       x \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})", "assume \"v \\<in> set (map (\\<lambda>j. ?mu1 i j \\<cdot>\\<^sub>v ?g1 j) [0 ..< i - 1])\""], ["proof (state)\nthis:\n  v \\<in> set (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n                [0..<i - 1])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>j.\n                            fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n                     [0..<i - 1]) \\<Longrightarrow>\n       x \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n                [0..<i - 1])", "obtain j where j: \"j < i - 1\" and v: \"v = ?mu1 i j \\<cdot>\\<^sub>v ?g1 j\""], ["proof (prove)\nusing this:\n  v \\<in> set (map (\\<lambda>j. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n                [0..<i - 1])\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < i - 1;\n         v = fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j < i - 1\n  v = fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>j.\n                            fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j)\n                     [0..<i - 1]) \\<Longrightarrow>\n       x \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})", "show \"v \\<in> ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})", "unfolding v"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.\\<mu> i j \\<cdot>\\<^sub>v fs.gs.gso j\n    \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})", "by (rule gs.smult_in_span[OF G], unfold S'S[symmetric], rule gs.span_mem, insert gs i j, auto)"], ["proof (state)\nthis:\n  v \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i -\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n  \\<in> gs.span (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "assume \"x \\<in> ?S\""], ["proof (state)\nthis:\n  x \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "hence x: \"x \\<in> ?S'\""], ["proof (prove)\nusing this:\n  x \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})\n\ngoal (1 subgoal):\n 1. x \\<in> gs.span (fs.gs.gso ` {0..<i - 1})", "using S'S"], ["proof (prove)\nusing this:\n  x \\<in> gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})\n  gs.span (fs.gs.gso ` {0..<i - 1}) =\n  gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})\n\ngoal (1 subgoal):\n 1. x \\<in> gs.span (fs.gs.gso ` {0..<i - 1})", "by simp"], ["proof (state)\nthis:\n  x \\<in> gs.span (fs.gs.gso ` {0..<i - 1})\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> gs.span\n                ((!) (map of_int_hom.vec_hom fs) `\n                 {0..<i - 1}) \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       u =\n       0", "show \"(?g1 i + ?mu_f1) \\<bullet> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    x =\n    0", "proof (rule gs.orthocompl_span[OF _ G' inRn x])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "assume \"x \\<in> ?gs1\""], ["proof (state)\nthis:\n  x \\<in> fs.gs.gso ` {0..<i - 1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "then"], ["proof (chain)\npicking this:\n  x \\<in> fs.gs.gso ` {0..<i - 1}", "obtain j where j: \"j < i - 1\" and x_id: \"x = ?g1 j\""], ["proof (prove)\nusing this:\n  x \\<in> fs.gs.gso ` {0..<i - 1}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < i - 1; x = fs.gs.gso j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j < i - 1\n  x = fs.gs.gso j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "from j i x_id gs[of j]"], ["proof (chain)\npicking this:\n  j < i - 1\n  i < m\n  x = fs.gs.gso j\n  j < m \\<Longrightarrow> fs.gs.gso j \\<in> Rn", "have x: \"x \\<in> Rn\""], ["proof (prove)\nusing this:\n  j < i - 1\n  i < m\n  x = fs.gs.gso j\n  j < m \\<Longrightarrow> fs.gs.gso j \\<in> Rn\n\ngoal (1 subgoal):\n 1. x \\<in> Rn", "by auto"], ["proof (state)\nthis:\n  x \\<in> Rn\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "{"], ["proof (state)\nthis:\n  x \\<in> Rn\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "assume k: \"k > j\" \"k < m\""], ["proof (state)\nthis:\n  j < k\n  k < m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "have \"?g1 k \\<bullet> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso k \\<bullet> x = 0", "unfolding x_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso k \\<bullet> fs.gs.gso j = 0", "by (rule fs.gs.orthogonal, insert conn1 k, auto)"], ["proof (state)\nthis:\n  fs.gs.gso k \\<bullet> x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>j < ?k4; ?k4 < m\\<rbrakk>\n  \\<Longrightarrow> fs.gs.gso ?k4 \\<bullet> x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "from this[of i] this[of \"i - 1\"] j i"], ["proof (chain)\npicking this:\n  \\<lbrakk>j < i; i < m\\<rbrakk>\n  \\<Longrightarrow> fs.gs.gso i \\<bullet> x = 0\n  \\<lbrakk>j < i - 1; i - 1 < m\\<rbrakk>\n  \\<Longrightarrow> fs.gs.gso (i - 1) \\<bullet> x = 0\n  j < i - 1\n  i < m", "have main: \"?g1 i \\<bullet> x = 0\" \"?g1 (i - 1) \\<bullet> x = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>j < i; i < m\\<rbrakk>\n  \\<Longrightarrow> fs.gs.gso i \\<bullet> x = 0\n  \\<lbrakk>j < i - 1; i - 1 < m\\<rbrakk>\n  \\<Longrightarrow> fs.gs.gso (i - 1) \\<bullet> x = 0\n  j < i - 1\n  i < m\n\ngoal (1 subgoal):\n 1. fs.gs.gso i \\<bullet> x = 0 &&& fs.gs.gso (i - 1) \\<bullet> x = 0", "by auto"], ["proof (state)\nthis:\n  fs.gs.gso i \\<bullet> x = 0\n  fs.gs.gso (i - 1) \\<bullet> x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "have \"(?g1 i + ?mu_f1) \\<bullet> x = ?g1 i \\<bullet> x + ?mu_f1 \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    x =\n    fs.gs.gso i \\<bullet> x +\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet> x", "by (rule add_scalar_prod_distrib[OF gs[OF i] _ x], insert gsi, auto)"], ["proof (state)\nthis:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  x =\n  fs.gs.gso i \\<bullet> x +\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "also"], ["proof (state)\nthis:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  x =\n  fs.gs.gso i \\<bullet> x +\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso i \\<bullet> x +\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet> x =\n    0", "using main"], ["proof (prove)\nusing this:\n  fs.gs.gso i \\<bullet> x = 0\n  fs.gs.gso (i - 1) \\<bullet> x = 0\n\ngoal (1 subgoal):\n 1. fs.gs.gso i \\<bullet> x +\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet> x =\n    0", "by (subst smult_scalar_prod_distrib[OF gsi x], auto)"], ["proof (state)\nthis:\n  fs.gs.gso i \\<bullet> x +\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet> x =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> fs.gs.gso ` {0..<i - 1} \\<Longrightarrow>\n       (fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n       x =\n       0", "finally"], ["proof (chain)\npicking this:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  x =\n  0", "show \"(?g1 i + ?mu_f1) \\<bullet> x = 0\""], ["proof (prove)\nusing this:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  x =\n  0\n\ngoal (1 subgoal):\n 1. (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    x =\n    0", "."], ["proof (state)\nthis:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  x =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  x =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs.is_oc_projection\n   (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n   (gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}))\n   (map of_int_hom.vec_hom fs ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs2.gso (i - 1) =\n  fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  gs2.gso (i - 1) =\n  fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* 16.13 (i): for g, only g_i and g_{i-1} can change *)"], ["proof (state)\nthis:\n  gs2.gso (i - 1) =\n  fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "fix k"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume kn: \"k < m\" \n      and ki: \"k \\<noteq> i\" \"k \\<noteq> i - 1\""], ["proof (state)\nthis:\n  k < m\n  k \\<noteq> i\n  k \\<noteq> i - 1\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?g2 k = gs.oc_projection (gs.span (?g2 ` {0..<k})) (?f2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso k =\n    gs.oc_projection (gs.span (gs2.gso ` {0..<k}))\n     (map of_int_hom.vec_hom fs' ! k)", "by (rule gs2.gso_oc_projection_span, insert kn conn2, auto)"], ["proof (state)\nthis:\n  gs2.gso k =\n  gs.oc_projection (gs.span (gs2.gso ` {0..<k}))\n   (map of_int_hom.vec_hom fs' ! k)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs2.gso k =\n  gs.oc_projection (gs.span (gs2.gso ` {0..<k}))\n   (map of_int_hom.vec_hom fs' ! k)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"gs.span (?g2 ` {0..<k}) = gs.span (?f2 ` {0..<k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (gs2.gso ` {0..<k}) =\n    gs.span ((!) (map of_int_hom.vec_hom fs') ` {0..<k})", "by (rule gs2.partial_span', insert conn2 kn, auto)"], ["proof (state)\nthis:\n  gs.span (gs2.gso ` {0..<k}) =\n  gs.span ((!) (map of_int_hom.vec_hom fs') ` {0..<k})\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs.span (gs2.gso ` {0..<k}) =\n  gs.span ((!) (map of_int_hom.vec_hom fs') ` {0..<k})\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f2 ` {0..<k} = ?f1 ` {0..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "proof(cases \"k\\<le>i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}\n 2. \\<not> k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "case True"], ["proof (state)\nthis:\n  k \\<le> i\n\ngoal (2 subgoals):\n 1. k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}\n 2. \\<not> k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "hence \"k < i - 1\""], ["proof (prove)\nusing this:\n  k \\<le> i\n\ngoal (1 subgoal):\n 1. k < i - 1", "using ki"], ["proof (prove)\nusing this:\n  k \\<le> i\n  k \\<noteq> i\n  k \\<noteq> i - 1\n\ngoal (1 subgoal):\n 1. k < i - 1", "by auto"], ["proof (state)\nthis:\n  k < i - 1\n\ngoal (2 subgoals):\n 1. k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}\n 2. \\<not> k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "then"], ["proof (chain)\npicking this:\n  k < i - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  k < i - 1\n\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "apply(intro image_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < i - 1 \\<Longrightarrow> {0..<k} = {0..<k}\n 2. \\<And>x.\n       \\<lbrakk>k < i - 1; x \\<in> {0..<k}\\<rbrakk>\n       \\<Longrightarrow> map of_int_hom.vec_hom fs' ! x =\n                         map of_int_hom.vec_hom fs ! x", "unfolding fs'_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < i - 1 \\<Longrightarrow> {0..<k} = {0..<k}\n 2. \\<And>x.\n       \\<lbrakk>k < i - 1; x \\<in> {0..<k}\\<rbrakk>\n       \\<Longrightarrow> map of_int_hom.vec_hom\n                          (fs[i := fs ! (i - 1), i - 1 := fs ! i]) !\n                         x =\n                         map of_int_hom.vec_hom fs ! x", "using len i"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n\ngoal (2 subgoals):\n 1. k < i - 1 \\<Longrightarrow> {0..<k} = {0..<k}\n 2. \\<And>x.\n       \\<lbrakk>k < i - 1; x \\<in> {0..<k}\\<rbrakk>\n       \\<Longrightarrow> map of_int_hom.vec_hom\n                          (fs[i := fs ! (i - 1), i - 1 := fs ! i]) !\n                         x =\n                         map of_int_hom.vec_hom fs ! x", "by auto"], ["proof (state)\nthis:\n  (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n  (!) (map of_int_hom.vec_hom fs) ` {0..<k}\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "case False"], ["proof (state)\nthis:\n  \\<not> k \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "have \"?f2 ` {0..<k} = Fun.swap i (i - 1) ?f1 ` {0..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    Fun.swap i (i - 1) ((!) (map of_int_hom.vec_hom fs)) ` {0..<k}", "unfolding Fun.swap_def fs'_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) `\n    {0..<k} =\n    ((!) (map of_int_hom.vec_hom fs))\n    (i := map of_int_hom.vec_hom fs ! (i - 1),\n     i - 1 := map of_int_hom.vec_hom fs ! i) `\n    {0..<k}", "using len i"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) `\n    {0..<k} =\n    ((!) (map of_int_hom.vec_hom fs))\n    (i := map of_int_hom.vec_hom fs ! (i - 1),\n     i - 1 := map of_int_hom.vec_hom fs ! i) `\n    {0..<k}", "by (intro image_cong, insert len kn, force+)"], ["proof (state)\nthis:\n  (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n  Fun.swap i (i - 1) ((!) (map of_int_hom.vec_hom fs)) ` {0..<k}\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "also"], ["proof (state)\nthis:\n  (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n  Fun.swap i (i - 1) ((!) (map of_int_hom.vec_hom fs)) ` {0..<k}\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "have \"\\<dots> = ?f1 ` {0..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap i (i - 1) ((!) (map of_int_hom.vec_hom fs)) ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "apply(rule swap_image_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i \\<in> {0..<k}\n 2. i - 1 \\<in> {0..<k}", "using False"], ["proof (prove)\nusing this:\n  \\<not> k \\<le> i\n\ngoal (2 subgoals):\n 1. i \\<in> {0..<k}\n 2. i - 1 \\<in> {0..<k}", "by auto"], ["proof (state)\nthis:\n  Fun.swap i (i - 1) ((!) (map of_int_hom.vec_hom fs)) ` {0..<k} =\n  (!) (map of_int_hom.vec_hom fs) ` {0..<k}\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> i \\<Longrightarrow>\n    (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "finally"], ["proof (chain)\npicking this:\n  (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n  (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "show ?thesis"], ["proof (prove)\nusing this:\n  (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n  (!) (map of_int_hom.vec_hom fs) ` {0..<k}\n\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<k}", "."], ["proof (state)\nthis:\n  (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n  (!) (map of_int_hom.vec_hom fs) ` {0..<k}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n  (!) (map of_int_hom.vec_hom fs) ` {0..<k}\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (!) (map of_int_hom.vec_hom fs') ` {0..<k} =\n  (!) (map of_int_hom.vec_hom fs) ` {0..<k}\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"gs.span \\<dots> = gs.span (?g1 ` {0..<k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<k}) =\n    gs.span (fs.gs.gso ` {0..<k})", "by (rule sym, rule fs.gs.partial_span', insert conn1 kn, auto)"], ["proof (state)\nthis:\n  gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<k}) =\n  gs.span (fs.gs.gso ` {0..<k})\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<k}) =\n  gs.span (fs.gs.gso ` {0..<k})\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f2 k = ?f1 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k", "using ki kn len"], ["proof (prove)\nusing this:\n  k \\<noteq> i\n  k \\<noteq> i - 1\n  k < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k", "unfolding fs'_def"], ["proof (prove)\nusing this:\n  k \\<noteq> i\n  k \\<noteq> i - 1\n  k < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) ! k =\n    map of_int_hom.vec_hom fs ! k", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! k = map of_int_hom.vec_hom fs ! k\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"gs.oc_projection (gs.span (?g1 ` {0..<k})) \\<dots> = ?g1 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.oc_projection (gs.span (fs.gs.gso ` {0..<k}))\n     (map of_int_hom.vec_hom fs ! k) =\n    fs.gs.gso k", "by (subst fs.gs.gso_oc_projection_span, insert kn conn1, auto)"], ["proof (state)\nthis:\n  gs.oc_projection (gs.span (fs.gs.gso ` {0..<k}))\n   (map of_int_hom.vec_hom fs ! k) =\n  fs.gs.gso k\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  gs2.gso k = fs.gs.gso k", "have \"?g2 k = ?g1 k\""], ["proof (prove)\nusing this:\n  gs2.gso k = fs.gs.gso k\n\ngoal (1 subgoal):\n 1. gs2.gso k = fs.gs.gso k", "."], ["proof (state)\nthis:\n  gs2.gso k = fs.gs.gso k\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < m; ?k4 \\<noteq> i; ?k4 \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.gso ?k4 = fs.gs.gso ?k4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note g2_g1_identical = this"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < m; ?k4 \\<noteq> i; ?k4 \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.gso ?k4 = fs.gs.gso ?k4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* calculation of new mu-values *)"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < m; ?k4 \\<noteq> i; ?k4 \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.gso ?k4 = fs.gs.gso ?k4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < m; ?k4 \\<noteq> i; ?k4 \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.gso ?k4 = fs.gs.gso ?k4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* no change of mu for lines before line i - 1 *)"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < m; ?k4 \\<noteq> i; ?k4 \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.gso ?k4 = fs.gs.gso ?k4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "fix jj ii"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume ii: \"ii < i - 1\""], ["proof (state)\nthis:\n  ii < i - 1\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?mu2 ii jj = ?mu1 ii jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii jj = fs.gs.\\<mu> ii jj", "using ii i len"], ["proof (prove)\nusing this:\n  ii < i - 1\n  i < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii jj = fs.gs.\\<mu> ii jj", "by (subst gs.\\<mu>_cong[of _ _ \"RAT fs\" \"RAT fs'\"], auto simp: fs'_def)"], ["proof (state)\nthis:\n  gs2.\\<mu> ii jj = fs.gs.\\<mu> ii jj\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  ?ii4 < i - 1 \\<Longrightarrow> gs2.\\<mu> ?ii4 ?jj4 = fs.gs.\\<mu> ?ii4 ?jj4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note mu'_mu_small_i = this"], ["proof (state)\nthis:\n  ?ii4 < i - 1 \\<Longrightarrow> gs2.\\<mu> ?ii4 ?jj4 = fs.gs.\\<mu> ?ii4 ?jj4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  ?ii4 < i - 1 \\<Longrightarrow> gs2.\\<mu> ?ii4 ?jj4 = fs.gs.\\<mu> ?ii4 ?jj4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* swap of mu-values in lines i - 1 and i for j < i - 1 *)"], ["proof (state)\nthis:\n  ?ii4 < i - 1 \\<Longrightarrow> gs2.\\<mu> ?ii4 ?jj4 = fs.gs.\\<mu> ?ii4 ?jj4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "fix jj"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume jj: \"jj < i - 1\""], ["proof (state)\nthis:\n  jj < i - 1\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "hence id1: \"jj < i - 1 \\<longleftrightarrow> True\" \"jj < i \\<longleftrightarrow> True\""], ["proof (prove)\nusing this:\n  jj < i - 1\n\ngoal (1 subgoal):\n 1. (jj < i - 1) = True &&& (jj < i) = True", "by auto"], ["proof (state)\nthis:\n  (jj < i - 1) = True\n  (jj < i) = True\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have id2: \"?g2 jj = ?g1 jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso jj = fs.gs.gso jj", "by (subst g2_g1_identical, insert jj i, auto)"], ["proof (state)\nthis:\n  gs2.gso jj = fs.gs.gso jj\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?mu2 i jj = ?mu1 (i - 1) jj\" \"?mu2 (i - 1) jj = ?mu1 i jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.\\<mu> i jj = fs.gs.\\<mu> (i - 1) jj &&&\n    gs2.\\<mu> (i - 1) jj = fs.gs.\\<mu> i jj", "unfolding gs2.\\<mu>.simps fs.gs.\\<mu>.simps id1 id2 if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i \\<bullet> fs.gs.gso jj /\n    \\<parallel>fs.gs.gso jj\\<parallel>\\<^sup>2 =\n    map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso jj /\n    \\<parallel>fs.gs.gso jj\\<parallel>\\<^sup>2 &&&\n    map of_int_hom.vec_hom fs' ! (i - 1) \\<bullet> fs.gs.gso jj /\n    \\<parallel>fs.gs.gso jj\\<parallel>\\<^sup>2 =\n    map of_int_hom.vec_hom fs ! i \\<bullet> fs.gs.gso jj /\n    \\<parallel>fs.gs.gso jj\\<parallel>\\<^sup>2", "using len i i0"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i \\<bullet> fs.gs.gso jj /\n    \\<parallel>fs.gs.gso jj\\<parallel>\\<^sup>2 =\n    map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso jj /\n    \\<parallel>fs.gs.gso jj\\<parallel>\\<^sup>2 &&&\n    map of_int_hom.vec_hom fs' ! (i - 1) \\<bullet> fs.gs.gso jj /\n    \\<parallel>fs.gs.gso jj\\<parallel>\\<^sup>2 =\n    map of_int_hom.vec_hom fs ! i \\<bullet> fs.gs.gso jj /\n    \\<parallel>fs.gs.gso jj\\<parallel>\\<^sup>2", "by (auto simp: fs'_def)"], ["proof (state)\nthis:\n  gs2.\\<mu> i jj = fs.gs.\\<mu> (i - 1) jj\n  gs2.\\<mu> (i - 1) jj = fs.gs.\\<mu> i jj\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  ?jj4 < i - 1 \\<Longrightarrow> gs2.\\<mu> i ?jj4 = fs.gs.\\<mu> (i - 1) ?jj4\n  ?jj4 < i - 1 \\<Longrightarrow> gs2.\\<mu> (i - 1) ?jj4 = fs.gs.\\<mu> i ?jj4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note mu'_mu_i_im1_j = this"], ["proof (state)\nthis:\n  ?jj4 < i - 1 \\<Longrightarrow> gs2.\\<mu> i ?jj4 = fs.gs.\\<mu> (i - 1) ?jj4\n  ?jj4 < i - 1 \\<Longrightarrow> gs2.\\<mu> (i - 1) ?jj4 = fs.gs.\\<mu> i ?jj4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have im1: \"i - 1 < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - 1 < m", "using i"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. i - 1 < m", "by auto"], ["proof (state)\nthis:\n  i - 1 < m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* calculation of new value of g_i *)"], ["proof (state)\nthis:\n  i - 1 < m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?g2_im1 = \"?g2 (i - 1)\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have g2_im1_Rn: \"?g2_im1 \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso (i - 1) \\<in> Rn", "using i conn2"], ["proof (prove)\nusing this:\n  i < m\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n\ngoal (1 subgoal):\n 1. gs2.gso (i - 1) \\<in> Rn", "by (auto intro!: fs.gs.gso_carrier)"], ["proof (state)\nthis:\n  gs2.gso (i - 1) \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  gs2.gso (i - 1) \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?mu2_f2 = \"\\<lambda> j. - ?mu2 i j \\<cdot>\\<^sub>v ?g2 j\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?sum = \"gs.sumlist (map (\\<lambda>j. - ?mu1 (i - 1) j \\<cdot>\\<^sub>v ?g1 j) [0 ..< i - 1])\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have mhs: \"?mu2_f2 (i - 1) \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1) \\<in> Rn", "using i conn2"], ["proof (prove)\nusing this:\n  i < m\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n\ngoal (1 subgoal):\n 1. - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1) \\<in> Rn", "by (auto intro!: fs.gs.gso_carrier)"], ["proof (state)\nthis:\n  - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1) \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have sum': \"?sum \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1])\n    \\<in> Rn", "by (rule gs.sumlist_carrier, insert gs i, auto)"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])\n  \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have gim1: \"?f1 (i - 1) \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) \\<in> Rn", "using g i"], ["proof (prove)\nusing this:\n  ?j1 < m \\<Longrightarrow> map of_int_hom.vec_hom fs ! ?j1 \\<in> Rn\n  i < m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) \\<in> Rn", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) \\<in> Rn\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?g2 i = ?f2 i + gs.sumlist (map ?mu2_f2 [0 ..< i-1] @ [?mu2_f2 (i-1)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso i =\n    map of_int_hom.vec_hom fs' ! i +\n    gs.M.sumlist\n     (map (\\<lambda>j. - gs2.\\<mu> i j \\<cdot>\\<^sub>v gs2.gso j)\n       [0..<i - 1] @\n      [- gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)])", "unfolding gs2.gso.simps[of i] list"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i +\n    gs.M.sumlist\n     (map (\\<lambda>j. - gs2.\\<mu> i j \\<cdot>\\<^sub>v gs2.gso j)\n       ([0..<i - 1] @ [i - 1])) =\n    map of_int_hom.vec_hom fs' ! i +\n    gs.M.sumlist\n     (map (\\<lambda>j. - gs2.\\<mu> i j \\<cdot>\\<^sub>v gs2.gso j)\n       [0..<i - 1] @\n      [- gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)])", "by simp"], ["proof (state)\nthis:\n  gs2.gso i =\n  map of_int_hom.vec_hom fs' ! i +\n  gs.M.sumlist\n   (map (\\<lambda>j. - gs2.\\<mu> i j \\<cdot>\\<^sub>v gs2.gso j)\n     [0..<i - 1] @\n    [- gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)])\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs2.gso i =\n  map of_int_hom.vec_hom fs' ! i +\n  gs.M.sumlist\n   (map (\\<lambda>j. - gs2.\\<mu> i j \\<cdot>\\<^sub>v gs2.gso j)\n     [0..<i - 1] @\n    [- gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)])\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f2 i = ?f1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i = map of_int_hom.vec_hom fs ! (i - 1)", "unfolding fs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) ! i =\n    map of_int_hom.vec_hom fs ! (i - 1)", "using len i i0"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) ! i =\n    map of_int_hom.vec_hom fs ! (i - 1)", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i = map of_int_hom.vec_hom fs ! (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i = map of_int_hom.vec_hom fs ! (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"map ?mu2_f2 [0 ..< i-1] = map (\\<lambda>j. - ?mu1 (i - 1) j \\<cdot>\\<^sub>v ?g1 j) [0 ..< i - 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>j. - gs2.\\<mu> i j \\<cdot>\\<^sub>v gs2.gso j)\n     [0..<i - 1] =\n    map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1]", "by (rule map_cong[OF refl], subst g2_g1_identical, insert i, auto simp: mu'_mu_i_im1_j)"], ["proof (state)\nthis:\n  map (\\<lambda>j. - gs2.\\<mu> i j \\<cdot>\\<^sub>v gs2.gso j) [0..<i - 1] =\n  map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n   [0..<i - 1]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map (\\<lambda>j. - gs2.\\<mu> i j \\<cdot>\\<^sub>v gs2.gso j) [0..<i - 1] =\n  map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n   [0..<i - 1]\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"gs.sumlist (\\<dots> @ [?mu2_f2 (i - 1)]) = ?sum + ?mu2_f2 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1] @\n      [- gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)]) =\n    gs.M.sumlist\n     (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1]) +\n    - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)", "by (subst gs.sumlist_append, insert gs i mhs, auto)"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1] @\n    [- gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)]) =\n  gs.M.sumlist\n   (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1]) +\n  - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs.M.sumlist\n   (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1] @\n    [- gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)]) =\n  gs.M.sumlist\n   (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1]) +\n  - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 (i - 1) + \\<dots> = (?f1 (i - 1) + ?sum) + ?mu2_f2 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) +\n    (gs.M.sumlist\n      (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n        [0..<i - 1]) +\n     - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)) =\n    map of_int_hom.vec_hom fs ! (i - 1) +\n    gs.M.sumlist\n     (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1]) +\n    - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)", "using gim1 sum' mhs"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs ! (i - 1) \\<in> Rn\n  gs.M.sumlist\n   (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1])\n  \\<in> Rn\n  - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1) \\<in> Rn\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) +\n    (gs.M.sumlist\n      (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n        [0..<i - 1]) +\n     - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)) =\n    map of_int_hom.vec_hom fs ! (i - 1) +\n    gs.M.sumlist\n     (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1]) +\n    - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) +\n  (gs.M.sumlist\n    (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n      [0..<i - 1]) +\n   - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)) =\n  map of_int_hom.vec_hom fs ! (i - 1) +\n  gs.M.sumlist\n   (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1]) +\n  - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) +\n  (gs.M.sumlist\n    (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n      [0..<i - 1]) +\n   - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)) =\n  map of_int_hom.vec_hom fs ! (i - 1) +\n  gs.M.sumlist\n   (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1]) +\n  - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 (i - 1) + ?sum = ?g1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) +\n    gs.M.sumlist\n     (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1]) =\n    fs.gs.gso (i - 1)", "unfolding fs.gs.gso.simps[of \"i - 1\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) +\n    gs.M.sumlist\n     (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1]) =\n    map of_int_hom.vec_hom fs ! (i - 1) +\n    gs.M.sumlist\n     (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n       [0..<i - 1])", "by simp"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) +\n  gs.M.sumlist\n   (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1]) =\n  fs.gs.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) +\n  gs.M.sumlist\n   (map (\\<lambda>j. - fs.gs.\\<mu> (i - 1) j \\<cdot>\\<^sub>v fs.gs.gso j)\n     [0..<i - 1]) =\n  fs.gs.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?mu2_f2 (i - 1) = - (?f2 i \\<bullet> ?g2_im1 / sq_norm ?g2_im1) \\<cdot>\\<^sub>v ?g2_im1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1) =\n    - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n       \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v\n    gs2.gso (i - 1)", "unfolding gs2.\\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (if i - 1 < i\n       then map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n            \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n       else if i = i - 1 then 1 else 0) \\<cdot>\\<^sub>v\n    gs2.gso (i - 1) =\n    - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n       \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v\n    gs2.gso (i - 1)", "using i0"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. - (if i - 1 < i\n       then map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n            \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n       else if i = i - 1 then 1 else 0) \\<cdot>\\<^sub>v\n    gs2.gso (i - 1) =\n    - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n       \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v\n    gs2.gso (i - 1)", "by simp"], ["proof (state)\nthis:\n  - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1) =\n  - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v\n  gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  - gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1) =\n  - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v\n  gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = - ((?f2 i \\<bullet> ?g2_im1 / sq_norm ?g2_im1) \\<cdot>\\<^sub>v ?g2_im1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n       \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v\n    gs2.gso (i - 1) =\n    - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n       \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n       gs2.gso (i - 1))", "by auto"], ["proof (state)\nthis:\n  - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v\n  gs2.gso (i - 1) =\n  - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n     gs2.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v\n  gs2.gso (i - 1) =\n  - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n     gs2.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?g1 (i - 1) + \\<dots> = ?g1 (i - 1) - ((?f2 i \\<bullet> ?g2_im1 / sq_norm ?g2_im1) \\<cdot>\\<^sub>v ?g2_im1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso (i - 1) +\n    - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n       \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n       gs2.gso (i - 1)) =\n    fs.gs.gso (i - 1) -\n    map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n    gs2.gso (i - 1)", "by (rule sym, rule minus_add_uminus_vec[of _ n], insert gsi g2_im1_Rn, auto)"], ["proof (state)\nthis:\n  fs.gs.gso (i - 1) +\n  - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n     gs2.gso (i - 1)) =\n  fs.gs.gso (i - 1) -\n  map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n  gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  fs.gs.gso (i - 1) +\n  - (map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n     gs2.gso (i - 1)) =\n  fs.gs.gso (i - 1) -\n  map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n  gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f2 i = ?f1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i = map of_int_hom.vec_hom fs ! (i - 1)", "by fact"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i = map of_int_hom.vec_hom fs ! (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  gs2.gso i =\n  fs.gs.gso (i - 1) -\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n  gs2.gso (i - 1)", "have \"?g2 i = ?g1 (i - 1) - (?f1 (i - 1) \\<bullet> ?g2 (i - 1) / sq_norm (?g2 (i - 1))) \\<cdot>\\<^sub>v ?g2 (i - 1)\""], ["proof (prove)\nusing this:\n  gs2.gso i =\n  fs.gs.gso (i - 1) -\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n  gs2.gso (i - 1)\n\ngoal (1 subgoal):\n 1. gs2.gso i =\n    fs.gs.gso (i - 1) -\n    map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n    gs2.gso (i - 1)", "."], ["proof (state)\nthis:\n  gs2.gso i =\n  fs.gs.gso (i - 1) -\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n  gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  gs2.gso i =\n  fs.gs.gso (i - 1) -\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n  gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note g2_i = this"], ["proof (state)\nthis:\n  gs2.gso i =\n  fs.gs.gso (i - 1) -\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n  gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?n1 = \"\\<lambda> i. sq_norm (?g1 i)\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "let ?n2 = \"\\<lambda> i. sq_norm (?g2 i)\""], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* calculation of new norms *)"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* norm of g (i - 1) *)"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?n2 (i - 1) = sq_norm (?g1 i + ?mu_f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n    \\<parallel>fs.gs.gso i +\n               fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v\n               fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "unfolding g2_im1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso i +\n               fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v\n               fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 =\n    \\<parallel>fs.gs.gso i +\n               fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v\n               fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v\n             fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v\n             fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = (?g1 i + ?mu_f1) \\<bullet> (?g1 i + ?mu_f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso i +\n               fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v\n               fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 =\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "by (simp add: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v\n             fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 =\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v\n             fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 =\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = (?g1 i + ?mu_f1) \\<bullet> ?g1 i + (?g1 i + ?mu_f1) \\<bullet> ?mu_f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    fs.gs.gso i +\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "by (rule scalar_prod_add_distrib, insert gs i, auto)"], ["proof (state)\nthis:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  fs.gs.gso i +\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  fs.gs.gso i +\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"(?g1 i + ?mu_f1) \\<bullet> ?g1 i = ?g1 i \\<bullet> ?g1 i + ?mu_f1 \\<bullet> ?g1 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    fs.gs.gso i =\n    fs.gs.gso i \\<bullet> fs.gs.gso i +\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    fs.gs.gso i", "by (rule add_scalar_prod_distrib, insert gs i, auto)"], ["proof (state)\nthis:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  fs.gs.gso i =\n  fs.gs.gso i \\<bullet> fs.gs.gso i +\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  fs.gs.gso i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  fs.gs.gso i =\n  fs.gs.gso i \\<bullet> fs.gs.gso i +\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  fs.gs.gso i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"(?g1 i + ?mu_f1) \\<bullet> ?mu_f1 = ?g1 i \\<bullet> ?mu_f1 + ?mu_f1 \\<bullet> ?mu_f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    fs.gs.gso i \\<bullet>\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) +\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "by (rule add_scalar_prod_distrib, insert gs i, auto)"], ["proof (state)\nthis:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  fs.gs.gso i \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) +\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (fs.gs.gso i +\n   fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  fs.gs.gso i \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) +\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?mu_f1 \\<bullet> ?g1 i = ?g1 i \\<bullet> ?mu_f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    fs.gs.gso i =\n    fs.gs.gso i \\<bullet>\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "by (rule comm_scalar_prod, insert gs i, auto)"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  fs.gs.gso i =\n  fs.gs.gso i \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  fs.gs.gso i =\n  fs.gs.gso i \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?g1 i \\<bullet> ?g1 i = sq_norm (?g1 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso i \\<bullet> fs.gs.gso i =\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2", "by (simp add: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  fs.gs.gso i \\<bullet> fs.gs.gso i =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  fs.gs.gso i \\<bullet> fs.gs.gso i =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?g1 i \\<bullet> ?mu_f1 = ?mu1 i (i - 1) * (?g1 i \\<bullet> ?g1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso i \\<bullet>\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    fs.gs.\\<mu> i (i - 1) * (fs.gs.gso i \\<bullet> fs.gs.gso (i - 1))", "by (rule scalar_prod_smult_right, insert gs[OF i] gs[OF \\<open>i - 1 < m\\<close>], auto)"], ["proof (state)\nthis:\n  fs.gs.gso i \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  fs.gs.\\<mu> i (i - 1) * (fs.gs.gso i \\<bullet> fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  fs.gs.gso i \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  fs.gs.\\<mu> i (i - 1) * (fs.gs.gso i \\<bullet> fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?g1 i \\<bullet> ?g1 (i - 1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso i \\<bullet> fs.gs.gso (i - 1) = 0", "using orthogonalD[OF fs.gs.orthogonal_gso, of i \"i - 1\"] i len i0"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length\n                (map fs.gs.gso [0..<length (map of_int_hom.vec_hom fs)]);\n   i - 1\n   < length\n      (map fs.gs.gso [0..<length (map of_int_hom.vec_hom fs)])\\<rbrakk>\n  \\<Longrightarrow> (map fs.gs.gso\n                      [0..<length (map of_int_hom.vec_hom fs)] !\n                     i \\<bullet>\n                     map fs.gs.gso\n                      [0..<length (map of_int_hom.vec_hom fs)] !\n                     (i - 1) =\n                     0) =\n                    (i \\<noteq> i - 1)\n  i < m\n  length fs = m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fs.gs.gso i \\<bullet> fs.gs.gso (i - 1) = 0", "by (auto simp: o_def)"], ["proof (state)\nthis:\n  fs.gs.gso i \\<bullet> fs.gs.gso (i - 1) = 0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  fs.gs.gso i \\<bullet> fs.gs.gso (i - 1) = 0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?mu_f1 \\<bullet> ?mu_f1 = ?mu1 i (i - 1) * (?mu_f1 \\<bullet> ?g1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    fs.gs.\\<mu> i (i - 1) *\n    ((fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n     fs.gs.gso (i - 1))", "by (rule scalar_prod_smult_right, insert gs[OF i] gs[OF \\<open>i - 1 < m\\<close>], auto)"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  fs.gs.\\<mu> i (i - 1) *\n  ((fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n   fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  fs.gs.\\<mu> i (i - 1) *\n  ((fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n   fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?mu_f1 \\<bullet> ?g1 (i - 1) = ?mu1 i (i - 1) * (?g1 (i - 1) \\<bullet> ?g1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n    fs.gs.gso (i - 1) =\n    fs.gs.\\<mu> i (i - 1) * (fs.gs.gso (i - 1) \\<bullet> fs.gs.gso (i - 1))", "by (rule scalar_prod_smult_left, insert gs[OF i] gs[OF \\<open>i - 1 < m\\<close>], auto)"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  fs.gs.gso (i - 1) =\n  fs.gs.\\<mu> i (i - 1) * (fs.gs.gso (i - 1) \\<bullet> fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) \\<bullet>\n  fs.gs.gso (i - 1) =\n  fs.gs.\\<mu> i (i - 1) * (fs.gs.gso (i - 1) \\<bullet> fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?g1 (i - 1) \\<bullet> ?g1 (i - 1) = sq_norm (?g1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso (i - 1) \\<bullet> fs.gs.gso (i - 1) =\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "by (simp add: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  fs.gs.gso (i - 1) \\<bullet> fs.gs.gso (i - 1) =\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 + fs.gs.\\<mu> i (i - 1) * 0 +\n  (fs.gs.\\<mu> i (i - 1) * 0 +\n   fs.gs.\\<mu> i (i - 1) *\n   (fs.gs.\\<mu> i (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2))", "have \"?n2 (i - 1) = ?n1 i + (?mu1 i (i - 1) * ?mu1 i (i - 1)) * ?n1 (i - 1)\""], ["proof (prove)\nusing this:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 + fs.gs.\\<mu> i (i - 1) * 0 +\n  (fs.gs.\\<mu> i (i - 1) * 0 +\n   fs.gs.\\<mu> i (i - 1) *\n   (fs.gs.\\<mu> i (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n    fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "by (simp add: ac_simps o_def)"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note sq_norm_g2_im1 = this"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from norm_pos1[OF i] norm_pos1[OF im1] norm_pos2[OF i] norm_pos2[OF im1]"], ["proof (chain)\npicking this:\n  0 < \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n  0 < \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n  0 < \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n  0 < \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "have norm0: \"?n1 i \\<noteq> 0\" \"?n1 (i - 1) \\<noteq> 0\" \"?n2 i \\<noteq> 0\" \"?n2 (i - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n  0 < \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n  0 < \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n  0 < \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<noteq> 0 &&&\n     \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0) &&&\n    \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<noteq> 0 &&&\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "hence norm0': \"?n2 (i - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0", "using i"], ["proof (prove)\nusing this:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n  i < m\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* new norm of g i *)"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have si: \"Suc i \\<le> m\" and im1: \"i - 1 \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i \\<le> m &&& i - 1 \\<le> m", "using i"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. Suc i \\<le> m &&& i - 1 \\<le> m", "by auto"], ["proof (state)\nthis:\n  Suc i \\<le> m\n  i - 1 \\<le> m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have det1: \"gs.Gramian_determinant (RAT fs) (Suc i) = (\\<Prod>j<Suc i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.d (Suc i) =\n    (\\<Prod>j<Suc i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)", "using fs.gs.Gramian_determinant si len"], ["proof (prove)\nusing this:\n  ?k \\<le> length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  fs.gs.d ?k = (\\<Prod>j<?k. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n  ?k \\<le> length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  0 < fs.gs.d ?k\n  Suc i \\<le> m\n  length fs = m\n\ngoal (1 subgoal):\n 1. fs.gs.d (Suc i) =\n    (\\<Prod>j<Suc i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  fs.gs.d (Suc i) =\n  (\\<Prod>j<Suc i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have det2: \"gs.Gramian_determinant (RAT fs') (Suc i) = (\\<Prod>j<Suc i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.d (Suc i) =\n    (\\<Prod>j<Suc i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)", "using gs2.Gramian_determinant si len'"], ["proof (prove)\nusing this:\n  ?k \\<le> length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  gs2.d ?k = (\\<Prod>j<?k. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)\n  ?k \\<le> length (map of_int_hom.vec_hom fs') \\<Longrightarrow>\n  0 < gs2.d ?k\n  Suc i \\<le> m\n  length fs' = m\n\ngoal (1 subgoal):\n 1. gs2.d (Suc i) =\n    (\\<Prod>j<Suc i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  gs2.d (Suc i) = (\\<Prod>j<Suc i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from norm_zero1[OF less_le_trans[OF _ im1]]"], ["proof (chain)\npicking this:\n  ?j1 < i - 1 \\<Longrightarrow>\n  \\<parallel>fs.gs.gso ?j1\\<parallel>\\<^sup>2 \\<noteq> 0", "have 0: \"(\\<Prod>j < i-1. ?n1 j) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ?j1 < i - 1 \\<Longrightarrow>\n  \\<parallel>fs.gs.gso ?j1\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) \\<noteq> 0", "by (subst prod_zero_iff, auto)"], ["proof (state)\nthis:\n  (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) \\<noteq> 0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"rat_of_int (d fs' (Suc i)) = rat_of_int (d fs (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc i)) = rat_of_int (d fs (Suc i))", "using d_swap_unchanged[OF len i0 i _ si fs'_def]"], ["proof (prove)\nusing this:\n  Suc i \\<noteq> i \\<Longrightarrow> d fs (Suc i) = d fs' (Suc i)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc i)) = rat_of_int (d fs (Suc i))", "by auto"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc i)) = rat_of_int (d fs (Suc i))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc i)) = rat_of_int (d fs (Suc i))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"rat_of_int (d fs' (Suc i)) = gs.Gramian_determinant (RAT fs') (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc i)) = gs2.d (Suc i)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs' (Suc i)) = gs2.d (Suc i)", "by (subst fs.of_int_Gramian_determinant[symmetric], insert conn2 i g fs', auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc i)) = gs2.d (Suc i)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc i)) = gs2.d (Suc i)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = (\\<Prod>j<Suc i. ?n2 j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.d (Suc i) =\n    (\\<Prod>j<Suc i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)", "unfolding det2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<Suc i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2) =\n    (\\<Prod>j<Suc i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)", "by (rule prod.cong, insert i, auto)"], ["proof (state)\nthis:\n  gs2.d (Suc i) = (\\<Prod>j<Suc i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs2.d (Suc i) = (\\<Prod>j<Suc i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"rat_of_int (d fs (Suc i)) = gs.Gramian_determinant (RAT fs) (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc i)) = fs.gs.d (Suc i)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs (Suc i)) = fs.gs.d (Suc i)", "by (subst fs.of_int_Gramian_determinant[symmetric], insert conn1 i g, auto)"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc i)) = fs.gs.d (Suc i)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc i)) = fs.gs.d (Suc i)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = (\\<Prod>j<Suc i. ?n1 j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.d (Suc i) =\n    (\\<Prod>j<Suc i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)", "unfolding det1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<Suc i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) =\n    (\\<Prod>j<Suc i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)", "by (rule prod.cong, insert i, auto)"], ["proof (state)\nthis:\n  fs.gs.d (Suc i) =\n  (\\<Prod>j<Suc i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  fs.gs.d (Suc i) =\n  (\\<Prod>j<Suc i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"{..<Suc i} = insert i (insert (i-1) {..<i-1})\" (is \"_ = ?set\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<Suc i} = insert i (insert (i - 1) {..<i - 1})", "by auto"], ["proof (state)\nthis:\n  {..<Suc i} = insert i (insert (i - 1) {..<i - 1})\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  {..<Suc i} = insert i (insert (i - 1) {..<i - 1})\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"(\\<Prod>j\\<in> ?set. ?n2 j) = ?n2 i * ?n2 (i - 1) * (\\<Prod>j < i-1. ?n2 j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j\\<in>insert i (insert (i - 1) {..<i - 1}).\n       \\<parallel>gs2.gso j\\<parallel>\\<^sup>2) =\n    \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 *\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n    (\\<Prod>j<i - 1. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)", "using i0"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>j\\<in>insert i (insert (i - 1) {..<i - 1}).\n       \\<parallel>gs2.gso j\\<parallel>\\<^sup>2) =\n    \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 *\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n    (\\<Prod>j<i - 1. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)", "by (subst prod.insert; (subst prod.insert)?; auto)"], ["proof (state)\nthis:\n  (\\<Prod>j\\<in>insert i (insert (i - 1) {..<i - 1}).\n     \\<parallel>gs2.gso j\\<parallel>\\<^sup>2) =\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>j<i - 1. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (\\<Prod>j\\<in>insert i (insert (i - 1) {..<i - 1}).\n     \\<parallel>gs2.gso j\\<parallel>\\<^sup>2) =\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>j<i - 1. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"(\\<Prod>j\\<in> ?set. ?n1 j) = ?n1 i * ?n1 (i - 1) * (\\<Prod>j < i-1. ?n1 j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j\\<in>insert i (insert (i - 1) {..<i - 1}).\n       \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) =\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n    (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)", "using i0"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>j\\<in>insert i (insert (i - 1) {..<i - 1}).\n       \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) =\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n    (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)", "by (subst prod.insert; (subst prod.insert)?; auto)"], ["proof (state)\nthis:\n  (\\<Prod>j\\<in>insert i (insert (i - 1) {..<i - 1}).\n     \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (\\<Prod>j\\<in>insert i (insert (i - 1) {..<i - 1}).\n     \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"(\\<Prod>j < i-1. ?n2 j) = (\\<Prod>j < i-1. ?n1 j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<i - 1. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2) =\n    (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)", "by (rule prod.cong, insert G2_G, auto)"], ["proof (state)\nthis:\n  (\\<Prod>j<i - 1. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2) =\n  (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)", "have \"?n2 i = ?n1 i * ?n1 (i - 1) / ?n2 (i - 1)\""], ["proof (prove)\nusing this:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "using 0 norm0'"], ["proof (prove)\nusing this:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n  (\\<Prod>j<i - 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) \\<noteq> 0\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note sq_norm_g2_i = this"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* mu values in rows > i do not change with j \\<notin> {i, i - 1} *)"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "fix ii j"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume ii: \"ii > i\" \"ii < m\" \n     and ji: \"j \\<noteq> i\" \"j \\<noteq> i - 1\""], ["proof (state)\nthis:\n  i < ii\n  ii < m\n  j \\<noteq> i\n  j \\<noteq> i - 1\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  i < ii\n  ii < m\n  j \\<noteq> i\n  j \\<noteq> i - 1\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume j: \"j < ii\""], ["proof (state)\nthis:\n  j < ii\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?mu2 ii j = (?f2 ii \\<bullet> ?g2 j) / sq_norm (?g2 j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii j =\n    map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso j /\n    \\<parallel>gs2.gso j\\<parallel>\\<^sup>2", "unfolding gs2.\\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < ii\n     then map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso j /\n          \\<parallel>gs2.gso j\\<parallel>\\<^sup>2\n     else if ii = j then 1 else 0) =\n    map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso j /\n    \\<parallel>gs2.gso j\\<parallel>\\<^sup>2", "using j"], ["proof (prove)\nusing this:\n  j < ii\n\ngoal (1 subgoal):\n 1. (if j < ii\n     then map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso j /\n          \\<parallel>gs2.gso j\\<parallel>\\<^sup>2\n     else if ii = j then 1 else 0) =\n    map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso j /\n    \\<parallel>gs2.gso j\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  gs2.\\<mu> ii j =\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso j /\n  \\<parallel>gs2.gso j\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs2.\\<mu> ii j =\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso j /\n  \\<parallel>gs2.gso j\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f2 ii = ?f1 ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! ii = map of_int_hom.vec_hom fs ! ii", "using ii len"], ["proof (prove)\nusing this:\n  i < ii\n  ii < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! ii = map of_int_hom.vec_hom fs ! ii", "unfolding fs'_def"], ["proof (prove)\nusing this:\n  i < ii\n  ii < m\n  length fs = m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) ! ii =\n    map of_int_hom.vec_hom fs ! ii", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! ii = map of_int_hom.vec_hom fs ! ii\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! ii = map of_int_hom.vec_hom fs ! ii\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?g2 j = ?g1 j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso j = fs.gs.gso j", "using g2_g1_identical[of j] j ii ji"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < m; j \\<noteq> i; j \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.gso j = fs.gs.gso j\n  j < ii\n  i < ii\n  ii < m\n  j \\<noteq> i\n  j \\<noteq> i - 1\n\ngoal (1 subgoal):\n 1. gs2.gso j = fs.gs.gso j", "by auto"], ["proof (state)\nthis:\n  gs2.gso j = fs.gs.gso j\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  gs2.\\<mu> ii j =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso j /\n  \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2", "have \"?mu2 ii j = ?mu1 ii j\""], ["proof (prove)\nusing this:\n  gs2.\\<mu> ii j =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso j /\n  \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii j = fs.gs.\\<mu> ii j", "unfolding fs.gs.\\<mu>.simps"], ["proof (prove)\nusing this:\n  gs2.\\<mu> ii j =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso j /\n  \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii j =\n    (if j < ii\n     then map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso j /\n          \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2\n     else if ii = j then 1 else 0)", "using j"], ["proof (prove)\nusing this:\n  gs2.\\<mu> ii j =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso j /\n  \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2\n  j < ii\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii j =\n    (if j < ii\n     then map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso j /\n          \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2\n     else if ii = j then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  gs2.\\<mu> ii j = fs.gs.\\<mu> ii j\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  j < ii \\<Longrightarrow> gs2.\\<mu> ii j = fs.gs.\\<mu> ii j\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "hence \"?mu2 ii j = ?mu1 ii j\""], ["proof (prove)\nusing this:\n  j < ii \\<Longrightarrow> gs2.\\<mu> ii j = fs.gs.\\<mu> ii j\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii j = fs.gs.\\<mu> ii j", "by (cases \"j < ii\", auto simp: gs2.\\<mu>.simps fs.gs.\\<mu>.simps)"], ["proof (state)\nthis:\n  gs2.\\<mu> ii j = fs.gs.\\<mu> ii j\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?ii4; ?ii4 < m; ?j4 \\<noteq> i; ?j4 \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?ii4 ?j4 = fs.gs.\\<mu> ?ii4 ?j4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note mu_no_change_large_row = this"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?ii4; ?ii4 < m; ?j4 \\<noteq> i; ?j4 \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?ii4 ?j4 = fs.gs.\\<mu> ?ii4 ?j4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?ii4; ?ii4 < m; ?j4 \\<noteq> i; ?j4 \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?ii4 ?j4 = fs.gs.\\<mu> ?ii4 ?j4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* the new value of mu i (i - 1) *)"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?ii4; ?ii4 < m; ?j4 \\<noteq> i; ?j4 \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?ii4 ?j4 = fs.gs.\\<mu> ?ii4 ?j4\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?mu2 i (i - 1) = (?f2 i \\<bullet> ?g2 (i - 1)) / ?n2 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.\\<mu> i (i - 1) =\n    map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "unfolding gs2.\\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i - 1 < i\n     then map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n          \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n     else if i = i - 1 then 1 else 0) =\n    map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "using i0"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if i - 1 < i\n     then map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n          \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n     else if i = i - 1 then 1 else 0) =\n    map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  gs2.\\<mu> i (i - 1) =\n  map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs2.\\<mu> i (i - 1) =\n  map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f2 i \\<bullet> ?g2 (i - 1) = ?f1 (i - 1) \\<bullet> ?g2 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) =\n    map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1)", "using len i i0"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) =\n    map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1)", "unfolding fs'_def"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) !\n    i \\<bullet>\n    gram_schmidt_fs.gso n\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]))\n     (i - 1) =\n    map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n    gram_schmidt_fs.gso n\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]))\n     (i - 1)", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = ?f1 (i - 1) \\<bullet> (?g1 i + ?mu1 i (i - 1) \\<cdot>\\<^sub>v ?g1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) =\n    map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "unfolding g2_im1"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "by simp"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = ?f1 (i - 1) \\<bullet> ?g1 i + ?f1 (i - 1) \\<bullet> (?mu1 i (i - 1) \\<cdot>\\<^sub>v ?g1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso i +\n    map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "by (rule scalar_prod_add_distrib[of _ n], insert i gs g, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso i +\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso i +\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 (i - 1) \\<bullet> ?g1 i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso i = 0", "by (subst fs.gs.fi_scalar_prod_gso, insert conn1 im1 i i0, auto simp: fs.gs.\\<mu>.simps fs.gs.\\<mu>.simps)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso i = 0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso i = 0\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 (i - 1) \\<bullet> (?mu1 i (i - 1) \\<cdot>\\<^sub>v ?g1 (i - 1)) = \n       ?mu1 i (i - 1) * (?f1 (i - 1) \\<bullet> ?g1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    fs.gs.\\<mu> i (i - 1) *\n    (map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso (i - 1))", "by (rule scalar_prod_smult_distrib, insert gs g i, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  fs.gs.\\<mu> i (i - 1) *\n  (map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  fs.gs.\\<mu> i (i - 1) *\n  (map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 (i - 1) \\<bullet> ?g1 (i - 1) = ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso (i - 1) =\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "by (subst fs.gs.fi_scalar_prod_gso, insert conn1 im1, auto simp: fs.gs.\\<mu>.simps)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> fs.gs.gso (i - 1) =\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  gs2.\\<mu> i (i - 1) =\n  (0 +\n   fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "have \"?mu2 i (i - 1) = ?mu1 i (i - 1) * ?n1 (i - 1) / ?n2 (i - 1)\""], ["proof (prove)\nusing this:\n  gs2.\\<mu> i (i - 1) =\n  (0 +\n   fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> i (i - 1) =\n    fs.gs.\\<mu> i (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "by (simp add: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  gs2.\\<mu> i (i - 1) =\n  fs.gs.\\<mu> i (i - 1) * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  gs2.\\<mu> i (i - 1) =\n  fs.gs.\\<mu> i (i - 1) * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note mu'_mu_i_im1 = this"], ["proof (state)\nthis:\n  gs2.\\<mu> i (i - 1) =\n  fs.gs.\\<mu> i (i - 1) * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  gs2.\\<mu> i (i - 1) =\n  fs.gs.\\<mu> i (i - 1) * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* the new values of mu ii (i - 1) for ii > i *)"], ["proof (state)\nthis:\n  gs2.\\<mu> i (i - 1) =\n  fs.gs.\\<mu> i (i - 1) * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "fix ii"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume iii: \"ii > i\" and ii: \"ii < m\""], ["proof (state)\nthis:\n  i < ii\n  ii < m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "hence iii1: \"i - 1 < ii\""], ["proof (prove)\nusing this:\n  i < ii\n  ii < m\n\ngoal (1 subgoal):\n 1. i - 1 < ii", "by auto"], ["proof (state)\nthis:\n  i - 1 < ii\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?mu2 ii (i - 1) = (?f2 ii \\<bullet> ?g2 (i - 1)) / ?n2 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii (i - 1) =\n    map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "unfolding gs2.\\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i - 1 < ii\n     then map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n          \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n     else if ii = i - 1 then 1 else 0) =\n    map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "using i0 iii1"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  i - 1 < ii\n\ngoal (1 subgoal):\n 1. (if i - 1 < ii\n     then map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n          \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n     else if ii = i - 1 then 1 else 0) =\n    map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  gs2.\\<mu> ii (i - 1) =\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs2.\\<mu> ii (i - 1) =\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f2 ii \\<bullet> ?g2 (i-1) = ?f1 ii \\<bullet> ?g2 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) =\n    map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1)", "using len i i0 iii ii"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n  i \\<noteq> 0\n  i < ii\n  ii < m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) =\n    map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1)", "unfolding fs'_def"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n  i \\<noteq> 0\n  i < ii\n  ii < m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) !\n    ii \\<bullet>\n    gram_schmidt_fs.gso n\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]))\n     (i - 1) =\n    map of_int_hom.vec_hom fs ! ii \\<bullet>\n    gram_schmidt_fs.gso n\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]))\n     (i - 1)", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = ?f1 ii \\<bullet> (?g1 i + ?mu1 i (i - 1) \\<cdot>\\<^sub>v ?g1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) =\n    map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "unfolding g2_im1"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "by simp"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = ?f1 ii \\<bullet> ?g1 i + ?f1 ii \\<bullet> (?mu1 i (i - 1) \\<cdot>\\<^sub>v ?g1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (fs.gs.gso i +\n     fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso i +\n    map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))", "by (rule scalar_prod_add_distrib[of _ n], insert i ii gs g, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso i +\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.gso i + fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso i +\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 ii \\<bullet> ?g1 i = ?mu1 ii i * ?n1 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso i =\n    fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2", "by (rule fs.gs.fi_scalar_prod_gso, insert conn1 ii i, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso i =\n  fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso i =\n  fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 ii \\<bullet> (?mu1 i (i - 1) \\<cdot>\\<^sub>v ?g1 (i - 1)) = \n       ?mu1 i (i - 1) * (?f1 ii \\<bullet> ?g1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n    fs.gs.\\<mu> i (i - 1) *\n    (map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso (i - 1))", "by (rule scalar_prod_smult_distrib, insert gs g i ii, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  fs.gs.\\<mu> i (i - 1) *\n  (map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)) =\n  fs.gs.\\<mu> i (i - 1) *\n  (map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 ii \\<bullet> ?g1 (i - 1) = ?mu1 ii (i - 1) * ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso (i - 1) =\n    fs.gs.\\<mu> ii (i - 1) * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "by (rule fs.gs.fi_scalar_prod_gso, insert conn1 ii im1, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso (i - 1) =\n  fs.gs.\\<mu> ii (i - 1) * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  gs2.\\<mu> ii (i - 1) =\n  (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n   fs.gs.\\<mu> i (i - 1) *\n   (fs.gs.\\<mu> ii (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "have \"?mu2 ii (i - 1) = ?mu1 ii (i - 1) * ?mu2 i (i - 1) + ?mu1 ii i * ?n1 i / ?n2 (i - 1)\""], ["proof (prove)\nusing this:\n  gs2.\\<mu> ii (i - 1) =\n  (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n   fs.gs.\\<mu> i (i - 1) *\n   (fs.gs.\\<mu> ii (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii (i - 1) =\n    fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n    fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "unfolding mu'_mu_i_im1"], ["proof (prove)\nusing this:\n  gs2.\\<mu> ii (i - 1) =\n  (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n   fs.gs.\\<mu> i (i - 1) *\n   (fs.gs.\\<mu> ii (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii (i - 1) =\n    fs.gs.\\<mu> ii (i - 1) *\n    (fs.gs.\\<mu> i (i - 1) *\n     \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) +\n    fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "using norm0"], ["proof (prove)\nusing this:\n  gs2.\\<mu> ii (i - 1) =\n  (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n   fs.gs.\\<mu> i (i - 1) *\n   (fs.gs.\\<mu> ii (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii (i - 1) =\n    fs.gs.\\<mu> ii (i - 1) *\n    (fs.gs.\\<mu> i (i - 1) *\n     \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) +\n    fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  gs2.\\<mu> ii (i - 1) =\n  fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n  fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?ii4; ?ii4 < m\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?ii4 (i - 1) =\n                    fs.gs.\\<mu> ?ii4 (i - 1) * gs2.\\<mu> i (i - 1) +\n                    fs.gs.\\<mu> ?ii4 i *\n                    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n                    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note mu'_mu_large_row_im1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?ii4; ?ii4 < m\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?ii4 (i - 1) =\n                    fs.gs.\\<mu> ?ii4 (i - 1) * gs2.\\<mu> i (i - 1) +\n                    fs.gs.\\<mu> ?ii4 i *\n                    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n                    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?ii4; ?ii4 < m\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?ii4 (i - 1) =\n                    fs.gs.\\<mu> ?ii4 (i - 1) * gs2.\\<mu> i (i - 1) +\n                    fs.gs.\\<mu> ?ii4 i *\n                    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n                    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* the new values of mu ii i for ii > i *)"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?ii4; ?ii4 < m\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?ii4 (i - 1) =\n                    fs.gs.\\<mu> ?ii4 (i - 1) * gs2.\\<mu> i (i - 1) +\n                    fs.gs.\\<mu> ?ii4 i *\n                    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n                    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "fix ii"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume iii: \"ii > i\" and ii: \"ii < m\""], ["proof (state)\nthis:\n  i < ii\n  ii < m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?mu2 ii i = (?f2 ii \\<bullet> ?g2 i) / ?n2 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii i =\n    map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso i /\n    \\<parallel>gs2.gso i\\<parallel>\\<^sup>2", "unfolding gs2.\\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < ii\n     then map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso i /\n          \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n     else if ii = i then 1 else 0) =\n    map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso i /\n    \\<parallel>gs2.gso i\\<parallel>\\<^sup>2", "using i0 iii"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  i < ii\n\ngoal (1 subgoal):\n 1. (if i < ii\n     then map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso i /\n          \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n     else if ii = i then 1 else 0) =\n    map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso i /\n    \\<parallel>gs2.gso i\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  gs2.\\<mu> ii i =\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso i /\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs2.\\<mu> ii i =\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso i /\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f2 ii \\<bullet> ?g2 i = ?f1 ii \\<bullet> ?g2 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso i =\n    map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso i", "using len i i0 iii ii"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n  i \\<noteq> 0\n  i < ii\n  ii < m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso i =\n    map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso i", "unfolding fs'_def"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n  i \\<noteq> 0\n  i < ii\n  ii < m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) !\n    ii \\<bullet>\n    gram_schmidt_fs.gso n\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) i =\n    map of_int_hom.vec_hom fs ! ii \\<bullet>\n    gram_schmidt_fs.gso n\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) i", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso i =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso i =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = ?f1 ii \\<bullet> (?g1 (i - 1) - (?f1 (i - 1) \\<bullet> ?g2 (i - 1) / ?n2 (i - 1)) \\<cdot>\\<^sub>v ?g2 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso i =\n    map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (fs.gs.gso (i - 1) -\n     map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n     gs2.gso (i - 1))", "unfolding g2_i"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (fs.gs.gso (i - 1) -\n     map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n     gs2.gso (i - 1)) =\n    map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (fs.gs.gso (i - 1) -\n     map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n     gs2.gso (i - 1))", "by simp"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso i =\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.gso (i - 1) -\n   map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n   gs2.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso i =\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.gso (i - 1) -\n   map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n   gs2.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 (i - 1) = ?f2 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) = map of_int_hom.vec_hom fs' ! i", "using i i0 len"], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n  length fs = m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) = map of_int_hom.vec_hom fs' ! i", "unfolding fs'_def"], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n  length fs = m\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) =\n    map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) ! i", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) = map of_int_hom.vec_hom fs' ! i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) = map of_int_hom.vec_hom fs' ! i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f2 i \\<bullet> ?g2 (i - 1) / ?n2 (i - 1) = ?mu2 i (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n    gs2.\\<mu> i (i - 1)", "unfolding gs2.\\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n    (if i - 1 < i\n     then map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n          \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n     else if i = i - 1 then 1 else 0)", "using i i0"], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n    (if i - 1 < i\n     then map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n          \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n     else if i = i - 1 then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  gs2.\\<mu> i (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! i \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  gs2.\\<mu> i (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 ii \\<bullet> (?g1 (i - 1) - ?mu2 i (i - 1) \\<cdot>\\<^sub>v ?g2 (i - 1))\n       = ?f1 ii \\<bullet> ?g1 (i - 1) - ?f1 ii \\<bullet> (?mu2 i (i - 1) \\<cdot>\\<^sub>v ?g2 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (fs.gs.gso (i - 1) -\n     gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)) =\n    map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso (i - 1) -\n    map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1))", "by (rule scalar_prod_minus_distrib[OF g gs], insert gs2 ii i, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.gso (i - 1) -\n   gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)) =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso (i - 1) -\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (fs.gs.gso (i - 1) -\n   gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)) =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso (i - 1) -\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 ii \\<bullet> ?g1 (i - 1) = ?mu1 ii (i - 1) * ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso (i - 1) =\n    fs.gs.\\<mu> ii (i - 1) * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "by (rule fs.gs.fi_scalar_prod_gso, insert conn1 ii im1, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso (i - 1) =\n  fs.gs.\\<mu> ii (i - 1) * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> fs.gs.gso (i - 1) =\n  fs.gs.\\<mu> ii (i - 1) * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 ii \\<bullet> (?mu2 i (i - 1) \\<cdot>\\<^sub>v ?g2 (i - 1)) = \n       ?mu2 i (i - 1) * (?f1 ii \\<bullet> ?g2 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet>\n    (gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)) =\n    gs2.\\<mu> i (i - 1) *\n    (map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1))", "by (rule scalar_prod_smult_distrib, insert gs gs2 g i ii, auto)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)) =\n  gs2.\\<mu> i (i - 1) *\n  (map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet>\n  (gs2.\\<mu> i (i - 1) \\<cdot>\\<^sub>v gs2.gso (i - 1)) =\n  gs2.\\<mu> i (i - 1) *\n  (map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1))\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 ii \\<bullet> ?g2 (i - 1) = (?f1 ii \\<bullet> ?g2 (i - 1) / ?n2 (i - 1)) * ?n2 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) =\n    map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "using norm0"], ["proof (prove)\nusing this:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) =\n    map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?f1 ii \\<bullet> ?g2 (i - 1) = ?f2 ii \\<bullet> ?g2 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) =\n    map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1)", "using len ii iii"], ["proof (prove)\nusing this:\n  length fs = m\n  ii < m\n  i < ii\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) =\n    map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1)", "unfolding fs'_def"], ["proof (prove)\nusing this:\n  length fs = m\n  ii < m\n  i < ii\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! ii \\<bullet>\n    gram_schmidt_fs.gso n\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]))\n     (i - 1) =\n    map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) !\n    ii \\<bullet>\n    gram_schmidt_fs.gso n\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]))\n     (i - 1)", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! ii \\<bullet> gs2.gso (i - 1) =\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> / ?n2 (i - 1) = ?mu2 ii (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n    gs2.\\<mu> ii (i - 1)", "unfolding gs2.\\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n    (if i - 1 < ii\n     then map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n          \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n     else if ii = i - 1 then 1 else 0)", "using iii"], ["proof (prove)\nusing this:\n  i < ii\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n    (if i - 1 < ii\n     then map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n          \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n     else if ii = i - 1 then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs' ! ii \\<bullet> gs2.gso (i - 1) /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  gs2.\\<mu> ii (i - 1)\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  gs2.\\<mu> ii i =\n  (fs.gs.\\<mu> ii (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 -\n   gs2.\\<mu> i (i - 1) *\n   (gs2.\\<mu> ii (i - 1) * \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2)) /\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2", "have \"?mu2 ii i = \n       (?mu1 ii (i - 1) * ?n1 (i - 1) - ?mu2 i (i - 1) * ?mu2 ii (i - 1) * ?n2 (i - 1)) / ?n2 i\""], ["proof (prove)\nusing this:\n  gs2.\\<mu> ii i =\n  (fs.gs.\\<mu> ii (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 -\n   gs2.\\<mu> i (i - 1) *\n   (gs2.\\<mu> ii (i - 1) * \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2)) /\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii i =\n    (fs.gs.\\<mu> ii (i - 1) *\n     \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 -\n     gs2.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1) *\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) /\n    \\<parallel>gs2.gso i\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  gs2.\\<mu> ii i =\n  (fs.gs.\\<mu> ii (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 -\n   gs2.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1) *\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) /\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  gs2.\\<mu> ii i =\n  (fs.gs.\\<mu> ii (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 -\n   gs2.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1) *\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) /\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = (?mu1 ii (i - 1) - ?mu1 i (i - 1) * ?mu2 ii (i - 1)) * ?n2 (i - 1) / ?n1 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> ii (i - 1) *\n     \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 -\n     gs2.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1) *\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) /\n    \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n    (fs.gs.\\<mu> ii (i - 1) -\n     fs.gs.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1)) *\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2", "unfolding sq_norm_g2_i mu'_mu_i_im1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> ii (i - 1) *\n     \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 -\n     fs.gs.\\<mu> i (i - 1) *\n     \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n     gs2.\\<mu> ii (i - 1) *\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) /\n    (\\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n     \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) =\n    (fs.gs.\\<mu> ii (i - 1) -\n     fs.gs.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1)) *\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2", "using norm0"], ["proof (prove)\nusing this:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> ii (i - 1) *\n     \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 -\n     fs.gs.\\<mu> i (i - 1) *\n     \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n     gs2.\\<mu> ii (i - 1) *\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) /\n    (\\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n     \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) =\n    (fs.gs.\\<mu> ii (i - 1) -\n     fs.gs.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1)) *\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> ii (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 -\n   gs2.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1) *\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) /\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n  (fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1)) *\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> ii (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 -\n   gs2.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1) *\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) /\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n  (fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1)) *\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = (?mu1 ii (i - 1) * ?n2 (i - 1) - \n      ?mu1 i (i - 1) * ((?mu1 ii i * ?n1 i + ?mu1 i (i - 1) * ?mu1 ii (i - 1) * ?n1 (i - 1)))) / ?n1 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> ii (i - 1) -\n     fs.gs.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1)) *\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 =\n    (fs.gs.\\<mu> ii (i - 1) *\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 -\n     fs.gs.\\<mu> i (i - 1) *\n     (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n      fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii (i - 1) *\n      \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2", "unfolding mu'_mu_large_row_im1[OF iii ii] mu'_mu_i_im1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> ii (i - 1) -\n     fs.gs.\\<mu> i (i - 1) *\n     (fs.gs.\\<mu> ii (i - 1) *\n      (fs.gs.\\<mu> i (i - 1) *\n       \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n       \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) +\n      fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n      \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2)) *\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 =\n    (fs.gs.\\<mu> ii (i - 1) *\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 -\n     fs.gs.\\<mu> i (i - 1) *\n     (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n      fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii (i - 1) *\n      \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2", "using norm0"], ["proof (prove)\nusing this:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> ii (i - 1) -\n     fs.gs.\\<mu> i (i - 1) *\n     (fs.gs.\\<mu> ii (i - 1) *\n      (fs.gs.\\<mu> i (i - 1) *\n       \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n       \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2) +\n      fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n      \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2)) *\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 =\n    (fs.gs.\\<mu> ii (i - 1) *\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 -\n     fs.gs.\\<mu> i (i - 1) *\n     (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n      fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii (i - 1) *\n      \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1)) *\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 =\n  (fs.gs.\\<mu> ii (i - 1) * \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 -\n   fs.gs.\\<mu> i (i - 1) *\n   (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n    fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * gs2.\\<mu> ii (i - 1)) *\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 =\n  (fs.gs.\\<mu> ii (i - 1) * \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 -\n   fs.gs.\\<mu> i (i - 1) *\n   (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n    fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = ?mu1 ii (i - 1) - ?mu1 i (i - 1) * ?mu1 ii i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> ii (i - 1) *\n     \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 -\n     fs.gs.\\<mu> i (i - 1) *\n     (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n      fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii (i - 1) *\n      \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 =\n    fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i", "unfolding sq_norm_g2_im1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> ii (i - 1) *\n     (\\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n      fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n      \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2) -\n     fs.gs.\\<mu> i (i - 1) *\n     (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n      fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii (i - 1) *\n      \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 =\n    fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i", "using norm0"], ["proof (prove)\nusing this:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> ii (i - 1) *\n     (\\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n      fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n      \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2) -\n     fs.gs.\\<mu> i (i - 1) *\n     (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n      fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii (i - 1) *\n      \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 =\n    fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> ii (i - 1) * \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 -\n   fs.gs.\\<mu> i (i - 1) *\n   (fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n    fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)) /\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 =\n  fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  gs2.\\<mu> ii i =\n  fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i", "have \"?mu2 ii i = ?mu1 ii (i - 1) - ?mu1 i (i - 1) * ?mu1 ii i\""], ["proof (prove)\nusing this:\n  gs2.\\<mu> ii i =\n  fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> ii i =\n    fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i", "."], ["proof (state)\nthis:\n  gs2.\\<mu> ii i =\n  fs.gs.\\<mu> ii (i - 1) - fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?ii4; ?ii4 < m\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?ii4 i =\n                    fs.gs.\\<mu> ?ii4 (i - 1) -\n                    fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ?ii4 i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note mu'_mu_large_row_i = this"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?ii4; ?ii4 < m\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?ii4 i =\n                    fs.gs.\\<mu> ?ii4 (i - 1) -\n                    fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ?ii4 i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?ii4; ?ii4 < m\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?ii4 i =\n                    fs.gs.\\<mu> ?ii4 (i - 1) -\n                    fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ?ii4 i\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "fix k"], ["proof (state)\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume k: \"k < m\""], ["proof (state)\nthis:\n  k < m\n\ngoal (7 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       gs2.gso k =\n       (if k = i - 1\n        then fs.gs.gso i +\n             fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n        else if k = i\n             then fs.gs.gso (i - 1) -\n                  map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n                  gs2.gso (i - 1) /\n                  \\<parallel>gs2.gso\n                              (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n                  gs2.gso (i - 1)\n             else fs.gs.gso k)\n 5. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 6. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 7. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "show \"?g2 k = ?newg k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso k =\n    (if k = i - 1\n     then fs.gs.gso i +\n          fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n     else if k = i\n          then fs.gs.gso (i - 1) -\n               map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n               gs2.gso (i - 1) /\n               \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n               gs2.gso (i - 1)\n          else fs.gs.gso k)", "unfolding g2_i[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso k =\n    (if k = i - 1\n     then fs.gs.gso i +\n          fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n     else if k = i then gs2.gso i else fs.gs.gso k)", "unfolding g2_im1[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso k =\n    (if k = i - 1 then gs2.gso (i - 1)\n     else if k = i then gs2.gso i else fs.gs.gso k)", "using g2_g1_identical[OF k]"], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<noteq> i; k \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.gso k = fs.gs.gso k\n\ngoal (1 subgoal):\n 1. gs2.gso k =\n    (if k = i - 1 then gs2.gso (i - 1)\n     else if k = i then gs2.gso i else fs.gs.gso k)", "by auto"], ["proof (state)\nthis:\n  gs2.gso k =\n  (if k = i - 1\n   then fs.gs.gso i +\n        fs.gs.\\<mu> i (i - 1) \\<cdot>\\<^sub>v fs.gs.gso (i - 1)\n   else if k = i\n        then fs.gs.gso (i - 1) -\n             map of_int_hom.vec_hom fs ! (i - 1) \\<bullet> gs2.gso (i - 1) /\n             \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n             gs2.gso (i - 1)\n        else fs.gs.gso k)\n\ngoal (6 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n       (if k = i - 1\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n             fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n        else if k = i\n             then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n 5. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 6. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "show \"?n2 k = ?new_norm k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n    (if k = i - 1\n     then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n          fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n          \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n     else if k = i\n          then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n               \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n               \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n          else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)", "unfolding sq_norm_g2_i[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n    (if k = i - 1\n     then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n          fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n          \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n     else if k = i then \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n          else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)", "unfolding sq_norm_g2_im1[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n    (if k = i - 1 then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n     else if k = i then \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n          else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)", "using g2_g1_identical[OF k]"], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<noteq> i; k \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.gso k = fs.gs.gso k\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n    (if k = i - 1 then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n     else if k = i then \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n          else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n  (if k = i - 1\n   then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n        fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n        \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n   else if k = i\n        then \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 *\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n        else \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2)\n\ngoal (5 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 5. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "fix j"], ["proof (state)\ngoal (5 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 5. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume jk: \"j < k\""], ["proof (state)\nthis:\n  j < k\n\ngoal (5 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 5. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "hence j: \"j < m\""], ["proof (prove)\nusing this:\n  j < k\n\ngoal (1 subgoal):\n 1. j < m", "using k"], ["proof (prove)\nusing this:\n  j < k\n  k < m\n\ngoal (1 subgoal):\n 1. j < m", "by auto"], ["proof (state)\nthis:\n  j < m\n\ngoal (5 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 5. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"k < i - 1 \\<or> k = i - 1 \\<or> k = i \\<or> k > i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < i - 1 \\<or> k = i - 1 \\<or> k = i \\<or> i < k", "by linarith"], ["proof (state)\nthis:\n  k < i - 1 \\<or> k = i - 1 \\<or> k = i \\<or> i < k\n\ngoal (5 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii j.\n       \\<lbrakk>ii < m; j < ii\\<rbrakk>\n       \\<Longrightarrow> gs2.\\<mu> ii j =\n                         (if ii = i - 1 then fs.gs.\\<mu> i j\n                          else if ii = i\n                               then if j = i - 1\n                                    then fs.gs.\\<mu> i (i - 1) *\n   \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> (i - 1) j\n                               else if i < ii \\<and> j = i\n                                    then fs.gs.\\<mu> ii (i - 1) -\n   fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> ii i\n                                    else if i < ii \\<and> j = i - 1\n   then fs.gs.\\<mu> ii (i - 1) * gs2.\\<mu> i (i - 1) +\n        fs.gs.\\<mu> ii i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n        \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n   else fs.gs.\\<mu> ii j)\n 5. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "thus \"?mu2 k j = ?new_mu k j\""], ["proof (prove)\nusing this:\n  k < i - 1 \\<or> k = i - 1 \\<or> k = i \\<or> i < k\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> k j =\n    (if k = i - 1 then fs.gs.\\<mu> i j\n     else if k = i\n          then if j = i - 1\n               then fs.gs.\\<mu> i (i - 1) *\n                    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n               else fs.gs.\\<mu> (i - 1) j\n          else if i < k \\<and> j = i\n               then fs.gs.\\<mu> k (i - 1) -\n                    fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> k i\n               else if i < k \\<and> j = i - 1\n                    then fs.gs.\\<mu> k (i - 1) * gs2.\\<mu> i (i - 1) +\n                         fs.gs.\\<mu> k i *\n                         \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n                         \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                    else fs.gs.\\<mu> k j)", "unfolding mu'_mu_i_im1[symmetric]"], ["proof (prove)\nusing this:\n  k < i - 1 \\<or> k = i - 1 \\<or> k = i \\<or> i < k\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> k j =\n    (if k = i - 1 then fs.gs.\\<mu> i j\n     else if k = i\n          then if j = i - 1 then gs2.\\<mu> i (i - 1)\n               else fs.gs.\\<mu> (i - 1) j\n          else if i < k \\<and> j = i\n               then fs.gs.\\<mu> k (i - 1) -\n                    fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> k i\n               else if i < k \\<and> j = i - 1\n                    then fs.gs.\\<mu> k (i - 1) * gs2.\\<mu> i (i - 1) +\n                         fs.gs.\\<mu> k i *\n                         \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n                         \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                    else fs.gs.\\<mu> k j)", "using\n        mu'_mu_large_row_i[OF _ k]\n        mu'_mu_large_row_im1 [OF _ k]\n        mu_no_change_large_row[OF _ k, of j]\n        mu'_mu_small_i\n        mu'_mu_i_im1_j jk j k"], ["proof (prove)\nusing this:\n  k < i - 1 \\<or> k = i - 1 \\<or> k = i \\<or> i < k\n  i < k \\<Longrightarrow>\n  gs2.\\<mu> k i =\n  fs.gs.\\<mu> k (i - 1) - fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> k i\n  i < k \\<Longrightarrow>\n  gs2.\\<mu> k (i - 1) =\n  fs.gs.\\<mu> k (i - 1) * gs2.\\<mu> i (i - 1) +\n  fs.gs.\\<mu> k i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<lbrakk>i < k; j \\<noteq> i; j \\<noteq> i - 1\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> k j = fs.gs.\\<mu> k j\n  ?ii4 < i - 1 \\<Longrightarrow> gs2.\\<mu> ?ii4 ?jj4 = fs.gs.\\<mu> ?ii4 ?jj4\n  ?jj4 < i - 1 \\<Longrightarrow> gs2.\\<mu> i ?jj4 = fs.gs.\\<mu> (i - 1) ?jj4\n  ?jj4 < i - 1 \\<Longrightarrow> gs2.\\<mu> (i - 1) ?jj4 = fs.gs.\\<mu> i ?jj4\n  j < k\n  j < m\n  k < m\n\ngoal (1 subgoal):\n 1. gs2.\\<mu> k j =\n    (if k = i - 1 then fs.gs.\\<mu> i j\n     else if k = i\n          then if j = i - 1 then gs2.\\<mu> i (i - 1)\n               else fs.gs.\\<mu> (i - 1) j\n          else if i < k \\<and> j = i\n               then fs.gs.\\<mu> k (i - 1) -\n                    fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> k i\n               else if i < k \\<and> j = i - 1\n                    then fs.gs.\\<mu> k (i - 1) * gs2.\\<mu> i (i - 1) +\n                         fs.gs.\\<mu> k i *\n                         \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n                         \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                    else fs.gs.\\<mu> k j)", "by auto"], ["proof (state)\nthis:\n  gs2.\\<mu> k j =\n  (if k = i - 1 then fs.gs.\\<mu> i j\n   else if k = i\n        then if j = i - 1\n             then fs.gs.\\<mu> i (i - 1) *\n                  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n             else fs.gs.\\<mu> (i - 1) j\n        else if i < k \\<and> j = i\n             then fs.gs.\\<mu> k (i - 1) -\n                  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> k i\n             else if i < k \\<and> j = i - 1\n                  then fs.gs.\\<mu> k (i - 1) * gs2.\\<mu> i (i - 1) +\n                       fs.gs.\\<mu> k i *\n                       \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n                       \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                  else fs.gs.\\<mu> k j)\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < m; ?j4 < ?k4\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?k4 ?j4 =\n                    (if ?k4 = i - 1 then fs.gs.\\<mu> i ?j4\n                     else if ?k4 = i\n                          then if ?j4 = i - 1\n                               then fs.gs.\\<mu> i (i - 1) *\n                                    \\<parallel>fs.gs.gso\n          (i - 1)\\<parallel>\\<^sup>2 /\n                                    \\<parallel>gs2.gso\n          (i - 1)\\<parallel>\\<^sup>2\n                               else fs.gs.\\<mu> (i - 1) ?j4\n                          else if i < ?k4 \\<and> ?j4 = i\n                               then fs.gs.\\<mu> ?k4 (i - 1) -\n                                    fs.gs.\\<mu> i (i - 1) *\n                                    fs.gs.\\<mu> ?k4 i\n                               else if i < ?k4 \\<and> ?j4 = i - 1\n                                    then fs.gs.\\<mu> ?k4 (i - 1) *\n   gs2.\\<mu> i (i - 1) +\n   fs.gs.\\<mu> ?k4 i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> ?k4 ?j4)\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note new_g = this"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < m; ?j4 < ?k4\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?k4 ?j4 =\n                    (if ?k4 = i - 1 then fs.gs.\\<mu> i ?j4\n                     else if ?k4 = i\n                          then if ?j4 = i - 1\n                               then fs.gs.\\<mu> i (i - 1) *\n                                    \\<parallel>fs.gs.gso\n          (i - 1)\\<parallel>\\<^sup>2 /\n                                    \\<parallel>gs2.gso\n          (i - 1)\\<parallel>\\<^sup>2\n                               else fs.gs.\\<mu> (i - 1) ?j4\n                          else if i < ?k4 \\<and> ?j4 = i\n                               then fs.gs.\\<mu> ?k4 (i - 1) -\n                                    fs.gs.\\<mu> i (i - 1) *\n                                    fs.gs.\\<mu> ?k4 i\n                               else if i < ?k4 \\<and> ?j4 = i - 1\n                                    then fs.gs.\\<mu> ?k4 (i - 1) *\n   gs2.\\<mu> i (i - 1) +\n   fs.gs.\\<mu> ?k4 i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> ?k4 ?j4)\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < m; ?j4 < ?k4\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?k4 ?j4 =\n                    (if ?k4 = i - 1 then fs.gs.\\<mu> i ?j4\n                     else if ?k4 = i\n                          then if ?j4 = i - 1\n                               then fs.gs.\\<mu> i (i - 1) *\n                                    \\<parallel>fs.gs.gso\n          (i - 1)\\<parallel>\\<^sup>2 /\n                                    \\<parallel>gs2.gso\n          (i - 1)\\<parallel>\\<^sup>2\n                               else fs.gs.\\<mu> (i - 1) ?j4\n                          else if i < ?k4 \\<and> ?j4 = i\n                               then fs.gs.\\<mu> ?k4 (i - 1) -\n                                    fs.gs.\\<mu> i (i - 1) *\n                                    fs.gs.\\<mu> ?k4 i\n                               else if i < ?k4 \\<and> ?j4 = i - 1\n                                    then fs.gs.\\<mu> ?k4 (i - 1) *\n   gs2.\\<mu> i (i - 1) +\n   fs.gs.\\<mu> ?k4 i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> ?k4 ?j4)\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* 16.13 (ii) : norm of g (i - 1) decreases by reduction factor *)"], ["proof (state)\nthis:\n  \\<lbrakk>?k4 < m; ?j4 < ?k4\\<rbrakk>\n  \\<Longrightarrow> gs2.\\<mu> ?k4 ?j4 =\n                    (if ?k4 = i - 1 then fs.gs.\\<mu> i ?j4\n                     else if ?k4 = i\n                          then if ?j4 = i - 1\n                               then fs.gs.\\<mu> i (i - 1) *\n                                    \\<parallel>fs.gs.gso\n          (i - 1)\\<parallel>\\<^sup>2 /\n                                    \\<parallel>gs2.gso\n          (i - 1)\\<parallel>\\<^sup>2\n                               else fs.gs.\\<mu> (i - 1) ?j4\n                          else if i < ?k4 \\<and> ?j4 = i\n                               then fs.gs.\\<mu> ?k4 (i - 1) -\n                                    fs.gs.\\<mu> i (i - 1) *\n                                    fs.gs.\\<mu> ?k4 i\n                               else if i < ?k4 \\<and> ?j4 = i - 1\n                                    then fs.gs.\\<mu> ?k4 (i - 1) *\n   gs2.\\<mu> i (i - 1) +\n   fs.gs.\\<mu> ?k4 i * \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 /\n   \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n                                    else fs.gs.\\<mu> ?k4 ?j4)\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note sq_norm_g2_im1"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"?n1 i + (?mu1 i (i - 1) * ?mu1 i (i - 1)) * ?n1 (i - 1)\n      < 1/\\<alpha> * (?n1 (i - 1)) + (1/2 * 1/2) * (?n1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n    fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n    < 1 / \\<alpha> * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 +\n      1 / 2 * 1 / 2 * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "proof (rule add_less_le_mono[OF _ mult_mono])"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n    < 1 / \\<alpha> * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n 2. fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) \\<le> 1 / 2 * 1 / 2\n 3. \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n 4. 0 \\<le> 1 / 2 * 1 / 2\n 5. 0 \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "from norm_ineq[unfolded mult.commute[of \\<alpha>],\n          THEN linordered_field_class.mult_imp_less_div_pos[OF \\<alpha>0(1)]]"], ["proof (chain)\npicking this:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n  < \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 / \\<alpha>", "show \"?n1 i < 1/\\<alpha> * ?n1 (i - 1)\""], ["proof (prove)\nusing this:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n  < \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 / \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n    < 1 / \\<alpha> * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "using len i"], ["proof (prove)\nusing this:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n  < \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 / \\<alpha>\n  length fs = m\n  i < m\n\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n    < 1 / \\<alpha> * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n  < 1 / \\<alpha> * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (4 subgoals):\n 1. fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) \\<le> 1 / 2 * 1 / 2\n 2. \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n 3. 0 \\<le> 1 / 2 * 1 / 2\n 4. 0 \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "from m12"], ["proof (chain)\npicking this:\n  \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2", "have abs: \"abs (?mu1 i (i - 1)) \\<le> 1/2\""], ["proof (prove)\nusing this:\n  \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> inverse 2\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> \\<le> 1 / 2\n\ngoal (4 subgoals):\n 1. fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) \\<le> 1 / 2 * 1 / 2\n 2. \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n 3. 0 \\<le> 1 / 2 * 1 / 2\n 4. 0 \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "have \"?mu1 i (i - 1) * ?mu1 i (i - 1) \\<le> abs (?mu1 i (i - 1)) * abs (?mu1 i (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1)\n    \\<le> \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> *\n          \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar>", "by auto"], ["proof (state)\nthis:\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1)\n  \\<le> \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> *\n        \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar>\n\ngoal (4 subgoals):\n 1. fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) \\<le> 1 / 2 * 1 / 2\n 2. \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n 3. 0 \\<le> 1 / 2 * 1 / 2\n 4. 0 \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1)\n  \\<le> \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> *\n        \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar>\n\ngoal (4 subgoals):\n 1. fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) \\<le> 1 / 2 * 1 / 2\n 2. \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n 3. 0 \\<le> 1 / 2 * 1 / 2\n 4. 0 \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "have \"\\<dots> \\<le> 1/2 * 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> * \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar>\n    \\<le> 1 / 2 * 1 / 2", "using mult_mono[OF abs abs]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1 / 2; 0 \\<le> \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar>\\<rbrakk>\n  \\<Longrightarrow> \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> *\n                    \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar>\n                    \\<le> 1 / 2 * (1 / 2)\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> * \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar>\n    \\<le> 1 / 2 * 1 / 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar> * \\<bar>fs.gs.\\<mu> i (i - 1)\\<bar>\n  \\<le> 1 / 2 * 1 / 2\n\ngoal (4 subgoals):\n 1. fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) \\<le> 1 / 2 * 1 / 2\n 2. \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n 3. 0 \\<le> 1 / 2 * 1 / 2\n 4. 0 \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) \\<le> 1 / 2 * 1 / 2", "show \"?mu1 i (i - 1) * ?mu1 i (i - 1) \\<le> 1/2 * 1/2\""], ["proof (prove)\nusing this:\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) \\<le> 1 / 2 * 1 / 2\n\ngoal (1 subgoal):\n 1. fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) \\<le> 1 / 2 * 1 / 2", "by auto"], ["proof (state)\nthis:\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) \\<le> 1 / 2 * 1 / 2\n\ngoal (3 subgoals):\n 1. \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n 2. 0 \\<le> 1 / 2 * 1 / 2\n 3. 0 \\<le> \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "qed auto"], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n  < 1 / \\<alpha> * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 +\n    1 / 2 * 1 / 2 * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 +\n  fs.gs.\\<mu> i (i - 1) * fs.gs.\\<mu> i (i - 1) *\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n  < 1 / \\<alpha> * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 +\n    1 / 2 * 1 / 2 * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = reduction * sq_norm (?g1 (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / \\<alpha> * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 +\n    1 / 2 * 1 / 2 * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 =\n    reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "unfolding reduction_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / \\<alpha> * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 +\n    1 / 2 * 1 / 2 * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 =\n    (4 + \\<alpha>) / (4 * \\<alpha>) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "using \\<alpha>0"], ["proof (prove)\nusing this:\n  0 < \\<alpha>\n  \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 / \\<alpha> * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 +\n    1 / 2 * 1 / 2 * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 =\n    (4 + \\<alpha>) / (4 * \\<alpha>) *\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "by (simp add: ring_distribs add_divide_distrib)"], ["proof (state)\nthis:\n  1 / \\<alpha> * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 +\n  1 / 2 * 1 / 2 * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 =\n  reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  < reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "have \"?n2 (i - 1) < reduction * ?n1 (i - 1)\""], ["proof (prove)\nusing this:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  < reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n    < reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "."], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  < reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  < reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note g_reduction = this"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  < reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* Lemma 16.13 (ii) *)"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  < reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have lin_indpt_list_fs': \"gs.lin_indpt_list (RAT fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs')", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map of_int_hom.vec_hom fs') \\<subseteq> Rn \\<and>\n    distinct (map of_int_hom.vec_hom fs') \\<and>\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs'))", "using conn2"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn\n  length (map of_int_hom.vec_hom fs') = m\n  distinct (map of_int_hom.vec_hom fs')\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n\ngoal (1 subgoal):\n 1. set (map of_int_hom.vec_hom fs') \\<subseteq> Rn \\<and>\n    distinct (map of_int_hom.vec_hom fs') \\<and>\n    gs.lin_indpt (set (map of_int_hom.vec_hom fs'))", "by auto"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* stay reduced *)"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "assume \"LLL_invariant False i fs\""], ["proof (state)\nthis:\n  LLL_invariant False i fs\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note inv = LLL_invD[OF this]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs.gs.reduced \\<alpha> i\n  False \\<or> \\<mu>_small fs i\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from inv"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs.gs.reduced \\<alpha> i\n  False \\<or> \\<mu>_small fs i", "have \"weakly_reduced fs i\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs.gs.reduced \\<alpha> i\n  False \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. fs.gs.weakly_reduced \\<alpha> i", "by auto"], ["proof (state)\nthis:\n  fs.gs.weakly_reduced \\<alpha> i\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "hence \"weakly_reduced fs (i - 1)\""], ["proof (prove)\nusing this:\n  fs.gs.weakly_reduced \\<alpha> i\n\ngoal (1 subgoal):\n 1. fs.gs.weakly_reduced \\<alpha> (i - 1)", "unfolding gram_schmidt_fs.weakly_reduced_def"], ["proof (prove)\nusing this:\n  \\<forall>ia.\n     Suc ia < i \\<longrightarrow>\n     \\<parallel>fs.gs.gso ia\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>fs.gs.gso (Suc ia)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<forall>ia.\n       Suc ia < i - 1 \\<longrightarrow>\n       \\<parallel>fs.gs.gso ia\\<parallel>\\<^sup>2\n       \\<le> \\<alpha> * \\<parallel>fs.gs.gso (Suc ia)\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  fs.gs.weakly_reduced \\<alpha> (i - 1)\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "hence red: \"weakly_reduced fs' (i - 1)\""], ["proof (prove)\nusing this:\n  fs.gs.weakly_reduced \\<alpha> (i - 1)\n\ngoal (1 subgoal):\n 1. gs2.weakly_reduced \\<alpha> (i - 1)", "unfolding gram_schmidt_fs.weakly_reduced_def"], ["proof (prove)\nusing this:\n  \\<forall>ia.\n     Suc ia < i - 1 \\<longrightarrow>\n     \\<parallel>fs.gs.gso ia\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>fs.gs.gso (Suc ia)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<forall>ia.\n       Suc ia < i - 1 \\<longrightarrow>\n       \\<parallel>gs2.gso ia\\<parallel>\\<^sup>2\n       \\<le> \\<alpha> * \\<parallel>gs2.gso (Suc ia)\\<parallel>\\<^sup>2", "using i G2_G"], ["proof (prove)\nusing this:\n  \\<forall>ia.\n     Suc ia < i - 1 \\<longrightarrow>\n     \\<parallel>fs.gs.gso ia\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>fs.gs.gso (Suc ia)\\<parallel>\\<^sup>2\n  i < m\n  ?k3 < i - 1 \\<Longrightarrow> gs2.gso ?k3 = fs.gs.gso ?k3\n\ngoal (1 subgoal):\n 1. \\<forall>ia.\n       Suc ia < i - 1 \\<longrightarrow>\n       \\<parallel>gs2.gso ia\\<parallel>\\<^sup>2\n       \\<le> \\<alpha> * \\<parallel>gs2.gso (Suc ia)\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  gs2.weakly_reduced \\<alpha> (i - 1)\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from inv"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs.gs.reduced \\<alpha> i\n  False \\<or> \\<mu>_small fs i", "have sred: \"reduced fs i\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs.gs.reduced \\<alpha> i\n  False \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. fs.gs.reduced \\<alpha> i", "by auto"], ["proof (state)\nthis:\n  fs.gs.reduced \\<alpha> i\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have sred: \"reduced fs' (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.reduced \\<alpha> (i - 1)", "unfolding gram_schmidt_fs.reduced_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.weakly_reduced \\<alpha> (i - 1) \\<and>\n    (\\<forall>ia j.\n        ia < i - 1 \\<longrightarrow>\n        j < ia \\<longrightarrow> \\<bar>gs2.\\<mu> ia j\\<bar> \\<le> 1 / 2)", "proof (intro conjI[OF red] allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < i - 1; j < ia\\<rbrakk>\n       \\<Longrightarrow> \\<bar>gs2.\\<mu> ia j\\<bar> \\<le> 1 / 2", "case (1 i' j)"], ["proof (state)\nthis:\n  i' < i - 1\n  j < i'\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < i - 1; j < ia\\<rbrakk>\n       \\<Longrightarrow> \\<bar>gs2.\\<mu> ia j\\<bar> \\<le> 1 / 2", "with sred"], ["proof (chain)\npicking this:\n  fs.gs.reduced \\<alpha> i\n  i' < i - 1\n  j < i'", "have \"\\<bar>?mu1 i' j\\<bar> \\<le> 1 / 2\""], ["proof (prove)\nusing this:\n  fs.gs.reduced \\<alpha> i\n  i' < i - 1\n  j < i'\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i' j\\<bar> \\<le> 1 / 2", "unfolding gram_schmidt_fs.reduced_def"], ["proof (prove)\nusing this:\n  fs.gs.weakly_reduced \\<alpha> i \\<and>\n  (\\<forall>ia j.\n      ia < i \\<longrightarrow>\n      j < ia \\<longrightarrow> \\<bar>fs.gs.\\<mu> ia j\\<bar> \\<le> 1 / 2)\n  i' < i - 1\n  j < i'\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i' j\\<bar> \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>fs.gs.\\<mu> i' j\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < i - 1; j < ia\\<rbrakk>\n       \\<Longrightarrow> \\<bar>gs2.\\<mu> ia j\\<bar> \\<le> 1 / 2", "thus ?case"], ["proof (prove)\nusing this:\n  \\<bar>fs.gs.\\<mu> i' j\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<bar>gs2.\\<mu> i' j\\<bar> \\<le> 1 / 2", "using mu'_mu_small_i[OF 1(1)]"], ["proof (prove)\nusing this:\n  \\<bar>fs.gs.\\<mu> i' j\\<bar> \\<le> 1 / 2\n  gs2.\\<mu> i' ?jj4 = fs.gs.\\<mu> i' ?jj4\n\ngoal (1 subgoal):\n 1. \\<bar>gs2.\\<mu> i' j\\<bar> \\<le> 1 / 2", "by simp"], ["proof (state)\nthis:\n  \\<bar>gs2.\\<mu> i' j\\<bar> \\<le> 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs2.reduced \\<alpha> (i - 1)\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have mu_small: \"\\<mu>_small fs' (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>_small fs' (i - 1)", "unfolding \\<mu>_small_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<i - 1. \\<bar>gs2.\\<mu> (i - 1) j\\<bar> \\<le> 1 / 2", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < i - 1 \\<Longrightarrow>\n       \\<bar>gs2.\\<mu> (i - 1) j\\<bar> \\<le> 1 / 2", "case (1 j)"], ["proof (state)\nthis:\n  j < i - 1\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < i - 1 \\<Longrightarrow>\n       \\<bar>gs2.\\<mu> (i - 1) j\\<bar> \\<le> 1 / 2", "thus ?case"], ["proof (prove)\nusing this:\n  j < i - 1\n\ngoal (1 subgoal):\n 1. \\<bar>gs2.\\<mu> (i - 1) j\\<bar> \\<le> 1 / 2", "using inv(11)"], ["proof (prove)\nusing this:\n  j < i - 1\n  False \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. \\<bar>gs2.\\<mu> (i - 1) j\\<bar> \\<le> 1 / 2", "unfolding mu'_mu_i_im1_j[OF 1] \\<mu>_small_def"], ["proof (prove)\nusing this:\n  j < i - 1\n  False \\<or> (\\<forall>j<i. \\<bar>fs.gs.\\<mu> i j\\<bar> \\<le> 1 / 2)\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar> \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>gs2.\\<mu> (i - 1) j\\<bar> \\<le> 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<mu>_small fs' (i - 1)\n\ngoal (4 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_invariant False i fs \\<Longrightarrow>\n    LLL_invariant False (i - 1) fs'\n 3. LLL_measure (i - 1) fs' < LLL_measure i fs\n 4. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "show \"LLL_invariant False (i - 1) fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant False (i - 1) fs'", "by (rule LLL_invI, insert lin_indpt_list_fs' conn2 mu_small span' lattice fs' sred i, auto)"], ["proof (state)\nthis:\n  LLL_invariant False (i - 1) fs'\n\ngoal (3 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_measure (i - 1) fs' < LLL_measure i fs\n 3. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  LLL_invariant False i fs \\<Longrightarrow> LLL_invariant False (i - 1) fs'\n\ngoal (3 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_measure (i - 1) fs' < LLL_measure i fs\n 3. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* invariant is established *)"], ["proof (state)\nthis:\n  LLL_invariant False i fs \\<Longrightarrow> LLL_invariant False (i - 1) fs'\n\ngoal (3 subgoals):\n 1. LLL_invariant_weak fs'\n 2. LLL_measure (i - 1) fs' < LLL_measure i fs\n 3. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "show newInvw: \"LLL_invariant_weak fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant_weak fs'", "by (rule LLL_inv_wI, insert lin_indpt_list_fs' conn2 span' lattice fs', auto)"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* show decrease in measure *)"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "{"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "(* 16.16 (ii), the decreasing case *)"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have ile: \"i \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> m", "using i"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. i \\<le> m", "by auto"], ["proof (state)\nthis:\n  i \\<le> m\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "from Gd[OF newInvw, folded d_def, OF ile]"], ["proof (chain)\npicking this:\n  rat_of_int (d fs' i) =\n  (\\<Prod>j<i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)", "have \"?R (d fs' i) = (\\<Prod>j<i. ?n2 j )\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs' i) =\n  (\\<Prod>j<i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs' i) =\n    (\\<Prod>j<i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  rat_of_int (d fs' i) =\n  (\\<Prod>j<i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs' i) =\n  (\\<Prod>j<i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = prod ?n2 ({0 ..< i-1} \\<union> {i - 1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2) =\n    (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n       \\<parallel>gs2.gso i\\<parallel>\\<^sup>2)", "by (rule sym, rule prod.cong, (insert i0, auto)[1], insert i, auto)"], ["proof (state)\nthis:\n  (\\<Prod>j<i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2) =\n  (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n     \\<parallel>gs2.gso i\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (\\<Prod>j<i. \\<parallel>gs2.gso j\\<parallel>\\<^sup>2) =\n  (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n     \\<parallel>gs2.gso i\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = ?n2 (i - 1) * prod ?n2 ({0 ..< i-1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n       \\<parallel>gs2.gso i\\<parallel>\\<^sup>2) =\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n    (\\<Prod>i = 0..<i - 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n     \\<parallel>gs2.gso i\\<parallel>\\<^sup>2) =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>i = 0..<i - 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n     \\<parallel>gs2.gso i\\<parallel>\\<^sup>2) =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (\\<Prod>i = 0..<i - 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"prod ?n2 ({0 ..< i-1}) = prod ?n1 ({0 ..< i-1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<i - 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2) =\n    (\\<Prod>i = 0..<i - 1. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2)", "by (rule prod.cong[OF refl], subst g2_g1_identical, insert i, auto)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<i - 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2) =\n  (\\<Prod>i = 0..<i - 1. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<i - 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2) =\n  (\\<Prod>i = 0..<i - 1. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = (prod ?n1 ({0 ..< i-1} \\<union> {i - 1})) / ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<i - 1. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) =\n    (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n       \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) /\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2", "by (subst prod.union_disjoint, insert norm_pos1[OF im1], auto)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<i - 1. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) =\n  (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n     \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) /\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<i - 1. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) =\n  (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n     \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) /\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"prod ?n1 ({0 ..< i-1} \\<union> {i - 1}) = prod ?n1 {0..<i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n       \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) =\n    (\\<Prod>i = 0..<i. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2)", "by (rule arg_cong[of _ _ \"prod ?n1\"], insert i0, auto)"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n     \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) =\n  (\\<Prod>i = 0..<i. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<i - 1} \\<union> {i - 1}.\n     \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) =\n  (\\<Prod>i = 0..<i. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = (\\<Prod>j<i. ?n1 j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<i. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) =\n    (\\<Prod>j<i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)", "by (rule prod.cong, insert i0, auto)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<i. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) =\n  (\\<Prod>j<i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<i. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2) =\n  (\\<Prod>j<i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = ?R (d fs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) =\n    rat_of_int (d fs i)", "unfolding d_def Gd[OF Linvw ile]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) =\n    (\\<Prod>j<i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)", "by (rule prod.cong[OF refl], insert i, auto)"], ["proof (state)\nthis:\n  (\\<Prod>j<i. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) =\n  rat_of_int (d fs i)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (d fs' i) =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (rat_of_int (d fs i) / \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)", "have new_di: \"?R (d fs' i) = ?n2 (i - 1) / ?n1 (i - 1) * ?R (d fs i)\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs' i) =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 *\n  (rat_of_int (d fs i) / \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs' i) =\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs i)", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs' i) =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs i)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs' i) =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs i)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> < (reduction * ?n1 (i - 1)) / ?n1 (i - 1) * ?R (d fs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs i)\n    < reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n      \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n      rat_of_int (d fs i)", "by (rule mult_strict_right_mono[OF divide_strict_right_mono[OF g_reduction norm_pos1[OF im1]]],\n        insert LLL_d_pos[OF Linvw] i, auto)"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs i)\n  < reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs i)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "also"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs i)\n  < reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs i)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "have \"\\<dots> = reduction * ?R (d fs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs i) =\n    reduction * rat_of_int (d fs i)", "using norm_pos1[OF im1]"], ["proof (prove)\nusing this:\n  0 < \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs i) =\n    reduction * rat_of_int (d fs i)", "by auto"], ["proof (state)\nthis:\n  reduction * \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs i) =\n  reduction * rat_of_int (d fs i)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (d fs' i) < reduction * rat_of_int (d fs i)", "have \"d fs' i < real_of_rat reduction * d fs i\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs' i) < reduction * rat_of_int (d fs i)\n\ngoal (1 subgoal):\n 1. real_of_int (d fs' i) < real_of_rat reduction * real_of_int (d fs i)", "using of_rat_less of_rat_mult of_rat_of_int_eq"], ["proof (prove)\nusing this:\n  rat_of_int (d fs' i) < reduction * rat_of_int (d fs i)\n  (of_rat ?r < of_rat ?s) = (?r < ?s)\n  of_rat (?a * ?b) = of_rat ?a * of_rat ?b\n  of_rat (rat_of_int ?z) = of_int ?z\n\ngoal (1 subgoal):\n 1. real_of_int (d fs' i) < real_of_rat reduction * real_of_int (d fs i)", "by metis"], ["proof (state)\nthis:\n  real_of_int (d fs' i) < real_of_rat reduction * real_of_int (d fs i)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note this new_di"], ["proof (state)\nthis:\n  real_of_int (d fs' i) < real_of_rat reduction * real_of_int (d fs i)\n  rat_of_int (d fs' i) =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs i)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "}"], ["proof (state)\nthis:\n  real_of_int (d fs' i) < real_of_rat reduction * real_of_int (d fs i)\n  rat_of_int (d fs' i) =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs i)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "note d_i = this"], ["proof (state)\nthis:\n  real_of_int (d fs' i) < real_of_rat reduction * real_of_int (d fs i)\n  rat_of_int (d fs' i) =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs i)\n\ngoal (2 subgoals):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs\n 2. \\<And>ii.\n       ii \\<le> m \\<Longrightarrow>\n       rat_of_int (d fs' ii) =\n       (if ii = i\n        then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n             rat_of_int (d fs i)\n        else rat_of_int (d fs ii))", "show \"ii \\<le> m \\<Longrightarrow> ?R (d fs' ii) = (if ii = i then ?n2 (i - 1) / ?n1 (i - 1) * ?R (d fs i) else ?R (d fs ii))\" \n    for ii"], ["proof (prove)\ngoal (1 subgoal):\n 1. ii \\<le> m \\<Longrightarrow>\n    rat_of_int (d fs' ii) =\n    (if ii = i\n     then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n          \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n          rat_of_int (d fs i)\n     else rat_of_int (d fs ii))", "using d_i d"], ["proof (prove)\nusing this:\n  real_of_int (d fs' i) < real_of_rat reduction * real_of_int (d fs i)\n  rat_of_int (d fs' i) =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs i)\n  \\<lbrakk>?k4 \\<le> m; ?k4 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> d fs ?k4 = d fs' ?k4\n\ngoal (1 subgoal):\n 1. ii \\<le> m \\<Longrightarrow>\n    rat_of_int (d fs' ii) =\n    (if ii = i\n     then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n          \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n          rat_of_int (d fs i)\n     else rat_of_int (d fs ii))", "by auto"], ["proof (state)\nthis:\n  ?ii2 \\<le> m \\<Longrightarrow>\n  rat_of_int (d fs' ?ii2) =\n  (if ?ii2 = i\n   then \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 /\n        \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n        rat_of_int (d fs i)\n   else rat_of_int (d fs ?ii2))\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have pos: \"k < m \\<Longrightarrow> 0 < d fs' k\" \"k < m \\<Longrightarrow> 0 \\<le> d fs' k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k < m \\<Longrightarrow> 0 < d fs' k) &&&\n    (k < m \\<Longrightarrow> 0 \\<le> d fs' k)", "using LLL_d_pos[OF newInvw, of k]"], ["proof (prove)\nusing this:\n  k \\<le> m \\<Longrightarrow> 0 < d fs' k\n\ngoal (1 subgoal):\n 1. (k < m \\<Longrightarrow> 0 < d fs' k) &&&\n    (k < m \\<Longrightarrow> 0 \\<le> d fs' k)", "by auto"], ["proof (state)\nthis:\n  ?k2 < m \\<Longrightarrow> 0 < d fs' ?k2\n  ?k2 < m \\<Longrightarrow> 0 \\<le> d fs' ?k2\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have prodpos:\"0< (\\<Prod>i<m. d fs' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < prod (d fs') {..<m}", "apply (rule prod_pos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{..<m}. 0 < d fs' a", "using LLL_d_pos[OF newInvw]"], ["proof (prove)\nusing this:\n  ?k \\<le> m \\<Longrightarrow> 0 < d fs' ?k\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{..<m}. 0 < d fs' a", "by auto"], ["proof (state)\nthis:\n  0 < prod (d fs') {..<m}\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have prod_pos':\"0 < (\\<Prod>x\\<in>{0..<m} - {i}. real_of_int (d fs' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Prod>x\\<in>{0..<m} - {i}. real_of_int (d fs' x))", "apply (rule prod_pos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{0..<m} - {i}. 0 < real_of_int (d fs' a)", "using LLL_d_pos[OF newInvw] pos"], ["proof (prove)\nusing this:\n  ?k \\<le> m \\<Longrightarrow> 0 < d fs' ?k\n  ?k2 < m \\<Longrightarrow> 0 < d fs' ?k2\n  ?k2 < m \\<Longrightarrow> 0 \\<le> d fs' ?k2\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{0..<m} - {i}. 0 < real_of_int (d fs' a)", "by auto"], ["proof (state)\nthis:\n  0 < (\\<Prod>x\\<in>{0..<m} - {i}. real_of_int (d fs' x))\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have prod_nonneg:\"0 \\<le> (\\<Prod>x\\<in>{0..<m} - {i}. real_of_int (d fs' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Prod>x\\<in>{0..<m} - {i}. real_of_int (d fs' x))", "apply (rule prod_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{0..<m} - {i}. 0 \\<le> real_of_int (d fs' a)", "using LLL_d_pos[OF newInvw] pos"], ["proof (prove)\nusing this:\n  ?k \\<le> m \\<Longrightarrow> 0 < d fs' ?k\n  ?k2 < m \\<Longrightarrow> 0 < d fs' ?k2\n  ?k2 < m \\<Longrightarrow> 0 \\<le> d fs' ?k2\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{0..<m} - {i}. 0 \\<le> real_of_int (d fs' a)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (\\<Prod>x\\<in>{0..<m} - {i}. real_of_int (d fs' x))\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have prodpos2:\"0<(\\<Prod>ia<m. d fs ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < prod (d fs) {..<m}", "apply (rule prod_pos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{..<m}. 0 < d fs a", "using LLL_d_pos[OF Linvw]"], ["proof (prove)\nusing this:\n  ?k \\<le> m \\<Longrightarrow> 0 < d fs ?k\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>{..<m}. 0 < d fs a", "by auto"], ["proof (state)\nthis:\n  0 < prod (d fs) {..<m}\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have \"D fs' = real_of_int (\\<Prod>i<m. d fs' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (D fs') = real_of_int (prod (d fs') {..<m})", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (nat (prod (d fs') {..<m})) = real_of_int (prod (d fs') {..<m})", "using prodpos"], ["proof (prove)\nusing this:\n  0 < prod (d fs') {..<m}\n\ngoal (1 subgoal):\n 1. real (nat (prod (d fs') {..<m})) = real_of_int (prod (d fs') {..<m})", "by simp"], ["proof (state)\nthis:\n  real (D fs') = real_of_int (prod (d fs') {..<m})\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "also"], ["proof (state)\nthis:\n  real (D fs') = real_of_int (prod (d fs') {..<m})\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have \"(\\<Prod>i<m. d fs' i) = (\\<Prod> j \\<in> {0 ..< m} - {i} \\<union> {i}. d fs' j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (d fs') {..<m} = prod (d fs') ({0..<m} - {i} \\<union> {i})", "by (rule prod.cong, insert i, auto)"], ["proof (state)\nthis:\n  prod (d fs') {..<m} = prod (d fs') ({0..<m} - {i} \\<union> {i})\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "also"], ["proof (state)\nthis:\n  prod (d fs') {..<m} = prod (d fs') ({0..<m} - {i} \\<union> {i})\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have \"real_of_int \\<dots> = real_of_int (\\<Prod> j \\<in> {0 ..< m} - {i}. d fs' j) * real_of_int (d fs' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (prod (d fs') ({0..<m} - {i} \\<union> {i})) =\n    real_of_int (prod (d fs') ({0..<m} - {i})) * real_of_int (d fs' i)", "by (subst prod.union_disjoint, auto)"], ["proof (state)\nthis:\n  real_of_int (prod (d fs') ({0..<m} - {i} \\<union> {i})) =\n  real_of_int (prod (d fs') ({0..<m} - {i})) * real_of_int (d fs' i)\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "also"], ["proof (state)\nthis:\n  real_of_int (prod (d fs') ({0..<m} - {i} \\<union> {i})) =\n  real_of_int (prod (d fs') ({0..<m} - {i})) * real_of_int (d fs' i)\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have \"\\<dots> < (\\<Prod> j \\<in> {0 ..< m} - {i}. d fs' j) * (of_rat reduction * d fs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (prod (d fs') ({0..<m} - {i})) * real_of_int (d fs' i)\n    < real_of_int (prod (d fs') ({0..<m} - {i})) *\n      (real_of_rat reduction * real_of_int (d fs i))", "by(rule mult_strict_left_mono[OF d_i(1)],insert prod_pos',auto)"], ["proof (state)\nthis:\n  real_of_int (prod (d fs') ({0..<m} - {i})) * real_of_int (d fs' i)\n  < real_of_int (prod (d fs') ({0..<m} - {i})) *\n    (real_of_rat reduction * real_of_int (d fs i))\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "also"], ["proof (state)\nthis:\n  real_of_int (prod (d fs') ({0..<m} - {i})) * real_of_int (d fs' i)\n  < real_of_int (prod (d fs') ({0..<m} - {i})) *\n    (real_of_rat reduction * real_of_int (d fs i))\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have \"(\\<Prod> j \\<in> {0 ..< m} - {i}. d fs' j) = (\\<Prod> j \\<in> {0 ..< m} - {i}. d fs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (d fs') ({0..<m} - {i}) = prod (d fs) ({0..<m} - {i})", "by (rule prod.cong, insert d, auto)"], ["proof (state)\nthis:\n  prod (d fs') ({0..<m} - {i}) = prod (d fs) ({0..<m} - {i})\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "also"], ["proof (state)\nthis:\n  prod (d fs') ({0..<m} - {i}) = prod (d fs) ({0..<m} - {i})\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have \"\\<dots> * (of_rat reduction * d fs i) \n    = of_rat reduction * (\\<Prod> j \\<in> {0 ..< m} - {i} \\<union> {i}. d fs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (prod (d fs) ({0..<m} - {i})) *\n    (real_of_rat reduction * real_of_int (d fs i)) =\n    real_of_rat reduction *\n    real_of_int (prod (d fs) ({0..<m} - {i} \\<union> {i}))", "by (subst prod.union_disjoint, auto)"], ["proof (state)\nthis:\n  real_of_int (prod (d fs) ({0..<m} - {i})) *\n  (real_of_rat reduction * real_of_int (d fs i)) =\n  real_of_rat reduction *\n  real_of_int (prod (d fs) ({0..<m} - {i} \\<union> {i}))\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "also"], ["proof (state)\nthis:\n  real_of_int (prod (d fs) ({0..<m} - {i})) *\n  (real_of_rat reduction * real_of_int (d fs i)) =\n  real_of_rat reduction *\n  real_of_int (prod (d fs) ({0..<m} - {i} \\<union> {i}))\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have \"(\\<Prod> j \\<in> {0 ..< m} - {i} \\<union> {i}. d fs j) = (\\<Prod> j<m. d fs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (d fs) ({0..<m} - {i} \\<union> {i}) = prod (d fs) {..<m}", "by (subst prod.cong, insert i, auto)"], ["proof (state)\nthis:\n  prod (d fs) ({0..<m} - {i} \\<union> {i}) = prod (d fs) {..<m}\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "finally"], ["proof (chain)\npicking this:\n  real (D fs') < real_of_rat reduction * real_of_int (prod (d fs) {..<m})", "have D: \"D fs' < real_of_rat reduction * D fs\""], ["proof (prove)\nusing this:\n  real (D fs') < real_of_rat reduction * real_of_int (prod (d fs) {..<m})\n\ngoal (1 subgoal):\n 1. real (D fs') < real_of_rat reduction * real (D fs)", "unfolding D_def"], ["proof (prove)\nusing this:\n  real (nat (prod (d fs') {..<m}))\n  < real_of_rat reduction * real_of_int (prod (d fs) {..<m})\n\ngoal (1 subgoal):\n 1. real (nat (prod (d fs') {..<m}))\n    < real_of_rat reduction * real (nat (prod (d fs) {..<m}))", "using prodpos2"], ["proof (prove)\nusing this:\n  real (nat (prod (d fs') {..<m}))\n  < real_of_rat reduction * real_of_int (prod (d fs) {..<m})\n  0 < prod (d fs) {..<m}\n\ngoal (1 subgoal):\n 1. real (nat (prod (d fs') {..<m}))\n    < real_of_rat reduction * real (nat (prod (d fs) {..<m}))", "by auto"], ["proof (state)\nthis:\n  real (D fs') < real_of_rat reduction * real (D fs)\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "have logD: \"logD fs' < logD fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. logD fs' < logD fs", "proof (cases \"\\<alpha> = 4/3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> = 4 / 3 \\<Longrightarrow> logD fs' < logD fs\n 2. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "case True"], ["proof (state)\nthis:\n  \\<alpha> = 4 / 3\n\ngoal (2 subgoals):\n 1. \\<alpha> = 4 / 3 \\<Longrightarrow> logD fs' < logD fs\n 2. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. logD fs' < logD fs", "using D"], ["proof (prove)\nusing this:\n  real (D fs') < real_of_rat reduction * real (D fs)\n\ngoal (1 subgoal):\n 1. logD fs' < logD fs", "unfolding reduction(4)[OF True] logD_def"], ["proof (prove)\nusing this:\n  real (D fs') < real_of_rat 1 * real (D fs)\n\ngoal (1 subgoal):\n 1. (if \\<alpha> = 4 / 3 then D fs'\n     else nat \\<lfloor>log (1 / real_of_rat 1) (real (D fs'))\\<rfloor>)\n    < (if \\<alpha> = 4 / 3 then D fs\n       else nat \\<lfloor>log (1 / real_of_rat 1) (real (D fs))\\<rfloor>)", "unfolding True"], ["proof (prove)\nusing this:\n  real (D fs') < real_of_rat 1 * real (D fs)\n\ngoal (1 subgoal):\n 1. (if 4 / 3 = 4 / 3 then D fs'\n     else nat \\<lfloor>log (1 / real_of_rat 1) (real (D fs'))\\<rfloor>)\n    < (if 4 / 3 = 4 / 3 then D fs\n       else nat \\<lfloor>log (1 / real_of_rat 1) (real (D fs))\\<rfloor>)", "by simp"], ["proof (state)\nthis:\n  logD fs' < logD fs\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "case False"], ["proof (state)\nthis:\n  \\<alpha> \\<noteq> 4 / 3\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "hence False': \"\\<alpha> = 4/3 \\<longleftrightarrow> False\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> 4 / 3\n\ngoal (1 subgoal):\n 1. (\\<alpha> = 4 / 3) = False", "by simp"], ["proof (state)\nthis:\n  (\\<alpha> = 4 / 3) = False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "from False \\<alpha>"], ["proof (chain)\npicking this:\n  \\<alpha> \\<noteq> 4 / 3\n  4 / 3 \\<le> \\<alpha>", "have \"\\<alpha> > 4/3\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> 4 / 3\n  4 / 3 \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. 4 / 3 < \\<alpha>", "by simp"], ["proof (state)\nthis:\n  4 / 3 < \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "with reduction"], ["proof (chain)\npicking this:\n  0 < reduction\n  reduction \\<le> 1\n  4 / 3 < \\<alpha> \\<Longrightarrow> reduction < 1\n  \\<alpha> = 4 / 3 \\<Longrightarrow> reduction = 1\n  4 / 3 < \\<alpha>", "have reduction1: \"reduction < 1\""], ["proof (prove)\nusing this:\n  0 < reduction\n  reduction \\<le> 1\n  4 / 3 < \\<alpha> \\<Longrightarrow> reduction < 1\n  \\<alpha> = 4 / 3 \\<Longrightarrow> reduction = 1\n  4 / 3 < \\<alpha>\n\ngoal (1 subgoal):\n 1. reduction < 1", "by simp"], ["proof (state)\nthis:\n  reduction < 1\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "let ?new = \"real (D fs')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "let ?old = \"real (D fs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "let ?log = \"log (1/of_rat reduction)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "note pos = LLL_D_pos[OF newInvw] LLL_D_pos[OF Linvw]"], ["proof (state)\nthis:\n  0 < D fs'\n  0 < D fs\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "from reduction"], ["proof (chain)\npicking this:\n  0 < reduction\n  reduction \\<le> 1\n  4 / 3 < \\<alpha> \\<Longrightarrow> reduction < 1\n  \\<alpha> = 4 / 3 \\<Longrightarrow> reduction = 1", "have \"real_of_rat reduction > 0\""], ["proof (prove)\nusing this:\n  0 < reduction\n  reduction \\<le> 1\n  4 / 3 < \\<alpha> \\<Longrightarrow> reduction < 1\n  \\<alpha> = 4 / 3 \\<Longrightarrow> reduction = 1\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat reduction", "by auto"], ["proof (state)\nthis:\n  0 < real_of_rat reduction\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "hence gediv:\"1/real_of_rat reduction > 0\""], ["proof (prove)\nusing this:\n  0 < real_of_rat reduction\n\ngoal (1 subgoal):\n 1. 0 < 1 / real_of_rat reduction", "by auto"], ["proof (state)\nthis:\n  0 < 1 / real_of_rat reduction\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "have \"(1/of_rat reduction) * ?new \\<le> ((1/of_rat reduction) * of_rat reduction) * ?old\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / real_of_rat reduction * real (D fs')\n    \\<le> 1 / real_of_rat reduction * real_of_rat reduction * real (D fs)", "unfolding mult.assoc mult_le_cancel_iff2[OF gediv]"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (D fs') \\<le> real_of_rat reduction * real (D fs)", "using D"], ["proof (prove)\nusing this:\n  real (D fs') < real_of_rat reduction * real (D fs)\n\ngoal (1 subgoal):\n 1. real (D fs') \\<le> real_of_rat reduction * real (D fs)", "by simp"], ["proof (state)\nthis:\n  1 / real_of_rat reduction * real (D fs')\n  \\<le> 1 / real_of_rat reduction * real_of_rat reduction * real (D fs)\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "also"], ["proof (state)\nthis:\n  1 / real_of_rat reduction * real (D fs')\n  \\<le> 1 / real_of_rat reduction * real_of_rat reduction * real (D fs)\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "have \"(1/of_rat reduction) * of_rat reduction = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / of_rat reduction * of_rat reduction = (1::'a)", "using reduction"], ["proof (prove)\nusing this:\n  0 < reduction\n  reduction \\<le> 1\n  4 / 3 < \\<alpha> \\<Longrightarrow> reduction < 1\n  \\<alpha> = 4 / 3 \\<Longrightarrow> reduction = 1\n\ngoal (1 subgoal):\n 1. (1::'a) / of_rat reduction * of_rat reduction = (1::'a)", "by auto"], ["proof (state)\nthis:\n  (1::?'a3) / of_rat reduction * of_rat reduction = (1::?'a3)\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "finally"], ["proof (chain)\npicking this:\n  1 / real_of_rat reduction * real (D fs') \\<le> 1 * real (D fs)", "have \"(1/of_rat reduction) * ?new \\<le> ?old\""], ["proof (prove)\nusing this:\n  1 / real_of_rat reduction * real (D fs') \\<le> 1 * real (D fs)\n\ngoal (1 subgoal):\n 1. 1 / real_of_rat reduction * real (D fs') \\<le> real (D fs)", "by auto"], ["proof (state)\nthis:\n  1 / real_of_rat reduction * real (D fs') \\<le> real (D fs)\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "hence \"?log ((1/of_rat reduction) * ?new) \\<le> ?log ?old\""], ["proof (prove)\nusing this:\n  1 / real_of_rat reduction * real (D fs') \\<le> real (D fs)\n\ngoal (1 subgoal):\n 1. log (1 / real_of_rat reduction)\n     (1 / real_of_rat reduction * real (D fs'))\n    \\<le> log (1 / real_of_rat reduction) (real (D fs))", "by (subst log_le_cancel_iff, auto simp: pos reduction1 reduction)"], ["proof (state)\nthis:\n  log (1 / real_of_rat reduction) (1 / real_of_rat reduction * real (D fs'))\n  \\<le> log (1 / real_of_rat reduction) (real (D fs))\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "hence \"floor (?log ((1/of_rat reduction) * ?new)) \\<le> floor (?log ?old)\""], ["proof (prove)\nusing this:\n  log (1 / real_of_rat reduction) (1 / real_of_rat reduction * real (D fs'))\n  \\<le> log (1 / real_of_rat reduction) (real (D fs))\n\ngoal (1 subgoal):\n 1. \\<lfloor>log (1 / real_of_rat reduction)\n              (1 / real_of_rat reduction * real (D fs'))\\<rfloor>\n    \\<le> \\<lfloor>log (1 / real_of_rat reduction) (real (D fs))\\<rfloor>", "by (rule floor_mono)"], ["proof (state)\nthis:\n  \\<lfloor>log (1 / real_of_rat reduction)\n            (1 / real_of_rat reduction * real (D fs'))\\<rfloor>\n  \\<le> \\<lfloor>log (1 / real_of_rat reduction) (real (D fs))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "hence \"nat (floor (?log ((1/of_rat reduction) * ?new))) \\<le> nat (floor (?log ?old))\""], ["proof (prove)\nusing this:\n  \\<lfloor>log (1 / real_of_rat reduction)\n            (1 / real_of_rat reduction * real (D fs'))\\<rfloor>\n  \\<le> \\<lfloor>log (1 / real_of_rat reduction) (real (D fs))\\<rfloor>\n\ngoal (1 subgoal):\n 1. nat \\<lfloor>log (1 / real_of_rat reduction)\n                  (1 / real_of_rat reduction * real (D fs'))\\<rfloor>\n    \\<le> nat \\<lfloor>log (1 / real_of_rat reduction)\n                        (real (D fs))\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  nat \\<lfloor>log (1 / real_of_rat reduction)\n                (1 / real_of_rat reduction * real (D fs'))\\<rfloor>\n  \\<le> nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "also"], ["proof (state)\nthis:\n  nat \\<lfloor>log (1 / real_of_rat reduction)\n                (1 / real_of_rat reduction * real (D fs'))\\<rfloor>\n  \\<le> nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "have \"\\<dots> = logD fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs))\\<rfloor> =\n    logD fs", "unfolding logD_def False'"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs))\\<rfloor> =\n    (if False then D fs\n     else nat \\<lfloor>log (1 / real_of_rat reduction)\n                        (real (D fs))\\<rfloor>)", "by simp"], ["proof (state)\nthis:\n  nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs))\\<rfloor> =\n  logD fs\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "also"], ["proof (state)\nthis:\n  nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs))\\<rfloor> =\n  logD fs\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "have \"?log ((1/of_rat reduction) * ?new) = 1 + ?log ?new\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log (1 / real_of_rat reduction)\n     (1 / real_of_rat reduction * real (D fs')) =\n    1 + log (1 / real_of_rat reduction) (real (D fs'))", "by (subst log_mult, insert reduction reduction1, auto simp: pos )"], ["proof (state)\nthis:\n  log (1 / real_of_rat reduction)\n   (1 / real_of_rat reduction * real (D fs')) =\n  1 + log (1 / real_of_rat reduction) (real (D fs'))\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "also"], ["proof (state)\nthis:\n  log (1 / real_of_rat reduction)\n   (1 / real_of_rat reduction * real (D fs')) =\n  1 + log (1 / real_of_rat reduction) (real (D fs'))\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "have \"floor (1 + ?log ?new) = 1 + floor (?log ?new)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>1 + log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor> =\n    1 + \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<lfloor>1 + log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor> =\n  1 + \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "also"], ["proof (state)\nthis:\n  \\<lfloor>1 + log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor> =\n  1 + \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "have \"nat (1 + floor (?log ?new)) = 1 + nat (floor (?log ?new))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (1 +\n         \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor>) =\n    1 + nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor>", "by (subst nat_add_distrib, insert pos reduction reduction1, auto)"], ["proof (state)\nthis:\n  nat (1 +\n       \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor>) =\n  1 + nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "also"], ["proof (state)\nthis:\n  nat (1 +\n       \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor>) =\n  1 + nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "have \"nat (floor (?log ?new)) = logD fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor> =\n    logD fs'", "unfolding logD_def False'"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor> =\n    (if False then D fs'\n     else nat \\<lfloor>log (1 / real_of_rat reduction)\n                        (real (D fs'))\\<rfloor>)", "by simp"], ["proof (state)\nthis:\n  nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs'))\\<rfloor> =\n  logD fs'\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 4 / 3 \\<Longrightarrow> logD fs' < logD fs", "finally"], ["proof (chain)\npicking this:\n  1 + logD fs' \\<le> logD fs", "show \"logD fs' < logD fs\""], ["proof (prove)\nusing this:\n  1 + logD fs' \\<le> logD fs\n\ngoal (1 subgoal):\n 1. logD fs' < logD fs", "by simp"], ["proof (state)\nthis:\n  logD fs' < logD fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  logD fs' < logD fs\n\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "show \"LLL_measure i fs > LLL_measure (i - 1) fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_measure (i - 1) fs' < LLL_measure i fs", "unfolding LLL_measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * logD fs' + m - (i - 1) < 2 * logD fs + m - i", "using i logD"], ["proof (prove)\nusing this:\n  i < m\n  logD fs' < logD fs\n\ngoal (1 subgoal):\n 1. 2 * logD fs' + m - (i - 1) < 2 * logD fs + m - i", "by simp"], ["proof (state)\nthis:\n  LLL_measure (i - 1) fs' < LLL_measure i fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_inv_initial_state: \"LLL_invariant True 0 fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True 0 fs_init", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_invariant True 0 fs_init", "from lin_dep[unfolded gs.lin_indpt_list_def]"], ["proof (chain)\npicking this:\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs_init) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))", "have \"set (RAT fs_init) \\<subseteq> Rn\""], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs_init) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n\ngoal (1 subgoal):\n 1. set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. LLL_invariant True 0 fs_init", "hence fs_init: \"set fs_init \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. set fs_init \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set fs_init \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. LLL_invariant True 0 fs_init", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True 0 fs_init", "by (rule LLL_invI[OF fs_init len _ _ lin_dep], auto simp: L_def gs.reduced_def gs.weakly_reduced_def)"], ["proof (state)\nthis:\n  LLL_invariant True 0 fs_init\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_inv_m_imp_reduced: assumes \"LLL_invariant True m fs\" \n  shows \"reduced fs m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m", "using LLL_invD[OF assms]"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  m \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  True \\<or> \\<mu>_small fs m\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m", "by blast"], ["", "lemma basis_reduction_short_vector: assumes LLL_inv: \"LLL_invariant True m fs\" \n  and v: \"v = hd fs\" \n  and m0: \"m \\<noteq> 0\"\nshows \"v \\<in> carrier_vec n\"\n  \"v \\<in> L - {0\\<^sub>v n}\"  \n  \"h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow> rat_of_int (sq_norm v) \\<le> \\<alpha> ^ (m - 1) * rat_of_int (sq_norm h)\" \n  \"v \\<noteq> 0\\<^sub>v j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n &&& v \\<in> L - {0\\<^sub>v n}) &&&\n    (h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) &&&\n    v \\<noteq> 0\\<^sub>v j", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "let ?L = \"lattice_of fs_init\""], ["proof (state)\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "have a1: \"\\<alpha> \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> \\<alpha>", "using \\<alpha>"], ["proof (prove)\nusing this:\n  4 / 3 \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<alpha>", "by auto"], ["proof (state)\nthis:\n  1 \\<le> \\<alpha>\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "from LLL_invD[OF LLL_inv]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  m \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  True \\<or> \\<mu>_small fs m", "have\n    L: \"lattice_of fs = L\" \n    and red: \"gram_schmidt_fs.weakly_reduced n (RAT fs) \\<alpha> (length (RAT fs))\" \n    and basis: \"lin_indep fs\" \n    and lenH: \"length fs = m\" \n    and H: \"set fs \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  m \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  True \\<or> \\<mu>_small fs m\n\ngoal (1 subgoal):\n 1. (lattice_of fs = L &&&\n     gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n      (length (map of_int_hom.vec_hom fs))) &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) &&&\n    length fs = m &&& set fs \\<subseteq> carrier_vec n", "by (auto simp: gs.lin_indpt_list_def gs.reduced_def)"], ["proof (state)\nthis:\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n   (length (map of_int_hom.vec_hom fs))\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = m\n  set fs \\<subseteq> carrier_vec n\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "from lin_dep"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)", "have G: \"set fs_init \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)\n\ngoal (1 subgoal):\n 1. set fs_init \\<subseteq> carrier_vec n", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs_init) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n\ngoal (1 subgoal):\n 1. set fs_init \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set fs_init \\<subseteq> carrier_vec n\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "with m0 len"], ["proof (chain)\npicking this:\n  m \\<noteq> 0\n  length fs_init = m\n  set fs_init \\<subseteq> carrier_vec n", "have \"dim_vec (hd fs_init) = n\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n  length fs_init = m\n  set fs_init \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec (hd fs_init) = n", "by (cases fs_init, auto)"], ["proof (state)\nthis:\n  dim_vec (hd fs_init) = n\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "from v m0 lenH v"], ["proof (chain)\npicking this:\n  v = hd fs\n  m \\<noteq> 0\n  length fs = m\n  v = hd fs", "have v: \"v = fs ! 0\""], ["proof (prove)\nusing this:\n  v = hd fs\n  m \\<noteq> 0\n  length fs = m\n  v = hd fs\n\ngoal (1 subgoal):\n 1. v = fs ! 0", "by (cases fs, auto)"], ["proof (state)\nthis:\n  v = fs ! 0\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "interpret gs1: gram_schmidt_fs_lin_indpt n \"RAT fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_lin_indpt n (map of_int_hom.vec_hom fs)", "by (standard) (use assms LLL_invariant_def gs.lin_indpt_list_def in auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "let ?rv = \"map_vec ?r\""], ["proof (state)\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "let ?F = \"RAT fs\""], ["proof (state)\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "let ?h = \"?rv h\""], ["proof (state)\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "assume h:\"h \\<in> L - {0\\<^sub>v n}\" (is ?h_req)"], ["proof (state)\nthis:\n  h \\<in> L - {0\\<^sub>v n}\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "from h[folded L]"], ["proof (chain)\npicking this:\n  h \\<in> lattice_of fs - {0\\<^sub>v n}", "have h: \"h \\<in> lattice_of fs\" \"h \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  h \\<in> lattice_of fs - {0\\<^sub>v n}\n\ngoal (1 subgoal):\n 1. h \\<in> lattice_of fs &&& h \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  h \\<in> lattice_of fs\n  h \\<noteq> 0\\<^sub>v n\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "{"], ["proof (state)\nthis:\n  h \\<in> lattice_of fs\n  h \\<noteq> 0\\<^sub>v n\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "assume f: \"?h = 0\\<^sub>v n\""], ["proof (state)\nthis:\n  of_int_hom.vec_hom h = 0\\<^sub>v n\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "have \"?h = ?rv (0\\<^sub>v n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom h = of_int_hom.vec_hom (0\\<^sub>v n)", "unfolding f"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n = of_int_hom.vec_hom (0\\<^sub>v n)", "by (intro eq_vecI, auto)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom h = of_int_hom.vec_hom (0\\<^sub>v n)\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "hence \"h = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom h = of_int_hom.vec_hom (0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. h = 0\\<^sub>v n", "using of_int_hom.vec_hom_zero_iff[of h] of_int_hom.vec_hom_inj"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom h = of_int_hom.vec_hom (0\\<^sub>v n)\n  (of_int_hom.vec_hom h = 0\\<^sub>v ?n) = (h = 0\\<^sub>v ?n)\n  of_int_hom.vec_hom ?v = of_int_hom.vec_hom ?w \\<Longrightarrow> ?v = ?w\n\ngoal (1 subgoal):\n 1. h = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  h = 0\\<^sub>v n\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "with h"], ["proof (chain)\npicking this:\n  h \\<in> lattice_of fs\n  h \\<noteq> 0\\<^sub>v n\n  h = 0\\<^sub>v n", "have False"], ["proof (prove)\nusing this:\n  h \\<in> lattice_of fs\n  h \\<noteq> 0\\<^sub>v n\n  h = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "}"], ["proof (state)\nthis:\n  of_int_hom.vec_hom h = 0\\<^sub>v n \\<Longrightarrow> False\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "hence h0: \"?h \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom h = 0\\<^sub>v n \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom h \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  of_int_hom.vec_hom h \\<noteq> 0\\<^sub>v n\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "with lattice_of_of_int[OF H h(1)]"], ["proof (chain)\npicking this:\n  of_int_hom.vec_hom h \\<in> gs.lattice_of (map of_int_hom.vec_hom fs)\n  of_int_hom.vec_hom h \\<noteq> 0\\<^sub>v n", "have \"?h \\<in> gs.lattice_of ?F - {0\\<^sub>v n}\""], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom h \\<in> gs.lattice_of (map of_int_hom.vec_hom fs)\n  of_int_hom.vec_hom h \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom h\n    \\<in> gs.lattice_of (map of_int_hom.vec_hom fs) - {0\\<^sub>v n}", "by auto"], ["proof (state)\nthis:\n  of_int_hom.vec_hom h\n  \\<in> gs.lattice_of (map of_int_hom.vec_hom fs) - {0\\<^sub>v n}\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "}"], ["proof (state)\nthis:\n  h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n  of_int_hom.vec_hom h\n  \\<in> gs.lattice_of (map of_int_hom.vec_hom fs) - {0\\<^sub>v n}\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n 4. v \\<noteq> 0\\<^sub>v j", "from gs1.weakly_reduced_imp_short_vector[OF red this a1] lenH"], ["proof (chain)\npicking this:\n  h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n  map of_int_hom.vec_hom fs \\<noteq> [] \\<and>\n  \\<parallel>map of_int_hom.vec_hom fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (length (map of_int_hom.vec_hom fs) - 1) *\n        \\<parallel>of_int_hom.vec_hom h\\<parallel>\\<^sup>2\n  length fs = m", "show \"h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow> ?r (sq_norm v) \\<le> \\<alpha> ^ (m - 1) * ?r (sq_norm h)\""], ["proof (prove)\nusing this:\n  h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n  map of_int_hom.vec_hom fs \\<noteq> [] \\<and>\n  \\<parallel>map of_int_hom.vec_hom fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (length (map of_int_hom.vec_hom fs) - 1) *\n        \\<parallel>of_int_hom.vec_hom h\\<parallel>\\<^sup>2\n  length fs = m\n\ngoal (1 subgoal):\n 1. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2", "using basis"], ["proof (prove)\nusing this:\n  h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n  map of_int_hom.vec_hom fs \\<noteq> [] \\<and>\n  \\<parallel>map of_int_hom.vec_hom fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (length (map of_int_hom.vec_hom fs) - 1) *\n        \\<parallel>of_int_hom.vec_hom h\\<parallel>\\<^sup>2\n  length fs = m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2", "unfolding L v gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n  map of_int_hom.vec_hom fs \\<noteq> [] \\<and>\n  \\<parallel>map of_int_hom.vec_hom fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (length (map of_int_hom.vec_hom fs) - 1) *\n        \\<parallel>of_int_hom.vec_hom h\\<parallel>\\<^sup>2\n  length fs = m\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n\ngoal (1 subgoal):\n 1. h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n    rat_of_int \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2", "by (auto simp: sq_norm_of_int)"], ["proof (state)\nthis:\n  h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n  rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>h\\<parallel>\\<^sup>2\n\ngoal (3 subgoals):\n 1. v \\<in> carrier_vec n\n 2. v \\<in> L - {0\\<^sub>v n}\n 3. v \\<noteq> 0\\<^sub>v j", "from m0 H lenH"], ["proof (chain)\npicking this:\n  m \\<noteq> 0\n  set fs \\<subseteq> carrier_vec n\n  length fs = m", "show vn: \"v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n  set fs \\<subseteq> carrier_vec n\n  length fs = m\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "unfolding v"], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n  set fs \\<subseteq> carrier_vec n\n  length fs = m\n\ngoal (1 subgoal):\n 1. fs ! 0 \\<in> carrier_vec n", "by (cases fs, auto)"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. v \\<in> L - {0\\<^sub>v n}\n 2. v \\<noteq> 0\\<^sub>v j", "have vL: \"v \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> L", "unfolding L[symmetric] v"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! 0 \\<in> lattice_of fs", "using m0 H lenH"], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n  set fs \\<subseteq> carrier_vec n\n  length fs = m\n\ngoal (1 subgoal):\n 1. fs ! 0 \\<in> lattice_of fs", "by (intro basis_in_latticeI, cases fs, auto)"], ["proof (state)\nthis:\n  v \\<in> L\n\ngoal (2 subgoals):\n 1. v \\<in> L - {0\\<^sub>v n}\n 2. v \\<noteq> 0\\<^sub>v j", "{"], ["proof (state)\nthis:\n  v \\<in> L\n\ngoal (2 subgoals):\n 1. v \\<in> L - {0\\<^sub>v n}\n 2. v \\<noteq> 0\\<^sub>v j", "assume \"v = 0\\<^sub>v n\""], ["proof (state)\nthis:\n  v = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. v \\<in> L - {0\\<^sub>v n}\n 2. v \\<noteq> 0\\<^sub>v j", "hence \"hd ?F = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. hd (map of_int_hom.vec_hom fs) = 0\\<^sub>v n", "unfolding v"], ["proof (prove)\nusing this:\n  fs ! 0 = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. hd (map of_int_hom.vec_hom fs) = 0\\<^sub>v n", "using m0 lenH"], ["proof (prove)\nusing this:\n  fs ! 0 = 0\\<^sub>v n\n  m \\<noteq> 0\n  length fs = m\n\ngoal (1 subgoal):\n 1. hd (map of_int_hom.vec_hom fs) = 0\\<^sub>v n", "by (cases fs, auto)"], ["proof (state)\nthis:\n  hd (map of_int_hom.vec_hom fs) = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. v \\<in> L - {0\\<^sub>v n}\n 2. v \\<noteq> 0\\<^sub>v j", "with gs.lin_indpt_list_nonzero[OF basis]"], ["proof (chain)\npicking this:\n  0\\<^sub>v n \\<notin> set (map of_int_hom.vec_hom fs)\n  hd (map of_int_hom.vec_hom fs) = 0\\<^sub>v n", "have False"], ["proof (prove)\nusing this:\n  0\\<^sub>v n \\<notin> set (map of_int_hom.vec_hom fs)\n  hd (map of_int_hom.vec_hom fs) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. False", "using m0 lenH"], ["proof (prove)\nusing this:\n  0\\<^sub>v n \\<notin> set (map of_int_hom.vec_hom fs)\n  hd (map of_int_hom.vec_hom fs) = 0\\<^sub>v n\n  m \\<noteq> 0\n  length fs = m\n\ngoal (1 subgoal):\n 1. False", "by (cases fs, auto)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. v \\<in> L - {0\\<^sub>v n}\n 2. v \\<noteq> 0\\<^sub>v j", "}"], ["proof (state)\nthis:\n  v = 0\\<^sub>v n \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. v \\<in> L - {0\\<^sub>v n}\n 2. v \\<noteq> 0\\<^sub>v j", "with vL"], ["proof (chain)\npicking this:\n  v \\<in> L\n  v = 0\\<^sub>v n \\<Longrightarrow> False", "show v: \"v \\<in> L - {0\\<^sub>v n}\""], ["proof (prove)\nusing this:\n  v \\<in> L\n  v = 0\\<^sub>v n \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<in> L - {0\\<^sub>v n}", "by auto"], ["proof (state)\nthis:\n  v \\<in> L - {0\\<^sub>v n}\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v j", "have jn:\"0\\<^sub>v j \\<in> carrier_vec n \\<Longrightarrow> j = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v j \\<in> carrier_vec n \\<Longrightarrow> j = n", "unfolding zero_vec_def carrier_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec j (\\<lambda>i. 0::'a) \\<in> {v. dim_vec v = n} \\<Longrightarrow>\n    j = n", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v j \\<in> carrier_vec n \\<Longrightarrow> j = n\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v j", "with v vn"], ["proof (chain)\npicking this:\n  v \\<in> L - {0\\<^sub>v n}\n  v \\<in> carrier_vec n\n  0\\<^sub>v j \\<in> carrier_vec n \\<Longrightarrow> j = n", "show \"v \\<noteq> 0\\<^sub>v j\""], ["proof (prove)\nusing this:\n  v \\<in> L - {0\\<^sub>v n}\n  v \\<in> carrier_vec n\n  0\\<^sub>v j \\<in> carrier_vec n \\<Longrightarrow> j = n\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v j", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_mu_d_Z: assumes inv: \"LLL_invariant_weak fs\" \n  and j: \"j \\<le> ii\" and ii: \"ii < m\" \nshows \"of_int (d fs (Suc j)) * \\<mu> fs ii j \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) *\n    gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii j\n    \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) *\n    gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii j\n    \\<in> \\<int>", "interpret fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by standard (use inv in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> ii j \\<in> \\<int>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> ii j \\<in> \\<int>", "using assms fs.fs_int_mu_d_Z LLL_inv_wD[OF inv]"], ["proof (prove)\nusing this:\n  LLL_invariant_weak fs\n  j \\<le> ii\n  ii < m\n  \\<lbrakk>?j \\<le> ?ii; ?ii < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (fs.d fs (Suc ?j)) * fs.gs.\\<mu> ?ii ?j\n                    \\<in> \\<int>\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> ii j \\<in> \\<int>", "unfolding d_def fs.d_def"], ["proof (prove)\nusing this:\n  LLL_invariant_weak fs\n  j \\<le> ii\n  ii < m\n  \\<lbrakk>?j \\<le> ?ii; ?ii < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (gs.Gramian_determinant fs (Suc ?j)) *\n                    fs.gs.\\<mu> ?ii ?j\n                    \\<in> \\<int>\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs (Suc j)) * fs.gs.\\<mu> ii j\n    \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> ii j \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "context fixes fs\n  assumes Linv: \"LLL_invariant_weak fs\" and gbnd: \"g_bound fs\" \nbegin"], ["", "interpretation gs1: gram_schmidt_fs_lin_indpt n \"RAT fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_lin_indpt n (map of_int_hom.vec_hom fs)", "by (standard) (use Linv LLL_invariant_weak_def gs.lin_indpt_list_def in auto)"], ["", "lemma LLL_inv_N_pos: assumes m: \"m \\<noteq> 0\" \nshows \"N > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < N", "let ?r = rat_of_int"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < N", "note inv = LLL_inv_wD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. 0 < N", "from inv"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L", "have F: \"RAT fs ! 0 \\<in> Rn\" \"fs ! 0 \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! 0 \\<in> Rn &&& fs ! 0 \\<in> carrier_vec n", "using m"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! 0 \\<in> Rn &&& fs ! 0 \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! 0 \\<in> Rn\n  fs ! 0 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. 0 < N", "from m"], ["proof (chain)\npicking this:\n  m \\<noteq> 0", "have upt: \"[0..< m] = 0 # [1 ..< m]\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [0..<m] = 0 # [1..<m]", "using upt_add_eq_append[of 0 1 \"m - 1\"]"], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n  0 \\<le> 1 \\<Longrightarrow>\n  [0..<1 + (m - 1)] = [0..<1] @ [1..<1 + (m - 1)]\n\ngoal (1 subgoal):\n 1. [0..<m] = 0 # [1..<m]", "by auto"], ["proof (state)\nthis:\n  [0..<m] = 0 # [1..<m]\n\ngoal (1 subgoal):\n 1. 0 < N", "from inv(6) m"], ["proof (chain)\npicking this:\n  length fs = m\n  m \\<noteq> 0", "have \"map_vec ?r (fs ! 0) \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  length fs = m\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! 0) \\<noteq> 0\\<^sub>v n", "using gs.lin_indpt_list_nonzero[OF inv(1)]"], ["proof (prove)\nusing this:\n  length fs = m\n  m \\<noteq> 0\n  0\\<^sub>v n \\<notin> set (map of_int_hom.vec_hom fs)\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! 0) \\<noteq> 0\\<^sub>v n", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  length fs = m\n  m \\<noteq> 0\n  0\\<^sub>v n\n  \\<notin> {map of_int_hom.vec_hom fs ! i |i.\n            i < length (map of_int_hom.vec_hom fs)}\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! 0) \\<noteq> 0\\<^sub>v n", "by force"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs ! 0) \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. 0 < N", "hence F0: \"fs ! 0 \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (fs ! 0) \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. fs ! 0 \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  fs ! 0 \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. 0 < N", "hence \"sq_norm (fs ! 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  fs ! 0 \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! 0\\<parallel>\\<^sup>2 \\<noteq> 0", "using F"], ["proof (prove)\nusing this:\n  fs ! 0 \\<noteq> 0\\<^sub>v n\n  map of_int_hom.vec_hom fs ! 0 \\<in> Rn\n  fs ! 0 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! 0\\<parallel>\\<^sup>2 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < N", "hence 1: \"sq_norm (fs ! 0) \\<ge> 1\""], ["proof (prove)\nusing this:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>fs ! 0\\<parallel>\\<^sup>2", "using sq_norm_vec_ge_0[of \"fs ! 0\"]"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2 \\<noteq> 0\n  0 \\<le> \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<parallel>fs ! 0\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  1 \\<le> \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 < N", "from gbnd m"], ["proof (chain)\npicking this:\n  g_bound fs\n  m \\<noteq> 0", "have \"sq_norm (gso fs 0) \\<le> of_nat N\""], ["proof (prove)\nusing this:\n  g_bound fs\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>gs1.gso 0\\<parallel>\\<^sup>2 \\<le> rat_of_nat N", "unfolding g_bound_def"], ["proof (prove)\nusing this:\n  \\<forall>i<m. \\<parallel>gs1.gso i\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>gs1.gso 0\\<parallel>\\<^sup>2 \\<le> rat_of_nat N", "by auto"], ["proof (state)\nthis:\n  \\<parallel>gs1.gso 0\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. 0 < N", "also"], ["proof (state)\nthis:\n  \\<parallel>gs1.gso 0\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. 0 < N", "have \"gso fs 0 = RAT fs ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs1.gso 0 = map of_int_hom.vec_hom fs ! 0", "unfolding upt"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs1.gso 0 = map of_int_hom.vec_hom fs ! 0", "using F"], ["proof (prove)\nusing this:\n  map of_int_hom.vec_hom fs ! 0 \\<in> Rn\n  fs ! 0 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. gs1.gso 0 = map of_int_hom.vec_hom fs ! 0", "by (simp add: gs1.gso.simps[of 0])"], ["proof (state)\nthis:\n  gs1.gso 0 = map of_int_hom.vec_hom fs ! 0\n\ngoal (1 subgoal):\n 1. 0 < N", "also"], ["proof (state)\nthis:\n  gs1.gso 0 = map of_int_hom.vec_hom fs ! 0\n\ngoal (1 subgoal):\n 1. 0 < N", "have \"RAT fs ! 0 = map_vec ?r (fs ! 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! 0 = of_int_hom.vec_hom (fs ! 0)", "using inv(6) m"], ["proof (prove)\nusing this:\n  length fs = m\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! 0 = of_int_hom.vec_hom (fs ! 0)", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! 0 = of_int_hom.vec_hom (fs ! 0)\n\ngoal (1 subgoal):\n 1. 0 < N", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! 0 = of_int_hom.vec_hom (fs ! 0)\n\ngoal (1 subgoal):\n 1. 0 < N", "have \"sq_norm \\<dots> = ?r (sq_norm (fs ! 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>of_int_hom.vec_hom (fs ! 0)\\<parallel>\\<^sup>2 =\n    rat_of_int \\<parallel>fs ! 0\\<parallel>\\<^sup>2", "by (simp add: sq_norm_of_int)"], ["proof (state)\nthis:\n  \\<parallel>of_int_hom.vec_hom (fs ! 0)\\<parallel>\\<^sup>2 =\n  rat_of_int \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 < N", "finally"], ["proof (chain)\npicking this:\n  rat_of_int \\<parallel>fs ! 0\\<parallel>\\<^sup>2 \\<le> rat_of_nat N", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_of_int \\<parallel>fs ! 0\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. 0 < N", "using 1"], ["proof (prove)\nusing this:\n  rat_of_int \\<parallel>fs ! 0\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n  1 \\<le> \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 < N", "by (cases N, auto)"], ["proof (state)\nthis:\n  0 < N\n\ngoal:\nNo subgoals!", "qed"], ["", "(* equation (3) in front of Lemma 16.18 *)"], ["", "lemma d_approx_main: assumes i: \"ii \\<le> m\" \"m \\<noteq> 0\" \nshows \"rat_of_int (d fs ii) \\<le> rat_of_nat (N^ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "note inv = LLL_inv_wD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "from LLL_inv_N_pos i"], ["proof (chain)\npicking this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  ii \\<le> m\n  m \\<noteq> 0", "have A: \"0 < N\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  ii \\<le> m\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "note main = inv(2)[unfolded gram_schmidt_int_def gram_schmidt_wit_def]"], ["proof (state)\nthis:\n  length (map of_int_hom.vec_hom fs) = m\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "have \"rat_of_int (d fs ii) = (\\<Prod>j<ii. \\<parallel>gso fs j\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) =\n    (\\<Prod>j<ii. \\<parallel>gs1.gso j\\<parallel>\\<^sup>2)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs ii) =\n    (\\<Prod>j<ii. \\<parallel>gs1.gso j\\<parallel>\\<^sup>2)", "using i"], ["proof (prove)\nusing this:\n  ii \\<le> m\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs ii) =\n    (\\<Prod>j<ii. \\<parallel>gs1.gso j\\<parallel>\\<^sup>2)", "by (auto simp: Gramian_determinant [OF Linv])"], ["proof (state)\nthis:\n  rat_of_int (d fs ii) =\n  (\\<Prod>j<ii. \\<parallel>gs1.gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs ii) =\n  (\\<Prod>j<ii. \\<parallel>gs1.gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "have \"\\<dots> \\<le> (\\<Prod>j<ii. of_nat N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<ii. \\<parallel>gs1.gso j\\<parallel>\\<^sup>2)\n    \\<le> (\\<Prod>j<ii. rat_of_nat N)", "using i"], ["proof (prove)\nusing this:\n  ii \\<le> m\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>j<ii. \\<parallel>gs1.gso j\\<parallel>\\<^sup>2)\n    \\<le> (\\<Prod>j<ii. rat_of_nat N)", "by (intro prod_mono ballI conjI prod_nonneg, insert gbnd[unfolded g_bound_def], auto)"], ["proof (state)\nthis:\n  (\\<Prod>j<ii. \\<parallel>gs1.gso j\\<parallel>\\<^sup>2)\n  \\<le> (\\<Prod>j<ii. rat_of_nat N)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "also"], ["proof (state)\nthis:\n  (\\<Prod>j<ii. \\<parallel>gs1.gso j\\<parallel>\\<^sup>2)\n  \\<le> (\\<Prod>j<ii. rat_of_nat N)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "have \"\\<dots> = (of_nat N)^ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<ii. rat_of_nat N) = rat_of_nat N ^ ii", "unfolding prod_constant"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat N ^ card {..<ii} = rat_of_nat N ^ ii", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>j<ii. rat_of_nat N) = rat_of_nat N ^ ii\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "also"], ["proof (state)\nthis:\n  (\\<Prod>j<ii. rat_of_nat N) = rat_of_nat N ^ ii\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "have \"\\<dots> = of_nat (N^ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat N ^ ii = rat_of_nat (N ^ ii)", "by simp"], ["proof (state)\nthis:\n  rat_of_nat N ^ ii = rat_of_nat (N ^ ii)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_approx: assumes i: \"ii < m\"  \n  shows \"rat_of_int (d fs ii) \\<le> rat_of_nat (N^ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "using d_approx_main[of ii] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>ii \\<le> m; m \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)\n  ii < m\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)", "by auto"], ["", "lemma d_bound: assumes i: \"ii < m\" \n  shows \"d fs ii \\<le> N^ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d fs ii \\<le> int (N ^ ii)", "using d_approx[OF assms]"], ["proof (prove)\nusing this:\n  rat_of_int (d fs ii) \\<le> rat_of_nat (N ^ ii)\n\ngoal (1 subgoal):\n 1. d fs ii \\<le> int (N ^ ii)", "unfolding d_def"], ["proof (prove)\nusing this:\n  rat_of_int (gs.Gramian_determinant fs ii) \\<le> rat_of_nat (N ^ ii)\n\ngoal (1 subgoal):\n 1. gs.Gramian_determinant fs ii \\<le> int (N ^ ii)", "by linarith"], ["", "lemma D_approx: \"D fs \\<le> N ^ (m * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "note inv = LLL_inv_wD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "from LLL_inv_N_pos"], ["proof (chain)\npicking this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N", "have N: \"m \\<noteq> 0 \\<Longrightarrow> 0 < N\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> 0 < N", "by auto"], ["proof (state)\nthis:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "note main = inv(2)[unfolded gram_schmidt_int_def gram_schmidt_wit_def]"], ["proof (state)\nthis:\n  length (map of_int_hom.vec_hom fs) = m\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "have \"rat_of_int (\\<Prod>i<m. d fs i) = (\\<Prod>i<m. rat_of_int (d fs i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (prod (d fs) {..<m}) = (\\<Prod>i<m. rat_of_int (d fs i))", "by simp"], ["proof (state)\nthis:\n  rat_of_int (prod (d fs) {..<m}) = (\\<Prod>i<m. rat_of_int (d fs i))\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "also"], ["proof (state)\nthis:\n  rat_of_int (prod (d fs) {..<m}) = (\\<Prod>i<m. rat_of_int (d fs i))\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "have \"\\<dots> \\<le> (\\<Prod>i<m. (of_nat N) ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<m. rat_of_int (d fs i)) \\<le> prod ((^) (rat_of_nat N)) {..<m}", "by (rule prod_mono, insert d_approx LLL_d_pos[OF Linv], auto simp: less_le)"], ["proof (state)\nthis:\n  (\\<Prod>i<m. rat_of_int (d fs i)) \\<le> prod ((^) (rat_of_nat N)) {..<m}\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i<m. rat_of_int (d fs i)) \\<le> prod ((^) (rat_of_nat N)) {..<m}\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "have \"\\<dots> \\<le> (\\<Prod>i<m. (of_nat N ^ m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod ((^) (rat_of_nat N)) {..<m} \\<le> (\\<Prod>i<m. rat_of_nat N ^ m)", "by (rule prod_mono, insert N, auto intro: pow_mono_exp)"], ["proof (state)\nthis:\n  prod ((^) (rat_of_nat N)) {..<m} \\<le> (\\<Prod>i<m. rat_of_nat N ^ m)\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "also"], ["proof (state)\nthis:\n  prod ((^) (rat_of_nat N)) {..<m} \\<le> (\\<Prod>i<m. rat_of_nat N ^ m)\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "have \"\\<dots> = (of_nat N)^(m * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<m. rat_of_nat N ^ m) = rat_of_nat N ^ (m * m)", "unfolding prod_constant power_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_nat N ^ m) ^ card {..<m} = (rat_of_nat N ^ m) ^ m", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>i<m. rat_of_nat N ^ m) = rat_of_nat N ^ (m * m)\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i<m. rat_of_nat N ^ m) = rat_of_nat N ^ (m * m)\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "have \"\\<dots> = of_nat (N ^ (m * m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat N ^ (m * m) = rat_of_nat (N ^ (m * m))", "by simp"], ["proof (state)\nthis:\n  rat_of_nat N ^ (m * m) = rat_of_nat (N ^ (m * m))\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (prod (d fs) {..<m}) \\<le> rat_of_nat (N ^ (m * m))", "have \"(\\<Prod>i<m. d fs i) \\<le> N ^ (m * m)\""], ["proof (prove)\nusing this:\n  rat_of_int (prod (d fs) {..<m}) \\<le> rat_of_nat (N ^ (m * m))\n\ngoal (1 subgoal):\n 1. prod (d fs) {..<m} \\<le> int (N ^ (m * m))", "by linarith"], ["proof (state)\nthis:\n  prod (d fs) {..<m} \\<le> int (N ^ (m * m))\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "also"], ["proof (state)\nthis:\n  prod (d fs) {..<m} \\<le> int (N ^ (m * m))\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "have \"(\\<Prod>i<m. d fs i) = D fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (d fs) {..<m} = int (D fs)", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (d fs) {..<m} = int (nat (prod (d fs) {..<m}))", "by (subst nat_0_le, rule prod_nonneg, insert LLL_d_pos[OF Linv], auto simp: le_less)"], ["proof (state)\nthis:\n  prod (d fs) {..<m} = int (D fs)\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "finally"], ["proof (chain)\npicking this:\n  int (D fs) \\<le> int (N ^ (m * m))", "show \"D fs \\<le> N ^ (m * m)\""], ["proof (prove)\nusing this:\n  int (D fs) \\<le> int (N ^ (m * m))\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "by linarith"], ["proof (state)\nthis:\n  D fs \\<le> N ^ (m * m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_measure_approx: assumes \"\\<alpha> > 4/3\" \"m \\<noteq> 0\" \nshows \"LLL_measure i fs \\<le> m + 2 * m * m * log base N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "have b1: \"base > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < base", "using base assms"], ["proof (prove)\nusing this:\n  4 / 3 < \\<alpha> \\<Longrightarrow> 1 < base\n  4 / 3 < \\<alpha>\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 < base", "by auto"], ["proof (state)\nthis:\n  1 < base\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "have id: \"base = 1 / real_of_rat reduction\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base = 1 / real_of_rat reduction", "unfolding base_def reduction_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)) =\n    1 / real_of_rat ((4 + \\<alpha>) / (4 * \\<alpha>))", "using \\<alpha>0"], ["proof (prove)\nusing this:\n  0 < \\<alpha>\n  \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)) =\n    1 / real_of_rat ((4 + \\<alpha>) / (4 * \\<alpha>))", "by\n    (auto simp: field_simps of_rat_divide)"], ["proof (state)\nthis:\n  base = 1 / real_of_rat reduction\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "from LLL_D_pos[OF Linv]"], ["proof (chain)\npicking this:\n  0 < D fs", "have D1: \"real (D fs) \\<ge> 1\""], ["proof (prove)\nusing this:\n  0 < D fs\n\ngoal (1 subgoal):\n 1. 1 \\<le> real (D fs)", "by auto"], ["proof (state)\nthis:\n  1 \\<le> real (D fs)\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "note invD = LLL_inv_wD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "from invD"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L", "have F: \"set fs \\<subseteq> carrier_vec n\" and len: \"length fs = m\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. set fs \\<subseteq> carrier_vec n &&& length fs = m", "by auto"], ["proof (state)\nthis:\n  set fs \\<subseteq> carrier_vec n\n  length fs = m\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "have N0: \"N > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < N", "using LLL_inv_N_pos[OF assms(2)]"], ["proof (prove)\nusing this:\n  0 < N\n\ngoal (1 subgoal):\n 1. 0 < N", "."], ["proof (state)\nthis:\n  0 < N\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "from D_approx"], ["proof (chain)\npicking this:\n  D fs \\<le> N ^ (m * m)", "have D: \"D fs \\<le> N ^ (m * m)\""], ["proof (prove)\nusing this:\n  D fs \\<le> N ^ (m * m)\n\ngoal (1 subgoal):\n 1. D fs \\<le> N ^ (m * m)", "."], ["proof (state)\nthis:\n  D fs \\<le> N ^ (m * m)\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "hence \"real (D fs) \\<le> real (N ^ (m * m))\""], ["proof (prove)\nusing this:\n  D fs \\<le> N ^ (m * m)\n\ngoal (1 subgoal):\n 1. real (D fs) \\<le> real (N ^ (m * m))", "by linarith"], ["proof (state)\nthis:\n  real (D fs) \\<le> real (N ^ (m * m))\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "also"], ["proof (state)\nthis:\n  real (D fs) \\<le> real (N ^ (m * m))\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "have \"\\<dots> = real N ^ (m * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (N ^ (m * m)) = real N ^ (m * m)", "by simp"], ["proof (state)\nthis:\n  real (N ^ (m * m)) = real N ^ (m * m)\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "finally"], ["proof (chain)\npicking this:\n  real (D fs) \\<le> real N ^ (m * m)", "have log: \"log base (real (D fs)) \\<le> log base (real N ^ (m * m))\""], ["proof (prove)\nusing this:\n  real (D fs) \\<le> real N ^ (m * m)\n\ngoal (1 subgoal):\n 1. log base (real (D fs)) \\<le> log base (real N ^ (m * m))", "by (subst log_le_cancel_iff[OF b1], insert D1 N0, auto)"], ["proof (state)\nthis:\n  log base (real (D fs)) \\<le> log base (real N ^ (m * m))\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "have \"real (logD fs) = real (nat \\<lfloor>log base (real (D fs))\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (logD fs) = real (nat \\<lfloor>log base (real (D fs))\\<rfloor>)", "unfolding logD_def id"], ["proof (prove)\ngoal (1 subgoal):\n 1. real\n     (if \\<alpha> = 4 / 3 then D fs\n      else nat \\<lfloor>log (1 / real_of_rat reduction)\n                         (real (D fs))\\<rfloor>) =\n    real\n     (nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs))\\<rfloor>)", "using assms"], ["proof (prove)\nusing this:\n  4 / 3 < \\<alpha>\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real\n     (if \\<alpha> = 4 / 3 then D fs\n      else nat \\<lfloor>log (1 / real_of_rat reduction)\n                         (real (D fs))\\<rfloor>) =\n    real\n     (nat \\<lfloor>log (1 / real_of_rat reduction) (real (D fs))\\<rfloor>)", "by auto"], ["proof (state)\nthis:\n  real (logD fs) = real (nat \\<lfloor>log base (real (D fs))\\<rfloor>)\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "also"], ["proof (state)\nthis:\n  real (logD fs) = real (nat \\<lfloor>log base (real (D fs))\\<rfloor>)\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "have \"\\<dots> \\<le> log base (real (D fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (nat \\<lfloor>log base (real (D fs))\\<rfloor>)\n    \\<le> log base (real (D fs))", "using b1 D1"], ["proof (prove)\nusing this:\n  1 < base\n  1 \\<le> real (D fs)\n\ngoal (1 subgoal):\n 1. real (nat \\<lfloor>log base (real (D fs))\\<rfloor>)\n    \\<le> log base (real (D fs))", "by auto"], ["proof (state)\nthis:\n  real (nat \\<lfloor>log base (real (D fs))\\<rfloor>)\n  \\<le> log base (real (D fs))\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "also"], ["proof (state)\nthis:\n  real (nat \\<lfloor>log base (real (D fs))\\<rfloor>)\n  \\<le> log base (real (D fs))\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "have \"\\<dots> \\<le> log base (real N ^ (m * m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log base (real (D fs)) \\<le> log base (real N ^ (m * m))", "by fact"], ["proof (state)\nthis:\n  log base (real (D fs)) \\<le> log base (real N ^ (m * m))\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "also"], ["proof (state)\nthis:\n  log base (real (D fs)) \\<le> log base (real N ^ (m * m))\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "have \"\\<dots> = (m * m) * log base (real N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log base (real N ^ (m * m)) = real (m * m) * log base (real N)", "by (rule log_nat_power, insert N0, auto)"], ["proof (state)\nthis:\n  log base (real N ^ (m * m)) = real (m * m) * log base (real N)\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "finally"], ["proof (chain)\npicking this:\n  real (logD fs) \\<le> real (m * m) * log base (real N)", "have main: \"logD fs \\<le> m * m * log base N\""], ["proof (prove)\nusing this:\n  real (logD fs) \\<le> real (m * m) * log base (real N)\n\ngoal (1 subgoal):\n 1. real (logD fs) \\<le> real (m * m) * log base (real N)", "by simp"], ["proof (state)\nthis:\n  real (logD fs) \\<le> real (m * m) * log base (real N)\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "have \"real (LLL_measure i fs) = real (2 * logD fs + m - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (LLL_measure i fs) = real (2 * logD fs + m - i)", "unfolding LLL_measure_def split invD(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 * logD fs + m - i) = real (2 * logD fs + m - i)", "by simp"], ["proof (state)\nthis:\n  real (LLL_measure i fs) = real (2 * logD fs + m - i)\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "also"], ["proof (state)\nthis:\n  real (LLL_measure i fs) = real (2 * logD fs + m - i)\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "have \"\\<dots> \\<le> 2 * real (logD fs) + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 * logD fs + m - i) \\<le> 2 * real (logD fs) + real m", "using invD"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. real (2 * logD fs + m - i) \\<le> 2 * real (logD fs) + real m", "by simp"], ["proof (state)\nthis:\n  real (2 * logD fs + m - i) \\<le> 2 * real (logD fs) + real m\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "also"], ["proof (state)\nthis:\n  real (2 * logD fs + m - i) \\<le> 2 * real (logD fs) + real m\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "have \"\\<dots> \\<le> 2 * (m * m * log base N) + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * real (logD fs) + real m\n    \\<le> 2 * (real (m * m) * log base (real N)) + real m", "using main"], ["proof (prove)\nusing this:\n  real (logD fs) \\<le> real (m * m) * log base (real N)\n\ngoal (1 subgoal):\n 1. 2 * real (logD fs) + real m\n    \\<le> 2 * (real (m * m) * log base (real N)) + real m", "by auto"], ["proof (state)\nthis:\n  2 * real (logD fs) + real m\n  \\<le> 2 * (real (m * m) * log base (real N)) + real m\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "finally"], ["proof (chain)\npicking this:\n  real (LLL_measure i fs)\n  \\<le> 2 * (real (m * m) * log base (real N)) + real m", "show ?thesis"], ["proof (prove)\nusing this:\n  real (LLL_measure i fs)\n  \\<le> 2 * (real (m * m) * log base (real N)) + real m\n\ngoal (1 subgoal):\n 1. real (LLL_measure i fs)\n    \\<le> real m + real (2 * m * m) * log base (real N)", "by simp"], ["proof (state)\nthis:\n  real (LLL_measure i fs)\n  \\<le> real m + real (2 * m * m) * log base (real N)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma g_bound_fs_init: \"g_bound fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_bound fs_init", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g_bound fs_init", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. g_bound fs_init", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. g_bound fs_init", "assume i: \"i < m\""], ["proof (state)\nthis:\n  i < m\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "let ?N = \"map (nat o sq_norm) fs_init\""], ["proof (state)\ngoal (1 subgoal):\n 1. g_bound fs_init", "let ?r = rat_of_int"], ["proof (state)\ngoal (1 subgoal):\n 1. g_bound fs_init", "from i"], ["proof (chain)\npicking this:\n  i < m", "have mem: \"nat (sq_norm (fs_init ! i)) \\<in> set ?N\""], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n    \\<in> set (map (nat \\<circ> sq_norm) fs_init)", "using fs_init len"], ["proof (prove)\nusing this:\n  i < m\n  set fs_init \\<subseteq> carrier_vec n\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n    \\<in> set (map (nat \\<circ> sq_norm) fs_init)", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  i < m\n  {fs_init ! i |i. i < length fs_init} \\<subseteq> carrier_vec n\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n    \\<in> {map (nat \\<circ> sq_norm) fs_init ! i |i.\n           i < length (map (nat \\<circ> sq_norm) fs_init)}", "by force"], ["proof (state)\nthis:\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n  \\<in> set (map (nat \\<circ> sq_norm) fs_init)\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "interpret gs: gram_schmidt_fs_lin_indpt n \"RAT fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_lin_indpt n (map of_int_hom.vec_hom fs_init)", "by (standard) (use len lin_dep LLL_invariant_def gs.lin_indpt_list_def in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. g_bound fs_init", "from mem_set_imp_le_max_list[OF _ mem]"], ["proof (chain)\npicking this:\n  (\\<And>a b.\n      \\<lbrakk>a \\<in> set (map (nat \\<circ> sq_norm) fs_init);\n       b \\<in> set (map (nat \\<circ> sq_norm) fs_init)\\<rbrakk>\n      \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a) \\<Longrightarrow>\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init)", "have FN: \"nat (sq_norm (fs_init ! i)) \\<le> N\""], ["proof (prove)\nusing this:\n  (\\<And>a b.\n      \\<lbrakk>a \\<in> set (map (nat \\<circ> sq_norm) fs_init);\n       b \\<in> set (map (nat \\<circ> sq_norm) fs_init)\\<rbrakk>\n      \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a) \\<Longrightarrow>\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init)\n\ngoal (1 subgoal):\n 1. nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> N", "unfolding N_def"], ["proof (prove)\nusing this:\n  (\\<And>a b.\n      \\<lbrakk>a \\<in> set (map (nat \\<circ> sq_norm) fs_init);\n       b \\<in> set (map (nat \\<circ> sq_norm) fs_init)\\<rbrakk>\n      \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a) \\<Longrightarrow>\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init)\n\ngoal (1 subgoal):\n 1. nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n    \\<le> Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init)", "by force"], ["proof (state)\nthis:\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> N\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "hence \"\\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int N\""], ["proof (prove)\nusing this:\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> N\n\ngoal (1 subgoal):\n 1. \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int N", "using i"], ["proof (prove)\nusing this:\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> N\n  i < m\n\ngoal (1 subgoal):\n 1. \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int N", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int N\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "also"], ["proof (state)\nthis:\n  \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int N\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "have \"\\<dots> \\<le> int (N * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int N \\<le> int (N * m)", "using i"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. int N \\<le> int (N * m)", "by fastforce"], ["proof (state)\nthis:\n  int N \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)", "have f_bnd:  \"\\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)\""], ["proof (prove)\nusing this:\n  \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)", "."], ["proof (state)\nthis:\n  \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "from FN"], ["proof (chain)\npicking this:\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> N", "have \"rat_of_nat (nat (sq_norm (fs_init ! i))) \\<le> rat_of_nat N\""], ["proof (prove)\nusing this:\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> N\n\ngoal (1 subgoal):\n 1. rat_of_nat (nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2)\n    \\<le> rat_of_nat N", "by simp"], ["proof (state)\nthis:\n  rat_of_nat (nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2)\n  \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "also"], ["proof (state)\nthis:\n  rat_of_nat (nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2)\n  \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "have \"rat_of_nat (nat (sq_norm (fs_init ! i))) = ?r (sq_norm (fs_init ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2) =\n    rat_of_int \\<parallel>fs_init ! i\\<parallel>\\<^sup>2", "using sq_norm_vec_ge_0[of \"fs_init ! i\"]"], ["proof (prove)\nusing this:\n  0 \\<le> \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. rat_of_nat (nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2) =\n    rat_of_int \\<parallel>fs_init ! i\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  rat_of_nat (nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2) =\n  rat_of_int \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "also"], ["proof (state)\nthis:\n  rat_of_nat (nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2) =\n  rat_of_int \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "have \"\\<dots> = sq_norm (RAT fs_init ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 =\n    \\<parallel>map of_int_hom.vec_hom fs_init ! i\\<parallel>\\<^sup>2", "unfolding sq_norm_of_int[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>of_int_hom.vec_hom (fs_init ! i)\\<parallel>\\<^sup>2 =\n    \\<parallel>map of_int_hom.vec_hom fs_init ! i\\<parallel>\\<^sup>2", "using fs_init len i"], ["proof (prove)\nusing this:\n  set fs_init \\<subseteq> carrier_vec n\n  length fs_init = m\n  i < m\n\ngoal (1 subgoal):\n 1. \\<parallel>of_int_hom.vec_hom (fs_init ! i)\\<parallel>\\<^sup>2 =\n    \\<parallel>map of_int_hom.vec_hom fs_init ! i\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  rat_of_int \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 =\n  \\<parallel>map of_int_hom.vec_hom fs_init ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>map of_int_hom.vec_hom fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat N", "have \"sq_norm (RAT fs_init ! i) \\<le> rat_of_nat N\""], ["proof (prove)\nusing this:\n  \\<parallel>map of_int_hom.vec_hom fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. \\<parallel>map of_int_hom.vec_hom fs_init ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat N", "."], ["proof (state)\nthis:\n  \\<parallel>map of_int_hom.vec_hom fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "with gs.sq_norm_gso_le_f i len lin_dep"], ["proof (chain)\npicking this:\n  ?i < length (map of_int_hom.vec_hom fs_init) \\<Longrightarrow>\n  \\<parallel>gs.gso ?i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>map of_int_hom.vec_hom fs_init ! ?i\\<parallel>\\<^sup>2\n  i < m\n  length fs_init = m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)\n  \\<parallel>map of_int_hom.vec_hom fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat N", "have g_bnd: \"\\<parallel>gs.gso i\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\""], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs_init) \\<Longrightarrow>\n  \\<parallel>gs.gso ?i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>map of_int_hom.vec_hom fs_init ! ?i\\<parallel>\\<^sup>2\n  i < m\n  length fs_init = m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)\n  \\<parallel>map of_int_hom.vec_hom fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. \\<parallel>gs.gso i\\<parallel>\\<^sup>2 \\<le> rat_of_nat N", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs_init) \\<Longrightarrow>\n  \\<parallel>gs.gso ?i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>map of_int_hom.vec_hom fs_init ! ?i\\<parallel>\\<^sup>2\n  i < m\n  length fs_init = m\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs_init) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n  \\<parallel>map of_int_hom.vec_hom fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. \\<parallel>gs.gso i\\<parallel>\\<^sup>2 \\<le> rat_of_nat N", "by fastforce"], ["proof (state)\nthis:\n  \\<parallel>gs.gso i\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "note f_bnd g_bnd"], ["proof (state)\nthis:\n  \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)\n  \\<parallel>gs.gso i\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "}"], ["proof (state)\nthis:\n  ?i3 < m \\<Longrightarrow>\n  \\<parallel>fs_init ! ?i3\\<parallel>\\<^sup>2 \\<le> int (N * m)\n  ?i3 < m \\<Longrightarrow>\n  \\<parallel>gs.gso ?i3\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "thus \"g_bound fs_init\""], ["proof (prove)\nusing this:\n  ?i3 < m \\<Longrightarrow>\n  \\<parallel>fs_init ! ?i3\\<parallel>\\<^sup>2 \\<le> int (N * m)\n  ?i3 < m \\<Longrightarrow>\n  \\<parallel>gs.gso ?i3\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. g_bound fs_init", "unfolding g_bound_def"], ["proof (prove)\nusing this:\n  ?i3 < m \\<Longrightarrow>\n  \\<parallel>fs_init ! ?i3\\<parallel>\\<^sup>2 \\<le> int (N * m)\n  ?i3 < m \\<Longrightarrow>\n  \\<parallel>gs.gso ?i3\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. \\<forall>i<m. \\<parallel>gs.gso i\\<parallel>\\<^sup>2 \\<le> rat_of_nat N", "by auto"], ["proof (state)\nthis:\n  g_bound fs_init\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_measure_approx_fs_init: \n  \"LLL_invariant upw i fs_init \\<Longrightarrow> 4 / 3 < \\<alpha> \\<Longrightarrow> m \\<noteq> 0 \\<Longrightarrow> \n  real (LLL_measure i fs_init) \\<le> real m + real (2 * m * m) * log base (real N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LLL_invariant upw i fs_init; 4 / 3 < \\<alpha>;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> real (LLL_measure i fs_init)\n                      \\<le> real m + real (2 * m * m) * log base (real N)", "using LLL_measure_approx[OF LLL_inv_imp_w g_bound_fs_init]"], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_invariant ?upw1 ?i1 fs_init; 4 / 3 < \\<alpha>;\n   m \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> real (LLL_measure ?i fs_init)\n                    \\<le> real m + real (2 * m * m) * log base (real N)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>LLL_invariant upw i fs_init; 4 / 3 < \\<alpha>;\n     m \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> real (LLL_measure i fs_init)\n                      \\<le> real m + real (2 * m * m) * log base (real N)", "."], ["", "lemma N_le_MMn: assumes m0: \"m \\<noteq> 0\" \n  shows \"N \\<le> nat M * nat M * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<le> nat M * nat M * n", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init)\n    \\<le> nat M * nat M * n", "proof (rule max_list_le, unfold set_map o_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "fix ni"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "assume \"ni \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) ` set fs_init\""], ["proof (state)\nthis:\n  ni \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) ` set fs_init\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "then"], ["proof (chain)\npicking this:\n  ni \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) ` set fs_init", "obtain fi where ni: \"ni = nat (\\<parallel>fi\\<parallel>\\<^sup>2)\" and fi: \"fi \\<in> set fs_init\""], ["proof (prove)\nusing this:\n  ni \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) ` set fs_init\n\ngoal (1 subgoal):\n 1. (\\<And>fi.\n        \\<lbrakk>ni = nat \\<parallel>fi\\<parallel>\\<^sup>2;\n         fi \\<in> set fs_init\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ni = nat \\<parallel>fi\\<parallel>\\<^sup>2\n  fi \\<in> set fs_init\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "from fi len"], ["proof (chain)\npicking this:\n  fi \\<in> set fs_init\n  length fs_init = m", "obtain i where fii: \"fi = fs_init ! i\" and i: \"i < m\""], ["proof (prove)\nusing this:\n  fi \\<in> set fs_init\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>fi = fs_init ! i; i < m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  fi \\<in> {fs_init ! i |i. i < length fs_init}\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>fi = fs_init ! i; i < m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fi = fs_init ! i\n  i < m\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "from fi fs_init"], ["proof (chain)\npicking this:\n  fi \\<in> set fs_init\n  set fs_init \\<subseteq> carrier_vec n", "have fi: \"fi \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  fi \\<in> set fs_init\n  set fs_init \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. fi \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  fi \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "let ?set = \"{\\<bar>fs_init ! i $ j\\<bar> |i j. i < m \\<and> j < n} \\<union> {0}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "have id: \"?set = (\\<lambda> (i,j). abs (fs_init ! i $ j)) ` ({0..<m} \\<times> {0..<n}) \\<union> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<bar>fs_init ! i $ j\\<bar> |i j. i < m \\<and> j < n} \\<union> {0} =\n    (\\<lambda>(i, j). \\<bar>fs_init ! i $ j\\<bar>) `\n    ({0..<m} \\<times> {0..<n}) \\<union>\n    {0}", "by force"], ["proof (state)\nthis:\n  {\\<bar>fs_init ! i $ j\\<bar> |i j. i < m \\<and> j < n} \\<union> {0} =\n  (\\<lambda>(i, j). \\<bar>fs_init ! i $ j\\<bar>) `\n  ({0..<m} \\<times> {0..<n}) \\<union>\n  {0}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "have fin: \"finite ?set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({\\<bar>fs_init ! i $ j\\<bar> |i j. i < m \\<and> j < n} \\<union> {0})", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(i, j). \\<bar>fs_init ! i $ j\\<bar>) `\n      ({0..<m} \\<times> {0..<n}) \\<union>\n      {0})", "by auto"], ["proof (state)\nthis:\n  finite\n   ({\\<bar>fs_init ! i $ j\\<bar> |i j. i < m \\<and> j < n} \\<union> {0})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "{"], ["proof (state)\nthis:\n  finite\n   ({\\<bar>fs_init ! i $ j\\<bar> |i j. i < m \\<and> j < n} \\<union> {0})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "assume \"j < n\""], ["proof (state)\nthis:\n  j < n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "hence \"M \\<ge> \\<bar>fs_init ! i $ j\\<bar>\""], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. \\<bar>fs_init ! i $ j\\<bar> \\<le> M", "unfolding M_def"], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. \\<bar>fs_init ! i $ j\\<bar>\n    \\<le> Max ({\\<bar>fs_init ! i $ j\\<bar> |i j.\n                i < m \\<and> j < n} \\<union>\n               {0})", "using i"], ["proof (prove)\nusing this:\n  j < n\n  i < m\n\ngoal (1 subgoal):\n 1. \\<bar>fs_init ! i $ j\\<bar>\n    \\<le> Max ({\\<bar>fs_init ! i $ j\\<bar> |i j.\n                i < m \\<and> j < n} \\<union>\n               {0})", "by (intro Max_ge[of _ \"abs (fs_init ! i $ j)\"], intro fin, auto)"], ["proof (state)\nthis:\n  \\<bar>fs_init ! i $ j\\<bar> \\<le> M\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "}"], ["proof (state)\nthis:\n  ?j3 < n \\<Longrightarrow> \\<bar>fs_init ! i $ ?j3\\<bar> \\<le> M\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "note M = this"], ["proof (state)\nthis:\n  ?j3 < n \\<Longrightarrow> \\<bar>fs_init ! i $ ?j3\\<bar> \\<le> M\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "from Max_ge[OF fin, of 0]"], ["proof (chain)\npicking this:\n  0 \\<in> {\\<bar>fs_init ! i $ j\\<bar> |i j. i < m \\<and> j < n} \\<union>\n          {0} \\<Longrightarrow>\n  0 \\<le> Max ({\\<bar>fs_init ! i $ j\\<bar> |i j.\n                i < m \\<and> j < n} \\<union>\n               {0})", "have M0: \"M \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<in> {\\<bar>fs_init ! i $ j\\<bar> |i j. i < m \\<and> j < n} \\<union>\n          {0} \\<Longrightarrow>\n  0 \\<le> Max ({\\<bar>fs_init ! i $ j\\<bar> |i j.\n                i < m \\<and> j < n} \\<union>\n               {0})\n\ngoal (1 subgoal):\n 1. 0 \\<le> M", "unfolding M_def"], ["proof (prove)\nusing this:\n  0 \\<in> {\\<bar>fs_init ! i $ j\\<bar> |i j. i < m \\<and> j < n} \\<union>\n          {0} \\<Longrightarrow>\n  0 \\<le> Max ({\\<bar>fs_init ! i $ j\\<bar> |i j.\n                i < m \\<and> j < n} \\<union>\n               {0})\n\ngoal (1 subgoal):\n 1. 0 \\<le> Max ({\\<bar>fs_init ! i $ j\\<bar> |i j.\n                  i < m \\<and> j < n} \\<union>\n                 {0})", "by auto"], ["proof (state)\nthis:\n  0 \\<le> M\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "have \"ni = nat (\\<parallel>fi\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ni = nat \\<parallel>fi\\<parallel>\\<^sup>2", "unfolding ni"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<parallel>fi\\<parallel>\\<^sup>2 =\n    nat \\<parallel>fi\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  ni = nat \\<parallel>fi\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "also"], ["proof (state)\nthis:\n  ni = nat \\<parallel>fi\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "have \"\\<dots> \\<le> nat (int n * \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<parallel>fi\\<parallel>\\<^sup>2\n    \\<le> nat (int n * \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2)", "using sq_norm_vec_le_linf_norm[OF fi]"], ["proof (prove)\nusing this:\n  \\<parallel>fi\\<parallel>\\<^sup>2\n  \\<le> int n * \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2\n\ngoal (1 subgoal):\n 1. nat \\<parallel>fi\\<parallel>\\<^sup>2\n    \\<le> nat (int n * \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2)", "by (intro nat_mono, auto)"], ["proof (state)\nthis:\n  nat \\<parallel>fi\\<parallel>\\<^sup>2\n  \\<le> nat (int n * \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "also"], ["proof (state)\nthis:\n  nat \\<parallel>fi\\<parallel>\\<^sup>2\n  \\<le> nat (int n * \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "have \"\\<dots> = n * nat (\\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (int n * \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2) =\n    n * nat (\\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2)", "by (simp add: nat_mult_distrib)"], ["proof (state)\nthis:\n  nat (int n * \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2) =\n  n * nat (\\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "also"], ["proof (state)\nthis:\n  nat (int n * \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2) =\n  n * nat (\\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "have \"\\<dots> \\<le> n * nat (M^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * nat (\\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2)\n    \\<le> n * nat (M\\<^sup>2)", "proof (rule mult_left_mono[OF nat_mono])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2 \\<le> M\\<^sup>2\n 2. 0 \\<le> n", "have fi: \"\\<parallel>fi\\<parallel>\\<^sub>\\<infinity> \\<le> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fi\\<parallel>\\<^sub>\\<infinity> \\<le> M", "unfolding linf_norm_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list (map abs (list_of_vec fi) @ [0]) \\<le> M", "proof (rule max_list_le, unfold set_append set_map, rule ccontr)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> abs ` set (list_of_vec fi) \\<union> set [0];\n        \\<not> x \\<le> M\\<rbrakk>\n       \\<Longrightarrow> False\n 2. map abs (list_of_vec fi) @ [0] \\<noteq> []", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> abs ` set (list_of_vec fi) \\<union> set [0];\n        \\<not> x \\<le> M\\<rbrakk>\n       \\<Longrightarrow> False\n 2. map abs (list_of_vec fi) @ [0] \\<noteq> []", "assume \"x \\<in> abs ` set (list_of_vec fi) \\<union> set [0]\" and xM: \"\\<not> x \\<le> M\""], ["proof (state)\nthis:\n  x \\<in> abs ` set (list_of_vec fi) \\<union> set [0]\n  \\<not> x \\<le> M\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> abs ` set (list_of_vec fi) \\<union> set [0];\n        \\<not> x \\<le> M\\<rbrakk>\n       \\<Longrightarrow> False\n 2. map abs (list_of_vec fi) @ [0] \\<noteq> []", "with M0"], ["proof (chain)\npicking this:\n  0 \\<le> M\n  x \\<in> abs ` set (list_of_vec fi) \\<union> set [0]\n  \\<not> x \\<le> M", "obtain fij where fij: \"fij \\<in> set (list_of_vec fi)\" and x: \"x = abs fij\""], ["proof (prove)\nusing this:\n  0 \\<le> M\n  x \\<in> abs ` set (list_of_vec fi) \\<union> set [0]\n  \\<not> x \\<le> M\n\ngoal (1 subgoal):\n 1. (\\<And>fij.\n        \\<lbrakk>fij \\<in> set (list_of_vec fi);\n         x = \\<bar>fij\\<bar>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fij \\<in> set (list_of_vec fi)\n  x = \\<bar>fij\\<bar>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> abs ` set (list_of_vec fi) \\<union> set [0];\n        \\<not> x \\<le> M\\<rbrakk>\n       \\<Longrightarrow> False\n 2. map abs (list_of_vec fi) @ [0] \\<noteq> []", "from fij fi"], ["proof (chain)\npicking this:\n  fij \\<in> set (list_of_vec fi)\n  fi \\<in> carrier_vec n", "obtain j where j: \"j < n\" and fij: \"fij = fi $ j\""], ["proof (prove)\nusing this:\n  fij \\<in> set (list_of_vec fi)\n  fi \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < n; fij = fi $ j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_list_of_vec vec_set_def"], ["proof (prove)\nusing this:\n  fij \\<in> ($) fi ` {..<dim_vec fi}\n  fi \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < n; fij = fi $ j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j < n\n  fij = fi $ j\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> abs ` set (list_of_vec fi) \\<union> set [0];\n        \\<not> x \\<le> M\\<rbrakk>\n       \\<Longrightarrow> False\n 2. map abs (list_of_vec fi) @ [0] \\<noteq> []", "from M[OF j] xM[unfolded x fij fii]"], ["proof (chain)\npicking this:\n  \\<bar>fs_init ! i $ j\\<bar> \\<le> M\n  \\<not> \\<bar>fs_init ! i $ j\\<bar> \\<le> M", "show False"], ["proof (prove)\nusing this:\n  \\<bar>fs_init ! i $ j\\<bar> \\<le> M\n  \\<not> \\<bar>fs_init ! i $ j\\<bar> \\<le> M\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. map abs (list_of_vec fi) @ [0] \\<noteq> []", "qed auto"], ["proof (state)\nthis:\n  \\<parallel>fi\\<parallel>\\<^sub>\\<infinity> \\<le> M\n\ngoal (2 subgoals):\n 1. \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2 \\<le> M\\<^sup>2\n 2. 0 \\<le> n", "show \"\\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2 \\<le> M^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2 \\<le> M\\<^sup>2", "unfolding abs_le_square_iff[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<bar>\n    \\<le> \\<bar>M\\<bar>", "using fi"], ["proof (prove)\nusing this:\n  \\<parallel>fi\\<parallel>\\<^sub>\\<infinity> \\<le> M\n\ngoal (1 subgoal):\n 1. \\<bar>\\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<bar>\n    \\<le> \\<bar>M\\<bar>", "using linf_norm_vec_ge_0[of fi]"], ["proof (prove)\nusing this:\n  \\<parallel>fi\\<parallel>\\<^sub>\\<infinity> \\<le> M\n  0 \\<le> \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\n\ngoal (1 subgoal):\n 1. \\<bar>\\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<bar>\n    \\<le> \\<bar>M\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2 \\<le> M\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> n", "qed auto"], ["proof (state)\nthis:\n  n * nat (\\<parallel>fi\\<parallel>\\<^sub>\\<infinity>\\<^sup>2)\n  \\<le> n * nat (M\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) `\n               set fs_init \\<Longrightarrow>\n       x \\<le> nat M * nat M * n\n 2. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "finally"], ["proof (chain)\npicking this:\n  ni \\<le> n * nat (M\\<^sup>2)", "show \"ni \\<le> nat M * nat M * n\""], ["proof (prove)\nusing this:\n  ni \\<le> n * nat (M\\<^sup>2)\n\ngoal (1 subgoal):\n 1. ni \\<le> nat M * nat M * n", "using M0"], ["proof (prove)\nusing this:\n  ni \\<le> n * nat (M\\<^sup>2)\n  0 \\<le> M\n\ngoal (1 subgoal):\n 1. ni \\<le> nat M * nat M * n", "by (subst nat_mult_distrib[symmetric], auto simp: power2_eq_square ac_simps)"], ["proof (state)\nthis:\n  ni \\<le> nat M * nat M * n\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. nat \\<parallel>x\\<parallel>\\<^sup>2) fs_init \\<noteq>\n    []", "qed (insert m0 len, auto)"], ["", "subsection \\<open>Basic LLL implementation based on previous results\\<close>"], ["", "text \\<open>We now assemble a basic implementation of the LLL algorithm,\n  where only the lattice basis is updated, and where the GSO and the $\\mu$-values\n  are always computed from scratch. This enables a simple soundness proof \n  and permits to separate an efficient implementation from the soundness reasoning.\\<close>"], ["", "fun basis_reduction_add_rows_loop where\n  \"basis_reduction_add_rows_loop i fs 0 = fs\" \n| \"basis_reduction_add_rows_loop i fs (Suc j) = (\n     let c = round (\\<mu> fs i j);\n         fs' = (if c = 0 then fs else fs[ i := fs ! i - c \\<cdot>\\<^sub>v fs ! j])\n      in basis_reduction_add_rows_loop i fs' j)\""], ["", "definition basis_reduction_add_rows where\n  \"basis_reduction_add_rows upw i fs = \n     (if upw then basis_reduction_add_rows_loop i fs i else fs)\""], ["", "definition basis_reduction_swap where\n  \"basis_reduction_swap i fs = (False, i - 1, fs[i := fs ! (i - 1), i - 1 := fs ! i])\""], ["", "definition basis_reduction_step where\n  \"basis_reduction_step upw i fs = (if i = 0 then (True, Suc i, fs)\n     else let \n       fs' = basis_reduction_add_rows upw i fs\n     in if sq_norm (gso fs' (i - 1)) \\<le> \\<alpha> * sq_norm (gso fs' i) then\n          (True, Suc i, fs') \n        else basis_reduction_swap i fs')\""], ["", "function basis_reduction_main where\n  \"basis_reduction_main (upw,i,fs) = (if i < m \\<and> LLL_invariant upw i fs\n     then basis_reduction_main (basis_reduction_step upw i fs) else\n     fs)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>upw i fs.\n           x = (upw, i, fs) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>upw i fs upwa ia fsa.\n       (upw, i, fs) = (upwa, ia, fsa) \\<Longrightarrow>\n       (if i < m \\<and> LLL_invariant upw i fs\n        then basis_reduction_main_sumC (basis_reduction_step upw i fs)\n        else fs) =\n       (if ia < m \\<and> LLL_invariant upwa ia fsa\n        then basis_reduction_main_sumC (basis_reduction_step upwa ia fsa)\n        else fsa)", "by pat_completeness auto"], ["", "definition \"reduce_basis = basis_reduction_main (True, 0, fs_init)\""], ["", "definition \"short_vector = hd reduce_basis\""], ["", "text \\<open>Soundness of this implementation is easily proven\\<close>"], ["", "lemma basis_reduction_add_rows_loop: assumes \n  inv: \"LLL_invariant True i fs\" \n  and mu_small: \"\\<mu>_small_row i fs j\"\n  and res: \"basis_reduction_add_rows_loop i fs j = fs'\" \n  and i: \"i < m\" \n  and j: \"j \\<le> i\" \nshows \"LLL_invariant False i fs'\" \"LLL_measure i fs' = LLL_measure i fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' &&& LLL_measure i fs' = LLL_measure i fs", "proof (atomize(full), insert assms, induct j arbitrary: fs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fs.\n       \\<lbrakk>LLL_invariant True i fs; \\<mu>_small_row i fs 0;\n        basis_reduction_add_rows_loop i fs 0 = fs'; i < m;\n        0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                         LLL_measure i fs' = LLL_measure i fs\n 2. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                                     LLL_measure i fs' = LLL_measure i fs;\n        LLL_invariant True i fs; \\<mu>_small_row i fs (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                         LLL_measure i fs' = LLL_measure i fs", "case (0 fs)"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs 0\n  basis_reduction_add_rows_loop i fs 0 = fs'\n  i < m\n  0 \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>fs.\n       \\<lbrakk>LLL_invariant True i fs; \\<mu>_small_row i fs 0;\n        basis_reduction_add_rows_loop i fs 0 = fs'; i < m;\n        0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                         LLL_measure i fs' = LLL_measure i fs\n 2. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                                     LLL_measure i fs' = LLL_measure i fs;\n        LLL_invariant True i fs; \\<mu>_small_row i fs (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                         LLL_measure i fs' = LLL_measure i fs", "thus ?case"], ["proof (prove)\nusing this:\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs 0\n  basis_reduction_add_rows_loop i fs 0 = fs'\n  i < m\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "using basis_reduction_add_row_done[of i fs]"], ["proof (prove)\nusing this:\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs 0\n  basis_reduction_add_rows_loop i fs 0 = fs'\n  i < m\n  0 \\<le> i\n  \\<lbrakk>LLL_invariant True i fs; i < m; \\<mu>_small_row i fs 0\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant False i fs\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                                     LLL_measure i fs' = LLL_measure i fs;\n        LLL_invariant True i fs; \\<mu>_small_row i fs (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                         LLL_measure i fs' = LLL_measure i fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                                     LLL_measure i fs' = LLL_measure i fs;\n        LLL_invariant True i fs; \\<mu>_small_row i fs (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                         LLL_measure i fs' = LLL_measure i fs", "case (Suc j fs)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_invariant True i ?fs1; \\<mu>_small_row i ?fs1 j;\n   basis_reduction_add_rows_loop i ?fs1 j = fs'; i < m; j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                    LLL_measure i fs' = LLL_measure i ?fs1\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs (Suc j)\n  basis_reduction_add_rows_loop i fs (Suc j) = fs'\n  i < m\n  Suc j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                                     LLL_measure i fs' = LLL_measure i fs;\n        LLL_invariant True i fs; \\<mu>_small_row i fs (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                         LLL_measure i fs' = LLL_measure i fs", "hence j: \"j < i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_invariant True i ?fs1; \\<mu>_small_row i ?fs1 j;\n   basis_reduction_add_rows_loop i ?fs1 j = fs'; i < m; j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                    LLL_measure i fs' = LLL_measure i ?fs1\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs (Suc j)\n  basis_reduction_add_rows_loop i fs (Suc j) = fs'\n  i < m\n  Suc j \\<le> i\n\ngoal (1 subgoal):\n 1. j < i", "by auto"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                                     LLL_measure i fs' = LLL_measure i fs;\n        LLL_invariant True i fs; \\<mu>_small_row i fs (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                         LLL_measure i fs' = LLL_measure i fs", "let ?c = \"round (\\<mu> fs i j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                                     LLL_measure i fs' = LLL_measure i fs;\n        LLL_invariant True i fs; \\<mu>_small_row i fs (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                         LLL_measure i fs' = LLL_measure i fs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "proof (cases \"?c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) =\n    0 \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs\n 2. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "case True"], ["proof (state)\nthis:\n  round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) = 0\n\ngoal (2 subgoals):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) =\n    0 \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs\n 2. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "thus ?thesis"], ["proof (prove)\nusing this:\n  round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) = 0\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "using Suc(1)[OF Suc(2) basis_reduction_add_row_main_0[OF LLL_inv_imp_w[OF Suc(2)] i j True Suc(3)]]\n      Suc(2-)"], ["proof (prove)\nusing this:\n  round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) = 0\n  \\<lbrakk>basis_reduction_add_rows_loop i fs j = fs'; i < m;\n   j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                    LLL_measure i fs' = LLL_measure i fs\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs (Suc j)\n  basis_reduction_add_rows_loop i fs (Suc j) = fs'\n  i < m\n  Suc j \\<le> i\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs\n\ngoal (1 subgoal):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "case False"], ["proof (state)\nthis:\n  round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "note step = basis_reduction_add_row_main(2-)[OF LLL_inv_imp_w[OF Suc(2)] i j refl]"], ["proof (state)\nthis:\n  LLL_invariant True i fs \\<Longrightarrow>\n  LLL_invariant True i (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j])\n  \\<lbrakk>?c =\n           round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n   \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i\n                     (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) j\n  ?c =\n  round\n   (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n     j) \\<Longrightarrow>\n  \\<bar>gram_schmidt_fs.\\<mu> n\n         (map of_int_hom.vec_hom\n           (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]))\n         i j\\<bar>\n  \\<le> 1 / 2\n  LLL_measure i (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) =\n  LLL_measure i fs\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n\n   (map of_int_hom.vec_hom (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]))\n   ?i =\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i\n  \\<lbrakk>?i' < m; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                     (map of_int_hom.vec_hom\n                       (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]))\n                     ?i' ?j' =\n                    (if ?i' = i \\<and> ?j' \\<le> j\n                     then gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) i ?j' -\n                          rat_of_int ?c *\n                          gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) j ?j'\n                     else gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) ?i' ?j')\n  ?ii \\<le> m \\<Longrightarrow>\n  d (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) ?ii = d fs ?ii\n\ngoal (1 subgoal):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "note step = step(1)[OF Suc(2)] step(2-)"], ["proof (state)\nthis:\n  LLL_invariant True i (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j])\n  \\<lbrakk>?c =\n           round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n   \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i\n                     (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) j\n  ?c =\n  round\n   (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n     j) \\<Longrightarrow>\n  \\<bar>gram_schmidt_fs.\\<mu> n\n         (map of_int_hom.vec_hom\n           (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]))\n         i j\\<bar>\n  \\<le> 1 / 2\n  LLL_measure i (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) =\n  LLL_measure i fs\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n\n   (map of_int_hom.vec_hom (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]))\n   ?i =\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i\n  \\<lbrakk>?i' < m; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n\n                     (map of_int_hom.vec_hom\n                       (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]))\n                     ?i' ?j' =\n                    (if ?i' = i \\<and> ?j' \\<le> j\n                     then gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) i ?j' -\n                          rat_of_int ?c *\n                          gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) j ?j'\n                     else gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) ?i' ?j')\n  ?ii \\<le> m \\<Longrightarrow>\n  d (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) ?ii = d fs ?ii\n\ngoal (1 subgoal):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "using Suc(1)[OF step(1-2)] False Suc(2-) step(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?c2 =\n           round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n   \\<mu>_small_row i fs (Suc j);\n   basis_reduction_add_rows_loop i\n    (fs[i := fs ! i - ?c2 \\<cdot>\\<^sub>v fs ! j]) j =\n   fs';\n   i < m; j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant False i fs' \\<and>\n                    LLL_measure i fs' =\n                    LLL_measure i\n                     (fs[i := fs ! i - ?c2 \\<cdot>\\<^sub>v fs ! j])\n  round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq> 0\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs (Suc j)\n  basis_reduction_add_rows_loop i fs (Suc j) = fs'\n  i < m\n  Suc j \\<le> i\n  LLL_measure i (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) =\n  LLL_measure i fs\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "by simp"], ["proof (state)\nthis:\n  LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_add_rows: assumes \n  inv: \"LLL_invariant upw i fs\" \n  and res: \"basis_reduction_add_rows upw i fs = fs'\" \n  and i: \"i < m\" \nshows \"LLL_invariant False i fs'\" \"LLL_measure i fs' = LLL_measure i fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' &&& LLL_measure i fs' = LLL_measure i fs", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "note def = basis_reduction_add_rows_def"], ["proof (state)\nthis:\n  basis_reduction_add_rows ?upw ?i ?fs =\n  (if ?upw then basis_reduction_add_rows_loop ?i ?fs ?i else ?fs)\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "proof (cases upw)"], ["proof (state)\ngoal (2 subgoals):\n 1. upw \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs\n 2. \\<not> upw \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "case False"], ["proof (state)\nthis:\n  \\<not> upw\n\ngoal (2 subgoals):\n 1. upw \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs\n 2. \\<not> upw \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "with res inv"], ["proof (chain)\npicking this:\n  basis_reduction_add_rows upw i fs = fs'\n  LLL_invariant upw i fs\n  \\<not> upw", "show ?thesis"], ["proof (prove)\nusing this:\n  basis_reduction_add_rows upw i fs = fs'\n  LLL_invariant upw i fs\n  \\<not> upw\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "by (simp add: def)"], ["proof (state)\nthis:\n  LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "case True"], ["proof (state)\nthis:\n  upw\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "with inv"], ["proof (chain)\npicking this:\n  LLL_invariant upw i fs\n  upw", "have \"LLL_invariant True i fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw i fs\n  upw\n\ngoal (1 subgoal):\n 1. LLL_invariant True i fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "note start = this \\<mu>_small_row_refl[of i fs]"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs i\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "from res[unfolded def] True"], ["proof (chain)\npicking this:\n  (if upw then basis_reduction_add_rows_loop i fs i else fs) = fs'\n  upw", "have \"basis_reduction_add_rows_loop i fs i = fs'\""], ["proof (prove)\nusing this:\n  (if upw then basis_reduction_add_rows_loop i fs i else fs) = fs'\n  upw\n\ngoal (1 subgoal):\n 1. basis_reduction_add_rows_loop i fs i = fs'", "by auto"], ["proof (state)\nthis:\n  basis_reduction_add_rows_loop i fs i = fs'\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "from basis_reduction_add_rows_loop[OF start this i]"], ["proof (chain)\npicking this:\n  i \\<le> i \\<Longrightarrow> LLL_invariant False i fs'\n  i \\<le> i \\<Longrightarrow> LLL_measure i fs' = LLL_measure i fs", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> i \\<Longrightarrow> LLL_invariant False i fs'\n  i \\<le> i \\<Longrightarrow> LLL_measure i fs' = LLL_measure i fs\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_invariant False i fs' \\<and> LLL_measure i fs' = LLL_measure i fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_swap: assumes \n  inv: \"LLL_invariant False i fs\" \n  and res: \"basis_reduction_swap i fs = (upw',i',fs')\" \n  and cond: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\" \n  and i: \"i < m\" \"i \\<noteq> 0\" \nshows \"LLL_invariant upw' i' fs'\" (is ?g1)\n  \"LLL_measure i' fs' < LLL_measure i fs\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' &&& LLL_measure i' fs' < LLL_measure i fs", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_invariant upw' i' fs'\n 2. LLL_measure i' fs' < LLL_measure i fs", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (2 subgoals):\n 1. LLL_invariant upw' i' fs'\n 2. LLL_measure i' fs' < LLL_measure i fs", "note def = basis_reduction_swap_def"], ["proof (state)\nthis:\n  basis_reduction_swap ?i ?fs =\n  (False, ?i - 1, ?fs[?i := ?fs ! (?i - 1), ?i - 1 := ?fs ! ?i])\n\ngoal (2 subgoals):\n 1. LLL_invariant upw' i' fs'\n 2. LLL_measure i' fs' < LLL_measure i fs", "from res[unfolded basis_reduction_swap_def]"], ["proof (chain)\npicking this:\n  (False, i - 1, fs[i := fs ! (i - 1), i - 1 := fs ! i]) = (upw', i', fs')", "have id: \"upw' = False\" \"i' = i - 1\" \"fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]\""], ["proof (prove)\nusing this:\n  (False, i - 1, fs[i := fs ! (i - 1), i - 1 := fs ! i]) = (upw', i', fs')\n\ngoal (1 subgoal):\n 1. upw' = False &&&\n    i' = i - 1 &&& fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]", "by auto"], ["proof (state)\nthis:\n  upw' = False\n  i' = i - 1\n  fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]\n\ngoal (2 subgoals):\n 1. LLL_invariant upw' i' fs'\n 2. LLL_measure i' fs' < LLL_measure i fs", "from basis_reduction_swap_main(2-3)[OF invw _ i cond id(3)] inv"], ["proof (chain)\npicking this:\n  \\<lbrakk>LLL_invariant False i fs \\<or>\n           \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                  (i - 1)\\<bar>\n           \\<le> 1 / 2;\n   LLL_invariant False i fs\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant False (i - 1) fs'\n  LLL_invariant False i fs \\<or>\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1)\\<bar>\n  \\<le> 1 / 2 \\<Longrightarrow>\n  LLL_measure (i - 1) fs' < LLL_measure i fs\n  LLL_invariant False i fs", "show ?g1 ?g2"], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_invariant False i fs \\<or>\n           \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                  (i - 1)\\<bar>\n           \\<le> 1 / 2;\n   LLL_invariant False i fs\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant False (i - 1) fs'\n  LLL_invariant False i fs \\<or>\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1)\\<bar>\n  \\<le> 1 / 2 \\<Longrightarrow>\n  LLL_measure (i - 1) fs' < LLL_measure i fs\n  LLL_invariant False i fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' &&& LLL_measure i' fs' < LLL_measure i fs", "unfolding id"], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_invariant False i fs \\<or>\n           \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                  (i - 1)\\<bar>\n           \\<le> 1 / 2;\n   LLL_invariant False i fs\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant False (i - 1)\n                     (fs[i := fs ! (i - 1), i - 1 := fs ! i])\n  LLL_invariant False i fs \\<or>\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1)\\<bar>\n  \\<le> 1 / 2 \\<Longrightarrow>\n  LLL_measure (i - 1) (fs[i := fs ! (i - 1), i - 1 := fs ! i])\n  < LLL_measure i fs\n  LLL_invariant False i fs\n\ngoal (1 subgoal):\n 1. LLL_invariant False (i - 1) (fs[i := fs ! (i - 1), i - 1 := fs ! i]) &&&\n    LLL_measure (i - 1) (fs[i := fs ! (i - 1), i - 1 := fs ! i])\n    < LLL_measure i fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw' i' fs'\n  LLL_measure i' fs' < LLL_measure i fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_step: assumes \n  inv: \"LLL_invariant upw i fs\" \n  and res: \"basis_reduction_step upw i fs = (upw',i',fs')\" \n  and i: \"i < m\" \nshows \"LLL_invariant upw' i' fs'\" \"LLL_measure i' fs' < LLL_measure i fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' &&& LLL_measure i' fs' < LLL_measure i fs", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "note def = basis_reduction_step_def"], ["proof (state)\nthis:\n  basis_reduction_step ?upw ?i ?fs =\n  (if ?i = 0 then (True, Suc ?i, ?fs)\n   else let fs' = basis_reduction_add_rows ?upw ?i ?fs\n        in if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                          (?i - 1)\\<parallel>\\<^sup>2\n              \\<le> \\<alpha> *\n                    \\<parallel>gram_schmidt_fs.gso n\n                                (map of_int_hom.vec_hom fs')\n                                ?i\\<parallel>\\<^sup>2\n           then (True, Suc ?i, fs') else basis_reduction_swap ?i fs')\n\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "obtain fs'' where fs'': \"basis_reduction_add_rows upw i fs = fs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs''.\n        basis_reduction_add_rows upw i fs = fs'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  basis_reduction_add_rows upw i fs = fs''\n\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "from increase_i[OF inv i] True\n      res"], ["proof (chain)\npicking this:\n  \\<lbrakk>upw \\<Longrightarrow> i = 0;\n   i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     i\\<parallel>\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant True (Suc i) fs\n  \\<lbrakk>upw \\<Longrightarrow> i = 0;\n   i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     i\\<parallel>\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> LLL_measure (Suc i) fs < LLL_measure i fs\n  i = 0\n  basis_reduction_step upw i fs = (upw', i', fs')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>upw \\<Longrightarrow> i = 0;\n   i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     i\\<parallel>\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant True (Suc i) fs\n  \\<lbrakk>upw \\<Longrightarrow> i = 0;\n   i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     i\\<parallel>\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> LLL_measure (Suc i) fs < LLL_measure i fs\n  i = 0\n  basis_reduction_step upw i fs = (upw', i', fs')\n\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "by (auto simp: def)"], ["proof (state)\nthis:\n  LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "hence id: \"(i = 0) = False\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (i = 0) = False", "by auto"], ["proof (state)\nthis:\n  (i = 0) = False\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "note res = res[unfolded def id if_False fs'' Let_def]"], ["proof (state)\nthis:\n  (if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2\n      \\<le> \\<alpha> *\n            \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                        i\\<parallel>\\<^sup>2\n   then (True, Suc i, fs'') else basis_reduction_swap i fs'') =\n  (upw', i', fs')\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "let ?x = \"sq_norm (gso fs'' (i - 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "let ?y = \"\\<alpha> * sq_norm (gso fs'' i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "from basis_reduction_add_rows[OF inv fs'' i]"], ["proof (chain)\npicking this:\n  LLL_invariant False i fs''\n  LLL_measure i fs'' = LLL_measure i fs", "have inv: \"LLL_invariant False i fs''\"\n      and meas: \"LLL_measure i fs'' = LLL_measure i fs\""], ["proof (prove)\nusing this:\n  LLL_invariant False i fs''\n  LLL_measure i fs'' = LLL_measure i fs\n\ngoal (1 subgoal):\n 1. LLL_invariant False i fs'' &&& LLL_measure i fs'' = LLL_measure i fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant False i fs''\n  LLL_measure i fs'' = LLL_measure i fs\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs''\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "proof (cases \"?x \\<le> ?y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> *\n          \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                      i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs\n 2. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "case True"], ["proof (state)\nthis:\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                    i\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> *\n          \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                      i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs\n 2. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "from increase_i[OF inv i] id True res meas"], ["proof (chain)\npicking this:\n  \\<lbrakk>False \\<Longrightarrow> i = 0;\n   i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     i\\<parallel>\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant True (Suc i) fs''\n  \\<lbrakk>False \\<Longrightarrow> i = 0;\n   i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     i\\<parallel>\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> LLL_measure (Suc i) fs'' < LLL_measure i fs''\n  (i = 0) = False\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                    i\\<parallel>\\<^sup>2\n  (if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2\n      \\<le> \\<alpha> *\n            \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                        i\\<parallel>\\<^sup>2\n   then (True, Suc i, fs'') else basis_reduction_swap i fs'') =\n  (upw', i', fs')\n  LLL_measure i fs'' = LLL_measure i fs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>False \\<Longrightarrow> i = 0;\n   i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     i\\<parallel>\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant True (Suc i) fs''\n  \\<lbrakk>False \\<Longrightarrow> i = 0;\n   i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     i\\<parallel>\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> LLL_measure (Suc i) fs'' < LLL_measure i fs''\n  (i = 0) = False\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                    i\\<parallel>\\<^sup>2\n  (if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2\n      \\<le> \\<alpha> *\n            \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                        i\\<parallel>\\<^sup>2\n   then (True, Suc i, fs'') else basis_reduction_swap i fs'') =\n  (upw', i', fs')\n  LLL_measure i fs'' = LLL_measure i fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "by simp"], ["proof (state)\nthis:\n  LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs\n\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "case gt: False"], ["proof (state)\nthis:\n  \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     (i - 1)\\<parallel>\\<^sup>2\n         \\<le> \\<alpha> *\n               \\<parallel>gram_schmidt_fs.gso n\n                           (map of_int_hom.vec_hom fs'')\n                           i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "hence \"?x > ?y\""], ["proof (prove)\nusing this:\n  \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     (i - 1)\\<parallel>\\<^sup>2\n         \\<le> \\<alpha> *\n               \\<parallel>gram_schmidt_fs.gso n\n                           (map of_int_hom.vec_hom fs'')\n                           i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<alpha> *\n    \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                i\\<parallel>\\<^sup>2\n    < \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<alpha> *\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n              i\\<parallel>\\<^sup>2\n  < \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "from basis_reduction_swap[OF inv _ this i False] gt res meas"], ["proof (chain)\npicking this:\n  basis_reduction_swap i fs'' = (?upw', ?i', ?fs') \\<Longrightarrow>\n  LLL_invariant ?upw' ?i' ?fs'\n  basis_reduction_swap i fs'' = (?upw', ?i', ?fs') \\<Longrightarrow>\n  LLL_measure ?i' ?fs' < LLL_measure i fs''\n  \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     (i - 1)\\<parallel>\\<^sup>2\n         \\<le> \\<alpha> *\n               \\<parallel>gram_schmidt_fs.gso n\n                           (map of_int_hom.vec_hom fs'')\n                           i\\<parallel>\\<^sup>2\n  (if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2\n      \\<le> \\<alpha> *\n            \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                        i\\<parallel>\\<^sup>2\n   then (True, Suc i, fs'') else basis_reduction_swap i fs'') =\n  (upw', i', fs')\n  LLL_measure i fs'' = LLL_measure i fs", "show ?thesis"], ["proof (prove)\nusing this:\n  basis_reduction_swap i fs'' = (?upw', ?i', ?fs') \\<Longrightarrow>\n  LLL_invariant ?upw' ?i' ?fs'\n  basis_reduction_swap i fs'' = (?upw', ?i', ?fs') \\<Longrightarrow>\n  LLL_measure ?i' ?fs' < LLL_measure i fs''\n  \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     (i - 1)\\<parallel>\\<^sup>2\n         \\<le> \\<alpha> *\n               \\<parallel>gram_schmidt_fs.gso n\n                           (map of_int_hom.vec_hom fs'')\n                           i\\<parallel>\\<^sup>2\n  (if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2\n      \\<le> \\<alpha> *\n            \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                        i\\<parallel>\\<^sup>2\n   then (True, Suc i, fs'') else basis_reduction_swap i fs'') =\n  (upw', i', fs')\n  LLL_measure i fs'' = LLL_measure i fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_invariant upw' i' fs' \\<and> LLL_measure i' fs' < LLL_measure i fs\n\ngoal:\nNo subgoals!", "qed"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All basis_reduction_main_dom", "by (relation \"measure (\\<lambda> (upw,i,fs). LLL_measure i fs)\", insert basis_reduction_step, auto split: prod.splits)"], ["", "declare basis_reduction_main.simps[simp del]"], ["", "lemma basis_reduction_main: assumes \"LLL_invariant upw i fs\" \n  and res: \"basis_reduction_main (upw,i,fs) = fs'\" \nshows \"LLL_invariant True m fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True m fs'", "using assms"], ["proof (prove)\nusing this:\n  LLL_invariant upw i fs\n  basis_reduction_main (upw, i, fs) = fs'\n\ngoal (1 subgoal):\n 1. LLL_invariant True m fs'", "proof (induct \"LLL_measure i fs\" arbitrary: i fs upw rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_invariant upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant True m fs';\n        LLL_invariant upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant True m fs'", "case (less i fs upw)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_measure ?i1 ?fs1 < LLL_measure i fs;\n   LLL_invariant ?upw1 ?i1 ?fs1;\n   basis_reduction_main (?upw1, ?i1, ?fs1) = fs'\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant True m fs'\n  LLL_invariant upw i fs\n  basis_reduction_main (upw, i, fs) = fs'\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_invariant upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant True m fs';\n        LLL_invariant upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant True m fs'", "have id: \"LLL_invariant upw i fs = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant upw i fs = True", "using less"], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_measure ?i1 ?fs1 < LLL_measure i fs;\n   LLL_invariant ?upw1 ?i1 ?fs1;\n   basis_reduction_main (?upw1, ?i1, ?fs1) = fs'\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant True m fs'\n  LLL_invariant upw i fs\n  basis_reduction_main (upw, i, fs) = fs'\n\ngoal (1 subgoal):\n 1. LLL_invariant upw i fs = True", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw i fs = True\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_invariant upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant True m fs';\n        LLL_invariant upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant True m fs'", "note res = less(3)[unfolded basis_reduction_main.simps[of upw i fs] id]"], ["proof (state)\nthis:\n  (if i < m \\<and> True\n   then basis_reduction_main (basis_reduction_step upw i fs) else fs) =\n  fs'\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_invariant upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant True m fs';\n        LLL_invariant upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant True m fs'", "note inv = less(2)"], ["proof (state)\nthis:\n  LLL_invariant upw i fs\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_invariant upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant True m fs';\n        LLL_invariant upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant True m fs'", "note IH = less(1)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_measure ?i1 ?fs1 < LLL_measure i fs;\n   LLL_invariant ?upw1 ?i1 ?fs1;\n   basis_reduction_main (?upw1, ?i1, ?fs1) = fs'\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant True m fs'\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_invariant upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_invariant True m fs';\n        LLL_invariant upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_invariant True m fs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True m fs'", "proof (cases \"i < m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow> LLL_invariant True m fs'\n 2. \\<not> i < m \\<Longrightarrow> LLL_invariant True m fs'", "case i: True"], ["proof (state)\nthis:\n  i < m\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow> LLL_invariant True m fs'\n 2. \\<not> i < m \\<Longrightarrow> LLL_invariant True m fs'", "obtain i' fs' upw' where step: \"basis_reduction_step upw i fs = (upw',i',fs')\" \n      (is \"?step = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>upw' i' fs'.\n        basis_reduction_step upw i fs = (upw', i', fs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?step, auto)"], ["proof (state)\nthis:\n  basis_reduction_step upw i fs = (upw', i', fs')\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow> LLL_invariant True m fs'\n 2. \\<not> i < m \\<Longrightarrow> LLL_invariant True m fs'", "from IH[OF basis_reduction_step(2,1)[OF inv step i]] res[unfolded step] i"], ["proof (chain)\npicking this:\n  basis_reduction_main (upw', i', fs') = fs' \\<Longrightarrow>\n  LLL_invariant True m fs'\n  (if i < m \\<and> True then basis_reduction_main (upw', i', fs') else fs) =\n  fs'\n  i < m", "show ?thesis"], ["proof (prove)\nusing this:\n  basis_reduction_main (upw', i', fs') = fs' \\<Longrightarrow>\n  LLL_invariant True m fs'\n  (if i < m \\<and> True then basis_reduction_main (upw', i', fs') else fs) =\n  fs'\n  i < m\n\ngoal (1 subgoal):\n 1. LLL_invariant True m fs'", "by auto"], ["proof (state)\nthis:\n  LLL_invariant True m fs'\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow> LLL_invariant True m fs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow> LLL_invariant True m fs'", "case False"], ["proof (state)\nthis:\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow> LLL_invariant True m fs'", "with LLL_invD[OF inv]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i\n  \\<not> i < m", "have i: \"i = m\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. i = m", "by auto"], ["proof (state)\nthis:\n  i = m\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow> LLL_invariant True m fs'", "with False res inv"], ["proof (chain)\npicking this:\n  \\<not> i < m\n  (if i < m \\<and> True\n   then basis_reduction_main (basis_reduction_step upw i fs) else fs) =\n  fs'\n  LLL_invariant upw i fs\n  i = m", "have \"LLL_invariant upw m fs'\""], ["proof (prove)\nusing this:\n  \\<not> i < m\n  (if i < m \\<and> True\n   then basis_reduction_main (basis_reduction_step upw i fs) else fs) =\n  fs'\n  LLL_invariant upw i fs\n  i = m\n\ngoal (1 subgoal):\n 1. LLL_invariant upw m fs'", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw m fs'\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow> LLL_invariant True m fs'", "thus \"LLL_invariant True m fs'\""], ["proof (prove)\nusing this:\n  LLL_invariant upw m fs'\n\ngoal (1 subgoal):\n 1. LLL_invariant True m fs'", "unfolding LLL_invariant_def"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n  lattice_of fs' = L \\<and>\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs') \\<alpha> m \\<and>\n  m \\<le> m \\<and> length fs' = m \\<and> (upw \\<or> \\<mu>_small fs' m)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs') \\<and>\n    lattice_of fs' = L \\<and>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs') \\<alpha> m \\<and>\n    m \\<le> m \\<and> length fs' = m \\<and> (True \\<or> \\<mu>_small fs' m)", "by auto"], ["proof (state)\nthis:\n  LLL_invariant True m fs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_invariant True m fs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduce_basis_inv: assumes res: \"reduce_basis = fs\" \n  shows \"LLL_invariant True m fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True m fs", "using basis_reduction_main[OF LLL_inv_initial_state res[unfolded reduce_basis_def]]"], ["proof (prove)\nusing this:\n  LLL_invariant True m fs\n\ngoal (1 subgoal):\n 1. LLL_invariant True m fs", "."], ["", "lemma reduce_basis: assumes res: \"reduce_basis = fs\"\n  shows \"lattice_of fs = L\" \n  \"reduced fs m\" \n  \"lin_indep fs\" \n  \"length fs = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lattice_of fs = L &&&\n     gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m) &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) &&& length fs = m", "using LLL_invD[OF reduce_basis_inv[OF res]]"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  m \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  True \\<or> \\<mu>_small fs m\n\ngoal (1 subgoal):\n 1. (lattice_of fs = L &&&\n     gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m) &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) &&& length fs = m", "by blast+"], ["", "lemma short_vector: assumes res: \"short_vector = v\" \n  and m0: \"m \\<noteq> 0\"\nshows \"v \\<in> carrier_vec n\"\n  \"v \\<in> L - {0\\<^sub>v n}\"  \n  \"h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow> rat_of_int (sq_norm v) \\<le> \\<alpha> ^ (m - 1) * rat_of_int (sq_norm h)\" \n  \"v \\<noteq> 0\\<^sub>v j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n &&& v \\<in> L - {0\\<^sub>v n}) &&&\n    (h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) &&&\n    v \\<noteq> 0\\<^sub>v j", "using basis_reduction_short_vector[OF reduce_basis_inv[OF refl] res[symmetric, unfolded short_vector_def] m0]"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<in> L - {0\\<^sub>v n}\n  ?h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n  rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>?h\\<parallel>\\<^sup>2\n  v \\<noteq> 0\\<^sub>v ?j\n\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n &&& v \\<in> L - {0\\<^sub>v n}) &&&\n    (h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) &&&\n    v \\<noteq> 0\\<^sub>v j", "by blast+"], ["", "end"], ["", "end"]]}