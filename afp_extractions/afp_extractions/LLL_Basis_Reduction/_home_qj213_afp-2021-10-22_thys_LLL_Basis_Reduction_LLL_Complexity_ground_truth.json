{"file_name": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction/LLL_Complexity.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction", "problem_names": ["lemma round_num_denom_cost:  \n  shows \"result (round_num_denom_cost n d) = round_num_denom n d\"  \n   \"cost (round_num_denom_cost n d) \\<le> 4\"", "lemma basis_reduction_add_rows_loop_cost: assumes \"length fs = j\" \n  shows \"result (basis_reduction_add_rows_loop_cost state i j fs) = LLL_Impl.basis_reduction_add_rows_loop n state i j fs\"  \n   \"cost (basis_reduction_add_rows_loop_cost state i j fs) \\<le> sum (\\<lambda> j. (2 * n + 4 + 3 * (Suc j))) {0..<j}\"", "lemma basis_reduction_add_rows_cost: assumes impl: \"LLL_impl_inv state i fs\" and inv: \"LLL_invariant upw i fs\" \n  shows \"result (basis_reduction_add_rows_cost upw i state) = LLL_Impl.basis_reduction_add_rows n upw i state\"  \n   \"cost (basis_reduction_add_rows_cost upw i state) \\<le> (2 * n + 2 * i + 7) * i\"", "lemma swap_mu_cost: \n   \"result (swap_mu_cost dmu i dmu_i_im1 dim1 di dsi) = swap_mu m dmu i dmu_i_im1 dim1 di dsi\"  \n   \"cost (swap_mu_cost dmu i dmu_i_im1 dim1 di dsi) \\<le> 8 * (m - Suc i)\"", "lemma basis_reduction_swap_cost: \n   \"result (basis_reduction_swap_cost i state) = LLL_Impl.basis_reduction_swap m i state\"  \n   \"cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4\"", "lemma basis_reduction_step_cost: assumes \n    impl: \"LLL_impl_inv state i fs\" \n  and inv: \"LLL_invariant upw i fs\" \n  and i: \"i < m\" \n  shows \"result (basis_reduction_step_cost upw i state) = LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\" (is ?g1)\n     \"cost (basis_reduction_step_cost upw i state) \\<le> body_cost\" (is ?g2)", "lemma basis_reduction_main_cost: assumes impl: \"LLL_impl_inv state i (fs_state state)\" \n  and inv: \"LLL_invariant upw i (fs_state state)\" \n  and state: \"state = initial_state m fs_init\" \n  and i: \"i = 0\" \n  shows \"result (basis_reduction_main_cost upw i state c) = LLL_Impl.basis_reduction_main \\<alpha> n m upw i state\" (is ?g1) \n   \"cost (basis_reduction_main_cost upw i state c) \\<le> c + body_cost * num_loops\" (is ?g2)", "lemma sigma_array_cost: \n  \"result (sigma_array_cost dmus dmusi dmusj dll l) = sigma_array dmus dmusi dmusj dll l\"\n  \"cost (sigma_array_cost dmus dmusi dmusj dll l) \\<le> 4 * l + 1\"", "lemma dmu_array_row_main_cost: assumes \"j \\<le> i\" \n  shows \"result (dmu_array_row_main_cost fi i dmus j) = dmu_array_row_main fs fi i dmus j\"\n  \"cost (dmu_array_row_main_cost fi i dmus j) \\<le> (\\<Sum> jj \\<in> {j ..< i}. 2 * n + 2 + 4 * jj + 1)\"", "lemma dmu_array_row_cost: \n   \"result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i\"  \n   \"cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\"", "lemma dmu_array_cost: assumes \"i \\<le> m\" \n  shows \"result (dmu_array_cost dmus i) = dmu_array fs m dmus i\"  \n   \"cost (dmu_array_cost dmus i) \\<le> (\\<Sum> ii \\<in> {i ..< m}. 2 * n + (2 * n + 1 + 2 * ii) * ii)\"", "lemma d\\<mu>_impl_cost: \"result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init\" \n  \"cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)\"", "lemma initial_state_cost: \"result (initial_state_cost fs_init) = initial_state m fs_init\" (is ?g1)\n  \"cost (initial_state_cost fs_init) \\<le> initial_gso_cost\" (is ?g2)", "lemma basis_reduction_cost: \n   \"result (basis_reduction_cost fs_init) = basis_reduction \\<alpha> n fs_init\"  (is ?g1)\n   \"cost (basis_reduction_cost fs_init) \\<le> initial_gso_cost + body_cost * num_loops\" (is ?g2)", "lemma reduce_basis_cost: \n   \"result (reduce_basis_cost fs_init) = LLL_Impl.reduce_basis \\<alpha> fs_init\"  (is ?g1)\n   \"cost (reduce_basis_cost fs_init) \\<le> initial_gso_cost + body_cost * num_loops\" (is ?g2)", "lemma mn: \"m \\<le> n\"", "lemma reduce_basis_cost_expanded: \n  assumes \"Lg \\<ge> nat \\<lceil>log (of_rat (4 * \\<alpha> / (4 + \\<alpha>))) N\\<rceil>\"   \n  shows \"cost (reduce_basis_cost fs_init)\n  \\<le> 4 * Lg * m * m * m * n\n    + 4 * Lg * m * m * m * m\n    + 16 * Lg * m * m * m\n    + 4 * Lg * m * m\n    + 3 * m * m * m\n    + 3 * m * m * n \n    + 10 * m * m\n    + 2 * n * m \n    + 3 * m\" \n  (is \"?cost \\<le> ?exp Lg\")", "lemma reduce_basis_cost_0: assumes \"m = 0\" \n  shows \"cost (reduce_basis_cost fs_init) = 0\"", "lemma reduce_basis_cost_N:\n  assumes \"Lg \\<ge> nat \\<lceil>log (of_rat (4 * \\<alpha> / (4 + \\<alpha>))) N\\<rceil>\"   \n  and 0: \"Lg > 0\"  \n  shows \"cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\"", "lemma reduce_basis_cost_M:\n  assumes \"Lg \\<ge> nat \\<lceil>log (of_rat (4 * \\<alpha> / (4 + \\<alpha>))) (M * n)\\<rceil>\"   \n  and 0: \"Lg > 0\"\n  shows \"cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\""], "translations": [["", "lemma round_num_denom_cost:  \n  shows \"result (round_num_denom_cost n d) = round_num_denom n d\"  \n   \"cost (round_num_denom_cost n d) \\<le> 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (round_num_denom_cost n d) = round_num_denom n d &&&\n    cost (round_num_denom_cost n d) \\<le> 4", "unfolding round_num_denom_cost_def round_num_denom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. result ((2 * n + d) div (2 * d), 4) = (2 * n + d) div (2 * d) &&&\n    cost ((2 * n + d) div (2 * d), 4) \\<le> 4", "by (auto simp: cost_simps)"], ["", "context LLL_with_assms\nbegin"], ["", "context\n  assumes \\<alpha>_gt: \"\\<alpha> > 4/3\" and m0: \"m \\<noteq> 0\" \nbegin"], ["", "fun basis_reduction_add_rows_loop_cost where\n  \"basis_reduction_add_rows_loop_cost state i j [] = (state, 0)\" \n| \"basis_reduction_add_rows_loop_cost state i sj (fj # fjs) = (\n     let fi = fi_state state;\n         dsj = d_state state sj;\n         j = sj - 1;\n         (c,cost1) = round_num_denom_cost (dmu_ij_state state i j) dsj;\n         state' = (if c = 0 then state else upd_fi_mu_state state i (vec n (\\<lambda> i. fi $ i - c * fj $ i)) \\<comment> \\<open>2n arith. operations\\<close>\n             (IArray.of_fun (\\<lambda> jj. let mu = dmu_ij_state state i jj in \\<comment> \\<open>3 sj arith. operations\\<close>\n                  if jj < j then mu - c * dmu_ij_state state j jj else \n                  if jj = j then mu - dsj * c else mu) i));\n         local_cost = 2 * n + 3 * sj;\n         (res,cost2) = basis_reduction_add_rows_loop_cost state' i j fjs\n      in (res, cost1 + local_cost + cost2))\""], ["", "lemma basis_reduction_add_rows_loop_cost: assumes \"length fs = j\" \n  shows \"result (basis_reduction_add_rows_loop_cost state i j fs) = LLL_Impl.basis_reduction_add_rows_loop n state i j fs\"  \n   \"cost (basis_reduction_add_rows_loop_cost state i j fs) \\<le> sum (\\<lambda> j. (2 * n + 4 + 3 * (Suc j))) {0..<j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_loop_cost state i j fs) =\n    LLL_Impl.basis_reduction_add_rows_loop n state i j fs &&&\n    cost (basis_reduction_add_rows_loop_cost state i j fs)\n    \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "using assms"], ["proof (prove)\nusing this:\n  length fs = j\n\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_loop_cost state i j fs) =\n    LLL_Impl.basis_reduction_add_rows_loop n state i j fs &&&\n    cost (basis_reduction_add_rows_loop_cost state i j fs)\n    \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "proof (atomize(full), induct fs arbitrary: state j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>state j.\n       length [] = j \\<Longrightarrow>\n       result (basis_reduction_add_rows_loop_cost state i j []) =\n       LLL_Impl.basis_reduction_add_rows_loop n state i j [] \\<and>\n       cost (basis_reduction_add_rows_loop_cost state i j [])\n       \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n 2. \\<And>a fs state j.\n       \\<lbrakk>\\<And>state j.\n                   length fs = j \\<Longrightarrow>\n                   result\n                    (basis_reduction_add_rows_loop_cost state i j fs) =\n                   LLL_Impl.basis_reduction_add_rows_loop n state i j\n                    fs \\<and>\n                   cost (basis_reduction_add_rows_loop_cost state i j fs)\n                   \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j);\n        length (a # fs) = j\\<rbrakk>\n       \\<Longrightarrow> result\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs)) =\n                         LLL_Impl.basis_reduction_add_rows_loop n state i j\n                          (a # fs) \\<and>\n                         cost\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs))\n                         \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "case (Cons fj fs state j)"], ["proof (state)\nthis:\n  length fs = ?j1 \\<Longrightarrow>\n  result (basis_reduction_add_rows_loop_cost ?state1 i ?j1 fs) =\n  LLL_Impl.basis_reduction_add_rows_loop n ?state1 i ?j1 fs \\<and>\n  cost (basis_reduction_add_rows_loop_cost ?state1 i ?j1 fs)\n  \\<le> (\\<Sum>j = 0..<?j1. 2 * n + 4 + 3 * Suc j)\n  length (fj # fs) = j\n\ngoal (2 subgoals):\n 1. \\<And>state j.\n       length [] = j \\<Longrightarrow>\n       result (basis_reduction_add_rows_loop_cost state i j []) =\n       LLL_Impl.basis_reduction_add_rows_loop n state i j [] \\<and>\n       cost (basis_reduction_add_rows_loop_cost state i j [])\n       \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n 2. \\<And>a fs state j.\n       \\<lbrakk>\\<And>state j.\n                   length fs = j \\<Longrightarrow>\n                   result\n                    (basis_reduction_add_rows_loop_cost state i j fs) =\n                   LLL_Impl.basis_reduction_add_rows_loop n state i j\n                    fs \\<and>\n                   cost (basis_reduction_add_rows_loop_cost state i j fs)\n                   \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j);\n        length (a # fs) = j\\<rbrakk>\n       \\<Longrightarrow> result\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs)) =\n                         LLL_Impl.basis_reduction_add_rows_loop n state i j\n                          (a # fs) \\<and>\n                         cost\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs))\n                         \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "let ?dm_ij = \"dmu_ij_state state i (j - 1)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>state j.\n       length [] = j \\<Longrightarrow>\n       result (basis_reduction_add_rows_loop_cost state i j []) =\n       LLL_Impl.basis_reduction_add_rows_loop n state i j [] \\<and>\n       cost (basis_reduction_add_rows_loop_cost state i j [])\n       \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n 2. \\<And>a fs state j.\n       \\<lbrakk>\\<And>state j.\n                   length fs = j \\<Longrightarrow>\n                   result\n                    (basis_reduction_add_rows_loop_cost state i j fs) =\n                   LLL_Impl.basis_reduction_add_rows_loop n state i j\n                    fs \\<and>\n                   cost (basis_reduction_add_rows_loop_cost state i j fs)\n                   \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j);\n        length (a # fs) = j\\<rbrakk>\n       \\<Longrightarrow> result\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs)) =\n                         LLL_Impl.basis_reduction_add_rows_loop n state i j\n                          (a # fs) \\<and>\n                         cost\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs))\n                         \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "let ?dj = \"d_state state j\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>state j.\n       length [] = j \\<Longrightarrow>\n       result (basis_reduction_add_rows_loop_cost state i j []) =\n       LLL_Impl.basis_reduction_add_rows_loop n state i j [] \\<and>\n       cost (basis_reduction_add_rows_loop_cost state i j [])\n       \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n 2. \\<And>a fs state j.\n       \\<lbrakk>\\<And>state j.\n                   length fs = j \\<Longrightarrow>\n                   result\n                    (basis_reduction_add_rows_loop_cost state i j fs) =\n                   LLL_Impl.basis_reduction_add_rows_loop n state i j\n                    fs \\<and>\n                   cost (basis_reduction_add_rows_loop_cost state i j fs)\n                   \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j);\n        length (a # fs) = j\\<rbrakk>\n       \\<Longrightarrow> result\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs)) =\n                         LLL_Impl.basis_reduction_add_rows_loop n state i j\n                          (a # fs) \\<and>\n                         cost\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs))\n                         \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "obtain c1 fc where flc: \"round_num_denom_cost ?dm_ij ?dj = (fc, c1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fc c1.\n        round_num_denom_cost (dmu_ij_state state i (j - 1))\n         (d_state state j) =\n        (fc, c1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  round_num_denom_cost (dmu_ij_state state i (j - 1)) (d_state state j) =\n  (fc, c1)\n\ngoal (2 subgoals):\n 1. \\<And>state j.\n       length [] = j \\<Longrightarrow>\n       result (basis_reduction_add_rows_loop_cost state i j []) =\n       LLL_Impl.basis_reduction_add_rows_loop n state i j [] \\<and>\n       cost (basis_reduction_add_rows_loop_cost state i j [])\n       \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n 2. \\<And>a fs state j.\n       \\<lbrakk>\\<And>state j.\n                   length fs = j \\<Longrightarrow>\n                   result\n                    (basis_reduction_add_rows_loop_cost state i j fs) =\n                   LLL_Impl.basis_reduction_add_rows_loop n state i j\n                    fs \\<and>\n                   cost (basis_reduction_add_rows_loop_cost state i j fs)\n                   \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j);\n        length (a # fs) = j\\<rbrakk>\n       \\<Longrightarrow> result\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs)) =\n                         LLL_Impl.basis_reduction_add_rows_loop n state i j\n                          (a # fs) \\<and>\n                         cost\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs))\n                         \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "from result_costD[OF round_num_denom_cost flc]"], ["proof (chain)\npicking this:\n  fc = round_num_denom (dmu_ij_state state i (j - 1)) (d_state state j)\n  c1 \\<le> 4", "have fl: \"round_num_denom ?dm_ij ?dj = fc\" and c1: \"c1 \\<le> 4\""], ["proof (prove)\nusing this:\n  fc = round_num_denom (dmu_ij_state state i (j - 1)) (d_state state j)\n  c1 \\<le> 4\n\ngoal (1 subgoal):\n 1. round_num_denom (dmu_ij_state state i (j - 1)) (d_state state j) =\n    fc &&&\n    c1 \\<le> 4", "by auto"], ["proof (state)\nthis:\n  round_num_denom (dmu_ij_state state i (j - 1)) (d_state state j) = fc\n  c1 \\<le> 4\n\ngoal (2 subgoals):\n 1. \\<And>state j.\n       length [] = j \\<Longrightarrow>\n       result (basis_reduction_add_rows_loop_cost state i j []) =\n       LLL_Impl.basis_reduction_add_rows_loop n state i j [] \\<and>\n       cost (basis_reduction_add_rows_loop_cost state i j [])\n       \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n 2. \\<And>a fs state j.\n       \\<lbrakk>\\<And>state j.\n                   length fs = j \\<Longrightarrow>\n                   result\n                    (basis_reduction_add_rows_loop_cost state i j fs) =\n                   LLL_Impl.basis_reduction_add_rows_loop n state i j\n                    fs \\<and>\n                   cost (basis_reduction_add_rows_loop_cost state i j fs)\n                   \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j);\n        length (a # fs) = j\\<rbrakk>\n       \\<Longrightarrow> result\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs)) =\n                         LLL_Impl.basis_reduction_add_rows_loop n state i j\n                          (a # fs) \\<and>\n                         cost\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs))\n                         \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "obtain st where st: \"(if fc = 0 then state\n             else upd_fi_mu_state state i (vec n (\\<lambda> i. fi_state state $ i - fc * fj $ i))\n                   (IArray.of_fun\n                     (\\<lambda>jj. if jj < j - 1 then dmu_ij_state state i jj - fc * dmu_ij_state state (j - 1) jj\n                           else if jj = j - 1 then dmu_ij_state state i jj - d_state state j * fc else dmu_ij_state state i jj)\n                     i)) = st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st.\n        (if fc = 0 then state\n         else upd_fi_mu_state state i\n               (vec n (\\<lambda>i. fi_state state $ i - fc * fj $ i))\n               (IArray.of_fun\n                 (\\<lambda>jj.\n                     if jj < j - 1\n                     then dmu_ij_state state i jj -\n                          fc * dmu_ij_state state (j - 1) jj\n                     else if jj = j - 1\n                          then dmu_ij_state state i jj -\n                               d_state state j * fc\n                          else dmu_ij_state state i jj)\n                 i)) =\n        st \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (if fc = 0 then state\n   else upd_fi_mu_state state i\n         (vec n (\\<lambda>i. fi_state state $ i - fc * fj $ i))\n         (IArray.of_fun\n           (\\<lambda>jj.\n               if jj < j - 1\n               then dmu_ij_state state i jj -\n                    fc * dmu_ij_state state (j - 1) jj\n               else if jj = j - 1\n                    then dmu_ij_state state i jj - d_state state j * fc\n                    else dmu_ij_state state i jj)\n           i)) =\n  st\n\ngoal (2 subgoals):\n 1. \\<And>state j.\n       length [] = j \\<Longrightarrow>\n       result (basis_reduction_add_rows_loop_cost state i j []) =\n       LLL_Impl.basis_reduction_add_rows_loop n state i j [] \\<and>\n       cost (basis_reduction_add_rows_loop_cost state i j [])\n       \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n 2. \\<And>a fs state j.\n       \\<lbrakk>\\<And>state j.\n                   length fs = j \\<Longrightarrow>\n                   result\n                    (basis_reduction_add_rows_loop_cost state i j fs) =\n                   LLL_Impl.basis_reduction_add_rows_loop n state i j\n                    fs \\<and>\n                   cost (basis_reduction_add_rows_loop_cost state i j fs)\n                   \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j);\n        length (a # fs) = j\\<rbrakk>\n       \\<Longrightarrow> result\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs)) =\n                         LLL_Impl.basis_reduction_add_rows_loop n state i j\n                          (a # fs) \\<and>\n                         cost\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs))\n                         \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "obtain res c2 where rec: \"basis_reduction_add_rows_loop_cost st i (j - 1) fs = (res,c2)\" (is \"?x = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>res c2.\n        basis_reduction_add_rows_loop_cost st i (j - 1) fs =\n        (res, c2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?x, auto)"], ["proof (state)\nthis:\n  basis_reduction_add_rows_loop_cost st i (j - 1) fs = (res, c2)\n\ngoal (2 subgoals):\n 1. \\<And>state j.\n       length [] = j \\<Longrightarrow>\n       result (basis_reduction_add_rows_loop_cost state i j []) =\n       LLL_Impl.basis_reduction_add_rows_loop n state i j [] \\<and>\n       cost (basis_reduction_add_rows_loop_cost state i j [])\n       \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n 2. \\<And>a fs state j.\n       \\<lbrakk>\\<And>state j.\n                   length fs = j \\<Longrightarrow>\n                   result\n                    (basis_reduction_add_rows_loop_cost state i j fs) =\n                   LLL_Impl.basis_reduction_add_rows_loop n state i j\n                    fs \\<and>\n                   cost (basis_reduction_add_rows_loop_cost state i j fs)\n                   \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j);\n        length (a # fs) = j\\<rbrakk>\n       \\<Longrightarrow> result\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs)) =\n                         LLL_Impl.basis_reduction_add_rows_loop n state i j\n                          (a # fs) \\<and>\n                         cost\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs))\n                         \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "from Cons(2)"], ["proof (chain)\npicking this:\n  length (fj # fs) = j", "have \"length fs = j - 1\""], ["proof (prove)\nusing this:\n  length (fj # fs) = j\n\ngoal (1 subgoal):\n 1. length fs = j - 1", "by auto"], ["proof (state)\nthis:\n  length fs = j - 1\n\ngoal (2 subgoals):\n 1. \\<And>state j.\n       length [] = j \\<Longrightarrow>\n       result (basis_reduction_add_rows_loop_cost state i j []) =\n       LLL_Impl.basis_reduction_add_rows_loop n state i j [] \\<and>\n       cost (basis_reduction_add_rows_loop_cost state i j [])\n       \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n 2. \\<And>a fs state j.\n       \\<lbrakk>\\<And>state j.\n                   length fs = j \\<Longrightarrow>\n                   result\n                    (basis_reduction_add_rows_loop_cost state i j fs) =\n                   LLL_Impl.basis_reduction_add_rows_loop n state i j\n                    fs \\<and>\n                   cost (basis_reduction_add_rows_loop_cost state i j fs)\n                   \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j);\n        length (a # fs) = j\\<rbrakk>\n       \\<Longrightarrow> result\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs)) =\n                         LLL_Impl.basis_reduction_add_rows_loop n state i j\n                          (a # fs) \\<and>\n                         cost\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs))\n                         \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "from result_costD'[OF Cons(1)[OF this] rec]"], ["proof (chain)\npicking this:\n  res = LLL_Impl.basis_reduction_add_rows_loop n st i (j - 1) fs\n  c2 \\<le> (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j)", "have res: \"LLL_Impl.basis_reduction_add_rows_loop n st i (j - 1) fs = res\" \n    and c2: \"c2 \\<le> (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j)\""], ["proof (prove)\nusing this:\n  res = LLL_Impl.basis_reduction_add_rows_loop n st i (j - 1) fs\n  c2 \\<le> (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j)\n\ngoal (1 subgoal):\n 1. LLL_Impl.basis_reduction_add_rows_loop n st i (j - 1) fs = res &&&\n    c2 \\<le> (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j)", "by auto"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_add_rows_loop n st i (j - 1) fs = res\n  c2 \\<le> (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j)\n\ngoal (2 subgoals):\n 1. \\<And>state j.\n       length [] = j \\<Longrightarrow>\n       result (basis_reduction_add_rows_loop_cost state i j []) =\n       LLL_Impl.basis_reduction_add_rows_loop n state i j [] \\<and>\n       cost (basis_reduction_add_rows_loop_cost state i j [])\n       \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n 2. \\<And>a fs state j.\n       \\<lbrakk>\\<And>state j.\n                   length fs = j \\<Longrightarrow>\n                   result\n                    (basis_reduction_add_rows_loop_cost state i j fs) =\n                   LLL_Impl.basis_reduction_add_rows_loop n state i j\n                    fs \\<and>\n                   cost (basis_reduction_add_rows_loop_cost state i j fs)\n                   \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j);\n        length (a # fs) = j\\<rbrakk>\n       \\<Longrightarrow> result\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs)) =\n                         LLL_Impl.basis_reduction_add_rows_loop n state i j\n                          (a # fs) \\<and>\n                         cost\n                          (basis_reduction_add_rows_loop_cost state i j\n                            (a # fs))\n                         \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_loop_cost state i j (fj # fs)) =\n    LLL_Impl.basis_reduction_add_rows_loop n state i j (fj # fs) \\<and>\n    cost (basis_reduction_add_rows_loop_cost state i j (fj # fs))\n    \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "unfolding basis_reduction_add_rows_loop_cost.simps Let_def flc split \n      LLL_Impl.basis_reduction_add_rows_loop.simps fl st rec res cost_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. res = res \\<and>\n    c1 + (2 * n + 3 * j) + c2 \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "proof (intro conjI refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. c1 + (2 * n + 3 * j) + c2 \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. c1 + (2 * n + 3 * j) + c2 \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "have \"c1 + (2 * n + 3 * j) + c2 \\<le> (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j) + (2 * n + 4 + 3 * Suc (j - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 + (2 * n + 3 * j) + c2\n    \\<le> (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j) +\n          (2 * n + 4 + 3 * Suc (j - 1))", "using c1 c2"], ["proof (prove)\nusing this:\n  c1 \\<le> 4\n  c2 \\<le> (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j)\n\ngoal (1 subgoal):\n 1. c1 + (2 * n + 3 * j) + c2\n    \\<le> (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j) +\n          (2 * n + 4 + 3 * Suc (j - 1))", "by auto"], ["proof (state)\nthis:\n  c1 + (2 * n + 3 * j) + c2\n  \\<le> (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j) +\n        (2 * n + 4 + 3 * Suc (j - 1))\n\ngoal (1 subgoal):\n 1. c1 + (2 * n + 3 * j) + c2 \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "also"], ["proof (state)\nthis:\n  c1 + (2 * n + 3 * j) + c2\n  \\<le> (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j) +\n        (2 * n + 4 + 3 * Suc (j - 1))\n\ngoal (1 subgoal):\n 1. c1 + (2 * n + 3 * j) + c2 \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "have \"\\<dots> = (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j) +\n    (2 * n + 4 + 3 * Suc (j - 1)) =\n    (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "by (subst (2) sum.remove[of _ \"j - 1\"], insert Cons(2), auto intro: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<j - 1. 2 * n + 4 + 3 * Suc j) +\n  (2 * n + 4 + 3 * Suc (j - 1)) =\n  (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n\ngoal (1 subgoal):\n 1. c1 + (2 * n + 3 * j) + c2 \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "finally"], ["proof (chain)\npicking this:\n  c1 + (2 * n + 3 * j) + c2 \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "show ?case"], ["proof (prove)\nusing this:\n  c1 + (2 * n + 3 * j) + c2 \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n\ngoal (1 subgoal):\n 1. c1 + (2 * n + 3 * j) + c2 \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "."], ["proof (state)\nthis:\n  c1 + (2 * n + 3 * j) + c2 \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  result (basis_reduction_add_rows_loop_cost state i j (fj # fs)) =\n  LLL_Impl.basis_reduction_add_rows_loop n state i j (fj # fs) \\<and>\n  cost (basis_reduction_add_rows_loop_cost state i j (fj # fs))\n  \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>state j.\n       length [] = j \\<Longrightarrow>\n       result (basis_reduction_add_rows_loop_cost state i j []) =\n       LLL_Impl.basis_reduction_add_rows_loop n state i j [] \\<and>\n       cost (basis_reduction_add_rows_loop_cost state i j [])\n       \\<le> (\\<Sum>j = 0..<j. 2 * n + 4 + 3 * Suc j)", "qed (auto simp: cost_simps)"], ["", "definition basis_reduction_add_rows_cost where\n  \"basis_reduction_add_rows_cost upw i state = \n     (if upw then basis_reduction_add_rows_loop_cost state i i (small_fs_state state) \n        else (state,0))\""], ["", "lemma basis_reduction_add_rows_cost: assumes impl: \"LLL_impl_inv state i fs\" and inv: \"LLL_invariant upw i fs\" \n  shows \"result (basis_reduction_add_rows_cost upw i state) = LLL_Impl.basis_reduction_add_rows n upw i state\"  \n   \"cost (basis_reduction_add_rows_cost upw i state) \\<le> (2 * n + 2 * i + 7) * i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state &&&\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "proof (atomize (full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "note d = basis_reduction_add_rows_cost_def LLL_Impl.basis_reduction_add_rows_def"], ["proof (state)\nthis:\n  basis_reduction_add_rows_cost ?upw ?i ?state =\n  (if ?upw\n   then basis_reduction_add_rows_loop_cost ?state ?i ?i\n         (small_fs_state ?state)\n   else (?state, 0))\n  LLL_Impl.basis_reduction_add_rows ?n ?upw ?i ?state =\n  (if ?upw\n   then LLL_Impl.basis_reduction_add_rows_loop ?n ?state ?i ?i\n         (small_fs_state ?state)\n   else ?state)\n\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "proof (cases upw)"], ["proof (state)\ngoal (2 subgoals):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i\n 2. \\<not> upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "case False"], ["proof (state)\nthis:\n  \\<not> upw\n\ngoal (2 subgoals):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i\n 2. \\<not> upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> upw\n\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "by (auto simp: d cost_simps)"], ["proof (state)\nthis:\n  result (basis_reduction_add_rows_cost upw i state) =\n  LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (2 * n + 2 * i + 7) * i\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "case True"], ["proof (state)\nthis:\n  upw\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "hence upw: \"upw = True\""], ["proof (prove)\nusing this:\n  upw\n\ngoal (1 subgoal):\n 1. upw = True", "by simp"], ["proof (state)\nthis:\n  upw = True\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "obtain f mu ds where state: \"state = (f,mu,ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f mu ds.\n        state = (f, mu, ds) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases state, auto)"], ["proof (state)\nthis:\n  state = (f, mu, ds)\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "from to_list_repr[OF impl inv state]"], ["proof (chain)\npicking this:\n  list_repr i f (map ((!) fs) [0..<m])", "have len: \"length (small_fs_state state) = i\""], ["proof (prove)\nusing this:\n  list_repr i f (map ((!) fs) [0..<m])\n\ngoal (1 subgoal):\n 1. length (small_fs_state state) = i", "unfolding small_fs_state.simps state list_repr_def"], ["proof (prove)\nusing this:\n  i \\<le> length (map ((!) fs) [0..<m]) \\<and>\n  fst f = rev (take i (map ((!) fs) [0..<m])) \\<and>\n  snd f = drop i (map ((!) fs) [0..<m])\n\ngoal (1 subgoal):\n 1. length (fst f) = i", "by auto"], ["proof (state)\nthis:\n  length (small_fs_state state) = i\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "let ?call = \"basis_reduction_add_rows_cost upw i state\""], ["proof (state)\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "have res: \"result ?call = LLL_Impl.basis_reduction_add_rows n upw i state\" \n      and cost: \"cost ?call \\<le> sum (\\<lambda> j. (2 * n + 4 + 3 * (Suc j))) {0..<i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state &&&\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (\\<Sum>j = 0..<i. 2 * n + 4 + 3 * Suc j)", "unfolding d upw if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. result\n     (basis_reduction_add_rows_loop_cost state i i (small_fs_state state)) =\n    LLL_Impl.basis_reduction_add_rows_loop n state i i\n     (small_fs_state state) &&&\n    cost\n     (basis_reduction_add_rows_loop_cost state i i (small_fs_state state))\n    \\<le> (\\<Sum>j = 0..<i. 2 * n + 4 + 3 * Suc j)", "using basis_reduction_add_rows_loop_cost[OF len, of state i]"], ["proof (prove)\nusing this:\n  result\n   (basis_reduction_add_rows_loop_cost state i i (small_fs_state state)) =\n  LLL_Impl.basis_reduction_add_rows_loop n state i i (small_fs_state state)\n  cost (basis_reduction_add_rows_loop_cost state i i (small_fs_state state))\n  \\<le> (\\<Sum>j = 0..<i. 2 * n + 4 + 3 * Suc j)\n\ngoal (1 subgoal):\n 1. result\n     (basis_reduction_add_rows_loop_cost state i i (small_fs_state state)) =\n    LLL_Impl.basis_reduction_add_rows_loop n state i i\n     (small_fs_state state) &&&\n    cost\n     (basis_reduction_add_rows_loop_cost state i i (small_fs_state state))\n    \\<le> (\\<Sum>j = 0..<i. 2 * n + 4 + 3 * Suc j)", "by auto"], ["proof (state)\nthis:\n  result (basis_reduction_add_rows_cost upw i state) =\n  LLL_Impl.basis_reduction_add_rows n upw i state\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (\\<Sum>j = 0..<i. 2 * n + 4 + 3 * Suc j)\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "note cost"], ["proof (state)\nthis:\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (\\<Sum>j = 0..<i. 2 * n + 4 + 3 * Suc j)\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "also"], ["proof (state)\nthis:\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (\\<Sum>j = 0..<i. 2 * n + 4 + 3 * Suc j)\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "have \"sum (\\<lambda> j. (2 * n + 4 + 3 * (Suc j))) {0..<i} = (2 * n + 7) * i + 3 * (\\<Sum>j = 0..<i. j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<i. 2 * n + 4 + 3 * Suc j) =\n    (2 * n + 7) * i + 3 * \\<Sum> {0..<i}", "by (auto simp: algebra_simps  sum.distrib sum_distrib_right sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<i. 2 * n + 4 + 3 * Suc j) =\n  (2 * n + 7) * i + 3 * \\<Sum> {0..<i}\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<i. 2 * n + 4 + 3 * Suc j) =\n  (2 * n + 7) * i + 3 * \\<Sum> {0..<i}\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "have \"(\\<Sum>j = 0..<i. j) = (i * (i - 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum> {0..<i} = i * (i - 1) div 2", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Sum> {0..<0} = 0 * (0 - 1) div 2\n 2. \\<And>i.\n       \\<Sum> {0..<i} = i * (i - 1) div 2 \\<Longrightarrow>\n       \\<Sum> {0..<Suc i} = Suc i * (Suc i - 1) div 2", "case (Suc i)"], ["proof (state)\nthis:\n  \\<Sum> {0..<i} = i * (i - 1) div 2\n\ngoal (2 subgoals):\n 1. \\<Sum> {0..<0} = 0 * (0 - 1) div 2\n 2. \\<And>i.\n       \\<Sum> {0..<i} = i * (i - 1) div 2 \\<Longrightarrow>\n       \\<Sum> {0..<Suc i} = Suc i * (Suc i - 1) div 2", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Sum> {0..<i} = i * (i - 1) div 2\n\ngoal (1 subgoal):\n 1. \\<Sum> {0..<Suc i} = Suc i * (Suc i - 1) div 2", "by (cases i, auto)"], ["proof (state)\nthis:\n  \\<Sum> {0..<Suc i} = Suc i * (Suc i - 1) div 2\n\ngoal (1 subgoal):\n 1. \\<Sum> {0..<0} = 0 * (0 - 1) div 2", "qed auto"], ["proof (state)\nthis:\n  \\<Sum> {0..<i} = i * (i - 1) div 2\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "finally"], ["proof (chain)\npicking this:\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (2 * n + 7) * i + 3 * (i * (i - 1) div 2)", "have \"cost ?call \\<le> (2 * n + 7) * i + 3 * (i * (i - 1) div 2)\""], ["proof (prove)\nusing this:\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (2 * n + 7) * i + 3 * (i * (i - 1) div 2)\n\ngoal (1 subgoal):\n 1. cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 7) * i + 3 * (i * (i - 1) div 2)", "."], ["proof (state)\nthis:\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (2 * n + 7) * i + 3 * (i * (i - 1) div 2)\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "also"], ["proof (state)\nthis:\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (2 * n + 7) * i + 3 * (i * (i - 1) div 2)\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "have \"\\<dots> \\<le> (2 * n + 7) * i + 2 * i * i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * n + 7) * i + 3 * (i * (i - 1) div 2)\n    \\<le> (2 * n + 7) * i + 2 * i * i", "proof (rule add_left_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 * (i * (i - 1) div 2) \\<le> 2 * i * i", "have \"3 * (i * (i - 1) div 2) \\<le> 2 * i * (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * (i * (i - 1) div 2) \\<le> 2 * i * (i - 1)", "by simp"], ["proof (state)\nthis:\n  3 * (i * (i - 1) div 2) \\<le> 2 * i * (i - 1)\n\ngoal (1 subgoal):\n 1. 3 * (i * (i - 1) div 2) \\<le> 2 * i * i", "also"], ["proof (state)\nthis:\n  3 * (i * (i - 1) div 2) \\<le> 2 * i * (i - 1)\n\ngoal (1 subgoal):\n 1. 3 * (i * (i - 1) div 2) \\<le> 2 * i * i", "have \"\\<dots> \\<le> 2 * i * i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * i * (i - 1) \\<le> 2 * i * i", "by (intro mult_mono, auto)"], ["proof (state)\nthis:\n  2 * i * (i - 1) \\<le> 2 * i * i\n\ngoal (1 subgoal):\n 1. 3 * (i * (i - 1) div 2) \\<le> 2 * i * i", "finally"], ["proof (chain)\npicking this:\n  3 * (i * (i - 1) div 2) \\<le> 2 * i * i", "show \"3 * (i * (i - 1) div 2) \\<le> 2 * i * i\""], ["proof (prove)\nusing this:\n  3 * (i * (i - 1) div 2) \\<le> 2 * i * i\n\ngoal (1 subgoal):\n 1. 3 * (i * (i - 1) div 2) \\<le> 2 * i * i", "."], ["proof (state)\nthis:\n  3 * (i * (i - 1) div 2) \\<le> 2 * i * i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (2 * n + 7) * i + 3 * (i * (i - 1) div 2)\n  \\<le> (2 * n + 7) * i + 2 * i * i\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "also"], ["proof (state)\nthis:\n  (2 * n + 7) * i + 3 * (i * (i - 1) div 2)\n  \\<le> (2 * n + 7) * i + 2 * i * i\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "have \"\\<dots> = (2 * n + 2 * i + 7) * i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * n + 7) * i + 2 * i * i = (2 * n + 2 * i + 7) * i", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (2 * n + 7) * i + 2 * i * i = (2 * n + 2 * i + 7) * i\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "finally"], ["proof (chain)\npicking this:\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (2 * n + 2 * i + 7) * i", "have cost: \"cost ?call \\<le> (2 * n + 2 * i + 7) * i\""], ["proof (prove)\nusing this:\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (2 * n + 2 * i + 7) * i\n\ngoal (1 subgoal):\n 1. cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "."], ["proof (state)\nthis:\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (2 * n + 2 * i + 7) * i\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "using res cost"], ["proof (prove)\nusing this:\n  result (basis_reduction_add_rows_cost upw i state) =\n  LLL_Impl.basis_reduction_add_rows n upw i state\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (2 * n + 2 * i + 7) * i\n\ngoal (1 subgoal):\n 1. result (basis_reduction_add_rows_cost upw i state) =\n    LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n    cost (basis_reduction_add_rows_cost upw i state)\n    \\<le> (2 * n + 2 * i + 7) * i", "by simp"], ["proof (state)\nthis:\n  result (basis_reduction_add_rows_cost upw i state) =\n  LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (2 * n + 2 * i + 7) * i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  result (basis_reduction_add_rows_cost upw i state) =\n  LLL_Impl.basis_reduction_add_rows n upw i state \\<and>\n  cost (basis_reduction_add_rows_cost upw i state)\n  \\<le> (2 * n + 2 * i + 7) * i\n\ngoal:\nNo subgoals!", "qed"], ["", "definition swap_mu_cost :: \"int iarray iarray \\<Rightarrow> nat \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int iarray iarray cost\" where\n  \"swap_mu_cost dmu i dmu_i_im1 dim1 di dsi = (let im1 = i - 1;\n       res = IArray.of_fun (\\<lambda> ii. if ii < im1 then dmu !! ii else \n         if ii > i then let dmu_ii = dmu !! ii in \n             IArray.of_fun (\\<lambda> j. let dmu_ii_j = dmu_ii !! j in   \\<comment> \\<open>8 arith. operations for whole line\\<close>\n                 if j = i then (dsi * dmu_ii !! im1 - dmu_i_im1 * dmu_ii_j) div di \\<comment> \\<open>4 arith. operations for this entry\\<close>\n                 else if j = im1 then (dmu_i_im1 * dmu_ii_j + dmu_ii !! i * dim1) div di \\<comment> \\<open>4 arith. operations for this entry\\<close>\n                 else dmu_ii_j) ii else \n         if ii = i then let mu_im1 = dmu !! im1 in \n             IArray.of_fun (\\<lambda> j. if j = im1 then dmu_i_im1 else mu_im1 !! j) ii \n           else IArray.of_fun (\\<lambda> j. dmu !! i !! j) ii) \\<comment> \\<open>ii = i - 1\\<close>\n         m; \\<comment> \\<open>in total, there are m - (i+1) many lines that require arithmetic operations: i + 1, ..., m - 1\\<close>\n       cost = 8 * (m - Suc i)\n    in (res,cost))\""], ["", "lemma swap_mu_cost: \n   \"result (swap_mu_cost dmu i dmu_i_im1 dim1 di dsi) = swap_mu m dmu i dmu_i_im1 dim1 di dsi\"  \n   \"cost (swap_mu_cost dmu i dmu_i_im1 dim1 di dsi) \\<le> 8 * (m - Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (swap_mu_cost dmu i dmu_i_im1 dim1 di dsi) =\n    swap_mu m dmu i dmu_i_im1 dim1 di dsi &&&\n    cost (swap_mu_cost dmu i dmu_i_im1 dim1 di dsi) \\<le> 8 * (m - Suc i)", "by (auto simp: swap_mu_cost_def swap_mu_def Let_def cost_simps)"], ["", "definition basis_reduction_swap_cost where\n  \"basis_reduction_swap_cost i state = (let \n       di = d_state state i;\n       dsi = d_state state (Suc i);\n       dim1 = d_state state (i - 1);\n       fi = fi_state state;\n       fim1 = fim1_state state;\n       dmu_i_im1 = dmu_ij_state state i (i - 1);\n       fi' = fim1;\n       fim1' = fi;\n       di' = (dsi * dim1 + dmu_i_im1 * dmu_i_im1) div di; \\<comment> \\<open>4 arith. operations\\<close>\n       local_cost = 4 \n     in (case state of (f,dmus,djs) \\<Rightarrow>\n        case swap_mu_cost dmus i dmu_i_im1 dim1 di dsi of\n          (swap_res, swap_cost) \\<Rightarrow>\n          let res = (False, i - 1, \n                     (dec_i (update_im1 (update_i f fi') fim1'), \n                      swap_res, \n                      iarray_update djs i di'));\n              cost = local_cost + swap_cost \n         in (res, cost)))\""], ["", "lemma basis_reduction_swap_cost: \n   \"result (basis_reduction_swap_cost i state) = LLL_Impl.basis_reduction_swap m i state\"  \n   \"cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_swap_cost i state) =\n    LLL_Impl.basis_reduction_swap m i state &&&\n    cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. result (basis_reduction_swap_cost i state) =\n    LLL_Impl.basis_reduction_swap m i state \\<and>\n    cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. result (basis_reduction_swap_cost i state) =\n    LLL_Impl.basis_reduction_swap m i state \\<and>\n    cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4", "obtain f dmus djs where state: \"state = (f,dmus,djs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f dmus djs.\n        state = (f, dmus, djs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases state, auto)"], ["proof (state)\nthis:\n  state = (f, dmus, djs)\n\ngoal (1 subgoal):\n 1. result (basis_reduction_swap_cost i state) =\n    LLL_Impl.basis_reduction_swap m i state \\<and>\n    cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4", "let ?mu = \"dmu_ij_state (f, dmus, djs) i (i - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. result (basis_reduction_swap_cost i state) =\n    LLL_Impl.basis_reduction_swap m i state \\<and>\n    cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4", "let ?di1 = \"d_state (f, dmus, djs) (i - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. result (basis_reduction_swap_cost i state) =\n    LLL_Impl.basis_reduction_swap m i state \\<and>\n    cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4", "let ?di = \"d_state (f, dmus, djs) i\""], ["proof (state)\ngoal (1 subgoal):\n 1. result (basis_reduction_swap_cost i state) =\n    LLL_Impl.basis_reduction_swap m i state \\<and>\n    cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4", "let ?dsi = \"d_state (f, dmus, djs) (Suc i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. result (basis_reduction_swap_cost i state) =\n    LLL_Impl.basis_reduction_swap m i state \\<and>\n    cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_swap_cost i state) =\n    LLL_Impl.basis_reduction_swap m i state \\<and>\n    cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4", "unfolding basis_reduction_swap_cost_def LLL_Impl.basis_reduction_swap_def Let_def state split"], ["proof (prove)\ngoal (1 subgoal):\n 1. result\n     (case swap_mu_cost dmus i (dmu_ij_state (f, dmus, djs) i (i - 1))\n            (d_state (f, dmus, djs) (i - 1)) (d_state (f, dmus, djs) i)\n            (d_state (f, dmus, djs) (Suc i)) of\n      (swap_res, swap_cost) \\<Rightarrow>\n        ((False, i - 1,\n          dec_i\n           (update_im1 (update_i f (fim1_state (f, dmus, djs)))\n             (fi_state (f, dmus, djs))),\n          swap_res,\n          iarray_update djs i\n           ((d_state (f, dmus, djs) (Suc i) *\n             d_state (f, dmus, djs) (i - 1) +\n             dmu_ij_state (f, dmus, djs) i (i - 1) *\n             dmu_ij_state (f, dmus, djs) i (i - 1)) div\n            d_state (f, dmus, djs) i)),\n         4 + swap_cost)) =\n    (False, i - 1,\n     dec_i\n      (update_im1 (update_i f (fim1_state (f, dmus, djs)))\n        (fi_state (f, dmus, djs))),\n     swap_mu m dmus i (dmu_ij_state (f, dmus, djs) i (i - 1))\n      (d_state (f, dmus, djs) (i - 1)) (d_state (f, dmus, djs) i)\n      (d_state (f, dmus, djs) (Suc i)),\n     iarray_update djs i\n      ((d_state (f, dmus, djs) (Suc i) * d_state (f, dmus, djs) (i - 1) +\n        dmu_ij_state (f, dmus, djs) i (i - 1) *\n        dmu_ij_state (f, dmus, djs) i (i - 1)) div\n       d_state (f, dmus, djs) i)) \\<and>\n    cost\n     (case swap_mu_cost dmus i (dmu_ij_state (f, dmus, djs) i (i - 1))\n            (d_state (f, dmus, djs) (i - 1)) (d_state (f, dmus, djs) i)\n            (d_state (f, dmus, djs) (Suc i)) of\n      (swap_res, swap_cost) \\<Rightarrow>\n        ((False, i - 1,\n          dec_i\n           (update_im1 (update_i f (fim1_state (f, dmus, djs)))\n             (fi_state (f, dmus, djs))),\n          swap_res,\n          iarray_update djs i\n           ((d_state (f, dmus, djs) (Suc i) *\n             d_state (f, dmus, djs) (i - 1) +\n             dmu_ij_state (f, dmus, djs) i (i - 1) *\n             dmu_ij_state (f, dmus, djs) i (i - 1)) div\n            d_state (f, dmus, djs) i)),\n         4 + swap_cost))\n    \\<le> 8 * (m - Suc i) + 4", "using swap_mu_cost[of dmus i ?mu ?di1 ?di ?dsi]"], ["proof (prove)\nusing this:\n  result\n   (swap_mu_cost dmus i (dmu_ij_state (f, dmus, djs) i (i - 1))\n     (d_state (f, dmus, djs) (i - 1)) (d_state (f, dmus, djs) i)\n     (d_state (f, dmus, djs) (Suc i))) =\n  swap_mu m dmus i (dmu_ij_state (f, dmus, djs) i (i - 1))\n   (d_state (f, dmus, djs) (i - 1)) (d_state (f, dmus, djs) i)\n   (d_state (f, dmus, djs) (Suc i))\n  cost\n   (swap_mu_cost dmus i (dmu_ij_state (f, dmus, djs) i (i - 1))\n     (d_state (f, dmus, djs) (i - 1)) (d_state (f, dmus, djs) i)\n     (d_state (f, dmus, djs) (Suc i)))\n  \\<le> 8 * (m - Suc i)\n\ngoal (1 subgoal):\n 1. result\n     (case swap_mu_cost dmus i (dmu_ij_state (f, dmus, djs) i (i - 1))\n            (d_state (f, dmus, djs) (i - 1)) (d_state (f, dmus, djs) i)\n            (d_state (f, dmus, djs) (Suc i)) of\n      (swap_res, swap_cost) \\<Rightarrow>\n        ((False, i - 1,\n          dec_i\n           (update_im1 (update_i f (fim1_state (f, dmus, djs)))\n             (fi_state (f, dmus, djs))),\n          swap_res,\n          iarray_update djs i\n           ((d_state (f, dmus, djs) (Suc i) *\n             d_state (f, dmus, djs) (i - 1) +\n             dmu_ij_state (f, dmus, djs) i (i - 1) *\n             dmu_ij_state (f, dmus, djs) i (i - 1)) div\n            d_state (f, dmus, djs) i)),\n         4 + swap_cost)) =\n    (False, i - 1,\n     dec_i\n      (update_im1 (update_i f (fim1_state (f, dmus, djs)))\n        (fi_state (f, dmus, djs))),\n     swap_mu m dmus i (dmu_ij_state (f, dmus, djs) i (i - 1))\n      (d_state (f, dmus, djs) (i - 1)) (d_state (f, dmus, djs) i)\n      (d_state (f, dmus, djs) (Suc i)),\n     iarray_update djs i\n      ((d_state (f, dmus, djs) (Suc i) * d_state (f, dmus, djs) (i - 1) +\n        dmu_ij_state (f, dmus, djs) i (i - 1) *\n        dmu_ij_state (f, dmus, djs) i (i - 1)) div\n       d_state (f, dmus, djs) i)) \\<and>\n    cost\n     (case swap_mu_cost dmus i (dmu_ij_state (f, dmus, djs) i (i - 1))\n            (d_state (f, dmus, djs) (i - 1)) (d_state (f, dmus, djs) i)\n            (d_state (f, dmus, djs) (Suc i)) of\n      (swap_res, swap_cost) \\<Rightarrow>\n        ((False, i - 1,\n          dec_i\n           (update_im1 (update_i f (fim1_state (f, dmus, djs)))\n             (fi_state (f, dmus, djs))),\n          swap_res,\n          iarray_update djs i\n           ((d_state (f, dmus, djs) (Suc i) *\n             d_state (f, dmus, djs) (i - 1) +\n             dmu_ij_state (f, dmus, djs) i (i - 1) *\n             dmu_ij_state (f, dmus, djs) i (i - 1)) div\n            d_state (f, dmus, djs) i)),\n         4 + swap_cost))\n    \\<le> 8 * (m - Suc i) + 4", "by (cases \"swap_mu_cost dmus i ?mu ?di1 ?di ?dsi\", auto simp: cost_simps)"], ["proof (state)\nthis:\n  result (basis_reduction_swap_cost i state) =\n  LLL_Impl.basis_reduction_swap m i state \\<and>\n  cost (basis_reduction_swap_cost i state) \\<le> 8 * (m - Suc i) + 4\n\ngoal:\nNo subgoals!", "qed"], ["", "definition basis_reduction_step_cost where\n  \"basis_reduction_step_cost upw i state = (if i = 0 then ((True, Suc i, inc_state state), 0)\n     else let \n       (state',cost_add) = basis_reduction_add_rows_cost upw i state;\n       di = d_state state' i;\n       dsi = d_state state' (Suc i);\n       dim1 = d_state state' (i - 1);\n       (num,denom) = quotient_of \\<alpha>;\n       cond = (di * di * denom \\<le> num * dim1 * dsi); \\<comment> \\<open>5 arith. operations\\<close>\n       local_cost = 5\n    in if cond then\n          ((True, Suc i, inc_state state'), local_cost + cost_add) \n        else case basis_reduction_swap_cost i state' of (res, cost_swap) \\<Rightarrow> (res, local_cost + cost_swap + cost_add))\""], ["", "definition \"body_cost = 2 + (8 + 2 * n + 2 * m) * m\""], ["", "lemma basis_reduction_step_cost: assumes \n    impl: \"LLL_impl_inv state i fs\" \n  and inv: \"LLL_invariant upw i fs\" \n  and i: \"i < m\" \n  shows \"result (basis_reduction_step_cost upw i state) = LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\" (is ?g1)\n     \"cost (basis_reduction_step_cost upw i state) \\<le> body_cost\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state &&&\n    cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "obtain state' c_add where add: \"basis_reduction_add_rows_cost upw i state = (state',c_add)\" \n    (is \"?add = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state' c_add.\n        basis_reduction_add_rows_cost upw i state =\n        (state', c_add) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?add, auto)"], ["proof (state)\nthis:\n  basis_reduction_add_rows_cost upw i state = (state', c_add)\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "obtain state'' c_swap where swapc: \"basis_reduction_swap_cost i state' = (state'',c_swap)\" \n    (is \"?swap = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state'' c_swap.\n        basis_reduction_swap_cost i state' =\n        (state'', c_swap) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?swap, auto)"], ["proof (state)\nthis:\n  basis_reduction_swap_cost i state' = (state'', c_swap)\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "note res = basis_reduction_step_cost_def[of upw i state, unfolded add split swap]"], ["proof (state)\nthis:\n  basis_reduction_step_cost upw i state =\n  (if i = 0 then ((True, Suc i, inc_state state), 0)\n   else let (state', cost_add) = (state', c_add); di = d_state state' i;\n            dsi = d_state state' (Suc i); dim1 = d_state state' (i - 1);\n            (num, denom) = quotient_of \\<alpha>;\n            cond = di * di * denom \\<le> num * dim1 * dsi; local_cost = 5\n        in if cond\n           then ((True, Suc i, inc_state state'), local_cost + cost_add)\n           else case basis_reduction_swap_cost i state' of\n                (res, cost_swap) \\<Rightarrow>\n                  (res, local_cost + cost_swap + cost_add))\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "from result_costD[OF basis_reduction_add_rows_cost[OF impl inv] add]"], ["proof (chain)\npicking this:\n  state' = LLL_Impl.basis_reduction_add_rows n upw i state\n  c_add \\<le> (2 * n + 2 * i + 7) * i", "have add: \"LLL_Impl.basis_reduction_add_rows n upw i state = state'\" \n    and c_add: \"c_add \\<le> (2 * n + 2 * i + 7) * i\""], ["proof (prove)\nusing this:\n  state' = LLL_Impl.basis_reduction_add_rows n upw i state\n  c_add \\<le> (2 * n + 2 * i + 7) * i\n\ngoal (1 subgoal):\n 1. LLL_Impl.basis_reduction_add_rows n upw i state = state' &&&\n    c_add \\<le> (2 * n + 2 * i + 7) * i", "by auto"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_add_rows n upw i state = state'\n  c_add \\<le> (2 * n + 2 * i + 7) * i\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "from result_costD[OF basis_reduction_swap_cost swapc]"], ["proof (chain)\npicking this:\n  state'' = LLL_Impl.basis_reduction_swap m i state'\n  c_swap \\<le> 8 * (m - Suc i) + 4", "have swap: \"LLL_Impl.basis_reduction_swap m i state' = state''\" \n    and c_swap: \"c_swap \\<le> 8 * (m - Suc i) + 4\""], ["proof (prove)\nusing this:\n  state'' = LLL_Impl.basis_reduction_swap m i state'\n  c_swap \\<le> 8 * (m - Suc i) + 4\n\ngoal (1 subgoal):\n 1. LLL_Impl.basis_reduction_swap m i state' = state'' &&&\n    c_swap \\<le> 8 * (m - Suc i) + 4", "by auto"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_swap m i state' = state''\n  c_swap \\<le> 8 * (m - Suc i) + 4\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "have \"c_add + c_swap + 5 \\<le> 8 * m + 2 + (2 * n + 2 * i) * i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_add + c_swap + 5 \\<le> 8 * m + 2 + (2 * n + 2 * i) * i", "using c_add c_swap i"], ["proof (prove)\nusing this:\n  c_add \\<le> (2 * n + 2 * i + 7) * i\n  c_swap \\<le> 8 * (m - Suc i) + 4\n  i < m\n\ngoal (1 subgoal):\n 1. c_add + c_swap + 5 \\<le> 8 * m + 2 + (2 * n + 2 * i) * i", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  c_add + c_swap + 5 \\<le> 8 * m + 2 + (2 * n + 2 * i) * i\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "also"], ["proof (state)\nthis:\n  c_add + c_swap + 5 \\<le> 8 * m + 2 + (2 * n + 2 * i) * i\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "have \"\\<dots> \\<le> 8 * m + 2 + (2 * n + 2 * m) * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 8 * m + 2 + (2 * n + 2 * i) * i \\<le> 8 * m + 2 + (2 * n + 2 * m) * m", "by (intro add_left_mono mult_mono, insert i, auto)"], ["proof (state)\nthis:\n  8 * m + 2 + (2 * n + 2 * i) * i \\<le> 8 * m + 2 + (2 * n + 2 * m) * m\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "also"], ["proof (state)\nthis:\n  8 * m + 2 + (2 * n + 2 * i) * i \\<le> 8 * m + 2 + (2 * n + 2 * m) * m\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "have \"\\<dots> = 2 + (8 + 2 * n + 2 * m) * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 8 * m + 2 + (2 * n + 2 * m) * m = 2 + (8 + 2 * n + 2 * m) * m", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  8 * m + 2 + (2 * n + 2 * m) * m = 2 + (8 + 2 * n + 2 * m) * m\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "finally"], ["proof (chain)\npicking this:\n  c_add + c_swap + 5 \\<le> 2 + (8 + 2 * n + 2 * m) * m", "have body: \"c_add + c_swap + 5 \\<le> body_cost\""], ["proof (prove)\nusing this:\n  c_add + c_swap + 5 \\<le> 2 + (8 + 2 * n + 2 * m) * m\n\ngoal (1 subgoal):\n 1. c_add + c_swap + 5 \\<le> body_cost", "unfolding body_cost_def"], ["proof (prove)\nusing this:\n  c_add + c_swap + 5 \\<le> 2 + (8 + 2 * n + 2 * m) * m\n\ngoal (1 subgoal):\n 1. c_add + c_swap + 5 \\<le> 2 + (8 + 2 * n + 2 * m) * m", "."], ["proof (state)\nthis:\n  c_add + c_swap + 5 \\<le> body_cost\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "obtain num denom where alpha: \"quotient_of \\<alpha> = (num,denom)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>num denom.\n        quotient_of \\<alpha> = (num, denom) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of \\<alpha> = (num, denom)\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "note res' = LLL_Impl.basis_reduction_step_def[of \\<alpha> n m upw i state, unfolded add swap Let_def alpha split]"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (if i = 0 then (True, Suc i, inc_state state)\n   else if d_state state' i * d_state state' i * denom\n           \\<le> num * d_state state' (i - 1) * d_state state' (Suc i)\n        then (True, Suc i, inc_state state') else state'')\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "note d = res res'"], ["proof (state)\nthis:\n  basis_reduction_step_cost upw i state =\n  (if i = 0 then ((True, Suc i, inc_state state), 0)\n   else let (state', cost_add) = (state', c_add); di = d_state state' i;\n            dsi = d_state state' (Suc i); dim1 = d_state state' (i - 1);\n            (num, denom) = quotient_of \\<alpha>;\n            cond = di * di * denom \\<le> num * dim1 * dsi; local_cost = 5\n        in if cond\n           then ((True, Suc i, inc_state state'), local_cost + cost_add)\n           else case basis_reduction_swap_cost i state' of\n                (res, cost_swap) \\<Rightarrow>\n                  (res, local_cost + cost_swap + cost_add))\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (if i = 0 then (True, Suc i, inc_state state)\n   else if d_state state' i * d_state state' i * denom\n           \\<le> num * d_state state' (i - 1) * d_state state' (Suc i)\n        then (True, Suc i, inc_state state') else state'')\n\ngoal (2 subgoals):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n 2. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "show ?g1"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_step_cost upw i state) =\n    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. result\n     (if i = 0 then ((True, Suc i, inc_state state), 0)\n      else let (state', cost_add) = (state', c_add); di = d_state state' i;\n               dsi = d_state state' (Suc i); dim1 = d_state state' (i - 1);\n               (num, denom) = quotient_of \\<alpha>;\n               cond = di * di * denom \\<le> num * dim1 * dsi; local_cost = 5\n           in if cond\n              then ((True, Suc i, inc_state state'), local_cost + cost_add)\n              else case basis_reduction_swap_cost i state' of\n                   (res, cost_swap) \\<Rightarrow>\n                     (res, local_cost + cost_swap + cost_add)) =\n    (if i = 0 then (True, Suc i, inc_state state)\n     else if d_state state' i * d_state state' i * denom\n             \\<le> num * d_state state' (i - 1) * d_state state' (Suc i)\n          then (True, Suc i, inc_state state') else state'')", "by (auto split: if_splits simp: cost_simps Let_def alpha swapc)"], ["proof (state)\nthis:\n  result (basis_reduction_step_cost upw i state) =\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n\ngoal (1 subgoal):\n 1. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "show ?g2"], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (basis_reduction_step_cost upw i state) \\<le> body_cost", "unfolding d nat_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. cost\n     (if i = 0 then ((True, Suc i, inc_state state), 0)\n      else let (state', cost_add) = (state', c_add); di = d_state state' i;\n               dsi = d_state state' (Suc i); dim1 = d_state state' (i - 1);\n               (num, denom) = quotient_of \\<alpha>;\n               cond = di * di * denom \\<le> num * dim1 * dsi; local_cost = 5\n           in if cond\n              then ((True, Suc i, inc_state state'), local_cost + cost_add)\n              else case basis_reduction_swap_cost i state' of\n                   (res, cost_swap) \\<Rightarrow>\n                     (res, local_cost + cost_swap + cost_add))\n    \\<le> body_cost", "using body"], ["proof (prove)\nusing this:\n  c_add + c_swap + 5 \\<le> body_cost\n\ngoal (1 subgoal):\n 1. cost\n     (if i = 0 then ((True, Suc i, inc_state state), 0)\n      else let (state', cost_add) = (state', c_add); di = d_state state' i;\n               dsi = d_state state' (Suc i); dim1 = d_state state' (i - 1);\n               (num, denom) = quotient_of \\<alpha>;\n               cond = di * di * denom \\<le> num * dim1 * dsi; local_cost = 5\n           in if cond\n              then ((True, Suc i, inc_state state'), local_cost + cost_add)\n              else case basis_reduction_swap_cost i state' of\n                   (res, cost_swap) \\<Rightarrow>\n                     (res, local_cost + cost_swap + cost_add))\n    \\<le> body_cost", "by (auto split: if_splits simp: cost_simps alpha Let_def swapc)"], ["proof (state)\nthis:\n  cost (basis_reduction_step_cost upw i state) \\<le> body_cost\n\ngoal:\nNo subgoals!", "qed"], ["", "partial_function (tailrec) basis_reduction_main_cost where\n  \"basis_reduction_main_cost upw i state c = (if i < m\n     then let ((upw',i',state'), c_step) = basis_reduction_step_cost upw i state\n       in basis_reduction_main_cost upw' i' state' (c + c_step)\n     else (state, c))\""], ["", "definition \"num_loops = m + 2 * m * m * nat (ceiling (log base (real N)))\""], ["", "lemma basis_reduction_main_cost: assumes impl: \"LLL_impl_inv state i (fs_state state)\" \n  and inv: \"LLL_invariant upw i (fs_state state)\" \n  and state: \"state = initial_state m fs_init\" \n  and i: \"i = 0\" \n  shows \"result (basis_reduction_main_cost upw i state c) = LLL_Impl.basis_reduction_main \\<alpha> n m upw i state\" (is ?g1) \n   \"cost (basis_reduction_main_cost upw i state c) \\<le> c + body_cost * num_loops\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state &&&\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * num_loops", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state\n 2. cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * num_loops", "have ?g1 and cost: \"cost (basis_reduction_main_cost upw i state c) \\<le> c + body_cost * LLL_measure i (fs_state state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state &&&\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "using assms(1-2)"], ["proof (prove)\nusing this:\n  LLL_impl_inv state i (fs_state state)\n  LLL_invariant upw i (fs_state state)\n\ngoal (1 subgoal):\n 1. result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state &&&\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "proof (atomize (full), induct \"LLL_measure i (fs_state state)\" arbitrary: upw i state c rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i state upw c.\n       \\<lbrakk>\\<And>ia statea upw c.\n                   \\<lbrakk>LLL_measure ia (fs_state statea)\n                            < LLL_measure i (fs_state state);\n                    LLL_impl_inv statea ia (fs_state statea);\n                    LLL_invariant upw ia (fs_state statea)\\<rbrakk>\n                   \\<Longrightarrow> result\n(basis_reduction_main_cost upw ia statea c) =\n                                     LLL_Impl.basis_reduction_main \\<alpha>\nn m upw ia statea \\<and>\n                                     cost\n(basis_reduction_main_cost upw ia statea c)\n                                     \\<le> c +\n     body_cost * LLL_measure ia (fs_state statea);\n        LLL_impl_inv state i (fs_state state);\n        LLL_invariant upw i (fs_state state)\\<rbrakk>\n       \\<Longrightarrow> result (basis_reduction_main_cost upw i state c) =\n                         LLL_Impl.basis_reduction_main \\<alpha> n m upw i\n                          state \\<and>\n                         cost (basis_reduction_main_cost upw i state c)\n                         \\<le> c +\n                               body_cost * LLL_measure i (fs_state state)", "case (less i state upw c)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_measure ?i1 (fs_state ?state1)\n           < LLL_measure i (fs_state state);\n   LLL_impl_inv ?state1 ?i1 (fs_state ?state1);\n   LLL_invariant ?upw1 ?i1 (fs_state ?state1)\\<rbrakk>\n  \\<Longrightarrow> result\n                     (basis_reduction_main_cost ?upw1 ?i1 ?state1 ?c1) =\n                    LLL_Impl.basis_reduction_main \\<alpha> n m ?upw1 ?i1\n                     ?state1 \\<and>\n                    cost (basis_reduction_main_cost ?upw1 ?i1 ?state1 ?c1)\n                    \\<le> ?c1 +\n                          body_cost * LLL_measure ?i1 (fs_state ?state1)\n  LLL_impl_inv state i (fs_state state)\n  LLL_invariant upw i (fs_state state)\n\ngoal (1 subgoal):\n 1. \\<And>i state upw c.\n       \\<lbrakk>\\<And>ia statea upw c.\n                   \\<lbrakk>LLL_measure ia (fs_state statea)\n                            < LLL_measure i (fs_state state);\n                    LLL_impl_inv statea ia (fs_state statea);\n                    LLL_invariant upw ia (fs_state statea)\\<rbrakk>\n                   \\<Longrightarrow> result\n(basis_reduction_main_cost upw ia statea c) =\n                                     LLL_Impl.basis_reduction_main \\<alpha>\nn m upw ia statea \\<and>\n                                     cost\n(basis_reduction_main_cost upw ia statea c)\n                                     \\<le> c +\n     body_cost * LLL_measure ia (fs_state statea);\n        LLL_impl_inv state i (fs_state state);\n        LLL_invariant upw i (fs_state state)\\<rbrakk>\n       \\<Longrightarrow> result (basis_reduction_main_cost upw i state c) =\n                         LLL_Impl.basis_reduction_main \\<alpha> n m upw i\n                          state \\<and>\n                         cost (basis_reduction_main_cost upw i state c)\n                         \\<le> c +\n                               body_cost * LLL_measure i (fs_state state)", "note inv = less(3)"], ["proof (state)\nthis:\n  LLL_invariant upw i (fs_state state)\n\ngoal (1 subgoal):\n 1. \\<And>i state upw c.\n       \\<lbrakk>\\<And>ia statea upw c.\n                   \\<lbrakk>LLL_measure ia (fs_state statea)\n                            < LLL_measure i (fs_state state);\n                    LLL_impl_inv statea ia (fs_state statea);\n                    LLL_invariant upw ia (fs_state statea)\\<rbrakk>\n                   \\<Longrightarrow> result\n(basis_reduction_main_cost upw ia statea c) =\n                                     LLL_Impl.basis_reduction_main \\<alpha>\nn m upw ia statea \\<and>\n                                     cost\n(basis_reduction_main_cost upw ia statea c)\n                                     \\<le> c +\n     body_cost * LLL_measure ia (fs_state statea);\n        LLL_impl_inv state i (fs_state state);\n        LLL_invariant upw i (fs_state state)\\<rbrakk>\n       \\<Longrightarrow> result (basis_reduction_main_cost upw i state c) =\n                         LLL_Impl.basis_reduction_main \\<alpha> n m upw i\n                          state \\<and>\n                         cost (basis_reduction_main_cost upw i state c)\n                         \\<le> c +\n                               body_cost * LLL_measure i (fs_state state)", "note impl = less(2)"], ["proof (state)\nthis:\n  LLL_impl_inv state i (fs_state state)\n\ngoal (1 subgoal):\n 1. \\<And>i state upw c.\n       \\<lbrakk>\\<And>ia statea upw c.\n                   \\<lbrakk>LLL_measure ia (fs_state statea)\n                            < LLL_measure i (fs_state state);\n                    LLL_impl_inv statea ia (fs_state statea);\n                    LLL_invariant upw ia (fs_state statea)\\<rbrakk>\n                   \\<Longrightarrow> result\n(basis_reduction_main_cost upw ia statea c) =\n                                     LLL_Impl.basis_reduction_main \\<alpha>\nn m upw ia statea \\<and>\n                                     cost\n(basis_reduction_main_cost upw ia statea c)\n                                     \\<le> c +\n     body_cost * LLL_measure ia (fs_state statea);\n        LLL_impl_inv state i (fs_state state);\n        LLL_invariant upw i (fs_state state)\\<rbrakk>\n       \\<Longrightarrow> result (basis_reduction_main_cost upw i state c) =\n                         LLL_Impl.basis_reduction_main \\<alpha> n m upw i\n                          state \\<and>\n                         cost (basis_reduction_main_cost upw i state c)\n                         \\<le> c +\n                               body_cost * LLL_measure i (fs_state state)", "obtain i' upw' state' c_step where step: \"basis_reduction_step_cost upw i state = ((upw',i',state'),c_step)\" \n      (is \"?step = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>upw' i' state' c_step.\n        basis_reduction_step_cost upw i state =\n        ((upw', i', state'), c_step) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?step, auto)"], ["proof (state)\nthis:\n  basis_reduction_step_cost upw i state = ((upw', i', state'), c_step)\n\ngoal (1 subgoal):\n 1. \\<And>i state upw c.\n       \\<lbrakk>\\<And>ia statea upw c.\n                   \\<lbrakk>LLL_measure ia (fs_state statea)\n                            < LLL_measure i (fs_state state);\n                    LLL_impl_inv statea ia (fs_state statea);\n                    LLL_invariant upw ia (fs_state statea)\\<rbrakk>\n                   \\<Longrightarrow> result\n(basis_reduction_main_cost upw ia statea c) =\n                                     LLL_Impl.basis_reduction_main \\<alpha>\nn m upw ia statea \\<and>\n                                     cost\n(basis_reduction_main_cost upw ia statea c)\n                                     \\<le> c +\n     body_cost * LLL_measure ia (fs_state statea);\n        LLL_impl_inv state i (fs_state state);\n        LLL_invariant upw i (fs_state state)\\<rbrakk>\n       \\<Longrightarrow> result (basis_reduction_main_cost upw i state c) =\n                         LLL_Impl.basis_reduction_main \\<alpha> n m upw i\n                          state \\<and>\n                         cost (basis_reduction_main_cost upw i state c)\n                         \\<le> c +\n                               body_cost * LLL_measure i (fs_state state)", "obtain state'' c_rec where rec: \"basis_reduction_main_cost upw' i' state' (c + c_step) = (state'', c_rec)\"\n      (is \"?rec = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state'' c_rec.\n        basis_reduction_main_cost upw' i' state' (c + c_step) =\n        (state'', c_rec) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?rec, auto)"], ["proof (state)\nthis:\n  basis_reduction_main_cost upw' i' state' (c + c_step) = (state'', c_rec)\n\ngoal (1 subgoal):\n 1. \\<And>i state upw c.\n       \\<lbrakk>\\<And>ia statea upw c.\n                   \\<lbrakk>LLL_measure ia (fs_state statea)\n                            < LLL_measure i (fs_state state);\n                    LLL_impl_inv statea ia (fs_state statea);\n                    LLL_invariant upw ia (fs_state statea)\\<rbrakk>\n                   \\<Longrightarrow> result\n(basis_reduction_main_cost upw ia statea c) =\n                                     LLL_Impl.basis_reduction_main \\<alpha>\nn m upw ia statea \\<and>\n                                     cost\n(basis_reduction_main_cost upw ia statea c)\n                                     \\<le> c +\n     body_cost * LLL_measure ia (fs_state statea);\n        LLL_impl_inv state i (fs_state state);\n        LLL_invariant upw i (fs_state state)\\<rbrakk>\n       \\<Longrightarrow> result (basis_reduction_main_cost upw i state c) =\n                         LLL_Impl.basis_reduction_main \\<alpha> n m upw i\n                          state \\<and>\n                         cost (basis_reduction_main_cost upw i state c)\n                         \\<le> c +\n                               body_cost * LLL_measure i (fs_state state)", "note step' = result_costD[OF basis_reduction_step_cost[OF impl inv] step]"], ["proof (state)\nthis:\n  \\<lbrakk>i < m; i < m\\<rbrakk>\n  \\<Longrightarrow> (upw', i', state') =\n                    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n  \\<lbrakk>i < m; i < m\\<rbrakk> \\<Longrightarrow> c_step \\<le> body_cost\n\ngoal (1 subgoal):\n 1. \\<And>i state upw c.\n       \\<lbrakk>\\<And>ia statea upw c.\n                   \\<lbrakk>LLL_measure ia (fs_state statea)\n                            < LLL_measure i (fs_state state);\n                    LLL_impl_inv statea ia (fs_state statea);\n                    LLL_invariant upw ia (fs_state statea)\\<rbrakk>\n                   \\<Longrightarrow> result\n(basis_reduction_main_cost upw ia statea c) =\n                                     LLL_Impl.basis_reduction_main \\<alpha>\nn m upw ia statea \\<and>\n                                     cost\n(basis_reduction_main_cost upw ia statea c)\n                                     \\<le> c +\n     body_cost * LLL_measure ia (fs_state statea);\n        LLL_impl_inv state i (fs_state state);\n        LLL_invariant upw i (fs_state state)\\<rbrakk>\n       \\<Longrightarrow> result (basis_reduction_main_cost upw i state c) =\n                         LLL_Impl.basis_reduction_main \\<alpha> n m upw i\n                          state \\<and>\n                         cost (basis_reduction_main_cost upw i state c)\n                         \\<le> c +\n                               body_cost * LLL_measure i (fs_state state)", "note d = basis_reduction_main_cost.simps[of upw] step split rec \n        LLL_Impl.basis_reduction_main.simps[of _ _ _ upw]"], ["proof (state)\nthis:\n  basis_reduction_main_cost upw ?i ?state ?c =\n  (if ?i < m\n   then let ((upw', i', state'), c_step) =\n              basis_reduction_step_cost upw ?i ?state\n        in basis_reduction_main_cost upw' i' state' (?c + c_step)\n   else (?state, ?c))\n  basis_reduction_step_cost upw i state = ((upw', i', state'), c_step)\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  basis_reduction_main_cost upw' i' state' (c + c_step) = (state'', c_rec)\n  LLL_Impl.basis_reduction_main ?\\<alpha> ?n ?m upw ?i ?state =\n  (if ?i < ?m\n   then case LLL_Impl.basis_reduction_step ?\\<alpha> ?n ?m upw ?i ?state of\n        (upw', i', state') \\<Rightarrow>\n          LLL_Impl.basis_reduction_main ?\\<alpha> ?n ?m upw' i' state'\n   else ?state)\n\ngoal (1 subgoal):\n 1. \\<And>i state upw c.\n       \\<lbrakk>\\<And>ia statea upw c.\n                   \\<lbrakk>LLL_measure ia (fs_state statea)\n                            < LLL_measure i (fs_state state);\n                    LLL_impl_inv statea ia (fs_state statea);\n                    LLL_invariant upw ia (fs_state statea)\\<rbrakk>\n                   \\<Longrightarrow> result\n(basis_reduction_main_cost upw ia statea c) =\n                                     LLL_Impl.basis_reduction_main \\<alpha>\nn m upw ia statea \\<and>\n                                     cost\n(basis_reduction_main_cost upw ia statea c)\n                                     \\<le> c +\n     body_cost * LLL_measure ia (fs_state statea);\n        LLL_impl_inv state i (fs_state state);\n        LLL_invariant upw i (fs_state state)\\<rbrakk>\n       \\<Longrightarrow> result (basis_reduction_main_cost upw i state c) =\n                         LLL_Impl.basis_reduction_main \\<alpha> n m upw i\n                          state \\<and>\n                         cost (basis_reduction_main_cost upw i state c)\n                         \\<le> c +\n                               body_cost * LLL_measure i (fs_state state)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "proof (cases \"i < m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)\n 2. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "case i: True"], ["proof (state)\nthis:\n  i < m\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)\n 2. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "from step' i"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < m; i < m\\<rbrakk>\n  \\<Longrightarrow> (upw', i', state') =\n                    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n  \\<lbrakk>i < m; i < m\\<rbrakk> \\<Longrightarrow> c_step \\<le> body_cost\n  i < m", "have step': \"LLL_Impl.basis_reduction_step \\<alpha> n m upw i state = (upw',i',state')\"\n         and c_step: \"c_step \\<le> body_cost\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i < m; i < m\\<rbrakk>\n  \\<Longrightarrow> (upw', i', state') =\n                    LLL_Impl.basis_reduction_step \\<alpha> n m upw i state\n  \\<lbrakk>i < m; i < m\\<rbrakk> \\<Longrightarrow> c_step \\<le> body_cost\n  i < m\n\ngoal (1 subgoal):\n 1. LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n    (upw', i', state') &&&\n    c_step \\<le> body_cost", "by auto"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (upw', i', state')\n  c_step \\<le> body_cost\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)\n 2. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "note d = d step'"], ["proof (state)\nthis:\n  basis_reduction_main_cost upw ?i ?state ?c =\n  (if ?i < m\n   then let ((upw', i', state'), c_step) =\n              basis_reduction_step_cost upw ?i ?state\n        in basis_reduction_main_cost upw' i' state' (?c + c_step)\n   else (?state, ?c))\n  basis_reduction_step_cost upw i state = ((upw', i', state'), c_step)\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  basis_reduction_main_cost upw' i' state' (c + c_step) = (state'', c_rec)\n  LLL_Impl.basis_reduction_main ?\\<alpha> ?n ?m upw ?i ?state =\n  (if ?i < ?m\n   then case LLL_Impl.basis_reduction_step ?\\<alpha> ?n ?m upw ?i ?state of\n        (upw', i', state') \\<Rightarrow>\n          LLL_Impl.basis_reduction_main ?\\<alpha> ?n ?m upw' i' state'\n   else ?state)\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (upw', i', state')\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)\n 2. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "from basis_reduction_step[OF impl inv step' i refl]"], ["proof (chain)\npicking this:\n  LLL_impl_inv state' i' (fs_state state')\n  LLL_invariant upw' i' (fs_state state')\n  LLL_measure i' (fs_state state') < LLL_measure i (fs_state state)\n  local.basis_reduction_step upw i (fs_state state) =\n  (upw', i', fs_state state')", "have impl': \"LLL_impl_inv state' i' (fs_state state')\" \n        and inv': \"LLL_invariant upw' i' (fs_state state')\"\n        and meas: \"LLL_measure i' (fs_state state') < LLL_measure i (fs_state state)\""], ["proof (prove)\nusing this:\n  LLL_impl_inv state' i' (fs_state state')\n  LLL_invariant upw' i' (fs_state state')\n  LLL_measure i' (fs_state state') < LLL_measure i (fs_state state)\n  local.basis_reduction_step upw i (fs_state state) =\n  (upw', i', fs_state state')\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' (fs_state state') &&&\n    LLL_invariant upw' i' (fs_state state') &&&\n    LLL_measure i' (fs_state state') < LLL_measure i (fs_state state)", "by auto"], ["proof (state)\nthis:\n  LLL_impl_inv state' i' (fs_state state')\n  LLL_invariant upw' i' (fs_state state')\n  LLL_measure i' (fs_state state') < LLL_measure i (fs_state state)\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)\n 2. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "from result_costD'[OF less(1)[OF meas impl' inv'] rec]"], ["proof (chain)\npicking this:\n  state'' = LLL_Impl.basis_reduction_main \\<alpha> n m upw' i' state'\n  c_rec \\<le> c + c_step + body_cost * LLL_measure i' (fs_state state')", "have rec': \"LLL_Impl.basis_reduction_main \\<alpha> n m upw' i' state' = state''\" \n        and c_rec: \"c_rec \\<le> c + c_step + body_cost * LLL_measure i' (fs_state state')\""], ["proof (prove)\nusing this:\n  state'' = LLL_Impl.basis_reduction_main \\<alpha> n m upw' i' state'\n  c_rec \\<le> c + c_step + body_cost * LLL_measure i' (fs_state state')\n\ngoal (1 subgoal):\n 1. LLL_Impl.basis_reduction_main \\<alpha> n m upw' i' state' = state'' &&&\n    c_rec \\<le> c + c_step + body_cost * LLL_measure i' (fs_state state')", "by auto"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_main \\<alpha> n m upw' i' state' = state''\n  c_rec \\<le> c + c_step + body_cost * LLL_measure i' (fs_state state')\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)\n 2. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "from c_step c_rec"], ["proof (chain)\npicking this:\n  c_step \\<le> body_cost\n  c_rec \\<le> c + c_step + body_cost * LLL_measure i' (fs_state state')", "have \"c_rec \\<le> c + body_cost * Suc (LLL_measure i' (fs_state state'))\""], ["proof (prove)\nusing this:\n  c_step \\<le> body_cost\n  c_rec \\<le> c + c_step + body_cost * LLL_measure i' (fs_state state')\n\ngoal (1 subgoal):\n 1. c_rec \\<le> c + body_cost * Suc (LLL_measure i' (fs_state state'))", "by auto"], ["proof (state)\nthis:\n  c_rec \\<le> c + body_cost * Suc (LLL_measure i' (fs_state state'))\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)\n 2. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "also"], ["proof (state)\nthis:\n  c_rec \\<le> c + body_cost * Suc (LLL_measure i' (fs_state state'))\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)\n 2. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "have \"\\<dots> \\<le> c + body_cost * LLL_measure i (fs_state state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c + body_cost * Suc (LLL_measure i' (fs_state state'))\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "using meas"], ["proof (prove)\nusing this:\n  LLL_measure i' (fs_state state') < LLL_measure i (fs_state state)\n\ngoal (1 subgoal):\n 1. c + body_cost * Suc (LLL_measure i' (fs_state state'))\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "by (intro plus_right_mono mult_left_mono) auto"], ["proof (state)\nthis:\n  c + body_cost * Suc (LLL_measure i' (fs_state state'))\n  \\<le> c + body_cost * LLL_measure i (fs_state state)\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)\n 2. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "finally"], ["proof (chain)\npicking this:\n  c_rec \\<le> c + body_cost * LLL_measure i (fs_state state)", "show ?thesis"], ["proof (prove)\nusing this:\n  c_rec \\<le> c + body_cost * LLL_measure i (fs_state state)\n\ngoal (1 subgoal):\n 1. result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "using i inv impl"], ["proof (prove)\nusing this:\n  c_rec \\<le> c + body_cost * LLL_measure i (fs_state state)\n  i < m\n  LLL_invariant upw i (fs_state state)\n  LLL_impl_inv state i (fs_state state)\n\ngoal (1 subgoal):\n 1. result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "by (auto simp: cost_simps d rec')"], ["proof (state)\nthis:\n  result (basis_reduction_main_cost upw i state c) =\n  LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n  cost (basis_reduction_main_cost upw i state c)\n  \\<le> c + body_cost * LLL_measure i (fs_state state)\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "case False"], ["proof (state)\nthis:\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n    cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "unfolding d"], ["proof (prove)\nusing this:\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. result\n     (if i < m\n      then let ((upw', i', state'), c_step) = ((upw', i', state'), c_step)\n           in basis_reduction_main_cost upw' i' state' (c + c_step)\n      else (state, c)) =\n    (if i < m\n     then case LLL_Impl.basis_reduction_step \\<alpha> n m upw i state of\n          (upw', xa, xb) \\<Rightarrow>\n            LLL_Impl.basis_reduction_main \\<alpha> n m upw' xa xb\n     else state) \\<and>\n    cost\n     (if i < m\n      then let ((upw', i', state'), c_step) = ((upw', i', state'), c_step)\n           in basis_reduction_main_cost upw' i' state' (c + c_step)\n      else (state, c))\n    \\<le> c + body_cost * LLL_measure i (fs_state state)", "by (auto simp: cost_simps)"], ["proof (state)\nthis:\n  result (basis_reduction_main_cost upw i state c) =\n  LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n  cost (basis_reduction_main_cost upw i state c)\n  \\<le> c + body_cost * LLL_measure i (fs_state state)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  result (basis_reduction_main_cost upw i state c) =\n  LLL_Impl.basis_reduction_main \\<alpha> n m upw i state \\<and>\n  cost (basis_reduction_main_cost upw i state c)\n  \\<le> c + body_cost * LLL_measure i (fs_state state)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  result (basis_reduction_main_cost upw i state c) =\n  LLL_Impl.basis_reduction_main \\<alpha> n m upw i state\n  cost (basis_reduction_main_cost upw i state c)\n  \\<le> c + body_cost * LLL_measure i (fs_state state)\n\ngoal (2 subgoals):\n 1. result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state\n 2. cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * num_loops", "show ?g1"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_main_cost upw i state c) =\n    LLL_Impl.basis_reduction_main \\<alpha> n m upw i state", "by fact"], ["proof (state)\nthis:\n  result (basis_reduction_main_cost upw i state c) =\n  LLL_Impl.basis_reduction_main \\<alpha> n m upw i state\n\ngoal (1 subgoal):\n 1. cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * num_loops", "note cost"], ["proof (state)\nthis:\n  cost (basis_reduction_main_cost upw i state c)\n  \\<le> c + body_cost * LLL_measure i (fs_state state)\n\ngoal (1 subgoal):\n 1. cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * num_loops", "also"], ["proof (state)\nthis:\n  cost (basis_reduction_main_cost upw i state c)\n  \\<le> c + body_cost * LLL_measure i (fs_state state)\n\ngoal (1 subgoal):\n 1. cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * num_loops", "have \"body_cost * LLL_measure i (fs_state state) \\<le> body_cost * num_loops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. body_cost * LLL_measure i (fs_state state) \\<le> body_cost * num_loops", "proof (rule mult_left_mono; linarith?)"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state) \\<le> num_loops", "define l where \"l = log base (real N)\""], ["proof (state)\nthis:\n  l = log base (real N)\n\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state) \\<le> num_loops", "define k where \"k = 2 * m * m\""], ["proof (state)\nthis:\n  k = 2 * m * m\n\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state) \\<le> num_loops", "obtain f mu ds where init: \"initial_state m fs_init = (f,mu,ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f mu ds.\n        initial_state m fs_init = (f, mu, ds) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"initial_state m fs_init\", auto)"], ["proof (state)\nthis:\n  initial_state m fs_init = (f, mu, ds)\n\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state) \\<le> num_loops", "from initial_state"], ["proof (chain)\npicking this:\n  LLL_impl_inv (initial_state m fs_init) 0 fs_init\n  fs_state (initial_state m fs_init) = fs_init", "have fs: \"fs_state (initial_state m fs_init) = fs_init\""], ["proof (prove)\nusing this:\n  LLL_impl_inv (initial_state m fs_init) 0 fs_init\n  fs_state (initial_state m fs_init) = fs_init\n\ngoal (1 subgoal):\n 1. fs_state (initial_state m fs_init) = fs_init", "by auto"], ["proof (state)\nthis:\n  fs_state (initial_state m fs_init) = fs_init\n\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state) \\<le> num_loops", "have \"LLL_measure i (fs_state state) \\<le> nat (ceiling (m + k * l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state)\n    \\<le> nat \\<lceil>real m + real k * l\\<rceil>", "unfolding l_def k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state)\n    \\<le> nat \\<lceil>real m + real (2 * m * m) * log base (real N)\\<rceil>", "using LLL_measure_approx_fs_init[OF LLL_inv_initial_state \\<alpha>_gt m0]"], ["proof (prove)\nusing this:\n  real (LLL_measure 0 fs_init)\n  \\<le> real m + real (2 * m * m) * log base (real N)\n\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state)\n    \\<le> nat \\<lceil>real m + real (2 * m * m) * log base (real N)\\<rceil>", "unfolding state fs i"], ["proof (prove)\nusing this:\n  real (LLL_measure 0 fs_init)\n  \\<le> real m + real (2 * m * m) * log base (real N)\n\ngoal (1 subgoal):\n 1. LLL_measure 0 fs_init\n    \\<le> nat \\<lceil>real m + real (2 * m * m) * log base (real N)\\<rceil>", "by linarith"], ["proof (state)\nthis:\n  LLL_measure i (fs_state state)\n  \\<le> nat \\<lceil>real m + real k * l\\<rceil>\n\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state) \\<le> num_loops", "also"], ["proof (state)\nthis:\n  LLL_measure i (fs_state state)\n  \\<le> nat \\<lceil>real m + real k * l\\<rceil>\n\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state) \\<le> num_loops", "have \"\\<dots> \\<le> num_loops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>real m + real k * l\\<rceil> \\<le> num_loops", "unfolding num_loops_def l_def[symmetric] k_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>real m + real k * l\\<rceil>\n    \\<le> m + k * nat \\<lceil>l\\<rceil>", "by (simp add: of_nat_ceiling times_right_mono)"], ["proof (state)\nthis:\n  nat \\<lceil>real m + real k * l\\<rceil> \\<le> num_loops\n\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state) \\<le> num_loops", "finally"], ["proof (chain)\npicking this:\n  LLL_measure i (fs_state state) \\<le> num_loops", "show \"LLL_measure i (fs_state state) \\<le> num_loops\""], ["proof (prove)\nusing this:\n  LLL_measure i (fs_state state) \\<le> num_loops\n\ngoal (1 subgoal):\n 1. LLL_measure i (fs_state state) \\<le> num_loops", "."], ["proof (state)\nthis:\n  LLL_measure i (fs_state state) \\<le> num_loops\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  body_cost * LLL_measure i (fs_state state) \\<le> body_cost * num_loops\n\ngoal (1 subgoal):\n 1. cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * num_loops", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> c + x \\<le> c + y) \\<Longrightarrow>\n  cost (basis_reduction_main_cost upw i state c)\n  \\<le> c + body_cost * num_loops", "show ?g2"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> c + x \\<le> c + y) \\<Longrightarrow>\n  cost (basis_reduction_main_cost upw i state c)\n  \\<le> c + body_cost * num_loops\n\ngoal (1 subgoal):\n 1. cost (basis_reduction_main_cost upw i state c)\n    \\<le> c + body_cost * num_loops", "by auto"], ["proof (state)\nthis:\n  cost (basis_reduction_main_cost upw i state c)\n  \\<le> c + body_cost * num_loops\n\ngoal:\nNo subgoals!", "qed"], ["", "context fixes\n  fs :: \"int vec iarray\" \nbegin"], ["", "fun sigma_array_cost where\n  \"sigma_array_cost dmus dmusi dmusj dll l = (if l = 0 then (dmusi !! l * dmusj !! l, 1)\n      else let l1 = l - 1; dll1 = dmus !! l1 !! l1;\n        (sig, cost_rec) = sigma_array_cost dmus dmusi dmusj dll1 l1;\n        res = (dll * sig + dmusi !! l * dmusj !! l) div dll1; \\<comment> \\<open>4 arith. operations\\<close>\n        local_cost = (4 :: nat)\n        in\n      (res, local_cost + cost_rec))\""], ["", "declare sigma_array_cost.simps[simp del]"], ["", "lemma sigma_array_cost: \n  \"result (sigma_array_cost dmus dmusi dmusj dll l) = sigma_array dmus dmusi dmusj dll l\"\n  \"cost (sigma_array_cost dmus dmusi dmusj dll l) \\<le> 4 * l + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (sigma_array_cost dmus dmusi dmusj dll l) =\n    sigma_array dmus dmusi dmusj dll l &&&\n    cost (sigma_array_cost dmus dmusi dmusj dll l) \\<le> 4 * l + 1", "proof (atomize(full), induct l arbitrary: dll)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>dll.\n       result (sigma_array_cost dmus dmusi dmusj dll 0) =\n       sigma_array dmus dmusi dmusj dll 0 \\<and>\n       cost (sigma_array_cost dmus dmusi dmusj dll 0) \\<le> 4 * 0 + 1\n 2. \\<And>l dll.\n       (\\<And>dll.\n           result (sigma_array_cost dmus dmusi dmusj dll l) =\n           sigma_array dmus dmusi dmusj dll l \\<and>\n           cost (sigma_array_cost dmus dmusi dmusj dll l)\n           \\<le> 4 * l + 1) \\<Longrightarrow>\n       result (sigma_array_cost dmus dmusi dmusj dll (Suc l)) =\n       sigma_array dmus dmusi dmusj dll (Suc l) \\<and>\n       cost (sigma_array_cost dmus dmusi dmusj dll (Suc l))\n       \\<le> 4 * Suc l + 1", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>dll.\n       result (sigma_array_cost dmus dmusi dmusj dll 0) =\n       sigma_array dmus dmusi dmusj dll 0 \\<and>\n       cost (sigma_array_cost dmus dmusi dmusj dll 0) \\<le> 4 * 0 + 1\n 2. \\<And>l dll.\n       (\\<And>dll.\n           result (sigma_array_cost dmus dmusi dmusj dll l) =\n           sigma_array dmus dmusi dmusj dll l \\<and>\n           cost (sigma_array_cost dmus dmusi dmusj dll l)\n           \\<le> 4 * l + 1) \\<Longrightarrow>\n       result (sigma_array_cost dmus dmusi dmusj dll (Suc l)) =\n       sigma_array dmus dmusi dmusj dll (Suc l) \\<and>\n       cost (sigma_array_cost dmus dmusi dmusj dll (Suc l))\n       \\<le> 4 * Suc l + 1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (sigma_array_cost dmus dmusi dmusj dll 0) =\n    sigma_array dmus dmusi dmusj dll 0 \\<and>\n    cost (sigma_array_cost dmus dmusi dmusj dll 0) \\<le> 4 * 0 + 1", "unfolding sigma_array_cost.simps[of _ _ _ _ 0] sigma_array.simps[of _ _ _ _ 0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. result\n     (if 0 = 0 then (dmusi !! 0 * dmusj !! 0, 1)\n      else let l1 = 0 - 1; dll1 = dmus !! l1 !! l1;\n               (sig, cost_rec) = sigma_array_cost dmus dmusi dmusj dll1 l1;\n               res = (dll * sig + dmusi !! 0 * dmusj !! 0) div dll1;\n               local_cost = 4\n           in (res, local_cost + cost_rec)) =\n    (if 0 = 0 then dmusi !! 0 * dmusj !! 0\n     else let l1 = 0 - 1; dll1 = dmus !! l1 !! l1\n          in (dll * sigma_array dmus dmusi dmusj dll1 l1 +\n              dmusi !! 0 * dmusj !! 0) div\n             dll1) \\<and>\n    cost\n     (if 0 = 0 then (dmusi !! 0 * dmusj !! 0, 1)\n      else let l1 = 0 - 1; dll1 = dmus !! l1 !! l1;\n               (sig, cost_rec) = sigma_array_cost dmus dmusi dmusj dll1 l1;\n               res = (dll * sig + dmusi !! 0 * dmusj !! 0) div dll1;\n               local_cost = 4\n           in (res, local_cost + cost_rec))\n    \\<le> 4 * 0 + 1", "by (simp add: cost_simps)"], ["proof (state)\nthis:\n  result (sigma_array_cost dmus dmusi dmusj dll 0) =\n  sigma_array dmus dmusi dmusj dll 0 \\<and>\n  cost (sigma_array_cost dmus dmusi dmusj dll 0) \\<le> 4 * 0 + 1\n\ngoal (1 subgoal):\n 1. \\<And>l dll.\n       (\\<And>dll.\n           result (sigma_array_cost dmus dmusi dmusj dll l) =\n           sigma_array dmus dmusi dmusj dll l \\<and>\n           cost (sigma_array_cost dmus dmusi dmusj dll l)\n           \\<le> 4 * l + 1) \\<Longrightarrow>\n       result (sigma_array_cost dmus dmusi dmusj dll (Suc l)) =\n       sigma_array dmus dmusi dmusj dll (Suc l) \\<and>\n       cost (sigma_array_cost dmus dmusi dmusj dll (Suc l))\n       \\<le> 4 * Suc l + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l dll.\n       (\\<And>dll.\n           result (sigma_array_cost dmus dmusi dmusj dll l) =\n           sigma_array dmus dmusi dmusj dll l \\<and>\n           cost (sigma_array_cost dmus dmusi dmusj dll l)\n           \\<le> 4 * l + 1) \\<Longrightarrow>\n       result (sigma_array_cost dmus dmusi dmusj dll (Suc l)) =\n       sigma_array dmus dmusi dmusj dll (Suc l) \\<and>\n       cost (sigma_array_cost dmus dmusi dmusj dll (Suc l))\n       \\<le> 4 * Suc l + 1", "case (Suc l)"], ["proof (state)\nthis:\n  result (sigma_array_cost dmus dmusi dmusj ?dll1 l) =\n  sigma_array dmus dmusi dmusj ?dll1 l \\<and>\n  cost (sigma_array_cost dmus dmusi dmusj ?dll1 l) \\<le> 4 * l + 1\n\ngoal (1 subgoal):\n 1. \\<And>l dll.\n       (\\<And>dll.\n           result (sigma_array_cost dmus dmusi dmusj dll l) =\n           sigma_array dmus dmusi dmusj dll l \\<and>\n           cost (sigma_array_cost dmus dmusi dmusj dll l)\n           \\<le> 4 * l + 1) \\<Longrightarrow>\n       result (sigma_array_cost dmus dmusi dmusj dll (Suc l)) =\n       sigma_array dmus dmusi dmusj dll (Suc l) \\<and>\n       cost (sigma_array_cost dmus dmusi dmusj dll (Suc l))\n       \\<le> 4 * Suc l + 1", "let ?sl = \"Suc l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l dll.\n       (\\<And>dll.\n           result (sigma_array_cost dmus dmusi dmusj dll l) =\n           sigma_array dmus dmusi dmusj dll l \\<and>\n           cost (sigma_array_cost dmus dmusi dmusj dll l)\n           \\<le> 4 * l + 1) \\<Longrightarrow>\n       result (sigma_array_cost dmus dmusi dmusj dll (Suc l)) =\n       sigma_array dmus dmusi dmusj dll (Suc l) \\<and>\n       cost (sigma_array_cost dmus dmusi dmusj dll (Suc l))\n       \\<le> 4 * Suc l + 1", "let ?dll = \"dmus !! (Suc l - 1) !! (Suc l - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l dll.\n       (\\<And>dll.\n           result (sigma_array_cost dmus dmusi dmusj dll l) =\n           sigma_array dmus dmusi dmusj dll l \\<and>\n           cost (sigma_array_cost dmus dmusi dmusj dll l)\n           \\<le> 4 * l + 1) \\<Longrightarrow>\n       result (sigma_array_cost dmus dmusi dmusj dll (Suc l)) =\n       sigma_array dmus dmusi dmusj dll (Suc l) \\<and>\n       cost (sigma_array_cost dmus dmusi dmusj dll (Suc l))\n       \\<le> 4 * Suc l + 1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (sigma_array_cost dmus dmusi dmusj dll (Suc l)) =\n    sigma_array dmus dmusi dmusj dll (Suc l) \\<and>\n    cost (sigma_array_cost dmus dmusi dmusj dll (Suc l)) \\<le> 4 * Suc l + 1", "unfolding sigma_array_cost.simps[of _ _ _ _ ?sl] sigma_array.simps[of _ _ _ _ ?sl] Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. result\n     (if Suc l = 0 then (dmusi !! Suc l * dmusj !! Suc l, 1)\n      else case sigma_array_cost dmus dmusi dmusj\n                 (dmus !! (Suc l - 1) !! (Suc l - 1)) (Suc l - 1) of\n           (sig, cost_rec) \\<Rightarrow>\n             ((dll * sig + dmusi !! Suc l * dmusj !! Suc l) div\n              dmus !! (Suc l - 1) !! (Suc l - 1),\n              4 + cost_rec)) =\n    (if Suc l = 0 then dmusi !! Suc l * dmusj !! Suc l\n     else (dll *\n           sigma_array dmus dmusi dmusj (dmus !! (Suc l - 1) !! (Suc l - 1))\n            (Suc l - 1) +\n           dmusi !! Suc l * dmusj !! Suc l) div\n          dmus !! (Suc l - 1) !! (Suc l - 1)) \\<and>\n    cost\n     (if Suc l = 0 then (dmusi !! Suc l * dmusj !! Suc l, 1)\n      else case sigma_array_cost dmus dmusi dmusj\n                 (dmus !! (Suc l - 1) !! (Suc l - 1)) (Suc l - 1) of\n           (sig, cost_rec) \\<Rightarrow>\n             ((dll * sig + dmusi !! Suc l * dmusj !! Suc l) div\n              dmus !! (Suc l - 1) !! (Suc l - 1),\n              4 + cost_rec))\n    \\<le> 4 * Suc l + 1", "using Suc[of ?dll]"], ["proof (prove)\nusing this:\n  result\n   (sigma_array_cost dmus dmusi dmusj (dmus !! (Suc l - 1) !! (Suc l - 1))\n     l) =\n  sigma_array dmus dmusi dmusj (dmus !! (Suc l - 1) !! (Suc l - 1)) l \\<and>\n  cost\n   (sigma_array_cost dmus dmusi dmusj (dmus !! (Suc l - 1) !! (Suc l - 1))\n     l)\n  \\<le> 4 * l + 1\n\ngoal (1 subgoal):\n 1. result\n     (if Suc l = 0 then (dmusi !! Suc l * dmusj !! Suc l, 1)\n      else case sigma_array_cost dmus dmusi dmusj\n                 (dmus !! (Suc l - 1) !! (Suc l - 1)) (Suc l - 1) of\n           (sig, cost_rec) \\<Rightarrow>\n             ((dll * sig + dmusi !! Suc l * dmusj !! Suc l) div\n              dmus !! (Suc l - 1) !! (Suc l - 1),\n              4 + cost_rec)) =\n    (if Suc l = 0 then dmusi !! Suc l * dmusj !! Suc l\n     else (dll *\n           sigma_array dmus dmusi dmusj (dmus !! (Suc l - 1) !! (Suc l - 1))\n            (Suc l - 1) +\n           dmusi !! Suc l * dmusj !! Suc l) div\n          dmus !! (Suc l - 1) !! (Suc l - 1)) \\<and>\n    cost\n     (if Suc l = 0 then (dmusi !! Suc l * dmusj !! Suc l, 1)\n      else case sigma_array_cost dmus dmusi dmusj\n                 (dmus !! (Suc l - 1) !! (Suc l - 1)) (Suc l - 1) of\n           (sig, cost_rec) \\<Rightarrow>\n             ((dll * sig + dmusi !! Suc l * dmusj !! Suc l) div\n              dmus !! (Suc l - 1) !! (Suc l - 1),\n              4 + cost_rec))\n    \\<le> 4 * Suc l + 1", "by (auto split: prod.splits simp: cost_simps)"], ["proof (state)\nthis:\n  result (sigma_array_cost dmus dmusi dmusj dll (Suc l)) =\n  sigma_array dmus dmusi dmusj dll (Suc l) \\<and>\n  cost (sigma_array_cost dmus dmusi dmusj dll (Suc l)) \\<le> 4 * Suc l + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "function dmu_array_row_main_cost where\n  \"dmu_array_row_main_cost fi i dmus j = (if j \\<ge> i then (dmus, 0)\n     else let sj = Suc j; \n       dmus_i = dmus !! i;\n       djj = dmus !! j !! j;\n       (sigma, cost_sigma) = sigma_array_cost dmus dmus_i (dmus !! sj) djj j;\n       dmu_ij = djj * (fi \\<bullet> fs !! sj) - sigma; \\<comment> \\<open>2n + 2 arith. operations\\<close>\n       dmus' = iarray_update dmus i (iarray_append dmus_i dmu_ij);\n       (res, cost_rec) = dmu_array_row_main_cost fi i dmus' sj;\n       local_cost = 2 * n + 2\n      in (res, cost_rec + cost_sigma + local_cost))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>fi i dmus j.\n           x = (fi, i, dmus, j) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>fi i dmus j fia ia dmusa ja.\n       (fi, i, dmus, j) = (fia, ia, dmusa, ja) \\<Longrightarrow>\n       (if i \\<le> j then (dmus, 0)\n        else let sj = Suc j; dmus_i = dmus !! i; djj = dmus !! j !! j;\n                 (sigma, cost_sigma) =\n                   sigma_array_cost dmus dmus_i (dmus !! sj) djj j;\n                 dmu_ij = djj * (fi \\<bullet> fs !! sj) - sigma;\n                 dmus' = iarray_update dmus i (iarray_append dmus_i dmu_ij);\n                 (res, cost_rec) =\n                   dmu_array_row_main_cost_sumC (fi, i, dmus', sj);\n                 local_cost = 2 * n + 2\n             in (res, cost_rec + cost_sigma + local_cost)) =\n       (if ia \\<le> ja then (dmusa, 0)\n        else let sj = Suc ja; dmus_i = dmusa !! ia; djj = dmusa !! ja !! ja;\n                 (sigma, cost_sigma) =\n                   sigma_array_cost dmusa dmus_i (dmusa !! sj) djj ja;\n                 dmu_ij = djj * (fia \\<bullet> fs !! sj) - sigma;\n                 dmus' =\n                   iarray_update dmusa ia (iarray_append dmus_i dmu_ij);\n                 (res, cost_rec) =\n                   dmu_array_row_main_cost_sumC (fia, ia, dmus', sj);\n                 local_cost = 2 * n + 2\n             in (res, cost_rec + cost_sigma + local_cost))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All dmu_array_row_main_cost_dom", "by (relation \"measure (\\<lambda> (fi,i,dmus,j). i - j)\", auto)"], ["", "declare dmu_array_row_main_cost.simps[simp del]"], ["", "lemma dmu_array_row_main_cost: assumes \"j \\<le> i\" \n  shows \"result (dmu_array_row_main_cost fi i dmus j) = dmu_array_row_main fs fi i dmus j\"\n  \"cost (dmu_array_row_main_cost fi i dmus j) \\<le> (\\<Sum> jj \\<in> {j ..< i}. 2 * n + 2 + 4 * jj + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (dmu_array_row_main_cost fi i dmus j) =\n    dmu_array_row_main fs fi i dmus j &&&\n    cost (dmu_array_row_main_cost fi i dmus j)\n    \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "using assms"], ["proof (prove)\nusing this:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_main_cost fi i dmus j) =\n    dmu_array_row_main fs fi i dmus j &&&\n    cost (dmu_array_row_main_cost fi i dmus j)\n    \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "proof (atomize(full), induct \"i - j\" arbitrary: j dmus)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j dmus.\n       \\<lbrakk>0 = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)\n 2. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "case (0 j dmus)"], ["proof (state)\nthis:\n  0 = i - j\n  j \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>j dmus.\n       \\<lbrakk>0 = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)\n 2. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "hence j: \"j = i\""], ["proof (prove)\nusing this:\n  0 = i - j\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. j = i", "by auto"], ["proof (state)\nthis:\n  j = i\n\ngoal (2 subgoals):\n 1. \\<And>j dmus.\n       \\<lbrakk>0 = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)\n 2. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  j = i\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_main_cost fi i dmus j) =\n    dmu_array_row_main fs fi i dmus j \\<and>\n    cost (dmu_array_row_main_cost fi i dmus j)\n    \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "unfolding dmu_array_row_main_cost.simps[of _ _ _ j] \n    dmu_array_row_main.simps[of _ _ _ _ j]"], ["proof (prove)\nusing this:\n  j = i\n\ngoal (1 subgoal):\n 1. result\n     (if i \\<le> j then (dmus, 0)\n      else let sj = Suc j; dmus_i = dmus !! i; djj = dmus !! j !! j;\n               (sigma, cost_sigma) =\n                 sigma_array_cost dmus dmus_i (dmus !! sj) djj j;\n               dmu_ij = djj * (fi \\<bullet> fs !! sj) - sigma;\n               dmus' = iarray_update dmus i (iarray_append dmus_i dmu_ij);\n               (res, cost_rec) = dmu_array_row_main_cost fi i dmus' sj;\n               local_cost = 2 * n + 2\n           in (res, cost_rec + cost_sigma + local_cost)) =\n    (if j = i then dmus\n     else let sj = Suc j; dmus_i = dmus !! i; djj = dmus !! j !! j;\n              dmu_ij =\n                djj * (fi \\<bullet> fs !! sj) -\n                sigma_array dmus dmus_i (dmus !! sj) djj j;\n              dmus' = iarray_update dmus i (iarray_append dmus_i dmu_ij)\n          in dmu_array_row_main fs fi i dmus' sj) \\<and>\n    cost\n     (if i \\<le> j then (dmus, 0)\n      else let sj = Suc j; dmus_i = dmus !! i; djj = dmus !! j !! j;\n               (sigma, cost_sigma) =\n                 sigma_array_cost dmus dmus_i (dmus !! sj) djj j;\n               dmu_ij = djj * (fi \\<bullet> fs !! sj) - sigma;\n               dmus' = iarray_update dmus i (iarray_append dmus_i dmu_ij);\n               (res, cost_rec) = dmu_array_row_main_cost fi i dmus' sj;\n               local_cost = 2 * n + 2\n           in (res, cost_rec + cost_sigma + local_cost))\n    \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "by (simp add: cost_simps)"], ["proof (state)\nthis:\n  result (dmu_array_row_main_cost fi i dmus j) =\n  dmu_array_row_main fs fi i dmus j \\<and>\n  cost (dmu_array_row_main_cost fi i dmus j)\n  \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "case (Suc l j dmus)"], ["proof (state)\nthis:\n  \\<lbrakk>l = i - ?j1; ?j1 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> result (dmu_array_row_main_cost fi i ?dmus1 ?j1) =\n                    dmu_array_row_main fs fi i ?dmus1 ?j1 \\<and>\n                    cost (dmu_array_row_main_cost fi i ?dmus1 ?j1)\n                    \\<le> (\\<Sum>jj = ?j1..<i. 2 * n + 2 + 4 * jj + 1)\n  Suc l = i - j\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "from Suc(2)"], ["proof (chain)\npicking this:\n  Suc l = i - j", "have id: \"(i \\<le> j) = False\" \"(j = i) = False\""], ["proof (prove)\nusing this:\n  Suc l = i - j\n\ngoal (1 subgoal):\n 1. (i \\<le> j) = False &&& (j = i) = False", "by auto"], ["proof (state)\nthis:\n  (i \\<le> j) = False\n  (j = i) = False\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "let ?sl = \"Suc l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "let ?dll = \"dmus !! (Suc l - 1) !! (Suc l - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "obtain sig c_sig where \n    sig_c: \"sigma_array_cost dmus (dmus !! i) (dmus !! Suc j) (dmus !! j !! j) j = (sig,c_sig)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sig c_sig.\n        sigma_array_cost dmus (dmus !! i) (dmus !! Suc j) (dmus !! j !! j)\n         j =\n        (sig, c_sig) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  sigma_array_cost dmus (dmus !! i) (dmus !! Suc j) (dmus !! j !! j) j =\n  (sig, c_sig)\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "from result_costD[OF sigma_array_cost sig_c]"], ["proof (chain)\npicking this:\n  sig = sigma_array dmus (dmus !! i) (dmus !! Suc j) (dmus !! j !! j) j\n  c_sig \\<le> 4 * j + 1", "have sig: \"sigma_array dmus (dmus !! i) (dmus !! Suc j) (dmus !! j !! j) j = sig\" \n    and c_sig: \"c_sig \\<le> 4 * j + 1\""], ["proof (prove)\nusing this:\n  sig = sigma_array dmus (dmus !! i) (dmus !! Suc j) (dmus !! j !! j) j\n  c_sig \\<le> 4 * j + 1\n\ngoal (1 subgoal):\n 1. sigma_array dmus (dmus !! i) (dmus !! Suc j) (dmus !! j !! j) j =\n    sig &&&\n    c_sig \\<le> 4 * j + 1", "by auto"], ["proof (state)\nthis:\n  sigma_array dmus (dmus !! i) (dmus !! Suc j) (dmus !! j !! j) j = sig\n  c_sig \\<le> 4 * j + 1\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "obtain dmus' where \n    dmus': \"iarray_update dmus i (iarray_append (dmus !! i) (dmus !! j !! j * (fi \\<bullet> fs !! Suc j) - sig)) = dmus'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>dmus'.\n        iarray_update dmus i\n         (iarray_append (dmus !! i)\n           (dmus !! j !! j * (fi \\<bullet> fs !! Suc j) - sig)) =\n        dmus' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  iarray_update dmus i\n   (iarray_append (dmus !! i)\n     (dmus !! j !! j * (fi \\<bullet> fs !! Suc j) - sig)) =\n  dmus'\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "obtain res c_rec where rec_c: \"dmu_array_row_main_cost fi i dmus' (Suc j) = (res, c_rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>res c_rec.\n        dmu_array_row_main_cost fi i dmus' (Suc j) =\n        (res, c_rec) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  dmu_array_row_main_cost fi i dmus' (Suc j) = (res, c_rec)\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "let ?c = \"\\<lambda> j. 2 * n + 2 + 4 * j + 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "from Suc(2-3)"], ["proof (chain)\npicking this:\n  Suc l = i - j\n  j \\<le> i", "have \"l = i - Suc j\" \"Suc j \\<le> i\""], ["proof (prove)\nusing this:\n  Suc l = i - j\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. l = i - Suc j &&& Suc j \\<le> i", "by auto"], ["proof (state)\nthis:\n  l = i - Suc j\n  Suc j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "from Suc(1)[OF this, of dmus', unfolded rec_c cost_simps]"], ["proof (chain)\npicking this:\n  res = dmu_array_row_main fs fi i dmus' (Suc j) \\<and>\n  c_rec \\<le> (\\<Sum>jj = Suc j..<i. 2 * n + 2 + 4 * jj + 1)", "have rec: \"dmu_array_row_main fs fi i dmus' (Suc j) = res\" \n   and c_rec: \"c_rec \\<le> (\\<Sum>jj = Suc j..<i. ?c jj)\""], ["proof (prove)\nusing this:\n  res = dmu_array_row_main fs fi i dmus' (Suc j) \\<and>\n  c_rec \\<le> (\\<Sum>jj = Suc j..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. dmu_array_row_main fs fi i dmus' (Suc j) = res &&&\n    c_rec \\<le> (\\<Sum>jj = Suc j..<i. 2 * n + 2 + 4 * jj + 1)", "by auto"], ["proof (state)\nthis:\n  dmu_array_row_main fs fi i dmus' (Suc j) = res\n  c_rec \\<le> (\\<Sum>jj = Suc j..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "have \"c_rec + c_sig + 2 * n + 2 \\<le> ?c j + (\\<Sum>jj = Suc j..<i. ?c jj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_rec + c_sig + 2 * n + 2\n    \\<le> 2 * n + 2 + 4 * j + 1 +\n          (\\<Sum>jj = Suc j..<i. 2 * n + 2 + 4 * jj + 1)", "using c_rec c_sig"], ["proof (prove)\nusing this:\n  c_rec \\<le> (\\<Sum>jj = Suc j..<i. 2 * n + 2 + 4 * jj + 1)\n  c_sig \\<le> 4 * j + 1\n\ngoal (1 subgoal):\n 1. c_rec + c_sig + 2 * n + 2\n    \\<le> 2 * n + 2 + 4 * j + 1 +\n          (\\<Sum>jj = Suc j..<i. 2 * n + 2 + 4 * jj + 1)", "by auto"], ["proof (state)\nthis:\n  c_rec + c_sig + 2 * n + 2\n  \\<le> 2 * n + 2 + 4 * j + 1 +\n        (\\<Sum>jj = Suc j..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "also"], ["proof (state)\nthis:\n  c_rec + c_sig + 2 * n + 2\n  \\<le> 2 * n + 2 + 4 * j + 1 +\n        (\\<Sum>jj = Suc j..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "have \"\\<dots> = (\\<Sum>jj = j..<i. ?c jj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * n + 2 + 4 * j + 1 + (\\<Sum>jj = Suc j..<i. 2 * n + 2 + 4 * jj + 1) =\n    (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "by (subst (2) sum.remove[of _ j], insert Suc(2-), auto intro: sum.cong)"], ["proof (state)\nthis:\n  2 * n + 2 + 4 * j + 1 + (\\<Sum>jj = Suc j..<i. 2 * n + 2 + 4 * jj + 1) =\n  (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "finally"], ["proof (chain)\npicking this:\n  c_rec + c_sig + 2 * n + 2 \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "have cost: \"c_rec + c_sig + 2 * n + 2 \\<le> (\\<Sum>jj = j..<i. ?c jj)\""], ["proof (prove)\nusing this:\n  c_rec + c_sig + 2 * n + 2 \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. c_rec + c_sig + 2 * n + 2\n    \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "by auto"], ["proof (state)\nthis:\n  c_rec + c_sig + 2 * n + 2 \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x j dmus.\n       \\<lbrakk>\\<And>j dmus.\n                   \\<lbrakk>x = i - j; j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> result\n(dmu_array_row_main_cost fi i dmus j) =\n                                     dmu_array_row_main fs fi i dmus\nj \\<and>\n                                     cost\n(dmu_array_row_main_cost fi i dmus j)\n                                     \\<le> (\\<Sum>jj = j..<i.\n         2 * n + 2 + 4 * jj + 1);\n        Suc x = i - j; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_row_main_cost fi i dmus j) =\n                         dmu_array_row_main fs fi i dmus j \\<and>\n                         cost (dmu_array_row_main_cost fi i dmus j)\n                         \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "thus ?case"], ["proof (prove)\nusing this:\n  c_rec + c_sig + 2 * n + 2 \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_main_cost fi i dmus j) =\n    dmu_array_row_main fs fi i dmus j \\<and>\n    cost (dmu_array_row_main_cost fi i dmus j)\n    \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "unfolding dmu_array_row_main_cost.simps[of _ _ _ j] dmu_array_row_main.simps[of _ _ _ _ j] Let_def\n    id if_False sig_c split sig dmus' rec rec_c cost_simps"], ["proof (prove)\nusing this:\n  c_rec + c_sig + 2 * n + 2 \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. res = res \\<and>\n    c_rec + c_sig + (2 * n + 2)\n    \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)", "by auto"], ["proof (state)\nthis:\n  result (dmu_array_row_main_cost fi i dmus j) =\n  dmu_array_row_main fs fi i dmus j \\<and>\n  cost (dmu_array_row_main_cost fi i dmus j)\n  \\<le> (\\<Sum>jj = j..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition dmu_array_row_cost where\n  \"dmu_array_row_cost dmus i = (let fi = fs !! i;\n      sp = fi \\<bullet> fs !! 0 \\<comment> \\<open>2n arith. operations\\<close>;\n      local_cost = 2 * n;\n      (res, main_cost) = dmu_array_row_main_cost fi i (iarray_append dmus (IArray [sp])) 0 in \n      (res, local_cost + main_cost))\""], ["", "lemma dmu_array_row_cost: \n   \"result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i\"  \n   \"cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i &&&\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "let ?fi = \"fs !! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "let ?arr = \"iarray_append dmus (IArray [?fi \\<bullet> fs !! 0])\""], ["proof (state)\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "obtain res c_main where res_c: \"dmu_array_row_main_cost ?fi i ?arr 0 = (res, c_main)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>res c_main.\n        dmu_array_row_main_cost (fs !! i) i\n         (iarray_append dmus (IArray [fs !! i \\<bullet> fs !! 0])) 0 =\n        (res, c_main) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  dmu_array_row_main_cost (fs !! i) i\n   (iarray_append dmus (IArray [fs !! i \\<bullet> fs !! 0])) 0 =\n  (res, c_main)\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "from result_costD[OF dmu_array_row_main_cost res_c]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> i; 0 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> res =\n                    dmu_array_row_main fs (fs !! i) i\n                     (iarray_append dmus\n                       (IArray [fs !! i \\<bullet> fs !! 0]))\n                     0\n  \\<lbrakk>0 \\<le> i; 0 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> c_main \\<le> (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1)", "have res: \"dmu_array_row_main fs ?fi i ?arr 0 = res\" \n    and c_main: \"c_main \\<le> (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> i; 0 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> res =\n                    dmu_array_row_main fs (fs !! i) i\n                     (iarray_append dmus\n                       (IArray [fs !! i \\<bullet> fs !! 0]))\n                     0\n  \\<lbrakk>0 \\<le> i; 0 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> c_main \\<le> (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. dmu_array_row_main fs (fs !! i) i\n     (iarray_append dmus (IArray [fs !! i \\<bullet> fs !! 0])) 0 =\n    res &&&\n    c_main \\<le> (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1)", "by auto"], ["proof (state)\nthis:\n  dmu_array_row_main fs (fs !! i) i\n   (iarray_append dmus (IArray [fs !! i \\<bullet> fs !! 0])) 0 =\n  res\n  c_main \\<le> (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "have \"2 * n + c_main \\<le> 2 * n + (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * n + c_main \\<le> 2 * n + (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1)", "using c_main"], ["proof (prove)\nusing this:\n  c_main \\<le> (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. 2 * n + c_main \\<le> 2 * n + (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1)", "by auto"], ["proof (state)\nthis:\n  2 * n + c_main \\<le> 2 * n + (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "also"], ["proof (state)\nthis:\n  2 * n + c_main \\<le> 2 * n + (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1)\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "have \"\\<dots> = 2 * n + (2 * n + 3) * i + 2 * (\\<Sum>jj < i. 2 * jj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * n + (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1) =\n    2 * n + (2 * n + 3) * i + 2 * sum ((*) 2) {..<i}", "unfolding sum.distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * n +\n    ((\\<Sum>jj = 0..<i. 2 * n) + (\\<Sum>jj = 0..<i. 2) +\n     sum ((*) 4) {0..<i} +\n     (\\<Sum>jj = 0..<i. 1)) =\n    2 * n + (2 * n + 3) * i + 2 * sum ((*) 2) {..<i}", "by (auto simp: sum_distrib_left field_simps intro: sum.cong)"], ["proof (state)\nthis:\n  2 * n + (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1) =\n  2 * n + (2 * n + 3) * i + 2 * sum ((*) 2) {..<i}\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "also"], ["proof (state)\nthis:\n  2 * n + (\\<Sum>jj = 0..<i. 2 * n + 2 + 4 * jj + 1) =\n  2 * n + (2 * n + 3) * i + 2 * sum ((*) 2) {..<i}\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "have \"(\\<Sum>jj < i. 2 * jj) = i * (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((*) 2) {..<i} = i * (i - 1)", "by (induct i, force, rename_tac i, case_tac i, auto)"], ["proof (state)\nthis:\n  sum ((*) 2) {..<i} = i * (i - 1)\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "finally"], ["proof (chain)\npicking this:\n  2 * n + c_main \\<le> 2 * n + (2 * n + 3) * i + 2 * (i * (i - 1))", "have \"2 * n + c_main \\<le> 2 * n + (2 * n + 3 + 2 * (i - 1)) * i\""], ["proof (prove)\nusing this:\n  2 * n + c_main \\<le> 2 * n + (2 * n + 3) * i + 2 * (i * (i - 1))\n\ngoal (1 subgoal):\n 1. 2 * n + c_main \\<le> 2 * n + (2 * n + 3 + 2 * (i - 1)) * i", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  2 * n + c_main \\<le> 2 * n + (2 * n + 3 + 2 * (i - 1)) * i\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "also"], ["proof (state)\nthis:\n  2 * n + c_main \\<le> 2 * n + (2 * n + 3 + 2 * (i - 1)) * i\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "have \"\\<dots> = 2 * n + (2 * n + 1 + 2 * i) * i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * n + (2 * n + 3 + 2 * (i - 1)) * i = 2 * n + (2 * n + 1 + 2 * i) * i", "by (cases i, auto simp: field_simps)"], ["proof (state)\nthis:\n  2 * n + (2 * n + 3 + 2 * (i - 1)) * i = 2 * n + (2 * n + 1 + 2 * i) * i\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "finally"], ["proof (chain)\npicking this:\n  2 * n + c_main \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "have \"2 * n + c_main \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\""], ["proof (prove)\nusing this:\n  2 * n + c_main \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\n\ngoal (1 subgoal):\n 1. 2 * n + c_main \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "."], ["proof (state)\nthis:\n  2 * n + c_main \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "thus ?case"], ["proof (prove)\nusing this:\n  2 * n + c_main \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\n\ngoal (1 subgoal):\n 1. result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n    cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "unfolding dmu_array_row_cost_def Let_def dmu_array_row_def res_c res split cost_simps"], ["proof (prove)\nusing this:\n  2 * n + c_main \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\n\ngoal (1 subgoal):\n 1. res = res \\<and> 2 * n + c_main \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "by auto"], ["proof (state)\nthis:\n  result (dmu_array_row_cost dmus i) = dmu_array_row fs dmus i \\<and>\n  cost (dmu_array_row_cost dmus i) \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\n\ngoal:\nNo subgoals!", "qed"], ["", "function dmu_array_cost where \n  \"dmu_array_cost dmus i = (if i \\<ge> m then (dmus,0) else \n    let (dmus', cost_row) = dmu_array_row_cost dmus i;\n        (res, cost_rec) = dmu_array_cost dmus' (Suc i)\n     in (res, cost_row + cost_rec))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>dmus i. x = (dmus, i) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>dmus i dmusa ia.\n       (dmus, i) = (dmusa, ia) \\<Longrightarrow>\n       (if m \\<le> i then (dmus, 0)\n        else let (dmus', cost_row) = dmu_array_row_cost dmus i;\n                 (res, cost_rec) = dmu_array_cost_sumC (dmus', Suc i)\n             in (res, cost_row + cost_rec)) =\n       (if m \\<le> ia then (dmusa, 0)\n        else let (dmus', cost_row) = dmu_array_row_cost dmusa ia;\n                 (res, cost_rec) = dmu_array_cost_sumC (dmus', Suc ia)\n             in (res, cost_row + cost_rec))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All dmu_array_cost_dom", "by (relation \"measure (\\<lambda> (dmus, i). m - i)\", auto)"], ["", "declare dmu_array_cost.simps[simp del]"], ["", "lemma dmu_array_cost: assumes \"i \\<le> m\" \n  shows \"result (dmu_array_cost dmus i) = dmu_array fs m dmus i\"  \n   \"cost (dmu_array_cost dmus i) \\<le> (\\<Sum> ii \\<in> {i ..< m}. 2 * n + (2 * n + 1 + 2 * ii) * ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (dmu_array_cost dmus i) = dmu_array fs m dmus i &&&\n    cost (dmu_array_cost dmus i)\n    \\<le> (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. result (dmu_array_cost dmus i) = dmu_array fs m dmus i &&&\n    cost (dmu_array_cost dmus i)\n    \\<le> (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "proof (atomize(full), induct \"m - i\" arbitrary: i dmus)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i dmus.\n       \\<lbrakk>0 = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)\n 2. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "case (0 i dmus)"], ["proof (state)\nthis:\n  0 = m - i\n  i \\<le> m\n\ngoal (2 subgoals):\n 1. \\<And>i dmus.\n       \\<lbrakk>0 = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)\n 2. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "hence i: \"i = m\""], ["proof (prove)\nusing this:\n  0 = m - i\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. i = m", "by auto"], ["proof (state)\nthis:\n  i = m\n\ngoal (2 subgoals):\n 1. \\<And>i dmus.\n       \\<lbrakk>0 = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)\n 2. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "thus ?case"], ["proof (prove)\nusing this:\n  i = m\n\ngoal (1 subgoal):\n 1. result (dmu_array_cost dmus i) = dmu_array fs m dmus i \\<and>\n    cost (dmu_array_cost dmus i)\n    \\<le> (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "unfolding dmu_array_cost.simps[of _ i] \n    dmu_array.simps[of _ _ _ i]"], ["proof (prove)\nusing this:\n  i = m\n\ngoal (1 subgoal):\n 1. result\n     (if m \\<le> i then (dmus, 0)\n      else let (dmus', cost_row) = dmu_array_row_cost dmus i;\n               (res, cost_rec) = dmu_array_cost dmus' (Suc i)\n           in (res, cost_row + cost_rec)) =\n    (if i = m then dmus\n     else let dmus' = dmu_array_row fs dmus i\n          in dmu_array fs m dmus' (Suc i)) \\<and>\n    cost\n     (if m \\<le> i then (dmus, 0)\n      else let (dmus', cost_row) = dmu_array_row_cost dmus i;\n               (res, cost_rec) = dmu_array_cost dmus' (Suc i)\n           in (res, cost_row + cost_rec))\n    \\<le> (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "by (simp add: cost_simps)"], ["proof (state)\nthis:\n  result (dmu_array_cost dmus i) = dmu_array fs m dmus i \\<and>\n  cost (dmu_array_cost dmus i)\n  \\<le> (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "case (Suc k i dmus)"], ["proof (state)\nthis:\n  \\<lbrakk>k = m - ?i1; ?i1 \\<le> m\\<rbrakk>\n  \\<Longrightarrow> result (dmu_array_cost ?dmus1 ?i1) =\n                    dmu_array fs m ?dmus1 ?i1 \\<and>\n                    cost (dmu_array_cost ?dmus1 ?i1)\n                    \\<le> (\\<Sum>ii = ?i1..<m.\n                              2 * n + (2 * n + 1 + 2 * ii) * ii)\n  Suc k = m - i\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "obtain dmus' c_row where row_c: \"dmu_array_row_cost dmus i = (dmus',c_row)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>dmus' c_row.\n        dmu_array_row_cost dmus i = (dmus', c_row) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  dmu_array_row_cost dmus i = (dmus', c_row)\n\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "from result_costD[OF dmu_array_row_cost row_c]"], ["proof (chain)\npicking this:\n  dmus' = dmu_array_row fs dmus i\n  c_row \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "have row: \"dmu_array_row fs dmus i = dmus'\" \n    and c_row: \"c_row \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\" (is \"_ \\<le> ?c i\")"], ["proof (prove)\nusing this:\n  dmus' = dmu_array_row fs dmus i\n  c_row \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\n\ngoal (1 subgoal):\n 1. dmu_array_row fs dmus i = dmus' &&&\n    c_row \\<le> 2 * n + (2 * n + 1 + 2 * i) * i", "by auto"], ["proof (state)\nthis:\n  dmu_array_row fs dmus i = dmus'\n  c_row \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\n\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>k = m - ?i1; ?i1 \\<le> m\\<rbrakk>\n  \\<Longrightarrow> result (dmu_array_cost ?dmus1 ?i1) =\n                    dmu_array fs m ?dmus1 ?i1 \\<and>\n                    cost (dmu_array_cost ?dmus1 ?i1)\n                    \\<le> (\\<Sum>ii = ?i1..<m.\n                              2 * n + (2 * n + 1 + 2 * ii) * ii)\n  Suc k = m - i\n  i \\<le> m", "have \"k = m - Suc i\" \"Suc i \\<le> m\" \n    and id: \"(m \\<le> i) = False\" \"(i = m) = False\""], ["proof (prove)\nusing this:\n  \\<lbrakk>k = m - ?i1; ?i1 \\<le> m\\<rbrakk>\n  \\<Longrightarrow> result (dmu_array_cost ?dmus1 ?i1) =\n                    dmu_array fs m ?dmus1 ?i1 \\<and>\n                    cost (dmu_array_cost ?dmus1 ?i1)\n                    \\<le> (\\<Sum>ii = ?i1..<m.\n                              2 * n + (2 * n + 1 + 2 * ii) * ii)\n  Suc k = m - i\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. (k = m - Suc i &&& Suc i \\<le> m) &&&\n    (m \\<le> i) = False &&& (i = m) = False", "by auto"], ["proof (state)\nthis:\n  k = m - Suc i\n  Suc i \\<le> m\n  (m \\<le> i) = False\n  (i = m) = False\n\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "note IH = Suc(1)[OF this(1-2)]"], ["proof (state)\nthis:\n  result (dmu_array_cost ?dmus1 (Suc i)) =\n  dmu_array fs m ?dmus1 (Suc i) \\<and>\n  cost (dmu_array_cost ?dmus1 (Suc i))\n  \\<le> (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "obtain res c_rec where rec_c: \"dmu_array_cost dmus' (Suc i) = (res, c_rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>res c_rec.\n        dmu_array_cost dmus' (Suc i) = (res, c_rec) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  dmu_array_cost dmus' (Suc i) = (res, c_rec)\n\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "from result_costD'[OF IH rec_c]"], ["proof (chain)\npicking this:\n  res = dmu_array fs m dmus' (Suc i)\n  c_rec \\<le> (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "have rec: \"dmu_array fs m dmus' (Suc i) = res\" \n    and c_rec: \"c_rec \\<le> (\\<Sum>ii = Suc i..<m. ?c ii)\""], ["proof (prove)\nusing this:\n  res = dmu_array fs m dmus' (Suc i)\n  c_rec \\<le> (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. dmu_array fs m dmus' (Suc i) = res &&&\n    c_rec \\<le> (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "by auto"], ["proof (state)\nthis:\n  dmu_array fs m dmus' (Suc i) = res\n  c_rec \\<le> (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "have \"c_row + c_rec \\<le> ?c i + (\\<Sum>ii = Suc i..<m. ?c ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_row + c_rec\n    \\<le> 2 * n + (2 * n + 1 + 2 * i) * i +\n          (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "using c_rec c_row"], ["proof (prove)\nusing this:\n  c_rec \\<le> (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n  c_row \\<le> 2 * n + (2 * n + 1 + 2 * i) * i\n\ngoal (1 subgoal):\n 1. c_row + c_rec\n    \\<le> 2 * n + (2 * n + 1 + 2 * i) * i +\n          (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "by auto"], ["proof (state)\nthis:\n  c_row + c_rec\n  \\<le> 2 * n + (2 * n + 1 + 2 * i) * i +\n        (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "also"], ["proof (state)\nthis:\n  c_row + c_rec\n  \\<le> 2 * n + (2 * n + 1 + 2 * i) * i +\n        (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "have \"\\<dots> = (\\<Sum>ii = i..<m. ?c ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * n + (2 * n + 1 + 2 * i) * i +\n    (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii) =\n    (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "by (subst sum.atLeast_Suc_lessThan [of i]) (use Suc in auto)"], ["proof (state)\nthis:\n  2 * n + (2 * n + 1 + 2 * i) * i +\n  (\\<Sum>ii = Suc i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii) =\n  (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. \\<And>x i dmus.\n       \\<lbrakk>\\<And>i dmus.\n                   \\<lbrakk>x = m - i; i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                                     dmu_array fs m dmus i \\<and>\n                                     cost (dmu_array_cost dmus i)\n                                     \\<le> (\\<Sum>ii = i..<m.\n         2 * n + (2 * n + 1 + 2 * ii) * ii);\n        Suc x = m - i; i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> result (dmu_array_cost dmus i) =\n                         dmu_array fs m dmus i \\<and>\n                         cost (dmu_array_cost dmus i)\n                         \\<le> (\\<Sum>ii = i..<m.\n                                   2 * n + (2 * n + 1 + 2 * ii) * ii)", "finally"], ["proof (chain)\npicking this:\n  c_row + c_rec \\<le> (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "show ?case"], ["proof (prove)\nusing this:\n  c_row + c_rec \\<le> (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. result (dmu_array_cost dmus i) = dmu_array fs m dmus i \\<and>\n    cost (dmu_array_cost dmus i)\n    \\<le> (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "unfolding dmu_array_cost.simps[of _ i] \n    dmu_array.simps[of _ _ _ i] id if_False Let_def rec_c row_c row rec split cost_simps"], ["proof (prove)\nusing this:\n  c_row + c_rec \\<le> (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. res = res \\<and>\n    c_row + c_rec\n    \\<le> (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "by auto"], ["proof (state)\nthis:\n  result (dmu_array_cost dmus i) = dmu_array fs m dmus i \\<and>\n  cost (dmu_array_cost dmus i)\n  \\<le> (\\<Sum>ii = i..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* fs *)"], ["", "definition d\\<mu>_impl_cost :: \"int vec list \\<Rightarrow> int iarray iarray cost\" where\n  \"d\\<mu>_impl_cost fs = dmu_array_cost (IArray fs) (IArray []) 0\""], ["", "lemma d\\<mu>_impl_cost: \"result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init\" \n  \"cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init &&&\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "let ?fs = \"IArray fs_init\""], ["proof (state)\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "let ?dmus = \"IArray []\""], ["proof (state)\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "obtain res cost where res_c: \"dmu_array_cost ?fs ?dmus 0 = (res, cost)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>res cost.\n        dmu_array_cost (IArray fs_init) (IArray []) 0 =\n        (res, cost) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  dmu_array_cost (IArray fs_init) (IArray []) 0 = (res, cost)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "from result_costD[OF dmu_array_cost res_c]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> m; 0 \\<le> m\\<rbrakk>\n  \\<Longrightarrow> res = dmu_array (IArray fs_init) m (IArray []) 0\n  \\<lbrakk>0 \\<le> m; 0 \\<le> m\\<rbrakk>\n  \\<Longrightarrow> cost\n                    \\<le> (\\<Sum>ii = 0..<m.\n                              2 * n + (2 * n + 1 + 2 * ii) * ii)", "have res: \"dmu_array ?fs m ?dmus 0 = res\" \n    and cost: \"cost \\<le> (\\<Sum>ii = 0..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii) \""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> m; 0 \\<le> m\\<rbrakk>\n  \\<Longrightarrow> res = dmu_array (IArray fs_init) m (IArray []) 0\n  \\<lbrakk>0 \\<le> m; 0 \\<le> m\\<rbrakk>\n  \\<Longrightarrow> cost\n                    \\<le> (\\<Sum>ii = 0..<m.\n                              2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. dmu_array (IArray fs_init) m (IArray []) 0 = res &&&\n    cost \\<le> (\\<Sum>ii = 0..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)", "by auto"], ["proof (state)\nthis:\n  dmu_array (IArray fs_init) m (IArray []) 0 = res\n  cost \\<le> (\\<Sum>ii = 0..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "note cost"], ["proof (state)\nthis:\n  cost \\<le> (\\<Sum>ii = 0..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "also"], ["proof (state)\nthis:\n  cost \\<le> (\\<Sum>ii = 0..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "have \"(\\<Sum>ii = 0..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii) \n     = 2 * n * m + (2 * n + 1) * (\\<Sum>ii = 0..<m.  ii) + 2 * (\\<Sum>ii = 0..<m. ii * ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ii = 0..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii) =\n    2 * n * m + (2 * n + 1) * \\<Sum> {0..<m} +\n    2 * (\\<Sum>ii = 0..<m. ii * ii)", "by (auto simp: field_simps sum.distrib sum_distrib_left intro: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>ii = 0..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii) =\n  2 * n * m + (2 * n + 1) * \\<Sum> {0..<m} + 2 * (\\<Sum>ii = 0..<m. ii * ii)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ii = 0..<m. 2 * n + (2 * n + 1 + 2 * ii) * ii) =\n  2 * n * m + (2 * n + 1) * \\<Sum> {0..<m} + 2 * (\\<Sum>ii = 0..<m. ii * ii)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "have \"\\<dots> \\<le> 2 * n * m + (2 * n + 2) * (\\<Sum>ii = 0..<m.  ii) + 2 * (\\<Sum>ii = 0..<m. ii * ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * n * m + (2 * n + 1) * \\<Sum> {0..<m} +\n    2 * (\\<Sum>ii = 0..<m. ii * ii)\n    \\<le> 2 * n * m + (2 * n + 2) * \\<Sum> {0..<m} +\n          2 * (\\<Sum>ii = 0..<m. ii * ii)", "by auto"], ["proof (state)\nthis:\n  2 * n * m + (2 * n + 1) * \\<Sum> {0..<m} + 2 * (\\<Sum>ii = 0..<m. ii * ii)\n  \\<le> 2 * n * m + (2 * n + 2) * \\<Sum> {0..<m} +\n        2 * (\\<Sum>ii = 0..<m. ii * ii)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "also"], ["proof (state)\nthis:\n  2 * n * m + (2 * n + 1) * \\<Sum> {0..<m} + 2 * (\\<Sum>ii = 0..<m. ii * ii)\n  \\<le> 2 * n * m + (2 * n + 2) * \\<Sum> {0..<m} +\n        2 * (\\<Sum>ii = 0..<m. ii * ii)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "have \"(2 * n + 2) * (\\<Sum>ii = 0..<m.  ii) = (n + 1) * (2 * (\\<Sum>ii = 0..<m.  ii))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * n + 2) * \\<Sum> {0..<m} = (n + 1) * (2 * \\<Sum> {0..<m})", "by auto"], ["proof (state)\nthis:\n  (2 * n + 2) * \\<Sum> {0..<m} = (n + 1) * (2 * \\<Sum> {0..<m})\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "also"], ["proof (state)\nthis:\n  (2 * n + 2) * \\<Sum> {0..<m} = (n + 1) * (2 * \\<Sum> {0..<m})\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "have \"2 * (\\<Sum>ii = 0..<m.  ii) = m * (m - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * \\<Sum> {0..<m} = m * (m - 1)", "by (induct m, force, rename_tac i, case_tac i, auto)"], ["proof (state)\nthis:\n  2 * \\<Sum> {0..<m} = m * (m - 1)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "also"], ["proof (state)\nthis:\n  2 * \\<Sum> {0..<m} = m * (m - 1)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "have \"2 * (\\<Sum>ii = 0..<m.  ii * ii) = (6 * (\\<Sum>ii = 0..<m.  ii * ii)) div 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (\\<Sum>ii = 0..<m. ii * ii) = 6 * (\\<Sum>ii = 0..<m. ii * ii) div 3", "by simp"], ["proof (state)\nthis:\n  2 * (\\<Sum>ii = 0..<m. ii * ii) = 6 * (\\<Sum>ii = 0..<m. ii * ii) div 3\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "also"], ["proof (state)\nthis:\n  2 * (\\<Sum>ii = 0..<m. ii * ii) = 6 * (\\<Sum>ii = 0..<m. ii * ii) div 3\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "have \"6 * (\\<Sum>ii = 0..<m.  ii * ii) = 2 * (m - 1)*(m-1)*(m-1) + 3 * (m - 1) * (m - 1) + (m - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 6 * (\\<Sum>ii = 0..<m. ii * ii) =\n    2 * (m - 1) * (m - 1) * (m - 1) + 3 * (m - 1) * (m - 1) + (m - 1)", "by (induct m, simp, rename_tac i, case_tac i, auto simp: field_simps)"], ["proof (state)\nthis:\n  6 * (\\<Sum>ii = 0..<m. ii * ii) =\n  2 * (m - 1) * (m - 1) * (m - 1) + 3 * (m - 1) * (m - 1) + (m - 1)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "finally"], ["proof (chain)\npicking this:\n  cost\n  \\<le> 2 * n * m + (n + 1) * (m * (m - 1)) +\n        (2 * (m - 1) * (m - 1) * (m - 1) + 3 * (m - 1) * (m - 1) +\n         (m - 1)) div\n        3", "have \"cost \\<le> 2 * n * m + (n + 1) * (m * (m - 1)) \n    + (2 * (m - 1) * (m - 1) * (m - 1) + 3 * (m - 1) * (m - 1) + (m - 1)) div 3\""], ["proof (prove)\nusing this:\n  cost\n  \\<le> 2 * n * m + (n + 1) * (m * (m - 1)) +\n        (2 * (m - 1) * (m - 1) * (m - 1) + 3 * (m - 1) * (m - 1) +\n         (m - 1)) div\n        3\n\ngoal (1 subgoal):\n 1. cost\n    \\<le> 2 * n * m + (n + 1) * (m * (m - 1)) +\n          (2 * (m - 1) * (m - 1) * (m - 1) + 3 * (m - 1) * (m - 1) +\n           (m - 1)) div\n          3", "."], ["proof (state)\nthis:\n  cost\n  \\<le> 2 * n * m + (n + 1) * (m * (m - 1)) +\n        (2 * (m - 1) * (m - 1) * (m - 1) + 3 * (m - 1) * (m - 1) +\n         (m - 1)) div\n        3\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "also"], ["proof (state)\nthis:\n  cost\n  \\<le> 2 * n * m + (n + 1) * (m * (m - 1)) +\n        (2 * (m - 1) * (m - 1) * (m - 1) + 3 * (m - 1) * (m - 1) +\n         (m - 1)) div\n        3\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "have \"\\<dots> \\<le> 2 * n * m + (n + 1) * (m * m) + (3 * m * m * m + 3 * m * m + 3 * m) div 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * n * m + (n + 1) * (m * (m - 1)) +\n    (2 * (m - 1) * (m - 1) * (m - 1) + 3 * (m - 1) * (m - 1) + (m - 1)) div\n    3\n    \\<le> 2 * n * m + (n + 1) * (m * m) +\n          (3 * m * m * m + 3 * m * m + 3 * m) div 3", "by (intro add_mono div_le_mono mult_mono, auto)"], ["proof (state)\nthis:\n  2 * n * m + (n + 1) * (m * (m - 1)) +\n  (2 * (m - 1) * (m - 1) * (m - 1) + 3 * (m - 1) * (m - 1) + (m - 1)) div 3\n  \\<le> 2 * n * m + (n + 1) * (m * m) +\n        (3 * m * m * m + 3 * m * m + 3 * m) div 3\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "also"], ["proof (state)\nthis:\n  2 * n * m + (n + 1) * (m * (m - 1)) +\n  (2 * (m - 1) * (m - 1) * (m - 1) + 3 * (m - 1) * (m - 1) + (m - 1)) div 3\n  \\<le> 2 * n * m + (n + 1) * (m * m) +\n        (3 * m * m * m + 3 * m * m + 3 * m) div 3\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "have \"\\<dots> = 2 * n * m + (n + 1) * (m * m) + (m * m * m + m * m + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * n * m + (n + 1) * (m * m) +\n    (3 * m * m * m + 3 * m * m + 3 * m) div 3 =\n    2 * n * m + (n + 1) * (m * m) + (m * m * m + m * m + m)", "by simp"], ["proof (state)\nthis:\n  2 * n * m + (n + 1) * (m * m) +\n  (3 * m * m * m + 3 * m * m + 3 * m) div 3 =\n  2 * n * m + (n + 1) * (m * m) + (m * m * m + m * m + m)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "also"], ["proof (state)\nthis:\n  2 * n * m + (n + 1) * (m * m) +\n  (3 * m * m * m + 3 * m * m + 3 * m) div 3 =\n  2 * n * m + (n + 1) * (m * m) + (m * m * m + m * m + m)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "have \"\\<dots> = m * (m * (m + n + 2) + 2 * n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * n * m + (n + 1) * (m * m) + (m * m * m + m * m + m) =\n    m * (m * (m + n + 2) + 2 * n + 1)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  2 * n * m + (n + 1) * (m * m) + (m * m * m + m * m + m) =\n  m * (m * (m + n + 2) + 2 * n + 1)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "finally"], ["proof (chain)\npicking this:\n  cost \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "show ?case"], ["proof (prove)\nusing this:\n  cost \\<le> m * (m * (m + n + 2) + 2 * n + 1)\n\ngoal (1 subgoal):\n 1. result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n    cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "unfolding d\\<mu>_impl_cost_def d\\<mu>_impl_def len res res_c cost_simps"], ["proof (prove)\nusing this:\n  cost \\<le> m * (m * (m + n + 2) + 2 * n + 1)\n\ngoal (1 subgoal):\n 1. res = res \\<and> cost \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "by simp"], ["proof (state)\nthis:\n  result (d\\<mu>_impl_cost fs_init) = d\\<mu>_impl fs_init \\<and>\n  cost (d\\<mu>_impl_cost fs_init) \\<le> m * (m * (m + n + 2) + 2 * n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"initial_gso_cost = m * (m * (m + n + 2) + 2 * n + 1)\""], ["", "definition \"initial_state_cost fs = (let\n  (dmus, cost) = d\\<mu>_impl_cost fs;\n  ds = IArray.of_fun (\\<lambda> i. if i = 0 then 1 else let i1 = i - 1 in dmus !! i1 !! i1) (Suc m);\n  dmus' = IArray.of_fun (\\<lambda> i. let row_i = dmus !! i in\n       IArray.of_fun (\\<lambda> j. row_i !! j) i) m\n  in ((([], fs), dmus', ds), cost) :: LLL_dmu_d_state cost)\""], ["", "definition basis_reduction_cost :: \"_ \\<Rightarrow> LLL_dmu_d_state cost\" where \n  \"basis_reduction_cost fs = (\n    case initial_state_cost fs of (state1, c1) \\<Rightarrow> \n    case basis_reduction_main_cost True 0 state1 0 of (state2, c2) \\<Rightarrow> \n      (state2, c1 + c2))\""], ["", "definition reduce_basis_cost :: \"_ \\<Rightarrow> int vec list cost\" where\n  \"reduce_basis_cost fs = (case fs of Nil \\<Rightarrow> (fs, 0) | Cons f _ \\<Rightarrow> \n    case basis_reduction_cost fs of (state,c) \\<Rightarrow> \n    (fs_state state, c))\""], ["", "lemma initial_state_cost: \"result (initial_state_cost fs_init) = initial_state m fs_init\" (is ?g1)\n  \"cost (initial_state_cost fs_init) \\<le> initial_gso_cost\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (initial_state_cost fs_init) = initial_state m fs_init &&&\n    cost (initial_state_cost fs_init) \\<le> initial_gso_cost", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. result (initial_state_cost fs_init) = initial_state m fs_init\n 2. cost (initial_state_cost fs_init) \\<le> initial_gso_cost", "obtain st c where dmu: \"d\\<mu>_impl_cost fs_init = (st,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st c.\n        d\\<mu>_impl_cost fs_init = (st, c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  d\\<mu>_impl_cost fs_init = (st, c)\n\ngoal (2 subgoals):\n 1. result (initial_state_cost fs_init) = initial_state m fs_init\n 2. cost (initial_state_cost fs_init) \\<le> initial_gso_cost", "from d\\<mu>_impl_cost[unfolded dmu cost_simps]"], ["proof (chain)\npicking this:\n  st = d\\<mu>_impl fs_init\n  c \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "have dmu': \"d\\<mu>_impl fs_init = st\" and c: \"c \\<le> initial_gso_cost\""], ["proof (prove)\nusing this:\n  st = d\\<mu>_impl fs_init\n  c \\<le> m * (m * (m + n + 2) + 2 * n + 1)\n\ngoal (1 subgoal):\n 1. d\\<mu>_impl fs_init = st &&& c \\<le> initial_gso_cost", "unfolding initial_gso_cost_def"], ["proof (prove)\nusing this:\n  st = d\\<mu>_impl fs_init\n  c \\<le> m * (m * (m + n + 2) + 2 * n + 1)\n\ngoal (1 subgoal):\n 1. d\\<mu>_impl fs_init = st &&& c \\<le> m * (m * (m + n + 2) + 2 * n + 1)", "by auto"], ["proof (state)\nthis:\n  d\\<mu>_impl fs_init = st\n  c \\<le> initial_gso_cost\n\ngoal (2 subgoals):\n 1. result (initial_state_cost fs_init) = initial_state m fs_init\n 2. cost (initial_state_cost fs_init) \\<le> initial_gso_cost", "show ?g1 ?g2"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (initial_state_cost fs_init) = initial_state m fs_init &&&\n    cost (initial_state_cost fs_init) \\<le> initial_gso_cost", "using c"], ["proof (prove)\nusing this:\n  c \\<le> initial_gso_cost\n\ngoal (1 subgoal):\n 1. result (initial_state_cost fs_init) = initial_state m fs_init &&&\n    cost (initial_state_cost fs_init) \\<le> initial_gso_cost", "unfolding initial_state_cost_def dmu dmu' split cost_simps \n    initial_state_def Let_def"], ["proof (prove)\nusing this:\n  c \\<le> initial_gso_cost\n\ngoal (1 subgoal):\n 1. (([], fs_init),\n     IArray.of_fun (\\<lambda>i. IArray.of_fun ((!!) (st !! i)) i) m,\n     IArray.of_fun\n      (\\<lambda>i. if i = 0 then 1 else st !! (i - 1) !! (i - 1)) (Suc m)) =\n    (([], fs_init),\n     IArray.of_fun (\\<lambda>i. IArray.of_fun ((!!) (st !! i)) i) m,\n     IArray.of_fun\n      (\\<lambda>i. if i = 0 then 1 else st !! (i - 1) !! (i - 1))\n      (Suc m)) &&&\n    c \\<le> initial_gso_cost", "by auto"], ["proof (state)\nthis:\n  result (initial_state_cost fs_init) = initial_state m fs_init\n  cost (initial_state_cost fs_init) \\<le> initial_gso_cost\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_cost: \n   \"result (basis_reduction_cost fs_init) = basis_reduction \\<alpha> n fs_init\"  (is ?g1)\n   \"cost (basis_reduction_cost fs_init) \\<le> initial_gso_cost + body_cost * num_loops\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init &&&\n    cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init\n 2. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "obtain state1 c1 where init: \"initial_state_cost fs_init = (state1, c1)\" (is \"?init = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state1 c1.\n        initial_state_cost fs_init = (state1, c1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?init, auto)"], ["proof (state)\nthis:\n  initial_state_cost fs_init = (state1, c1)\n\ngoal (2 subgoals):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init\n 2. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "obtain state2 c2 where main: \"basis_reduction_main_cost True 0 state1 0 = (state2, c2)\" (is \"?main = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state2 c2.\n        basis_reduction_main_cost True 0 state1 0 =\n        (state2, c2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?main, auto)"], ["proof (state)\nthis:\n  basis_reduction_main_cost True 0 state1 0 = (state2, c2)\n\ngoal (2 subgoals):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init\n 2. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "have res: \"basis_reduction_cost fs_init = (state2, c1 + c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_reduction_cost fs_init = (state2, c1 + c2)", "unfolding basis_reduction_cost_def init main split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (state2, c1 + c2) = (state2, c1 + c2)", "by simp"], ["proof (state)\nthis:\n  basis_reduction_cost fs_init = (state2, c1 + c2)\n\ngoal (2 subgoals):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init\n 2. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "from result_costD[OF initial_state_cost init]"], ["proof (chain)\npicking this:\n  state1 = initial_state m fs_init\n  c1 \\<le> initial_gso_cost", "have c1: \"c1 \\<le> initial_gso_cost\" and init: \"initial_state m fs_init = state1\""], ["proof (prove)\nusing this:\n  state1 = initial_state m fs_init\n  c1 \\<le> initial_gso_cost\n\ngoal (1 subgoal):\n 1. c1 \\<le> initial_gso_cost &&& initial_state m fs_init = state1", "by auto"], ["proof (state)\nthis:\n  c1 \\<le> initial_gso_cost\n  initial_state m fs_init = state1\n\ngoal (2 subgoals):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init\n 2. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "note inv = LLL_inv_initial_state(1)"], ["proof (state)\nthis:\n  LLL_invariant True 0 fs_init\n\ngoal (2 subgoals):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init\n 2. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "note impl = initial_state"], ["proof (state)\nthis:\n  LLL_impl_inv (initial_state m fs_init) 0 fs_init\n  fs_state (initial_state m fs_init) = fs_init\n\ngoal (2 subgoals):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init\n 2. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "have fs: \"fs_state (initial_state m fs_init) = fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_state (initial_state m fs_init) = fs_init", "by fact"], ["proof (state)\nthis:\n  fs_state (initial_state m fs_init) = fs_init\n\ngoal (2 subgoals):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init\n 2. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "from basis_reduction_main_cost[of \"initial_state m fs_init\" _ _ 0, unfolded fs, OF impl(1) inv,\n    unfolded init main cost_simps]"], ["proof (chain)\npicking this:\n  \\<lbrakk>state1 = state1; 0 = 0\\<rbrakk>\n  \\<Longrightarrow> state2 =\n                    LLL_Impl.basis_reduction_main \\<alpha> n m True 0 state1\n  \\<lbrakk>state1 = state1; 0 = 0\\<rbrakk>\n  \\<Longrightarrow> c2 \\<le> 0 + body_cost * num_loops", "have main: \"LLL_Impl.basis_reduction_main \\<alpha> n m True 0 state1 = state2\" and c2: \"c2 \\<le> body_cost * num_loops\""], ["proof (prove)\nusing this:\n  \\<lbrakk>state1 = state1; 0 = 0\\<rbrakk>\n  \\<Longrightarrow> state2 =\n                    LLL_Impl.basis_reduction_main \\<alpha> n m True 0 state1\n  \\<lbrakk>state1 = state1; 0 = 0\\<rbrakk>\n  \\<Longrightarrow> c2 \\<le> 0 + body_cost * num_loops\n\ngoal (1 subgoal):\n 1. LLL_Impl.basis_reduction_main \\<alpha> n m True 0 state1 = state2 &&&\n    c2 \\<le> body_cost * num_loops", "by auto"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_main \\<alpha> n m True 0 state1 = state2\n  c2 \\<le> body_cost * num_loops\n\ngoal (2 subgoals):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init\n 2. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "have res': \"basis_reduction \\<alpha> n fs_init = state2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_reduction \\<alpha> n fs_init = state2", "unfolding basis_reduction_def len init main Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. state2 = state2", ".."], ["proof (state)\nthis:\n  basis_reduction \\<alpha> n fs_init = state2\n\ngoal (2 subgoals):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init\n 2. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "show ?g1"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (basis_reduction_cost fs_init) =\n    basis_reduction \\<alpha> n fs_init", "unfolding res res' cost_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. state2 = state2", ".."], ["proof (state)\nthis:\n  result (basis_reduction_cost fs_init) = basis_reduction \\<alpha> n fs_init\n\ngoal (1 subgoal):\n 1. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "show ?g2"], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (basis_reduction_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "unfolding res cost_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 + c2 \\<le> initial_gso_cost + body_cost * num_loops", "using c1 c2"], ["proof (prove)\nusing this:\n  c1 \\<le> initial_gso_cost\n  c2 \\<le> body_cost * num_loops\n\ngoal (1 subgoal):\n 1. c1 + c2 \\<le> initial_gso_cost + body_cost * num_loops", "by auto"], ["proof (state)\nthis:\n  cost (basis_reduction_cost fs_init)\n  \\<le> initial_gso_cost + body_cost * num_loops\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The lemma for the LLL algorithm with explicit cost annotations @{const reduce_basis_cost}\n  shows that the termination measure\n  indeed gives rise to an explicit cost bound. Moreover, the computed result is\n  the same as in the non-cost counting @{const reduce_basis}.\\<close>"], ["", "lemma reduce_basis_cost: \n   \"result (reduce_basis_cost fs_init) = LLL_Impl.reduce_basis \\<alpha> fs_init\"  (is ?g1)\n   \"cost (reduce_basis_cost fs_init) \\<le> initial_gso_cost + body_cost * num_loops\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (reduce_basis_cost fs_init) =\n    LLL_Impl.reduce_basis \\<alpha> fs_init &&&\n    cost (reduce_basis_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. result (reduce_basis_cost fs_init) =\n    LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n    cost (reduce_basis_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. result (reduce_basis_cost fs_init) =\n    LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n    cost (reduce_basis_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "note d = reduce_basis_cost_def LLL_Impl.reduce_basis_def"], ["proof (state)\nthis:\n  reduce_basis_cost ?fs =\n  (case ?fs of [] \\<Rightarrow> (?fs, 0)\n   | f # x \\<Rightarrow>\n       case basis_reduction_cost ?fs of\n       (state, c) \\<Rightarrow> (fs_state state, c))\n  LLL_Impl.reduce_basis ?\\<alpha> ?fs =\n  (case ?fs of [] \\<Rightarrow> ?fs\n   | f # x \\<Rightarrow>\n       fs_state (basis_reduction ?\\<alpha> (dim_vec f) ?fs))\n\ngoal (1 subgoal):\n 1. result (reduce_basis_cost fs_init) =\n    LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n    cost (reduce_basis_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (reduce_basis_cost fs_init) =\n    LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n    cost (reduce_basis_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "proof (cases fs_init)"], ["proof (state)\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow>\n    result (reduce_basis_cost fs_init) =\n    LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n    cost (reduce_basis_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       result (reduce_basis_cost fs_init) =\n       LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n       cost (reduce_basis_cost fs_init)\n       \\<le> initial_gso_cost + body_cost * num_loops", "case Nil"], ["proof (state)\nthis:\n  fs_init = []\n\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow>\n    result (reduce_basis_cost fs_init) =\n    LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n    cost (reduce_basis_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       result (reduce_basis_cost fs_init) =\n       LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n       cost (reduce_basis_cost fs_init)\n       \\<le> initial_gso_cost + body_cost * num_loops", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (reduce_basis_cost fs_init) =\n    LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n    cost (reduce_basis_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. result\n     (case fs_init of [] \\<Rightarrow> (fs_init, 0)\n      | f # x \\<Rightarrow>\n          case basis_reduction_cost fs_init of\n          (state, x) \\<Rightarrow> (fs_state state, x)) =\n    (case fs_init of [] \\<Rightarrow> fs_init\n     | f # x \\<Rightarrow>\n         fs_state (basis_reduction \\<alpha> (dim_vec f) fs_init)) \\<and>\n    cost\n     (case fs_init of [] \\<Rightarrow> (fs_init, 0)\n      | f # x \\<Rightarrow>\n          case basis_reduction_cost fs_init of\n          (state, x) \\<Rightarrow> (fs_state state, x))\n    \\<le> initial_gso_cost + body_cost * num_loops", "unfolding Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. result\n     (case [] of [] \\<Rightarrow> ([], 0)\n      | f # x \\<Rightarrow>\n          case basis_reduction_cost [] of\n          (state, x) \\<Rightarrow> (fs_state state, x)) =\n    (case [] of [] \\<Rightarrow> []\n     | f # x \\<Rightarrow>\n         fs_state (basis_reduction \\<alpha> (dim_vec f) [])) \\<and>\n    cost\n     (case [] of [] \\<Rightarrow> ([], 0)\n      | f # x \\<Rightarrow>\n          case basis_reduction_cost [] of\n          (state, x) \\<Rightarrow> (fs_state state, x))\n    \\<le> initial_gso_cost +\n          body_cost * LLL_with_assms.num_loops m [] \\<alpha>", "by (auto simp: cost_simps)"], ["proof (state)\nthis:\n  result (reduce_basis_cost fs_init) =\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n  cost (reduce_basis_cost fs_init)\n  \\<le> initial_gso_cost + body_cost * num_loops\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       result (reduce_basis_cost fs_init) =\n       LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n       cost (reduce_basis_cost fs_init)\n       \\<le> initial_gso_cost + body_cost * num_loops", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       result (reduce_basis_cost fs_init) =\n       LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n       cost (reduce_basis_cost fs_init)\n       \\<le> initial_gso_cost + body_cost * num_loops", "case (Cons f)"], ["proof (state)\nthis:\n  fs_init = f # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       result (reduce_basis_cost fs_init) =\n       LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n       cost (reduce_basis_cost fs_init)\n       \\<le> initial_gso_cost + body_cost * num_loops", "obtain state c where b: \"basis_reduction_cost fs_init = (state,c)\" (is \"?b = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state c.\n        basis_reduction_cost fs_init = (state, c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?b, auto)"], ["proof (state)\nthis:\n  basis_reduction_cost fs_init = (state, c)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       result (reduce_basis_cost fs_init) =\n       LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n       cost (reduce_basis_cost fs_init)\n       \\<le> initial_gso_cost + body_cost * num_loops", "from result_costD[OF basis_reduction_cost b]"], ["proof (chain)\npicking this:\n  state = basis_reduction \\<alpha> n fs_init\n  c \\<le> initial_gso_cost + body_cost * num_loops", "have bb: \"basis_reduction \\<alpha> n fs_init = state\" and c: \"c \\<le> initial_gso_cost + body_cost * num_loops\""], ["proof (prove)\nusing this:\n  state = basis_reduction \\<alpha> n fs_init\n  c \\<le> initial_gso_cost + body_cost * num_loops\n\ngoal (1 subgoal):\n 1. basis_reduction \\<alpha> n fs_init = state &&&\n    c \\<le> initial_gso_cost + body_cost * num_loops", "by auto"], ["proof (state)\nthis:\n  basis_reduction \\<alpha> n fs_init = state\n  c \\<le> initial_gso_cost + body_cost * num_loops\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       result (reduce_basis_cost fs_init) =\n       LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n       cost (reduce_basis_cost fs_init)\n       \\<le> initial_gso_cost + body_cost * num_loops", "from fs_init[unfolded Cons]"], ["proof (chain)\npicking this:\n  set (f # list_) \\<subseteq> carrier_vec n", "have dim: \"dim_vec f = n\""], ["proof (prove)\nusing this:\n  set (f # list_) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec f = n", "by auto"], ["proof (state)\nthis:\n  dim_vec f = n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       result (reduce_basis_cost fs_init) =\n       LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n       cost (reduce_basis_cost fs_init)\n       \\<le> initial_gso_cost + body_cost * num_loops", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (reduce_basis_cost fs_init) =\n    LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n    cost (reduce_basis_cost fs_init)\n    \\<le> initial_gso_cost + body_cost * num_loops", "unfolding d b split"], ["proof (prove)\ngoal (1 subgoal):\n 1. result\n     (case fs_init of [] \\<Rightarrow> (fs_init, 0)\n      | f # x \\<Rightarrow> (fs_state state, c)) =\n    (case fs_init of [] \\<Rightarrow> fs_init\n     | f # x \\<Rightarrow>\n         fs_state (basis_reduction \\<alpha> (dim_vec f) fs_init)) \\<and>\n    cost\n     (case fs_init of [] \\<Rightarrow> (fs_init, 0)\n      | f # x \\<Rightarrow> (fs_state state, c))\n    \\<le> initial_gso_cost + body_cost * num_loops", "unfolding Cons list.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (fs_state state, c) =\n    fs_state (basis_reduction \\<alpha> (dim_vec f) (f # list_)) \\<and>\n    cost (fs_state state, c)\n    \\<le> initial_gso_cost +\n          body_cost * LLL_with_assms.num_loops m (f # list_) \\<alpha>", "unfolding Cons[symmetric] dim bb"], ["proof (prove)\ngoal (1 subgoal):\n 1. result (fs_state state, c) = fs_state state \\<and>\n    cost (fs_state state, c) \\<le> initial_gso_cost + body_cost * num_loops", "using c"], ["proof (prove)\nusing this:\n  c \\<le> initial_gso_cost + body_cost * num_loops\n\ngoal (1 subgoal):\n 1. result (fs_state state, c) = fs_state state \\<and>\n    cost (fs_state state, c) \\<le> initial_gso_cost + body_cost * num_loops", "by (auto simp: cost_simps)"], ["proof (state)\nthis:\n  result (reduce_basis_cost fs_init) =\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n  cost (reduce_basis_cost fs_init)\n  \\<le> initial_gso_cost + body_cost * num_loops\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  result (reduce_basis_cost fs_init) =\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<and>\n  cost (reduce_basis_cost fs_init)\n  \\<le> initial_gso_cost + body_cost * num_loops\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mn: \"m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n", "unfolding len[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. length fs_init \\<le> n", "using lin_dep length_map"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)\n  length (map ?f ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length fs_init \\<le> n", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs_init) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n  length (map ?f ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length fs_init \\<le> n", "by (metis distinct_card gs.dim_is_n gs.fin_dim gs.li_le_dim(2))"], ["", "text \\<open>Theorem with expanded costs: $O(n\\cdot m^3 \\cdot \\log (\\mathit{maxnorm}\\ F))$ arithmetic operations\\<close>"], ["", "lemma reduce_basis_cost_expanded: \n  assumes \"Lg \\<ge> nat \\<lceil>log (of_rat (4 * \\<alpha> / (4 + \\<alpha>))) N\\<rceil>\"   \n  shows \"cost (reduce_basis_cost fs_init)\n  \\<le> 4 * Lg * m * m * m * n\n    + 4 * Lg * m * m * m * m\n    + 16 * Lg * m * m * m\n    + 4 * Lg * m * m\n    + 3 * m * m * m\n    + 3 * m * m * n \n    + 10 * m * m\n    + 2 * n * m \n    + 3 * m\" \n  (is \"?cost \\<le> ?exp Lg\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init)\n    \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n          16 * Lg * m * m * m +\n          4 * Lg * m * m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init)\n    \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n          16 * Lg * m * m * m +\n          4 * Lg * m * m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "define Log where \"Log = nat \\<lceil>log (of_rat (4 * \\<alpha> / (4 + \\<alpha>))) N\\<rceil>\""], ["proof (state)\nthis:\n  Log =\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init)\n    \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n          16 * Lg * m * m * m +\n          4 * Lg * m * m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "have Lg: \"Log \\<le> Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Log \\<le> Lg", "using assms"], ["proof (prove)\nusing this:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n  \\<le> Lg\n\ngoal (1 subgoal):\n 1. Log \\<le> Lg", "unfolding Log_def"], ["proof (prove)\nusing this:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n  \\<le> Lg\n\ngoal (1 subgoal):\n 1. nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                 (real N)\\<rceil>\n    \\<le> Lg", "."], ["proof (state)\nthis:\n  Log \\<le> Lg\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init)\n    \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n          16 * Lg * m * m * m +\n          4 * Lg * m * m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "have \"?cost \\<le> ?exp Log\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init)\n    \\<le> 4 * Log * m * m * m * n + 4 * Log * m * m * m * m +\n          16 * Log * m * m * m +\n          4 * Log * m * m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "unfolding Log_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init)\n    \\<le> 4 *\n          nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                       (real N)\\<rceil> *\n          m *\n          m *\n          m *\n          n +\n          4 *\n          nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                       (real N)\\<rceil> *\n          m *\n          m *\n          m *\n          m +\n          16 *\n          nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                       (real N)\\<rceil> *\n          m *\n          m *\n          m +\n          4 *\n          nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                       (real N)\\<rceil> *\n          m *\n          m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "using reduce_basis_cost(2)[unfolded num_loops_def body_cost_def initial_gso_cost_def base_def]"], ["proof (prove)\nusing this:\n  cost (reduce_basis_cost fs_init)\n  \\<le> m * (m * (m + n + 2) + 2 * n + 1) +\n        (2 + (8 + 2 * n + 2 * m) * m) *\n        (m +\n         2 * m * m *\n         nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                      (real N)\\<rceil>)\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init)\n    \\<le> 4 *\n          nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                       (real N)\\<rceil> *\n          m *\n          m *\n          m *\n          n +\n          4 *\n          nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                       (real N)\\<rceil> *\n          m *\n          m *\n          m *\n          m +\n          16 *\n          nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                       (real N)\\<rceil> *\n          m *\n          m *\n          m +\n          4 *\n          nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                       (real N)\\<rceil> *\n          m *\n          m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  cost (reduce_basis_cost fs_init)\n  \\<le> 4 * Log * m * m * m * n + 4 * Log * m * m * m * m +\n        16 * Log * m * m * m +\n        4 * Log * m * m +\n        3 * m * m * m +\n        3 * m * m * n +\n        10 * m * m +\n        2 * n * m +\n        3 * m\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init)\n    \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n          16 * Lg * m * m * m +\n          4 * Lg * m * m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "also"], ["proof (state)\nthis:\n  cost (reduce_basis_cost fs_init)\n  \\<le> 4 * Log * m * m * m * n + 4 * Log * m * m * m * m +\n        16 * Log * m * m * m +\n        4 * Log * m * m +\n        3 * m * m * m +\n        3 * m * m * n +\n        10 * m * m +\n        2 * n * m +\n        3 * m\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init)\n    \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n          16 * Lg * m * m * m +\n          4 * Lg * m * m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "have \"\\<dots> \\<le> ?exp Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * Log * m * m * m * n + 4 * Log * m * m * m * m +\n    16 * Log * m * m * m +\n    4 * Log * m * m +\n    3 * m * m * m +\n    3 * m * m * n +\n    10 * m * m +\n    2 * n * m +\n    3 * m\n    \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n          16 * Lg * m * m * m +\n          4 * Lg * m * m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "by (intro add_mono mult_mono Lg, auto)"], ["proof (state)\nthis:\n  4 * Log * m * m * m * n + 4 * Log * m * m * m * m + 16 * Log * m * m * m +\n  4 * Log * m * m +\n  3 * m * m * m +\n  3 * m * m * n +\n  10 * m * m +\n  2 * n * m +\n  3 * m\n  \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n        16 * Lg * m * m * m +\n        4 * Lg * m * m +\n        3 * m * m * m +\n        3 * m * m * n +\n        10 * m * m +\n        2 * n * m +\n        3 * m\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init)\n    \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n          16 * Lg * m * m * m +\n          4 * Lg * m * m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "finally"], ["proof (chain)\npicking this:\n  cost (reduce_basis_cost fs_init)\n  \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n        16 * Lg * m * m * m +\n        4 * Lg * m * m +\n        3 * m * m * m +\n        3 * m * m * n +\n        10 * m * m +\n        2 * n * m +\n        3 * m", "show ?thesis"], ["proof (prove)\nusing this:\n  cost (reduce_basis_cost fs_init)\n  \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n        16 * Lg * m * m * m +\n        4 * Lg * m * m +\n        3 * m * m * m +\n        3 * m * m * n +\n        10 * m * m +\n        2 * n * m +\n        3 * m\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init)\n    \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n          16 * Lg * m * m * m +\n          4 * Lg * m * m +\n          3 * m * m * m +\n          3 * m * m * n +\n          10 * m * m +\n          2 * n * m +\n          3 * m", "."], ["proof (state)\nthis:\n  cost (reduce_basis_cost fs_init)\n  \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n        16 * Lg * m * m * m +\n        4 * Lg * m * m +\n        3 * m * m * m +\n        3 * m * m * n +\n        10 * m * m +\n        2 * n * m +\n        3 * m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduce_basis_cost_0: assumes \"m = 0\" \n  shows \"cost (reduce_basis_cost fs_init) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init) = 0", "from len assms"], ["proof (chain)\npicking this:\n  length fs_init = m\n  m = 0", "have fs_init: \"fs_init = []\""], ["proof (prove)\nusing this:\n  length fs_init = m\n  m = 0\n\ngoal (1 subgoal):\n 1. fs_init = []", "by auto"], ["proof (state)\nthis:\n  fs_init = []\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  fs_init = []\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init) = 0", "unfolding reduce_basis_cost_def"], ["proof (prove)\nusing this:\n  fs_init = []\n\ngoal (1 subgoal):\n 1. cost\n     (case fs_init of [] \\<Rightarrow> (fs_init, 0)\n      | f # x \\<Rightarrow>\n          case basis_reduction_cost fs_init of\n          (state, x) \\<Rightarrow> (fs_state state, x)) =\n    0", "by (simp add: cost_simps)"], ["proof (state)\nthis:\n  cost (reduce_basis_cost fs_init) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduce_basis_cost_N:\n  assumes \"Lg \\<ge> nat \\<lceil>log (of_rat (4 * \\<alpha> / (4 + \\<alpha>))) N\\<rceil>\"   \n  and 0: \"Lg > 0\"  \n  shows \"cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "proof (cases \"m > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "case True"], ["proof (state)\nthis:\n  0 < m\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "with mn 0"], ["proof (chain)\npicking this:\n  m \\<le> n\n  0 < Lg\n  0 < m", "have 0: \"0 < Lg\" \"0 < m\" \"0 < n\""], ["proof (prove)\nusing this:\n  m \\<le> n\n  0 < Lg\n  0 < m\n\ngoal (1 subgoal):\n 1. 0 < Lg &&& 0 < m &&& 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < Lg\n  0 < m\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "note reduce_basis_cost_expanded[OF assms(1)]"], ["proof (state)\nthis:\n  cost (reduce_basis_cost fs_init)\n  \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n        16 * Lg * m * m * m +\n        4 * Lg * m * m +\n        3 * m * m * m +\n        3 * m * m * n +\n        10 * m * m +\n        2 * n * m +\n        3 * m\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  cost (reduce_basis_cost fs_init)\n  \\<le> 4 * Lg * m * m * m * n + 4 * Lg * m * m * m * m +\n        16 * Lg * m * m * m +\n        4 * Lg * m * m +\n        3 * m * m * m +\n        3 * m * m * n +\n        10 * m * m +\n        2 * n * m +\n        3 * m\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "have \"4 * Lg * m * m * m * n = 4 * m ^ 3 * n * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * Lg * m * m * m * n = 4 * m ^ 3 * n * Lg", "using 0"], ["proof (prove)\nusing this:\n  0 < Lg\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. 4 * Lg * m * m * m * n = 4 * m ^ 3 * n * Lg", "by (auto simp add: power3_eq_cube)"], ["proof (state)\nthis:\n  4 * Lg * m * m * m * n = 4 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  4 * Lg * m * m * m * n = 4 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "have \"4 * Lg * m * m * m * m \\<le> 4 * m ^ 3 * n * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * Lg * m * m * m * m \\<le> 4 * m ^ 3 * n * Lg", "using 0 mn"], ["proof (prove)\nusing this:\n  0 < Lg\n  0 < m\n  0 < n\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. 4 * Lg * m * m * m * m \\<le> 4 * m ^ 3 * n * Lg", "by (auto simp add: power3_eq_cube)"], ["proof (state)\nthis:\n  4 * Lg * m * m * m * m \\<le> 4 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  4 * Lg * m * m * m * m \\<le> 4 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "have \"16 * Lg * m * m * m \\<le> 16 * m ^ 3 * n * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 16 * Lg * m * m * m \\<le> 16 * m ^ 3 * n * Lg", "using 0"], ["proof (prove)\nusing this:\n  0 < Lg\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. 16 * Lg * m * m * m \\<le> 16 * m ^ 3 * n * Lg", "by (auto simp add: power3_eq_cube)"], ["proof (state)\nthis:\n  16 * Lg * m * m * m \\<le> 16 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  16 * Lg * m * m * m \\<le> 16 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "have \"4 * Lg * m * m \\<le> 4 *  m ^ 3 * n * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * Lg * m * m \\<le> 4 * m ^ 3 * n * Lg", "using 0"], ["proof (prove)\nusing this:\n  0 < Lg\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. 4 * Lg * m * m \\<le> 4 * m ^ 3 * n * Lg", "by (auto simp add: power3_eq_cube)"], ["proof (state)\nthis:\n  4 * Lg * m * m \\<le> 4 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  4 * Lg * m * m \\<le> 4 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "have \"3 * m * m * m \\<le> 3 *  m ^ 3 * n * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * m * m * m \\<le> 3 * m ^ 3 * n * Lg", "using 0"], ["proof (prove)\nusing this:\n  0 < Lg\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. 3 * m * m * m \\<le> 3 * m ^ 3 * n * Lg", "by (auto simp add: power3_eq_cube)"], ["proof (state)\nthis:\n  3 * m * m * m \\<le> 3 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  3 * m * m * m \\<le> 3 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "have \"3 * m * m * n \\<le> 3 * m ^ 3 * n * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * m * m * n \\<le> 3 * m ^ 3 * n * Lg", "using 0"], ["proof (prove)\nusing this:\n  0 < Lg\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. 3 * m * m * n \\<le> 3 * m ^ 3 * n * Lg", "by (auto simp add: power3_eq_cube)"], ["proof (state)\nthis:\n  3 * m * m * n \\<le> 3 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  3 * m * m * n \\<le> 3 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "have \"10 * m * m \\<le> 10 * m ^ 3 * n * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 10 * m * m \\<le> 10 * m ^ 3 * n * Lg", "using 0"], ["proof (prove)\nusing this:\n  0 < Lg\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. 10 * m * m \\<le> 10 * m ^ 3 * n * Lg", "by (auto simp add: power3_eq_cube)"], ["proof (state)\nthis:\n  10 * m * m \\<le> 10 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  10 * m * m \\<le> 10 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "have \"2 * n * m  \\<le> 2 * m ^ 3 * n * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * n * m \\<le> 2 * m ^ 3 * n * Lg", "using 0"], ["proof (prove)\nusing this:\n  0 < Lg\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. 2 * n * m \\<le> 2 * m ^ 3 * n * Lg", "by (auto simp add: power3_eq_cube)"], ["proof (state)\nthis:\n  2 * n * m \\<le> 2 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  2 * n * m \\<le> 2 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "have \"3 * m \\<le> 3 * m ^ 3 * n * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * m \\<le> 3 * m ^ 3 * n * Lg", "using 0"], ["proof (prove)\nusing this:\n  0 < Lg\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. 3 * m \\<le> 3 * m ^ 3 * n * Lg", "by (auto simp add: power3_eq_cube)"], ["proof (state)\nthis:\n  3 * m \\<le> 3 * m ^ 3 * n * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              4 * m ^ 3 * n * Lg + x + 16 * Lg * m * m * m +\n              4 * Lg * m * m +\n              3 * m * m * m +\n              3 * m * m * n +\n              10 * m * m +\n              2 * n * m +\n              3 * m\n              \\<le> 4 * m ^ 3 * n * Lg + y + 16 * Lg * m * m * m +\n                    4 * Lg * m * m +\n                    3 * m * m * m +\n                    3 * m * m * n +\n                    10 * m * m +\n                    2 * n * m +\n                    3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + x + 4 * Lg * m * m +\n      3 * m * m * m +\n      3 * m * m * n +\n      10 * m * m +\n      2 * n * m +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + y + 4 * Lg * m * m +\n            3 * m * m * m +\n            3 * m * m * n +\n            10 * m * m +\n            2 * n * m +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg + x +\n      3 * m * m * m +\n      3 * m * m * n +\n      10 * m * m +\n      2 * n * m +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            y +\n            3 * m * m * m +\n            3 * m * m * n +\n            10 * m * m +\n            2 * n * m +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n      4 * m ^ 3 * n * Lg +\n      x +\n      3 * m * m * n +\n      10 * m * m +\n      2 * n * m +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            4 * m ^ 3 * n * Lg +\n            y +\n            3 * m * m * n +\n            10 * m * m +\n            2 * n * m +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n      4 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      x +\n      10 * m * m +\n      2 * n * m +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            4 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            y +\n            10 * m * m +\n            2 * n * m +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n      4 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      x +\n      2 * n * m +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            4 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            y +\n            2 * n * m +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n      4 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      10 * m ^ 3 * n * Lg +\n      x +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            4 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            10 * m ^ 3 * n * Lg +\n            y +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n      4 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      10 * m ^ 3 * n * Lg +\n      2 * m ^ 3 * n * Lg +\n      x\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            4 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            10 * m ^ 3 * n * Lg +\n            2 * m ^ 3 * n * Lg +\n            y\\<rbrakk>\n  \\<Longrightarrow> cost (reduce_basis_cost fs_init)\n                    \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg +\n                          16 * m ^ 3 * n * Lg +\n                          4 * m ^ 3 * n * Lg +\n                          3 * m ^ 3 * n * Lg +\n                          3 * m ^ 3 * n * Lg +\n                          10 * m ^ 3 * n * Lg +\n                          2 * m ^ 3 * n * Lg +\n                          3 * m ^ 3 * n * Lg", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              4 * m ^ 3 * n * Lg + x + 16 * Lg * m * m * m +\n              4 * Lg * m * m +\n              3 * m * m * m +\n              3 * m * m * n +\n              10 * m * m +\n              2 * n * m +\n              3 * m\n              \\<le> 4 * m ^ 3 * n * Lg + y + 16 * Lg * m * m * m +\n                    4 * Lg * m * m +\n                    3 * m * m * m +\n                    3 * m * m * n +\n                    10 * m * m +\n                    2 * n * m +\n                    3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + x + 4 * Lg * m * m +\n      3 * m * m * m +\n      3 * m * m * n +\n      10 * m * m +\n      2 * n * m +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + y + 4 * Lg * m * m +\n            3 * m * m * m +\n            3 * m * m * n +\n            10 * m * m +\n            2 * n * m +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg + x +\n      3 * m * m * m +\n      3 * m * m * n +\n      10 * m * m +\n      2 * n * m +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            y +\n            3 * m * m * m +\n            3 * m * m * n +\n            10 * m * m +\n            2 * n * m +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n      4 * m ^ 3 * n * Lg +\n      x +\n      3 * m * m * n +\n      10 * m * m +\n      2 * n * m +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            4 * m ^ 3 * n * Lg +\n            y +\n            3 * m * m * n +\n            10 * m * m +\n            2 * n * m +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n      4 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      x +\n      10 * m * m +\n      2 * n * m +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            4 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            y +\n            10 * m * m +\n            2 * n * m +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n      4 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      x +\n      2 * n * m +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            4 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            y +\n            2 * n * m +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n      4 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      10 * m ^ 3 * n * Lg +\n      x +\n      3 * m\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            4 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            10 * m ^ 3 * n * Lg +\n            y +\n            3 * m;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n      4 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      3 * m ^ 3 * n * Lg +\n      10 * m ^ 3 * n * Lg +\n      2 * m ^ 3 * n * Lg +\n      x\n      \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg + 16 * m ^ 3 * n * Lg +\n            4 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            3 * m ^ 3 * n * Lg +\n            10 * m ^ 3 * n * Lg +\n            2 * m ^ 3 * n * Lg +\n            y\\<rbrakk>\n  \\<Longrightarrow> cost (reduce_basis_cost fs_init)\n                    \\<le> 4 * m ^ 3 * n * Lg + 4 * m ^ 3 * n * Lg +\n                          16 * m ^ 3 * n * Lg +\n                          4 * m ^ 3 * n * Lg +\n                          3 * m ^ 3 * n * Lg +\n                          3 * m ^ 3 * n * Lg +\n                          10 * m ^ 3 * n * Lg +\n                          2 * m ^ 3 * n * Lg +\n                          3 * m ^ 3 * n * Lg\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < m\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "with reduce_basis_cost_0"], ["proof (chain)\npicking this:\n  m = 0 \\<Longrightarrow> cost (reduce_basis_cost fs_init) = 0\n  \\<not> 0 < m", "show ?thesis"], ["proof (prove)\nusing this:\n  m = 0 \\<Longrightarrow> cost (reduce_basis_cost fs_init) = 0\n  \\<not> 0 < m\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg", "by simp"], ["proof (state)\nthis:\n  cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * Lg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduce_basis_cost_M:\n  assumes \"Lg \\<ge> nat \\<lceil>log (of_rat (4 * \\<alpha> / (4 + \\<alpha>))) (M * n)\\<rceil>\"   \n  and 0: \"Lg > 0\"\n  shows \"cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "proof (cases \"m > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "case True"], ["proof (state)\nthis:\n  0 < m\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "let ?prod = \"nat M * nat M * n\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "let ?p = \"nat M * nat M * n * n\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "let ?lg = \"real_of_int (M * n)\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "from 0 True"], ["proof (chain)\npicking this:\n  0 < Lg\n  0 < m", "have m0: \"m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < Lg\n  0 < m\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "from LLL_inv_N_pos[OF LLL_inv_imp_w[OF LLL_inv_initial_state] g_bound_fs_init m0]"], ["proof (chain)\npicking this:\n  0 < N", "have N0: \"N > 0\""], ["proof (prove)\nusing this:\n  0 < N\n\ngoal (1 subgoal):\n 1. 0 < N", "."], ["proof (state)\nthis:\n  0 < N\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "from N_le_MMn[OF m0]"], ["proof (chain)\npicking this:\n  N \\<le> nat M * nat M * n", "have N_prod: \"N \\<le> ?prod\""], ["proof (prove)\nusing this:\n  N \\<le> nat M * nat M * n\n\ngoal (1 subgoal):\n 1. N \\<le> nat M * nat M * n", "by auto"], ["proof (state)\nthis:\n  N \\<le> nat M * nat M * n\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "from N0 N_prod"], ["proof (chain)\npicking this:\n  0 < N\n  N \\<le> nat M * nat M * n", "have M0: \"M > 0\""], ["proof (prove)\nusing this:\n  0 < N\n  N \\<le> nat M * nat M * n\n\ngoal (1 subgoal):\n 1. 0 < M", "by (cases \"M \\<le> 0\", auto)"], ["proof (state)\nthis:\n  0 < M\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "from N0 N_prod"], ["proof (chain)\npicking this:\n  0 < N\n  N \\<le> nat M * nat M * n", "have prod0: \"0 < ?prod\""], ["proof (prove)\nusing this:\n  0 < N\n  N \\<le> nat M * nat M * n\n\ngoal (1 subgoal):\n 1. 0 < nat M * nat M * n", "by linarith"], ["proof (state)\nthis:\n  0 < nat M * nat M * n\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "from prod0"], ["proof (chain)\npicking this:\n  0 < nat M * nat M * n", "have n0: \"n > 0\""], ["proof (prove)\nusing this:\n  0 < nat M * nat M * n\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "from n0 prod0 M0"], ["proof (chain)\npicking this:\n  0 < n\n  0 < nat M * nat M * n\n  0 < M", "have prod_p: \"?prod \\<le> ?p\""], ["proof (prove)\nusing this:\n  0 < n\n  0 < nat M * nat M * n\n  0 < M\n\ngoal (1 subgoal):\n 1. nat M * nat M * n \\<le> nat M * nat M * n * n", "by auto"], ["proof (state)\nthis:\n  nat M * nat M * n \\<le> nat M * nat M * n * n\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "with N_prod prod0"], ["proof (chain)\npicking this:\n  N \\<le> nat M * nat M * n\n  0 < nat M * nat M * n\n  nat M * nat M * n \\<le> nat M * nat M * n * n", "have N_p: \"N \\<le> ?p\" and p0: \"0 < ?p\""], ["proof (prove)\nusing this:\n  N \\<le> nat M * nat M * n\n  0 < nat M * nat M * n\n  nat M * nat M * n \\<le> nat M * nat M * n * n\n\ngoal (1 subgoal):\n 1. N \\<le> nat M * nat M * n * n &&& 0 < nat M * nat M * n * n", "by linarith+"], ["proof (state)\nthis:\n  N \\<le> nat M * nat M * n * n\n  0 < nat M * nat M * n * n\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "let ?base = \"real_of_rat (4 * \\<alpha> / (4 + \\<alpha>))\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "have base: \"1 < ?base\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < real_of_rat (4 * \\<alpha> / (4 + \\<alpha>))", "using \\<alpha>_gt"], ["proof (prove)\nusing this:\n  4 / 3 < \\<alpha>\n\ngoal (1 subgoal):\n 1. 1 < real_of_rat (4 * \\<alpha> / (4 + \\<alpha>))", "by auto"], ["proof (state)\nthis:\n  1 < real_of_rat (4 * \\<alpha> / (4 + \\<alpha>))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "have Lg: \"nat \\<lceil>log ?base N\\<rceil> \\<le> nat \\<lceil>log ?base ?p\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                 (real N)\\<rceil>\n    \\<le> nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                       (real (nat M * nat M * n * n))\\<rceil>", "by (intro nat_mono ceiling_mono log_mono, subst log_le_cancel_iff[OF base],\n      insert M0 N_p N0 p0 n0, auto simp flip: of_int_mult of_nat_mult)"], ["proof (state)\nthis:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n  \\<le> nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                     (real (nat M * nat M * n * n))\\<rceil>\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n  \\<le> nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                     (real (nat M * nat M * n * n))\\<rceil>\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "have \"log ?base ?p = log ?base (?lg^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n     (real (nat M * nat M * n * n)) =\n    log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n     ((real_of_int (M * int n))\\<^sup>2)", "using M0"], ["proof (prove)\nusing this:\n  0 < M\n\ngoal (1 subgoal):\n 1. log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n     (real (nat M * nat M * n * n)) =\n    log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n     ((real_of_int (M * int n))\\<^sup>2)", "by (simp add: power2_eq_square ac_simps)"], ["proof (state)\nthis:\n  log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n   (real (nat M * nat M * n * n)) =\n  log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n   ((real_of_int (M * int n))\\<^sup>2)\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n   (real (nat M * nat M * n * n)) =\n  log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n   ((real_of_int (M * int n))\\<^sup>2)\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "have \"\\<dots> = 2 * log ?base ?lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n     ((real_of_int (M * int n))\\<^sup>2) =\n    2 *\n    log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n     (real_of_int (M * int n))", "by (subst log_nat_power, insert M0 n0, auto)"], ["proof (state)\nthis:\n  log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n   ((real_of_int (M * int n))\\<^sup>2) =\n  2 *\n  log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n   (real_of_int (M * int n))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "finally"], ["proof (chain)\npicking this:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n  \\<le> nat \\<lceil>2 *\n                    log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                     (real_of_int (M * int n))\\<rceil>", "have \"nat \\<lceil>log ?base N\\<rceil> \\<le> nat \\<lceil>2 * log ?base ?lg\\<rceil>\""], ["proof (prove)\nusing this:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n  \\<le> nat \\<lceil>2 *\n                    log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                     (real_of_int (M * int n))\\<rceil>\n\ngoal (1 subgoal):\n 1. nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                 (real N)\\<rceil>\n    \\<le> nat \\<lceil>2 *\n                      log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                       (real_of_int (M * int n))\\<rceil>", "."], ["proof (state)\nthis:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n  \\<le> nat \\<lceil>2 *\n                    log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                     (real_of_int (M * int n))\\<rceil>\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "also"], ["proof (state)\nthis:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n  \\<le> nat \\<lceil>2 *\n                    log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                     (real_of_int (M * int n))\\<rceil>\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "have \"\\<dots> \\<le> 2 * Lg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>2 *\n                log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                 (real_of_int (M * int n))\\<rceil>\n    \\<le> 2 * Lg", "using assms"], ["proof (prove)\nusing this:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real_of_int (M * int n))\\<rceil>\n  \\<le> Lg\n  0 < Lg\n\ngoal (1 subgoal):\n 1. nat \\<lceil>2 *\n                log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                 (real_of_int (M * int n))\\<rceil>\n    \\<le> 2 * Lg", "by linarith"], ["proof (state)\nthis:\n  nat \\<lceil>2 *\n              log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real_of_int (M * int n))\\<rceil>\n  \\<le> 2 * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "finally"], ["proof (chain)\npicking this:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n  \\<le> 2 * Lg", "have Log: \"nat \\<lceil>log ?base N\\<rceil> \\<le> 2 * Lg\""], ["proof (prove)\nusing this:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n  \\<le> 2 * Lg\n\ngoal (1 subgoal):\n 1. nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n                 (real N)\\<rceil>\n    \\<le> 2 * Lg", "."], ["proof (state)\nthis:\n  nat \\<lceil>log (real_of_rat (4 * \\<alpha> / (4 + \\<alpha>)))\n               (real N)\\<rceil>\n  \\<le> 2 * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "from 0"], ["proof (chain)\npicking this:\n  0 < Lg", "have \"0 < 2 * Lg\""], ["proof (prove)\nusing this:\n  0 < Lg\n\ngoal (1 subgoal):\n 1. 0 < 2 * Lg", "by simp"], ["proof (state)\nthis:\n  0 < 2 * Lg\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n 2. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "from reduce_basis_cost_N[OF Log this]"], ["proof (chain)\npicking this:\n  cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * (2 * Lg)", "show ?thesis"], ["proof (prove)\nusing this:\n  cost (reduce_basis_cost fs_init) \\<le> 49 * m ^ 3 * n * (2 * Lg)\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "by simp"], ["proof (state)\nthis:\n  cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < m\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "with reduce_basis_cost_0"], ["proof (chain)\npicking this:\n  m = 0 \\<Longrightarrow> cost (reduce_basis_cost fs_init) = 0\n  \\<not> 0 < m", "show ?thesis"], ["proof (prove)\nusing this:\n  m = 0 \\<Longrightarrow> cost (reduce_basis_cost fs_init) = 0\n  \\<not> 0 < m\n\ngoal (1 subgoal):\n 1. cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg", "by simp"], ["proof (state)\nthis:\n  cost (reduce_basis_cost fs_init) \\<le> 98 * m ^ 3 * n * Lg\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* fixing arith_cost and assume \\<alpha> > 4/3 *)"], ["", "end"], ["", "(* LLL locale *)"], ["", "end"], ["", "(* theory *)"]]}