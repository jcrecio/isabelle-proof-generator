{"file_name": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction/Gram_Schmidt_Int.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction", "problem_names": ["lemma Gramian_beta:\n  assumes \"i < m\"\n  shows \"\\<beta> fs i = \\<parallel>fs ! i\\<parallel>\\<^sup>2 - (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)\"", "lemma gso_norm_beta:\n  assumes \"j < m\"\n  shows \"\\<beta> fs j = sq_norm (gso j)\"", "lemma mu_Gramian_beta_def:\n  assumes \"j < i\" \"i < m\"\n  shows \"\\<mu> i j = (fs ! i \\<bullet> fs ! j - (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) / \\<beta> fs j\"", "lemma (in gram_schmidt) Gramian_matrix_alt_alt_alt_def:\n  assumes \"k \\<le> length fs\" \"set fs \\<subseteq> carrier_vec n\"\n  shows \"Gramian_matrix fs k = mat k k (\\<lambda>(i,j). fs ! i \\<bullet> fs ! j)\"", "lemma (in gram_schmidt_fs_Rn) Gramian_determinant_1 [simp]:\n  assumes \"0 < length fs\"\n  shows \"Gramian_determinant fs (Suc 0) = \\<parallel>fs ! 0\\<parallel>\\<^sup>2\"", "lemma d_Suc: \"d (Suc i) = \\<mu>' i i\"", "lemma d_0: \"d 0 = 1\"", "lemma \\<sigma>: assumes lj: \"l \\<le> m\" \n  shows \"\\<sigma> l i j = d l * (\\<Sum>k < l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\"", "lemma \\<mu>': assumes j: \"j \\<le> i\" and i: \"i < m\" \n  shows \"\\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\"", "lemma \\<sigma>_via_\\<mu>': \"\\<sigma> (Suc l) i j = \n  (if l = 0 then \\<mu>' i 0 * \\<mu>' j 0 else (\\<mu>' l l * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) / \\<mu>' (l - 1) (l - 1))\"", "lemma \\<mu>'_via_\\<sigma>: assumes j: \"j \\<le> i\" and i: \"i < m\" \n  shows \"\\<mu>' i j = \n    (if j = 0 then fs ! i \\<bullet> fs ! j else \\<mu>' (j - 1) (j - 1) * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j)\"", "lemma fs_i_sumlist_\\<kappa>:\n  assumes \"i < m\" \"l \\<le> i\" \"j < l\"\n  shows \"(fs ! i + sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])) \\<bullet> fs ! j = 0\"", "lemma \\<beta>_pos : \"i < m \\<Longrightarrow> \\<beta> fs i > 0\"", "lemma \\<beta>_zero : \"i < m \\<Longrightarrow> \\<beta> fs i \\<noteq> 0\"", "lemma \\<sigma>_integer:  \n  assumes l: \"l \\<le> j\" and j: \"j \\<le> i\" and i: \"i < m\"\n  shows \"\\<sigma> l i j \\<in> \\<int>\"", "lemma \\<sigma>s_\\<mu>': \"l < j \\<Longrightarrow> j \\<le> i \\<Longrightarrow> i < m \\<Longrightarrow> of_int (\\<sigma>s l i j) = gs.\\<sigma> (Suc l) i j\" \n  \"i < m \\<Longrightarrow> j \\<le> i \\<Longrightarrow> of_int (\\<mu>'  i j) = gs.\\<mu>' i j\"", "lemma \\<mu>': assumes \"i < m\" \"j \\<le> i\"\n  shows \"\\<mu>' i j = d\\<mu> i j\"\n    \"j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)\"", "lemma sigma_array: assumes mm: \"mm \\<le> m\" and j: \"j < mm\" \n  shows \"l \\<le> j \\<Longrightarrow> sigma_array (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i)) (Suc mm))\n\t     (IArray.of_fun (\\<mu>' mm) (Suc j)) (IArray.of_fun (\\<mu>' (Suc j)) (if Suc j = mm then Suc j else Suc (Suc j))) (\\<mu>' l l) l =\n\t    \\<sigma>s l mm (Suc j)\"", "lemma dmu_array_row_main: assumes mm: \"mm \\<le> m\" shows\n  \"j \\<le> mm \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !!  mm) mm\n\t    (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i)) (Suc mm))    \n\t     j = IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)\"", "lemma dmu_array_row: assumes mm: \"mm \\<le> m\" shows\n  \"dmu_array_row (IArray fs) (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n\t    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)\"", "lemma dmu_array: assumes \"mm \\<le> m\" \n  shows \"dmu_array (IArray fs) m (IArray.of_fun (\\<lambda> i. IArray.of_fun (\\<lambda> j. \\<mu>' i j) (Suc i)) mm) mm \n\t  = IArray.of_fun (\\<lambda> i. IArray.of_fun (\\<lambda> j. \\<mu>' i j) (Suc i)) m\"", "lemma d\\<mu>_impl: \"d\\<mu>_impl fs = IArray.of_fun (\\<lambda> i. IArray.of_fun (\\<lambda> j. d\\<mu> i j) (Suc i)) m\"", "lemma N_\\<mu>':\n  assumes \"i < m\" \"j \\<le> i\"\n  shows \"(\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)\"", "lemma N_\\<sigma>:\n  assumes \"i < m\" \"j \\<le> i\" \"l \\<le> j\"\n  shows \"\\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)\"", "lemma leq_squared: \"(z::int) \\<le> z\\<^sup>2\"", "lemma abs_leq_squared: \"\\<bar>z::int\\<bar> \\<le> z\\<^sup>2\"", "lemma gso'_carrier_vec: \n  assumes \"i < m\"\n  shows \"gso' i \\<in> carrier_vec n\"", "lemma a_carrier_vec: \n  assumes \"l \\<le> i\" \"i < m\"\n  shows \"a i l \\<in> carrier_vec n\"", "lemma a_l: \n  assumes \"l \\<le> i\" \"i < m\"\n  shows \"a i l = d l \\<cdot>\\<^sub>v (fs ! i + M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))\"", "lemma a_l': \n  assumes \"i < m\"\n  shows \"a i i = gso' i\"", "lemma \n  assumes \"i < m\" \"l' \\<le> i\"\n  shows \"a i l' = (case l' of\n         0 \\<Rightarrow> fs ! i |\n         Suc l \\<Rightarrow> (1 / d l) \\<cdot>\\<^sub>v (d (Suc l) \\<cdot>\\<^sub>v (a i l) - (\\<mu>' i l) \\<cdot>\\<^sub>v a l l))\"", "lemma a_Ints:\n  assumes \"i < m\" \"l \\<le> i\" \"k < n\"\n  shows \"a i l $ k \\<in> \\<int>\"", "lemma a_alt_def:\n  assumes \"l < length fs\"\n  shows \"a i (Suc l) = (let v = \\<mu>' l l \\<cdot>\\<^sub>v (a i l) - ( \\<mu>' i l) \\<cdot>\\<^sub>v a l l in\n                       (if l = 0 then v else (1 / \\<mu>' (l - 1) (l - 1)) \\<cdot>\\<^sub>v v))\"", "lemma gso_int_carrier_vec:\n  assumes \"i < length fs\" \"l \\<le> i\"\n  shows \"gso_int i l \\<in> carrier_vec n\"", "lemma gso_int:\n  assumes \"i < length fs\" \"l \\<le> i\"\n  shows \"of_int_hom.vec_hom (gso_int i l) = gs.a i l\"", "lemma gso_int_tail':\n  assumes \"acc = gso_int i l\" \"0 < i\" \"0 < l\" \"l \\<le> i\"\n  shows \"gso_int_tail' i l acc = gso_int i i\"", "lemma gso_int_tail: \"gso_int_tail i = gso_int i i\"", "lemma map_vec_id[simp]: \"map_vec id = id\"", "lemma \"gso_array.gso'_array (d\\<mu>_impl fs) fs = IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])\"", "lemma combined_size_bound_integer:  \n  assumes x: \"x \\<in> {fs ! i $ j | i j. i < m \\<and> j < n} \n    \\<union> {\\<mu>' i j | i j. j \\<le> i \\<and> i < m}\n    \\<union> {\\<sigma> l i j | i j l. i < m \\<and> j \\<le> i \\<and> l \\<le> j}\" \n    (is \"x \\<in> ?fs \\<union> ?\\<mu>' \\<union> ?\\<sigma>\")\n    and m: \"m \\<noteq> 0\"\n  shows \"\\<bar>x\\<bar> \\<le> of_nat m * N ^ (3 * Suc m)\"", "lemma combined_size_bound_rat_log:  \n  assumes x: \"x \\<in> {gs.\\<mu>' i j | i j. j \\<le> i \\<and> i < m}\n    \\<union> {gs.\\<sigma> l i j | i j l. i < m \\<and> j \\<le> i \\<and> l \\<le> j}\" \n    (is \"x \\<in> ?\\<mu>' \\<union> ?\\<sigma>\")\n    and m: \"m \\<noteq> 0\" \"x \\<noteq> 0\"\n  shows \"log 2 \\<bar>real_of_rat x\\<bar> \\<le> log 2 m + (3 + 3 * m) * log 2 (real_of_rat gs.N)\"", "lemma combined_size_bound_integer_log:  \n  assumes x: \"x \\<in> {\\<mu>' i j | i j. j \\<le> i \\<and> i < m}\n    \\<union> {\\<sigma>s l i j | i j l. i < m \\<and> j \\<le> i \\<and> l < j}\" \n    (is \"x \\<in> ?\\<mu>' \\<union> ?\\<sigma>\")\n    and m: \"m \\<noteq> 0\" \"x \\<noteq> 0\"\n  shows \"log 2 \\<bar>real_of_int x\\<bar> \\<le> log 2 m + (3 + 3 * m) * log 2 (real_of_rat gs.N)\""], "translations": [["", "lemma Gramian_beta:\n  assumes \"i < m\"\n  shows \"\\<beta> fs i = \\<parallel>fs ! i\\<parallel>\\<^sup>2 - (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "let ?S = \"M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "have S: \"?S \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n    \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n    \\<in> carrier_vec n", "by (auto intro!: M.sumlist_carrier gso_carrier)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "have fi: \"fs ! i \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  fs ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "have \"\\<beta> fs i = gso i \\<bullet> gso i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> fs i = gso i \\<bullet> gso i", "unfolding \\<beta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc i) / d i = gso i \\<bullet> gso i", "using assms dist"], ["proof (prove)\nusing this:\n  i < length fs\n  distinct fs\n\ngoal (1 subgoal):\n 1. d (Suc i) / d i = gso i \\<bullet> gso i", "by (auto simp add: Gramian_determinant_div sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  \\<beta> fs i = gso i \\<bullet> gso i\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "also"], ["proof (state)\nthis:\n  \\<beta> fs i = gso i \\<bullet> gso i\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "have \"\\<dots> = (fs ! i + ?S) \\<bullet> (fs ! i + ?S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i \\<bullet> gso i =\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n        [0..<i])) \\<bullet>\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]))", "by (subst gso.simps, subst (2) gso.simps) auto"], ["proof (state)\nthis:\n  gso i \\<bullet> gso i =\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) \\<bullet>\n  (fs ! i +\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]))\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "also"], ["proof (state)\nthis:\n  gso i \\<bullet> gso i =\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) \\<bullet>\n  (fs ! i +\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]))\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "have \"\\<dots> = fs ! i \\<bullet> fs ! i + ?S \\<bullet> fs ! i + fs ! i \\<bullet> ?S + ?S \\<bullet> ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n        [0..<i])) \\<bullet>\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) =\n    fs ! i \\<bullet> fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    fs ! i +\n    fs ! i \\<bullet>\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "using assms S"], ["proof (prove)\nusing this:\n  i < length fs\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n        [0..<i])) \\<bullet>\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) =\n    fs ! i \\<bullet> fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    fs ! i +\n    fs ! i \\<bullet>\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "by (auto simp add: add_scalar_prod_distrib[of _ n] scalar_prod_add_distrib[of _ n])"], ["proof (state)\nthis:\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) \\<bullet>\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) =\n  fs ! i \\<bullet> fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  fs ! i +\n  fs ! i \\<bullet>\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "also"], ["proof (state)\nthis:\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) \\<bullet>\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) =\n  fs ! i \\<bullet> fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  fs ! i +\n  fs ! i \\<bullet>\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "have \"fs ! i \\<bullet> ?S = ?S \\<bullet> fs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<bullet>\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    fs ! i", "by (rule comm_scalar_prod[OF fi S])"], ["proof (state)\nthis:\n  fs ! i \\<bullet>\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  fs ! i\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "also"], ["proof (state)\nthis:\n  fs ! i \\<bullet>\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  fs ! i\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "have \"?S \\<bullet> fs ! i = ?S \\<bullet> gso i - ?S \\<bullet> ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    gso i -\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    gso i -\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "have \"fs ! i = gso i - M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i -\n    M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "using assms S"], ["proof (prove)\nusing this:\n  i < length fs\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i -\n    M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "by (subst gso.simps) auto"], ["proof (state)\nthis:\n  fs ! i =\n  gso i -\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    gso i -\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "then"], ["proof (chain)\npicking this:\n  fs ! i =\n  gso i -\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "show ?thesis"], ["proof (prove)\nusing this:\n  fs ! i =\n  gso i -\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    gso i -\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "using assms S"], ["proof (prove)\nusing this:\n  fs ! i =\n  gso i -\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  i < length fs\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    gso i -\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "by (auto simp add: minus_scalar_prod_distrib[of _ n] scalar_prod_minus_distrib[of _ n])"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  fs ! i =\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i -\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  fs ! i =\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i -\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  fs ! i =\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i -\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "have \"?S \\<bullet> gso i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    gso i =\n    (0::'a)", "using assms orthogonal"], ["proof (prove)\nusing this:\n  i < length fs\n  \\<lbrakk>?i < length fs; ?j < length fs; ?i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> gso ?i \\<bullet> gso ?j = (0::'a)\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    gso i =\n    (0::'a)", "by(subst scalar_prod_left_sum_distrib)\n      (auto intro!: sum_list_neutral M.sumlist_carrier gso_carrier)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "have \"?S \\<bullet> ?S = (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * (gso j \\<bullet> gso j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * (gso j \\<bullet> gso j))", "using assms dist"], ["proof (prove)\nusing this:\n  i < length fs\n  distinct fs\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * (gso j \\<bullet> gso j))", "by (subst scalar_prod_lincomb_gso)\n       (auto simp add: power2_eq_square interv_sum_list_conv_sum_set_nat)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n  (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * (gso j \\<bullet> gso j))\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n  (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * (gso j \\<bullet> gso j))\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "have \"\\<dots> =  (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * (gso j \\<bullet> gso j)) =\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "using assms dist"], ["proof (prove)\nusing this:\n  i < length fs\n  distinct fs\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * (gso j \\<bullet> gso j)) =\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "by (auto simp add: \\<beta>_def Gramian_determinant_div sq_norm_vec_as_cscalar_prod\n        intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * (gso j \\<bullet> gso j)) =\n  (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "finally"], ["proof (chain)\npicking this:\n  \\<beta> fs i =\n  fs ! i \\<bullet> fs ! i +\n  ((0::'a) - (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)) +\n  ((0::'a) - (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)) +\n  (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> fs i =\n  fs ! i \\<bullet> fs ! i +\n  ((0::'a) - (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)) +\n  ((0::'a) - (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)) +\n  (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)\n\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)", "by (auto simp add: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  \\<beta> fs i =\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n  (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gso_norm_beta:\n  assumes \"j < m\"\n  shows \"\\<beta> fs j = sq_norm (gso j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> fs j = \\<parallel>gso j\\<parallel>\\<^sup>2", "unfolding \\<beta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc j) / d j = \\<parallel>gso j\\<parallel>\\<^sup>2", "using assms dist"], ["proof (prove)\nusing this:\n  j < length fs\n  distinct fs\n\ngoal (1 subgoal):\n 1. d (Suc j) / d j = \\<parallel>gso j\\<parallel>\\<^sup>2", "by (auto simp add: Gramian_determinant_div sq_norm_vec_as_cscalar_prod)"], ["", "lemma mu_Gramian_beta_def:\n  assumes \"j < i\" \"i < m\"\n  shows \"\\<mu> i j = (fs ! i \\<bullet> fs ! j - (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) / \\<beta> fs j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "let ?list = \"map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "let ?neg_sum = \"M.sumlist (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have list: \"set ?list \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n    \\<subseteq> carrier_vec n", "using gso_carrier assms"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  j < i\n  i < length fs\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n    \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "define fi where \"fi = fs ! i\""], ["proof (state)\nthis:\n  fi = fs ! i\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have list_id: \"[0..<i] = [0..<j] @ [j..<i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<i] = [0..<j] @ [j..<i]", "using assms"], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n\ngoal (1 subgoal):\n 1. [0..<i] = [0..<j] @ [j..<i]", "by (metis append.simps(1) neq0_conv upt.simps(1) upt_append)"], ["proof (state)\nthis:\n  [0..<i] = [0..<j] @ [j..<i]\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \"\\<mu> i j = (fs ! i) \\<bullet> (gso j) / sq_norm (gso j) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> i j = fs ! i \\<bullet> gso j / \\<parallel>gso j\\<parallel>\\<^sup>2", "unfolding \\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < i\n     then fs ! i \\<bullet> gso j / \\<parallel>gso j\\<parallel>\\<^sup>2\n     else if i = j then 1::'a else (0::'a)) =\n    fs ! i \\<bullet> gso j / \\<parallel>gso j\\<parallel>\\<^sup>2", "using assms"], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n\ngoal (1 subgoal):\n 1. (if j < i\n     then fs ! i \\<bullet> gso j / \\<parallel>gso j\\<parallel>\\<^sup>2\n     else if i = j then 1::'a else (0::'a)) =\n    fs ! i \\<bullet> gso j / \\<parallel>gso j\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<mu> i j = fs ! i \\<bullet> gso j / \\<parallel>gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  \\<mu> i j = fs ! i \\<bullet> gso j / \\<parallel>gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \" ... = fs ! i \\<bullet> (fs ! j + ?neg_sum) / sq_norm (gso j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j / \\<parallel>gso j\\<parallel>\\<^sup>2 =\n    fs ! i \\<bullet>\n    (fs ! j +\n     M.sumlist\n      (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n    \\<parallel>gso j\\<parallel>\\<^sup>2", "by (subst gso.simps, simp)"], ["proof (state)\nthis:\n  fs ! i \\<bullet> gso j / \\<parallel>gso j\\<parallel>\\<^sup>2 =\n  fs ! i \\<bullet>\n  (fs ! j +\n   M.sumlist\n    (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n  \\<parallel>gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  fs ! i \\<bullet> gso j / \\<parallel>gso j\\<parallel>\\<^sup>2 =\n  fs ! i \\<bullet>\n  (fs ! j +\n   M.sumlist\n    (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n  \\<parallel>gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \" ... = (fi \\<bullet> fs ! j + fs ! i \\<bullet> ?neg_sum) / sq_norm (gso j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<bullet>\n    (fs ! j +\n     M.sumlist\n      (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n    \\<parallel>gso j\\<parallel>\\<^sup>2 =\n    (fi \\<bullet> fs ! j +\n     fs ! i \\<bullet>\n     M.sumlist\n      (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n    \\<parallel>gso j\\<parallel>\\<^sup>2", "using assms"], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet>\n    (fs ! j +\n     M.sumlist\n      (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n    \\<parallel>gso j\\<parallel>\\<^sup>2 =\n    (fi \\<bullet> fs ! j +\n     fs ! i \\<bullet>\n     M.sumlist\n      (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n    \\<parallel>gso j\\<parallel>\\<^sup>2", "unfolding fi_def"], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet>\n    (fs ! j +\n     M.sumlist\n      (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n    \\<parallel>gso j\\<parallel>\\<^sup>2 =\n    (fs ! i \\<bullet> fs ! j +\n     fs ! i \\<bullet>\n     M.sumlist\n      (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n    \\<parallel>gso j\\<parallel>\\<^sup>2", "by (subst scalar_prod_add_distrib [of _ n]) (auto intro!: M.sumlist_carrier gso_carrier)"], ["proof (state)\nthis:\n  fs ! i \\<bullet>\n  (fs ! j +\n   M.sumlist\n    (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n  \\<parallel>gso j\\<parallel>\\<^sup>2 =\n  (fi \\<bullet> fs ! j +\n   fs ! i \\<bullet>\n   M.sumlist\n    (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n  \\<parallel>gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  fs ! i \\<bullet>\n  (fs ! j +\n   M.sumlist\n    (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n  \\<parallel>gso j\\<parallel>\\<^sup>2 =\n  (fi \\<bullet> fs ! j +\n   fs ! i \\<bullet>\n   M.sumlist\n    (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])) /\n  \\<parallel>gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \"fs ! i = gso i + M.sumlist ?list \""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "by (rule fs_by_gso_def[OF assms(2)])"], ["proof (state)\nthis:\n  fs ! i =\n  gso i +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  fs ! i =\n  gso i +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \"... \\<bullet> ?neg_sum = gso i \\<bullet> ?neg_sum + M.sumlist ?list \\<bullet> ?neg_sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gso i +\n     M.sumlist\n      (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n        [0..<i])) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n    gso i \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n       [0..<i]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])", "using assms"], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n\ngoal (1 subgoal):\n 1. (gso i +\n     M.sumlist\n      (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n        [0..<i])) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n    gso i \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n       [0..<i]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])", "by (subst add_scalar_prod_distrib [of _ n]) (auto intro!: M.sumlist_carrier gso_carrier)"], ["proof (state)\nthis:\n  (gso i +\n   M.sumlist\n    (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n      [0..<i])) \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n  gso i \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n  M.sumlist\n   (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  (gso i +\n   M.sumlist\n    (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n      [0..<i])) \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n  gso i \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n  M.sumlist\n   (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \" M.sumlist ?list = M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) \n     + M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [j..<i]) \" (is \"_ = ?sumj + ?sumi\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [j..<i])", "unfolding list_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n       ([0..<j] @ [j..<i])) =\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [j..<i])", "by (subst M.sumlist_append[symmetric], insert gso_carrier assms, auto)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [j..<i])\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [j..<i])\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \"gso i \\<bullet> ?neg_sum = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n    (0::'a)", "by (rule orthogonal_sumlist, insert gso_carrier dist assms orthogonal, auto)"], ["proof (state)\nthis:\n  gso i \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  gso i \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \" (?sumj + ?sumi) \\<bullet> ?neg_sum = ?sumj \\<bullet> ?neg_sum + ?sumi \\<bullet> ?neg_sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n     M.sumlist\n      (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n        [j..<i])) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n       [0..<j]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n       [j..<i]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])", "using assms"], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n     M.sumlist\n      (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n        [j..<i])) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n       [0..<j]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n       [j..<i]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])", "by (subst add_scalar_prod_distrib [of _ n], auto intro!: M.sumlist_carrier gso_carrier)"], ["proof (state)\nthis:\n  (M.sumlist\n    (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n   M.sumlist\n    (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n      [j..<i])) \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n  M.sumlist\n   (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n  M.sumlist\n   (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [j..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  (M.sumlist\n    (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n   M.sumlist\n    (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n      [j..<i])) \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n  M.sumlist\n   (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) +\n  M.sumlist\n   (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [j..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j])\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \" ?sumj \\<bullet> ?neg_sum = (\\<Sum>l = 0..<j. (\\<mu> i l) * (-\\<mu> j l) * (gso l \\<bullet> gso l)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n       [0..<j]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n    (\\<Sum>l = 0..<j. \\<mu> i l * - \\<mu> j l * (gso l \\<bullet> gso l))", "using assms"], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n       [0..<j]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n    (\\<Sum>l = 0..<j. \\<mu> i l * - \\<mu> j l * (gso l \\<bullet> gso l))", "by (subst scalar_prod_lincomb_gso) (auto simp add: interv_sum_list_conv_sum_set_nat)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n  (\\<Sum>l = 0..<j. \\<mu> i l * - \\<mu> j l * (gso l \\<bullet> gso l))\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<j]) \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n  (\\<Sum>l = 0..<j. \\<mu> i l * - \\<mu> j l * (gso l \\<bullet> gso l))\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \"\\<dots> = - (\\<Sum>l = 0..<j. (\\<mu> i l) * (\\<mu> j l) * (gso l \\<bullet> gso l)) \" (is \"_ = - ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l = 0..<j. \\<mu> i l * - \\<mu> j l * (gso l \\<bullet> gso l)) =\n    - (\\<Sum>l = 0..<j. \\<mu> i l * \\<mu> j l * (gso l \\<bullet> gso l))", "by (auto simp add: sum_negf)"], ["proof (state)\nthis:\n  (\\<Sum>l = 0..<j. \\<mu> i l * - \\<mu> j l * (gso l \\<bullet> gso l)) =\n  - (\\<Sum>l = 0..<j. \\<mu> i l * \\<mu> j l * (gso l \\<bullet> gso l))\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  (\\<Sum>l = 0..<j. \\<mu> i l * - \\<mu> j l * (gso l \\<bullet> gso l)) =\n  - (\\<Sum>l = 0..<j. \\<mu> i l * \\<mu> j l * (gso l \\<bullet> gso l))\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \"?sum = (\\<Sum>l = 0..<j. (\\<mu> j l) * (\\<mu> i l) * \\<beta> fs l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l = 0..<j. \\<mu> i l * \\<mu> j l * (gso l \\<bullet> gso l)) =\n    (\\<Sum>l = 0..<j. \\<mu> j l * \\<mu> i l * \\<beta> fs l)", "using assms"], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n\ngoal (1 subgoal):\n 1. (\\<Sum>l = 0..<j. \\<mu> i l * \\<mu> j l * (gso l \\<bullet> gso l)) =\n    (\\<Sum>l = 0..<j. \\<mu> j l * \\<mu> i l * \\<beta> fs l)", "by (intro sum.cong, auto simp: gso_norm_beta sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  (\\<Sum>l = 0..<j. \\<mu> i l * \\<mu> j l * (gso l \\<bullet> gso l)) =\n  (\\<Sum>l = 0..<j. \\<mu> j l * \\<mu> i l * \\<beta> fs l)\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  (\\<Sum>l = 0..<j. \\<mu> i l * \\<mu> j l * (gso l \\<bullet> gso l)) =\n  (\\<Sum>l = 0..<j. \\<mu> j l * \\<mu> i l * \\<beta> fs l)\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \"?sumi \\<bullet> ?neg_sum = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n       [j..<i]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n    (0::'a)", "apply (rule orthogonal_sumlist, insert gso_carrier assms orthogonal, auto intro!: M.sumlist_carrier gso_carrier)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>j < i; i < length fs;\n        \\<And>i j.\n           \\<lbrakk>i < length fs; j < length fs; i \\<noteq> j\\<rbrakk>\n           \\<Longrightarrow> gso i \\<bullet> gso j = (0::'a);\n        xa < j\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>ja.\n                                   \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n                            [j..<i]) \\<bullet>\n                         (- \\<mu> j xa \\<cdot>\\<^sub>v gso xa) =\n                         (0::'a)", "apply (subst comm_scalar_prod[of _ n], auto intro!: M.sumlist_carrier)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>j < i; i < length fs;\n        \\<And>i j.\n           \\<lbrakk>i < length fs; j < length fs; i \\<noteq> j\\<rbrakk>\n           \\<Longrightarrow> gso i \\<bullet> gso j = (0::'a);\n        xa < j\\<rbrakk>\n       \\<Longrightarrow> (- \\<mu> j xa \\<cdot>\\<^sub>v gso xa) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>ja.\n                                   \\<mu> i ja \\<cdot>\\<^sub>v gso ja)\n                            [j..<i]) =\n                         (0::'a)", "by (rule orthogonal_sumlist, use dist in auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [j..<i]) \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [j..<i]) \\<bullet>\n  M.sumlist\n   (map (\\<lambda>ja. - \\<mu> j ja \\<cdot>\\<^sub>v gso ja) [0..<j]) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "have \"sq_norm (gso j) = \\<beta> fs j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gso j\\<parallel>\\<^sup>2 = \\<beta> fs j", "using assms"], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n\ngoal (1 subgoal):\n 1. \\<parallel>gso j\\<parallel>\\<^sup>2 = \\<beta> fs j", "by (subst gso_norm_beta, auto)"], ["proof (state)\nthis:\n  \\<parallel>gso j\\<parallel>\\<^sup>2 = \\<beta> fs j\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "finally"], ["proof (chain)\npicking this:\n  \\<mu> i j =\n  (fi \\<bullet> fs ! j +\n   ((0::'a) +\n    (- (\\<Sum>l = 0..<j. \\<mu> j l * \\<mu> i l * \\<beta> fs l) +\n     (0::'a)))) /\n  \\<beta> fs j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> i j =\n  (fi \\<bullet> fs ! j +\n   ((0::'a) +\n    (- (\\<Sum>l = 0..<j. \\<mu> j l * \\<mu> i l * \\<beta> fs l) +\n     (0::'a)))) /\n  \\<beta> fs j\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "unfolding fi_def"], ["proof (prove)\nusing this:\n  \\<mu> i j =\n  (fs ! i \\<bullet> fs ! j +\n   ((0::'a) +\n    (- (\\<Sum>l = 0..<j. \\<mu> j l * \\<mu> i l * \\<beta> fs l) +\n     (0::'a)))) /\n  \\<beta> fs j\n\ngoal (1 subgoal):\n 1. \\<mu> i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n    \\<beta> fs j", "by simp"], ["proof (state)\nthis:\n  \\<mu> i j =\n  (fs ! i \\<bullet> fs ! j -\n   (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n  \\<beta> fs j\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma (in gram_schmidt) Gramian_matrix_alt_alt_alt_def:\n  assumes \"k \\<le> length fs\" \"set fs \\<subseteq> carrier_vec n\"\n  shows \"Gramian_matrix fs k = mat k k (\\<lambda>(i,j). fs ! i \\<bullet> fs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_matrix fs k = mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gramian_matrix fs k = mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "have *: \"vec n (($) (fs ! i)) = fs ! i\" if \"i < length fs\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (($) (fs ! i)) = fs ! i", "using that assms"], ["proof (prove)\nusing this:\n  i < length fs\n  k \\<le> length fs\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. vec n (($) (fs ! i)) = fs ! i", "by (metis carrier_vecD dim_vec eq_vecI index_vec nth_mem subsetCE)"], ["proof (state)\nthis:\n  ?i4 < length fs \\<Longrightarrow> vec n (($) (fs ! ?i4)) = fs ! ?i4\n\ngoal (1 subgoal):\n 1. Gramian_matrix fs k = mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "then"], ["proof (chain)\npicking this:\n  ?i4 < length fs \\<Longrightarrow> vec n (($) (fs ! ?i4)) = fs ! ?i4", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i4 < length fs \\<Longrightarrow> vec n (($) (fs ! ?i4)) = fs ! ?i4\n\ngoal (1 subgoal):\n 1. Gramian_matrix fs k = mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "unfolding Gramian_matrix_def"], ["proof (prove)\nusing this:\n  ?i4 < length fs \\<Longrightarrow> vec n (($) (fs ! ?i4)) = fs ! ?i4\n\ngoal (1 subgoal):\n 1. (let M = mat k n (\\<lambda>(i, y). fs ! i $ y) in M * M\\<^sup>T) =\n    mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "using  assms"], ["proof (prove)\nusing this:\n  ?i4 < length fs \\<Longrightarrow> vec n (($) (fs ! ?i4)) = fs ! ?i4\n  k \\<le> length fs\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (let M = mat k n (\\<lambda>(i, y). fs ! i $ y) in M * M\\<^sup>T) =\n    mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "by (intro eq_matI) (auto simp add: Let_def)"], ["proof (state)\nthis:\n  Gramian_matrix fs k = mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in gram_schmidt_fs_Rn) Gramian_determinant_1 [simp]:\n  assumes \"0 < length fs\"\n  shows \"Gramian_determinant fs (Suc 0) = \\<parallel>fs ! 0\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc 0) = \\<parallel>fs ! 0\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc 0) = \\<parallel>fs ! 0\\<parallel>\\<^sup>2", "have \"Gramian_determinant fs (Suc 0) = fs ! 0 \\<bullet> fs ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc 0) = fs ! 0 \\<bullet> fs ! 0", "using assms"], ["proof (prove)\nusing this:\n  0 < length fs\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc 0) = fs ! 0 \\<bullet> fs ! 0", "unfolding Gramian_determinant_def"], ["proof (prove)\nusing this:\n  0 < length fs\n\ngoal (1 subgoal):\n 1. det (Gramian_matrix fs (Suc 0)) = fs ! 0 \\<bullet> fs ! 0", "by (subst det_def') (auto simp add: Gramian_matrix_def Let_def scalar_prod_def)"], ["proof (state)\nthis:\n  Gramian_determinant fs (Suc 0) = fs ! 0 \\<bullet> fs ! 0\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc 0) = \\<parallel>fs ! 0\\<parallel>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  Gramian_determinant fs (Suc 0) = fs ! 0 \\<bullet> fs ! 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Gramian_determinant fs (Suc 0) = fs ! 0 \\<bullet> fs ! 0\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc 0) = \\<parallel>fs ! 0\\<parallel>\\<^sup>2", "by (subst sq_norm_vec_as_cscalar_prod) simp"], ["proof (state)\nthis:\n  Gramian_determinant fs (Suc 0) = \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "context gram_schmidt_fs_lin_indpt\nbegin"], ["", "definition \\<mu>' where \"\\<mu>' i j \\<equiv> d (Suc j) * \\<mu> i j\""], ["", "fun \\<sigma> where \n  \"\\<sigma> 0 i j = 0\" \n| \"\\<sigma> (Suc l) i j = (d (Suc l) * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) / d l\""], ["", "lemma d_Suc: \"d (Suc i) = \\<mu>' i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc i) = \\<mu>' i i", "unfolding \\<mu>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc i) = d (Suc i) * \\<mu> i i", "by (simp add: \\<mu>.simps)"], ["", "lemma d_0: \"d 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d 0 = (1::'a)", "by (rule Gramian_determinant_0)"], ["", "lemma \\<sigma>: assumes lj: \"l \\<le> m\" \n  shows \"\\<sigma> l i j = d l * (\\<Sum>k < l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> l i j = d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "using lj"], ["proof (prove)\nusing this:\n  l \\<le> length fs\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j = d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "case (Suc l)"], ["proof (state)\nthis:\n  l \\<le> length fs \\<Longrightarrow>\n  \\<sigma> l i j = d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n  Suc l \\<le> length fs\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "from Suc(2-)"], ["proof (chain)\npicking this:\n  Suc l \\<le> length fs", "have lj: \"l \\<le> m\""], ["proof (prove)\nusing this:\n  Suc l \\<le> length fs\n\ngoal (1 subgoal):\n 1. l \\<le> length fs", "by auto"], ["proof (state)\nthis:\n  l \\<le> length fs\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "note IH = Suc(1)[OF lj]"], ["proof (state)\nthis:\n  \\<sigma> l i j = d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "let ?f = \"\\<lambda> k. \\<mu> i k * \\<mu> j k * \\<beta> fs k\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "have dl0: \"d l > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < d l", "using lj Gramian_determinant dist"], ["proof (prove)\nusing this:\n  l \\<le> length fs\n  ?k \\<le> length fs \\<Longrightarrow>\n  d ?k = (\\<Prod>j<?k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n  ?k \\<le> length fs \\<Longrightarrow> (0::'a) < d ?k\n  distinct fs\n\ngoal (1 subgoal):\n 1. (0::'a) < d l", "unfolding lin_indpt_list_def"], ["proof (prove)\nusing this:\n  l \\<le> length fs\n  ?k \\<le> length fs \\<Longrightarrow>\n  d ?k = (\\<Prod>j<?k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n  ?k \\<le> length fs \\<Longrightarrow> (0::'a) < d ?k\n  distinct fs\n\ngoal (1 subgoal):\n 1. (0::'a) < d l", "by auto"], ["proof (state)\nthis:\n  (0::'a) < d l\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "have \"\\<sigma> (Suc l) i j = (d (Suc l) * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) / d l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (Suc l) i j =\n    (d (Suc l) * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) / d l", "by simp"], ["proof (state)\nthis:\n  \\<sigma> (Suc l) i j =\n  (d (Suc l) * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) / d l\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "also"], ["proof (state)\nthis:\n  \\<sigma> (Suc l) i j =\n  (d (Suc l) * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) / d l\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "have \"\\<dots> = (d (Suc l) * \\<sigma> l i j) / d l + (\\<mu>' i l * \\<mu>' j l) / d l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d (Suc l) * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) / d l =\n    d (Suc l) * \\<sigma> l i j / d l + \\<mu>' i l * \\<mu>' j l / d l", "using dl0"], ["proof (prove)\nusing this:\n  (0::'a) < d l\n\ngoal (1 subgoal):\n 1. (d (Suc l) * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) / d l =\n    d (Suc l) * \\<sigma> l i j / d l + \\<mu>' i l * \\<mu>' j l / d l", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (d (Suc l) * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) / d l =\n  d (Suc l) * \\<sigma> l i j / d l + \\<mu>' i l * \\<mu>' j l / d l\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "also"], ["proof (state)\nthis:\n  (d (Suc l) * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) / d l =\n  d (Suc l) * \\<sigma> l i j / d l + \\<mu>' i l * \\<mu>' j l / d l\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "have \"(\\<mu>' i l * \\<mu>' j l) / d l = d (Suc l) * ?f l\" (is \"_ = ?one\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>' i l * \\<mu>' j l / d l =\n    d (Suc l) * (\\<mu> i l * \\<mu> j l * \\<beta> fs l)", "unfolding \\<beta>_def \\<mu>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc l) * \\<mu> i l * (d (Suc l) * \\<mu> j l) / d l =\n    d (Suc l) * (\\<mu> i l * \\<mu> j l * (d (Suc l) / d l))", "by auto"], ["proof (state)\nthis:\n  \\<mu>' i l * \\<mu>' j l / d l =\n  d (Suc l) * (\\<mu> i l * \\<mu> j l * \\<beta> fs l)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "also"], ["proof (state)\nthis:\n  \\<mu>' i l * \\<mu>' j l / d l =\n  d (Suc l) * (\\<mu> i l * \\<mu> j l * \\<beta> fs l)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "have \"(d (Suc l) * \\<sigma> l i j) / d l = d (Suc l) * (\\<Sum>k < l. ?f k)\" (is \"_ = ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc l) * \\<sigma> l i j / d l =\n    d (Suc l) * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "using dl0"], ["proof (prove)\nusing this:\n  (0::'a) < d l\n\ngoal (1 subgoal):\n 1. d (Suc l) * \\<sigma> l i j / d l =\n    d (Suc l) * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "unfolding IH"], ["proof (prove)\nusing this:\n  (0::'a) < d l\n\ngoal (1 subgoal):\n 1. d (Suc l) * (d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)) /\n    d l =\n    d (Suc l) * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "by simp"], ["proof (state)\nthis:\n  d (Suc l) * \\<sigma> l i j / d l =\n  d (Suc l) * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "also"], ["proof (state)\nthis:\n  d (Suc l) * \\<sigma> l i j / d l =\n  d (Suc l) * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "have \"?sum + ?one = d (Suc l) * (?f l + (\\<Sum>k < l. ?f k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc l) * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k) +\n    d (Suc l) * (\\<mu> i l * \\<mu> j l * \\<beta> fs l) =\n    d (Suc l) *\n    (\\<mu> i l * \\<mu> j l * \\<beta> fs l +\n     (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  d (Suc l) * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k) +\n  d (Suc l) * (\\<mu> i l * \\<mu> j l * \\<beta> fs l) =\n  d (Suc l) *\n  (\\<mu> i l * \\<mu> j l * \\<beta> fs l +\n   (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k))\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "also"], ["proof (state)\nthis:\n  d (Suc l) * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k) +\n  d (Suc l) * (\\<mu> i l * \\<mu> j l * \\<beta> fs l) =\n  d (Suc l) *\n  (\\<mu> i l * \\<mu> j l * \\<beta> fs l +\n   (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k))\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "have \"?f l + (\\<Sum>k < l. ?f k) = (\\<Sum>k < Suc l. ?f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> i l * \\<mu> j l * \\<beta> fs l +\n    (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k) =\n    (\\<Sum>k<Suc l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "by simp"], ["proof (state)\nthis:\n  \\<mu> i l * \\<mu> j l * \\<beta> fs l +\n  (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k) =\n  (\\<Sum>k<Suc l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> length fs \\<Longrightarrow>\n                \\<sigma> l i j =\n                d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k);\n        Suc l \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (Suc l) i j =\n                         d (Suc l) *\n                         (\\<Sum>k<Suc l.\n                             \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "finally"], ["proof (chain)\npicking this:\n  \\<sigma> (Suc l) i j =\n  d (Suc l) * (\\<Sum>k<Suc l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "show ?case"], ["proof (prove)\nusing this:\n  \\<sigma> (Suc l) i j =\n  d (Suc l) * (\\<Sum>k<Suc l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<sigma> (Suc l) i j =\n    d (Suc l) * (\\<Sum>k<Suc l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "."], ["proof (state)\nthis:\n  \\<sigma> (Suc l) i j =\n  d (Suc l) * (\\<Sum>k<Suc l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. 0 \\<le> length fs \\<Longrightarrow>\n    \\<sigma> 0 i j = d 0 * (\\<Sum>k<0. \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "qed auto"], ["", "lemma \\<mu>': assumes j: \"j \\<le> i\" and i: \"i < m\" \n  shows \"\\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "proof (cases \"j < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "case j: True"], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have dsj: \"d (Suc j) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < d (Suc j)", "using j i Gramian_determinant dist"], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n  ?k \\<le> length fs \\<Longrightarrow>\n  d ?k = (\\<Prod>j<?k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n  ?k \\<le> length fs \\<Longrightarrow> (0::'a) < d ?k\n  distinct fs\n\ngoal (1 subgoal):\n 1. (0::'a) < d (Suc j)", "unfolding lin_indpt_list_def"], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n  ?k \\<le> length fs \\<Longrightarrow>\n  d ?k = (\\<Prod>j<?k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n  ?k \\<le> length fs \\<Longrightarrow> (0::'a) < d ?k\n  distinct fs\n\ngoal (1 subgoal):\n 1. (0::'a) < d (Suc j)", "by (meson less_trans_Suc nat_less_le)"], ["proof (state)\nthis:\n  (0::'a) < d (Suc j)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "let ?sum = \" (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)\""], ["proof (state)\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have \"\\<mu>' i j = (fs ! i \\<bullet> fs ! j - ?sum) * (d (Suc j) / \\<beta> fs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>' i j =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) *\n    (d (Suc j) / \\<beta> fs j)", "unfolding mu_Gramian_beta_def[OF j i] \\<mu>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc j) *\n    ((fs ! i \\<bullet> fs ! j -\n      (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) /\n     \\<beta> fs j) =\n    (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) *\n    (d (Suc j) / \\<beta> fs j)", "by simp"], ["proof (state)\nthis:\n  \\<mu>' i j =\n  (fs ! i \\<bullet> fs ! j -\n   (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) *\n  (d (Suc j) / \\<beta> fs j)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "also"], ["proof (state)\nthis:\n  \\<mu>' i j =\n  (fs ! i \\<bullet> fs ! j -\n   (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) *\n  (d (Suc j) / \\<beta> fs j)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have \"d (Suc j) / \\<beta> fs j = d j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc j) / \\<beta> fs j = d j", "unfolding \\<beta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc j) / (d (Suc j) / d j) = d j", "using dsj"], ["proof (prove)\nusing this:\n  (0::'a) < d (Suc j)\n\ngoal (1 subgoal):\n 1. d (Suc j) / (d (Suc j) / d j) = d j", "by auto"], ["proof (state)\nthis:\n  d (Suc j) / \\<beta> fs j = d j\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "also"], ["proof (state)\nthis:\n  d (Suc j) / \\<beta> fs j = d j\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have \"(fs ! i \\<bullet> fs ! j - ?sum) * d j = (fs ! i \\<bullet> fs ! j) * d j - d j * ?sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! i \\<bullet> fs ! j -\n     (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) *\n    d j =\n    fs ! i \\<bullet> fs ! j * d j -\n    d j * (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)", "by (simp add: ring_distribs)"], ["proof (state)\nthis:\n  (fs ! i \\<bullet> fs ! j -\n   (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) *\n  d j =\n  fs ! i \\<bullet> fs ! j * d j -\n  d j * (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "also"], ["proof (state)\nthis:\n  (fs ! i \\<bullet> fs ! j -\n   (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)) *\n  d j =\n  fs ! i \\<bullet> fs ! j * d j -\n  d j * (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have \"d j * ?sum = \\<sigma> j i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d j * (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k) =\n    \\<sigma> j i j", "by (subst \\<sigma>, (insert j i, force), intro arg_cong[of _ _ \"\\<lambda> x. _ * x\"] sum.cong, auto)"], ["proof (state)\nthis:\n  d j * (\\<Sum>k = 0..<j. \\<mu> j k * \\<mu> i k * \\<beta> fs k) =\n  \\<sigma> j i j\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "finally"], ["proof (chain)\npicking this:\n  \\<mu>' i j = fs ! i \\<bullet> fs ! j * d j - \\<sigma> j i j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu>' i j = fs ! i \\<bullet> fs ! j * d j - \\<sigma> j i j\n\ngoal (1 subgoal):\n 1. \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "by simp"], ["proof (state)\nthis:\n  \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "case False"], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "with j"], ["proof (chain)\npicking this:\n  j \\<le> i\n  \\<not> j < i", "have j: \"j = i\""], ["proof (prove)\nusing this:\n  j \\<le> i\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. j = i", "by auto"], ["proof (state)\nthis:\n  j = i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have dsi: \"d (Suc i) > 0\" \"d i > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < d (Suc i) &&& (0::'a) < d i", "using i Suc_leI dist"], ["proof (prove)\nusing this:\n  i < length fs\n  ?m < ?n \\<Longrightarrow> Suc ?m \\<le> ?n\n  distinct fs\n\ngoal (1 subgoal):\n 1. (0::'a) < d (Suc i) &&& (0::'a) < d i", "unfolding lin_indpt_list_def"], ["proof (prove)\nusing this:\n  i < length fs\n  ?m < ?n \\<Longrightarrow> Suc ?m \\<le> ?n\n  distinct fs\n\ngoal (1 subgoal):\n 1. (0::'a) < d (Suc i) &&& (0::'a) < d i", "by (simp_all add: Suc_leI Gramian_determinant(2))"], ["proof (state)\nthis:\n  (0::'a) < d (Suc i)\n  (0::'a) < d i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "let ?sum = \" (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have bzero: \"\\<beta> fs i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> fs i \\<noteq> (0::'a)", "unfolding \\<beta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc i) / d i \\<noteq> (0::'a)", "using dsi"], ["proof (prove)\nusing this:\n  (0::'a) < d (Suc i)\n  (0::'a) < d i\n\ngoal (1 subgoal):\n 1. d (Suc i) / d i \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<beta> fs i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have \"\\<mu>' i i = d (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>' i i = d (Suc i)", "by (simp add: \\<mu>.simps \\<mu>'_def)"], ["proof (state)\nthis:\n  \\<mu>' i i = d (Suc i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "also"], ["proof (state)\nthis:\n  \\<mu>' i i = d (Suc i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have \"\\<dots> = \\<beta> fs i * (d (Suc i)  / \\<beta> fs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc i) = \\<beta> fs i * (d (Suc i) / \\<beta> fs i)", "using bzero"], ["proof (prove)\nusing this:\n  \\<beta> fs i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. d (Suc i) = \\<beta> fs i * (d (Suc i) / \\<beta> fs i)", "by simp"], ["proof (state)\nthis:\n  d (Suc i) = \\<beta> fs i * (d (Suc i) / \\<beta> fs i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "also"], ["proof (state)\nthis:\n  d (Suc i) = \\<beta> fs i * (d (Suc i) / \\<beta> fs i)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have \"d (Suc i) / \\<beta> fs i = d i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc i) / \\<beta> fs i = d i", "unfolding \\<beta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc i) / (d (Suc i) / d i) = d i", "using dsi"], ["proof (prove)\nusing this:\n  (0::'a) < d (Suc i)\n  (0::'a) < d i\n\ngoal (1 subgoal):\n 1. d (Suc i) / (d (Suc i) / d i) = d i", "by auto"], ["proof (state)\nthis:\n  d (Suc i) / \\<beta> fs i = d i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "also"], ["proof (state)\nthis:\n  d (Suc i) / \\<beta> fs i = d i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have \"\\<beta> fs i = (fs ! i \\<bullet> fs ! i - ?sum)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> fs i =\n    fs ! i \\<bullet> fs ! i -\n    (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k)", "unfolding Gramian_beta[OF i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 -\n    (\\<Sum>j = 0..<i. (\\<mu> i j)\\<^sup>2 * \\<beta> fs j) =\n    fs ! i \\<bullet> fs ! i -\n    (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k)", "by (rule arg_cong2[of _ _ _ _ \"(-)\", OF _ sum.cong], \n        auto simp: power2_eq_square sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  \\<beta> fs i =\n  fs ! i \\<bullet> fs ! i -\n  (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "also"], ["proof (state)\nthis:\n  \\<beta> fs i =\n  fs ! i \\<bullet> fs ! i -\n  (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have \"(fs ! i \\<bullet> fs ! i - ?sum) * d i = (fs ! i \\<bullet> fs ! i) * d i - d i * ?sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! i \\<bullet> fs ! i -\n     (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k)) *\n    d i =\n    fs ! i \\<bullet> fs ! i * d i -\n    d i * (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k)", "by (simp add: ring_distribs)"], ["proof (state)\nthis:\n  (fs ! i \\<bullet> fs ! i -\n   (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k)) *\n  d i =\n  fs ! i \\<bullet> fs ! i * d i -\n  d i * (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "also"], ["proof (state)\nthis:\n  (fs ! i \\<bullet> fs ! i -\n   (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k)) *\n  d i =\n  fs ! i \\<bullet> fs ! i * d i -\n  d i * (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "have \"d i * ?sum = \\<sigma> i i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d i * (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k) =\n    \\<sigma> i i i", "by (subst \\<sigma>, (insert i i, force), intro arg_cong[of _ _ \"\\<lambda> x. _ * x\"] sum.cong, auto)"], ["proof (state)\nthis:\n  d i * (\\<Sum>k = 0..<i. \\<mu> i k * \\<mu> i k * \\<beta> fs k) =\n  \\<sigma> i i i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "finally"], ["proof (chain)\npicking this:\n  \\<mu>' i i = fs ! i \\<bullet> fs ! i * d i - \\<sigma> i i i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu>' i i = fs ! i \\<bullet> fs ! i * d i - \\<sigma> i i i\n\ngoal (1 subgoal):\n 1. \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "using j"], ["proof (prove)\nusing this:\n  \\<mu>' i i = fs ! i \\<bullet> fs ! i * d i - \\<sigma> i i i\n  j = i\n\ngoal (1 subgoal):\n 1. \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j", "by simp"], ["proof (state)\nthis:\n  \\<mu>' i j = d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<sigma>_via_\\<mu>': \"\\<sigma> (Suc l) i j = \n  (if l = 0 then \\<mu>' i 0 * \\<mu>' j 0 else (\\<mu>' l l * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) / \\<mu>' (l - 1) (l - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (Suc l) i j =\n    (if l = 0 then \\<mu>' i 0 * \\<mu>' j 0\n     else (\\<mu>' l l * \\<sigma> l i j + \\<mu>' i l * \\<mu>' j l) /\n          \\<mu>' (l - 1) (l - 1))", "by (cases l, auto simp: d_Suc)"], ["", "lemma \\<mu>'_via_\\<sigma>: assumes j: \"j \\<le> i\" and i: \"i < m\" \n  shows \"\\<mu>' i j = \n    (if j = 0 then fs ! i \\<bullet> fs ! j else \\<mu>' (j - 1) (j - 1) * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>' i j =\n    (if j = 0 then fs ! i \\<bullet> fs ! j\n     else \\<mu>' (j - 1) (j - 1) * (fs ! i \\<bullet> fs ! j) -\n          \\<sigma> j i j)", "unfolding \\<mu>'[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. d j * (fs ! i \\<bullet> fs ! j) - \\<sigma> j i j =\n    (if j = 0 then fs ! i \\<bullet> fs ! j\n     else \\<mu>' (j - 1) (j - 1) * (fs ! i \\<bullet> fs ! j) -\n          \\<sigma> j i j)", "by (cases j, auto simp: d_Suc)"], ["", "lemma fs_i_sumlist_\\<kappa>:\n  assumes \"i < m\" \"l \\<le> i\" \"j < l\"\n  shows \"(fs ! i + sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])) \\<bullet> fs ! j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "have \"fs ! i + sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n        = fs ! i - M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n    fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])", "using assms gso_carrier assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n    fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])", "by (subst \\<kappa>_def[symmetric]) (auto simp add: dim_sumlist sumlist_nth sum_negf)"], ["proof (state)\nthis:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  fs ! i -\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  fs ! i -\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "have \"\\<dots> = M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "have \"fs ! i = M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])", "by (intro fi_is_sum_of_mu_gso) auto"], ["proof (state)\nthis:\n  fs ! i =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])\n\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "also"], ["proof (state)\nthis:\n  fs ! i =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])\n\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "have \"\\<dots> = M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n                  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "have *: \"[0..<Suc i] = [0..<l] @ [l..<Suc i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc i] = [0..<l] @ [l..<Suc i]", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. [0..<Suc i] = [0..<l] @ [l..<Suc i]", "by (metis diff_zero le_imp_less_Suc length_upt list_trisect upt_conv_Cons)"], ["proof (state)\nthis:\n  [0..<Suc i] = [0..<l] @ [l..<Suc i]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "by (subst *, subst map_append, subst sumlist_append) (use gso_carrier assms in auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "finally"], ["proof (chain)\npicking this:\n  fs ! i =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "show ?thesis"], ["proof (prove)\nusing this:\n  fs ! i =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "using assms gso_carrier assms"], ["proof (prove)\nusing this:\n  fs ! i =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n  i < length fs\n  l \\<le> i\n  j < l\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "by (auto simp add: algebra_simps dim_sumlist)"], ["proof (state)\nthis:\n  fs ! i -\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fs ! i -\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "have \"fs ! i + M.sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n                M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\""], ["proof (prove)\nusing this:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "by simp"], ["proof (state)\nthis:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "moreover"], ["proof (state)\nthis:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "have \"\\<dots> \\<bullet> (fs ! j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n       [l..<Suc i]) \\<bullet>\n    fs ! j =\n    (0::'a)", "using assms gso_carrier assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n       [l..<Suc i]) \\<bullet>\n    fs ! j =\n    (0::'a)", "unfolding lin_indpt_list_def"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n       [l..<Suc i]) \\<bullet>\n    fs ! j =\n    (0::'a)", "by (subst scalar_prod_left_sum_distrib)\n       (auto simp add: algebra_simps dim_sumlist gso_scalar_zero intro!: sum_list_zero)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i]) \\<bullet>\n  fs ! j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i]) \\<bullet>\n  fs ! j =\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i]) \\<bullet>\n  fs ! j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i]) \\<bullet>\n  fs ! j =\n  (0::'a)\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n      [0..<l])) \\<bullet>\n  fs ! j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* gram_schmidt_fs_lin_indpt *)"], ["", "context gram_schmidt_fs_int\nbegin"], ["", "lemma \\<beta>_pos : \"i < m \\<Longrightarrow> \\<beta> fs i > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> (0::'a) < \\<beta> fs i", "using Gramian_determinant(2)"], ["proof (prove)\nusing this:\n  ?k \\<le> length fs \\<Longrightarrow> (0::'a) < d ?k\n\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> (0::'a) < \\<beta> fs i", "unfolding lin_indpt_list_def \\<beta>_def"], ["proof (prove)\nusing this:\n  ?k \\<le> length fs \\<Longrightarrow> (0::'a) < d ?k\n\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> (0::'a) < d (Suc i) / d i", "by auto"], ["", "lemma \\<beta>_zero : \"i < m \\<Longrightarrow> \\<beta> fs i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> \\<beta> fs i \\<noteq> (0::'a)", "using \\<beta>_pos[of i]"], ["proof (prove)\nusing this:\n  i < length fs \\<Longrightarrow> (0::'a) < \\<beta> fs i\n\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> \\<beta> fs i \\<noteq> (0::'a)", "by simp"], ["", "lemma \\<sigma>_integer:  \n  assumes l: \"l \\<le> j\" and j: \"j \\<le> i\" and i: \"i < m\"\n  shows \"\\<sigma> l i j \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "from assms"], ["proof (chain)\npicking this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs", "have ll: \"l \\<le> m\""], ["proof (prove)\nusing this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. l \\<le> length fs", "by auto"], ["proof (state)\nthis:\n  l \\<le> length fs\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have fs_carr: \"j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length fs \\<Longrightarrow> fs ! j \\<in> carrier_vec n", "using assms fs_carrier"], ["proof (prove)\nusing this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. j < length fs \\<Longrightarrow> fs ! j \\<in> carrier_vec n", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n  {fs ! i |i. i < length fs} \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. j < length fs \\<Longrightarrow> fs ! j \\<in> carrier_vec n", "by force"], ["proof (state)\nthis:\n  ?j1 < length fs \\<Longrightarrow> fs ! ?j1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "with assms"], ["proof (chain)\npicking this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n  ?j1 < length fs \\<Longrightarrow> fs ! ?j1 \\<in> carrier_vec n", "have fs_carr_j: \"fs ! j \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n  ?j1 < length fs \\<Longrightarrow> fs ! ?j1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. fs ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  fs ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have dim_gso: \"i < m \\<Longrightarrow> dim_vec (gso i) = n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> dim_vec (gso i) = n", "using gso_carrier"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> dim_vec (gso i) = n", "by auto"], ["proof (state)\nthis:\n  ?i1 < length fs \\<Longrightarrow> dim_vec (gso ?i1) = n\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have dim_fs: \"k < m \\<Longrightarrow> dim_vec (fs ! k) = n\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length fs \\<Longrightarrow> dim_vec (fs ! k) = n", "using smult_carrier_vec fs_carr"], ["proof (prove)\nusing this:\n  (?a \\<cdot>\\<^sub>v ?v \\<in> carrier_vec ?n) = (?v \\<in> carrier_vec ?n)\n  ?j1 < length fs \\<Longrightarrow> fs ! ?j1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. k < length fs \\<Longrightarrow> dim_vec (fs ! k) = n", "by auto"], ["proof (state)\nthis:\n  ?k1 < length fs \\<Longrightarrow> dim_vec (fs ! ?k1) = n\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have i_l_m: \"i < l \\<Longrightarrow> i < m\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < l \\<Longrightarrow> i < length fs", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. i < l \\<Longrightarrow> i < length fs", "by auto"], ["proof (state)\nthis:\n  ?i1 < l \\<Longrightarrow> ?i1 < length fs\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have smult: \"\\<And> i j . j < n \\<Longrightarrow> i < l \\<Longrightarrow> (c \\<cdot>\\<^sub>v fs ! i) $ j = c * (fs ! i $ j)\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < n; i < l\\<rbrakk>\n       \\<Longrightarrow> (c \\<cdot>\\<^sub>v fs ! i) $ j = c * fs ! i $ j", "using i_l_m dim_fs"], ["proof (prove)\nusing this:\n  ?i1 < l \\<Longrightarrow> ?i1 < length fs\n  ?k1 < length fs \\<Longrightarrow> dim_vec (fs ! ?k1) = n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < n; i < l\\<rbrakk>\n       \\<Longrightarrow> (c \\<cdot>\\<^sub>v fs ! i) $ j = c * fs ! i $ j", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?j1 < n; ?i1 < l\\<rbrakk>\n  \\<Longrightarrow> (?c2 \\<cdot>\\<^sub>v fs ! ?i1) $ ?j1 =\n                    ?c2 * fs ! ?i1 $ ?j1\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have \"\\<sigma> l i j = d l * (\\<Sum>k < l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> l i j = d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "unfolding \\<sigma>[OF ll]"], ["proof (prove)\ngoal (1 subgoal):\n 1. d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k) =\n    d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)", "by simp"], ["proof (state)\nthis:\n  \\<sigma> l i j = d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  \\<sigma> l i j = d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have \" ... = d l * (\\<Sum>k < l. \\<mu> i k * ((fs ! j) \\<bullet> (gso k) /  sq_norm (gso k)) * \\<beta> fs k)\" (is \"_ = _ * ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k) =\n    d l *\n    (\\<Sum>k<l.\n        \\<mu> i k *\n        (fs ! j \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2) *\n        \\<beta> fs k)", "unfolding \\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. d l *\n    (\\<Sum>k<l.\n        (if k < i\n         then fs ! i \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2\n         else if i = k then 1::'a else (0::'a)) *\n        (if k < j\n         then fs ! j \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2\n         else if j = k then 1::'a else (0::'a)) *\n        \\<beta> fs k) =\n    d l *\n    (\\<Sum>k<l.\n        (if k < i\n         then fs ! i \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2\n         else if i = k then 1::'a else (0::'a)) *\n        (fs ! j \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2) *\n        \\<beta> fs k)", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. d l *\n    (\\<Sum>k<l.\n        (if k < i\n         then fs ! i \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2\n         else if i = k then 1::'a else (0::'a)) *\n        (if k < j\n         then fs ! j \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2\n         else if j = k then 1::'a else (0::'a)) *\n        \\<beta> fs k) =\n    d l *\n    (\\<Sum>k<l.\n        (if k < i\n         then fs ! i \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2\n         else if i = k then 1::'a else (0::'a)) *\n        (fs ! j \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2) *\n        \\<beta> fs k)", "by auto"], ["proof (state)\nthis:\n  d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k) =\n  d l *\n  (\\<Sum>k<l.\n      \\<mu> i k *\n      (fs ! j \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2) *\n      \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  d l * (\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k) =\n  d l *\n  (\\<Sum>k<l.\n      \\<mu> i k *\n      (fs ! j \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2) *\n      \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have \"?sum =  (\\<Sum>k < l. \\<mu> i k * ((fs ! j) \\<bullet> (gso k) /  \\<beta> fs k) * \\<beta> fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<l.\n        \\<mu> i k *\n        (fs ! j \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2) *\n        \\<beta> fs k) =\n    (\\<Sum>k<l.\n        \\<mu> i k * (fs ! j \\<bullet> gso k / \\<beta> fs k) * \\<beta> fs k)", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<l.\n        \\<mu> i k *\n        (fs ! j \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2) *\n        \\<beta> fs k) =\n    (\\<Sum>k<l.\n        \\<mu> i k * (fs ! j \\<bullet> gso k / \\<beta> fs k) * \\<beta> fs k)", "by (auto simp add: gso_norm_beta[symmetric] intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>k<l.\n      \\<mu> i k *\n      (fs ! j \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2) *\n      \\<beta> fs k) =\n  (\\<Sum>k<l.\n      \\<mu> i k * (fs ! j \\<bullet> gso k / \\<beta> fs k) * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<l.\n      \\<mu> i k *\n      (fs ! j \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2) *\n      \\<beta> fs k) =\n  (\\<Sum>k<l.\n      \\<mu> i k * (fs ! j \\<bullet> gso k / \\<beta> fs k) * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have \"... = (\\<Sum>k < l. \\<mu> i k * ((fs ! j) \\<bullet> (gso k) ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<l.\n        \\<mu> i k * (fs ! j \\<bullet> gso k / \\<beta> fs k) *\n        \\<beta> fs k) =\n    (\\<Sum>k<l. \\<mu> i k * (fs ! j \\<bullet> gso k))", "using \\<beta>_zero assms"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> \\<beta> fs ?i \\<noteq> (0::'a)\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<l.\n        \\<mu> i k * (fs ! j \\<bullet> gso k / \\<beta> fs k) *\n        \\<beta> fs k) =\n    (\\<Sum>k<l. \\<mu> i k * (fs ! j \\<bullet> gso k))", "by (auto intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>k<l.\n      \\<mu> i k * (fs ! j \\<bullet> gso k / \\<beta> fs k) * \\<beta> fs k) =\n  (\\<Sum>k<l. \\<mu> i k * (fs ! j \\<bullet> gso k))\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<l.\n      \\<mu> i k * (fs ! j \\<bullet> gso k / \\<beta> fs k) * \\<beta> fs k) =\n  (\\<Sum>k<l. \\<mu> i k * (fs ! j \\<bullet> gso k))\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have \" ... = (fs ! j) \\<bullet> M.sumlist (map (\\<lambda>k. (\\<mu> i k) \\<cdot>\\<^sub>v (gso k)) [0..<l] )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<l. \\<mu> i k * (fs ! j \\<bullet> gso k)) =\n    fs ! j \\<bullet>\n    M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])", "using assms fs_carr[of j] gso_carrier"], ["proof (prove)\nusing this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n  j < length fs \\<Longrightarrow> fs ! j \\<in> carrier_vec n\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<l. \\<mu> i k * (fs ! j \\<bullet> gso k)) =\n    fs ! j \\<bullet>\n    M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])", "by (subst scalar_prod_right_sum_distrib) (auto intro!: gso_carrier fs_carr sum.cong simp: sum_list_sum_nth)"], ["proof (state)\nthis:\n  (\\<Sum>k<l. \\<mu> i k * (fs ! j \\<bullet> gso k)) =\n  fs ! j \\<bullet>\n  M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<l. \\<mu> i k * (fs ! j \\<bullet> gso k)) =\n  fs ! j \\<bullet>\n  M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have \"d l * \\<dots> = (fs ! j) \\<bullet> (d l \\<cdot>\\<^sub>v M.sumlist (map (\\<lambda>k. (\\<mu> i k) \\<cdot>\\<^sub>v (gso k)) [0..<l]))\" (is \"_ = _ \\<bullet> (_ \\<cdot>\\<^sub>v ?sum2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d l *\n    (fs ! j \\<bullet>\n     M.sumlist\n      (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])) =\n    fs ! j \\<bullet>\n    (d l \\<cdot>\\<^sub>v\n     M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]))", "apply (rule scalar_prod_smult_distrib[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. fs ! j \\<in> carrier_vec ?n\n 2. M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])\n    \\<in> carrier_vec ?n", "apply (rule fs_carr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. j < length fs\n 2. M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])\n    \\<in> carrier_vec n", "using assms gso_carrier"], ["proof (prove)\nusing this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. j < length fs\n 2. M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])\n    \\<in> carrier_vec n", "by (auto intro!: sumlist_carrier)"], ["proof (state)\nthis:\n  d l *\n  (fs ! j \\<bullet>\n   M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])) =\n  fs ! j \\<bullet>\n  (d l \\<cdot>\\<^sub>v\n   M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]))\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  d l *\n  (fs ! j \\<bullet>\n   M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])) =\n  fs ! j \\<bullet>\n  (d l \\<cdot>\\<^sub>v\n   M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]))\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have \"?sum2 = - sumlist (map (\\<lambda>k. (- \\<mu> i k) \\<cdot>\\<^sub>v (gso k)) [0..<l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]) =\n    - M.sumlist\n       (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])", "apply(rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec\n             (- M.sumlist\n                 (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k)\n                   [0..<l])) \\<Longrightarrow>\n       M.sumlist\n        (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]) $\n       ia =\n       (- M.sumlist\n           (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])) $\n       ia\n 2. dim_vec\n     (M.sumlist\n       (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])) =\n    dim_vec\n     (- M.sumlist\n         (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]))", "using fs_carr gso_carrier assms i_l_m"], ["proof (prove)\nusing this:\n  ?j1 < length fs \\<Longrightarrow> fs ! ?j1 \\<in> carrier_vec n\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n  ?i1 < l \\<Longrightarrow> ?i1 < length fs\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec\n             (- M.sumlist\n                 (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k)\n                   [0..<l])) \\<Longrightarrow>\n       M.sumlist\n        (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]) $\n       ia =\n       (- M.sumlist\n           (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])) $\n       ia\n 2. dim_vec\n     (M.sumlist\n       (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])) =\n    dim_vec\n     (- M.sumlist\n         (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]))", "by(auto simp: sum_negf[symmetric] dim_sumlist sumlist_nth dim_gso intro!: sum.cong)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]) =\n  - M.sumlist (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>k. \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]) =\n  - M.sumlist (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have \"\\<dots> = - sumlist (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - M.sumlist\n       (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]) =\n    - M.sumlist\n       (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "using assms gso_carrier assms"], ["proof (prove)\nusing this:\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. - M.sumlist\n       (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]) =\n    - M.sumlist\n       (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "apply (subst \\<kappa>_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>l \\<le> j; j \\<le> i; i < length fs;\n     \\<And>i. i < length fs \\<Longrightarrow> gso i \\<in> carrier_vec n;\n     l \\<le> j; j \\<le> i; i < length fs\\<rbrakk>\n    \\<Longrightarrow> i < length fs\n 2. \\<lbrakk>l \\<le> j; j \\<le> i; i < length fs;\n     \\<And>i. i < length fs \\<Longrightarrow> gso i \\<in> carrier_vec n;\n     l \\<le> j; j \\<le> i; i < length fs\\<rbrakk>\n    \\<Longrightarrow> l \\<le> i\n 3. \\<lbrakk>l \\<le> j; j \\<le> i; i < length fs;\n     \\<And>i. i < length fs \\<Longrightarrow> gso i \\<in> carrier_vec n;\n     l \\<le> j; j \\<le> i; i < length fs\\<rbrakk>\n    \\<Longrightarrow> - M.sumlist\n                         (map (\\<lambda>j.\n                                  \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n                           [0..<l]) =\n                      - M.sumlist\n                         (map (\\<lambda>k.\n                                  \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                           [0..<l])", "by (auto)"], ["proof (state)\nthis:\n  - M.sumlist\n     (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]) =\n  - M.sumlist\n     (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  - M.sumlist\n     (map (\\<lambda>k. - \\<mu> i k \\<cdot>\\<^sub>v gso k) [0..<l]) =\n  - M.sumlist\n     (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "have \"(d l \\<cdot>\\<^sub>v - sumlist (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])) =\n\t\t     (- sumlist (map (\\<lambda>k. (d l * \\<kappa> i l k) \\<cdot>\\<^sub>v fs ! k) [0..<l]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d l \\<cdot>\\<^sub>v\n    - M.sumlist\n       (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l]) =\n    - M.sumlist\n       (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n         [0..<l])", "apply(rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec\n             (- M.sumlist\n                 (map (\\<lambda>k.\n                          d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                   [0..<l])) \\<Longrightarrow>\n       (d l \\<cdot>\\<^sub>v\n        - M.sumlist\n           (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n             [0..<l])) $\n       ia =\n       (- M.sumlist\n           (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n             [0..<l])) $\n       ia\n 2. dim_vec\n     (d l \\<cdot>\\<^sub>v\n      - M.sumlist\n         (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n           [0..<l])) =\n    dim_vec\n     (- M.sumlist\n         (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n           [0..<l]))", "using fs_carr smult_carrier_vec dim_fs"], ["proof (prove)\nusing this:\n  ?j1 < length fs \\<Longrightarrow> fs ! ?j1 \\<in> carrier_vec n\n  (?a \\<cdot>\\<^sub>v ?v \\<in> carrier_vec ?n) = (?v \\<in> carrier_vec ?n)\n  ?k1 < length fs \\<Longrightarrow> dim_vec (fs ! ?k1) = n\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec\n             (- M.sumlist\n                 (map (\\<lambda>k.\n                          d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                   [0..<l])) \\<Longrightarrow>\n       (d l \\<cdot>\\<^sub>v\n        - M.sumlist\n           (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n             [0..<l])) $\n       ia =\n       (- M.sumlist\n           (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n             [0..<l])) $\n       ia\n 2. dim_vec\n     (d l \\<cdot>\\<^sub>v\n      - M.sumlist\n         (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n           [0..<l])) =\n    dim_vec\n     (- M.sumlist\n         (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n           [0..<l]))", "using dim_fs i_l_m"], ["proof (prove)\nusing this:\n  ?j1 < length fs \\<Longrightarrow> fs ! ?j1 \\<in> carrier_vec n\n  (?a \\<cdot>\\<^sub>v ?v \\<in> carrier_vec ?n) = (?v \\<in> carrier_vec ?n)\n  ?k1 < length fs \\<Longrightarrow> dim_vec (fs ! ?k1) = n\n  ?k1 < length fs \\<Longrightarrow> dim_vec (fs ! ?k1) = n\n  ?i1 < l \\<Longrightarrow> ?i1 < length fs\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec\n             (- M.sumlist\n                 (map (\\<lambda>k.\n                          d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                   [0..<l])) \\<Longrightarrow>\n       (d l \\<cdot>\\<^sub>v\n        - M.sumlist\n           (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n             [0..<l])) $\n       ia =\n       (- M.sumlist\n           (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n             [0..<l])) $\n       ia\n 2. dim_vec\n     (d l \\<cdot>\\<^sub>v\n      - M.sumlist\n         (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n           [0..<l])) =\n    dim_vec\n     (- M.sumlist\n         (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n           [0..<l]))", "by (auto simp: smult dim_sumlist sumlist_nth sum_distrib_left intro!: sum.cong)"], ["proof (state)\nthis:\n  d l \\<cdot>\\<^sub>v\n  - M.sumlist\n     (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l]) =\n  - M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  \\<sigma> l i j =\n  fs ! j \\<bullet>\n  - M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "have id: \" \\<sigma> l i j = fs ! j \\<bullet> - M.sumlist (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l]) \""], ["proof (prove)\nusing this:\n  \\<sigma> l i j =\n  fs ! j \\<bullet>\n  - M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j =\n    fs ! j \\<bullet>\n    - M.sumlist\n       (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n         [0..<l])", "."], ["proof (state)\nthis:\n  \\<sigma> l i j =\n  fs ! j \\<bullet>\n  - M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "(* now we are able to apply d_\\<kappa>_int *)"], ["proof (state)\nthis:\n  \\<sigma> l i j =\n  fs ! j \\<bullet>\n  - M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "show \"\\<sigma> l i j \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> l i j \\<in> \\<int>", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! j \\<bullet>\n    - M.sumlist\n       (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n         [0..<l])\n    \\<in> \\<int>", "using i_l_m fs_carr assms fs_int d_\\<kappa>_Ints"], ["proof (prove)\nusing this:\n  ?i1 < l \\<Longrightarrow> ?i1 < length fs\n  ?j1 < length fs \\<Longrightarrow> fs ! ?j1 \\<in> carrier_vec n\n  l \\<le> j\n  j \\<le> i\n  i < length fs\n  \\<lbrakk>?i < n; ?j < length fs\\<rbrakk>\n  \\<Longrightarrow> fs ! ?j $ ?i \\<in> \\<int>\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i; ?t < ?l\\<rbrakk>\n  \\<Longrightarrow> d ?l * \\<kappa> ?i ?l ?t \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. fs ! j \\<bullet>\n    - M.sumlist\n       (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n         [0..<l])\n    \\<in> \\<int>", "by (auto simp: dim_sumlist sumlist_nth smult \n\t        intro!: sumlist_carrier Ints_minus Ints_sum Ints_mult[of _ \"fs ! _ $ _\"]  Ints_scalar_prod[OF fs_carr])"], ["proof (state)\nthis:\n  \\<sigma> l i j \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* gram_schmidt_fs_int *)"], ["", "context fs_int_indpt\nbegin"], ["", "fun \\<sigma>s and \\<mu>' where \n  \"\\<sigma>s 0 i j = \\<mu>' i 0 * \\<mu>' j 0\" \n| \"\\<sigma>s (Suc l) i j = (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j + \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) div \\<mu>' l l\" \n| \"\\<mu>' i j = (if j = 0 then fs ! i \\<bullet> fs ! j else \\<mu>' (j - 1) (j - 1) * (fs ! i \\<bullet> fs ! j) - \\<sigma>s (j - 1) i j)\""], ["", "declare \\<mu>'.simps[simp del]"], ["", "lemma \\<sigma>s_\\<mu>': \"l < j \\<Longrightarrow> j \\<le> i \\<Longrightarrow> i < m \\<Longrightarrow> of_int (\\<sigma>s l i j) = gs.\\<sigma> (Suc l) i j\" \n  \"i < m \\<Longrightarrow> j \\<le> i \\<Longrightarrow> of_int (\\<mu>'  i j) = gs.\\<mu>' i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n     \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) =\n                       gs.\\<sigma> (Suc l) i j) &&&\n    (\\<lbrakk>i < length fs; j \\<le> i\\<rbrakk>\n     \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j)", "proof (induct l i j and i j rule: \\<sigma>s_\\<mu>'.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' i 0) = gs.\\<mu>' i 0;\n        \\<lbrakk>j < length fs; 0 \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j 0) = gs.\\<mu>' j 0;\n        0 < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s 0 i j) =\n                         gs.\\<sigma> (Suc 0) i j\n 2. \\<And>l i j.\n       \\<lbrakk>\\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                                  gs.\\<mu>' (Suc l) (Suc l);\n        \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) =\n                          gs.\\<sigma> (Suc l) i j;\n        \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) =\n                          gs.\\<mu>' i (Suc l);\n        \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) =\n                          gs.\\<mu>' j (Suc l);\n        \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l;\n        Suc l < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s (Suc l) i j) =\n                         gs.\\<sigma> (Suc (Suc l)) i j\n 3. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' i 0) = gs.\\<mu>' i 0\n  \\<lbrakk>j < length fs; 0 \\<le> j\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' j 0) = gs.\\<mu>' j 0\n  0 < j\n  j \\<le> i\n  i < length fs\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' i 0) = gs.\\<mu>' i 0;\n        \\<lbrakk>j < length fs; 0 \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j 0) = gs.\\<mu>' j 0;\n        0 < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s 0 i j) =\n                         gs.\\<sigma> (Suc 0) i j\n 2. \\<And>l i j.\n       \\<lbrakk>\\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                                  gs.\\<mu>' (Suc l) (Suc l);\n        \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) =\n                          gs.\\<sigma> (Suc l) i j;\n        \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) =\n                          gs.\\<mu>' i (Suc l);\n        \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) =\n                          gs.\\<mu>' j (Suc l);\n        \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l;\n        Suc l < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s (Suc l) i j) =\n                         gs.\\<sigma> (Suc (Suc l)) i j\n 3. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' i 0) = gs.\\<mu>' i 0\n  \\<lbrakk>j < length fs; 0 \\<le> j\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' j 0) = gs.\\<mu>' j 0\n  0 < j\n  j \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. rat_of_int (\\<sigma>s 0 i j) = gs.\\<sigma> (Suc 0) i j", "by (simp add: gs.\\<sigma>.simps)"], ["proof (state)\nthis:\n  rat_of_int (\\<sigma>s 0 i j) = gs.\\<sigma> (Suc 0) i j\n\ngoal (2 subgoals):\n 1. \\<And>l i j.\n       \\<lbrakk>\\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                                  gs.\\<mu>' (Suc l) (Suc l);\n        \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) =\n                          gs.\\<sigma> (Suc l) i j;\n        \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) =\n                          gs.\\<mu>' i (Suc l);\n        \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) =\n                          gs.\\<mu>' j (Suc l);\n        \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l;\n        Suc l < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s (Suc l) i j) =\n                         gs.\\<sigma> (Suc (Suc l)) i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l i j.\n       \\<lbrakk>\\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                                  gs.\\<mu>' (Suc l) (Suc l);\n        \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) =\n                          gs.\\<sigma> (Suc l) i j;\n        \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) =\n                          gs.\\<mu>' i (Suc l);\n        \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) =\n                          gs.\\<mu>' j (Suc l);\n        \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l;\n        Suc l < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s (Suc l) i j) =\n                         gs.\\<sigma> (Suc (Suc l)) i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "case (2 l i j)"], ["proof (state)\nthis:\n  \\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                    gs.\\<mu>' (Suc l) (Suc l)\n  \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) = gs.\\<sigma> (Suc l) i j\n  \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) = gs.\\<mu>' i (Suc l)\n  \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) = gs.\\<mu>' j (Suc l)\n  \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l\n  Suc l < j\n  j \\<le> i\n  i < length fs\n\ngoal (2 subgoals):\n 1. \\<And>l i j.\n       \\<lbrakk>\\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                                  gs.\\<mu>' (Suc l) (Suc l);\n        \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) =\n                          gs.\\<sigma> (Suc l) i j;\n        \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) =\n                          gs.\\<mu>' i (Suc l);\n        \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) =\n                          gs.\\<mu>' j (Suc l);\n        \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l;\n        Suc l < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s (Suc l) i j) =\n                         gs.\\<sigma> (Suc (Suc l)) i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "have \"gs.\\<sigma>(Suc (Suc l)) i j \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.\\<sigma> (Suc (Suc l)) i j \\<in> \\<int>", "by (rule gs.\\<sigma>_integer, insert 2 gs.fs_carrier, auto)"], ["proof (state)\nthis:\n  gs.\\<sigma> (Suc (Suc l)) i j \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. \\<And>l i j.\n       \\<lbrakk>\\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                                  gs.\\<mu>' (Suc l) (Suc l);\n        \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) =\n                          gs.\\<sigma> (Suc l) i j;\n        \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) =\n                          gs.\\<mu>' i (Suc l);\n        \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) =\n                          gs.\\<mu>' j (Suc l);\n        \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l;\n        Suc l < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s (Suc l) i j) =\n                         gs.\\<sigma> (Suc (Suc l)) i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "then"], ["proof (chain)\npicking this:\n  gs.\\<sigma> (Suc (Suc l)) i j \\<in> \\<int>", "have \"rat_of_int (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j + \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) / rat_of_int (\\<mu>' l l) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  gs.\\<sigma> (Suc (Suc l)) i j \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int\n     (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j +\n      \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) /\n    rat_of_int (\\<mu>' l l)\n    \\<in> \\<int>", "using 2 gs.d_Suc"], ["proof (prove)\nusing this:\n  gs.\\<sigma> (Suc (Suc l)) i j \\<in> \\<int>\n  \\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                    gs.\\<mu>' (Suc l) (Suc l)\n  \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) = gs.\\<sigma> (Suc l) i j\n  \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) = gs.\\<mu>' i (Suc l)\n  \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) = gs.\\<mu>' j (Suc l)\n  \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l\n  Suc l < j\n  j \\<le> i\n  i < length fs\n  gs.d (Suc ?i) = gs.\\<mu>' ?i ?i\n\ngoal (1 subgoal):\n 1. rat_of_int\n     (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j +\n      \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) /\n    rat_of_int (\\<mu>' l l)\n    \\<in> \\<int>", "by (auto)"], ["proof (state)\nthis:\n  rat_of_int\n   (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j +\n    \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) /\n  rat_of_int (\\<mu>' l l)\n  \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. \\<And>l i j.\n       \\<lbrakk>\\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                                  gs.\\<mu>' (Suc l) (Suc l);\n        \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) =\n                          gs.\\<sigma> (Suc l) i j;\n        \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) =\n                          gs.\\<mu>' i (Suc l);\n        \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) =\n                          gs.\\<mu>' j (Suc l);\n        \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l;\n        Suc l < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s (Suc l) i j) =\n                         gs.\\<sigma> (Suc (Suc l)) i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "then"], ["proof (chain)\npicking this:\n  rat_of_int\n   (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j +\n    \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) /\n  rat_of_int (\\<mu>' l l)\n  \\<in> \\<int>", "have \"rat_of_int (\\<sigma>s (Suc l) i j) = \n             of_int (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j + \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) / of_int (\\<mu>' l l)\""], ["proof (prove)\nusing this:\n  rat_of_int\n   (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j +\n    \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) /\n  rat_of_int (\\<mu>' l l)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int (\\<sigma>s (Suc l) i j) =\n    rat_of_int\n     (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j +\n      \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) /\n    rat_of_int (\\<mu>' l l)", "by (subst \\<sigma>s.simps, subst exact_division) auto"], ["proof (state)\nthis:\n  rat_of_int (\\<sigma>s (Suc l) i j) =\n  rat_of_int\n   (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j +\n    \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) /\n  rat_of_int (\\<mu>' l l)\n\ngoal (2 subgoals):\n 1. \\<And>l i j.\n       \\<lbrakk>\\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                                  gs.\\<mu>' (Suc l) (Suc l);\n        \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) =\n                          gs.\\<sigma> (Suc l) i j;\n        \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) =\n                          gs.\\<mu>' i (Suc l);\n        \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) =\n                          gs.\\<mu>' j (Suc l);\n        \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l;\n        Suc l < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s (Suc l) i j) =\n                         gs.\\<sigma> (Suc (Suc l)) i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "also"], ["proof (state)\nthis:\n  rat_of_int (\\<sigma>s (Suc l) i j) =\n  rat_of_int\n   (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j +\n    \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) /\n  rat_of_int (\\<mu>' l l)\n\ngoal (2 subgoals):\n 1. \\<And>l i j.\n       \\<lbrakk>\\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                                  gs.\\<mu>' (Suc l) (Suc l);\n        \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) =\n                          gs.\\<sigma> (Suc l) i j;\n        \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) =\n                          gs.\\<mu>' i (Suc l);\n        \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) =\n                          gs.\\<mu>' j (Suc l);\n        \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l;\n        Suc l < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s (Suc l) i j) =\n                         gs.\\<sigma> (Suc (Suc l)) i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "have \"\\<dots> = gs.\\<sigma> (Suc (Suc l)) i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int\n     (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j +\n      \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) /\n    rat_of_int (\\<mu>' l l) =\n    gs.\\<sigma> (Suc (Suc l)) i j", "using 2 gs.d_Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                    gs.\\<mu>' (Suc l) (Suc l)\n  \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) = gs.\\<sigma> (Suc l) i j\n  \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) = gs.\\<mu>' i (Suc l)\n  \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) = gs.\\<mu>' j (Suc l)\n  \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l\n  Suc l < j\n  j \\<le> i\n  i < length fs\n  gs.d (Suc ?i) = gs.\\<mu>' ?i ?i\n\ngoal (1 subgoal):\n 1. rat_of_int\n     (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j +\n      \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) /\n    rat_of_int (\\<mu>' l l) =\n    gs.\\<sigma> (Suc (Suc l)) i j", "by (auto)"], ["proof (state)\nthis:\n  rat_of_int\n   (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l i j +\n    \\<mu>' i (Suc l) * \\<mu>' j (Suc l)) /\n  rat_of_int (\\<mu>' l l) =\n  gs.\\<sigma> (Suc (Suc l)) i j\n\ngoal (2 subgoals):\n 1. \\<And>l i j.\n       \\<lbrakk>\\<lbrakk>Suc l < length fs; Suc l \\<le> Suc l\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (Suc l) (Suc l)) =\n                                  gs.\\<mu>' (Suc l) (Suc l);\n        \\<lbrakk>l < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s l i j) =\n                          gs.\\<sigma> (Suc l) i j;\n        \\<lbrakk>i < length fs; Suc l \\<le> i\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' i (Suc l)) =\n                          gs.\\<mu>' i (Suc l);\n        \\<lbrakk>j < length fs; Suc l \\<le> j\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' j (Suc l)) =\n                          gs.\\<mu>' j (Suc l);\n        \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<mu>' l l) = gs.\\<mu>' l l;\n        Suc l < j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<sigma>s (Suc l) i j) =\n                         gs.\\<sigma> (Suc (Suc l)) i j\n 2. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (\\<sigma>s (Suc l) i j) = gs.\\<sigma> (Suc (Suc l)) i j", "show ?case"], ["proof (prove)\nusing this:\n  rat_of_int (\\<sigma>s (Suc l) i j) = gs.\\<sigma> (Suc (Suc l)) i j\n\ngoal (1 subgoal):\n 1. rat_of_int (\\<sigma>s (Suc l) i j) = gs.\\<sigma> (Suc (Suc l)) i j", "by simp"], ["proof (state)\nthis:\n  rat_of_int (\\<sigma>s (Suc l) i j) = gs.\\<sigma> (Suc (Suc l)) i j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "case (3 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>j \\<noteq> 0; j - 1 < length fs; j - 1 \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                    gs.\\<mu>' (j - 1) (j - 1)\n  \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                    gs.\\<sigma> (Suc (j - 1)) i j\n  i < length fs\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "have \"dim_vec (fs ! j) = dim_vec (fs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (fs ! j) = dim_vec (fs ! i)", "using 3 f_carrier[of i] f_carrier[of j] carrier_vec_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<noteq> 0; j - 1 < length fs; j - 1 \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                    gs.\\<mu>' (j - 1) (j - 1)\n  \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                    gs.\\<sigma> (Suc (j - 1)) i j\n  i < length fs\n  j \\<le> i\n  i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n\n  j < length fs \\<Longrightarrow> fs ! j \\<in> carrier_vec n\n  carrier_vec ?n = {v. dim_vec v = ?n}\n\ngoal (1 subgoal):\n 1. dim_vec (fs ! j) = dim_vec (fs ! i)", "by auto"], ["proof (state)\nthis:\n  dim_vec (fs ! j) = dim_vec (fs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "then"], ["proof (chain)\npicking this:\n  dim_vec (fs ! j) = dim_vec (fs ! i)", "have \"of_int_hom.vec_hom (fs ! i) $ k = rat_of_int (fs ! i $ k)\" if \"k < dim_vec (fs ! j)\" for k"], ["proof (prove)\nusing this:\n  dim_vec (fs ! j) = dim_vec (fs ! i)\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! i) $ k = rat_of_int (fs ! i $ k)", "using that"], ["proof (prove)\nusing this:\n  dim_vec (fs ! j) = dim_vec (fs ! i)\n  k < dim_vec (fs ! j)\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! i) $ k = rat_of_int (fs ! i $ k)", "by simp"], ["proof (state)\nthis:\n  ?k1 < dim_vec (fs ! j) \\<Longrightarrow>\n  of_int_hom.vec_hom (fs ! i) $ ?k1 = rat_of_int (fs ! i $ ?k1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "then"], ["proof (chain)\npicking this:\n  ?k1 < dim_vec (fs ! j) \\<Longrightarrow>\n  of_int_hom.vec_hom (fs ! i) $ ?k1 = rat_of_int (fs ! i $ ?k1)", "have *: \"of_int_hom.vec_hom (fs ! i) \\<bullet> of_int_hom.vec_hom (fs ! j) = rat_of_int (fs ! i \\<bullet> fs ! j)\""], ["proof (prove)\nusing this:\n  ?k1 < dim_vec (fs ! j) \\<Longrightarrow>\n  of_int_hom.vec_hom (fs ! i) $ ?k1 = rat_of_int (fs ! i $ ?k1)\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! i) \\<bullet> of_int_hom.vec_hom (fs ! j) =\n    rat_of_int (fs ! i \\<bullet> fs ! j)", "using 3"], ["proof (prove)\nusing this:\n  ?k1 < dim_vec (fs ! j) \\<Longrightarrow>\n  of_int_hom.vec_hom (fs ! i) $ ?k1 = rat_of_int (fs ! i $ ?k1)\n  \\<lbrakk>j \\<noteq> 0; j - 1 < length fs; j - 1 \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                    gs.\\<mu>' (j - 1) (j - 1)\n  \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                    gs.\\<sigma> (Suc (j - 1)) i j\n  i < length fs\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! i) \\<bullet> of_int_hom.vec_hom (fs ! j) =\n    rat_of_int (fs ! i \\<bullet> fs ! j)", "by (auto simp add: scalar_prod_def)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs ! i) \\<bullet> of_int_hom.vec_hom (fs ! j) =\n  rat_of_int (fs ! i \\<bullet> fs ! j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>j \\<noteq> 0; j - 1 < length fs;\n                 j - 1 \\<le> j - 1\\<rbrakk>\n                \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                                  gs.\\<mu>' (j - 1) (j - 1);\n        \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n        \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                          gs.\\<sigma> (Suc (j - 1)) i j;\n        i < length fs; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "proof (cases \"j = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n 2. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "case True"], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n 2. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "have \"dim_vec (fs ! 0) = dim_vec (fs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (fs ! 0) = dim_vec (fs ! i)", "using 3 f_carrier[of i] f_carrier[of 0] carrier_vec_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<noteq> 0; j - 1 < length fs; j - 1 \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                    gs.\\<mu>' (j - 1) (j - 1)\n  \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                    gs.\\<sigma> (Suc (j - 1)) i j\n  i < length fs\n  j \\<le> i\n  i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n\n  0 < length fs \\<Longrightarrow> fs ! 0 \\<in> carrier_vec n\n  carrier_vec ?n = {v. dim_vec v = ?n}\n\ngoal (1 subgoal):\n 1. dim_vec (fs ! 0) = dim_vec (fs ! i)", "by fastforce"], ["proof (state)\nthis:\n  dim_vec (fs ! 0) = dim_vec (fs ! i)\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n 2. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "then"], ["proof (chain)\npicking this:\n  dim_vec (fs ! 0) = dim_vec (fs ! i)", "have 1: \"of_int_hom.vec_hom (fs ! i) $ k = rat_of_int (fs ! i $ k)\" if \"k < dim_vec (fs ! 0)\" for k"], ["proof (prove)\nusing this:\n  dim_vec (fs ! 0) = dim_vec (fs ! i)\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! i) $ k = rat_of_int (fs ! i $ k)", "using that"], ["proof (prove)\nusing this:\n  dim_vec (fs ! 0) = dim_vec (fs ! i)\n  k < dim_vec (fs ! 0)\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! i) $ k = rat_of_int (fs ! i $ k)", "by simp"], ["proof (state)\nthis:\n  ?k1 < dim_vec (fs ! 0) \\<Longrightarrow>\n  of_int_hom.vec_hom (fs ! i) $ ?k1 = rat_of_int (fs ! i $ ?k1)\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n 2. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "have \"(\\<mu>' i j) = fs ! i \\<bullet> fs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>' i j = fs ! i \\<bullet> fs ! j", "using True"], ["proof (prove)\nusing this:\n  j = 0\n\ngoal (1 subgoal):\n 1. \\<mu>' i j = fs ! i \\<bullet> fs ! j", "by (simp add: \\<mu>'.simps)"], ["proof (state)\nthis:\n  \\<mu>' i j = fs ! i \\<bullet> fs ! j\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n 2. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "also"], ["proof (state)\nthis:\n  \\<mu>' i j = fs ! i \\<bullet> fs ! j\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n 2. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "note *[symmetric]"], ["proof (state)\nthis:\n  rat_of_int (fs ! i \\<bullet> fs ! j) =\n  of_int_hom.vec_hom (fs ! i) \\<bullet> of_int_hom.vec_hom (fs ! j)\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n 2. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "also"], ["proof (state)\nthis:\n  rat_of_int (fs ! i \\<bullet> fs ! j) =\n  of_int_hom.vec_hom (fs ! i) \\<bullet> of_int_hom.vec_hom (fs ! j)\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n 2. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "have  \"of_int_hom.vec_hom (fs ! j) = map of_int_hom.vec_hom fs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! j) = map of_int_hom.vec_hom fs ! j", "using 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<noteq> 0; j - 1 < length fs; j - 1 \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                    gs.\\<mu>' (j - 1) (j - 1)\n  \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                    gs.\\<sigma> (Suc (j - 1)) i j\n  i < length fs\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! j) = map of_int_hom.vec_hom fs ! j", "by auto"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs ! j) = map of_int_hom.vec_hom fs ! j\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n 2. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (\\<mu>' i j) =\n  of_int_hom.vec_hom (fs ! i) \\<bullet> map of_int_hom.vec_hom fs ! j", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_of_int (\\<mu>' i j) =\n  of_int_hom.vec_hom (fs ! i) \\<bullet> map of_int_hom.vec_hom fs ! j\n\ngoal (1 subgoal):\n 1. rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "using 3 True"], ["proof (prove)\nusing this:\n  rat_of_int (\\<mu>' i j) =\n  of_int_hom.vec_hom (fs ! i) \\<bullet> map of_int_hom.vec_hom fs ! j\n  \\<lbrakk>j \\<noteq> 0; j - 1 < length fs; j - 1 \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                    gs.\\<mu>' (j - 1) (j - 1)\n  \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                    gs.\\<sigma> (Suc (j - 1)) i j\n  i < length fs\n  j \\<le> i\n  j = 0\n\ngoal (1 subgoal):\n 1. rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "by (subst gs.\\<mu>'_via_\\<sigma>) (auto)"], ["proof (state)\nthis:\n  rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "case False"], ["proof (state)\nthis:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "then"], ["proof (chain)\npicking this:\n  j \\<noteq> 0", "have \"gs.\\<mu>' i j = gs.\\<mu>' (j - Suc 0) (j - Suc 0) * (rat_of_int (fs ! i \\<bullet> fs ! j)) - gs.\\<sigma> j i j\""], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gs.\\<mu>' i j =\n    gs.\\<mu>' (j - Suc 0) (j - Suc 0) *\n    rat_of_int (fs ! i \\<bullet> fs ! j) -\n    gs.\\<sigma> j i j", "using * False 3"], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n  of_int_hom.vec_hom (fs ! i) \\<bullet> of_int_hom.vec_hom (fs ! j) =\n  rat_of_int (fs ! i \\<bullet> fs ! j)\n  j \\<noteq> 0\n  \\<lbrakk>j \\<noteq> 0; j - 1 < length fs; j - 1 \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                    gs.\\<mu>' (j - 1) (j - 1)\n  \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                    gs.\\<sigma> (Suc (j - 1)) i j\n  i < length fs\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. gs.\\<mu>' i j =\n    gs.\\<mu>' (j - Suc 0) (j - Suc 0) *\n    rat_of_int (fs ! i \\<bullet> fs ! j) -\n    gs.\\<sigma> j i j", "by (subst gs.\\<mu>'_via_\\<sigma>) (auto)"], ["proof (state)\nthis:\n  gs.\\<mu>' i j =\n  gs.\\<mu>' (j - Suc 0) (j - Suc 0) * rat_of_int (fs ! i \\<bullet> fs ! j) -\n  gs.\\<sigma> j i j\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "then"], ["proof (chain)\npicking this:\n  gs.\\<mu>' i j =\n  gs.\\<mu>' (j - Suc 0) (j - Suc 0) * rat_of_int (fs ! i \\<bullet> fs ! j) -\n  gs.\\<sigma> j i j", "show ?thesis"], ["proof (prove)\nusing this:\n  gs.\\<mu>' i j =\n  gs.\\<mu>' (j - Suc 0) (j - Suc 0) * rat_of_int (fs ! i \\<bullet> fs ! j) -\n  gs.\\<sigma> j i j\n\ngoal (1 subgoal):\n 1. rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "using False 3"], ["proof (prove)\nusing this:\n  gs.\\<mu>' i j =\n  gs.\\<mu>' (j - Suc 0) (j - Suc 0) * rat_of_int (fs ! i \\<bullet> fs ! j) -\n  gs.\\<sigma> j i j\n  j \\<noteq> 0\n  \\<lbrakk>j \\<noteq> 0; j - 1 < length fs; j - 1 \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' (j - 1) (j - 1)) =\n                    gs.\\<mu>' (j - 1) (j - 1)\n  \\<lbrakk>j \\<noteq> 0; j - 1 < j; j \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s (j - 1) i j) =\n                    gs.\\<sigma> (Suc (j - 1)) i j\n  i < length fs\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "by (subst \\<mu>'.simps) (auto)"], ["proof (state)\nthis:\n  rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<mu>': assumes \"i < m\" \"j \\<le> i\"\n  shows \"\\<mu>' i j = d\\<mu> i j\"\n    \"j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>' i j = d\\<mu> i j &&&\n    (j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<mu>' i j = d\\<mu> i j\n 2. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "let ?r = rat_of_int"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<mu>' i j = d\\<mu> i j\n 2. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "from assms"], ["proof (chain)\npicking this:\n  i < length fs\n  j \\<le> i", "have \"j < m\""], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. j < length fs", "by auto"], ["proof (state)\nthis:\n  j < length fs\n\ngoal (2 subgoals):\n 1. \\<mu>' i j = d\\<mu> i j\n 2. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "note d\\<mu> = d\\<mu>[OF this assms(1)]"], ["proof (state)\nthis:\n  rat_of_int (d\\<mu> i j) = rat_of_int (d fs (Suc j)) * gs.\\<mu> i j\n\ngoal (2 subgoals):\n 1. \\<mu>' i j = d\\<mu> i j\n 2. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "have \"?r (\\<mu>' i j) = gs.\\<mu>' i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "using \\<sigma>s_\\<mu>' assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l < ?j; ?j \\<le> ?i; ?i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s ?l ?i ?j) =\n                    gs.\\<sigma> (Suc ?l) ?i ?j\n  \\<lbrakk>?i < length fs; ?j \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' ?i ?j) = gs.\\<mu>' ?i ?j\n  i < length fs\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j", "by auto"], ["proof (state)\nthis:\n  rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n\ngoal (2 subgoals):\n 1. \\<mu>' i j = d\\<mu> i j\n 2. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "also"], ["proof (state)\nthis:\n  rat_of_int (\\<mu>' i j) = gs.\\<mu>' i j\n\ngoal (2 subgoals):\n 1. \\<mu>' i j = d\\<mu> i j\n 2. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "have \"\\<dots> = ?r (d\\<mu> i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.\\<mu>' i j = rat_of_int (d\\<mu> i j)", "unfolding gs.\\<mu>'_def d\\<mu>"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.d (Suc j) * gs.\\<mu> i j = rat_of_int (d fs (Suc j)) * gs.\\<mu> i j", "by (subst of_int_Gramian_determinant, insert assms fs_carrier, auto simp: d_def subset_eq)"], ["proof (state)\nthis:\n  gs.\\<mu>' i j = rat_of_int (d\\<mu> i j)\n\ngoal (2 subgoals):\n 1. \\<mu>' i j = d\\<mu> i j\n 2. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (\\<mu>' i j) = rat_of_int (d\\<mu> i j)", "show 1: \"\\<mu>' i j = d\\<mu> i j\""], ["proof (prove)\nusing this:\n  rat_of_int (\\<mu>' i j) = rat_of_int (d\\<mu> i j)\n\ngoal (1 subgoal):\n 1. \\<mu>' i j = d\\<mu> i j", "by simp"], ["proof (state)\nthis:\n  \\<mu>' i j = d\\<mu> i j\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "assume j: \"j = i\""], ["proof (state)\nthis:\n  j = i\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "have \"?r (\\<mu>' i j) = ?r (d\\<mu> i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (\\<mu>' i j) = rat_of_int (d\\<mu> i j)", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d\\<mu> i j) = rat_of_int (d\\<mu> i j)", ".."], ["proof (state)\nthis:\n  rat_of_int (\\<mu>' i j) = rat_of_int (d\\<mu> i j)\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "also"], ["proof (state)\nthis:\n  rat_of_int (\\<mu>' i j) = rat_of_int (d\\<mu> i j)\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "have \"\\<dots> = ?r (d fs (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d\\<mu> i j) = rat_of_int (d fs (Suc i))", "unfolding d\\<mu>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * gs.\\<mu> i j = rat_of_int (d fs (Suc i))", "unfolding j"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc i)) * gs.\\<mu> i i = rat_of_int (d fs (Suc i))", "by (simp add: gs.\\<mu>.simps)"], ["proof (state)\nthis:\n  rat_of_int (d\\<mu> i j) = rat_of_int (d fs (Suc i))\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow> \\<mu>' i j = d fs (Suc i)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (\\<mu>' i j) = rat_of_int (d fs (Suc i))", "show \"\\<mu>' i j = d fs (Suc i)\""], ["proof (prove)\nusing this:\n  rat_of_int (\\<mu>' i j) = rat_of_int (d fs (Suc i))\n\ngoal (1 subgoal):\n 1. \\<mu>' i j = d fs (Suc i)", "by simp"], ["proof (state)\nthis:\n  \\<mu>' i j = d fs (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sigma_array: assumes mm: \"mm \\<le> m\" and j: \"j < mm\" \n  shows \"l \\<le> j \\<Longrightarrow> sigma_array (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i)) (Suc mm))\n\t     (IArray.of_fun (\\<mu>' mm) (Suc j)) (IArray.of_fun (\\<mu>' (Suc j)) (if Suc j = mm then Suc j else Suc (Suc j))) (\\<mu>' l l) l =\n\t    \\<sigma>s l mm (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> j \\<Longrightarrow>\n    sigma_array\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n       (Suc mm))\n     (IArray.of_fun (\\<mu>' mm) (Suc j))\n     (IArray.of_fun (\\<mu>' (Suc j))\n       (if Suc j = mm then Suc j else Suc (Suc j)))\n     (\\<mu>' l l) l =\n    \\<sigma>s l mm (Suc j)", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> j \\<Longrightarrow>\n    sigma_array\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n       (Suc mm))\n     (IArray.of_fun (\\<mu>' mm) (Suc j))\n     (IArray.of_fun (\\<mu>' (Suc j))\n       (if Suc j = mm then Suc j else Suc (Suc j)))\n     (\\<mu>' 0 0) 0 =\n    \\<sigma>s 0 mm (Suc j)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> j \\<Longrightarrow>\n                sigma_array\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm))\n                 (IArray.of_fun (\\<mu>' mm) (Suc j))\n                 (IArray.of_fun (\\<mu>' (Suc j))\n                   (if Suc j = mm then Suc j else Suc (Suc j)))\n                 (\\<mu>' l l) l =\n                \\<sigma>s l mm (Suc j);\n        Suc l \\<le> j\\<rbrakk>\n       \\<Longrightarrow> sigma_array\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          (IArray.of_fun (\\<mu>' mm) (Suc j))\n                          (IArray.of_fun (\\<mu>' (Suc j))\n                            (if Suc j = mm then Suc j else Suc (Suc j)))\n                          (\\<mu>' (Suc l) (Suc l)) (Suc l) =\n                         \\<sigma>s (Suc l) mm (Suc j)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> j\n\ngoal (2 subgoals):\n 1. 0 \\<le> j \\<Longrightarrow>\n    sigma_array\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n       (Suc mm))\n     (IArray.of_fun (\\<mu>' mm) (Suc j))\n     (IArray.of_fun (\\<mu>' (Suc j))\n       (if Suc j = mm then Suc j else Suc (Suc j)))\n     (\\<mu>' 0 0) 0 =\n    \\<sigma>s 0 mm (Suc j)\n 2. \\<And>l.\n       \\<lbrakk>l \\<le> j \\<Longrightarrow>\n                sigma_array\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm))\n                 (IArray.of_fun (\\<mu>' mm) (Suc j))\n                 (IArray.of_fun (\\<mu>' (Suc j))\n                   (if Suc j = mm then Suc j else Suc (Suc j)))\n                 (\\<mu>' l l) l =\n                \\<sigma>s l mm (Suc j);\n        Suc l \\<le> j\\<rbrakk>\n       \\<Longrightarrow> sigma_array\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          (IArray.of_fun (\\<mu>' mm) (Suc j))\n                          (IArray.of_fun (\\<mu>' (Suc j))\n                            (if Suc j = mm then Suc j else Suc (Suc j)))\n                          (\\<mu>' (Suc l) (Suc l)) (Suc l) =\n                         \\<sigma>s (Suc l) mm (Suc j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_array\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n       (Suc mm))\n     (IArray.of_fun (\\<mu>' mm) (Suc j))\n     (IArray.of_fun (\\<mu>' (Suc j))\n       (if Suc j = mm then Suc j else Suc (Suc j)))\n     (\\<mu>' 0 0) 0 =\n    \\<sigma>s 0 mm (Suc j)", "unfolding \\<sigma>s.simps sigma_array.simps[of _ _ _ _ 0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 = 0\n     then IArray.of_fun (\\<mu>' mm) (Suc j) !! 0 *\n          IArray.of_fun (\\<mu>' (Suc j))\n           (if Suc j = mm then Suc j else Suc (Suc j)) !!\n          0\n     else let l1 = 0 - 1;\n              dll1 =\n                IArray.of_fun\n                 (\\<lambda>i.\n                     IArray.of_fun (\\<mu>' i)\n                      (if i = mm then Suc j else Suc i))\n                 (Suc mm) !!\n                l1 !!\n                l1\n          in (\\<mu>' 0 0 *\n              sigma_array\n               (IArray.of_fun\n                 (\\<lambda>i.\n                     IArray.of_fun (\\<mu>' i)\n                      (if i = mm then Suc j else Suc i))\n                 (Suc mm))\n               (IArray.of_fun (\\<mu>' mm) (Suc j))\n               (IArray.of_fun (\\<mu>' (Suc j))\n                 (if Suc j = mm then Suc j else Suc (Suc j)))\n               dll1 l1 +\n              IArray.of_fun (\\<mu>' mm) (Suc j) !! 0 *\n              IArray.of_fun (\\<mu>' (Suc j))\n               (if Suc j = mm then Suc j else Suc (Suc j)) !!\n              0) div\n             dll1) =\n    \\<mu>' mm 0 * \\<mu>' (Suc j) 0", "using mm j"], ["proof (prove)\nusing this:\n  mm \\<le> length fs\n  j < mm\n\ngoal (1 subgoal):\n 1. (if 0 = 0\n     then IArray.of_fun (\\<mu>' mm) (Suc j) !! 0 *\n          IArray.of_fun (\\<mu>' (Suc j))\n           (if Suc j = mm then Suc j else Suc (Suc j)) !!\n          0\n     else let l1 = 0 - 1;\n              dll1 =\n                IArray.of_fun\n                 (\\<lambda>i.\n                     IArray.of_fun (\\<mu>' i)\n                      (if i = mm then Suc j else Suc i))\n                 (Suc mm) !!\n                l1 !!\n                l1\n          in (\\<mu>' 0 0 *\n              sigma_array\n               (IArray.of_fun\n                 (\\<lambda>i.\n                     IArray.of_fun (\\<mu>' i)\n                      (if i = mm then Suc j else Suc i))\n                 (Suc mm))\n               (IArray.of_fun (\\<mu>' mm) (Suc j))\n               (IArray.of_fun (\\<mu>' (Suc j))\n                 (if Suc j = mm then Suc j else Suc (Suc j)))\n               dll1 l1 +\n              IArray.of_fun (\\<mu>' mm) (Suc j) !! 0 *\n              IArray.of_fun (\\<mu>' (Suc j))\n               (if Suc j = mm then Suc j else Suc (Suc j)) !!\n              0) div\n             dll1) =\n    \\<mu>' mm 0 * \\<mu>' (Suc j) 0", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  sigma_array\n   (IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n     (Suc mm))\n   (IArray.of_fun (\\<mu>' mm) (Suc j))\n   (IArray.of_fun (\\<mu>' (Suc j))\n     (if Suc j = mm then Suc j else Suc (Suc j)))\n   (\\<mu>' 0 0) 0 =\n  \\<sigma>s 0 mm (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>l \\<le> j \\<Longrightarrow>\n                sigma_array\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm))\n                 (IArray.of_fun (\\<mu>' mm) (Suc j))\n                 (IArray.of_fun (\\<mu>' (Suc j))\n                   (if Suc j = mm then Suc j else Suc (Suc j)))\n                 (\\<mu>' l l) l =\n                \\<sigma>s l mm (Suc j);\n        Suc l \\<le> j\\<rbrakk>\n       \\<Longrightarrow> sigma_array\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          (IArray.of_fun (\\<mu>' mm) (Suc j))\n                          (IArray.of_fun (\\<mu>' (Suc j))\n                            (if Suc j = mm then Suc j else Suc (Suc j)))\n                          (\\<mu>' (Suc l) (Suc l)) (Suc l) =\n                         \\<sigma>s (Suc l) mm (Suc j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>l \\<le> j \\<Longrightarrow>\n                sigma_array\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm))\n                 (IArray.of_fun (\\<mu>' mm) (Suc j))\n                 (IArray.of_fun (\\<mu>' (Suc j))\n                   (if Suc j = mm then Suc j else Suc (Suc j)))\n                 (\\<mu>' l l) l =\n                \\<sigma>s l mm (Suc j);\n        Suc l \\<le> j\\<rbrakk>\n       \\<Longrightarrow> sigma_array\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          (IArray.of_fun (\\<mu>' mm) (Suc j))\n                          (IArray.of_fun (\\<mu>' (Suc j))\n                            (if Suc j = mm then Suc j else Suc (Suc j)))\n                          (\\<mu>' (Suc l) (Suc l)) (Suc l) =\n                         \\<sigma>s (Suc l) mm (Suc j)", "case (Suc l)"], ["proof (state)\nthis:\n  l \\<le> j \\<Longrightarrow>\n  sigma_array\n   (IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n     (Suc mm))\n   (IArray.of_fun (\\<mu>' mm) (Suc j))\n   (IArray.of_fun (\\<mu>' (Suc j))\n     (if Suc j = mm then Suc j else Suc (Suc j)))\n   (\\<mu>' l l) l =\n  \\<sigma>s l mm (Suc j)\n  Suc l \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>l \\<le> j \\<Longrightarrow>\n                sigma_array\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm))\n                 (IArray.of_fun (\\<mu>' mm) (Suc j))\n                 (IArray.of_fun (\\<mu>' (Suc j))\n                   (if Suc j = mm then Suc j else Suc (Suc j)))\n                 (\\<mu>' l l) l =\n                \\<sigma>s l mm (Suc j);\n        Suc l \\<le> j\\<rbrakk>\n       \\<Longrightarrow> sigma_array\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          (IArray.of_fun (\\<mu>' mm) (Suc j))\n                          (IArray.of_fun (\\<mu>' (Suc j))\n                            (if Suc j = mm then Suc j else Suc (Suc j)))\n                          (\\<mu>' (Suc l) (Suc l)) (Suc l) =\n                         \\<sigma>s (Suc l) mm (Suc j)", "hence l: \"l < j\" \"l \\<le> j\""], ["proof (prove)\nusing this:\n  l \\<le> j \\<Longrightarrow>\n  sigma_array\n   (IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n     (Suc mm))\n   (IArray.of_fun (\\<mu>' mm) (Suc j))\n   (IArray.of_fun (\\<mu>' (Suc j))\n     (if Suc j = mm then Suc j else Suc (Suc j)))\n   (\\<mu>' l l) l =\n  \\<sigma>s l mm (Suc j)\n  Suc l \\<le> j\n\ngoal (1 subgoal):\n 1. l < j &&& l \\<le> j", "by auto"], ["proof (state)\nthis:\n  l < j\n  l \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>l \\<le> j \\<Longrightarrow>\n                sigma_array\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm))\n                 (IArray.of_fun (\\<mu>' mm) (Suc j))\n                 (IArray.of_fun (\\<mu>' (Suc j))\n                   (if Suc j = mm then Suc j else Suc (Suc j)))\n                 (\\<mu>' l l) l =\n                \\<sigma>s l mm (Suc j);\n        Suc l \\<le> j\\<rbrakk>\n       \\<Longrightarrow> sigma_array\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          (IArray.of_fun (\\<mu>' mm) (Suc j))\n                          (IArray.of_fun (\\<mu>' (Suc j))\n                            (if Suc j = mm then Suc j else Suc (Suc j)))\n                          (\\<mu>' (Suc l) (Suc l)) (Suc l) =\n                         \\<sigma>s (Suc l) mm (Suc j)", "have id: \"(Suc l = 0) = False\" \"Suc l - 1 = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc l = 0) = False &&& Suc l - 1 = l", "by auto"], ["proof (state)\nthis:\n  (Suc l = 0) = False\n  Suc l - 1 = l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>l \\<le> j \\<Longrightarrow>\n                sigma_array\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm))\n                 (IArray.of_fun (\\<mu>' mm) (Suc j))\n                 (IArray.of_fun (\\<mu>' (Suc j))\n                   (if Suc j = mm then Suc j else Suc (Suc j)))\n                 (\\<mu>' l l) l =\n                \\<sigma>s l mm (Suc j);\n        Suc l \\<le> j\\<rbrakk>\n       \\<Longrightarrow> sigma_array\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          (IArray.of_fun (\\<mu>' mm) (Suc j))\n                          (IArray.of_fun (\\<mu>' (Suc j))\n                            (if Suc j = mm then Suc j else Suc (Suc j)))\n                          (\\<mu>' (Suc l) (Suc l)) (Suc l) =\n                         \\<sigma>s (Suc l) mm (Suc j)", "have ineq: \"Suc l < Suc mm\" \"l < Suc mm\" \n    \"Suc l < (if Suc l = mm then Suc j else Suc (Suc l))\" \n    \"Suc l < (if Suc j = mm then Suc j else Suc (Suc j))\" \n    \"l < (if l = mm then Suc j else Suc l)\" \n    \"Suc l < Suc j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc l < Suc mm &&&\n     l < Suc mm &&& Suc l < (if Suc l = mm then Suc j else Suc (Suc l))) &&&\n    Suc l < (if Suc j = mm then Suc j else Suc (Suc j)) &&&\n    l < (if l = mm then Suc j else Suc l) &&& Suc l < Suc j", "using mm l j"], ["proof (prove)\nusing this:\n  mm \\<le> length fs\n  l < j\n  l \\<le> j\n  j < mm\n\ngoal (1 subgoal):\n 1. (Suc l < Suc mm &&&\n     l < Suc mm &&& Suc l < (if Suc l = mm then Suc j else Suc (Suc l))) &&&\n    Suc l < (if Suc j = mm then Suc j else Suc (Suc j)) &&&\n    l < (if l = mm then Suc j else Suc l) &&& Suc l < Suc j", "by auto"], ["proof (state)\nthis:\n  Suc l < Suc mm\n  l < Suc mm\n  Suc l < (if Suc l = mm then Suc j else Suc (Suc l))\n  Suc l < (if Suc j = mm then Suc j else Suc (Suc j))\n  l < (if l = mm then Suc j else Suc l)\n  Suc l < Suc j\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>l \\<le> j \\<Longrightarrow>\n                sigma_array\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm))\n                 (IArray.of_fun (\\<mu>' mm) (Suc j))\n                 (IArray.of_fun (\\<mu>' (Suc j))\n                   (if Suc j = mm then Suc j else Suc (Suc j)))\n                 (\\<mu>' l l) l =\n                \\<sigma>s l mm (Suc j);\n        Suc l \\<le> j\\<rbrakk>\n       \\<Longrightarrow> sigma_array\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          (IArray.of_fun (\\<mu>' mm) (Suc j))\n                          (IArray.of_fun (\\<mu>' (Suc j))\n                            (if Suc j = mm then Suc j else Suc (Suc j)))\n                          (\\<mu>' (Suc l) (Suc l)) (Suc l) =\n                         \\<sigma>s (Suc l) mm (Suc j)", "note IH = Suc(1)[OF l(2)]"], ["proof (state)\nthis:\n  sigma_array\n   (IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n     (Suc mm))\n   (IArray.of_fun (\\<mu>' mm) (Suc j))\n   (IArray.of_fun (\\<mu>' (Suc j))\n     (if Suc j = mm then Suc j else Suc (Suc j)))\n   (\\<mu>' l l) l =\n  \\<sigma>s l mm (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>l \\<le> j \\<Longrightarrow>\n                sigma_array\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm))\n                 (IArray.of_fun (\\<mu>' mm) (Suc j))\n                 (IArray.of_fun (\\<mu>' (Suc j))\n                   (if Suc j = mm then Suc j else Suc (Suc j)))\n                 (\\<mu>' l l) l =\n                \\<sigma>s l mm (Suc j);\n        Suc l \\<le> j\\<rbrakk>\n       \\<Longrightarrow> sigma_array\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          (IArray.of_fun (\\<mu>' mm) (Suc j))\n                          (IArray.of_fun (\\<mu>' (Suc j))\n                            (if Suc j = mm then Suc j else Suc (Suc j)))\n                          (\\<mu>' (Suc l) (Suc l)) (Suc l) =\n                         \\<sigma>s (Suc l) mm (Suc j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_array\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n       (Suc mm))\n     (IArray.of_fun (\\<mu>' mm) (Suc j))\n     (IArray.of_fun (\\<mu>' (Suc j))\n       (if Suc j = mm then Suc j else Suc (Suc j)))\n     (\\<mu>' (Suc l) (Suc l)) (Suc l) =\n    \\<sigma>s (Suc l) mm (Suc j)", "unfolding sigma_array.simps[of _ _ _ _ \"Suc l\"] id if_False Let_def IH\n\t    of_fun_nth[OF ineq(1)] of_fun_nth[OF ineq(2)] of_fun_nth[OF ineq(3)] \n\t    of_fun_nth[OF ineq(4)] of_fun_nth[OF ineq(5)] of_fun_nth[OF ineq(6)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l mm (Suc j) +\n     \\<mu>' mm (Suc l) * \\<mu>' (Suc j) (Suc l)) div\n    \\<mu>' l l =\n    \\<sigma>s (Suc l) mm (Suc j)", "unfolding \\<sigma>s.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l mm (Suc j) +\n     \\<mu>' mm (Suc l) * \\<mu>' (Suc j) (Suc l)) div\n    \\<mu>' l l =\n    (\\<mu>' (Suc l) (Suc l) * \\<sigma>s l mm (Suc j) +\n     \\<mu>' mm (Suc l) * \\<mu>' (Suc j) (Suc l)) div\n    \\<mu>' l l", "by simp"], ["proof (state)\nthis:\n  sigma_array\n   (IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n     (Suc mm))\n   (IArray.of_fun (\\<mu>' mm) (Suc j))\n   (IArray.of_fun (\\<mu>' (Suc j))\n     (if Suc j = mm then Suc j else Suc (Suc j)))\n   (\\<mu>' (Suc l) (Suc l)) (Suc l) =\n  \\<sigma>s (Suc l) mm (Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dmu_array_row_main: assumes mm: \"mm \\<le> m\" shows\n  \"j \\<le> mm \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !!  mm) mm\n\t    (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i)) (Suc mm))    \n\t     j = IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> mm \\<Longrightarrow>\n    dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n       (Suc mm))\n     j =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)", "proof (induct \"mm - j\" arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>0 = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)\n 2. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = mm - j; j \\<le> mm\\<rbrakk>\n                   \\<Longrightarrow> dmu_array_row_main (IArray fs)\n(IArray fs !! mm) mm\n(IArray.of_fun\n  (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n  (Suc mm))\nj =\n                                     IArray.of_fun\n(\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm);\n        Suc x = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)", "case 0"], ["proof (state)\nthis:\n  0 = mm - j\n  j \\<le> mm\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>0 = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)\n 2. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = mm - j; j \\<le> mm\\<rbrakk>\n                   \\<Longrightarrow> dmu_array_row_main (IArray fs)\n(IArray fs !! mm) mm\n(IArray.of_fun\n  (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n  (Suc mm))\nj =\n                                     IArray.of_fun\n(\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm);\n        Suc x = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)", "thus ?case"], ["proof (prove)\nusing this:\n  0 = mm - j\n  j \\<le> mm\n\ngoal (1 subgoal):\n 1. dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n       (Suc mm))\n     j =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)", "unfolding dmu_array_row_main.simps[of _ _ _ _ j]"], ["proof (prove)\nusing this:\n  0 = mm - j\n  j \\<le> mm\n\ngoal (1 subgoal):\n 1. (if j = mm\n     then IArray.of_fun\n           (\\<lambda>i.\n               IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n           (Suc mm)\n     else let sj = Suc j;\n              dmus_i =\n                IArray.of_fun\n                 (\\<lambda>i.\n                     IArray.of_fun (\\<mu>' i)\n                      (if i = mm then Suc j else Suc i))\n                 (Suc mm) !!\n                mm;\n              djj =\n                IArray.of_fun\n                 (\\<lambda>i.\n                     IArray.of_fun (\\<mu>' i)\n                      (if i = mm then Suc j else Suc i))\n                 (Suc mm) !!\n                j !!\n                j;\n              dmu_ij =\n                djj * (IArray fs !! mm \\<bullet> IArray fs !! sj) -\n                sigma_array\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm))\n                 dmus_i\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm) !!\n                  sj)\n                 djj j;\n              dmus' =\n                iarray_update\n                 (IArray.of_fun\n                   (\\<lambda>i.\n                       IArray.of_fun (\\<mu>' i)\n                        (if i = mm then Suc j else Suc i))\n                   (Suc mm))\n                 mm (iarray_append dmus_i dmu_ij)\n          in dmu_array_row_main (IArray fs) (IArray fs !! mm) mm dmus' sj) =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)", "by simp"], ["proof (state)\nthis:\n  dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n   (IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n     (Suc mm))\n   j =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = mm - j; j \\<le> mm\\<rbrakk>\n                   \\<Longrightarrow> dmu_array_row_main (IArray fs)\n(IArray fs !! mm) mm\n(IArray.of_fun\n  (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n  (Suc mm))\nj =\n                                     IArray.of_fun\n(\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm);\n        Suc x = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = mm - j; j \\<le> mm\\<rbrakk>\n                   \\<Longrightarrow> dmu_array_row_main (IArray fs)\n(IArray fs !! mm) mm\n(IArray.of_fun\n  (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n  (Suc mm))\nj =\n                                     IArray.of_fun\n(\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm);\n        Suc x = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)", "case (Suc x j)"], ["proof (state)\nthis:\n  \\<lbrakk>x = mm - ?j1; ?j1 \\<le> mm\\<rbrakk>\n  \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                     (IArray.of_fun\n                       (\\<lambda>i.\n                           IArray.of_fun (\\<mu>' i)\n                            (if i = mm then Suc ?j1 else Suc i))\n                       (Suc mm))\n                     ?j1 =\n                    IArray.of_fun\n                     (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)\n  Suc x = mm - j\n  j \\<le> mm\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = mm - j; j \\<le> mm\\<rbrakk>\n                   \\<Longrightarrow> dmu_array_row_main (IArray fs)\n(IArray fs !! mm) mm\n(IArray.of_fun\n  (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n  (Suc mm))\nj =\n                                     IArray.of_fun\n(\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm);\n        Suc x = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)", "hence prems: \"x = mm - Suc j\" \"Suc j \\<le> mm\" and j: \"j < mm\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x = mm - ?j1; ?j1 \\<le> mm\\<rbrakk>\n  \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                     (IArray.of_fun\n                       (\\<lambda>i.\n                           IArray.of_fun (\\<mu>' i)\n                            (if i = mm then Suc ?j1 else Suc i))\n                       (Suc mm))\n                     ?j1 =\n                    IArray.of_fun\n                     (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)\n  Suc x = mm - j\n  j \\<le> mm\n\ngoal (1 subgoal):\n 1. (x = mm - Suc j &&& Suc j \\<le> mm) &&& j < mm", "by auto"], ["proof (state)\nthis:\n  x = mm - Suc j\n  Suc j \\<le> mm\n  j < mm\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = mm - j; j \\<le> mm\\<rbrakk>\n                   \\<Longrightarrow> dmu_array_row_main (IArray fs)\n(IArray fs !! mm) mm\n(IArray.of_fun\n  (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n  (Suc mm))\nj =\n                                     IArray.of_fun\n(\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm);\n        Suc x = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)", "note IH = Suc(1)[OF prems]"], ["proof (state)\nthis:\n  dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n   (IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun (\\<mu>' i) (if i = mm then Suc (Suc j) else Suc i))\n     (Suc mm))\n   (Suc j) =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = mm - j; j \\<le> mm\\<rbrakk>\n                   \\<Longrightarrow> dmu_array_row_main (IArray fs)\n(IArray fs !! mm) mm\n(IArray.of_fun\n  (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n  (Suc mm))\nj =\n                                     IArray.of_fun\n(\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm);\n        Suc x = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)", "have id: \"(j = mm) = False\" \"(mm = mm) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (j = mm) = False &&& (mm = mm) = True", "using Suc(2-)"], ["proof (prove)\nusing this:\n  Suc x = mm - j\n  j \\<le> mm\n\ngoal (1 subgoal):\n 1. (j = mm) = False &&& (mm = mm) = True", "by auto"], ["proof (state)\nthis:\n  (j = mm) = False\n  (mm = mm) = True\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = mm - j; j \\<le> mm\\<rbrakk>\n                   \\<Longrightarrow> dmu_array_row_main (IArray fs)\n(IArray fs !! mm) mm\n(IArray.of_fun\n  (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n  (Suc mm))\nj =\n                                     IArray.of_fun\n(\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm);\n        Suc x = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)", "have id2: \"IArray.of_fun (\\<mu>' mm) (Suc j) = IArray (map (\\<mu>' mm) [0..<Suc j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<mu>' mm) (Suc j) = IArray (map (\\<mu>' mm) [0..<Suc j])", "by simp"], ["proof (state)\nthis:\n  IArray.of_fun (\\<mu>' mm) (Suc j) = IArray (map (\\<mu>' mm) [0..<Suc j])\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = mm - j; j \\<le> mm\\<rbrakk>\n                   \\<Longrightarrow> dmu_array_row_main (IArray fs)\n(IArray fs !! mm) mm\n(IArray.of_fun\n  (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n  (Suc mm))\nj =\n                                     IArray.of_fun\n(\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm);\n        Suc x = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)", "have id3: \"IArray fs !! mm = fs ! mm\" \"IArray fs !! Suc j = fs ! Suc j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray fs !! mm = fs ! mm &&& IArray fs !! Suc j = fs ! Suc j", "by auto"], ["proof (state)\nthis:\n  IArray fs !! mm = fs ! mm\n  IArray fs !! Suc j = fs ! Suc j\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = mm - j; j \\<le> mm\\<rbrakk>\n                   \\<Longrightarrow> dmu_array_row_main (IArray fs)\n(IArray fs !! mm) mm\n(IArray.of_fun\n  (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n  (Suc mm))\nj =\n                                     IArray.of_fun\n(\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm);\n        Suc x = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)", "have le: \"j < Suc j\" \"Suc j < Suc mm\" \"mm < Suc mm\" \"j < Suc mm\" \n    \"j < (if j = mm then Suc j else Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (j < Suc j &&& Suc j < Suc mm) &&&\n    mm < Suc mm &&& j < Suc mm &&& j < (if j = mm then Suc j else Suc j)", "using j"], ["proof (prove)\nusing this:\n  j < mm\n\ngoal (1 subgoal):\n 1. (j < Suc j &&& Suc j < Suc mm) &&&\n    mm < Suc mm &&& j < Suc mm &&& j < (if j = mm then Suc j else Suc j)", "by auto"], ["proof (state)\nthis:\n  j < Suc j\n  Suc j < Suc mm\n  mm < Suc mm\n  j < Suc mm\n  j < (if j = mm then Suc j else Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = mm - j; j \\<le> mm\\<rbrakk>\n                   \\<Longrightarrow> dmu_array_row_main (IArray fs)\n(IArray fs !! mm) mm\n(IArray.of_fun\n  (\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n  (Suc mm))\nj =\n                                     IArray.of_fun\n(\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm);\n        Suc x = mm - j; j \\<le> mm\\<rbrakk>\n       \\<Longrightarrow> dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n                          (IArray.of_fun\n                            (\\<lambda>i.\n                                IArray.of_fun (\\<mu>' i)\n                                 (if i = mm then Suc j else Suc i))\n                            (Suc mm))\n                          j =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (Suc mm)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n       (Suc mm))\n     j =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)", "unfolding dmu_array_row_main.simps[of _ _ _ _ j] \n      IH[symmetric] Let_def id if_True if_False id3\n      of_fun_nth[OF le(1)] of_fun_nth[OF le(2)]\n      of_fun_nth[OF le(3)] of_fun_nth[OF le(4)]\n      of_fun_nth[OF le(5)]  \n      sigma_array[OF mm j le_refl, folded id2]\n      iarray_length_of_fun iarray_update_of_fun iarray_append_of_fun"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array_row_main (IArray fs) (fs ! mm) mm\n     (IArray.of_fun\n       ((\\<lambda>i.\n            IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n        (mm :=\n           IArray.of_fun\n            ((\\<mu>' mm)\n             (Suc j :=\n                \\<mu>' j j * (fs ! mm \\<bullet> fs ! Suc j) -\n                \\<sigma>s j mm (Suc j)))\n            (Suc (Suc j))))\n       (Suc mm))\n     (Suc j) =\n    dmu_array_row_main (IArray fs) (fs ! mm) mm\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun (\\<mu>' i) (if i = mm then Suc (Suc j) else Suc i))\n       (Suc mm))\n     (Suc j)", "proof (rule arg_cong[of _ _ \"\\<lambda> x. dmu_array_row_main _ _ _ x _\"], rule iarray_cong', goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc mm \\<Longrightarrow>\n       ((\\<lambda>i.\n            IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n        (mm :=\n           IArray.of_fun\n            ((\\<mu>' mm)\n             (Suc j :=\n                \\<mu>' j j * (fs ! mm \\<bullet> fs ! Suc j) -\n                \\<sigma>s j mm (Suc j)))\n            (Suc (Suc j))))\n        i =\n       IArray.of_fun (\\<mu>' i) (if i = mm then Suc (Suc j) else Suc i)", "case (1 i)"], ["proof (state)\nthis:\n  i < Suc mm\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc mm \\<Longrightarrow>\n       ((\\<lambda>i.\n            IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n        (mm :=\n           IArray.of_fun\n            ((\\<mu>' mm)\n             (Suc j :=\n                \\<mu>' j j * (fs ! mm \\<bullet> fs ! Suc j) -\n                \\<sigma>s j mm (Suc j)))\n            (Suc (Suc j))))\n        i =\n       IArray.of_fun (\\<mu>' i) (if i = mm then Suc (Suc j) else Suc i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i.\n         IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n     (mm :=\n        IArray.of_fun\n         ((\\<mu>' mm)\n          (Suc j :=\n             \\<mu>' j j * (fs ! mm \\<bullet> fs ! Suc j) -\n             \\<sigma>s j mm (Suc j)))\n         (Suc (Suc j))))\n     i =\n    IArray.of_fun (\\<mu>' i) (if i = mm then Suc (Suc j) else Suc i)", "unfolding of_fun_nth[OF 1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i.\n         IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n     (mm :=\n        IArray.of_fun\n         ((\\<mu>' mm)\n          (Suc j :=\n             \\<mu>' j j * (fs ! mm \\<bullet> fs ! Suc j) -\n             \\<sigma>s j mm (Suc j)))\n         (Suc (Suc j))))\n     i =\n    IArray.of_fun (\\<mu>' i) (if i = mm then Suc (Suc j) else Suc i)", "using j 1"], ["proof (prove)\nusing this:\n  j < mm\n  i < Suc mm\n\ngoal (1 subgoal):\n 1. ((\\<lambda>i.\n         IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n     (mm :=\n        IArray.of_fun\n         ((\\<mu>' mm)\n          (Suc j :=\n             \\<mu>' j j * (fs ! mm \\<bullet> fs ! Suc j) -\n             \\<sigma>s j mm (Suc j)))\n         (Suc (Suc j))))\n     i =\n    IArray.of_fun (\\<mu>' i) (if i = mm then Suc (Suc j) else Suc i)", "by (cases \"i = mm\", auto simp: \\<mu>'.simps[of _ \"Suc j\"])"], ["proof (state)\nthis:\n  ((\\<lambda>i. IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n   (mm :=\n      IArray.of_fun\n       ((\\<mu>' mm)\n        (Suc j :=\n           \\<mu>' j j * (fs ! mm \\<bullet> fs ! Suc j) -\n           \\<sigma>s j mm (Suc j)))\n       (Suc (Suc j))))\n   i =\n  IArray.of_fun (\\<mu>' i) (if i = mm then Suc (Suc j) else Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n   (IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun (\\<mu>' i) (if i = mm then Suc j else Suc i))\n     (Suc mm))\n   j =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dmu_array_row: assumes mm: \"mm \\<le> m\" shows\n  \"dmu_array_row (IArray fs) (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n\t    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array_row (IArray fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dmu_array_row (IArray fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)", "have 0: \"0 \\<le> mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> mm", "by auto"], ["proof (state)\nthis:\n  0 \\<le> mm\n\ngoal (1 subgoal):\n 1. dmu_array_row (IArray fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array_row (IArray fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)", "unfolding dmu_array_row_def Let_def dmu_array_row_main[OF assms 0, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n     (iarray_append\n       (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm)\n       (IArray [IArray fs !! mm \\<bullet> IArray fs !! 0]))\n     0 =\n    dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n     (IArray.of_fun\n       (\\<lambda>i.\n           IArray.of_fun (\\<mu>' i) (if i = mm then Suc 0 else Suc i))\n       (Suc mm))\n     0", "unfolding iarray_append.simps IArray.of_fun_def id map_append list.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n     (IArray\n       (map (\\<lambda>i. IArray (map (\\<mu>' i) [0..<Suc i])) [0..<mm] @\n        [IArray [IArray fs !! mm \\<bullet> IArray fs !! 0]]))\n     0 =\n    dmu_array_row_main (IArray fs) (IArray fs !! mm) mm\n     (IArray\n       (map (\\<lambda>i.\n                IArray\n                 (map (\\<mu>' i) [0..<if i = mm then Suc 0 else Suc i]))\n         [0..<Suc mm]))\n     0", "by (rule arg_cong[of _ _ \"\\<lambda> x. dmu_array_row_main _ _ _ (IArray x) _\"], rule nth_equalityI, \n\t      auto simp: nth_append \\<mu>'.simps[of _ 0])"], ["proof (state)\nthis:\n  dmu_array_row (IArray fs)\n   (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dmu_array: assumes \"mm \\<le> m\" \n  shows \"dmu_array (IArray fs) m (IArray.of_fun (\\<lambda> i. IArray.of_fun (\\<lambda> j. \\<mu>' i j) (Suc i)) mm) mm \n\t  = IArray.of_fun (\\<lambda> i. IArray.of_fun (\\<lambda> j. \\<mu>' i j) (Suc i)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "using assms"], ["proof (prove)\nusing this:\n  mm \\<le> length fs\n\ngoal (1 subgoal):\n 1. dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "proof (induct mm rule: wf_induct[OF wf_measure[of \"\\<lambda> mm. m - mm\"]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure ((-) (length fs)) \\<longrightarrow>\n                   y \\<le> length fs \\<longrightarrow>\n                   dmu_array (IArray fs) (length fs)\n                    (IArray.of_fun\n                      (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) y)\n                    y =\n                   IArray.of_fun\n                    (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                    (length fs);\n        x \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> dmu_array (IArray fs) (length fs)\n                          (IArray.of_fun\n                            (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                            x)\n                          x =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (length fs)", "case (1 mm)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, mm) \\<in> measure ((-) (length fs)) \\<longrightarrow>\n     y \\<le> length fs \\<longrightarrow>\n     dmu_array (IArray fs) (length fs)\n      (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) y) y =\n     IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n      (length fs)\n  mm \\<le> length fs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure ((-) (length fs)) \\<longrightarrow>\n                   y \\<le> length fs \\<longrightarrow>\n                   dmu_array (IArray fs) (length fs)\n                    (IArray.of_fun\n                      (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) y)\n                    y =\n                   IArray.of_fun\n                    (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                    (length fs);\n        x \\<le> length fs\\<rbrakk>\n       \\<Longrightarrow> dmu_array (IArray fs) (length fs)\n                          (IArray.of_fun\n                            (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                            x)\n                          x =\n                         IArray.of_fun\n                          (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i))\n                          (length fs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "proof (cases \"mm = m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mm = length fs \\<Longrightarrow>\n    dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)\n 2. mm \\<noteq> length fs \\<Longrightarrow>\n    dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "case True"], ["proof (state)\nthis:\n  mm = length fs\n\ngoal (2 subgoals):\n 1. mm = length fs \\<Longrightarrow>\n    dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)\n 2. mm \\<noteq> length fs \\<Longrightarrow>\n    dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mm = length fs\n\ngoal (1 subgoal):\n 1. dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "unfolding dmu_array.simps[of _ _ _ mm]"], ["proof (prove)\nusing this:\n  mm = length fs\n\ngoal (1 subgoal):\n 1. (if mm = length fs\n     then IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm\n     else let dmus' =\n                dmu_array_row (IArray fs)\n                 (IArray.of_fun\n                   (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm)\n                 mm\n          in dmu_array (IArray fs) (length fs) dmus' (Suc mm)) =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "by simp"], ["proof (state)\nthis:\n  dmu_array (IArray fs) (length fs)\n   (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)\n\ngoal (1 subgoal):\n 1. mm \\<noteq> length fs \\<Longrightarrow>\n    dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mm \\<noteq> length fs \\<Longrightarrow>\n    dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "case False"], ["proof (state)\nthis:\n  mm \\<noteq> length fs\n\ngoal (1 subgoal):\n 1. mm \\<noteq> length fs \\<Longrightarrow>\n    dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "with 1(2-)"], ["proof (chain)\npicking this:\n  mm \\<le> length fs\n  mm \\<noteq> length fs", "have mm: \"mm \\<le> m\" and id: \"(Suc mm = 0) = False\" \"Suc mm - 1 = mm\" \"(mm = m) = False\"\n      and prems: \"(Suc mm, mm) \\<in> measure ((-) m)\" \"Suc mm \\<le> m\""], ["proof (prove)\nusing this:\n  mm \\<le> length fs\n  mm \\<noteq> length fs\n\ngoal (1 subgoal):\n 1. mm \\<le> length fs &&&\n    ((Suc mm = 0) = False &&&\n     Suc mm - 1 = mm &&& (mm = length fs) = False) &&&\n    (Suc mm, mm) \\<in> measure ((-) (length fs)) &&& Suc mm \\<le> length fs", "by auto"], ["proof (state)\nthis:\n  mm \\<le> length fs\n  (Suc mm = 0) = False\n  Suc mm - 1 = mm\n  (mm = length fs) = False\n  (Suc mm, mm) \\<in> measure ((-) (length fs))\n  Suc mm \\<le> length fs\n\ngoal (1 subgoal):\n 1. mm \\<noteq> length fs \\<Longrightarrow>\n    dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "have list: \"[0..<Suc mm] = [0..< mm] @ [mm]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc mm] = [0..<mm] @ [mm]", "by auto"], ["proof (state)\nthis:\n  [0..<Suc mm] = [0..<mm] @ [mm]\n\ngoal (1 subgoal):\n 1. mm \\<noteq> length fs \\<Longrightarrow>\n    dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "note IH = 1(1)[rule_format, OF prems]"], ["proof (state)\nthis:\n  dmu_array (IArray fs) (length fs)\n   (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm))\n   (Suc mm) =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)\n\ngoal (1 subgoal):\n 1. mm \\<noteq> length fs \\<Longrightarrow>\n    dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "unfolding dmu_array.simps[of _ _ _ mm] id if_False Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array (IArray fs) (length fs)\n     (dmu_array_row (IArray fs)\n       (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm)\n     (Suc mm) =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)", "unfolding dmu_array_row[OF mm] IH[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm))\n     (Suc mm) =\n    dmu_array (IArray fs) (length fs)\n     (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (Suc mm))\n     (Suc mm)", "by (rule arg_cong[of _ _ \"\\<lambda> x. dmu_array _ _ x _\"], rule iarray_cong, auto)"], ["proof (state)\nthis:\n  dmu_array (IArray fs) (length fs)\n   (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dmu_array (IArray fs) (length fs)\n   (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) mm) mm =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d\\<mu>_impl: \"d\\<mu>_impl fs = IArray.of_fun (\\<lambda> i. IArray.of_fun (\\<lambda> j. d\\<mu> i j) (Suc i)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu>_impl fs =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> i) (Suc i)) (length fs)", "unfolding d\\<mu>_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_array (IArray fs) (length fs) (IArray []) 0 =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> i) (Suc i)) (length fs)", "using dmu_array[of 0]"], ["proof (prove)\nusing this:\n  0 \\<le> length fs \\<Longrightarrow>\n  dmu_array (IArray fs) (length fs)\n   (IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) 0) 0 =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (\\<mu>' i) (Suc i)) (length fs)\n\ngoal (1 subgoal):\n 1. dmu_array (IArray fs) (length fs) (IArray []) 0 =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> i) (Suc i)) (length fs)", "by (auto simp: \\<mu>')"], ["", "end"], ["", "(* fs_int_indpt *)"], ["", "context gram_schmidt_fs_int\nbegin"], ["", "lemma N_\\<mu>':\n  assumes \"i < m\" \"j \\<le> i\"\n  shows \"(\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "have 1: \"1 \\<le> N * N ^ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> N * N ^ j", "using assms N_1 one_le_power[of _ \"Suc j\"]"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  set fs \\<noteq> {} \\<Longrightarrow> (1::'a) \\<le> N\n  (1::?'a) \\<le> ?a \\<Longrightarrow> (1::?'a) \\<le> ?a ^ Suc j\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> N * N ^ j", "by fastforce"], ["proof (state)\nthis:\n  (1::'a) \\<le> N * N ^ j\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "have \"0 < d (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < d (Suc j)", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. (0::'a) < d (Suc j)", "by (intro Gramian_determinant) auto"], ["proof (state)\nthis:\n  (0::'a) < d (Suc j)\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "then"], ["proof (chain)\npicking this:\n  (0::'a) < d (Suc j)", "have [simp]: \"0 \\<le> d (Suc j)\""], ["proof (prove)\nusing this:\n  (0::'a) < d (Suc j)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> d (Suc j)", "by arith"], ["proof (state)\nthis:\n  (0::'a) \\<le> d (Suc j)\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "have N_d: \"d (Suc j) \\<le> N ^ (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc j) \\<le> N ^ Suc j", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. d (Suc j) \\<le> N ^ Suc j", "by (intro N_d) auto"], ["proof (state)\nthis:\n  d (Suc j) \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "have \"(\\<mu>' i j)\\<^sup>2 = (d (Suc j)) * (d (Suc j)) * (\\<mu> i j)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 = d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2", "unfolding \\<mu>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d (Suc j) * \\<mu> i j)\\<^sup>2 =\n    d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2", "by (auto simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (\\<mu>' i j)\\<^sup>2 = d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "also"], ["proof (state)\nthis:\n  (\\<mu>' i j)\\<^sup>2 = d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "have \"\\<dots> \\<le> (d (Suc j)) * (d (Suc j)) * N ^ (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n    \\<le> d (Suc j) * d (Suc j) * N ^ Suc j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n    \\<le> d (Suc j) * d (Suc j) * N ^ Suc j", "have \"(\\<mu> i j)\\<^sup>2 \\<le> N ^ (Suc j)\" if \"i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "using that 1"], ["proof (prove)\nusing this:\n  i = j\n  (1::'a) \\<le> N * N ^ j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "by (auto simp add: \\<mu>.simps)"], ["proof (state)\nthis:\n  i = j \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n    \\<le> d (Suc j) * d (Suc j) * N ^ Suc j", "moreover"], ["proof (state)\nthis:\n  i = j \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n    \\<le> d (Suc j) * d (Suc j) * N ^ Suc j", "have \"(\\<mu> i j)\\<^sup>2 \\<le> N ^ (Suc j)\" if \"i \\<noteq> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "using N_mu assms that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length fs; ?j \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> (\\<mu> ?i ?j)\\<^sup>2 \\<le> N ^ Suc ?j\n  i < length fs\n  j \\<le> i\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "by (auto)"], ["proof (state)\nthis:\n  i \\<noteq> j \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n    \\<le> d (Suc j) * d (Suc j) * N ^ Suc j", "ultimately"], ["proof (chain)\npicking this:\n  i = j \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n  i \\<noteq> j \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "have \"(\\<mu> i j)\\<^sup>2 \\<le> N ^ (Suc j)\""], ["proof (prove)\nusing this:\n  i = j \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n  i \\<noteq> j \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "by fastforce"], ["proof (state)\nthis:\n  (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n    \\<le> d (Suc j) * d (Suc j) * N ^ Suc j", "then"], ["proof (chain)\npicking this:\n  (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n    \\<le> d (Suc j) * d (Suc j) * N ^ Suc j", "by (intro mult_mono[of _ _ \"(\\<mu> i j)\\<^sup>2\"]) (auto)"], ["proof (state)\nthis:\n  d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n  \\<le> d (Suc j) * d (Suc j) * N ^ Suc j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n  \\<le> d (Suc j) * d (Suc j) * N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "also"], ["proof (state)\nthis:\n  d (Suc j) * d (Suc j) * (\\<mu> i j)\\<^sup>2\n  \\<le> d (Suc j) * d (Suc j) * N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "have \"\\<dots> \\<le> N ^ (Suc j) * N ^ (Suc j) * N ^ (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc j) * d (Suc j) * N ^ Suc j\n    \\<le> N ^ Suc j * N ^ Suc j * N ^ Suc j", "using assms 1 N_d"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  (1::'a) \\<le> N * N ^ j\n  d (Suc j) \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. d (Suc j) * d (Suc j) * N ^ Suc j\n    \\<le> N ^ Suc j * N ^ Suc j * N ^ Suc j", "by (auto intro!: mult_mono)"], ["proof (state)\nthis:\n  d (Suc j) * d (Suc j) * N ^ Suc j \\<le> N ^ Suc j * N ^ Suc j * N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "also"], ["proof (state)\nthis:\n  d (Suc j) * d (Suc j) * N ^ Suc j \\<le> N ^ Suc j * N ^ Suc j * N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "have \"N ^ (Suc j) * N ^ (Suc j) * N ^ (Suc j) = N ^ (3 * (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N ^ Suc j * N ^ Suc j * N ^ Suc j = N ^ (3 * Suc j)", "using nat_pow_distrib nat_pow_pow power3_eq_cube"], ["proof (prove)\nusing this:\n  (?x * ?y) ^ ?n = ?x ^ ?n * ?y ^ ?n\n  (?x ^ ?n) ^ ?m = ?x ^ (?n * ?m)\n  ?a ^ 3 = ?a * ?a * ?a\n\ngoal (1 subgoal):\n 1. N ^ Suc j * N ^ Suc j * N ^ Suc j = N ^ (3 * Suc j)", "by metis"], ["proof (state)\nthis:\n  N ^ Suc j * N ^ Suc j * N ^ Suc j = N ^ (3 * Suc j)\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "finally"], ["proof (chain)\npicking this:\n  (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "by simp"], ["proof (state)\nthis:\n  (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma N_\\<sigma>:\n  assumes \"i < m\" \"j \\<le> i\" \"l \\<le> j\"\n  shows \"\\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "have 1: \"\\<bar>d l\\<bar> = d l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>d l\\<bar> = d l", "using Gramian_determinant(2) assms"], ["proof (prove)\nusing this:\n  ?k \\<le> length fs \\<Longrightarrow> (0::'a) < d ?k\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n\ngoal (1 subgoal):\n 1. \\<bar>d l\\<bar> = d l", "by (intro abs_of_pos) auto"], ["proof (state)\nthis:\n  \\<bar>d l\\<bar> = d l\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "then"], ["proof (chain)\npicking this:\n  \\<bar>d l\\<bar> = d l", "have \"\\<bar>\\<sigma> l i j\\<bar> = d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\""], ["proof (prove)\nusing this:\n  \\<bar>d l\\<bar> = d l\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> =\n    d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>", "using assms"], ["proof (prove)\nusing this:\n  \\<bar>d l\\<bar> = d l\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> =\n    d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>", "by (subst \\<sigma>, fastforce, subst abs_mult) auto"], ["proof (state)\nthis:\n  \\<bar>\\<sigma> l i j\\<bar> =\n  d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "also"], ["proof (state)\nthis:\n  \\<bar>\\<sigma> l i j\\<bar> =\n  d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "have \"\\<dots> \\<le> N ^ l * (of_nat l * N ^ (l + 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> N ^ l * (of_nat l * N ^ (l + 2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> N ^ l * (of_nat l * N ^ (l + 2))", "have \"\\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar> \\<le> of_nat l * N ^ (l + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "have [simp]: \"0 \\<le> \\<beta> fs k\" \"\\<parallel>gso k\\<parallel>\\<^sup>2 \\<le> N\" if \"k < l\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<beta> fs k &&&\n    \\<parallel>gso k\\<parallel>\\<^sup>2 \\<le> N", "using that assms N_gso \\<beta>_pos[of k]"], ["proof (prove)\nusing this:\n  k < l\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n  ?i < length fs \\<Longrightarrow>\n  \\<parallel>gso ?i\\<parallel>\\<^sup>2 \\<le> N\n  k < length fs \\<Longrightarrow> (0::'a) < \\<beta> fs k\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<beta> fs k &&&\n    \\<parallel>gso k\\<parallel>\\<^sup>2 \\<le> N", "by auto"], ["proof (state)\nthis:\n  ?k1 < l \\<Longrightarrow> (0::'a) \\<le> \\<beta> fs ?k1\n  ?k1 < l \\<Longrightarrow> \\<parallel>gso ?k1\\<parallel>\\<^sup>2 \\<le> N\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "have [simp]: \"0 \\<le> N * N ^ k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> N * N ^ k", "using N_ge_0 assms"], ["proof (prove)\nusing this:\n  0 < length fs \\<Longrightarrow> (0::'a) \\<le> N\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> N * N ^ k", "by fastforce"], ["proof (state)\nthis:\n  (0::'a) \\<le> N * N ^ ?k1\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "have \"\\<bar>(\\<Sum>k < l. \\<mu> i k * \\<mu> j k * \\<beta> fs k)\\<bar> \\<le> (\\<Sum>k < l. \\<bar>\\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>)", "using sum_abs"], ["proof (prove)\nusing this:\n  \\<bar>sum ?f ?A\\<bar> \\<le> (\\<Sum>i\\<in>?A. \\<bar>?f i\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>)", "by blast"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "also"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "have \"\\<dots> = (\\<Sum>k < l. \\<bar>\\<mu> i k * \\<mu> j k\\<bar> * \\<beta> fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>) =\n    (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k\\<bar> * \\<beta> fs k)", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>) =\n    (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k\\<bar> * \\<beta> fs k)", "by (auto intro!: sum.cong simp add: gso_norm_beta abs_mult_pos sq_norm_vec_ge_0)"], ["proof (state)\nthis:\n  (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>) =\n  (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k\\<bar> * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>) =\n  (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k\\<bar> * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "have \"\\<dots> = (\\<Sum>k < l. \\<bar>\\<mu> i k\\<bar> * \\<bar>\\<mu> j k\\<bar> * \\<beta> fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k\\<bar> * \\<beta> fs k) =\n    (\\<Sum>k<l.\n        \\<bar>\\<mu> i k\\<bar> * \\<bar>\\<mu> j k\\<bar> * \\<beta> fs k)", "using abs_mult"], ["proof (prove)\nusing this:\n  \\<bar>?a * ?b\\<bar> = \\<bar>?a\\<bar> * \\<bar>?b\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k\\<bar> * \\<beta> fs k) =\n    (\\<Sum>k<l.\n        \\<bar>\\<mu> i k\\<bar> * \\<bar>\\<mu> j k\\<bar> * \\<beta> fs k)", "by (fastforce intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k\\<bar> * \\<beta> fs k) =\n  (\\<Sum>k<l. \\<bar>\\<mu> i k\\<bar> * \\<bar>\\<mu> j k\\<bar> * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<l. \\<bar>\\<mu> i k * \\<mu> j k\\<bar> * \\<beta> fs k) =\n  (\\<Sum>k<l. \\<bar>\\<mu> i k\\<bar> * \\<bar>\\<mu> j k\\<bar> * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "have \"\\<dots> \\<le> (\\<Sum>k < l. (max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar>) * (max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar>) * \\<beta> fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<l.\n        \\<bar>\\<mu> i k\\<bar> * \\<bar>\\<mu> j k\\<bar> * \\<beta> fs k)\n    \\<le> (\\<Sum>k<l.\n              max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n              max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n              \\<beta> fs k)", "by (auto intro!: sum_mono mult_mono)"], ["proof (state)\nthis:\n  (\\<Sum>k<l. \\<bar>\\<mu> i k\\<bar> * \\<bar>\\<mu> j k\\<bar> * \\<beta> fs k)\n  \\<le> (\\<Sum>k<l.\n            max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n            max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n            \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<l. \\<bar>\\<mu> i k\\<bar> * \\<bar>\\<mu> j k\\<bar> * \\<beta> fs k)\n  \\<le> (\\<Sum>k<l.\n            max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n            max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n            \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "have \"\\<dots> = (\\<Sum>k < l. (max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar>)\\<^sup>2 * \\<beta> fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<l.\n        max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n        max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n        \\<beta> fs k) =\n    (\\<Sum>k<l.\n        (max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar>)\\<^sup>2 *\n        \\<beta> fs k)", "by (auto simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (\\<Sum>k<l.\n      max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n      max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n      \\<beta> fs k) =\n  (\\<Sum>k<l.\n      (max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar>)\\<^sup>2 *\n      \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<l.\n      max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n      max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar> *\n      \\<beta> fs k) =\n  (\\<Sum>k<l.\n      (max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar>)\\<^sup>2 *\n      \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "have \"\\<dots> \\<le> (\\<Sum>k < l. N ^ (Suc k) * \\<beta> fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<l.\n        (max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar>)\\<^sup>2 *\n        \\<beta> fs k)\n    \\<le> (\\<Sum>k<l. N ^ Suc k * \\<beta> fs k)", "using assms N_mu[of i] N_mu[of j] assms"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n  \\<lbrakk>i < length fs; ?j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> (\\<mu> i ?j)\\<^sup>2 \\<le> N ^ Suc ?j\n  \\<lbrakk>j < length fs; ?j \\<le> j\\<rbrakk>\n  \\<Longrightarrow> (\\<mu> j ?j)\\<^sup>2 \\<le> N ^ Suc ?j\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<l.\n        (max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar>)\\<^sup>2 *\n        \\<beta> fs k)\n    \\<le> (\\<Sum>k<l. N ^ Suc k * \\<beta> fs k)", "by (auto intro!: sum_mono mult_right_mono simp add: max_def)"], ["proof (state)\nthis:\n  (\\<Sum>k<l.\n      (max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar>)\\<^sup>2 *\n      \\<beta> fs k)\n  \\<le> (\\<Sum>k<l. N ^ Suc k * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<l.\n      (max \\<bar>\\<mu> i k\\<bar> \\<bar>\\<mu> j k\\<bar>)\\<^sup>2 *\n      \\<beta> fs k)\n  \\<le> (\\<Sum>k<l. N ^ Suc k * \\<beta> fs k)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "have \"\\<dots> \\<le> (\\<Sum>k < l. N ^ (Suc k) * N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<l. N ^ Suc k * \\<beta> fs k) \\<le> (\\<Sum>k<l. N ^ Suc k * N)", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<l. N ^ Suc k * \\<beta> fs k) \\<le> (\\<Sum>k<l. N ^ Suc k * N)", "by (auto simp add: gso_norm_beta intro!: sum_mono mult_left_mono)"], ["proof (state)\nthis:\n  (\\<Sum>k<l. N ^ Suc k * \\<beta> fs k) \\<le> (\\<Sum>k<l. N ^ Suc k * N)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<l. N ^ Suc k * \\<beta> fs k) \\<le> (\\<Sum>k<l. N ^ Suc k * N)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "have \"\\<dots> \\<le> (\\<Sum>k < l. N ^ (Suc l) * N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<l. N ^ Suc k * N) \\<le> (\\<Sum>k<l. N ^ Suc l * N)", "using assms N_1 N_ge_0 assms"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n  set fs \\<noteq> {} \\<Longrightarrow> (1::'a) \\<le> N\n  0 < length fs \\<Longrightarrow> (0::'a) \\<le> N\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<l. N ^ Suc k * N) \\<le> (\\<Sum>k<l. N ^ Suc l * N)", "by (fastforce intro!: sum_mono mult_right_mono power_increasing)"], ["proof (state)\nthis:\n  (\\<Sum>k<l. N ^ Suc k * N) \\<le> (\\<Sum>k<l. N ^ Suc l * N)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<l. N ^ Suc k * N) \\<le> (\\<Sum>k<l. N ^ Suc l * N)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "have \"\\<dots> = of_nat l * N ^ (l + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<l. N ^ Suc l * N) = of_nat l * N ^ (l + 2)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k<l. N ^ Suc l * N) = of_nat l * N ^ (l + 2)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> of_nat l * N ^ (l + 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> of_nat l * N ^ (l + 2)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> of_nat l * N ^ (l + 2)", "by auto"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> of_nat l * N ^ (l + 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> of_nat l * N ^ (l + 2)\n\ngoal (1 subgoal):\n 1. d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> N ^ l * (of_nat l * N ^ (l + 2))", "then"], ["proof (chain)\npicking this:\n  \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> of_nat l * N ^ (l + 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> of_nat l * N ^ (l + 2)\n\ngoal (1 subgoal):\n 1. d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> N ^ l * (of_nat l * N ^ (l + 2))", "using assms N_d N_ge_0"], ["proof (prove)\nusing this:\n  \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> of_nat l * N ^ (l + 2)\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n  ?i \\<le> length fs \\<Longrightarrow> d ?i \\<le> N ^ ?i\n  0 < length fs \\<Longrightarrow> (0::'a) \\<le> N\n\ngoal (1 subgoal):\n 1. d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n    \\<le> N ^ l * (of_nat l * N ^ (l + 2))", "by (fastforce intro!: mult_mono zero_le_power)"], ["proof (state)\nthis:\n  d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> N ^ l * (of_nat l * N ^ (l + 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> N ^ l * (of_nat l * N ^ (l + 2))\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "also"], ["proof (state)\nthis:\n  d l * \\<bar>\\<Sum>k<l. \\<mu> i k * \\<mu> j k * \\<beta> fs k\\<bar>\n  \\<le> N ^ l * (of_nat l * N ^ (l + 2))\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "have \"\\<dots> = of_nat l * N ^ (2 * l + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N ^ l * (of_nat l * N ^ (l + 2)) = of_nat l * N ^ (2 * l + 2)", "by (auto simp add: field_simps mult_2_right simp flip: power_add)"], ["proof (state)\nthis:\n  N ^ l * (of_nat l * N ^ (l + 2)) = of_nat l * N ^ (2 * l + 2)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "by simp"], ["proof (state)\nthis:\n  \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leq_squared: \"(z::int) \\<le> z\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> z\\<^sup>2", "proof (cases \"0 < z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < z \\<Longrightarrow> z \\<le> z\\<^sup>2\n 2. \\<not> 0 < z \\<Longrightarrow> z \\<le> z\\<^sup>2", "case True"], ["proof (state)\nthis:\n  0 < z\n\ngoal (2 subgoals):\n 1. 0 < z \\<Longrightarrow> z \\<le> z\\<^sup>2\n 2. \\<not> 0 < z \\<Longrightarrow> z \\<le> z\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  0 < z", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < z\n\ngoal (1 subgoal):\n 1. z \\<le> z\\<^sup>2", "by (auto intro!: self_le_power)"], ["proof (state)\nthis:\n  z \\<le> z\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> 0 < z \\<Longrightarrow> z \\<le> z\\<^sup>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < z \\<Longrightarrow> z \\<le> z\\<^sup>2", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < z\n\ngoal (1 subgoal):\n 1. \\<not> 0 < z \\<Longrightarrow> z \\<le> z\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < z", "have \"z \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < z\n\ngoal (1 subgoal):\n 1. z \\<le> 0", "by (simp)"], ["proof (state)\nthis:\n  z \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < z \\<Longrightarrow> z \\<le> z\\<^sup>2", "also"], ["proof (state)\nthis:\n  z \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < z \\<Longrightarrow> z \\<le> z\\<^sup>2", "have \"0 \\<le> z\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> z\\<^sup>2", "by (auto)"], ["proof (state)\nthis:\n  0 \\<le> z\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> 0 < z \\<Longrightarrow> z \\<le> z\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  z \\<le> z\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<le> z\\<^sup>2\n\ngoal (1 subgoal):\n 1. z \\<le> z\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  z \\<le> z\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_leq_squared: \"\\<bar>z::int\\<bar> \\<le> z\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>z\\<bar> \\<le> z\\<^sup>2", "using leq_squared[of \"\\<bar>z\\<bar>\"]"], ["proof (prove)\nusing this:\n  \\<bar>z\\<bar> \\<le> \\<bar>z\\<bar>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>z\\<bar> \\<le> z\\<^sup>2", "by auto"], ["", "end"], ["", "(* gram_schmidt_fs_int *)"], ["", "context gram_schmidt_fs_int\nbegin"], ["", "definition gso' where \"gso' i = d i \\<cdot>\\<^sub>v (gso i)\""], ["", "fun a where\n  \"a i 0 = fs ! i\" |\n  \"a i (Suc l) = (1 / d l) \\<cdot>\\<^sub>v ((d (Suc l) \\<cdot>\\<^sub>v (a i l)) - ( \\<mu>' i l) \\<cdot>\\<^sub>v gso' l)\""], ["", "lemma gso'_carrier_vec: \n  assumes \"i < m\"\n  shows \"gso' i \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso' i \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. gso' i \\<in> carrier_vec n", "by (auto simp add: gso'_def)"], ["", "lemma a_carrier_vec: \n  assumes \"l \\<le> i\" \"i < m\"\n  shows \"a i l \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a i l \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. a i l \\<in> carrier_vec n", "by (induction l arbitrary: i) (auto simp add: gso'_def)"], ["", "lemma a_l: \n  assumes \"l \\<le> i\" \"i < m\"\n  shows \"a i l = d l \\<cdot>\\<^sub>v (fs ! i + M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a i l =\n    d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. a i l =\n    d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))", "proof (induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> i; i < length fs\\<rbrakk>\n    \\<Longrightarrow> a i 0 =\n                      d 0 \\<cdot>\\<^sub>v\n                      (fs ! i +\n                       M.sumlist\n                        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                          [0..<0]))\n 2. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> i\n  i < length fs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> i; i < length fs\\<rbrakk>\n    \\<Longrightarrow> a i 0 =\n                      d 0 \\<cdot>\\<^sub>v\n                      (fs ! i +\n                       M.sumlist\n                        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                          [0..<0]))\n 2. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> i\n  i < length fs", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. a i 0 =\n    d 0 \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<0]))", "by auto"], ["proof (state)\nthis:\n  a i 0 =\n  d 0 \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<0]))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "case (Suc l)"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> a i l =\n                    d l \\<cdot>\\<^sub>v\n                    (fs ! i +\n                     M.sumlist\n                      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                        [0..<l]))\n  Suc l \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have fsi: \"fs ! i \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n", "using f_carrier[of i] assms"], ["proof (prove)\nusing this:\n  i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n\n  l \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  fs ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have l_i_m: \"l \\<le> i \\<Longrightarrow> l < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> i \\<Longrightarrow> l < length fs", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. l \\<le> i \\<Longrightarrow> l < length fs", "by auto"], ["proof (state)\nthis:\n  l \\<le> i \\<Longrightarrow> l < length fs\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "let ?a = \"fs ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "let ?sum = \"M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "let ?term = \"(- \\<mu> i l \\<cdot>\\<^sub>v gso l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have carr: \"{?a,?sum,?term} \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {fs ! i,\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]),\n     - \\<mu> i l \\<cdot>\\<^sub>v gso l}\n    \\<subseteq> carrier_vec n", "using gso_dim l_i_m Suc(2) sumlist_dim assms"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> dim_vec (gso ?i) = n\n  l \\<le> i \\<Longrightarrow> l < length fs\n  Suc l \\<le> i\n  (\\<And>x.\n      x \\<in> set ?xs \\<Longrightarrow>\n      x \\<in> carrier_vec n) \\<Longrightarrow>\n  dim_vec (M.sumlist ?xs) = n\n  l \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. {fs ! i,\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]),\n     - \\<mu> i l \\<cdot>\\<^sub>v gso l}\n    \\<subseteq> carrier_vec n", "by (auto intro!: sumlist_carrier)"], ["proof (state)\nthis:\n  {fs ! i,\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]),\n   - \\<mu> i l \\<cdot>\\<^sub>v gso l}\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"a i (Suc l) = \n        (1 / d l) \\<cdot>\\<^sub>v ((d (Suc l) \\<cdot>\\<^sub>v (d l \\<cdot>\\<^sub>v (fs ! i + M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))))\n        - ( \\<mu>' i l) \\<cdot>\\<^sub>v gso' l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a i (Suc l) =\n    (1::'a) / d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (d l \\<cdot>\\<^sub>v\n      (fs ! i +\n       M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) -\n     \\<mu>' i l \\<cdot>\\<^sub>v gso' l)", "using a.simps Suc"], ["proof (prove)\nusing this:\n  a ?i 0 = fs ! ?i\n  a ?i (Suc ?l) =\n  (1::'a) / d ?l \\<cdot>\\<^sub>v\n  (d (Suc ?l) \\<cdot>\\<^sub>v a ?i ?l -\n   \\<mu>' ?i ?l \\<cdot>\\<^sub>v gso' ?l)\n  \\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> a i l =\n                    d l \\<cdot>\\<^sub>v\n                    (fs ! i +\n                     M.sumlist\n                      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                        [0..<l]))\n  Suc l \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. a i (Suc l) =\n    (1::'a) / d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (d l \\<cdot>\\<^sub>v\n      (fs ! i +\n       M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) -\n     \\<mu>' i l \\<cdot>\\<^sub>v gso' l)", "by auto"], ["proof (state)\nthis:\n  a i (Suc l) =\n  (1::'a) / d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) -\n   \\<mu>' i l \\<cdot>\\<^sub>v gso' l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  a i (Suc l) =\n  (1::'a) / d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) -\n   \\<mu>' i l \\<cdot>\\<^sub>v gso' l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"\\<dots> = (1 / d l) \\<cdot>\\<^sub>v ((d (Suc l) \\<cdot>\\<^sub>v (d l \\<cdot>\\<^sub>v (fs ! i + M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))))\n        + -d (Suc l) * \\<mu> i l * d l \\<cdot>\\<^sub>v gso l )\"  (is \"_ = _ \\<cdot>\\<^sub>v (?t1 + ?t2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (d l \\<cdot>\\<^sub>v\n      (fs ! i +\n       M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) -\n     \\<mu>' i l \\<cdot>\\<^sub>v gso' l) =\n    (1::'a) / d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (d l \\<cdot>\\<^sub>v\n      (fs ! i +\n       M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) +\n     - d (Suc l) * \\<mu> i l * d l \\<cdot>\\<^sub>v gso l)", "unfolding \\<mu>'_def gso'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (d l \\<cdot>\\<^sub>v\n      (fs ! i +\n       M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) -\n     d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v (d l \\<cdot>\\<^sub>v gso l)) =\n    (1::'a) / d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (d l \\<cdot>\\<^sub>v\n      (fs ! i +\n       M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) +\n     - d (Suc l) * \\<mu> i l * d l \\<cdot>\\<^sub>v gso l)", "by auto"], ["proof (state)\nthis:\n  (1::'a) / d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) -\n   \\<mu>' i l \\<cdot>\\<^sub>v gso' l) =\n  (1::'a) / d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) +\n   - d (Suc l) * \\<mu> i l * d l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  (1::'a) / d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) -\n   \\<mu>' i l \\<cdot>\\<^sub>v gso' l) =\n  (1::'a) / d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) +\n   - d (Suc l) * \\<mu> i l * d l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"?t2 = d l \\<cdot>\\<^sub>v (-d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l )\" (is \"_ = d l \\<cdot>\\<^sub>v ?tt2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. - d (Suc l) * \\<mu> i l * d l \\<cdot>\\<^sub>v gso l =\n    d l \\<cdot>\\<^sub>v (- d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)", "using smult_smult_assoc"], ["proof (prove)\nusing this:\n  ?a \\<cdot>\\<^sub>v (?b \\<cdot>\\<^sub>v ?v) = ?a * ?b \\<cdot>\\<^sub>v ?v\n\ngoal (1 subgoal):\n 1. - d (Suc l) * \\<mu> i l * d l \\<cdot>\\<^sub>v gso l =\n    d l \\<cdot>\\<^sub>v (- d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)", "by (auto)"], ["proof (state)\nthis:\n  - d (Suc l) * \\<mu> i l * d l \\<cdot>\\<^sub>v gso l =\n  d l \\<cdot>\\<^sub>v (- d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  - d (Suc l) * \\<mu> i l * d l \\<cdot>\\<^sub>v gso l =\n  d l \\<cdot>\\<^sub>v (- d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"?t1 = d l \\<cdot>\\<^sub>v ((d (Suc l) \\<cdot>\\<^sub>v (fs ! i + M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))))\" (is \"_ = d l \\<cdot>\\<^sub>v ?tt1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc l) \\<cdot>\\<^sub>v\n    (d l \\<cdot>\\<^sub>v\n     (fs ! i +\n      M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) =\n    d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (fs ! i +\n      M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])))", "using smult_smult_assoc smult_smult_assoc[symmetric]"], ["proof (prove)\nusing this:\n  ?a \\<cdot>\\<^sub>v (?b \\<cdot>\\<^sub>v ?v) = ?a * ?b \\<cdot>\\<^sub>v ?v\n  ?a * ?b \\<cdot>\\<^sub>v ?v = ?a \\<cdot>\\<^sub>v (?b \\<cdot>\\<^sub>v ?v)\n\ngoal (1 subgoal):\n 1. d (Suc l) \\<cdot>\\<^sub>v\n    (d l \\<cdot>\\<^sub>v\n     (fs ! i +\n      M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) =\n    d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (fs ! i +\n      M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])))", "by (auto)"], ["proof (state)\nthis:\n  d (Suc l) \\<cdot>\\<^sub>v\n  (d l \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) =\n  d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  d (Suc l) \\<cdot>\\<^sub>v\n  (d l \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) =\n  d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"d l \\<cdot>\\<^sub>v ?tt1 + d l \\<cdot>\\<^sub>v ?tt2 = d l \\<cdot>\\<^sub>v (?tt1 + ?tt2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (fs ! i +\n      M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) +\n    d l \\<cdot>\\<^sub>v (- d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l) =\n    d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (fs ! i +\n      M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n     - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)", "using gso_carrier l_i_m Suc fsi"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  l \\<le> i \\<Longrightarrow> l < length fs\n  \\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> a i l =\n                    d l \\<cdot>\\<^sub>v\n                    (fs ! i +\n                     M.sumlist\n                      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                        [0..<l]))\n  Suc l \\<le> i\n  i < length fs\n  fs ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (fs ! i +\n      M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) +\n    d l \\<cdot>\\<^sub>v (- d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l) =\n    d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (fs ! i +\n      M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n     - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)", "by (auto intro!: smult_add_distrib_vec[symmetric, of _ n] add_carrier_vec sumlist_carrier)"], ["proof (state)\nthis:\n  d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) +\n  d l \\<cdot>\\<^sub>v (- d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l) =\n  d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n   - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))) +\n  d l \\<cdot>\\<^sub>v (- d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l) =\n  d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n   - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"(1 / d l) \\<cdot>\\<^sub>v \\<dots> = (d l / d l) \\<cdot>\\<^sub>v (?tt1 + ?tt2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / d l \\<cdot>\\<^sub>v\n    (d l \\<cdot>\\<^sub>v\n     (d (Suc l) \\<cdot>\\<^sub>v\n      (fs ! i +\n       M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n      - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)) =\n    d l / d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (fs ! i +\n      M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n     - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)", "by (intro eq_vecI, auto)"], ["proof (state)\nthis:\n  (1::'a) / d l \\<cdot>\\<^sub>v\n  (d l \\<cdot>\\<^sub>v\n   (d (Suc l) \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n    - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)) =\n  d l / d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n   - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  (1::'a) / d l \\<cdot>\\<^sub>v\n  (d l \\<cdot>\\<^sub>v\n   (d (Suc l) \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n    - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)) =\n  d l / d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n   - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"d l / d l = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d l / d l = (1::'a)", "using Gramian_determinant(2)[of l] l_i_m Suc"], ["proof (prove)\nusing this:\n  l \\<le> length fs \\<Longrightarrow> (0::'a) < d l\n  l \\<le> i \\<Longrightarrow> l < length fs\n  \\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> a i l =\n                    d l \\<cdot>\\<^sub>v\n                    (fs ! i +\n                     M.sumlist\n                      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                        [0..<l]))\n  Suc l \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. d l / d l = (1::'a)", "by(auto simp: field_simps)"], ["proof (state)\nthis:\n  d l / d l = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  d l / d l = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have  \"1 \\<cdot>\\<^sub>v (?tt1 + ?tt2) = ?tt1 + ?tt2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v\n     (fs ! i +\n      M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n     - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l) =\n    d (Suc l) \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n    - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l", "by simp"], ["proof (state)\nthis:\n  (1::'a) \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n   - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l) =\n  d (Suc l) \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n  - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  (1::'a) \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v\n   (fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n   - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l) =\n  d (Suc l) \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n  - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"?tt2 = d (Suc l) \\<cdot>\\<^sub>v (- \\<mu> i l \\<cdot>\\<^sub>v gso l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l =\n    d (Suc l) \\<cdot>\\<^sub>v (- \\<mu> i l \\<cdot>\\<^sub>v gso l)", "by auto"], ["proof (state)\nthis:\n  - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l =\n  d (Suc l) \\<cdot>\\<^sub>v (- \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  - d (Suc l) * \\<mu> i l \\<cdot>\\<^sub>v gso l =\n  d (Suc l) \\<cdot>\\<^sub>v (- \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"d (Suc l) \\<cdot>\\<^sub>v (fs ! i + ?sum) + \\<dots> =\n             d (Suc l) \\<cdot>\\<^sub>v (fs ! i + ?sum + ?term)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc l) \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n    d (Suc l) \\<cdot>\\<^sub>v (- \\<mu> i l \\<cdot>\\<^sub>v gso l) =\n    d (Suc l) \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v gso l)", "using carr"], ["proof (prove)\nusing this:\n  {fs ! i,\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]),\n   - \\<mu> i l \\<cdot>\\<^sub>v gso l}\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. d (Suc l) \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n    d (Suc l) \\<cdot>\\<^sub>v (- \\<mu> i l \\<cdot>\\<^sub>v gso l) =\n    d (Suc l) \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v gso l)", "by (subst smult_add_distrib_vec) (auto)"], ["proof (state)\nthis:\n  d (Suc l) \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n  d (Suc l) \\<cdot>\\<^sub>v (- \\<mu> i l \\<cdot>\\<^sub>v gso l) =\n  d (Suc l) \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  d (Suc l) \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])) +\n  d (Suc l) \\<cdot>\\<^sub>v (- \\<mu> i l \\<cdot>\\<^sub>v gso l) =\n  d (Suc l) \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"(?a + ?sum) + ?term = ?a + (?sum + ?term)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n    - \\<mu> i l \\<cdot>\\<^sub>v gso l =\n    fs ! i +\n    (M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v gso l)", "using carr"], ["proof (prove)\nusing this:\n  {fs ! i,\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]),\n   - \\<mu> i l \\<cdot>\\<^sub>v gso l}\n  \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n    - \\<mu> i l \\<cdot>\\<^sub>v gso l =\n    fs ! i +\n    (M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v gso l)", "by auto"], ["proof (state)\nthis:\n  fs ! i +\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  - \\<mu> i l \\<cdot>\\<^sub>v gso l =\n  fs ! i +\n  (M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  fs ! i +\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  - \\<mu> i l \\<cdot>\\<^sub>v gso l =\n  fs ! i +\n  (M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v gso l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"?term = M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<mu> i l \\<cdot>\\<^sub>v gso l =\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc l])", "using gso_carrier Suc l_i_m"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  \\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> a i l =\n                    d l \\<cdot>\\<^sub>v\n                    (fs ! i +\n                     M.sumlist\n                      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                        [0..<l]))\n  Suc l \\<le> i\n  i < length fs\n  l \\<le> i \\<Longrightarrow> l < length fs\n\ngoal (1 subgoal):\n 1. - \\<mu> i l \\<cdot>\\<^sub>v gso l =\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc l])", "by auto"], ["proof (state)\nthis:\n  - \\<mu> i l \\<cdot>\\<^sub>v gso l =\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc l])\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "also"], ["proof (state)\nthis:\n  - \\<mu> i l \\<cdot>\\<^sub>v gso l =\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc l])\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "have \"?sum + ... = M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc l]) =\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l])", "apply(subst sumlist_append[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])\n    \\<subseteq> carrier_vec n\n 2. set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc l])\n    \\<subseteq> carrier_vec n\n 3. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l] @\n      map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc l]) =\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l])", "using fsi l_i_m Suc sumlist_carrier gso_carrier"], ["proof (prove)\nusing this:\n  fs ! i \\<in> carrier_vec n\n  l \\<le> i \\<Longrightarrow> l < length fs\n  \\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n  \\<Longrightarrow> a i l =\n                    d l \\<cdot>\\<^sub>v\n                    (fs ! i +\n                     M.sumlist\n                      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                        [0..<l]))\n  Suc l \\<le> i\n  i < length fs\n  set ?xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n  M.sumlist ?xs \\<in> carrier_vec n\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n\ngoal (3 subgoals):\n 1. set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])\n    \\<subseteq> carrier_vec n\n 2. set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc l])\n    \\<subseteq> carrier_vec n\n 3. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l] @\n      map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc l]) =\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l])", "by (auto intro!: sumlist_carrier)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc l]) =\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l])\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<lbrakk>l \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> a i l =\n                                  d l \\<cdot>\\<^sub>v\n                                  (fs ! i +\n                                   M.sumlist\n                                    (map\n(\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]));\n        Suc l \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> a i (Suc l) =\n                         d (Suc l) \\<cdot>\\<^sub>v\n                         (fs ! i +\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<Suc l]))", "finally"], ["proof (chain)\npicking this:\n  a i (Suc l) =\n  d (Suc l) \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]))", "show ?case"], ["proof (prove)\nusing this:\n  a i (Suc l) =\n  d (Suc l) \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]))\n\ngoal (1 subgoal):\n 1. a i (Suc l) =\n    d (Suc l) \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]))", "by auto"], ["proof (state)\nthis:\n  a i (Suc l) =\n  d (Suc l) \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma a_l': \n  assumes \"i < m\"\n  shows \"a i i = gso' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a i i = gso' i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a i i = gso' i", "have \"a i i = d i \\<cdot>\\<^sub>v (fs ! i + M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a i i =\n    d i \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]))", "using a_l assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l \\<le> ?i; ?i < length fs\\<rbrakk>\n  \\<Longrightarrow> a ?i ?l =\n                    d ?l \\<cdot>\\<^sub>v\n                    (fs ! ?i +\n                     M.sumlist\n                      (map (\\<lambda>j. - \\<mu> ?i j \\<cdot>\\<^sub>v gso j)\n                        [0..<?l]))\n  i < length fs\n\ngoal (1 subgoal):\n 1. a i i =\n    d i \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]))", "by auto"], ["proof (state)\nthis:\n  a i i =\n  d i \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]))\n\ngoal (1 subgoal):\n 1. a i i = gso' i", "also"], ["proof (state)\nthis:\n  a i i =\n  d i \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]))\n\ngoal (1 subgoal):\n 1. a i i = gso' i", "have \"\\<dots> = d i \\<cdot>\\<^sub>v gso i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d i \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) =\n    d i \\<cdot>\\<^sub>v gso i", "by (subst gso.simps, auto)"], ["proof (state)\nthis:\n  d i \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) =\n  d i \\<cdot>\\<^sub>v gso i\n\ngoal (1 subgoal):\n 1. a i i = gso' i", "finally"], ["proof (chain)\npicking this:\n  a i i = d i \\<cdot>\\<^sub>v gso i", "have \"a i i = gso' i\""], ["proof (prove)\nusing this:\n  a i i = d i \\<cdot>\\<^sub>v gso i\n\ngoal (1 subgoal):\n 1. a i i = gso' i", "using gso'_def"], ["proof (prove)\nusing this:\n  a i i = d i \\<cdot>\\<^sub>v gso i\n  gso' ?i = d ?i \\<cdot>\\<^sub>v gso ?i\n\ngoal (1 subgoal):\n 1. a i i = gso' i", "by auto"], ["proof (state)\nthis:\n  a i i = gso' i\n\ngoal (1 subgoal):\n 1. a i i = gso' i", "from this"], ["proof (chain)\npicking this:\n  a i i = gso' i", "show ?thesis"], ["proof (prove)\nusing this:\n  a i i = gso' i\n\ngoal (1 subgoal):\n 1. a i i = gso' i", "by auto"], ["proof (state)\nthis:\n  a i i = gso' i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \n  assumes \"i < m\" \"l' \\<le> i\"\n  shows \"a i l' = (case l' of\n         0 \\<Rightarrow> fs ! i |\n         Suc l \\<Rightarrow> (1 / d l) \\<cdot>\\<^sub>v (d (Suc l) \\<cdot>\\<^sub>v (a i l) - (\\<mu>' i l) \\<cdot>\\<^sub>v a l l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a i l' =\n    (case l' of 0 \\<Rightarrow> fs ! i\n     | Suc l \\<Rightarrow>\n         (1::'a) / d l \\<cdot>\\<^sub>v\n         (d (Suc l) \\<cdot>\\<^sub>v a i l -\n          \\<mu>' i l \\<cdot>\\<^sub>v a l l))", "proof (cases l')"], ["proof (state)\ngoal (2 subgoals):\n 1. l' = 0 \\<Longrightarrow>\n    a i l' =\n    (case l' of 0 \\<Rightarrow> fs ! i\n     | Suc l \\<Rightarrow>\n         (1::'a) / d l \\<cdot>\\<^sub>v\n         (d (Suc l) \\<cdot>\\<^sub>v a i l -\n          \\<mu>' i l \\<cdot>\\<^sub>v a l l))\n 2. \\<And>nat.\n       l' = Suc nat \\<Longrightarrow>\n       a i l' =\n       (case l' of 0 \\<Rightarrow> fs ! i\n        | Suc l \\<Rightarrow>\n            (1::'a) / d l \\<cdot>\\<^sub>v\n            (d (Suc l) \\<cdot>\\<^sub>v a i l -\n             \\<mu>' i l \\<cdot>\\<^sub>v a l l))", "case (Suc l)"], ["proof (state)\nthis:\n  l' = Suc l\n\ngoal (2 subgoals):\n 1. l' = 0 \\<Longrightarrow>\n    a i l' =\n    (case l' of 0 \\<Rightarrow> fs ! i\n     | Suc l \\<Rightarrow>\n         (1::'a) / d l \\<cdot>\\<^sub>v\n         (d (Suc l) \\<cdot>\\<^sub>v a i l -\n          \\<mu>' i l \\<cdot>\\<^sub>v a l l))\n 2. \\<And>nat.\n       l' = Suc nat \\<Longrightarrow>\n       a i l' =\n       (case l' of 0 \\<Rightarrow> fs ! i\n        | Suc l \\<Rightarrow>\n            (1::'a) / d l \\<cdot>\\<^sub>v\n            (d (Suc l) \\<cdot>\\<^sub>v a i l -\n             \\<mu>' i l \\<cdot>\\<^sub>v a l l))", "have \"a i (Suc l) = (1 / d l) \\<cdot>\\<^sub>v ((d (Suc l) \\<cdot>\\<^sub>v (a i l)) - ( \\<mu>' i l) \\<cdot>\\<^sub>v a l l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a i (Suc l) =\n    (1::'a) / d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v a i l - \\<mu>' i l \\<cdot>\\<^sub>v a l l)", "using assms a_l Suc"], ["proof (prove)\nusing this:\n  i < length fs\n  l' \\<le> i\n  \\<lbrakk>?l \\<le> ?i; ?i < length fs\\<rbrakk>\n  \\<Longrightarrow> a ?i ?l =\n                    d ?l \\<cdot>\\<^sub>v\n                    (fs ! ?i +\n                     M.sumlist\n                      (map (\\<lambda>j. - \\<mu> ?i j \\<cdot>\\<^sub>v gso j)\n                        [0..<?l]))\n  l' = Suc l\n\ngoal (1 subgoal):\n 1. a i (Suc l) =\n    (1::'a) / d l \\<cdot>\\<^sub>v\n    (d (Suc l) \\<cdot>\\<^sub>v a i l - \\<mu>' i l \\<cdot>\\<^sub>v a l l)", "by(subst a_l', auto)"], ["proof (state)\nthis:\n  a i (Suc l) =\n  (1::'a) / d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v a i l - \\<mu>' i l \\<cdot>\\<^sub>v a l l)\n\ngoal (2 subgoals):\n 1. l' = 0 \\<Longrightarrow>\n    a i l' =\n    (case l' of 0 \\<Rightarrow> fs ! i\n     | Suc l \\<Rightarrow>\n         (1::'a) / d l \\<cdot>\\<^sub>v\n         (d (Suc l) \\<cdot>\\<^sub>v a i l -\n          \\<mu>' i l \\<cdot>\\<^sub>v a l l))\n 2. \\<And>nat.\n       l' = Suc nat \\<Longrightarrow>\n       a i l' =\n       (case l' of 0 \\<Rightarrow> fs ! i\n        | Suc l \\<Rightarrow>\n            (1::'a) / d l \\<cdot>\\<^sub>v\n            (d (Suc l) \\<cdot>\\<^sub>v a i l -\n             \\<mu>' i l \\<cdot>\\<^sub>v a l l))", "from this Suc"], ["proof (chain)\npicking this:\n  a i (Suc l) =\n  (1::'a) / d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v a i l - \\<mu>' i l \\<cdot>\\<^sub>v a l l)\n  l' = Suc l", "show ?thesis"], ["proof (prove)\nusing this:\n  a i (Suc l) =\n  (1::'a) / d l \\<cdot>\\<^sub>v\n  (d (Suc l) \\<cdot>\\<^sub>v a i l - \\<mu>' i l \\<cdot>\\<^sub>v a l l)\n  l' = Suc l\n\ngoal (1 subgoal):\n 1. a i l' =\n    (case l' of 0 \\<Rightarrow> fs ! i\n     | Suc l \\<Rightarrow>\n         (1::'a) / d l \\<cdot>\\<^sub>v\n         (d (Suc l) \\<cdot>\\<^sub>v a i l -\n          \\<mu>' i l \\<cdot>\\<^sub>v a l l))", "by auto"], ["proof (state)\nthis:\n  a i l' =\n  (case l' of 0 \\<Rightarrow> fs ! i\n   | Suc l \\<Rightarrow>\n       (1::'a) / d l \\<cdot>\\<^sub>v\n       (d (Suc l) \\<cdot>\\<^sub>v a i l - \\<mu>' i l \\<cdot>\\<^sub>v a l l))\n\ngoal (1 subgoal):\n 1. l' = 0 \\<Longrightarrow>\n    a i l' =\n    (case l' of 0 \\<Rightarrow> fs ! i\n     | Suc l \\<Rightarrow>\n         (1::'a) / d l \\<cdot>\\<^sub>v\n         (d (Suc l) \\<cdot>\\<^sub>v a i l -\n          \\<mu>' i l \\<cdot>\\<^sub>v a l l))", "qed auto"], ["", "lemma a_Ints:\n  assumes \"i < m\" \"l \\<le> i\" \"k < n\"\n  shows \"a i l $ k \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "have fsi: \"fs ! i \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n", "using f_carrier[of i] assms"], ["proof (prove)\nusing this:\n  i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  k < n\n\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  fs ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "have \"a i l = d l \\<cdot>\\<^sub>v (fs ! i + M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))\" \n    (is \"_ = _ \\<cdot>\\<^sub>v (_ + ?sum)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. a i l =\n    d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  k < n\n\ngoal (1 subgoal):\n 1. a i l =\n    d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))", "by (subst a_l, auto)"], ["proof (state)\nthis:\n  a i l =\n  d l \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  a i l =\n  d l \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]))\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "have \"?sum = sumlist (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "using assms gso_carrier"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  k < n\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "by (subst \\<kappa>_def, auto)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist\n   (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist\n   (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "have \"d l \\<cdot>\\<^sub>v (fs ! i + sumlist (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])) \n           = d l \\<cdot>\\<^sub>v fs ! i + d l \\<cdot>\\<^sub>v sumlist (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\"\n    (is \"_ = _ + ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])) =\n    d l \\<cdot>\\<^sub>v fs ! i +\n    d l \\<cdot>\\<^sub>v\n    M.sumlist\n     (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "using sumlist_carrier fsi"], ["proof (prove)\nusing this:\n  set ?xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n  M.sumlist ?xs \\<in> carrier_vec n\n  fs ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. d l \\<cdot>\\<^sub>v\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])) =\n    d l \\<cdot>\\<^sub>v fs ! i +\n    d l \\<cdot>\\<^sub>v\n    M.sumlist\n     (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "apply\n      (subst smult_add_distrib_vec[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                M.sumlist xs \\<in> carrier_vec n;\n     fs ! i \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> fs ! i \\<in> carrier_vec ?n3\n 2. \\<lbrakk>\\<And>xs.\n                set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                M.sumlist xs \\<in> carrier_vec n;\n     fs ! i \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist\n                       (map (\\<lambda>k.\n                                \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                         [0..<l])\n                      \\<in> carrier_vec ?n3\n 3. \\<lbrakk>\\<And>xs.\n                set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                M.sumlist xs \\<in> carrier_vec n;\n     fs ! i \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> d l \\<cdot>\\<^sub>v\n                      (fs ! i +\n                       M.sumlist\n                        (map (\\<lambda>k.\n                                 \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                          [0..<l])) =\n                      d l \\<cdot>\\<^sub>v\n                      (fs ! i +\n                       M.sumlist\n                        (map (\\<lambda>k.\n                                 \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                          [0..<l]))", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                M.sumlist xs \\<in> carrier_vec n;\n     fs ! i \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist\n                       (map (\\<lambda>k.\n                                \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                         [0..<l])\n                      \\<in> carrier_vec n\n 2. \\<lbrakk>\\<And>xs.\n                set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                M.sumlist xs \\<in> carrier_vec n;\n     fs ! i \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> d l \\<cdot>\\<^sub>v\n                      (fs ! i +\n                       M.sumlist\n                        (map (\\<lambda>k.\n                                 \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                          [0..<l])) =\n                      d l \\<cdot>\\<^sub>v\n                      (fs ! i +\n                       M.sumlist\n                        (map (\\<lambda>k.\n                                 \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                          [0..<l]))", "using assms fsi"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  k < n\n  fs ! i \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                M.sumlist xs \\<in> carrier_vec n;\n     fs ! i \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> M.sumlist\n                       (map (\\<lambda>k.\n                                \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                         [0..<l])\n                      \\<in> carrier_vec n\n 2. \\<lbrakk>\\<And>xs.\n                set xs \\<subseteq> carrier_vec n \\<Longrightarrow>\n                M.sumlist xs \\<in> carrier_vec n;\n     fs ! i \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> d l \\<cdot>\\<^sub>v\n                      (fs ! i +\n                       M.sumlist\n                        (map (\\<lambda>k.\n                                 \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                          [0..<l])) =\n                      d l \\<cdot>\\<^sub>v\n                      (fs ! i +\n                       M.sumlist\n                        (map (\\<lambda>k.\n                                 \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n                          [0..<l]))", "by (subst sumlist_carrier, auto)"], ["proof (state)\nthis:\n  d l \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])) =\n  d l \\<cdot>\\<^sub>v fs ! i +\n  d l \\<cdot>\\<^sub>v\n  M.sumlist\n   (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  d l \\<cdot>\\<^sub>v\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])) =\n  d l \\<cdot>\\<^sub>v fs ! i +\n  d l \\<cdot>\\<^sub>v\n  M.sumlist\n   (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "have \"?sum = sumlist  (map (\\<lambda>k. (d l * \\<kappa> i l k) \\<cdot>\\<^sub>v fs ! k) [0..<l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d l \\<cdot>\\<^sub>v\n    M.sumlist\n     (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "apply(subst eq_vecI sumlist_nth)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec ?y \\<Longrightarrow>\n       (d l \\<cdot>\\<^sub>v\n        M.sumlist\n         (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n           [0..<l])) $\n       ia =\n       ?y $ ia\n 2. dim_vec\n     (d l \\<cdot>\\<^sub>v\n      M.sumlist\n       (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])) =\n    dim_vec ?y\n 3. ?y =\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "using fsi assms"], ["proof (prove)\nusing this:\n  fs ! i \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  k < n\n\ngoal (3 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec ?y \\<Longrightarrow>\n       (d l \\<cdot>\\<^sub>v\n        M.sumlist\n         (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n           [0..<l])) $\n       ia =\n       ?y $ ia\n 2. dim_vec\n     (d l \\<cdot>\\<^sub>v\n      M.sumlist\n       (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])) =\n    dim_vec ?y\n 3. ?y =\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "by (auto simp: dim_sumlist sum_distrib_left sumlist_nth smult_smult_assoc algebra_simps)"], ["proof (state)\nthis:\n  d l \\<cdot>\\<^sub>v\n  M.sumlist\n   (map (\\<lambda>k. \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l]) =\n  M.sumlist\n   (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  a i l =\n  d l \\<cdot>\\<^sub>v fs ! i +\n  M.sumlist\n   (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "have \"a i l = d l \\<cdot>\\<^sub>v fs ! i + sumlist  (map (\\<lambda>k. (d l * \\<kappa> i l k) \\<cdot>\\<^sub>v fs ! k) [0..<l])\""], ["proof (prove)\nusing this:\n  a i l =\n  d l \\<cdot>\\<^sub>v fs ! i +\n  M.sumlist\n   (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. a i l =\n    d l \\<cdot>\\<^sub>v fs ! i +\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])", "by auto"], ["proof (state)\nthis:\n  a i l =\n  d l \\<cdot>\\<^sub>v fs ! i +\n  M.sumlist\n   (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "hence \"a i l $ k = (d l \\<cdot>\\<^sub>v fs ! i + sumlist (map (\\<lambda>k. (d l * \\<kappa> i l k) \\<cdot>\\<^sub>v fs ! k) [0..<l])) $ k\""], ["proof (prove)\nusing this:\n  a i l =\n  d l \\<cdot>\\<^sub>v fs ! i +\n  M.sumlist\n   (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l])\n\ngoal (1 subgoal):\n 1. a i l $ k =\n    (d l \\<cdot>\\<^sub>v fs ! i +\n     M.sumlist\n      (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n        [0..<l])) $\n    k", "by simp"], ["proof (state)\nthis:\n  a i l $ k =\n  (d l \\<cdot>\\<^sub>v fs ! i +\n   M.sumlist\n    (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n      [0..<l])) $\n  k\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  a i l $ k =\n  (d l \\<cdot>\\<^sub>v fs ! i +\n   M.sumlist\n    (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n      [0..<l])) $\n  k\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "have \"\\<dots> = (d l \\<cdot>\\<^sub>v fs ! i) $ k + (sumlist (map (\\<lambda>k. (d l * \\<kappa> i l k) \\<cdot>\\<^sub>v fs ! k) [0..<l])) $ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d l \\<cdot>\\<^sub>v fs ! i +\n     M.sumlist\n      (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n        [0..<l])) $\n    k =\n    (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n       [0..<l]) $\n    k", "apply (subst index_add_vec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < dim_vec\n         (M.sumlist\n           (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n             [0..<l]))\n 2. (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n       [0..<l]) $\n    k =\n    (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n       [0..<l]) $\n    k", "using assms fsi"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  k < n\n  fs ! i \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. k < dim_vec\n         (M.sumlist\n           (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n             [0..<l]))\n 2. (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n       [0..<l]) $\n    k =\n    (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n       [0..<l]) $\n    k", "by (subst sumlist_dim, auto)"], ["proof (state)\nthis:\n  (d l \\<cdot>\\<^sub>v fs ! i +\n   M.sumlist\n    (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n      [0..<l])) $\n  k =\n  (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n  M.sumlist\n   (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l]) $\n  k\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  a i l $ k =\n  (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n  M.sumlist\n   (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l]) $\n  k", "have id: \"a i l $ k = (d l \\<cdot>\\<^sub>v fs ! i) $ k + (sumlist (map (\\<lambda>k. (d l * \\<kappa> i l k) \\<cdot>\\<^sub>v fs ! k) [0..<l])) $ k\""], ["proof (prove)\nusing this:\n  a i l $ k =\n  (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n  M.sumlist\n   (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l]) $\n  k\n\ngoal (1 subgoal):\n 1. a i l $ k =\n    (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n       [0..<l]) $\n    k", "."], ["proof (state)\nthis:\n  a i l $ k =\n  (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n  M.sumlist\n   (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k) [0..<l]) $\n  k\n\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a i l $ k \\<in> \\<int>", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n       [0..<l]) $\n    k\n    \\<in> \\<int>", "using fsi assms d_\\<kappa>_Ints fs_int"], ["proof (prove)\nusing this:\n  fs ! i \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  k < n\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i; ?t < ?l\\<rbrakk>\n  \\<Longrightarrow> d ?l * \\<kappa> ?i ?l ?t \\<in> \\<int>\n  \\<lbrakk>?i < n; ?j < length fs\\<rbrakk>\n  \\<Longrightarrow> fs ! ?j $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (d l \\<cdot>\\<^sub>v fs ! i) $ k +\n    M.sumlist\n     (map (\\<lambda>k. d l * \\<kappa> i l k \\<cdot>\\<^sub>v fs ! k)\n       [0..<l]) $\n    k\n    \\<in> \\<int>", "by (auto simp: dim_sumlist sumlist_nth\n      intro!: Gramian_determinant_Ints sumlist_carrier Ints_minus Ints_add Ints_sum Ints_mult[of _ \"fs ! _ $ _\"]  Ints_scalar_prod[OF fsi])"], ["proof (state)\nthis:\n  a i l $ k \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma a_alt_def:\n  assumes \"l < length fs\"\n  shows \"a i (Suc l) = (let v = \\<mu>' l l \\<cdot>\\<^sub>v (a i l) - ( \\<mu>' i l) \\<cdot>\\<^sub>v a l l in\n                       (if l = 0 then v else (1 / \\<mu>' (l - 1) (l - 1)) \\<cdot>\\<^sub>v v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a i (Suc l) =\n    (let v = \\<mu>' l l \\<cdot>\\<^sub>v a i l -\n             \\<mu>' i l \\<cdot>\\<^sub>v a l l\n     in if l = 0 then v\n        else (1::'a) / \\<mu>' (l - 1) (l - 1) \\<cdot>\\<^sub>v v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a i (Suc l) =\n    (let v = \\<mu>' l l \\<cdot>\\<^sub>v a i l -\n             \\<mu>' i l \\<cdot>\\<^sub>v a l l\n     in if l = 0 then v\n        else (1::'a) / \\<mu>' (l - 1) (l - 1) \\<cdot>\\<^sub>v v)", "have [simp]: \"\\<mu>' (l - Suc 0) (l - Suc 0) = d l\" if \"0 < l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>' (l - Suc 0) (l - Suc 0) = d l", "using that"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. \\<mu>' (l - Suc 0) (l - Suc 0) = d l", "unfolding \\<mu>'_def"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. d (Suc (l - Suc 0)) * \\<mu> (l - Suc 0) (l - Suc 0) = d l", "by (auto simp add: \\<mu>.simps)"], ["proof (state)\nthis:\n  0 < l \\<Longrightarrow> \\<mu>' (l - Suc 0) (l - Suc 0) = d l\n\ngoal (1 subgoal):\n 1. a i (Suc l) =\n    (let v = \\<mu>' l l \\<cdot>\\<^sub>v a i l -\n             \\<mu>' i l \\<cdot>\\<^sub>v a l l\n     in if l = 0 then v\n        else (1::'a) / \\<mu>' (l - 1) (l - 1) \\<cdot>\\<^sub>v v)", "have [simp]: \"\\<mu>' l l = d (Suc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>' l l = d (Suc l)", "unfolding \\<mu>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc l) * \\<mu> l l = d (Suc l)", "by (auto simp add: \\<mu>.simps)"], ["proof (state)\nthis:\n  \\<mu>' l l = d (Suc l)\n\ngoal (1 subgoal):\n 1. a i (Suc l) =\n    (let v = \\<mu>' l l \\<cdot>\\<^sub>v a i l -\n             \\<mu>' i l \\<cdot>\\<^sub>v a l l\n     in if l = 0 then v\n        else (1::'a) / \\<mu>' (l - 1) (l - 1) \\<cdot>\\<^sub>v v)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a i (Suc l) =\n    (let v = \\<mu>' l l \\<cdot>\\<^sub>v a i l -\n             \\<mu>' i l \\<cdot>\\<^sub>v a l l\n     in if l = 0 then v\n        else (1::'a) / \\<mu>' (l - 1) (l - 1) \\<cdot>\\<^sub>v v)", "using assms"], ["proof (prove)\nusing this:\n  l < length fs\n\ngoal (1 subgoal):\n 1. a i (Suc l) =\n    (let v = \\<mu>' l l \\<cdot>\\<^sub>v a i l -\n             \\<mu>' i l \\<cdot>\\<^sub>v a l l\n     in if l = 0 then v\n        else (1::'a) / \\<mu>' (l - 1) (l - 1) \\<cdot>\\<^sub>v v)", "by (auto simp add: Let_def a_l')"], ["proof (state)\nthis:\n  a i (Suc l) =\n  (let v = \\<mu>' l l \\<cdot>\\<^sub>v a i l -\n           \\<mu>' i l \\<cdot>\\<^sub>v a l l\n   in if l = 0 then v\n      else (1::'a) / \\<mu>' (l - 1) (l - 1) \\<cdot>\\<^sub>v v)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* gram_schmidt_fs_int *)"], ["", "context fs_int_indpt\nbegin"], ["", "fun gso_int :: \"nat \\<Rightarrow> nat \\<Rightarrow> int vec\" where\n  \"gso_int i 0 = fs ! i\" |\n  \"gso_int i (Suc l) = (let v = \\<mu>' l l \\<cdot>\\<^sub>v (gso_int i l) - \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l in\n                         (if l = 0 then v else map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) v))\""], ["", "lemma gso_int_carrier_vec:\n  assumes \"i < length fs\" \"l \\<le> i\"\n  shows \"gso_int i l \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso_int i l \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n\ngoal (1 subgoal):\n 1. gso_int i l \\<in> carrier_vec n", "by (induction l arbitrary: i) (fastforce simp add: Let_def)+"], ["", "lemma gso_int:\n  assumes \"i < length fs\" \"l \\<le> i\"\n  shows \"of_int_hom.vec_hom (gso_int i l) = gs.a i l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i l) = gs.a i l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i l) = gs.a i l", "have \"dim_vec (gso_int i l) = n\" \"dim_vec (gs.a i l) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (gso_int i l) = n &&& dim_vec (gs.a i l) = n", "using gs.a_carrier_vec assms gso_int_carrier_vec carrier_dim_vec"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l \\<le> ?i; ?i < length (map of_int_hom.vec_hom fs)\\<rbrakk>\n  \\<Longrightarrow> gs.a ?i ?l \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> gso_int ?i ?l \\<in> carrier_vec n\n  (?v \\<in> carrier_vec ?n) = (dim_vec ?v = ?n)\n\ngoal (1 subgoal):\n 1. dim_vec (gso_int i l) = n &&& dim_vec (gs.a i l) = n", "by auto"], ["proof (state)\nthis:\n  dim_vec (gso_int i l) = n\n  dim_vec (gs.a i l) = n\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i l) = gs.a i l", "moreover"], ["proof (state)\nthis:\n  dim_vec (gso_int i l) = n\n  dim_vec (gs.a i l) = n\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i l) = gs.a i l", "have \"of_int_hom.vec_hom (gso_int i l) $ k = gs.a i l $ k\" if k: \"k < n\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i l) $ k = gs.a i l $ k", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i l) $ k = gs.a i l $ k", "proof (induction l arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i 0) $ k = gs.a i 0 $ k\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> of_int_hom.vec_hom (gso_int i l) $ k =\n                                     gs.a i l $ k;\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                         gs.a i (Suc l) $ k", "case (Suc l)"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int ?i1 l) $ k = gs.a ?i1 l $ k\n  i < length fs\n  Suc l \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i 0) $ k = gs.a i 0 $ k\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> of_int_hom.vec_hom (gso_int i l) $ k =\n                                     gs.a i l $ k;\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                         gs.a i (Suc l) $ k", "note IH = Suc(1)"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int ?i1 l) $ k = gs.a ?i1 l $ k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i 0) $ k = gs.a i 0 $ k\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> of_int_hom.vec_hom (gso_int i l) $ k =\n                                     gs.a i l $ k;\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                         gs.a i (Suc l) $ k", "have [simp]: \"dim_vec (gso_int i l) = n\" \"dim_vec (gs.a i l) = n\" \"dim_vec (gso_int l l) = n\"\n      \"dim_vec (gs.a l l) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dim_vec (gso_int i l) = n &&& dim_vec (gs.a i l) = n) &&&\n    dim_vec (gso_int l l) = n &&& dim_vec (gs.a l l) = n", "using Suc gs.a_carrier_vec gso_int_carrier_vec carrier_dim_vec gs.gso'_carrier_vec"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int ?i1 l) $ k = gs.a ?i1 l $ k\n  i < length fs\n  Suc l \\<le> i\n  \\<lbrakk>?l \\<le> ?i; ?i < length (map of_int_hom.vec_hom fs)\\<rbrakk>\n  \\<Longrightarrow> gs.a ?i ?l \\<in> carrier_vec n\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> gso_int ?i ?l \\<in> carrier_vec n\n  (?v \\<in> carrier_vec ?n) = (dim_vec ?v = ?n)\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs.gso' ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (dim_vec (gso_int i l) = n &&& dim_vec (gs.a i l) = n) &&&\n    dim_vec (gso_int l l) = n &&& dim_vec (gs.a l l) = n", "by auto"], ["proof (state)\nthis:\n  dim_vec (gso_int i l) = n\n  dim_vec (gs.a i l) = n\n  dim_vec (gso_int l l) = n\n  dim_vec (gs.a l l) = n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i 0) $ k = gs.a i 0 $ k\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> of_int_hom.vec_hom (gso_int i l) $ k =\n                                     gs.a i l $ k;\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                         gs.a i (Suc l) $ k", "have \"rat_of_int (gso_int i l $ k) = gs.a i l $ k\" \"rat_of_int (gso_int l l $ k) = gs.a l l $ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (gso_int i l $ k) = gs.a i l $ k &&&\n    rat_of_int (gso_int l l $ k) = gs.a l l $ k", "using that Suc(1)[of l] Suc(1)[of i] Suc"], ["proof (prove)\nusing this:\n  k < n\n  \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int l l) $ k = gs.a l l $ k\n  \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int i l) $ k = gs.a i l $ k\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int ?i1 l) $ k = gs.a ?i1 l $ k\n  i < length fs\n  Suc l \\<le> i\n\ngoal (1 subgoal):\n 1. rat_of_int (gso_int i l $ k) = gs.a i l $ k &&&\n    rat_of_int (gso_int l l $ k) = gs.a l l $ k", "by auto"], ["proof (state)\nthis:\n  rat_of_int (gso_int i l $ k) = gs.a i l $ k\n  rat_of_int (gso_int l l $ k) = gs.a l l $ k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i 0) $ k = gs.a i 0 $ k\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> of_int_hom.vec_hom (gso_int i l) $ k =\n                                     gs.a i l $ k;\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                         gs.a i (Suc l) $ k", "then"], ["proof (chain)\npicking this:\n  rat_of_int (gso_int i l $ k) = gs.a i l $ k\n  rat_of_int (gso_int l l $ k) = gs.a l l $ k", "have ?case if \"l = 0\""], ["proof (prove)\nusing this:\n  rat_of_int (gso_int i l $ k) = gs.a i l $ k\n  rat_of_int (gso_int l l $ k) = gs.a l l $ k\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_of_int (gso_int i l $ k) = gs.a i l $ k;\n     rat_of_int (gso_int l l $ k) = gs.a l l $ k\\<rbrakk>\n    \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                      gs.a i (Suc l) $ k", "have [simp]: \"fs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs \\<noteq> []", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int ?i1 l) $ k = gs.a ?i1 l $ k\n  i < length fs\n  Suc l \\<le> i\n\ngoal (1 subgoal):\n 1. fs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  fs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_of_int (gso_int i l $ k) = gs.a i l $ k;\n     rat_of_int (gso_int l l $ k) = gs.a l l $ k\\<rbrakk>\n    \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                      gs.a i (Suc l) $ k", "have [simp]: \"dim_vec (gso_int i 0) = n\" \"dim_vec (gso_int 0 0) = n\" \"dim_vec (gs.a i 0) = n\"\n        \"dim_vec (gs.a 0 0) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dim_vec (gso_int i 0) = n &&& dim_vec (gso_int 0 0) = n) &&&\n    dim_vec (gs.a i 0) = n &&& dim_vec (gs.a 0 0) = n", "using Suc fs_carrier carrier_dim_vec gs.a_carrier_vec f_carrier"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int ?i1 l) $ k = gs.a ?i1 l $ k\n  i < length fs\n  Suc l \\<le> i\n  set fs \\<subseteq> carrier_vec n\n  (?v \\<in> carrier_vec ?n) = (dim_vec ?v = ?n)\n  \\<lbrakk>?l \\<le> ?i; ?i < length (map of_int_hom.vec_hom fs)\\<rbrakk>\n  \\<Longrightarrow> gs.a ?i ?l \\<in> carrier_vec n\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (dim_vec (gso_int i 0) = n &&& dim_vec (gso_int 0 0) = n) &&&\n    dim_vec (gs.a i 0) = n &&& dim_vec (gs.a 0 0) = n", "by auto"], ["proof (state)\nthis:\n  dim_vec (gso_int i 0) = n\n  dim_vec (gso_int 0 0) = n\n  dim_vec (gs.a i 0) = n\n  dim_vec (gs.a 0 0) = n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_of_int (gso_int i l $ k) = gs.a i l $ k;\n     rat_of_int (gso_int l l $ k) = gs.a l l $ k\\<rbrakk>\n    \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                      gs.a i (Suc l) $ k", "have [simp]: \"rat_of_int (\\<mu>' i 0) = gs.\\<mu>' i 0\" \"rat_of_int (\\<mu>' 0 0) = gs.\\<mu>' 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (\\<mu>' i 0) = gs.\\<mu>' i 0 &&&\n    rat_of_int (\\<mu>' 0 0) = gs.\\<mu>' 0 0", "using Suc \\<sigma>s_\\<mu>'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int ?i1 l) $ k = gs.a ?i1 l $ k\n  i < length fs\n  Suc l \\<le> i\n  \\<lbrakk>?l < ?j; ?j \\<le> ?i; ?i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s ?l ?i ?j) =\n                    gs.\\<sigma> (Suc ?l) ?i ?j\n  \\<lbrakk>?i < length fs; ?j \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' ?i ?j) = gs.\\<mu>' ?i ?j\n\ngoal (1 subgoal):\n 1. rat_of_int (\\<mu>' i 0) = gs.\\<mu>' i 0 &&&\n    rat_of_int (\\<mu>' 0 0) = gs.\\<mu>' 0 0", "by (auto intro!: \\<sigma>s_\\<mu>')"], ["proof (state)\nthis:\n  rat_of_int (\\<mu>' i 0) = gs.\\<mu>' i 0\n  rat_of_int (\\<mu>' 0 0) = gs.\\<mu>' 0 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rat_of_int (gso_int i l $ k) = gs.a i l $ k;\n     rat_of_int (gso_int l l $ k) = gs.a l l $ k\\<rbrakk>\n    \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                      gs.a i (Suc l) $ k", "then"], ["proof (chain)\npicking this:\n  rat_of_int (\\<mu>' i 0) = gs.\\<mu>' i 0\n  rat_of_int (\\<mu>' 0 0) = gs.\\<mu>' 0 0", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_of_int (\\<mu>' i 0) = gs.\\<mu>' i 0\n  rat_of_int (\\<mu>' 0 0) = gs.\\<mu>' 0 0\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "using that k Suc IH[of i ] Suc(1)[of 0]"], ["proof (prove)\nusing this:\n  rat_of_int (\\<mu>' i 0) = gs.\\<mu>' i 0\n  rat_of_int (\\<mu>' 0 0) = gs.\\<mu>' 0 0\n  l = 0\n  k < n\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int ?i1 l) $ k = gs.a ?i1 l $ k\n  i < length fs\n  Suc l \\<le> i\n  \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int i l) $ k = gs.a i l $ k\n  \\<lbrakk>0 < length fs; l \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int 0 l) $ k = gs.a 0 l $ k\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "by (subst gso_int.simps, subst gs.a_alt_def) (auto simp del: gso_int.simps gs.a.simps)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l = 0 \\<Longrightarrow>\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i 0) $ k = gs.a i 0 $ k\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> of_int_hom.vec_hom (gso_int i l) $ k =\n                                     gs.a i l $ k;\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                         gs.a i (Suc l) $ k", "moreover"], ["proof (state)\nthis:\n  l = 0 \\<Longrightarrow>\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i 0) $ k = gs.a i 0 $ k\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> of_int_hom.vec_hom (gso_int i l) $ k =\n                                     gs.a i l $ k;\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                         gs.a i (Suc l) $ k", "have ?case if \"0 < l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "have *: \"rat_of_int (\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) / rat_of_int (\\<mu>' (l - Suc 0) (l - Suc 0))\n     = gs.a i (Suc l) $ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int\n     (\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) /\n    rat_of_int (\\<mu>' (l - Suc 0) (l - Suc 0)) =\n    gs.a i (Suc l) $ k", "using Suc IH[of l] IH[of i] \\<sigma>s_\\<mu>' k that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int ?i1 l) $ k = gs.a ?i1 l $ k\n  i < length fs\n  Suc l \\<le> i\n  \\<lbrakk>l < length fs; l \\<le> l\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int l l) $ k = gs.a l l $ k\n  \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int i l) $ k = gs.a i l $ k\n  \\<lbrakk>?l < ?j; ?j \\<le> ?i; ?i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s ?l ?i ?j) =\n                    gs.\\<sigma> (Suc ?l) ?i ?j\n  \\<lbrakk>?i < length fs; ?j \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' ?i ?j) = gs.\\<mu>' ?i ?j\n  k < n\n  0 < l\n\ngoal (1 subgoal):\n 1. rat_of_int\n     (\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) /\n    rat_of_int (\\<mu>' (l - Suc 0) (l - Suc 0)) =\n    gs.a i (Suc l) $ k", "by (subst gs.a_alt_def) (auto simp add: Let_def )"], ["proof (state)\nthis:\n  rat_of_int (\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) /\n  rat_of_int (\\<mu>' (l - Suc 0) (l - Suc 0)) =\n  gs.a i (Suc l) $ k\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "have \"of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n            rat_of_int ((\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) \n                        div \\<mu>' (l - Suc 0) (l - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n    rat_of_int\n     ((\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) div\n      \\<mu>' (l - Suc 0) (l - Suc 0))", "using that gso_int_carrier_vec k"], ["proof (prove)\nusing this:\n  0 < l\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> gso_int ?i ?l \\<in> carrier_vec n\n  k < n\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n    rat_of_int\n     ((\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) div\n      \\<mu>' (l - Suc 0) (l - Suc 0))", "by (auto)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n  rat_of_int\n   ((\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) div\n    \\<mu>' (l - Suc 0) (l - Suc 0))\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "also"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n  rat_of_int\n   ((\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) div\n    \\<mu>' (l - Suc 0) (l - Suc 0))\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "have \"\\<dots> = rat_of_int (\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) / rat_of_int (\\<mu>' (l - Suc 0) (l - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int\n     ((\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) div\n      \\<mu>' (l - Suc 0) (l - Suc 0)) =\n    rat_of_int\n     (\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) /\n    rat_of_int (\\<mu>' (l - Suc 0) (l - Suc 0))", "using gs.a_Ints k Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length (map of_int_hom.vec_hom fs); ?l \\<le> ?i;\n   ?k < n\\<rbrakk>\n  \\<Longrightarrow> gs.a ?i ?l $ ?k \\<in> \\<int>\n  k < n\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (gso_int ?i1 l) $ k = gs.a ?i1 l $ k\n  i < length fs\n  Suc l \\<le> i\n\ngoal (1 subgoal):\n 1. rat_of_int\n     ((\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) div\n      \\<mu>' (l - Suc 0) (l - Suc 0)) =\n    rat_of_int\n     (\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) /\n    rat_of_int (\\<mu>' (l - Suc 0) (l - Suc 0))", "by (intro exact_division, subst *, force)"], ["proof (state)\nthis:\n  rat_of_int\n   ((\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) div\n    \\<mu>' (l - Suc 0) (l - Suc 0)) =\n  rat_of_int (\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) /\n  rat_of_int (\\<mu>' (l - Suc 0) (l - Suc 0))\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "also"], ["proof (state)\nthis:\n  rat_of_int\n   ((\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) div\n    \\<mu>' (l - Suc 0) (l - Suc 0)) =\n  rat_of_int (\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) /\n  rat_of_int (\\<mu>' (l - Suc 0) (l - Suc 0))\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "note *"], ["proof (state)\nthis:\n  rat_of_int (\\<mu>' l l * gso_int i l $ k - \\<mu>' i l * gso_int l l $ k) /\n  rat_of_int (\\<mu>' (l - Suc 0) (l - Suc 0)) =\n  gs.a i (Suc l) $ k\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "finally"], ["proof (chain)\npicking this:\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "show ?thesis"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "by (auto)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < l \\<Longrightarrow>\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i 0) $ k = gs.a i 0 $ k\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> of_int_hom.vec_hom (gso_int i l) $ k =\n                                     gs.a i l $ k;\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i (Suc l)) $ k =\n                         gs.a i (Suc l) $ k", "ultimately"], ["proof (chain)\npicking this:\n  l = 0 \\<Longrightarrow>\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k\n  0 < l \\<Longrightarrow>\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "show ?case"], ["proof (prove)\nusing this:\n  l = 0 \\<Longrightarrow>\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k\n  0 < l \\<Longrightarrow>\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k", "by blast"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (gso_int i (Suc l)) $ k = gs.a i (Suc l) $ k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> of_int_hom.vec_hom (gso_int i 0) $ k = gs.a i 0 $ k", "qed (auto)"], ["proof (state)\nthis:\n  ?k1 < n \\<Longrightarrow>\n  of_int_hom.vec_hom (gso_int i l) $ ?k1 = gs.a i l $ ?k1\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i l) = gs.a i l", "ultimately"], ["proof (chain)\npicking this:\n  dim_vec (gso_int i l) = n\n  dim_vec (gs.a i l) = n\n  ?k1 < n \\<Longrightarrow>\n  of_int_hom.vec_hom (gso_int i l) $ ?k1 = gs.a i l $ ?k1", "show ?thesis"], ["proof (prove)\nusing this:\n  dim_vec (gso_int i l) = n\n  dim_vec (gs.a i l) = n\n  ?k1 < n \\<Longrightarrow>\n  of_int_hom.vec_hom (gso_int i l) $ ?k1 = gs.a i l $ ?k1\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gso_int i l) = gs.a i l", "by auto"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (gso_int i l) = gs.a i l\n\ngoal:\nNo subgoals!", "qed"], ["", "function gso_int_tail' :: \"nat \\<Rightarrow> nat \\<Rightarrow> int vec \\<Rightarrow> int vec\" where\n  \"gso_int_tail' i l acc = (if l \\<ge> i then acc\n    else (let v = \\<mu>' l l \\<cdot>\\<^sub>v acc - \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n              acc' = (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) v)\n        in gso_int_tail' i (l + 1) acc'))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i l acc.\n           x = (i, l, acc) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>i l acc ia la acca.\n       (i, l, acc) = (ia, la, acca) \\<Longrightarrow>\n       (if i \\<le> l then acc\n        else let v = \\<mu>' l l \\<cdot>\\<^sub>v acc -\n                     \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n                 x2 = map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) v\n             in gso_int_tail'_sumC (i, l + 1, x2)) =\n       (if ia \\<le> la then acca\n        else let v = \\<mu>' la la \\<cdot>\\<^sub>v acca -\n                     \\<mu>' ia la \\<cdot>\\<^sub>v gso_int la la;\n                 x2 = map_vec (\\<lambda>k. k div \\<mu>' (la - 1) (la - 1)) v\n             in gso_int_tail'_sumC (ia, la + 1, x2))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All gso_int_tail'_dom", "by  (relation \"(\\<lambda>(i,l,acc). i - l)  <*mlex*> {}\",  goal_cases) (auto intro!: mlex_less wf_mlex)"], ["", "fun gso_int_tail :: \"nat \\<Rightarrow> int vec\" where\n  \"gso_int_tail i = (if i = 0 then fs ! 0 else\n     let acc = \\<mu>' 0 0 \\<cdot>\\<^sub>v fs ! i - \\<mu>' i 0 \\<cdot>\\<^sub>v fs ! 0 in\n     gso_int_tail' i 1 acc)\""], ["", "lemma gso_int_tail':\n  assumes \"acc = gso_int i l\" \"0 < i\" \"0 < l\" \"l \\<le> i\"\n  shows \"gso_int_tail' i l acc = gso_int i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso_int_tail' i l acc = gso_int i i", "using assms"], ["proof (prove)\nusing this:\n  acc = gso_int i l\n  0 < i\n  0 < l\n  l \\<le> i\n\ngoal (1 subgoal):\n 1. gso_int_tail' i l acc = gso_int i i", "proof (induction i l acc rule: gso_int_tail'.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i l acc.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> i \\<le> l;\n                    x =\n                    \\<mu>' l l \\<cdot>\\<^sub>v acc -\n                    \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n                    xa =\n                    map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) x;\n                    xa = gso_int i (l + 1); 0 < i; 0 < l + 1;\n                    l + 1 \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> gso_int_tail' i (l + 1) xa =\n                                     gso_int i i;\n        acc = gso_int i l; 0 < i; 0 < l; l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> gso_int_tail' i l acc = gso_int i i", "case (1 i l acc)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> i \\<le> l;\n   ?x1 =\n   \\<mu>' l l \\<cdot>\\<^sub>v acc - \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n   ?xa1 = map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) ?x1;\n   ?xa1 = gso_int i (l + 1); 0 < i; 0 < l + 1; l + 1 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> gso_int_tail' i (l + 1) ?xa1 = gso_int i i\n  acc = gso_int i l\n  0 < i\n  0 < l\n  l \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>i l acc.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> i \\<le> l;\n                    x =\n                    \\<mu>' l l \\<cdot>\\<^sub>v acc -\n                    \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n                    xa =\n                    map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) x;\n                    xa = gso_int i (l + 1); 0 < i; 0 < l + 1;\n                    l + 1 \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> gso_int_tail' i (l + 1) xa =\n                                     gso_int i i;\n        acc = gso_int i l; 0 < i; 0 < l; l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> gso_int_tail' i l acc = gso_int i i", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> i \\<le> l;\n   ?x1 =\n   \\<mu>' l l \\<cdot>\\<^sub>v acc - \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n   ?xa1 = map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) ?x1;\n   ?xa1 = gso_int i (l + 1); 0 < i; 0 < l + 1; l + 1 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> gso_int_tail' i (l + 1) ?xa1 = gso_int i i\n  acc = gso_int i l\n  0 < i\n  0 < l\n  l \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>i l acc.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> i \\<le> l;\n                    x =\n                    \\<mu>' l l \\<cdot>\\<^sub>v acc -\n                    \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n                    xa =\n                    map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) x;\n                    xa = gso_int i (l + 1); 0 < i; 0 < l + 1;\n                    l + 1 \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> gso_int_tail' i (l + 1) xa =\n                                     gso_int i i;\n        acc = gso_int i l; 0 < i; 0 < l; l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> gso_int_tail' i l acc = gso_int i i", "assume li: \"l < i\""], ["proof (state)\nthis:\n  l < i\n\ngoal (1 subgoal):\n 1. \\<And>i l acc.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> i \\<le> l;\n                    x =\n                    \\<mu>' l l \\<cdot>\\<^sub>v acc -\n                    \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n                    xa =\n                    map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) x;\n                    xa = gso_int i (l + 1); 0 < i; 0 < l + 1;\n                    l + 1 \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> gso_int_tail' i (l + 1) xa =\n                                     gso_int i i;\n        acc = gso_int i l; 0 < i; 0 < l; l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> gso_int_tail' i l acc = gso_int i i", "then"], ["proof (chain)\npicking this:\n  l < i", "have \"gso_int_tail' i l acc =\n        gso_int_tail' i (l + 1) (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) (\\<mu>' l l \\<cdot>\\<^sub>v acc - \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l))\""], ["proof (prove)\nusing this:\n  l < i\n\ngoal (1 subgoal):\n 1. gso_int_tail' i l acc =\n    gso_int_tail' i (l + 1)\n     (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1))\n       (\\<mu>' l l \\<cdot>\\<^sub>v acc -\n        \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l))", "using 1"], ["proof (prove)\nusing this:\n  l < i\n  \\<lbrakk>\\<not> i \\<le> l;\n   ?x1 =\n   \\<mu>' l l \\<cdot>\\<^sub>v acc - \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n   ?xa1 = map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) ?x1;\n   ?xa1 = gso_int i (l + 1); 0 < i; 0 < l + 1; l + 1 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> gso_int_tail' i (l + 1) ?xa1 = gso_int i i\n  acc = gso_int i l\n  0 < i\n  0 < l\n  l \\<le> i\n\ngoal (1 subgoal):\n 1. gso_int_tail' i l acc =\n    gso_int_tail' i (l + 1)\n     (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1))\n       (\\<mu>' l l \\<cdot>\\<^sub>v acc -\n        \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  gso_int_tail' i l acc =\n  gso_int_tail' i (l + 1)\n   (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1))\n     (\\<mu>' l l \\<cdot>\\<^sub>v acc -\n      \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l))\n\ngoal (1 subgoal):\n 1. \\<And>i l acc.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> i \\<le> l;\n                    x =\n                    \\<mu>' l l \\<cdot>\\<^sub>v acc -\n                    \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n                    xa =\n                    map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) x;\n                    xa = gso_int i (l + 1); 0 < i; 0 < l + 1;\n                    l + 1 \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> gso_int_tail' i (l + 1) xa =\n                                     gso_int i i;\n        acc = gso_int i l; 0 < i; 0 < l; l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> gso_int_tail' i l acc = gso_int i i", "also"], ["proof (state)\nthis:\n  gso_int_tail' i l acc =\n  gso_int_tail' i (l + 1)\n   (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1))\n     (\\<mu>' l l \\<cdot>\\<^sub>v acc -\n      \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l))\n\ngoal (1 subgoal):\n 1. \\<And>i l acc.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> i \\<le> l;\n                    x =\n                    \\<mu>' l l \\<cdot>\\<^sub>v acc -\n                    \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n                    xa =\n                    map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) x;\n                    xa = gso_int i (l + 1); 0 < i; 0 < l + 1;\n                    l + 1 \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> gso_int_tail' i (l + 1) xa =\n                                     gso_int i i;\n        acc = gso_int i l; 0 < i; 0 < l; l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> gso_int_tail' i l acc = gso_int i i", "have \"\\<dots> = gso_int i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso_int_tail' i (l + 1)\n     (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1))\n       (\\<mu>' l l \\<cdot>\\<^sub>v acc -\n        \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l)) =\n    gso_int i i", "using 1 li"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> i \\<le> l;\n   ?x1 =\n   \\<mu>' l l \\<cdot>\\<^sub>v acc - \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n   ?xa1 = map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) ?x1;\n   ?xa1 = gso_int i (l + 1); 0 < i; 0 < l + 1; l + 1 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> gso_int_tail' i (l + 1) ?xa1 = gso_int i i\n  acc = gso_int i l\n  0 < i\n  0 < l\n  l \\<le> i\n  l < i\n\ngoal (1 subgoal):\n 1. gso_int_tail' i (l + 1)\n     (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1))\n       (\\<mu>' l l \\<cdot>\\<^sub>v acc -\n        \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l)) =\n    gso_int i i", "by (intro 1) (auto)"], ["proof (state)\nthis:\n  gso_int_tail' i (l + 1)\n   (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1))\n     (\\<mu>' l l \\<cdot>\\<^sub>v acc -\n      \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l)) =\n  gso_int i i\n\ngoal (1 subgoal):\n 1. \\<And>i l acc.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> i \\<le> l;\n                    x =\n                    \\<mu>' l l \\<cdot>\\<^sub>v acc -\n                    \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n                    xa =\n                    map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) x;\n                    xa = gso_int i (l + 1); 0 < i; 0 < l + 1;\n                    l + 1 \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> gso_int_tail' i (l + 1) xa =\n                                     gso_int i i;\n        acc = gso_int i l; 0 < i; 0 < l; l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> gso_int_tail' i l acc = gso_int i i", "}"], ["proof (state)\nthis:\n  l < i \\<Longrightarrow>\n  gso_int_tail' i (l + 1)\n   (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1))\n     (\\<mu>' l l \\<cdot>\\<^sub>v acc -\n      \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l)) =\n  gso_int i i\n\ngoal (1 subgoal):\n 1. \\<And>i l acc.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>\\<not> i \\<le> l;\n                    x =\n                    \\<mu>' l l \\<cdot>\\<^sub>v acc -\n                    \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n                    xa =\n                    map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) x;\n                    xa = gso_int i (l + 1); 0 < i; 0 < l + 1;\n                    l + 1 \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> gso_int_tail' i (l + 1) xa =\n                                     gso_int i i;\n        acc = gso_int i l; 0 < i; 0 < l; l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> gso_int_tail' i l acc = gso_int i i", "then"], ["proof (chain)\npicking this:\n  l < i \\<Longrightarrow>\n  gso_int_tail' i (l + 1)\n   (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1))\n     (\\<mu>' l l \\<cdot>\\<^sub>v acc -\n      \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l)) =\n  gso_int i i", "show ?case"], ["proof (prove)\nusing this:\n  l < i \\<Longrightarrow>\n  gso_int_tail' i (l + 1)\n   (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1))\n     (\\<mu>' l l \\<cdot>\\<^sub>v acc -\n      \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l)) =\n  gso_int i i\n\ngoal (1 subgoal):\n 1. gso_int_tail' i l acc = gso_int i i", "using 1"], ["proof (prove)\nusing this:\n  l < i \\<Longrightarrow>\n  gso_int_tail' i (l + 1)\n   (map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1))\n     (\\<mu>' l l \\<cdot>\\<^sub>v acc -\n      \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l)) =\n  gso_int i i\n  \\<lbrakk>\\<not> i \\<le> l;\n   ?x1 =\n   \\<mu>' l l \\<cdot>\\<^sub>v acc - \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n   ?xa1 = map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) ?x1;\n   ?xa1 = gso_int i (l + 1); 0 < i; 0 < l + 1; l + 1 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> gso_int_tail' i (l + 1) ?xa1 = gso_int i i\n  acc = gso_int i l\n  0 < i\n  0 < l\n  l \\<le> i\n\ngoal (1 subgoal):\n 1. gso_int_tail' i l acc = gso_int i i", "by fastforce"], ["proof (state)\nthis:\n  gso_int_tail' i l acc = gso_int i i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gso_int_tail: \"gso_int_tail i = gso_int i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso_int_tail i = gso_int i i", "proof (cases \"0 < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow> gso_int_tail i = gso_int i i\n 2. \\<not> 0 < i \\<Longrightarrow> gso_int_tail i = gso_int i i", "assume i: \"0 < i\""], ["proof (state)\nthis:\n  0 < i\n\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow> gso_int_tail i = gso_int i i\n 2. \\<not> 0 < i \\<Longrightarrow> gso_int_tail i = gso_int i i", "then"], ["proof (chain)\npicking this:\n  0 < i", "have \"gso_int_tail i = gso_int_tail' i (Suc 0) (gso_int i 1)\""], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. gso_int_tail i = gso_int_tail' i (Suc 0) (gso_int i 1)", "by (subst gso_int_tail.simps) (auto)"], ["proof (state)\nthis:\n  gso_int_tail i = gso_int_tail' i (Suc 0) (gso_int i 1)\n\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow> gso_int_tail i = gso_int i i\n 2. \\<not> 0 < i \\<Longrightarrow> gso_int_tail i = gso_int i i", "also"], ["proof (state)\nthis:\n  gso_int_tail i = gso_int_tail' i (Suc 0) (gso_int i 1)\n\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow> gso_int_tail i = gso_int i i\n 2. \\<not> 0 < i \\<Longrightarrow> gso_int_tail i = gso_int i i", "have \"\\<dots> = gso_int i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso_int_tail' i (Suc 0) (gso_int i 1) = gso_int i i", "using i"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. gso_int_tail' i (Suc 0) (gso_int i 1) = gso_int i i", "by (intro gso_int_tail') (auto intro!: gso_int_tail')"], ["proof (state)\nthis:\n  gso_int_tail' i (Suc 0) (gso_int i 1) = gso_int i i\n\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow> gso_int_tail i = gso_int i i\n 2. \\<not> 0 < i \\<Longrightarrow> gso_int_tail i = gso_int i i", "finally"], ["proof (chain)\npicking this:\n  gso_int_tail i = gso_int i i", "show \"gso_int_tail i = gso_int i i\""], ["proof (prove)\nusing this:\n  gso_int_tail i = gso_int i i\n\ngoal (1 subgoal):\n 1. gso_int_tail i = gso_int i i", "by simp"], ["proof (state)\nthis:\n  gso_int_tail i = gso_int i i\n\ngoal (1 subgoal):\n 1. \\<not> 0 < i \\<Longrightarrow> gso_int_tail i = gso_int i i", "qed (auto)"], ["", "end"], ["", "locale gso_array\nbegin"], ["", "function while :: \"nat \\<Rightarrow> nat \\<Rightarrow> int vec iarray \\<Rightarrow> int iarray iarray \\<Rightarrow> int vec \\<Rightarrow> int vec\" where\n  \"while i l gsa dmusa acc =  (if l \\<ge> i then acc\n    else (let v = dmusa !! l !! l \\<cdot>\\<^sub>v acc - dmusa !! i !! l \\<cdot>\\<^sub>v gsa !! l;\n              acc' = (map_vec (\\<lambda>k. k div dmusa !! (l - 1) !! (l - 1)) v)\n        in while i (l + 1) gsa dmusa acc'))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i l gsa dmusa acc.\n           x = (i, l, gsa, dmusa, acc) \\<Longrightarrow>\n           P) \\<Longrightarrow>\n       P\n 2. \\<And>i l gsa dmusa acc ia la gsaa dmusaa acca.\n       (i, l, gsa, dmusa, acc) =\n       (ia, la, gsaa, dmusaa, acca) \\<Longrightarrow>\n       (if i \\<le> l then acc\n        else let v = dmusa !! l !! l \\<cdot>\\<^sub>v acc -\n                     dmusa !! i !! l \\<cdot>\\<^sub>v gsa !! l;\n                 x4 = map_vec\n                       (\\<lambda>k. k div dmusa !! (l - 1) !! (l - 1)) v\n             in while_sumC (i, l + 1, gsa, dmusa, x4)) =\n       (if ia \\<le> la then acca\n        else let v = dmusaa !! la !! la \\<cdot>\\<^sub>v acca -\n                     dmusaa !! ia !! la \\<cdot>\\<^sub>v gsaa !! la;\n                 x4 = map_vec\n                       (\\<lambda>k. k div dmusaa !! (la - 1) !! (la - 1)) v\n             in while_sumC (ia, la + 1, gsaa, dmusaa, x4))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Wellfounded.accp while_rel x", "by  (relation \"(\\<lambda>(i,l,acc). i - l)  <*mlex*> {}\",  goal_cases) (auto intro!: mlex_less wf_mlex)"], ["", "declare while.simps[simp del]"], ["", "definition gso' where\n  \"gso' i fsa gsa dmusa = (if i = 0 then fsa !! 0 else\n     let acc = dmusa !! 0 !! 0 \\<cdot>\\<^sub>v fsa !! i - dmusa !! i !! 0 \\<cdot>\\<^sub>v fsa !! 0 in\n     while i 1 gsa dmusa acc)\""], ["", "function gsos' where\n  \"gsos' i n dmusa fsa gsa = (if i \\<ge> n then gsa else\n    gsos' (i + 1) n dmusa fsa (iarray_append gsa (gso' i fsa gsa dmusa)))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i n dmusa fsa gsa.\n           x = (i, n, dmusa, fsa, gsa) \\<Longrightarrow>\n           P) \\<Longrightarrow>\n       P\n 2. \\<And>i n dmusa fsa gsa ia na dmusaa fsaa gsaa.\n       (i, n, dmusa, fsa, gsa) =\n       (ia, na, dmusaa, fsaa, gsaa) \\<Longrightarrow>\n       (if n \\<le> i then gsa\n        else gsos'_sumC\n              (i + 1, n, dmusa, fsa,\n               iarray_append gsa (gso' i fsa gsa dmusa))) =\n       (if na \\<le> ia then gsaa\n        else gsos'_sumC\n              (ia + 1, na, dmusaa, fsaa,\n               iarray_append gsaa (gso' ia fsaa gsaa dmusaa)))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Wellfounded.accp gsos'_rel x", "by  (relation \"(\\<lambda>(i,n,dmusa,fsa,gsa). n - i)  <*mlex*> {}\",  goal_cases) (auto intro!: mlex_less wf_mlex)"], ["", "declare gsos'.simps[simp del]"], ["", "definition gso'_array where\n  \"gso'_array dmusa fs = gsos' 0 (length fs) dmusa (IArray fs) (IArray [])\""], ["", "definition gso_array where\n  \"gso_array fs = (let dmusa = d\\<mu>_impl fs; gsa = gso'_array dmusa fs\n                   in IArray.of_fun (\\<lambda>i. (if i = 0 then 1 else inverse (rat_of_int (dmusa !! (i - 1) !! (i - 1))))\n                      \\<cdot>\\<^sub>v of_int_hom.vec_hom (gsa !! i)) (length fs))\""], ["", "end"], ["", "declare gso_array.gso_array_def[code]"], ["", "declare gso_array.gso'_array_def[code]"], ["", "declare gso_array.gsos'.simps[code]"], ["", "declare gso_array.gso'_def[code]"], ["", "declare gso_array.while.simps[code]"], ["", "lemma map_vec_id[simp]: \"map_vec id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vec id = id", "by (auto intro!: eq_vecI)"], ["", "context fs_int_indpt\nbegin"], ["", "lemma \"gso_array.gso'_array (d\\<mu>_impl fs) fs = IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso_array.gso'_array (d\\<mu>_impl fs) fs =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gso_array.gso'_array (d\\<mu>_impl fs) fs =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "have a[simp]: \"IArray (IArray.list_of a) = a\" for a:: \"'a iarray\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray (IArray.list_of a) = a", "by (metis iarray.exhaust list_of.simps)"], ["proof (state)\nthis:\n  IArray (IArray.list_of ?a2) = ?a2\n\ngoal (1 subgoal):\n 1. gso_array.gso'_array (d\\<mu>_impl fs) fs =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "have [simp]: \"length (IArray.list_of (iarray_append xs x)) = Suc (IArray.length xs)\" for x xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (IArray.list_of (iarray_append xs x)) = Suc (IArray.length xs)", "unfolding iarray_append_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (IArray.list_of (IArray (IArray.list_of xs @ [x]))) =\n    Suc (IArray.length xs)", "by (simp)"], ["proof (state)\nthis:\n  length (IArray.list_of (iarray_append ?xs3 ?x3)) =\n  Suc (IArray.length ?xs3)\n\ngoal (1 subgoal):\n 1. gso_array.gso'_array (d\\<mu>_impl fs) fs =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "have [simp]: \"map_iarray f as = IArray (map f (IArray.list_of as))\" for f as"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iarray f as = IArray (map f (IArray.list_of as))", "by (metis a iarray.simps(4))"], ["proof (state)\nthis:\n  map_iarray ?f4 ?as4 = IArray (map ?f4 (IArray.list_of ?as4))\n\ngoal (1 subgoal):\n 1. gso_array.gso'_array (d\\<mu>_impl fs) fs =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "have d[simp]: \"IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! i) ! j = \\<mu>' i j\"\n    if \"i < length fs\" \"j \\<le> i\" for j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! i) ! j = \\<mu>' i j", "using that"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! i) ! j = \\<mu>' i j", "by (auto simp add: \\<mu>' d\\<mu>_impl nth_append)"], ["proof (state)\nthis:\n  \\<lbrakk>?i4 < length fs; ?j4 \\<le> ?i4\\<rbrakk>\n  \\<Longrightarrow> IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! ?i4) !\n                    ?j4 =\n                    \\<mu>' ?i4 ?j4\n\ngoal (1 subgoal):\n 1. gso_array.gso'_array (d\\<mu>_impl fs) fs =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "let ?rat_vec = \"of_int_hom.vec_hom\""], ["proof (state)\ngoal (1 subgoal):\n 1. gso_array.gso'_array (d\\<mu>_impl fs) fs =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "have *: \"gso_array.while i j gsa (d\\<mu>_impl fs) acc = gso_int_tail' i j acc'\"\n      if \"i < length fs\" \"j \\<le> i\" \"acc = acc'\"\n         \"\\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\" for i j gsa acc acc'"], ["proof (prove)\ngoal (1 subgoal):\n 1. gso_array.while i j gsa (d\\<mu>_impl fs) acc = gso_int_tail' i j acc'", "using that"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  acc = acc'\n  ?k5 < i \\<Longrightarrow> gsa !! ?k5 = gso_int ?k5 ?k5\n\ngoal (1 subgoal):\n 1. gso_array.while i j gsa (d\\<mu>_impl fs) acc = gso_int_tail' i j acc'", "apply (induction i j acc arbitrary: acc' rule: gso_int_tail'.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i l acc acc'.\n       \\<lbrakk>\\<And>x xa acc'.\n                   \\<lbrakk>\\<not> i \\<le> l;\n                    x =\n                    \\<mu>' l l \\<cdot>\\<^sub>v acc -\n                    \\<mu>' i l \\<cdot>\\<^sub>v gso_int l l;\n                    xa =\n                    map_vec (\\<lambda>k. k div \\<mu>' (l - 1) (l - 1)) x;\n                    i < length fs; l + 1 \\<le> i; xa = acc';\n                    \\<And>k.\n                       k < i \\<Longrightarrow>\n                       gsa !! k = gso_int k k\\<rbrakk>\n                   \\<Longrightarrow> gso_array.while i (l + 1) gsa\n(d\\<mu>_impl fs) xa =\n                                     gso_int_tail' i (l + 1) acc';\n        i < length fs; l \\<le> i; acc = acc';\n        \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n       \\<Longrightarrow> gso_array.while i l gsa (d\\<mu>_impl fs) acc =\n                         gso_int_tail' i l acc'", "by (subst gso_array.while.simps, subst gso_int_tail'.simps, auto)"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 < length fs; ?j5 \\<le> ?i5; ?acc5 = ?acc'5;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.while ?i5 ?j5 ?gsa5 (d\\<mu>_impl fs) ?acc5 =\n                    gso_int_tail' ?i5 ?j5 ?acc'5\n\ngoal (1 subgoal):\n 1. gso_array.gso'_array (d\\<mu>_impl fs) fs =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i5 < length fs; ?j5 \\<le> ?i5; ?acc5 = ?acc'5;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.while ?i5 ?j5 ?gsa5 (d\\<mu>_impl fs) ?acc5 =\n                    gso_int_tail' ?i5 ?j5 ?acc'5", "have *: \"gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i\"\n    if assms: \"i < length fs\" \"\\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\" for i gsa"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i5 < length fs; ?j5 \\<le> ?i5; ?acc5 = ?acc'5;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.while ?i5 ?j5 ?gsa5 (d\\<mu>_impl fs) ?acc5 =\n                    gso_int_tail' ?i5 ?j5 ?acc'5\n\ngoal (1 subgoal):\n 1. gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>i j acc acc' gsa.\n        \\<lbrakk>i < length fs; j \\<le> i; acc = acc';\n         \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n        \\<Longrightarrow> gso_array.while i j gsa (d\\<mu>_impl fs) acc =\n                          gso_int_tail' i j acc') \\<Longrightarrow>\n    gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i", "have \"IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! 0) ! 0 = \\<mu>' 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! 0) ! 0 = \\<mu>' 0 0", "using that"], ["proof (prove)\nusing this:\n  i < length fs\n  ?k5 < i \\<Longrightarrow> gsa !! ?k5 = gso_int ?k5 ?k5\n\ngoal (1 subgoal):\n 1. IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! 0) ! 0 = \\<mu>' 0 0", "by (subst d) (auto)"], ["proof (state)\nthis:\n  IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! 0) ! 0 = \\<mu>' 0 0\n\ngoal (1 subgoal):\n 1. (\\<And>i j acc acc' gsa.\n        \\<lbrakk>i < length fs; j \\<le> i; acc = acc';\n         \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n        \\<Longrightarrow> gso_array.while i j gsa (d\\<mu>_impl fs) acc =\n                          gso_int_tail' i j acc') \\<Longrightarrow>\n    gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i", "then"], ["proof (chain)\npicking this:\n  IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! 0) ! 0 = \\<mu>' 0 0", "have \"gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int_tail i\""], ["proof (prove)\nusing this:\n  IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! 0) ! 0 = \\<mu>' 0 0\n\ngoal (1 subgoal):\n 1. gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int_tail i", "unfolding gso_array.gso'_def gso_int_tail.simps Let_def"], ["proof (prove)\nusing this:\n  IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! 0) ! 0 = \\<mu>' 0 0\n\ngoal (1 subgoal):\n 1. (if i = 0 then IArray fs !! 0\n     else gso_array.while i 1 gsa (d\\<mu>_impl fs)\n           (d\\<mu>_impl fs !! 0 !! 0 \\<cdot>\\<^sub>v IArray fs !! i -\n            d\\<mu>_impl fs !! i !! 0 \\<cdot>\\<^sub>v IArray fs !! 0)) =\n    (if i = 0 then fs ! 0\n     else gso_int_tail' i 1\n           (\\<mu>' 0 0 \\<cdot>\\<^sub>v fs ! i -\n            \\<mu>' i 0 \\<cdot>\\<^sub>v fs ! 0))", "using that *"], ["proof (prove)\nusing this:\n  IArray.list_of (IArray.list_of (d\\<mu>_impl fs) ! 0) ! 0 = \\<mu>' 0 0\n  i < length fs\n  ?k5 < i \\<Longrightarrow> gsa !! ?k5 = gso_int ?k5 ?k5\n  \\<lbrakk>?i5 < length fs; ?j5 \\<le> ?i5; ?acc5 = ?acc'5;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.while ?i5 ?j5 ?gsa5 (d\\<mu>_impl fs) ?acc5 =\n                    gso_int_tail' ?i5 ?j5 ?acc'5\n\ngoal (1 subgoal):\n 1. (if i = 0 then IArray fs !! 0\n     else gso_array.while i 1 gsa (d\\<mu>_impl fs)\n           (d\\<mu>_impl fs !! 0 !! 0 \\<cdot>\\<^sub>v IArray fs !! i -\n            d\\<mu>_impl fs !! i !! 0 \\<cdot>\\<^sub>v IArray fs !! 0)) =\n    (if i = 0 then fs ! 0\n     else gso_int_tail' i 1\n           (\\<mu>' 0 0 \\<cdot>\\<^sub>v fs ! i -\n            \\<mu>' i 0 \\<cdot>\\<^sub>v fs ! 0))", "by (auto simp del: gso_int_tail'.simps)"], ["proof (state)\nthis:\n  gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int_tail i\n\ngoal (1 subgoal):\n 1. (\\<And>i j acc acc' gsa.\n        \\<lbrakk>i < length fs; j \\<le> i; acc = acc';\n         \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n        \\<Longrightarrow> gso_array.while i j gsa (d\\<mu>_impl fs) acc =\n                          gso_int_tail' i j acc') \\<Longrightarrow>\n    gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i", "then"], ["proof (chain)\npicking this:\n  gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int_tail i", "show ?thesis"], ["proof (prove)\nusing this:\n  gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int_tail i\n\ngoal (1 subgoal):\n 1. gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i", "using gso_int_tail"], ["proof (prove)\nusing this:\n  gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int_tail i\n  gso_int_tail ?i = gso_int ?i ?i\n\ngoal (1 subgoal):\n 1. gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i", "by simp"], ["proof (state)\nthis:\n  gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 < length fs;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.gso' ?i5 (IArray fs) ?gsa5 (d\\<mu>_impl fs) =\n                    gso_int ?i5 ?i5\n\ngoal (1 subgoal):\n 1. gso_array.gso'_array (d\\<mu>_impl fs) fs =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i5 < length fs;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.gso' ?i5 (IArray fs) ?gsa5 (d\\<mu>_impl fs) =\n                    gso_int ?i5 ?i5", "have *: \"gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n         IArray (IArray.list_of gsa @ (map (\\<lambda>k. gso_int k k) [i..<n]))\"\n    if \"n \\<le> length fs\"\n       \"gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\" for i n gsa"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i5 < length fs;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.gso' ?i5 (IArray fs) ?gsa5 (d\\<mu>_impl fs) =\n                    gso_int ?i5 ?i5\n\ngoal (1 subgoal):\n 1. gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n    IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i5 < length fs;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.gso' ?i5 (IArray fs) ?gsa5 (d\\<mu>_impl fs) =\n                    gso_int ?i5 ?i5\n  n \\<le> length fs\n  gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\n\ngoal (1 subgoal):\n 1. gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n    IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])", "proof (induction i n \"(d\\<mu>_impl fs)\" \"(IArray fs)\" gsa rule: gso_array.gsos'.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "case (1 i n gsa)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> n \\<le> i;\n   \\<And>i gsa.\n      \\<lbrakk>i < length fs;\n       \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n      \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) =\n                        gso_int i i;\n   n \\<le> length fs;\n   iarray_append gsa (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n   IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n  \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n                     (iarray_append gsa\n                       (gso_array.gso' i (IArray fs) gsa\n                         (d\\<mu>_impl fs))) =\n                    IArray\n                     (IArray.list_of\n                       (iarray_append gsa\n                         (gso_array.gso' i (IArray fs) gsa\n                           (d\\<mu>_impl fs))) @\n                      map (\\<lambda>k. gso_int k k) [i + 1..<n])\n  \\<lbrakk>?i5 < length fs;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.gso' ?i5 (IArray fs) ?gsa5 (d\\<mu>_impl fs) =\n                    gso_int ?i5 ?i5\n  n \\<le> length fs\n  gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\n\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> n \\<le> i;\n   \\<And>i gsa.\n      \\<lbrakk>i < length fs;\n       \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n      \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) =\n                        gso_int i i;\n   n \\<le> length fs;\n   iarray_append gsa (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n   IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n  \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n                     (iarray_append gsa\n                       (gso_array.gso' i (IArray fs) gsa\n                         (d\\<mu>_impl fs))) =\n                    IArray\n                     (IArray.list_of\n                       (iarray_append gsa\n                         (gso_array.gso' i (IArray fs) gsa\n                           (d\\<mu>_impl fs))) @\n                      map (\\<lambda>k. gso_int k k) [i + 1..<n])\n  \\<lbrakk>?i5 < length fs;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.gso' ?i5 (IArray fs) ?gsa5 (d\\<mu>_impl fs) =\n                    gso_int ?i5 ?i5\n  n \\<le> length fs\n  gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\n\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "assume i_n: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "have [simp]: \"gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i", "using 1 i_n"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> n \\<le> i;\n   \\<And>i gsa.\n      \\<lbrakk>i < length fs;\n       \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n      \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) =\n                        gso_int i i;\n   n \\<le> length fs;\n   iarray_append gsa (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n   IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n  \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n                     (iarray_append gsa\n                       (gso_array.gso' i (IArray fs) gsa\n                         (d\\<mu>_impl fs))) =\n                    IArray\n                     (IArray.list_of\n                       (iarray_append gsa\n                         (gso_array.gso' i (IArray fs) gsa\n                           (d\\<mu>_impl fs))) @\n                      map (\\<lambda>k. gso_int k k) [i + 1..<n])\n  \\<lbrakk>?i5 < length fs;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.gso' ?i5 (IArray fs) ?gsa5 (d\\<mu>_impl fs) =\n                    gso_int ?i5 ?i5\n  n \\<le> length fs\n  gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\n  i < n\n\ngoal (1 subgoal):\n 1. gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i", "by (intro *) auto"], ["proof (state)\nthis:\n  gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) = gso_int i i\n\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "have \"gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa = gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs) (iarray_append gsa (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n    gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n     (iarray_append gsa (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)))", "using i_n"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n    gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n     (iarray_append gsa (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)))", "by (simp add: gso_array.gsos'.simps)"], ["proof (state)\nthis:\n  gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n  gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n   (iarray_append gsa (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)))\n\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "also"], ["proof (state)\nthis:\n  gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n  gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n   (iarray_append gsa (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)))\n\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "have \"\\<dots> = IArray (IArray.list_of gsa @ gso_int i i # map (\\<lambda>k. gso_int k k) [Suc i..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n     (iarray_append gsa\n       (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) =\n    IArray\n     (IArray.list_of gsa @\n      gso_int i i # map (\\<lambda>k. gso_int k k) [Suc i..<n])", "using 1 i_n"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> n \\<le> i;\n   \\<And>i gsa.\n      \\<lbrakk>i < length fs;\n       \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n      \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs) =\n                        gso_int i i;\n   n \\<le> length fs;\n   iarray_append gsa (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n   IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n  \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n                     (iarray_append gsa\n                       (gso_array.gso' i (IArray fs) gsa\n                         (d\\<mu>_impl fs))) =\n                    IArray\n                     (IArray.list_of\n                       (iarray_append gsa\n                         (gso_array.gso' i (IArray fs) gsa\n                           (d\\<mu>_impl fs))) @\n                      map (\\<lambda>k. gso_int k k) [i + 1..<n])\n  \\<lbrakk>?i5 < length fs;\n   \\<And>k. k < ?i5 \\<Longrightarrow> ?gsa5 !! k = gso_int k k\\<rbrakk>\n  \\<Longrightarrow> gso_array.gso' ?i5 (IArray fs) ?gsa5 (d\\<mu>_impl fs) =\n                    gso_int ?i5 ?i5\n  n \\<le> length fs\n  gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\n  i < n\n\ngoal (1 subgoal):\n 1. gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n     (iarray_append gsa\n       (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) =\n    IArray\n     (IArray.list_of gsa @\n      gso_int i i # map (\\<lambda>k. gso_int k k) [Suc i..<n])", "by (subst 1) (auto simp add: iarray_append_code)"], ["proof (state)\nthis:\n  gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n   (iarray_append gsa (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) =\n  IArray\n   (IArray.list_of gsa @\n    gso_int i i # map (\\<lambda>k. gso_int k k) [Suc i..<n])\n\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "also"], ["proof (state)\nthis:\n  gso_array.gsos' (i + 1) n (d\\<mu>_impl fs) (IArray fs)\n   (iarray_append gsa (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) =\n  IArray\n   (IArray.list_of gsa @\n    gso_int i i # map (\\<lambda>k. gso_int k k) [Suc i..<n])\n\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "have \"\\<dots> = IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray\n     (IArray.list_of gsa @\n      gso_int i i # map (\\<lambda>k. gso_int k k) [Suc i..<n]) =\n    IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])", "using i_n"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. IArray\n     (IArray.list_of gsa @\n      gso_int i i # map (\\<lambda>k. gso_int k k) [Suc i..<n]) =\n    IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])", "by (auto simp add: upt_conv_Cons)"], ["proof (state)\nthis:\n  IArray\n   (IArray.list_of gsa @\n    gso_int i i # map (\\<lambda>k. gso_int k k) [Suc i..<n]) =\n  IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])\n\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "finally"], ["proof (chain)\npicking this:\n  gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n  IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])", "have ?case"], ["proof (prove)\nusing this:\n  gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n  IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])\n\ngoal (1 subgoal):\n 1. gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n    IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])", "by simp"], ["proof (state)\nthis:\n  gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n  IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])\n\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "}"], ["proof (state)\nthis:\n  i < n \\<Longrightarrow>\n  gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n  IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])\n\ngoal (1 subgoal):\n 1. \\<And>i n gsa.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> i;\n                 \\<And>i gsa.\n                    \\<lbrakk>i < length fs;\n                     \\<And>k.\n                        k < i \\<Longrightarrow>\n                        gsa !! k = gso_int k k\\<rbrakk>\n                    \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs) =\ngso_int i i;\n                 n \\<le> length fs;\n                 iarray_append gsa\n                  (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs)) =\n                 IArray.of_fun (\\<lambda>k. gso_int k k) (i + 1)\\<rbrakk>\n                \\<Longrightarrow> gso_array.gsos' (i + 1) n (d\\<mu>_impl fs)\n                                   (IArray fs)\n                                   (iarray_append gsa\n                                     (gso_array.gso' i (IArray fs) gsa\n (d\\<mu>_impl fs))) =\n                                  IArray\n                                   (IArray.list_of\n                                     (iarray_append gsa\n (gso_array.gso' i (IArray fs) gsa (d\\<mu>_impl fs))) @\n                                    map (\\<lambda>k. gso_int k k)\n                                     [i + 1..<n]);\n        \\<And>i gsa.\n           \\<lbrakk>i < length fs;\n            \\<And>k. k < i \\<Longrightarrow> gsa !! k = gso_int k k\\<rbrakk>\n           \\<Longrightarrow> gso_array.gso' i (IArray fs) gsa\n                              (d\\<mu>_impl fs) =\n                             gso_int i i;\n        n \\<le> length fs;\n        gsa = IArray.of_fun (\\<lambda>k. gso_int k k) i\\<rbrakk>\n       \\<Longrightarrow> gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs)\n                          gsa =\n                         IArray\n                          (IArray.list_of gsa @\n                           map (\\<lambda>k. gso_int k k) [i..<n])", "then"], ["proof (chain)\npicking this:\n  i < n \\<Longrightarrow>\n  gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n  IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])", "show ?case"], ["proof (prove)\nusing this:\n  i < n \\<Longrightarrow>\n  gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n  IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])\n\ngoal (1 subgoal):\n 1. gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n    IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])", "by (auto simp add: gso_array.gsos'.simps)"], ["proof (state)\nthis:\n  gso_array.gsos' i n (d\\<mu>_impl fs) (IArray fs) gsa =\n  IArray (IArray.list_of gsa @ map (\\<lambda>k. gso_int k k) [i..<n])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?n5 \\<le> length fs;\n   ?gsa5 = IArray.of_fun (\\<lambda>k. gso_int k k) ?i5\\<rbrakk>\n  \\<Longrightarrow> gso_array.gsos' ?i5 ?n5 (d\\<mu>_impl fs) (IArray fs)\n                     ?gsa5 =\n                    IArray\n                     (IArray.list_of ?gsa5 @\n                      map (\\<lambda>k. gso_int k k) [?i5..<?n5])\n\ngoal (1 subgoal):\n 1. gso_array.gso'_array (d\\<mu>_impl fs) fs =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?n5 \\<le> length fs;\n   ?gsa5 = IArray.of_fun (\\<lambda>k. gso_int k k) ?i5\\<rbrakk>\n  \\<Longrightarrow> gso_array.gsos' ?i5 ?n5 (d\\<mu>_impl fs) (IArray fs)\n                     ?gsa5 =\n                    IArray\n                     (IArray.list_of ?gsa5 @\n                      map (\\<lambda>k. gso_int k k) [?i5..<?n5])", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n5 \\<le> length fs;\n   ?gsa5 = IArray.of_fun (\\<lambda>k. gso_int k k) ?i5\\<rbrakk>\n  \\<Longrightarrow> gso_array.gsos' ?i5 ?n5 (d\\<mu>_impl fs) (IArray fs)\n                     ?gsa5 =\n                    IArray\n                     (IArray.list_of ?gsa5 @\n                      map (\\<lambda>k. gso_int k k) [?i5..<?n5])\n\ngoal (1 subgoal):\n 1. gso_array.gso'_array (d\\<mu>_impl fs) fs =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "unfolding gso_array.gso'_array_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n5 \\<le> length fs;\n   ?gsa5 = IArray.of_fun (\\<lambda>k. gso_int k k) ?i5\\<rbrakk>\n  \\<Longrightarrow> gso_array.gsos' ?i5 ?n5 (d\\<mu>_impl fs) (IArray fs)\n                     ?gsa5 =\n                    IArray\n                     (IArray.list_of ?gsa5 @\n                      map (\\<lambda>k. gso_int k k) [?i5..<?n5])\n\ngoal (1 subgoal):\n 1. gso_array.gsos' 0 (length fs) (d\\<mu>_impl fs) (IArray fs) (IArray []) =\n    IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])", "by (subst *) auto"], ["proof (state)\nthis:\n  gso_array.gso'_array (d\\<mu>_impl fs) fs =\n  IArray (map (\\<lambda>k. gso_int k k) [0..<length fs])\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Lemmas Summarizing All Bounds During GSO Computation\\<close>"], ["", "context gram_schmidt_fs_int\nbegin"], ["", "lemma combined_size_bound_integer:  \n  assumes x: \"x \\<in> {fs ! i $ j | i j. i < m \\<and> j < n} \n    \\<union> {\\<mu>' i j | i j. j \\<le> i \\<and> i < m}\n    \\<union> {\\<sigma> l i j | i j l. i < m \\<and> j \\<le> i \\<and> l \\<le> j}\" \n    (is \"x \\<in> ?fs \\<union> ?\\<mu>' \\<union> ?\\<sigma>\")\n    and m: \"m \\<noteq> 0\"\n  shows \"\\<bar>x\\<bar> \\<le> of_nat m * N ^ (3 * Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "let ?m = \"(of_nat m)::'a::trivial_conjugatable_linordered_field\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have [simp]: \"1 \\<le> ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> of_nat (length fs)", "using m"], ["proof (prove)\nusing this:\n  length fs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> of_nat (length fs)", "by (metis Num.of_nat_simps One_nat_def Suc_leI neq0_conv of_nat_mono)"], ["proof (state)\nthis:\n  (1::'a) \\<le> of_nat (length fs)\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have [simp]: \"\\<bar>(of_int z)::'a::trivial_conjugatable_linordered_field\\<bar> \\<le> (of_int z)\\<^sup>2\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>of_int z\\<bar> \\<le> (of_int z)\\<^sup>2", "using abs_leq_squared"], ["proof (prove)\nusing this:\n  \\<bar>?z\\<bar> \\<le> ?z\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>of_int z\\<bar> \\<le> (of_int z)\\<^sup>2", "by (metis of_int_abs of_int_le_iff of_int_power)"], ["proof (state)\nthis:\n  \\<bar>of_int ?z1\\<bar> \\<le> (of_int ?z1)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have \"\\<bar>fs ! i $ j\\<bar> \\<le> of_nat m * N ^ (3 * Suc m)\" if \"i < m\" \"j < n\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have \"\\<bar>fs ! i $ j\\<bar> \\<le> \\<bar>fs ! i $ j\\<bar>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> \\<bar>fs ! i $ j\\<bar>\\<^sup>2", "by (rule Ints_cases[of \"fs ! i $ j\"]) (use fs_int that in auto)"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar> \\<le> \\<bar>fs ! i $ j\\<bar>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "also"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar> \\<le> \\<bar>fs ! i $ j\\<bar>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have \"\\<bar>fs ! i $ j\\<bar>\\<^sup>2 \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "using that"], ["proof (prove)\nusing this:\n  i < length fs\n  j < n\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "by (intro vec_le_sq_norm) (auto)"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar>\\<^sup>2 \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "also"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar>\\<^sup>2 \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have \"... \\<le> 1 * N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> (1::'a) * N", "using N_fs that"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow>\n  \\<parallel>fs ! ?i\\<parallel>\\<^sup>2 \\<le> N\n  i < length fs\n  j < n\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> (1::'a) * N", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> (1::'a) * N\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "also"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> (1::'a) * N\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have \"\\<dots> \\<le> of_nat m * N ^ (3 * Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) * N \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "using m N_1"], ["proof (prove)\nusing this:\n  length fs \\<noteq> 0\n  set fs \\<noteq> {} \\<Longrightarrow> (1::'a) \\<le> N\n\ngoal (1 subgoal):\n 1. (1::'a) * N \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "by (intro mult_mono) (auto intro!: mult_mono self_le_power)"], ["proof (state)\nthis:\n  (1::'a) * N \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "finally"], ["proof (chain)\npicking this:\n  \\<bar>fs ! i $ j\\<bar>\n  \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>fs ! i $ j\\<bar>\n  \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "by (auto)"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar>\n  \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < length fs; ?j1 < n\\<rbrakk>\n  \\<Longrightarrow> \\<bar>fs ! ?i1 $ ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i1 < length fs; ?j1 < n\\<rbrakk>\n  \\<Longrightarrow> \\<bar>fs ! ?i1 $ ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have \"\\<bar>x\\<bar> \\<le> of_nat m * N ^ (3 * Suc m)\" if \"x \\<in> ?fs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; ?j1 < n\\<rbrakk>\n  \\<Longrightarrow> \\<bar>fs ! ?i1 $ ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; ?j1 < n\\<rbrakk>\n  \\<Longrightarrow> \\<bar>fs ! ?i1 $ ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n}\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "by auto"], ["proof (state)\nthis:\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "moreover"], ["proof (state)\nthis:\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have \"\\<bar>x\\<bar> \\<le> of_nat m * N ^ (3 * Suc m)\" if \"x \\<in> ?\\<mu>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have \"\\<bar>\\<mu>' i j\\<bar> \\<le> of_nat m * N ^ (3 + 3 * m)\" if \"j \\<le> i\" \"i < m\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "have \"\\<mu>' i j \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>' i j \\<in> \\<int>", "unfolding \\<mu>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc j) * \\<mu> i j \\<in> \\<int>", "using that d_mu_Ints"], ["proof (prove)\nusing this:\n  j \\<le> i\n  i < length fs\n  \\<lbrakk>?l \\<le> ?k; ?k < length fs\\<rbrakk>\n  \\<Longrightarrow> d (Suc ?l) * \\<mu> ?k ?l \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. d (Suc j) * \\<mu> i j \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  \\<mu>' i j \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "then"], ["proof (chain)\npicking this:\n  \\<mu>' i j \\<in> \\<int>", "have \"\\<bar>\\<mu>' i j\\<bar> \\<le> (\\<mu>' i j)\\<^sup>2\""], ["proof (prove)\nusing this:\n  \\<mu>' i j \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar> \\<le> (\\<mu>' i j)\\<^sup>2", "by (rule Ints_cases[of \"\\<mu>' i j\"]) auto"], ["proof (state)\nthis:\n  \\<bar>\\<mu>' i j\\<bar> \\<le> (\\<mu>' i j)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "also"], ["proof (state)\nthis:\n  \\<bar>\\<mu>' i j\\<bar> \\<le> (\\<mu>' i j)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "have \"\\<dots> \\<le> N ^ (3 * Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "using that N_\\<mu>'"], ["proof (prove)\nusing this:\n  j \\<le> i\n  i < length fs\n  \\<lbrakk>?i < length fs; ?j \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> (\\<mu>' ?i ?j)\\<^sup>2 \\<le> N ^ (3 * Suc ?j)\n\ngoal (1 subgoal):\n 1. (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)", "by auto"], ["proof (state)\nthis:\n  (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "also"], ["proof (state)\nthis:\n  (\\<mu>' i j)\\<^sup>2 \\<le> N ^ (3 * Suc j)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "have \"\\<dots> \\<le> 1 * N ^ (3 * Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N ^ (3 * Suc j) \\<le> (1::'a) * N ^ (3 * Suc (length fs))", "using that assms N_1"], ["proof (prove)\nusing this:\n  j \\<le> i\n  i < length fs\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n} \\<union>\n          {\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n  set fs \\<noteq> {} \\<Longrightarrow> (1::'a) \\<le> N\n\ngoal (1 subgoal):\n 1. N ^ (3 * Suc j) \\<le> (1::'a) * N ^ (3 * Suc (length fs))", "by (auto intro!: power_increasing)"], ["proof (state)\nthis:\n  N ^ (3 * Suc j) \\<le> (1::'a) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "also"], ["proof (state)\nthis:\n  N ^ (3 * Suc j) \\<le> (1::'a) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "have \"\\<dots> \\<le> of_nat m * N ^ (3 * Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) * N ^ (3 * Suc (length fs))\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "using N_ge_0 assms zero_le_power"], ["proof (prove)\nusing this:\n  0 < length fs \\<Longrightarrow> (0::'a) \\<le> N\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n} \\<union>\n          {\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n  (0::?'a) \\<le> ?a \\<Longrightarrow> (0::?'a) \\<le> ?a ^ ?n\n\ngoal (1 subgoal):\n 1. (1::'a) * N ^ (3 * Suc (length fs))\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "by (intro mult_mono) auto"], ["proof (state)\nthis:\n  (1::'a) * N ^ (3 * Suc (length fs))\n  \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>\\<mu>' i j\\<bar>\n  \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>\\<mu>' i j\\<bar>\n  \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>\\<mu>' i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "by auto"], ["proof (state)\nthis:\n  \\<bar>\\<mu>' i j\\<bar> \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?j1 \\<le> ?i1; ?i1 < length fs\\<rbrakk>\n  \\<Longrightarrow> \\<bar>\\<mu>' ?i1 ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?j1 \\<le> ?i1; ?i1 < length fs\\<rbrakk>\n  \\<Longrightarrow> \\<bar>\\<mu>' ?i1 ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j1 \\<le> ?i1; ?i1 < length fs\\<rbrakk>\n  \\<Longrightarrow> \\<bar>\\<mu>' ?i1 ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j1 \\<le> ?i1; ?i1 < length fs\\<rbrakk>\n  \\<Longrightarrow> \\<bar>\\<mu>' ?i1 ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)\n  x \\<in> {\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs}\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "by auto"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> {\\<mu>' i j |i j.\n           j \\<le> i \\<and> i < length fs} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "moreover"], ["proof (state)\nthis:\n  x \\<in> {\\<mu>' i j |i j.\n           j \\<le> i \\<and> i < length fs} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have \"\\<bar>x\\<bar> \\<le> of_nat m * N ^ (3 * Suc m)\" if \"x \\<in> ?\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have \"\\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat m * N ^ (3 + 3 * m)\" if \"i < m\" \"j \\<le> i\" \"l \\<le> j\" for i j l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "have \"\\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "using that N_\\<sigma>"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n  \\<lbrakk>?i < length fs; ?j \\<le> ?i; ?l \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> \\<bar>\\<sigma> ?l ?i ?j\\<bar>\n                    \\<le> of_nat ?l * N ^ (2 * ?l + 2)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)", "by auto"], ["proof (state)\nthis:\n  \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "also"], ["proof (state)\nthis:\n  \\<bar>\\<sigma> l i j\\<bar> \\<le> of_nat l * N ^ (2 * l + 2)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "have \"\\<dots> \\<le> of_nat m * N ^ (2 * l + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat l * N ^ (2 * l + 2) \\<le> of_nat (length fs) * N ^ (2 * l + 2)", "using that N_ge_0 assms zero_le_power"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n  0 < length fs \\<Longrightarrow> (0::'a) \\<le> N\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n} \\<union>\n          {\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n  (0::?'a) \\<le> ?a \\<Longrightarrow> (0::?'a) \\<le> ?a ^ ?n\n\ngoal (1 subgoal):\n 1. of_nat l * N ^ (2 * l + 2) \\<le> of_nat (length fs) * N ^ (2 * l + 2)", "by (intro mult_mono) auto"], ["proof (state)\nthis:\n  of_nat l * N ^ (2 * l + 2) \\<le> of_nat (length fs) * N ^ (2 * l + 2)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "also"], ["proof (state)\nthis:\n  of_nat l * N ^ (2 * l + 2) \\<le> of_nat (length fs) * N ^ (2 * l + 2)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "have \"\\<dots> \\<le> of_nat m * N ^ (3 * Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (length fs) * N ^ (2 * l + 2)\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat (length fs) * N ^ (2 * l + 2)\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "have \"N ^ (2 * l + 2) \\<le> N ^ (3 * Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N ^ (2 * l + 2) \\<le> N ^ (3 * Suc (length fs))", "using that assms N_1"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n} \\<union>\n          {\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n  set fs \\<noteq> {} \\<Longrightarrow> (1::'a) \\<le> N\n\ngoal (1 subgoal):\n 1. N ^ (2 * l + 2) \\<le> N ^ (3 * Suc (length fs))", "by (intro power_increasing) (auto intro!: power_increasing)"], ["proof (state)\nthis:\n  N ^ (2 * l + 2) \\<le> N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. of_nat (length fs) * N ^ (2 * l + 2)\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "then"], ["proof (chain)\npicking this:\n  N ^ (2 * l + 2) \\<le> N ^ (3 * Suc (length fs))", "show ?thesis"], ["proof (prove)\nusing this:\n  N ^ (2 * l + 2) \\<le> N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. of_nat (length fs) * N ^ (2 * l + 2)\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "using that assms N_1"], ["proof (prove)\nusing this:\n  N ^ (2 * l + 2) \\<le> N ^ (3 * Suc (length fs))\n  i < length fs\n  j \\<le> i\n  l \\<le> j\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n} \\<union>\n          {\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n  set fs \\<noteq> {} \\<Longrightarrow> (1::'a) \\<le> N\n\ngoal (1 subgoal):\n 1. of_nat (length fs) * N ^ (2 * l + 2)\n    \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "by (intro mult_mono) (auto)"], ["proof (state)\nthis:\n  of_nat (length fs) * N ^ (2 * l + 2)\n  \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_nat (length fs) * N ^ (2 * l + 2)\n  \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>\\<sigma> l i j\\<bar>\n  \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>\\<sigma> l i j\\<bar>\n  \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>\\<sigma> l i j\\<bar>\n    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "by simp"], ["proof (state)\nthis:\n  \\<bar>\\<sigma> l i j\\<bar>\n  \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < length fs; ?j1 \\<le> ?i1; ?l1 \\<le> ?j1\\<rbrakk>\n  \\<Longrightarrow> \\<bar>\\<sigma> ?l1 ?i1 ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i1 < length fs; ?j1 \\<le> ?i1; ?l1 \\<le> ?j1\\<rbrakk>\n  \\<Longrightarrow> \\<bar>\\<sigma> ?l1 ?i1 ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; ?j1 \\<le> ?i1; ?l1 \\<le> ?j1\\<rbrakk>\n  \\<Longrightarrow> \\<bar>\\<sigma> ?l1 ?i1 ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; ?j1 \\<le> ?i1; ?l1 \\<le> ?j1\\<rbrakk>\n  \\<Longrightarrow> \\<bar>\\<sigma> ?l1 ?i1 ?j1\\<bar>\n                    \\<le> of_nat (length fs) * N ^ (3 + 3 * length fs)\n  x \\<in> {\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "by (auto)"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> {\\<sigma> l i j |i j l.\n           i < length fs \\<and>\n           j \\<le> i \\<and> l \\<le> j} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n  x \\<in> {\\<mu>' i j |i j.\n           j \\<le> i \\<and> i < length fs} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n  x \\<in> {\\<sigma> l i j |i j l.\n           i < length fs \\<and>\n           j \\<le> i \\<and> l \\<le> j} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n  x \\<in> {\\<mu>' i j |i j.\n           j \\<le> i \\<and> i < length fs} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n  x \\<in> {\\<sigma> l i j |i j l.\n           i < length fs \\<and>\n           j \\<le> i \\<and> l \\<le> j} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n  x \\<in> {\\<mu>' i j |i j.\n           j \\<le> i \\<and> i < length fs} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n  x \\<in> {\\<sigma> l i j |i j l.\n           i < length fs \\<and>\n           j \\<le> i \\<and> l \\<le> j} \\<Longrightarrow>\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n  x \\<in> {fs ! i $ j |i j. i < length fs \\<and> j < n} \\<union>\n          {\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))", "by auto"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> of_nat (length fs) * N ^ (3 * Suc (length fs))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* gram_schmidt_fs_int *)\n\n (* \"x \\<noteq> 0 \\<Longrightarrow> log 2 \\<bar>x\\<bar> \\<le> 2 * m * log 2 N       + m + log 2 m\" (is \"_ \\<Longrightarrow> ?l1 \\<le> ?b1\")\n  \"x \\<noteq> 0 \\<Longrightarrow> log 2 \\<bar>x\\<bar> \\<le> 4 * m * log 2 (M * n) + m + log 2 m\" (is \"_ \\<Longrightarrow> _ \\<le> ?b2\") *)"], ["", "context fs_int_indpt\nbegin"], ["", "lemma combined_size_bound_rat_log:  \n  assumes x: \"x \\<in> {gs.\\<mu>' i j | i j. j \\<le> i \\<and> i < m}\n    \\<union> {gs.\\<sigma> l i j | i j l. i < m \\<and> j \\<le> i \\<and> l \\<le> j}\" \n    (is \"x \\<in> ?\\<mu>' \\<union> ?\\<sigma>\")\n    and m: \"m \\<noteq> 0\" \"x \\<noteq> 0\"\n  shows \"log 2 \\<bar>real_of_rat x\\<bar> \\<le> log 2 m + (3 + 3 * m) * log 2 (real_of_rat gs.N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "let ?r_fs = \"map of_int_hom.vec_hom fs::rat vec list\""], ["proof (state)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "have 1: \"map of_int_hom.vec_hom fs ! i $ j = of_int (fs ! i $ j)\" if \"i < m\" \"j < n\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i $ j = of_int (fs ! i $ j)", "using that"], ["proof (prove)\nusing this:\n  i < length fs\n  j < n\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i $ j = of_int (fs ! i $ j)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < length fs; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> map of_int_hom.vec_hom fs ! ?i2 $ ?j2 =\n                    of_int (fs ! ?i2 $ ?j2)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < length fs; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> map of_int_hom.vec_hom fs ! ?i2 $ ?j2 =\n                    of_int (fs ! ?i2 $ ?j2)", "have \"{?r_fs ! i $ j |i j. i < length ?r_fs \\<and> j < n} = \n             {rat_of_int (fs ! i $ j) |i j. i < length fs \\<and> j < n}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < length fs; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> map of_int_hom.vec_hom fs ! ?i2 $ ?j2 =\n                    of_int (fs ! ?i2 $ ?j2)\n\ngoal (1 subgoal):\n 1. {map of_int_hom.vec_hom fs ! i $ j |i j.\n     i < length (map of_int_hom.vec_hom fs) \\<and> j < n} =\n    {rat_of_int (fs ! i $ j) |i j. i < length fs \\<and> j < n}", "by (metis (mono_tags, hide_lams) length_map)"], ["proof (state)\nthis:\n  {map of_int_hom.vec_hom fs ! i $ j |i j.\n   i < length (map of_int_hom.vec_hom fs) \\<and> j < n} =\n  {rat_of_int (fs ! i $ j) |i j. i < length fs \\<and> j < n}\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "then"], ["proof (chain)\npicking this:\n  {map of_int_hom.vec_hom fs ! i $ j |i j.\n   i < length (map of_int_hom.vec_hom fs) \\<and> j < n} =\n  {rat_of_int (fs ! i $ j) |i j. i < length fs \\<and> j < n}", "have \"x \\<in> {?r_fs ! i $ j |i j. i < length (map of_int_hom.vec_hom fs) \\<and> j < n}\n                 \\<union> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length ?r_fs}\n                 \\<union> {gs.\\<sigma> l i j |i j l. i < length ?r_fs \\<and> j \\<le> i \\<and> l \\<le> j}\""], ["proof (prove)\nusing this:\n  {map of_int_hom.vec_hom fs ! i $ j |i j.\n   i < length (map of_int_hom.vec_hom fs) \\<and> j < n} =\n  {rat_of_int (fs ! i $ j) |i j. i < length fs \\<and> j < n}\n\ngoal (1 subgoal):\n 1. x \\<in> {map of_int_hom.vec_hom fs ! i $ j |i j.\n             i < length (map of_int_hom.vec_hom fs) \\<and> j < n} \\<union>\n            {gs.\\<mu>' i j |i j.\n             j \\<le> i \\<and>\n             i < length (map of_int_hom.vec_hom fs)} \\<union>\n            {gs.\\<sigma> l i j |i j l.\n             i < length (map of_int_hom.vec_hom fs) \\<and>\n             j \\<le> i \\<and> l \\<le> j}", "using assms"], ["proof (prove)\nusing this:\n  {map of_int_hom.vec_hom fs ! i $ j |i j.\n   i < length (map of_int_hom.vec_hom fs) \\<and> j < n} =\n  {rat_of_int (fs ! i $ j) |i j. i < length fs \\<and> j < n}\n  x \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> {map of_int_hom.vec_hom fs ! i $ j |i j.\n             i < length (map of_int_hom.vec_hom fs) \\<and> j < n} \\<union>\n            {gs.\\<mu>' i j |i j.\n             j \\<le> i \\<and>\n             i < length (map of_int_hom.vec_hom fs)} \\<union>\n            {gs.\\<sigma> l i j |i j l.\n             i < length (map of_int_hom.vec_hom fs) \\<and>\n             j \\<le> i \\<and> l \\<le> j}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {map of_int_hom.vec_hom fs ! i $ j |i j.\n           i < length (map of_int_hom.vec_hom fs) \\<and> j < n} \\<union>\n          {gs.\\<mu>' i j |i j.\n           j \\<le> i \\<and> i < length (map of_int_hom.vec_hom fs)} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length (map of_int_hom.vec_hom fs) \\<and>\n           j \\<le> i \\<and> l \\<le> j}\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "then"], ["proof (chain)\npicking this:\n  x \\<in> {map of_int_hom.vec_hom fs ! i $ j |i j.\n           i < length (map of_int_hom.vec_hom fs) \\<and> j < n} \\<union>\n          {gs.\\<mu>' i j |i j.\n           j \\<le> i \\<and> i < length (map of_int_hom.vec_hom fs)} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length (map of_int_hom.vec_hom fs) \\<and>\n           j \\<le> i \\<and> l \\<le> j}", "have 1: \"\\<bar>x\\<bar> \\<le> rat_of_nat (length ?r_fs) * gs.N ^ (3 * Suc (length ?r_fs))\" (is \"?ax \\<le> ?t\")"], ["proof (prove)\nusing this:\n  x \\<in> {map of_int_hom.vec_hom fs ! i $ j |i j.\n           i < length (map of_int_hom.vec_hom fs) \\<and> j < n} \\<union>\n          {gs.\\<mu>' i j |i j.\n           j \\<le> i \\<and> i < length (map of_int_hom.vec_hom fs)} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length (map of_int_hom.vec_hom fs) \\<and>\n           j \\<le> i \\<and> l \\<le> j}\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar>\n    \\<le> rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n          gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> {map of_int_hom.vec_hom fs ! i $ j |i j.\n           i < length (map of_int_hom.vec_hom fs) \\<and> j < n} \\<union>\n          {gs.\\<mu>' i j |i j.\n           j \\<le> i \\<and> i < length (map of_int_hom.vec_hom fs)} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length (map of_int_hom.vec_hom fs) \\<and>\n           j \\<le> i \\<and> l \\<le> j}\n  x \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar>\n    \\<le> rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n          gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))", "by (intro gs.combined_size_bound_integer) auto"], ["proof (state)\nthis:\n  \\<bar>x\\<bar>\n  \\<le> rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n        gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "then"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar>\n  \\<le> rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n        gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))", "have 1: \"real_of_rat ?ax \\<le> real_of_rat ?t\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar>\n  \\<le> rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n        gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))\n\ngoal (1 subgoal):\n 1. real_of_rat \\<bar>x\\<bar>\n    \\<le> real_of_rat\n           (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n            gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs))))", "using of_rat_less_eq 1"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar>\n  \\<le> rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n        gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))\n  (of_rat ?r \\<le> of_rat ?s) = (?r \\<le> ?s)\n  \\<bar>x\\<bar>\n  \\<le> rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n        gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))\n\ngoal (1 subgoal):\n 1. real_of_rat \\<bar>x\\<bar>\n    \\<le> real_of_rat\n           (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n            gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs))))", "by auto"], ["proof (state)\nthis:\n  real_of_rat \\<bar>x\\<bar>\n  \\<le> real_of_rat\n         (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n          gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs))))\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "have 2: \"\\<bar>real_of_rat x\\<bar> = real_of_rat \\<bar>x\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of_rat x\\<bar> = real_of_rat \\<bar>x\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<bar>real_of_rat x\\<bar> = real_of_rat \\<bar>x\\<bar>\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "have \"log 2 \\<bar>real_of_rat x\\<bar> \\<le> log 2 (real_of_rat ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2\n           (real_of_rat\n             (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n              gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2\n           (real_of_rat\n             (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n              gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))))", "have \"0 < rat_of_nat (length fs) * gs.N ^ (3 + 3 * length fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < rat_of_nat (length fs) * gs.N ^ (3 + 3 * length fs)", "using assms gs.N_1"], ["proof (prove)\nusing this:\n  x \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n  x \\<noteq> 0\n  set (map of_int_hom.vec_hom fs) \\<noteq> {} \\<Longrightarrow> 1 \\<le> gs.N\n\ngoal (1 subgoal):\n 1. 0 < rat_of_nat (length fs) * gs.N ^ (3 + 3 * length fs)", "by (auto)"], ["proof (state)\nthis:\n  0 < rat_of_nat (length fs) * gs.N ^ (3 + 3 * length fs)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2\n           (real_of_rat\n             (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n              gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))))", "then"], ["proof (chain)\npicking this:\n  0 < rat_of_nat (length fs) * gs.N ^ (3 + 3 * length fs)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < rat_of_nat (length fs) * gs.N ^ (3 + 3 * length fs)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2\n           (real_of_rat\n             (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n              gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))))", "using 1 assms"], ["proof (prove)\nusing this:\n  0 < rat_of_nat (length fs) * gs.N ^ (3 + 3 * length fs)\n  real_of_rat \\<bar>x\\<bar>\n  \\<le> real_of_rat\n         (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n          gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs))))\n  x \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2\n           (real_of_rat\n             (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n              gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))))", "by (subst log_le_cancel_iff) (auto)"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_rat x\\<bar>\n  \\<le> log 2\n         (real_of_rat\n           (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n            gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_rat x\\<bar>\n  \\<le> log 2\n         (real_of_rat\n           (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n            gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))))\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "also"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_rat x\\<bar>\n  \\<le> log 2\n         (real_of_rat\n           (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n            gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))))\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "have \"real_of_rat ?t = real m * real_of_rat gs.N ^ (3 + 3 * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat\n     (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n      gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))) =\n    real (length fs) * real_of_rat gs.N ^ (3 + 3 * length fs)", "by (auto simp add: of_rat_mult of_rat_power)"], ["proof (state)\nthis:\n  real_of_rat\n   (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n    gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))) =\n  real (length fs) * real_of_rat gs.N ^ (3 + 3 * length fs)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "also"], ["proof (state)\nthis:\n  real_of_rat\n   (rat_of_nat (length (map of_int_hom.vec_hom fs)) *\n    gs.N ^ (3 * Suc (length (map of_int_hom.vec_hom fs)))) =\n  real (length fs) * real_of_rat gs.N ^ (3 + 3 * length fs)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "have \"log 2 (m * real_of_rat gs.N ^ (3 + 3 * m)) = log 2 m + log 2 (real_of_rat gs.N ^ (3 + 3 * m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (length fs) * real_of_rat gs.N ^ (3 + 3 * length fs)) =\n    log 2 (real (length fs)) +\n    log 2 (real_of_rat gs.N ^ (3 + 3 * length fs))", "using gs.N_1 assms"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs) \\<noteq> {} \\<Longrightarrow> 1 \\<le> gs.N\n  x \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. log 2 (real (length fs) * real_of_rat gs.N ^ (3 + 3 * length fs)) =\n    log 2 (real (length fs)) +\n    log 2 (real_of_rat gs.N ^ (3 + 3 * length fs))", "by (subst log_mult) auto"], ["proof (state)\nthis:\n  log 2 (real (length fs) * real_of_rat gs.N ^ (3 + 3 * length fs)) =\n  log 2 (real (length fs)) + log 2 (real_of_rat gs.N ^ (3 + 3 * length fs))\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "also"], ["proof (state)\nthis:\n  log 2 (real (length fs) * real_of_rat gs.N ^ (3 + 3 * length fs)) =\n  log 2 (real (length fs)) + log 2 (real_of_rat gs.N ^ (3 + 3 * length fs))\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "have \"log 2 (real_of_rat gs.N ^ (3 + 3 * m)) = real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real_of_rat gs.N ^ (3 + 3 * length fs)) =\n    real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "using gs.N_1 assms"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs) \\<noteq> {} \\<Longrightarrow> 1 \\<le> gs.N\n  x \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n  length fs \\<noteq> 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. log 2 (real_of_rat gs.N ^ (3 + 3 * length fs)) =\n    real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "by (subst log_nat_power) auto"], ["proof (state)\nthis:\n  log 2 (real_of_rat gs.N ^ (3 + 3 * length fs)) =\n  real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "finally"], ["proof (chain)\npicking this:\n  log 2 \\<bar>real_of_rat x\\<bar>\n  \\<le> log 2 (real (length fs)) +\n        real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "show ?thesis"], ["proof (prove)\nusing this:\n  log 2 \\<bar>real_of_rat x\\<bar>\n  \\<le> log 2 (real (length fs)) +\n        real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_rat x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "by (auto)"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_rat x\\<bar>\n  \\<le> log 2 (real (length fs)) +\n        real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma combined_size_bound_integer_log:  \n  assumes x: \"x \\<in> {\\<mu>' i j | i j. j \\<le> i \\<and> i < m}\n    \\<union> {\\<sigma>s l i j | i j l. i < m \\<and> j \\<le> i \\<and> l < j}\" \n    (is \"x \\<in> ?\\<mu>' \\<union> ?\\<sigma>\")\n    and m: \"m \\<noteq> 0\" \"x \\<noteq> 0\"\n  shows \"log 2 \\<bar>real_of_int x\\<bar> \\<le> log 2 m + (3 + 3 * m) * log 2 (real_of_rat gs.N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "let ?x = \"rat_of_int x\""], ["proof (state)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "from m"], ["proof (chain)\npicking this:\n  length fs \\<noteq> 0\n  x \\<noteq> 0", "have m: \"m \\<noteq> 0\" \"?x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  length fs \\<noteq> 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length fs \\<noteq> 0 &&& rat_of_int x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length fs \\<noteq> 0\n  rat_of_int x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> log 2 (real (length fs)) +\n          real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)", "proof (rule order_trans[OF _ combined_size_bound_rat_log[OF _ m]], force)"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int x\n    \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}", "from x"], ["proof (chain)\npicking this:\n  x \\<in> {\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {\\<sigma>s l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l < j}", "consider (1) i j where \"x = \\<mu>' i j\" \"j \\<le> i\" \"i < m\" \n      | (2) l i j where \"x = \\<sigma>s l i j\" \"i < m\" \"j \\<le> i\" \"l < j\""], ["proof (prove)\nusing this:\n  x \\<in> {\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {\\<sigma>s l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l < j}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i j.\n                \\<lbrakk>x = \\<mu>' i j; j \\<le> i; i < length fs\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>l i j.\n        \\<lbrakk>x = \\<sigma>s l i j; i < length fs; j \\<le> i;\n         l < j\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i j.\n              \\<lbrakk>x = \\<mu>' i j; j \\<le> i; i < length fs\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   \\<And>l i j.\n      \\<lbrakk>x = \\<sigma>s l i j; i < length fs; j \\<le> i; l < j\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. rat_of_int x\n    \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}", "thus \"?x \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union> {gs.\\<sigma> l i j |i j l. i < m \\<and> j \\<le> i \\<and> l \\<le> j}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i j.\n              \\<lbrakk>x = \\<mu>' i j; j \\<le> i; i < length fs\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   \\<And>l i j.\n      \\<lbrakk>x = \\<sigma>s l i j; i < length fs; j \\<le> i; l < j\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. rat_of_int x\n    \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>x = \\<mu>' i j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int x\n                         \\<in> {gs.\\<mu>' i j |i j.\n                                j \\<le> i \\<and> i < length fs} \\<union>\n                               {gs.\\<sigma> l i j |i j l.\n                                i < length fs \\<and>\n                                j \\<le> i \\<and> l \\<le> j}\n 2. \\<And>l i j.\n       \\<lbrakk>x = \\<sigma>s l i j; i < length fs; j \\<le> i;\n        l < j\\<rbrakk>\n       \\<Longrightarrow> rat_of_int x\n                         \\<in> {gs.\\<mu>' i j |i j.\n                                j \\<le> i \\<and> i < length fs} \\<union>\n                               {gs.\\<sigma> l i j |i j l.\n                                i < length fs \\<and>\n                                j \\<le> i \\<and> l \\<le> j}", "case (1 i j)"], ["proof (state)\nthis:\n  x = \\<mu>' i j\n  j \\<le> i\n  i < length fs\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>x = \\<mu>' i j; j \\<le> i; i < length fs\\<rbrakk>\n       \\<Longrightarrow> rat_of_int x\n                         \\<in> {gs.\\<mu>' i j |i j.\n                                j \\<le> i \\<and> i < length fs} \\<union>\n                               {gs.\\<sigma> l i j |i j l.\n                                i < length fs \\<and>\n                                j \\<le> i \\<and> l \\<le> j}\n 2. \\<And>l i j.\n       \\<lbrakk>x = \\<sigma>s l i j; i < length fs; j \\<le> i;\n        l < j\\<rbrakk>\n       \\<Longrightarrow> rat_of_int x\n                         \\<in> {gs.\\<mu>' i j |i j.\n                                j \\<le> i \\<and> i < length fs} \\<union>\n                               {gs.\\<sigma> l i j |i j l.\n                                i < length fs \\<and>\n                                j \\<le> i \\<and> l \\<le> j}", "with \\<sigma>s_\\<mu>'(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length fs; ?j \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' ?i ?j) = gs.\\<mu>' ?i ?j\n  x = \\<mu>' i j\n  j \\<le> i\n  i < length fs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length fs; ?j \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<mu>' ?i ?j) = gs.\\<mu>' ?i ?j\n  x = \\<mu>' i j\n  j \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. rat_of_int x\n    \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}", "by blast"], ["proof (state)\nthis:\n  rat_of_int x\n  \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n        {gs.\\<sigma> l i j |i j l.\n         i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n\ngoal (1 subgoal):\n 1. \\<And>l i j.\n       \\<lbrakk>x = \\<sigma>s l i j; i < length fs; j \\<le> i;\n        l < j\\<rbrakk>\n       \\<Longrightarrow> rat_of_int x\n                         \\<in> {gs.\\<mu>' i j |i j.\n                                j \\<le> i \\<and> i < length fs} \\<union>\n                               {gs.\\<sigma> l i j |i j l.\n                                i < length fs \\<and>\n                                j \\<le> i \\<and> l \\<le> j}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l i j.\n       \\<lbrakk>x = \\<sigma>s l i j; i < length fs; j \\<le> i;\n        l < j\\<rbrakk>\n       \\<Longrightarrow> rat_of_int x\n                         \\<in> {gs.\\<mu>' i j |i j.\n                                j \\<le> i \\<and> i < length fs} \\<union>\n                               {gs.\\<sigma> l i j |i j l.\n                                i < length fs \\<and>\n                                j \\<le> i \\<and> l \\<le> j}", "case (2 l i j)"], ["proof (state)\nthis:\n  x = \\<sigma>s l i j\n  i < length fs\n  j \\<le> i\n  l < j\n\ngoal (1 subgoal):\n 1. \\<And>l i j.\n       \\<lbrakk>x = \\<sigma>s l i j; i < length fs; j \\<le> i;\n        l < j\\<rbrakk>\n       \\<Longrightarrow> rat_of_int x\n                         \\<in> {gs.\\<mu>' i j |i j.\n                                j \\<le> i \\<and> i < length fs} \\<union>\n                               {gs.\\<sigma> l i j |i j l.\n                                i < length fs \\<and>\n                                j \\<le> i \\<and> l \\<le> j}", "hence \"Suc l \\<le> j\""], ["proof (prove)\nusing this:\n  x = \\<sigma>s l i j\n  i < length fs\n  j \\<le> i\n  l < j\n\ngoal (1 subgoal):\n 1. Suc l \\<le> j", "by auto"], ["proof (state)\nthis:\n  Suc l \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>l i j.\n       \\<lbrakk>x = \\<sigma>s l i j; i < length fs; j \\<le> i;\n        l < j\\<rbrakk>\n       \\<Longrightarrow> rat_of_int x\n                         \\<in> {gs.\\<mu>' i j |i j.\n                                j \\<le> i \\<and> i < length fs} \\<union>\n                               {gs.\\<sigma> l i j |i j l.\n                                i < length fs \\<and>\n                                j \\<le> i \\<and> l \\<le> j}", "from \\<sigma>s_\\<mu>'(1) 2 this"], ["proof (chain)\npicking this:\n  \\<lbrakk>?l < ?j; ?j \\<le> ?i; ?i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s ?l ?i ?j) =\n                    gs.\\<sigma> (Suc ?l) ?i ?j\n  x = \\<sigma>s l i j\n  i < length fs\n  j \\<le> i\n  l < j\n  Suc l \\<le> j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l < ?j; ?j \\<le> ?i; ?i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (\\<sigma>s ?l ?i ?j) =\n                    gs.\\<sigma> (Suc ?l) ?i ?j\n  x = \\<sigma>s l i j\n  i < length fs\n  j \\<le> i\n  l < j\n  Suc l \\<le> j\n\ngoal (1 subgoal):\n 1. rat_of_int x\n    \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n          {gs.\\<sigma> l i j |i j l.\n           i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}", "by blast"], ["proof (state)\nthis:\n  rat_of_int x\n  \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n        {gs.\\<sigma> l i j |i j l.\n         i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rat_of_int x\n  \\<in> {gs.\\<mu>' i j |i j. j \\<le> i \\<and> i < length fs} \\<union>\n        {gs.\\<sigma> l i j |i j l.\n         i < length fs \\<and> j \\<le> i \\<and> l \\<le> j}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> log 2 (real (length fs)) +\n        real (3 + 3 * length fs) * log 2 (real_of_rat gs.N)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}