{"file_name": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction/Gram_Schmidt_2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction", "problem_names": ["lemma find_index_not_in_set: \"x \\<notin> set xs \\<longleftrightarrow> find_index xs x = length xs\"", "lemma find_index_in_set: \"x \\<in> set xs \\<Longrightarrow> xs ! (find_index xs x) = x\"", "lemma find_index_inj: \"inj_on (find_index xs) (set xs)\"", "lemma find_index_leq_length: \"find_index xs x < length xs \\<longleftrightarrow> x \\<in> set xs\"", "lemma rev_unsimp: \"rev xs @ (r # rs) = rev (r#xs) @ rs\"", "lemma corthogonal_is_orthogonal[simp]: \n  \"corthogonal (xs :: 'a :: trivial_conjugatable_ordered_field vec list) = orthogonal xs\"", "lemma lattice_of_finsum:\n  assumes \"set fs \\<subseteq> carrier_vec n\"\n  shows \"lattice_of fs = range (\\<lambda> c. finsum V (\\<lambda> i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) {0 ..< length fs})\"", "lemma in_latticeE: assumes \"f \\<in> lattice_of fs\" obtains c where\n    \"f = sumlist (map (\\<lambda> i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0 ..< length fs])\"", "lemma in_latticeI: assumes \"f = sumlist (map (\\<lambda> i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0 ..< length fs])\" \n  shows \"f \\<in> lattice_of fs\"", "lemma finsum_over_indexes_to_vectors:\n  assumes \"set vs \\<subseteq> carrier_vec n\" \"l = length vs\"\n  shows \"\\<exists>c. (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v)\"", "lemma lattice_of_altdef:\n  assumes \"set vs \\<subseteq> carrier_vec n\"\n  shows \"lattice_of vs = range (\\<lambda>c. \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v)\"", "lemma basis_in_latticeI:\n  assumes fs: \"set fs \\<subseteq> carrier_vec n\" and \"f \\<in> set fs\" \n  shows \"f \\<in> lattice_of fs\"", "lemma lattice_of_eq_set:\n  assumes \"set fs = set gs\" \"set fs \\<subseteq> carrier_vec n\"\n  shows \"lattice_of fs = lattice_of gs\"", "lemma lattice_of_swap: assumes fs: \"set fs \\<subseteq> carrier_vec n\" \n  and ij: \"i < length fs\" \"j < length fs\" \"i \\<noteq> j\" \n  and gs: \"gs = fs[ i := fs ! j, j := fs ! i]\" \nshows \"lattice_of gs = lattice_of fs\"", "lemma lattice_of_add: assumes fs: \"set fs \\<subseteq> carrier_vec n\" \n  and ij: \"i < length fs\" \"j < length fs\" \"i \\<noteq> j\" \n  and gs: \"gs = fs[ i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j]\" \nshows \"lattice_of gs = lattice_of fs\"", "lemma orthogonal_complement_subset:\n  assumes \"A \\<subseteq> B\"\n  shows \"orthogonal_complement B \\<subseteq> orthogonal_complement A\"", "lemma in_orthogonal_complement_span[simp]:\n  assumes [intro]:\"S \\<subseteq> carrier_vec n\"\n  shows \"orthogonal_complement (span S) = orthogonal_complement S\"", "lemma upper_triangular_imp_lin_indpt_list:\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and tri: \"upper_triangular A\"\n    and diag: \"0 \\<notin> set (diag_mat A)\"\n  shows \"lin_indpt_list (rows A)\"", "lemma basis_list_basis: assumes \"basis_list fs\" \n  shows \"distinct fs\" \"lin_indpt (set fs)\" \"basis (set fs)\"", "lemma basis_list_imp_lin_indpt_list: assumes \"basis_list fs\" shows \"lin_indpt_list fs\"", "lemma basis_det_nonzero:\n  assumes db:\"basis (set G)\" and len:\"length G = n\"\n  shows \"det (mat_of_rows n G) \\<noteq> 0\"", "lemma lin_indpt_list_add_vec: assumes  \n      i: \"j < length us\" \"i < length us\" \"i \\<noteq> j\" \n   and indep: \"lin_indpt_list  us\" \nshows \"lin_indpt_list (us [i := us ! i + c \\<cdot>\\<^sub>v us ! j])\" (is \"lin_indpt_list ?V\")", "lemma scalar_prod_lincomb_orthogonal: assumes ortho: \"orthogonal gs\" and gs: \"set gs \\<subseteq> carrier_vec n\"\n  shows \"k \\<le> length gs \\<Longrightarrow> sumlist (map (\\<lambda> i. g i \\<cdot>\\<^sub>v gs ! i) [0 ..< k]) \\<bullet> sumlist (map (\\<lambda> i. h i \\<cdot>\\<^sub>v gs ! i) [0 ..< k])\n  = sum_list (map (\\<lambda> i. g i * h i * (gs ! i \\<bullet> gs ! i)) [0 ..< k])\"", "lemma Gramian_matrix_alt_def: \"k \\<le> length G \\<Longrightarrow> \n  Gramian_matrix G k = (let M = mat_of_rows n (take k G) in M * M\\<^sup>T)\"", "lemma Gramian_determinant_0 [simp]: \"Gramian_determinant G 0 = 1\"", "lemma orthogonal_imp_lin_indpt_list: \n  assumes ortho: \"orthogonal gs\" and gs: \"set gs \\<subseteq> carrier_vec n\"\n  shows \"lin_indpt_list gs\"", "lemma orthocompl_span:\n  assumes \"\\<And> x. x \\<in> S \\<Longrightarrow> v \\<bullet> x = 0\" \"S \\<subseteq> carrier_vec n\" and [intro]: \"v \\<in> carrier_vec n\"\n  and \"y \\<in> span S\" \n  shows \"v \\<bullet> y = 0\"", "lemma orthogonal_sumlist:\n  assumes ortho: \"\\<And> x. x \\<in> set S \\<Longrightarrow> v \\<bullet> x = 0\" and S: \"set S \\<subseteq> carrier_vec n\" and v: \"v \\<in> carrier_vec n\"\n  shows \"v \\<bullet> sumlist S = 0\"", "lemma oc_projection_alt_def:\n  assumes carr:\"(W::'a vec set) \\<subseteq> carrier_vec n\" \"x \\<in> carrier_vec n\"\n      and alt1:\"y1 \\<in> W\" \"x - y1 \\<in> orthogonal_complement W\"\n      and alt2:\"y2 \\<in> W\" \"x - y2 \\<in> orthogonal_complement W\"\n  shows  \"y1 = y2\"", "lemma is_oc_projection_sq_norm: assumes \"is_oc_projection w S v\"\n  and S: \"S \\<subseteq> carrier_vec n\" \n  and v: \"v \\<in> carrier_vec n\" \nshows \"sq_norm w \\<le> sq_norm v\"", "lemma inv_in_span:\n  assumes incarr[intro]:\"U \\<subseteq> carrier_vec n\" and insp:\"a \\<in> span U\"\n  shows \"- a \\<in> span U\"", "lemma non_span_det_zero:\n  assumes len: \"length G = n\"\n  and nonb:\"\\<not> (carrier_vec n \\<subseteq> span (set G))\"\n  and carr:\"set G \\<subseteq> carrier_vec n\"\n  shows \"det (mat_of_rows n G) = 0\"", "lemma span_basis_det_zero_iff:\nassumes \"length G = n\" \"set G \\<subseteq> carrier_vec n\"\nshows \"carrier_vec n \\<subseteq> span (set G) \\<longleftrightarrow> det (mat_of_rows n G) \\<noteq> 0\" (is ?q1)\n      \"carrier_vec n \\<subseteq> span (set G) \\<longleftrightarrow> basis (set G)\" (is ?q2)\n      \"det (mat_of_rows n G) \\<noteq> 0 \\<longleftrightarrow> basis (set G)\" (is ?q3)", "lemma lin_indpt_list_nonzero:\n  assumes \"lin_indpt_list G\" \n  shows \"0\\<^sub>v n \\<notin> set G\"", "lemma is_oc_projection_eq:\n  assumes ispr:\"is_oc_projection a S v\" \"is_oc_projection b S v\" \n    and carr: \"S \\<subseteq> carrier_vec n\" \"v \\<in> carrier_vec n\"\n  shows \"a = b\"", "lemma gso_carrier'[intro]:\n  assumes \"\\<And> i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n\"\n  shows \"gso j \\<in> carrier_vec n\"", "lemma adjuster_wit: assumes res: \"adjuster_wit wits w us = (wits',a)\"\n  and w: \"w \\<in> carrier_vec n\"\n    and us: \"\\<And> i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n\"\n    and us_gs: \"us = map gso (rev [0 ..< j])\" \n    and wits: \"wits = map (\\<mu> i) [j ..< i]\" \n    and j: \"j \\<le> n\" \"j \\<le> i\" \n    and wi: \"w = fs ! i\" \n  shows \"adjuster n w us = a \\<and> a \\<in> carrier_vec n \\<and> wits' = map (\\<mu> i) [0 ..< i] \\<and>\n      (a = sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]))\"", "lemma sub2_wit:\n  assumes \"set us \\<subseteq> carrier_vec n\" \"set ws \\<subseteq> carrier_vec n\" \"length us + length ws = m\" \n    and \"ws = map (\\<lambda> i. fs ! i) [i ..< m]\"\n    and \"us = map gso (rev [0 ..< i])\" \n    and us: \"\\<And> j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\"\n    and mn: \"m \\<le> n\" \n  shows \"sub2_wit us ws = (wits,vvs) \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \n    \\<and> vvs = map gso [i ..< m] \\<and> wits = map (\\<lambda> i. map (\\<mu> i) [0..<i]) [i ..< m]\"", "lemma partial_connect: fixes vs\n  assumes \"length fs = m\" \"k \\<le> m\" \"m \\<le> n\" \"set us \\<subseteq> carrier_vec n\" \"snd (main us) = vs\" \n  \"us = take k fs\" \"set fs \\<subseteq> carrier_vec n\"\nshows \"gram_schmidt n us = vs\" \n    \"vs = map gso [0..<k]\"", "lemma adjuster_wit_small:\n  \"(adjuster_wit v a xs) = (x1,x2)\n  \\<longleftrightarrow> (fst (adjuster_wit v a xs) = x1 \\<and> x2 = adjuster n a xs)\"", "lemma sub2: \"rev xs @ snd (sub2_wit xs us) = rev (gram_schmidt_sub n xs us)\"", "lemma gso_connect: \"snd (main us) = gram_schmidt n us\"", "lemma f_carrier[simp]: \"i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n\"", "lemma gso_carrier[simp]: \"i < m \\<Longrightarrow> gso i \\<in> carrier_vec n\"", "lemma gso_dim[simp]: \"i < m \\<Longrightarrow> dim_vec (gso i) = n\"", "lemma f_dim[simp]: \"i < m \\<Longrightarrow> dim_vec (fs ! i) = n\"", "lemma fs0_gso0: \"0 < m \\<Longrightarrow> fs ! 0 = gso 0\"", "lemma fs_by_gso_def : \nassumes i: \"i < m\"\nshows \"fs ! i = gso i + M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\" (is \"_ = _ + ?sum\")", "lemma main_connect:\n  assumes \"m \\<le> n\"\n  shows \"gram_schmidt n fs = map gso [0..<m]\"", "lemma reduced_gso_E: \"weakly_reduced \\<alpha> k \\<Longrightarrow> k \\<le> m \\<Longrightarrow> Suc i < k \\<Longrightarrow> \n  sq_norm (gso i) \\<le> \\<alpha> * sq_norm (gso (Suc i))\"", "lemma FF_dim[simp]: \"dim_row FF = m\" \"dim_col FF = n\" \"FF \\<in> carrier_mat m n\"", "lemma Fs_dim[simp]: \"dim_row Fs = m\" \"dim_col Fs = n\" \"Fs \\<in> carrier_mat m n\"", "lemma M_dim[simp]: \"dim_row (M m) = m\" \"dim_col (M m) = m\" \"(M m) \\<in> carrier_mat m m\"", "lemma FF_index[simp]: \"i < m \\<Longrightarrow> j < n \\<Longrightarrow> FF $$ (i,j) = fs ! i $ j\"", "lemma M_index[simp]:\"i < m \\<Longrightarrow> j < m \\<Longrightarrow> (M m) $$ (i,j) = \\<mu> i j\"", "lemma matrix_equality: \"FF = (M m) * Fs\"", "lemma fi_is_sum_of_mu_gso: assumes i: \"i < m\" \n  shows \"fs ! i = sumlist (map (\\<lambda> j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0 ..< Suc i])\"", "lemma gi_is_fi_minus_sum_mu_gso:\n  assumes i: \"i < m\" \n  shows \"gso i = fs ! i - sumlist (map (\\<lambda> j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0 ..< i])\" (is \"_ = _ - ?sum\")", "lemma det: assumes m: \"m = n\" shows \"det FF = det Fs\"", "lemmas loc_assms = lin_indpt dist", "lemma mn:\n  shows \"m \\<le> n\"", "lemma\nshows span_gso: \"span (gso ` {0..<m}) = span (set fs)\"\n  and orthogonal_gso: \"orthogonal (map gso [0..<m])\" \n  and dist_gso: \"distinct (map gso [0..<m])\"", "lemma gso_inj[intro]:\n  assumes \"i < m\"\n  shows \"inj_on gso {0..<i}\"", "lemma partial_span:\n  assumes i: \"i \\<le> m\" \n  shows \"span (gso ` {0 ..< i}) = span (set (take i fs))\"", "lemma partial_span': \n  assumes i: \"i \\<le> m\" \n  shows \"span (gso ` {0 ..< i}) = span ((\\<lambda> j. fs ! j) ` {0 ..< i})\"", "lemma orthogonal:\n  assumes \"i < m\" \"j < m\" \"i \\<noteq> j\"\n  shows \"gso i \\<bullet> gso j = 0\"", "lemma same_base:\n  shows \"span (set fs) = span (gso ` {0..<m})\"", "lemma sq_norm_gso_le_f:\n  assumes i: \"i < m\"\n  shows \"sq_norm (gso i) \\<le> sq_norm (fs ! i)\"", "lemma oc_projection_exist:\n  assumes i: \"i < m\" \n  shows \"fs ! i - gso i \\<in> span (gso ` {0..<i})\"", "lemma oc_projection_unique:\n  assumes \"i < m\" \n          \"v \\<in> carrier_vec n\"\n          \"\\<And> x. x \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> x = 0\"\n          \"fs ! i - v \\<in> span (gso ` {0..<i})\"\n  shows \"v = gso i\"", "lemma gso_oc_projection:\n  assumes \"i < m\"\n  shows \"gso i = oc_projection (gso ` {0..<i}) (fs ! i)\"", "lemma gso_oc_projection_span:\n  assumes \"i < m\"\n  shows \"gso i = oc_projection (span (gso ` {0..<i})) (fs ! i)\"\n    and \"is_oc_projection (gso i) (span (gso ` {0..<i})) (fs ! i)\"", "lemma gso_is_oc_projection:\n  assumes \"i < m\"\n  shows \"is_oc_projection (gso i) (set (take i fs)) (fs ! i)\"", "lemma fi_scalar_prod_gso:\n  assumes i: \"i < m\" and j: \"j < m\" \n  shows \"fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2\"", "lemma gso_scalar_zero:\n  assumes \"k < m\" \"i < k\"\n  shows \"(gso k) \\<bullet> (fs ! i) = 0\"", "lemma scalar_prod_lincomb_gso:\n  assumes k: \"k \\<le> m\"\n  shows \"sumlist (map (\\<lambda> i. g i \\<cdot>\\<^sub>v gso i) [0 ..< k]) \\<bullet> sumlist (map (\\<lambda> i. h i \\<cdot>\\<^sub>v gso i) [0 ..< k])\n    = sum_list (map (\\<lambda> i. g i * h i * (gso i \\<bullet> gso i)) [0 ..< k])\"", "lemma gso_times_self_is_norm:\n  assumes \"j < m\"\n  shows \"fs ! j \\<bullet> gso j = sq_norm (gso j)\"", "lemma gram_schmidt_short_vector: \n  assumes in_L: \"h \\<in> lattice_of fs - {0\\<^sub>v n}\" \n  shows \"\\<exists> i < m. \\<parallel>h\\<parallel>\\<^sup>2 \\<ge> \\<parallel>gso i\\<parallel>\\<^sup>2\"", "lemma weakly_reduced_imp_short_vector: \n  assumes \"weakly_reduced \\<alpha> m\"\n    and in_L: \"h \\<in> lattice_of fs - {0\\<^sub>v n}\" and \\<alpha>_pos:\"\\<alpha> \\<ge> 1\"\n  shows \"fs \\<noteq> [] \\<and> sq_norm (fs ! 0) \\<le> \\<alpha>^(m-1) * sq_norm h\"", "lemma sq_norm_pos: \n  assumes j: \"j < m\" \n  shows \"sq_norm (gso j) > 0\"", "lemma Gramian_determinant: \n  assumes k: \"k \\<le> m\" \n  shows \"Gramian_determinant fs k = (\\<Prod> j<k. sq_norm (gso j))\"\n    \"Gramian_determinant fs k > 0\"", "lemma Gramian_determinant_div:\n  assumes \"l < m\"\n  shows \"Gramian_determinant fs (Suc l) / Gramian_determinant fs l = \\<parallel>gso l\\<parallel>\\<^sup>2\"", "lemma (in gram_schmidt_fs_Rn) Gramian_determinant_Ints:\n  assumes \"k \\<le> m\" \"\\<And>i j. i < n \\<Longrightarrow> j < m \\<Longrightarrow> fs ! j $ i \\<in> \\<int>\"\n  shows \"Gramian_determinant fs k \\<in> \\<int>\"", "lemma Gramian_determinant_ge1:\n  assumes \"k \\<le> m\"\n  shows \"1 \\<le> Gramian_determinant fs k\"", "lemma mu_bound_Gramian_determinant:\n  assumes \"l < k\" \"k < m\"\n  shows \"(\\<mu> k l)\\<^sup>2 \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2\"", "lemma gso_cong:\n  fixes f1 f2 :: \"'a vec list\"\n  assumes \"\\<And> i. i \\<le> x \\<Longrightarrow> f1 ! i = f2 ! i\"\n  shows \"gram_schmidt_fs.gso n f1 x = gram_schmidt_fs.gso n f2 x\"", "lemma \\<mu>_cong:\n  fixes f1 f2 :: \"'a vec list\"\n  assumes \"\\<And> k. j < i \\<Longrightarrow> k \\<le> j \\<Longrightarrow> f1 ! k = f2 ! k\"\n    and \"j < i \\<Longrightarrow> f1 ! i = f2 ! i\" \n  shows \"gram_schmidt_fs.\\<mu> n f1 i j = gram_schmidt_fs.\\<mu> n f2 i j\"", "lemma prod_list_le_mono: fixes us :: \"'a :: {linordered_nonzero_semiring,ordered_ring} list\" \n  assumes \"length us = length vs\" \n  and \"\\<And> i. i < length vs \\<Longrightarrow> 0 \\<le> us ! i \\<and> us ! i \\<le> vs ! i\" \nshows \"0 \\<le> prod_list us \\<and> prod_list us \\<le> prod_list vs\"", "lemma lattice_of_of_int: assumes G: \"set F \\<subseteq> carrier_vec n\" \n  and \"f \\<in> vec_module.lattice_of n F\"     \nshows \"map_vec rat_of_int f \\<in> vec_module.lattice_of n (map (map_vec of_int) F)\" \n  (is \"?f \\<in> vec_module.lattice_of _ ?F\")", "lemma Hadamard's_inequality: \n  fixes A::\"real mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" \n  shows  \"abs (det A) \\<le> sqrt (prod_list (map sq_norm (rows A)))\"", "lemma snd_gram_schmidt_int : \"snd (gram_schmidt_int n us) = gram_schmidt n (map (map_vec of_int) us)\"", "lemma adjuster_triv: \"adjuster_triv n w (map (\\<lambda> x. (x,sq_norm x)) us) = adjuster n w us\"", "lemma gram_schmidt_sub_triv: \"gram_schmidt_sub_triv n ((map (\\<lambda> x. (x,sq_norm x)) us)) ws = \n  map (\\<lambda> x. (x, sq_norm x)) (gram_schmidt_sub n us ws)\"", "lemma gram_schmidt_triv[simp]: \"gram_schmidt_triv n ws = map (\\<lambda> x. (x,sq_norm x)) (gram_schmidt n ws)\"", "lemma adjuster_wit_carrier_vec:\n  assumes \"f \\<in> carrier_vec n\" \"set gs \\<subseteq> carrier_vec n\"\n  shows \"snd (adjuster_wit mus f gs) \\<in> carrier_vec n\"", "lemma adjuster_wit'':\n  assumes \"adjuster_wit mus_acc f gs = (mus, g')\" \"n_gs = map (\\<lambda>x. (x, sq_norm_vec x)) gs\"\n \"f \\<in> carrier_vec n\" \"acc \\<in> carrier_vec n\" \"set gs \\<subseteq> carrier_vec n\"\n  shows \"mus_adjuster f n_gs mus_acc acc = (mus, acc + g')\"", "lemma adjuster_wit':\n  assumes \"n_gs = map (\\<lambda>x. (x, sq_norm_vec x)) gs\" \"f \\<in> carrier_vec n\" \"set gs \\<subseteq> carrier_vec n\"\n  shows \"mus_adjuster f n_gs mus_acc (0\\<^sub>v n) = adjuster_wit mus_acc f gs\"", "lemma sub2_wit_norms_mus':\n  assumes \"n_gs' = map (\\<lambda>v. (v, sq_norm_vec v)) gs'\"\n   \"sub2_wit gs' fs = (mus, gs)\" \"set fs \\<subseteq> carrier_vec n\" \"set gs' \\<subseteq> carrier_vec n\"\n shows \"norms_mus' fs n_gs' mus_acc = (map sq_norm_vec (rev gs @ gs'), rev mus @ mus_acc)\"", "lemma sub2_wit_gram_schmidt_sub_triv'':\n  assumes \"sub2_wit [] fs = (mus, gs)\" \"set fs \\<subseteq> carrier_vec n\"\n  shows \"norms_mus' fs [] [] = (map sq_norm_vec (rev gs), rev mus)\"", "lemma sub2_wit_gram_schmidt_norm_mus:\n  assumes \"sub2_wit [] fs = (mus, gs)\" \"set fs \\<subseteq> carrier_vec n\"\n  shows \"norms_mus fs = (map sq_norm_vec gs, mus)\"", "lemma (in gram_schmidt_fs_Rn) norms_mus: assumes \"set fs \\<subseteq> carrier_vec n\" \"length fs \\<le> n\"\n  shows \"norms_mus fs = (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs], map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])\"", "lemma norms_mus_rat_norms_mus:\n  \"norms_mus_rat n fs = gram_schmidt.norms_mus n fs\"", "lemma of_int_dvd:\n  \"b dvd a\" if \"of_int a / (of_int b :: 'a :: field_char_0) \\<in> \\<int>\" \"b \\<noteq> 0\"", "lemma denom_dvd_ints:\n  fixes i::int\n  assumes \"quotient_of r = (z, n)\" \"of_int i * r \\<in> \\<int>\"\n  shows \"n dvd i\"", "lemma quotient_of_bounds: \n  assumes \"quotient_of r = (n, d)\" \"rat_of_int i * r \\<in> \\<int>\" \"0 < i\" \"\\<bar>r\\<bar> \\<le> b\"\n  shows \"of_int \\<bar>n\\<bar> \\<le> of_int i * b\" \"d \\<le> i\"", "lemma ex_\\<kappa>:\n  assumes \"i < length fs\" \"l \\<le> i\"\n  shows \"\\<exists>\\<kappa>. sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0 ..< l]) =\n             sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0 ..< l])\" (is \"\\<exists>\\<kappa>. ?Prop l i \\<kappa>\")", "lemma \\<kappa>_def:\n  assumes \"i < length fs\" \"l \\<le> i\"\n  shows \"sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n         sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\"", "lemma (in gram_schmidt_fs_lin_indpt) fs_i_sumlist_\\<kappa>:\n  assumes \"i < m\" \"l \\<le> i\" \"j < l\"\n  shows \"(fs ! i + sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])) \\<bullet> fs ! j = 0\"", "lemma Ints_sum:\n  assumes \"\\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> \\<int>\"\n  shows \"sum f A \\<in> \\<int>\"", "lemma Ints_prod:\n  assumes \"\\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> \\<int>\"\n  shows \"prod f A \\<in> \\<int>\"", "lemma Ints_scalar_prod: \n  \"v \\<in> carrier_vec n \\<Longrightarrow> w \\<in> carrier_vec n\n   \\<Longrightarrow> (\\<And> i. i < n \\<Longrightarrow> v $ i \\<in> \\<int>) \\<Longrightarrow> (\\<And> i. i < n \\<Longrightarrow> w $ i \\<in> \\<int>) \\<Longrightarrow> v \\<bullet> w \\<in> \\<int>\"", "lemma Ints_det: assumes \"\\<And> i j. i < dim_row A \\<Longrightarrow> j < dim_col A \n  \\<Longrightarrow> A $$ (i,j) \\<in> \\<int>\"\n  shows \"det A \\<in> \\<int>\"", "lemma (in gram_schmidt_fs_Rn) Gramian_matrix_alt_alt_def:\n  assumes \"k \\<le> m\"\n  shows \"Gramian_matrix fs k = mat k k (\\<lambda>(i,j). fs ! i \\<bullet> fs ! j)\"", "lemma (in gram_schmidt_fs_int) fs_scalar_Ints:\n  assumes \"i < m\" \"j < m\"\n  shows \"fs ! i \\<bullet> fs ! j \\<in> \\<int>\"", "lemma (in gram_schmidt_fs_lin_indpt) fs_i_fs_j_sum_\\<kappa> :\n  assumes \"i < m\" \"l \\<le> i\" \"j < l\"\n  shows \"- (fs ! i \\<bullet> fs ! j) = (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)\"", "lemma (in gram_schmidt_fs_lin_indpt) Gramian_matrix_times_\\<kappa> :\n  assumes \"i < m\" \"l \\<le> i\"\n  shows \"Gramian_matrix fs l *\\<^sub>v (vec l (\\<lambda>t. \\<kappa> i l t)) = (vec l (\\<lambda>j. - (fs ! i \\<bullet> fs ! j)))\"", "lemma (in gram_schmidt_fs_int) d_\\<kappa>_Ints :\n  assumes \"i < m\" \"l \\<le> i\" \"t < l\"\n  shows \"d l * \\<kappa> i l t \\<in> \\<int>\"", "lemma (in gram_schmidt_fs_int) d_gso_Ints:\n  assumes \"i < n\" \"k < m\"\n  shows \"(d k \\<cdot>\\<^sub>v (gso k)) $ i \\<in> \\<int>\"", "lemma (in gram_schmidt_fs_int) d_mu_Ints:\n  assumes \"l \\<le> k\" \"k < m\"\n  shows \"d (Suc l) * \\<mu> k l \\<in> \\<int>\"", "lemma max_list_Max: \"ls \\<noteq> [] \\<Longrightarrow> max_list ls = Max (set ls)\"", "lemma N_ge_0:\n  assumes \"0 < m\"\n  shows \"0 \\<le> N\"", "lemma N_fs:\n  assumes \"i < m\"\n  shows \"\\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> N\"", "lemma N_gso:\n  assumes \"i < m\"\n  shows \"\\<parallel>gso i\\<parallel>\\<^sup>2 \\<le> N\"", "lemma N_d:\n  assumes \"i \\<le> m\"\n  shows \"Gramian_determinant fs i \\<le> N ^ i\"", "lemma ex_MAXIMUM: assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"\\<exists>a \\<in> A. Max (f ` A) = f a\"", "lemma fs_int': \"k < n \\<Longrightarrow> f \\<in> set fs \\<Longrightarrow> f $ k \\<in> \\<int>\"", "lemma\n  assumes \"i < m\"\n  shows fs_sq_norm_Ints: \"\\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<in> \\<int>\" and fs_sq_norm_ge_1: \"1 \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\"", "lemma\n  assumes \"set fs \\<noteq> {}\"\n  shows N_Ints: \"N \\<in> \\<int>\" and N_1: \"1 \\<le> N\"", "lemma N_mu:\n  assumes \"i < m\" \"j \\<le> i\"\n  shows \"(\\<mu> i j)\\<^sup>2 \\<le> N ^ (Suc j)\"", "lemma vec_hom_Ints:\n  assumes \"i < n\" \"xs \\<in> carrier_vec n\"\n  shows \"of_int_hom.vec_hom xs $ i \\<in> \\<int>\"", "lemma division_to_div: \"(of_int x  :: 'a :: floor_ceiling) = of_int y / of_int z \\<Longrightarrow> x = y div z\"", "lemma exact_division: assumes \"of_int x / (of_int y  :: 'a :: floor_ceiling) \\<in> \\<int>\"\n  shows \"of_int (x div y) = of_int x / (of_int y :: 'a)\"", "lemma int_via_rat_eqI: \"rat_of_int x = rat_of_int y \\<Longrightarrow> x = y\"", "lemma of_int_Gramian_determinant:\n  assumes \"k \\<le> length F\" \"\\<And>i. i < length F \\<Longrightarrow> dim_vec (F ! i) = n\"\n  shows \"gs.Gramian_determinant (map of_int_hom.vec_hom F) k = of_int (gs.Gramian_determinant F k)\"", "lemma f_carrier[dest]: \"i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n\"\n  and fs_carrier [simp]: \"set fs \\<subseteq> carrier_vec n\"", "lemma Gramian_determinant:\n  assumes k: \"k \\<le> m\" \n  shows \"of_int (gs.Gramian_determinant fs k) = (\\<Prod> j<k. sq_norm (gs.gso j))\" (is ?g1)\n    \"gs.Gramian_determinant fs k > 0\" (is ?g2)", "lemma fs_int_d_pos [intro]:\n  assumes k: \"k \\<le> m\" \nshows \"d fs k > 0\"", "lemma fs_int_d_Suc:\n  assumes k: \"k < m\" \nshows \"of_int (d fs (Suc k)) = sq_norm (gs.gso k) * of_int (d fs k)\"", "lemma fs_int_D_pos:\nshows \"D fs > 0\"", "lemma fs_int_mu_d_Z:\n  assumes j: \"j \\<le> ii\" and ii: \"ii < m\" \n  shows \"of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>\"", "lemma fs_int_mu_d_Z_m_m:\n  assumes j: \"j < m\" and ii: \"ii < m\" \n  shows \"of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>\"", "lemma sq_norm_fs_via_sum_mu_gso: assumes i: \"i < m\" \n  shows \"of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 = (\\<Sum>j\\<leftarrow>[0..<Suc i]. (gs.\\<mu> i j)\\<^sup>2 * \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\"", "lemma d\\<mu>: assumes \"j < m\" \"ii < m\" \n  shows \"of_int (d\\<mu> ii j) = of_int (d fs (Suc j)) * gs.\\<mu> ii j\""], "translations": [["", "lemma find_index_not_in_set: \"x \\<notin> set xs \\<longleftrightarrow> find_index xs x = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> set xs) = (find_index xs x = length xs)", "by (induction xs) auto"], ["", "lemma find_index_in_set: \"x \\<in> set xs \\<Longrightarrow> xs ! (find_index xs x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs ! find_index xs x = x", "by (induction xs) auto"], ["", "lemma find_index_inj: \"inj_on (find_index xs) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (find_index xs) (set xs)", "by (induction xs) (auto simp add: inj_on_def)"], ["", "lemma find_index_leq_length: \"find_index xs x < length xs \\<longleftrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_index xs x < length xs) = (x \\<in> set xs)", "by (induction xs) (auto)"], ["", "(* TODO: move *)"], ["", "lemma rev_unsimp: \"rev xs @ (r # rs) = rev (r#xs) @ rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs @ r # rs = rev (r # xs) @ rs", "by(induct xs,auto)"], ["", "(* TODO: unify *)"], ["", "lemma corthogonal_is_orthogonal[simp]: \n  \"corthogonal (xs :: 'a :: trivial_conjugatable_ordered_field vec list) = orthogonal xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal xs = orthogonal xs", "unfolding corthogonal_def orthogonal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<length xs.\n        \\<forall>j<length xs.\n           (xs ! i \\<bullet>c xs ! j = (0::'a)) = (i \\<noteq> j)) =\n    (\\<forall>i j.\n        i < length xs \\<longrightarrow>\n        j < length xs \\<longrightarrow>\n        (xs ! i \\<bullet> xs ! j = (0::'a)) = (i \\<noteq> j))", "by simp"], ["", "(* TODO: move *)"], ["", "context vec_module begin"], ["", "definition lattice_of :: \"'a vec list \\<Rightarrow> 'a vec set\" where\n  \"lattice_of fs = range (\\<lambda> c. sumlist (map (\\<lambda> i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0 ..< length fs]))\""], ["", "lemma lattice_of_finsum:\n  assumes \"set fs \\<subseteq> carrier_vec n\"\n  shows \"lattice_of fs = range (\\<lambda> c. finsum V (\\<lambda> i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) {0 ..< length fs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of fs =\n    range\n     (\\<lambda>c.\n         \\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n        fs}. of_int (c i) \\<cdot>\\<^sub>v fs ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of fs =\n    range\n     (\\<lambda>c.\n         \\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n        fs}. of_int (c i) \\<cdot>\\<^sub>v fs ! i)", "have \"sumlist (map (\\<lambda> i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0 ..< length fs])\n        = finsum V (\\<lambda> i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) {0 ..< length fs}\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n       [0..<length fs]) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n    fs}. of_int (c i) \\<cdot>\\<^sub>v fs ! i)", "using  assms"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n       [0..<length fs]) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n    fs}. of_int (c i) \\<cdot>\\<^sub>v fs ! i)", "by (subst sumlist_map_as_finsum) (fastforce)+"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (?c1 i) \\<cdot>\\<^sub>v fs ! i)\n     [0..<length fs]) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n  fs}. of_int (?c1 i) \\<cdot>\\<^sub>v fs ! i)\n\ngoal (1 subgoal):\n 1. lattice_of fs =\n    range\n     (\\<lambda>c.\n         \\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n        fs}. of_int (c i) \\<cdot>\\<^sub>v fs ! i)", "then"], ["proof (chain)\npicking this:\n  M.sumlist\n   (map (\\<lambda>i. of_int (?c1 i) \\<cdot>\\<^sub>v fs ! i)\n     [0..<length fs]) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n  fs}. of_int (?c1 i) \\<cdot>\\<^sub>v fs ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  M.sumlist\n   (map (\\<lambda>i. of_int (?c1 i) \\<cdot>\\<^sub>v fs ! i)\n     [0..<length fs]) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n  fs}. of_int (?c1 i) \\<cdot>\\<^sub>v fs ! i)\n\ngoal (1 subgoal):\n 1. lattice_of fs =\n    range\n     (\\<lambda>c.\n         \\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n        fs}. of_int (c i) \\<cdot>\\<^sub>v fs ! i)", "unfolding lattice_of_def"], ["proof (prove)\nusing this:\n  M.sumlist\n   (map (\\<lambda>i. of_int (?c1 i) \\<cdot>\\<^sub>v fs ! i)\n     [0..<length fs]) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n  fs}. of_int (?c1 i) \\<cdot>\\<^sub>v fs ! i)\n\ngoal (1 subgoal):\n 1. range\n     (\\<lambda>c.\n         M.sumlist\n          (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n            [0..<length fs])) =\n    range\n     (\\<lambda>c.\n         \\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n        fs}. of_int (c i) \\<cdot>\\<^sub>v fs ! i)", "by auto"], ["proof (state)\nthis:\n  lattice_of fs =\n  range\n   (\\<lambda>c.\n       \\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<length\n      fs}. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_latticeE: assumes \"f \\<in> lattice_of fs\" obtains c where\n    \"f = sumlist (map (\\<lambda> i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0 ..< length fs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f =\n        M.sumlist\n         (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n           [0..<length fs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> lattice_of fs\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f =\n        M.sumlist\n         (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n           [0..<length fs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding lattice_of_def"], ["proof (prove)\nusing this:\n  f \\<in> range\n           (\\<lambda>c.\n               M.sumlist\n                (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n                  [0..<length fs]))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f =\n        M.sumlist\n         (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n           [0..<length fs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma in_latticeI: assumes \"f = sumlist (map (\\<lambda> i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0 ..< length fs])\" \n  shows \"f \\<in> lattice_of fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> lattice_of fs", "using assms"], ["proof (prove)\nusing this:\n  f =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n\ngoal (1 subgoal):\n 1. f \\<in> lattice_of fs", "unfolding lattice_of_def"], ["proof (prove)\nusing this:\n  f =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n\ngoal (1 subgoal):\n 1. f \\<in> range\n             (\\<lambda>c.\n                 M.sumlist\n                  (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n                    [0..<length fs]))", "by auto"], ["", "lemma finsum_over_indexes_to_vectors:\n  assumes \"set vs \\<subseteq> carrier_vec n\" \"l = length vs\"\n  shows \"\\<exists>c. (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n          vs ! x) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (c v) \\<cdot>\\<^sub>v v)", "using assms"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> carrier_vec n\n  l = length vs\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n          vs ! x) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (c v) \\<cdot>\\<^sub>v v)", "proof (induction l arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "case (Suc l)"], ["proof (state)\nthis:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs", "obtain vs' v where vs'_def: \"vs = vs' @ [v]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n\ngoal (1 subgoal):\n 1. (\\<And>vs' v. vs = vs' @ [v] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Zero_not_Suc length_0_conv rev_exhaust)"], ["proof (state)\nthis:\n  vs = vs' @ [v]\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "have c: \"\\<exists>c. (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<l}. of_int (g i) \\<cdot>\\<^sub>v vs' ! i) = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<l}. of_int (g i) \\<cdot>\\<^sub>v\n          vs' ! i) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v)", "using Suc vs'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<l}. of_int (g i) \\<cdot>\\<^sub>v\n          vs' ! i) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v)", "by (auto)"], ["proof (state)\nthis:\n  \\<exists>c.\n     (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<l}. of_int (g i) \\<cdot>\\<^sub>v\n        vs' ! i) =\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\nvs'. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<l}. of_int (g i) \\<cdot>\\<^sub>v\n        vs' ! i) =\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\nvs'. of_int (c v) \\<cdot>\\<^sub>v v)", "obtain c \n    where c_def: \"(\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v vs' ! x) = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  \\<exists>c.\n     (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>{0..<l}. of_int (g i) \\<cdot>\\<^sub>v\n        vs' ! i) =\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\nvs'. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n            (g x) \\<cdot>\\<^sub>v\n           vs' ! x) =\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n   vs'. of_int (c v) \\<cdot>\\<^sub>v v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs' ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "have \"(\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) \n        = of_int (g l) \\<cdot>\\<^sub>v vs ! l + (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n    l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n    of_int (g l) \\<cdot>\\<^sub>v vs ! l +\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n       vs ! x)", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n    l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n    of_int (g l) \\<cdot>\\<^sub>v vs ! l +\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n       vs ! x)", "by (subst finsum_insert[symmetric]) (fastforce intro!: finsum_cong')+"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n  l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n  of_int (g l) \\<cdot>\\<^sub>v vs ! l +\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x)\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n  l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n  of_int (g l) \\<cdot>\\<^sub>v vs ! l +\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x)\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "have \"vs = vs' @ [v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs = vs' @ [v]", "using vs'_def"], ["proof (prove)\nusing this:\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. vs = vs' @ [v]", "by simp"], ["proof (state)\nthis:\n  vs = vs' @ [v]\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  vs = vs' @ [v]\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "have \"(\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v (vs' @ [v]) ! x) = (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v vs' ! x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n       (vs' @ [v]) ! x) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n       vs' ! x)", "using Suc vs'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n       (vs' @ [v]) ! x) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n       vs' ! x)", "by (intro finsum_cong') (auto simp add: in_mono append_Cons_nth_left)"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     (vs' @ [v]) ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs' ! x)\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     (vs' @ [v]) ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs' ! x)\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "note c_def"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs' ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs' ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "have \"(vs' @ [v]) ! l = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vs' @ [v]) ! l = v", "using Suc vs'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. (vs' @ [v]) ! l = v", "by auto"], ["proof (state)\nthis:\n  (vs' @ [v]) ! l = v\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  (vs' @ [v]) ! l = v\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "have \"\\<exists>d'. of_int (g l) \\<cdot>\\<^sub>v v + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (d' v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "proof (cases \"v \\<in> set vs'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "case True"], ["proof (state)\nthis:\n  v \\<in> set vs'\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  v \\<in> set vs'", "have I: \"set vs' = insert v (set vs' - {v})\""], ["proof (prove)\nusing this:\n  v \\<in> set vs'\n\ngoal (1 subgoal):\n 1. set vs' = insert v (set vs' - {v})", "by blast"], ["proof (state)\nthis:\n  set vs' = insert v (set vs' - {v})\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "define c' where \"c' x = (if x = v then c x + g l else c x)\" for x"], ["proof (state)\nthis:\n  c' ?x = (if ?x = v then c ?x + g l else c ?x)\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "have \"of_int (g l) \\<cdot>\\<^sub>v v + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\n          = of_int (g l) \\<cdot>\\<^sub>v v + (of_int (c v) \\<cdot>\\<^sub>v v + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' - {v}. of_int (c v) \\<cdot>\\<^sub>v v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (g l) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v\n       v) =\n    of_int (g l) \\<cdot>\\<^sub>v v +\n    (of_int (c v) \\<cdot>\\<^sub>v v +\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                     {v}. of_int (c v) \\<cdot>\\<^sub>v v))", "using Suc vs'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. of_int (g l) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v\n       v) =\n    of_int (g l) \\<cdot>\\<^sub>v v +\n    (of_int (c v) \\<cdot>\\<^sub>v v +\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                     {v}. of_int (c v) \\<cdot>\\<^sub>v v))", "by (subst I, subst finsum_insert) fastforce+"], ["proof (state)\nthis:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (of_int (c v) \\<cdot>\\<^sub>v v +\n   (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                   {v}. of_int (c v) \\<cdot>\\<^sub>v v))\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (of_int (c v) \\<cdot>\\<^sub>v v +\n   (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                   {v}. of_int (c v) \\<cdot>\\<^sub>v v))\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "have \"\\<dots> = of_int (g l) \\<cdot>\\<^sub>v v + of_int (c v) \\<cdot>\\<^sub>v v + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' - {v}. of_int (c v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (g l) \\<cdot>\\<^sub>v v +\n    (of_int (c v) \\<cdot>\\<^sub>v v +\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                     {v}. of_int (c v) \\<cdot>\\<^sub>v v)) =\n    of_int (g l) \\<cdot>\\<^sub>v v + of_int (c v) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                    {v}. of_int (c v) \\<cdot>\\<^sub>v v)", "using Suc vs'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. of_int (g l) \\<cdot>\\<^sub>v v +\n    (of_int (c v) \\<cdot>\\<^sub>v v +\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                     {v}. of_int (c v) \\<cdot>\\<^sub>v v)) =\n    of_int (g l) \\<cdot>\\<^sub>v v + of_int (c v) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                    {v}. of_int (c v) \\<cdot>\\<^sub>v v)", "by (subst a_assoc) (auto intro!: finsum_closed)"], ["proof (state)\nthis:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (of_int (c v) \\<cdot>\\<^sub>v v +\n   (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                   {v}. of_int (c v) \\<cdot>\\<^sub>v v)) =\n  of_int (g l) \\<cdot>\\<^sub>v v + of_int (c v) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                  {v}. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (of_int (c v) \\<cdot>\\<^sub>v v +\n   (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                   {v}. of_int (c v) \\<cdot>\\<^sub>v v)) =\n  of_int (g l) \\<cdot>\\<^sub>v v + of_int (c v) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                  {v}. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "have \"of_int (g l) \\<cdot>\\<^sub>v v + of_int (c v) \\<cdot>\\<^sub>v v = of_int (c' v)  \\<cdot>\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (g l) \\<cdot>\\<^sub>v v + of_int (c v) \\<cdot>\\<^sub>v v =\n    of_int (c' v) \\<cdot>\\<^sub>v v", "unfolding c'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (g l) \\<cdot>\\<^sub>v v + of_int (c v) \\<cdot>\\<^sub>v v =\n    of_int (if v = v then c v + g l else c v) \\<cdot>\\<^sub>v v", "by (auto simp add: add_smult_distrib_vec)"], ["proof (state)\nthis:\n  of_int (g l) \\<cdot>\\<^sub>v v + of_int (c v) \\<cdot>\\<^sub>v v =\n  of_int (c' v) \\<cdot>\\<^sub>v v\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  of_int (g l) \\<cdot>\\<^sub>v v + of_int (c v) \\<cdot>\\<^sub>v v =\n  of_int (c' v) \\<cdot>\\<^sub>v v\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "have \"(\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' - {v}. of_int (c v) \\<cdot>\\<^sub>v v) = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' - {v}. of_int (c' v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                    {v}. of_int (c v) \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                    {v}. of_int (c' v) \\<cdot>\\<^sub>v v)", "using Suc vs'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                    {v}. of_int (c v) \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                    {v}. of_int (c' v) \\<cdot>\\<^sub>v v)", "unfolding c'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                    {v}. of_int (c v) \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>va\\<in>set vs' -\n                                     {v}. of_int\n     (if va = v then c va + g l else c va) \\<cdot>\\<^sub>v\n    va)", "by (intro finsum_cong') (auto)"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                  {v}. of_int (c v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                  {v}. of_int (c' v) \\<cdot>\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                  {v}. of_int (c v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                  {v}. of_int (c' v) \\<cdot>\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "have \"of_int (c' v) \\<cdot>\\<^sub>v v + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' - {v}. of_int (c' v) \\<cdot>\\<^sub>v v)\n               = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v (set vs'). of_int (c' v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (c' v) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                    {v}. of_int (c' v) \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                     (set\n vs'). of_int (c' v) \\<cdot>\\<^sub>v v)", "using Suc vs'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. of_int (c' v) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                    {v}. of_int (c' v) \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                     (set\n vs'). of_int (c' v) \\<cdot>\\<^sub>v v)", "by (subst finsum_insert[symmetric]) (auto)"], ["proof (state)\nthis:\n  of_int (c' v) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs' -\n                                  {v}. of_int (c' v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                   (set vs'). of_int (c' v) \\<cdot>\\<^sub>v\n        v)\n\ngoal (2 subgoals):\n 1. v \\<in> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)\n 2. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "finally"], ["proof (chain)\npicking this:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                   (set vs'). of_int (c' v) \\<cdot>\\<^sub>v\n        v)", "show ?thesis"], ["proof (prove)\nusing this:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                   (set vs'). of_int (c' v) \\<cdot>\\<^sub>v\n        v)\n\ngoal (1 subgoal):\n 1. \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "using vs'_def"], ["proof (prove)\nusing this:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                   (set vs'). of_int (c' v) \\<cdot>\\<^sub>v\n        v)\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "by force"], ["proof (state)\nthis:\n  \\<exists>d'.\n     of_int (g l) \\<cdot>\\<^sub>v v +\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\nvs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\nvs. of_int (d' v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "case False"], ["proof (state)\nthis:\n  v \\<notin> set vs'\n\ngoal (1 subgoal):\n 1. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "define c' where \"c' x = (if x = v then g l else c x)\" for x"], ["proof (state)\nthis:\n  c' ?x = (if ?x = v then g l else c ?x)\n\ngoal (1 subgoal):\n 1. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "have \"of_int (g l) \\<cdot>\\<^sub>v v + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\n          = of_int (c' v) \\<cdot>\\<^sub>v v + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (g l) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v\n       v) =\n    of_int (c' v) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)", "unfolding c'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (g l) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v\n       v) =\n    of_int (if v = v then g l else c v) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)", "by simp"], ["proof (state)\nthis:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  of_int (c' v) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  of_int (c' v) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "have \"(\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v\n       v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v\n       v)", "unfolding c'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v\n       v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>va\\<in>set\nvs'. of_int (if va = v then g l else c va) \\<cdot>\\<^sub>v va)", "using Suc False vs'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n  v \\<notin> set vs'\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v\n       v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>va\\<in>set\nvs'. of_int (if va = v then g l else c va) \\<cdot>\\<^sub>v va)", "by (auto intro!: finsum_cong')"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "have \"of_int (c' v) \\<cdot>\\<^sub>v v + (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v v)\n               = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v (set vs'). of_int (c' v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (c' v) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v\n       v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                     (set\n vs'). of_int (c' v) \\<cdot>\\<^sub>v v)", "using False Suc vs'_def"], ["proof (prove)\nusing this:\n  v \\<notin> set vs'\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. of_int (c' v) \\<cdot>\\<^sub>v v +\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v\n       v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                     (set\n vs'). of_int (c' v) \\<cdot>\\<^sub>v v)", "by (subst finsum_insert[symmetric]) (auto)"], ["proof (state)\nthis:\n  of_int (c' v) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v\n     v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                   (set vs'). of_int (c' v) \\<cdot>\\<^sub>v\n        v)\n\ngoal (1 subgoal):\n 1. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  of_int (c' v) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v\n     v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                   (set vs'). of_int (c' v) \\<cdot>\\<^sub>v\n        v)\n\ngoal (1 subgoal):\n 1. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "have \"(\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v v) = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v\n       v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)", "unfolding c'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>va\\<in>set\nvs'. of_int (if va = v then g l else c va) \\<cdot>\\<^sub>v va) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)", "using False Suc vs'_def"], ["proof (prove)\nusing this:\n  v \\<notin> set vs'\n  \\<lbrakk>set ?vs1 \\<subseteq> carrier_vec n; l = length ?vs1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int\n                           (g x) \\<cdot>\\<^sub>v\n                          ?vs1 ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs1. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n  Suc l = length vs\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>va\\<in>set\nvs'. of_int (if va = v then g l else c va) \\<cdot>\\<^sub>v va) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)", "by (auto intro!: finsum_cong')"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c' v) \\<cdot>\\<^sub>v\n     v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. v \\<notin> set vs' \\<Longrightarrow>\n    \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "finally"], ["proof (chain)\npicking this:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                   (set vs'). of_int (c' v) \\<cdot>\\<^sub>v\n        v)", "show ?thesis"], ["proof (prove)\nusing this:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                   (set vs'). of_int (c' v) \\<cdot>\\<^sub>v\n        v)\n\ngoal (1 subgoal):\n 1. \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "using vs'_def"], ["proof (prove)\nusing this:\n  of_int (g l) \\<cdot>\\<^sub>v v +\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert v\n                                   (set vs'). of_int (c' v) \\<cdot>\\<^sub>v\n        v)\n  vs = vs' @ [v]\n\ngoal (1 subgoal):\n 1. \\<exists>d'.\n       of_int (g l) \\<cdot>\\<^sub>v v +\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (d' v) \\<cdot>\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  \\<exists>d'.\n     of_int (g l) \\<cdot>\\<^sub>v v +\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\nvs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\nvs. of_int (d' v) \\<cdot>\\<^sub>v v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d'.\n     of_int (g l) \\<cdot>\\<^sub>v v +\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\nvs'. of_int (c v) \\<cdot>\\<^sub>v v) =\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\nvs. of_int (d' v) \\<cdot>\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n 2. \\<And>l vs.\n       \\<lbrakk>\\<And>vs.\n                   \\<lbrakk>set vs \\<subseteq> carrier_vec n;\n                    l = length vs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c.\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<l}. of_int (g x) \\<cdot>\\<^sub>v\n     vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v);\n        set vs \\<subseteq> carrier_vec n; Suc l = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n                            l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "finally"], ["proof (chain)\npicking this:\n  \\<exists>d'.\n     (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n     l}. of_int (g x) \\<cdot>\\<^sub>v (vs' @ [v]) ! x) =\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\nvs. of_int (d' v) \\<cdot>\\<^sub>v v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>d'.\n     (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n     l}. of_int (g x) \\<cdot>\\<^sub>v (vs' @ [v]) ! x) =\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\nvs. of_int (d' v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n       l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  vs. of_int (c v) \\<cdot>\\<^sub>v v)", "unfolding vs'_def"], ["proof (prove)\nusing this:\n  \\<exists>d'.\n     (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n     l}. of_int (g x) \\<cdot>\\<^sub>v (vs' @ [v]) ! x) =\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n(vs' @ [v]). of_int (d' v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n       l}. of_int (g x) \\<cdot>\\<^sub>v (vs' @ [v]) ! x) =\n       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n  (vs' @ [v]). of_int (c v) \\<cdot>\\<^sub>v v)", "by blast"], ["proof (state)\nthis:\n  \\<exists>c.\n     (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<Suc\n     l}. of_int (g x) \\<cdot>\\<^sub>v vs ! x) =\n     (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<lbrakk>set vs \\<subseteq> carrier_vec n; 0 = length vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<0}. of_int\n                                (g x) \\<cdot>\\<^sub>v\n                               vs ! x) =\n                            (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "qed (auto)"], ["", "lemma lattice_of_altdef:\n  assumes \"set vs \\<subseteq> carrier_vec n\"\n  shows \"lattice_of vs = range (\\<lambda>c. \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of vs =\n    range\n     (\\<lambda>c.\n         \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n   vs. of_int (c v) \\<cdot>\\<^sub>v v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of vs =\n    range\n     (\\<lambda>c.\n         \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n   vs. of_int (c v) \\<cdot>\\<^sub>v v)", "have \"v \\<in> lattice_of vs\" if \"v \\<in> range (\\<lambda>c. \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v)\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "obtain c where v: \"v = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        v =\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n   vs. of_int (c v) \\<cdot>\\<^sub>v v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>v \\<in> range (\\<lambda>c. \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v)\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> range\n           (\\<lambda>c.\n               \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n         vs. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        v =\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n   vs. of_int (c v) \\<cdot>\\<^sub>v v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto)"], ["proof (state)\nthis:\n  v =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "define c' where \"c' i = (if find_index vs (vs ! i) = i then c (vs ! i) else 0)\" for i"], ["proof (state)\nthis:\n  c' ?i = (if find_index vs (vs ! ?i) = ?i then c (vs ! ?i) else 0)\n\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "have \"v = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c' (find_index vs v)) \\<cdot>\\<^sub>v vs ! (find_index vs v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int\n       (c' (find_index vs v)) \\<cdot>\\<^sub>v\n      vs ! find_index vs v)", "unfolding v"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v\n      v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int\n       (c' (find_index vs v)) \\<cdot>\\<^sub>v\n      vs ! find_index vs v)", "using assms"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v\n      v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int\n       (c' (find_index vs v)) \\<cdot>\\<^sub>v\n      vs ! find_index vs v)", "by (auto intro!: finsum_cong' simp add: c'_def find_index_in_set in_mono)"], ["proof (state)\nthis:\n  v =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int\n     (c' (find_index vs v)) \\<cdot>\\<^sub>v\n    vs ! find_index vs v)\n\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "also"], ["proof (state)\nthis:\n  v =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int\n     (c' (find_index vs v)) \\<cdot>\\<^sub>v\n    vs ! find_index vs v)\n\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "have \"\\<dots> = (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs ` (set vs). of_int (c' i) \\<cdot>\\<^sub>v vs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int\n       (c' (find_index vs v)) \\<cdot>\\<^sub>v\n      vs ! find_index vs v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                    set vs. of_int (c' i) \\<cdot>\\<^sub>v\n      vs ! i)", "using assms find_index_in_set find_index_inj"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> carrier_vec n\n  ?x \\<in> set ?xs \\<Longrightarrow> ?xs ! find_index ?xs ?x = ?x\n  inj_on (find_index ?xs) (set ?xs)\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int\n       (c' (find_index vs v)) \\<cdot>\\<^sub>v\n      vs ! find_index vs v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                    set vs. of_int (c' i) \\<cdot>\\<^sub>v\n      vs ! i)", "by (subst finsum_reindex) fastforce+"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int\n     (c' (find_index vs v)) \\<cdot>\\<^sub>v\n    vs ! find_index vs v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                  set vs. of_int (c' i) \\<cdot>\\<^sub>v\n    vs ! i)\n\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int\n     (c' (find_index vs v)) \\<cdot>\\<^sub>v\n    vs ! find_index vs v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                  set vs. of_int (c' i) \\<cdot>\\<^sub>v\n    vs ! i)\n\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "have \"\\<dots> = (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<length vs]. of_int (c' i) \\<cdot>\\<^sub>v vs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                    set vs. of_int (c' i) \\<cdot>\\<^sub>v\n      vs ! i) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n   length vs]. of_int (c' i) \\<cdot>\\<^sub>v vs ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                    set vs. of_int (c' i) \\<cdot>\\<^sub>v\n      vs ! i) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n   length vs]. of_int (c' i) \\<cdot>\\<^sub>v vs ! i)", "have \"i \\<in> find_index vs ` set vs\" if \"i < length vs\" \"find_index vs (vs ! i) = i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> find_index vs ` set vs", "using that"], ["proof (prove)\nusing this:\n  i < length vs\n  find_index vs (vs ! i) = i\n\ngoal (1 subgoal):\n 1. i \\<in> find_index vs ` set vs", "by (metis imageI nth_mem)"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < length vs; find_index vs (vs ! ?i1) = ?i1\\<rbrakk>\n  \\<Longrightarrow> ?i1 \\<in> find_index vs ` set vs\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                    set vs. of_int (c' i) \\<cdot>\\<^sub>v\n      vs ! i) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n   length vs]. of_int (c' i) \\<cdot>\\<^sub>v vs ! i)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i1 < length vs; find_index vs (vs ! ?i1) = ?i1\\<rbrakk>\n  \\<Longrightarrow> ?i1 \\<in> find_index vs ` set vs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length vs; find_index vs (vs ! ?i1) = ?i1\\<rbrakk>\n  \\<Longrightarrow> ?i1 \\<in> find_index vs ` set vs\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                    set vs. of_int (c' i) \\<cdot>\\<^sub>v\n      vs ! i) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n   length vs]. of_int (c' i) \\<cdot>\\<^sub>v vs ! i)", "unfolding c'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length vs; find_index vs (vs ! ?i1) = ?i1\\<rbrakk>\n  \\<Longrightarrow> ?i1 \\<in> find_index vs ` set vs\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                    set vs. of_int\n       (if find_index vs (vs ! i) = i then c (vs ! i)\n        else 0) \\<cdot>\\<^sub>v\n      vs ! i) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n   length\n    vs]. of_int\n          (if find_index vs (vs ! i) = i then c (vs ! i)\n           else 0) \\<cdot>\\<^sub>v\n         vs ! i)", "using find_index_leq_length assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length vs; find_index vs (vs ! ?i1) = ?i1\\<rbrakk>\n  \\<Longrightarrow> ?i1 \\<in> find_index vs ` set vs\n  (find_index ?xs ?x < length ?xs) = (?x \\<in> set ?xs)\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                    set vs. of_int\n       (if find_index vs (vs ! i) = i then c (vs ! i)\n        else 0) \\<cdot>\\<^sub>v\n      vs ! i) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n   length\n    vs]. of_int\n          (if find_index vs (vs ! i) = i then c (vs ! i)\n           else 0) \\<cdot>\\<^sub>v\n         vs ! i)", "by (intro add.finprod_mono_neutral_cong_left) (auto simp add: in_mono find_index_leq_length)"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                  set vs. of_int (c' i) \\<cdot>\\<^sub>v\n    vs ! i) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n length vs]. of_int (c' i) \\<cdot>\\<^sub>v vs ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                  set vs. of_int (c' i) \\<cdot>\\<^sub>v\n    vs ! i) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n length vs]. of_int (c' i) \\<cdot>\\<^sub>v vs ! i)\n\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>find_index vs `\n                                  set vs. of_int (c' i) \\<cdot>\\<^sub>v\n    vs ! i) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n length vs]. of_int (c' i) \\<cdot>\\<^sub>v vs ! i)\n\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "have \"\\<dots> = sumlist (map (\\<lambda>i. of_int (c' i) \\<cdot>\\<^sub>v vs ! i) [0..<length vs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n   length vs]. of_int (c' i) \\<cdot>\\<^sub>v vs ! i) =\n    M.sumlist\n     (map (\\<lambda>i. of_int (c' i) \\<cdot>\\<^sub>v vs ! i)\n       [0..<length vs])", "using assms"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n   length vs]. of_int (c' i) \\<cdot>\\<^sub>v vs ! i) =\n    M.sumlist\n     (map (\\<lambda>i. of_int (c' i) \\<cdot>\\<^sub>v vs ! i)\n       [0..<length vs])", "by (subst sumlist_map_as_finsum) (fastforce)+"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>i\\<in>set [0..<\n length vs]. of_int (c' i) \\<cdot>\\<^sub>v vs ! i) =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c' i) \\<cdot>\\<^sub>v vs ! i) [0..<length vs])\n\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "finally"], ["proof (chain)\npicking this:\n  v =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c' i) \\<cdot>\\<^sub>v vs ! i) [0..<length vs])", "show ?thesis"], ["proof (prove)\nusing this:\n  v =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c' i) \\<cdot>\\<^sub>v vs ! i) [0..<length vs])\n\ngoal (1 subgoal):\n 1. v \\<in> lattice_of vs", "unfolding lattice_of_def"], ["proof (prove)\nusing this:\n  v =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c' i) \\<cdot>\\<^sub>v vs ! i) [0..<length vs])\n\ngoal (1 subgoal):\n 1. v \\<in> range\n             (\\<lambda>c.\n                 M.sumlist\n                  (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i)\n                    [0..<length vs]))", "by blast"], ["proof (state)\nthis:\n  v \\<in> lattice_of vs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?v1\n  \\<in> range\n         (\\<lambda>c.\n             \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n       vs. of_int (c v) \\<cdot>\\<^sub>v v) \\<Longrightarrow>\n  ?v1 \\<in> lattice_of vs\n\ngoal (1 subgoal):\n 1. lattice_of vs =\n    range\n     (\\<lambda>c.\n         \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n   vs. of_int (c v) \\<cdot>\\<^sub>v v)", "moreover"], ["proof (state)\nthis:\n  ?v1\n  \\<in> range\n         (\\<lambda>c.\n             \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n       vs. of_int (c v) \\<cdot>\\<^sub>v v) \\<Longrightarrow>\n  ?v1 \\<in> lattice_of vs\n\ngoal (1 subgoal):\n 1. lattice_of vs =\n    range\n     (\\<lambda>c.\n         \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n   vs. of_int (c v) \\<cdot>\\<^sub>v v)", "have \"v \\<in> range (\\<lambda>c. \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (c v) \\<cdot>\\<^sub>v v)\" if \"v \\<in> lattice_of vs\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> range\n             (\\<lambda>c.\n                 \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n           vs. of_int (c v) \\<cdot>\\<^sub>v v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> range\n             (\\<lambda>c.\n                 \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n           vs. of_int (c v) \\<cdot>\\<^sub>v v)", "obtain c where \"v = sumlist (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i) [0..<length vs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        v =\n        M.sumlist\n         (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i)\n           [0..<length vs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>v \\<in> lattice_of vs\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> lattice_of vs\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        v =\n        M.sumlist\n         (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i)\n           [0..<length vs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding lattice_of_def"], ["proof (prove)\nusing this:\n  v \\<in> range\n           (\\<lambda>c.\n               M.sumlist\n                (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i)\n                  [0..<length vs]))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        v =\n        M.sumlist\n         (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i)\n           [0..<length vs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto)"], ["proof (state)\nthis:\n  v =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i) [0..<length vs])\n\ngoal (1 subgoal):\n 1. v \\<in> range\n             (\\<lambda>c.\n                 \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n           vs. of_int (c v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  v =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i) [0..<length vs])\n\ngoal (1 subgoal):\n 1. v \\<in> range\n             (\\<lambda>c.\n                 \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n           vs. of_int (c v) \\<cdot>\\<^sub>v v)", "have \"\\<dots> = (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<length vs}. of_int (c x) \\<cdot>\\<^sub>v vs ! x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i)\n       [0..<length vs]) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<length\n    vs}. of_int (c x) \\<cdot>\\<^sub>v vs ! x)", "using that assms"], ["proof (prove)\nusing this:\n  v \\<in> lattice_of vs\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i)\n       [0..<length vs]) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<length\n    vs}. of_int (c x) \\<cdot>\\<^sub>v vs ! x)", "by (subst sumlist_map_as_finsum) fastforce+"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i) [0..<length vs]) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<length\n  vs}. of_int (c x) \\<cdot>\\<^sub>v vs ! x)\n\ngoal (1 subgoal):\n 1. v \\<in> range\n             (\\<lambda>c.\n                 \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n           vs. of_int (c v) \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v vs ! i) [0..<length vs]) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<length\n  vs}. of_int (c x) \\<cdot>\\<^sub>v vs ! x)\n\ngoal (1 subgoal):\n 1. v \\<in> range\n             (\\<lambda>c.\n                 \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n           vs. of_int (c v) \\<cdot>\\<^sub>v v)", "obtain d where  \"\\<dots> = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (d v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<length\n        vs}. of_int (c x) \\<cdot>\\<^sub>v vs ! x) =\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n   vs. of_int (d v) \\<cdot>\\<^sub>v v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using finsum_over_indexes_to_vectors assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?vs \\<subseteq> carrier_vec n; ?l = length ?vs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<?l}. of_int\n                            (?g x) \\<cdot>\\<^sub>v\n                           ?vs ! x) =\n                       (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n                  ?vs. of_int (c v) \\<cdot>\\<^sub>v v)\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<length\n        vs}. of_int (c x) \\<cdot>\\<^sub>v vs ! x) =\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n   vs. of_int (d v) \\<cdot>\\<^sub>v v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>{0..<length\n  vs}. of_int (c x) \\<cdot>\\<^sub>v vs ! x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (d v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. v \\<in> range\n             (\\<lambda>c.\n                 \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n           vs. of_int (c v) \\<cdot>\\<^sub>v v)", "finally"], ["proof (chain)\npicking this:\n  v =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (d v) \\<cdot>\\<^sub>v v)", "show ?thesis"], ["proof (prove)\nusing this:\n  v =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set vs. of_int (d v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. v \\<in> range\n             (\\<lambda>c.\n                 \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n           vs. of_int (c v) \\<cdot>\\<^sub>v v)", "by blast"], ["proof (state)\nthis:\n  v \\<in> range\n           (\\<lambda>c.\n               \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n         vs. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?v1 \\<in> lattice_of vs \\<Longrightarrow>\n  ?v1\n  \\<in> range\n         (\\<lambda>c.\n             \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. lattice_of vs =\n    range\n     (\\<lambda>c.\n         \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n   vs. of_int (c v) \\<cdot>\\<^sub>v v)", "ultimately"], ["proof (chain)\npicking this:\n  ?v1\n  \\<in> range\n         (\\<lambda>c.\n             \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n       vs. of_int (c v) \\<cdot>\\<^sub>v v) \\<Longrightarrow>\n  ?v1 \\<in> lattice_of vs\n  ?v1 \\<in> lattice_of vs \\<Longrightarrow>\n  ?v1\n  \\<in> range\n         (\\<lambda>c.\n             \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n       vs. of_int (c v) \\<cdot>\\<^sub>v v)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?v1\n  \\<in> range\n         (\\<lambda>c.\n             \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n       vs. of_int (c v) \\<cdot>\\<^sub>v v) \\<Longrightarrow>\n  ?v1 \\<in> lattice_of vs\n  ?v1 \\<in> lattice_of vs \\<Longrightarrow>\n  ?v1\n  \\<in> range\n         (\\<lambda>c.\n             \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n       vs. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. lattice_of vs =\n    range\n     (\\<lambda>c.\n         \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n   vs. of_int (c v) \\<cdot>\\<^sub>v v)", "by fastforce"], ["proof (state)\nthis:\n  lattice_of vs =\n  range\n   (\\<lambda>c.\n       \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n vs. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_in_latticeI:\n  assumes fs: \"set fs \\<subseteq> carrier_vec n\" and \"f \\<in> set fs\" \n  shows \"f \\<in> lattice_of fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> lattice_of fs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> lattice_of fs", "define c :: \"'a vec \\<Rightarrow> int\" where \"c v = (if v = f then 1 else 0)\" for v"], ["proof (state)\nthis:\n  c ?v = (if ?v = f then 1 else 0)\n\ngoal (1 subgoal):\n 1. f \\<in> lattice_of fs", "have \"f = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{f}. of_int (c v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{f}. of_int (c v) \\<cdot>\\<^sub>v v)", "using assms"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  f \\<in> set fs\n\ngoal (1 subgoal):\n 1. f = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{f}. of_int (c v) \\<cdot>\\<^sub>v v)", "by (auto simp add: c_def)"], ["proof (state)\nthis:\n  f = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{f}. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. f \\<in> lattice_of fs", "also"], ["proof (state)\nthis:\n  f = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{f}. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. f \\<in> lattice_of fs", "have \"\\<dots> = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set fs. of_int (c v) \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{f}. of_int (c v) \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set fs. of_int (c v) \\<cdot>\\<^sub>v v)", "using assms"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  f \\<in> set fs\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{f}. of_int (c v) \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set fs. of_int (c v) \\<cdot>\\<^sub>v v)", "by (intro add.finprod_mono_neutral_cong_left) (auto simp add: c_def)"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>{f}. of_int (c v) \\<cdot>\\<^sub>v v) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set fs. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. f \\<in> lattice_of fs", "finally"], ["proof (chain)\npicking this:\n  f =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set fs. of_int (c v) \\<cdot>\\<^sub>v v)", "show ?thesis"], ["proof (prove)\nusing this:\n  f =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set fs. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. f \\<in> lattice_of fs", "using assms lattice_of_altdef"], ["proof (prove)\nusing this:\n  f =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set fs. of_int (c v) \\<cdot>\\<^sub>v v)\n  set fs \\<subseteq> carrier_vec n\n  f \\<in> set fs\n  set ?vs \\<subseteq> carrier_vec n \\<Longrightarrow>\n  lattice_of ?vs =\n  range\n   (\\<lambda>c.\n       \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n ?vs. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. f \\<in> lattice_of fs", "by blast"], ["proof (state)\nthis:\n  f \\<in> lattice_of fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lattice_of_eq_set:\n  assumes \"set fs = set gs\" \"set fs \\<subseteq> carrier_vec n\"\n  shows \"lattice_of fs = lattice_of gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of fs = lattice_of gs", "using assms lattice_of_altdef"], ["proof (prove)\nusing this:\n  set fs = set gs\n  set fs \\<subseteq> carrier_vec n\n  set ?vs \\<subseteq> carrier_vec n \\<Longrightarrow>\n  lattice_of ?vs =\n  range\n   (\\<lambda>c.\n       \\<Oplus>\\<^bsub>V\\<^esub>v\\<in>set\n ?vs. of_int (c v) \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. lattice_of fs = lattice_of gs", "by simp"], ["", "lemma lattice_of_swap: assumes fs: \"set fs \\<subseteq> carrier_vec n\" \n  and ij: \"i < length fs\" \"j < length fs\" \"i \\<noteq> j\" \n  and gs: \"gs = fs[ i := fs ! j, j := fs ! i]\" \nshows \"lattice_of gs = lattice_of fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "using assms mset_swap"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  gs = fs[i := fs ! j, j := fs ! i]\n  \\<lbrakk>?i < length ?ls; ?j < length ?ls\\<rbrakk>\n  \\<Longrightarrow> mset (?ls[?j := ?ls ! ?i, ?i := ?ls ! ?j]) = mset ?ls\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "by (intro lattice_of_eq_set) auto"], ["", "lemma lattice_of_add: assumes fs: \"set fs \\<subseteq> carrier_vec n\" \n  and ij: \"i < length fs\" \"j < length fs\" \"i \\<noteq> j\" \n  and gs: \"gs = fs[ i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j]\" \nshows \"lattice_of gs = lattice_of fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "fix i j l and fs :: \"'a vec list\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "assume *: \"i < j\" \"j < length fs\" and fs: \"set fs \\<subseteq> carrier_vec n\""], ["proof (state)\nthis:\n  i < j\n  j < length fs\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "note * = ij(1) *"], ["proof (state)\nthis:\n  i < length fs\n  i < j\n  j < length fs\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?gs = \"fs[ i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?len = \"[0..<i] @ [i] @ [Suc i..<j] @ [j] @ [Suc j..<length fs]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have \"[0 ..< length fs] = [0 ..< j] @ [j] @ [Suc j ..< length fs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<length fs] = [0..<j] @ [j] @ [Suc j..<length fs]", "using *"], ["proof (prove)\nusing this:\n  i < length fs\n  i < j\n  j < length fs\n\ngoal (1 subgoal):\n 1. [0..<length fs] = [0..<j] @ [j] @ [Suc j..<length fs]", "by (metis append_Cons append_self_conv2 less_Suc_eq_le less_imp_add_positive upt_add_eq_append \n          upt_conv_Cons zero_less_Suc)"], ["proof (state)\nthis:\n  [0..<length fs] = [0..<j] @ [j] @ [Suc j..<length fs]\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "also"], ["proof (state)\nthis:\n  [0..<length fs] = [0..<j] @ [j] @ [Suc j..<length fs]\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have \"[0 ..< j] = [0 ..< i] @ [i] @ [Suc i ..< j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<j] = [0..<i] @ [i] @ [Suc i..<j]", "using *"], ["proof (prove)\nusing this:\n  i < length fs\n  i < j\n  j < length fs\n\ngoal (1 subgoal):\n 1. [0..<j] = [0..<i] @ [i] @ [Suc i..<j]", "by (metis append_Cons append_self_conv2 less_Suc_eq_le less_imp_add_positive upt_add_eq_append \n          upt_conv_Cons zero_less_Suc)"], ["proof (state)\nthis:\n  [0..<j] = [0..<i] @ [i] @ [Suc i..<j]\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "finally"], ["proof (chain)\npicking this:\n  [0..<length fs] =\n  ([0..<i] @ [i] @ [Suc i..<j]) @ [j] @ [Suc j..<length fs]", "have len: \"[0..<length fs] = ?len\""], ["proof (prove)\nusing this:\n  [0..<length fs] =\n  ([0..<i] @ [i] @ [Suc i..<j]) @ [j] @ [Suc j..<length fs]\n\ngoal (1 subgoal):\n 1. [0..<length fs] =\n    [0..<i] @ [i] @ [Suc i..<j] @ [j] @ [Suc j..<length fs]", "by simp"], ["proof (state)\nthis:\n  [0..<length fs] = [0..<i] @ [i] @ [Suc i..<j] @ [j] @ [Suc j..<length fs]\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "from fs"], ["proof (chain)\npicking this:\n  set fs \\<subseteq> carrier_vec n", "have fs: \"\\<And> i. i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  {fs ! i |i. i < length fs} \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?i1 < length fs \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "from fs"], ["proof (chain)\npicking this:\n  ?i1 < length fs \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n", "have fsd: \"\\<And> i. i < length fs \\<Longrightarrow> dim_vec (fs ! i) = n\""], ["proof (prove)\nusing this:\n  ?i1 < length fs \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length fs \\<Longrightarrow> dim_vec (fs ! i) = n", "by auto"], ["proof (state)\nthis:\n  ?i1 < length fs \\<Longrightarrow> dim_vec (fs ! ?i1) = n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "from fsd[of i] fsd[of j] *"], ["proof (chain)\npicking this:\n  i < length fs \\<Longrightarrow> dim_vec (fs ! i) = n\n  j < length fs \\<Longrightarrow> dim_vec (fs ! j) = n\n  i < length fs\n  i < j\n  j < length fs", "have fsd: \"dim_vec (fs ! i) = n\" \"dim_vec (fs ! j) = n\""], ["proof (prove)\nusing this:\n  i < length fs \\<Longrightarrow> dim_vec (fs ! i) = n\n  j < length fs \\<Longrightarrow> dim_vec (fs ! j) = n\n  i < length fs\n  i < j\n  j < length fs\n\ngoal (1 subgoal):\n 1. dim_vec (fs ! i) = n &&& dim_vec (fs ! j) = n", "by auto"], ["proof (state)\nthis:\n  dim_vec (fs ! i) = n\n  dim_vec (fs ! j) = n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "{"], ["proof (state)\nthis:\n  dim_vec (fs ! i) = n\n  dim_vec (fs ! j) = n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "assume \"f \\<in> lattice_of fs\""], ["proof (state)\nthis:\n  f \\<in> lattice_of fs\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "from in_latticeE[OF this, unfolded len]"], ["proof (chain)\npicking this:\n  (\\<And>c.\n      f =\n      M.sumlist\n       (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n         ([0..<i] @\n          [i] @ [Suc i..<j] @ [j] @ [Suc j..<length fs])) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain c where\n        f: \"f = sumlist (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) ?len)\""], ["proof (prove)\nusing this:\n  (\\<And>c.\n      f =\n      M.sumlist\n       (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n         ([0..<i] @\n          [i] @ [Suc i..<j] @ [j] @ [Suc j..<length fs])) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f =\n        M.sumlist\n         (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n           ([0..<i] @\n            [i] @\n            [Suc i..<j] @ [j] @ [Suc j..<length fs])) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n     ([0..<i] @ [i] @ [Suc i..<j] @ [j] @ [Suc j..<length fs]))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "define sc where \"sc = (\\<lambda> xs. sumlist (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) xs))\""], ["proof (state)\nthis:\n  sc =\n  (\\<lambda>xs.\n      M.sumlist (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) xs))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "define d where \"d = (\\<lambda> k. if k = j then c j - c i * l else c k)\""], ["proof (state)\nthis:\n  d = (\\<lambda>k. if k = j then c j - c i * l else c k)\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "define sd where \"sd = (\\<lambda> xs. sumlist (map (\\<lambda>i. of_int (d i) \\<cdot>\\<^sub>v ?gs ! i) xs))\""], ["proof (state)\nthis:\n  sd =\n  (\\<lambda>xs.\n      M.sumlist\n       (map (\\<lambda>i.\n                of_int (d i) \\<cdot>\\<^sub>v\n                fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n         xs))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have isc: \"set is \\<subseteq> {0 ..< length fs} \\<Longrightarrow> sc is \\<in> carrier_vec n\" for \"is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set is \\<subseteq> {0..<length fs} \\<Longrightarrow>\n    sc is \\<in> carrier_vec n", "unfolding sc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set is \\<subseteq> {0..<length fs} \\<Longrightarrow>\n    M.sumlist (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) is)\n    \\<in> carrier_vec n", "by (intro sumlist_carrier, auto simp: fs)"], ["proof (state)\nthis:\n  set ?is1 \\<subseteq> {0..<length fs} \\<Longrightarrow>\n  sc ?is1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have isd: \"set is \\<subseteq> {0 ..< length fs} \\<Longrightarrow> sd is \\<in> carrier_vec n\" for \"is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set is \\<subseteq> {0..<length fs} \\<Longrightarrow>\n    sd is \\<in> carrier_vec n", "unfolding sd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set is \\<subseteq> {0..<length fs} \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       is)\n    \\<in> carrier_vec n", "using *"], ["proof (prove)\nusing this:\n  i < length fs\n  i < j\n  j < length fs\n\ngoal (1 subgoal):\n 1. set is \\<subseteq> {0..<length fs} \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       is)\n    \\<in> carrier_vec n", "by (intro sumlist_carrier, auto, rename_tac k,\n        case_tac \"k = i\", auto simp: fs)"], ["proof (state)\nthis:\n  set ?is1 \\<subseteq> {0..<length fs} \\<Longrightarrow>\n  sd ?is1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?a = \"sc [0..<i]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?b = \"sc [i]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?c = \"sc [Suc i ..< j]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?d = \"sc [j]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?e = \"sc [Suc j ..< length fs]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?A = \"sd [0..<i]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?B = \"sd [i]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?C = \"sd [Suc i ..< j]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?D = \"sd [j]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?E = \"sd [Suc j ..< length fs]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?CC = \"carrier_vec n\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have ae: \"?a \\<in> ?CC\" \"?b \\<in> ?CC\" \"?c \\<in> ?CC\" \"?d \\<in> ?CC\" \"?e \\<in> ?CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sc [0..<i] \\<in> carrier_vec n &&& sc [i] \\<in> carrier_vec n) &&&\n    sc [Suc i..<j] \\<in> carrier_vec n &&&\n    sc [j] \\<in> carrier_vec n &&&\n    sc [Suc j..<length fs] \\<in> carrier_vec n", "using *"], ["proof (prove)\nusing this:\n  i < length fs\n  i < j\n  j < length fs\n\ngoal (1 subgoal):\n 1. (sc [0..<i] \\<in> carrier_vec n &&& sc [i] \\<in> carrier_vec n) &&&\n    sc [Suc i..<j] \\<in> carrier_vec n &&&\n    sc [j] \\<in> carrier_vec n &&&\n    sc [Suc j..<length fs] \\<in> carrier_vec n", "by (auto intro: isc)"], ["proof (state)\nthis:\n  sc [0..<i] \\<in> carrier_vec n\n  sc [i] \\<in> carrier_vec n\n  sc [Suc i..<j] \\<in> carrier_vec n\n  sc [j] \\<in> carrier_vec n\n  sc [Suc j..<length fs] \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have AE: \"?A \\<in> ?CC\" \"?B \\<in> ?CC\" \"?C \\<in> ?CC\" \"?D \\<in> ?CC\" \"?E \\<in> ?CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sd [0..<i] \\<in> carrier_vec n &&& sd [i] \\<in> carrier_vec n) &&&\n    sd [Suc i..<j] \\<in> carrier_vec n &&&\n    sd [j] \\<in> carrier_vec n &&&\n    sd [Suc j..<length fs] \\<in> carrier_vec n", "using *"], ["proof (prove)\nusing this:\n  i < length fs\n  i < j\n  j < length fs\n\ngoal (1 subgoal):\n 1. (sd [0..<i] \\<in> carrier_vec n &&& sd [i] \\<in> carrier_vec n) &&&\n    sd [Suc i..<j] \\<in> carrier_vec n &&&\n    sd [j] \\<in> carrier_vec n &&&\n    sd [Suc j..<length fs] \\<in> carrier_vec n", "by (auto intro: isd)"], ["proof (state)\nthis:\n  sd [0..<i] \\<in> carrier_vec n\n  sd [i] \\<in> carrier_vec n\n  sd [Suc i..<j] \\<in> carrier_vec n\n  sd [j] \\<in> carrier_vec n\n  sd [Suc j..<length fs] \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have sc_sd: \"{i,j} \\<inter> set is \\<subseteq> {} \\<Longrightarrow> sc is = sd is\" for \"is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i, j} \\<inter> set is \\<subseteq> {} \\<Longrightarrow> sc is = sd is", "unfolding sc_def sd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i, j} \\<inter> set is \\<subseteq> {} \\<Longrightarrow>\n    M.sumlist (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) is) =\n    M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       is)", "by (rule arg_cong[of _ _ sumlist], rule map_cong, auto simp: d_def,\n        rename_tac k, case_tac \"i = k\", auto)"], ["proof (state)\nthis:\n  {i, j} \\<inter> set ?is2 \\<subseteq> {} \\<Longrightarrow>\n  sc ?is2 = sd ?is2\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have \"f = ?a + (?b + (?c + (?d + ?e)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f =\n    sc [0..<i] +\n    (sc [i] + (sc [Suc i..<j] + (sc [j] + sc [Suc j..<length fs])))", "unfolding f map_append sc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0..<i] @\n      map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [i] @\n      map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [Suc i..<j] @\n      map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [j] @\n      map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n       [Suc j..<length fs]) =\n    M.sumlist\n     (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0..<i]) +\n    (M.sumlist (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [i]) +\n     (M.sumlist\n       (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [Suc i..<j]) +\n      (M.sumlist\n        (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [j]) +\n       M.sumlist\n        (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n          [Suc j..<length fs]))))", "using fs *"], ["proof (prove)\nusing this:\n  ?i1 < length fs \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n  i < length fs\n  i < j\n  j < length fs\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0..<i] @\n      map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [i] @\n      map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [Suc i..<j] @\n      map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [j] @\n      map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n       [Suc j..<length fs]) =\n    M.sumlist\n     (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0..<i]) +\n    (M.sumlist (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [i]) +\n     (M.sumlist\n       (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [Suc i..<j]) +\n      (M.sumlist\n        (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [j]) +\n       M.sumlist\n        (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n          [Suc j..<length fs]))))", "by ((subst sumlist_append, force, force)+, simp)"], ["proof (state)\nthis:\n  f =\n  sc [0..<i] +\n  (sc [i] + (sc [Suc i..<j] + (sc [j] + sc [Suc j..<length fs])))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "also"], ["proof (state)\nthis:\n  f =\n  sc [0..<i] +\n  (sc [i] + (sc [Suc i..<j] + (sc [j] + sc [Suc j..<length fs])))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have \"\\<dots> = ?a + ((?b + ?d) + (?c + ?e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc [0..<i] +\n    (sc [i] + (sc [Suc i..<j] + (sc [j] + sc [Suc j..<length fs]))) =\n    sc [0..<i] +\n    (sc [i] + sc [j] + (sc [Suc i..<j] + sc [Suc j..<length fs]))", "using ae"], ["proof (prove)\nusing this:\n  sc [0..<i] \\<in> carrier_vec n\n  sc [i] \\<in> carrier_vec n\n  sc [Suc i..<j] \\<in> carrier_vec n\n  sc [j] \\<in> carrier_vec n\n  sc [Suc j..<length fs] \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. sc [0..<i] +\n    (sc [i] + (sc [Suc i..<j] + (sc [j] + sc [Suc j..<length fs]))) =\n    sc [0..<i] +\n    (sc [i] + sc [j] + (sc [Suc i..<j] + sc [Suc j..<length fs]))", "by auto"], ["proof (state)\nthis:\n  sc [0..<i] +\n  (sc [i] + (sc [Suc i..<j] + (sc [j] + sc [Suc j..<length fs]))) =\n  sc [0..<i] + (sc [i] + sc [j] + (sc [Suc i..<j] + sc [Suc j..<length fs]))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "also"], ["proof (state)\nthis:\n  sc [0..<i] +\n  (sc [i] + (sc [Suc i..<j] + (sc [j] + sc [Suc j..<length fs]))) =\n  sc [0..<i] + (sc [i] + sc [j] + (sc [Suc i..<j] + sc [Suc j..<length fs]))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have \"\\<dots> = ?A + ((?b + ?d) + (?C + ?E))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc [0..<i] +\n    (sc [i] + sc [j] + (sc [Suc i..<j] + sc [Suc j..<length fs])) =\n    sd [0..<i] +\n    (sc [i] + sc [j] + (sd [Suc i..<j] + sd [Suc j..<length fs]))", "using *"], ["proof (prove)\nusing this:\n  i < length fs\n  i < j\n  j < length fs\n\ngoal (1 subgoal):\n 1. sc [0..<i] +\n    (sc [i] + sc [j] + (sc [Suc i..<j] + sc [Suc j..<length fs])) =\n    sd [0..<i] +\n    (sc [i] + sc [j] + (sd [Suc i..<j] + sd [Suc j..<length fs]))", "by (auto simp: sc_sd)"], ["proof (state)\nthis:\n  sc [0..<i] +\n  (sc [i] + sc [j] + (sc [Suc i..<j] + sc [Suc j..<length fs])) =\n  sd [0..<i] + (sc [i] + sc [j] + (sd [Suc i..<j] + sd [Suc j..<length fs]))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "also"], ["proof (state)\nthis:\n  sc [0..<i] +\n  (sc [i] + sc [j] + (sc [Suc i..<j] + sc [Suc j..<length fs])) =\n  sd [0..<i] + (sc [i] + sc [j] + (sd [Suc i..<j] + sd [Suc j..<length fs]))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have \"?b + ?d = ?B + ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc [i] + sc [j] = sd [i] + sd [j]", "unfolding sd_def sc_def d_def sumlist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (+) (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [i])\n     (0\\<^sub>v n) +\n    foldr (+) (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [j])\n     (0\\<^sub>v n) =\n    foldr (+)\n     (map (\\<lambda>i.\n              of_int (if i = j then c j - c i * l else c i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [i])\n     (0\\<^sub>v n) +\n    foldr (+)\n     (map (\\<lambda>i.\n              of_int (if i = j then c j - c i * l else c i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [j])\n     (0\\<^sub>v n)", "by (rule eq_vecI, insert * fsd, auto simp: algebra_simps)"], ["proof (state)\nthis:\n  sc [i] + sc [j] = sd [i] + sd [j]\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "finally"], ["proof (chain)\npicking this:\n  f =\n  sd [0..<i] + (sd [i] + sd [j] + (sd [Suc i..<j] + sd [Suc j..<length fs]))", "have \"f = ?A + (?B + (?C + (?D + ?E)))\""], ["proof (prove)\nusing this:\n  f =\n  sd [0..<i] + (sd [i] + sd [j] + (sd [Suc i..<j] + sd [Suc j..<length fs]))\n\ngoal (1 subgoal):\n 1. f =\n    sd [0..<i] +\n    (sd [i] + (sd [Suc i..<j] + (sd [j] + sd [Suc j..<length fs])))", "using AE"], ["proof (prove)\nusing this:\n  f =\n  sd [0..<i] + (sd [i] + sd [j] + (sd [Suc i..<j] + sd [Suc j..<length fs]))\n  sd [0..<i] \\<in> carrier_vec n\n  sd [i] \\<in> carrier_vec n\n  sd [Suc i..<j] \\<in> carrier_vec n\n  sd [j] \\<in> carrier_vec n\n  sd [Suc j..<length fs] \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. f =\n    sd [0..<i] +\n    (sd [i] + (sd [Suc i..<j] + (sd [j] + sd [Suc j..<length fs])))", "by auto"], ["proof (state)\nthis:\n  f =\n  sd [0..<i] +\n  (sd [i] + (sd [Suc i..<j] + (sd [j] + sd [Suc j..<length fs])))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "also"], ["proof (state)\nthis:\n  f =\n  sd [0..<i] +\n  (sd [i] + (sd [Suc i..<j] + (sd [j] + sd [Suc j..<length fs])))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have \"\\<dots> = sumlist (map (\\<lambda>i. of_int (d i) \\<cdot>\\<^sub>v ?gs ! i) ?len)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sd [0..<i] +\n    (sd [i] + (sd [Suc i..<j] + (sd [j] + sd [Suc j..<length fs]))) =\n    M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       ([0..<i] @ [i] @ [Suc i..<j] @ [j] @ [Suc j..<length fs]))", "unfolding f map_append sd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [0..<i]) +\n    (M.sumlist\n      (map (\\<lambda>i.\n               of_int (d i) \\<cdot>\\<^sub>v\n               fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n        [i]) +\n     (M.sumlist\n       (map (\\<lambda>i.\n                of_int (d i) \\<cdot>\\<^sub>v\n                fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n         [Suc i..<j]) +\n      (M.sumlist\n        (map (\\<lambda>i.\n                 of_int (d i) \\<cdot>\\<^sub>v\n                 fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n          [j]) +\n       M.sumlist\n        (map (\\<lambda>i.\n                 of_int (d i) \\<cdot>\\<^sub>v\n                 fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n          [Suc j..<length fs])))) =\n    M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [0..<i] @\n      map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [i] @\n      map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [Suc i..<j] @\n      map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [j] @\n      map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [Suc j..<length fs])", "using fs *"], ["proof (prove)\nusing this:\n  ?i1 < length fs \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n  i < length fs\n  i < j\n  j < length fs\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [0..<i]) +\n    (M.sumlist\n      (map (\\<lambda>i.\n               of_int (d i) \\<cdot>\\<^sub>v\n               fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n        [i]) +\n     (M.sumlist\n       (map (\\<lambda>i.\n                of_int (d i) \\<cdot>\\<^sub>v\n                fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n         [Suc i..<j]) +\n      (M.sumlist\n        (map (\\<lambda>i.\n                 of_int (d i) \\<cdot>\\<^sub>v\n                 fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n          [j]) +\n       M.sumlist\n        (map (\\<lambda>i.\n                 of_int (d i) \\<cdot>\\<^sub>v\n                 fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n          [Suc j..<length fs])))) =\n    M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [0..<i] @\n      map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [i] @\n      map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [Suc i..<j] @\n      map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [j] @\n      map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [Suc j..<length fs])", "by ((subst sumlist_append, force, force)+, simp)"], ["proof (state)\nthis:\n  sd [0..<i] +\n  (sd [i] + (sd [Suc i..<j] + (sd [j] + sd [Suc j..<length fs]))) =\n  M.sumlist\n   (map (\\<lambda>i.\n            of_int (d i) \\<cdot>\\<^sub>v\n            fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n     ([0..<i] @ [i] @ [Suc i..<j] @ [j] @ [Suc j..<length fs]))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "also"], ["proof (state)\nthis:\n  sd [0..<i] +\n  (sd [i] + (sd [Suc i..<j] + (sd [j] + sd [Suc j..<length fs]))) =\n  M.sumlist\n   (map (\\<lambda>i.\n            of_int (d i) \\<cdot>\\<^sub>v\n            fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n     ([0..<i] @ [i] @ [Suc i..<j] @ [j] @ [Suc j..<length fs]))\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have \"\\<dots> = sumlist (map (\\<lambda>i. of_int (d i) \\<cdot>\\<^sub>v ?gs ! i) [0 ..< length ?gs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       ([0..<i] @ [i] @ [Suc i..<j] @ [j] @ [Suc j..<length fs])) =\n    M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [0..<length (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])])", "unfolding len[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [0..<length fs]) =\n    M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [0..<length (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])])", "by simp"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i.\n            of_int (d i) \\<cdot>\\<^sub>v\n            fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n     ([0..<i] @ [i] @ [Suc i..<j] @ [j] @ [Suc j..<length fs])) =\n  M.sumlist\n   (map (\\<lambda>i.\n            of_int (d i) \\<cdot>\\<^sub>v\n            fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n     [0..<length (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "finally"], ["proof (chain)\npicking this:\n  f =\n  M.sumlist\n   (map (\\<lambda>i.\n            of_int (d i) \\<cdot>\\<^sub>v\n            fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n     [0..<length (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])])", "have \"f = sumlist (map (\\<lambda>i. of_int (d i) \\<cdot>\\<^sub>v ?gs ! i) [0 ..< length ?gs])\""], ["proof (prove)\nusing this:\n  f =\n  M.sumlist\n   (map (\\<lambda>i.\n            of_int (d i) \\<cdot>\\<^sub>v\n            fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n     [0..<length (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])])\n\ngoal (1 subgoal):\n 1. f =\n    M.sumlist\n     (map (\\<lambda>i.\n              of_int (d i) \\<cdot>\\<^sub>v\n              fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n       [0..<length (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])])", "."], ["proof (state)\nthis:\n  f =\n  M.sumlist\n   (map (\\<lambda>i.\n            of_int (d i) \\<cdot>\\<^sub>v\n            fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i)\n     [0..<length (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "from in_latticeI[OF this]"], ["proof (chain)\npicking this:\n  f \\<in> lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])", "have \"f \\<in> lattice_of ?gs\""], ["proof (prove)\nusing this:\n  f \\<in> lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])\n\ngoal (1 subgoal):\n 1. f \\<in> lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])", "."], ["proof (state)\nthis:\n  f \\<in> lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "}"], ["proof (state)\nthis:\n  ?f3 \\<in> lattice_of fs \\<Longrightarrow>\n  ?f3 \\<in> lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "hence \"lattice_of fs \\<subseteq> lattice_of ?gs\""], ["proof (prove)\nusing this:\n  ?f3 \\<in> lattice_of fs \\<Longrightarrow>\n  ?f3 \\<in> lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])\n\ngoal (1 subgoal):\n 1. lattice_of fs\n    \\<subseteq> lattice_of\n                 (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])", "by blast"], ["proof (state)\nthis:\n  lattice_of fs\n  \\<subseteq> lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ia3 < ?ja3; ?ja3 < length ?fsa3;\n   set ?fsa3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> lattice_of ?fsa3\n                    \\<subseteq> lattice_of\n                                 (?fsa3\n                                  [?ia3 :=\n                                     ?fsa3 ! ?ia3 +\n                                     of_int ?la3 \\<cdot>\\<^sub>v\n                                     ?fsa3 ! ?ja3])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "note main = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ia3 < ?ja3; ?ja3 < length ?fsa3;\n   set ?fsa3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> lattice_of ?fsa3\n                    \\<subseteq> lattice_of\n                                 (?fsa3\n                                  [?ia3 :=\n                                     ?fsa3 ! ?ia3 +\n                                     of_int ?la3 \\<cdot>\\<^sub>v\n                                     ?fsa3 ! ?ja3])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?ia3 < ?ja3; ?ja3 < length ?fsa3;\n   set ?fsa3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> lattice_of ?fsa3\n                    \\<subseteq> lattice_of\n                                 (?fsa3\n                                  [?ia3 :=\n                                     ?fsa3 ! ?ia3 +\n                                     of_int ?la3 \\<cdot>\\<^sub>v\n                                     ?fsa3 ! ?ja3])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "fix i j and fs :: \"'a vec list\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "assume *: \"i < j\" \"j < length fs\" and fs: \"set fs \\<subseteq> carrier_vec n\""], ["proof (state)\nthis:\n  i < j\n  j < length fs\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "let ?gs = \"fs[ i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j]\""], ["proof (state)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "define gs where \"gs = ?gs\""], ["proof (state)\nthis:\n  gs = fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j]\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "from main[OF * fs, of l, folded gs_def]"], ["proof (chain)\npicking this:\n  lattice_of fs \\<subseteq> lattice_of gs", "have one: \"lattice_of fs \\<subseteq> lattice_of gs\""], ["proof (prove)\nusing this:\n  lattice_of fs \\<subseteq> lattice_of gs\n\ngoal (1 subgoal):\n 1. lattice_of fs \\<subseteq> lattice_of gs", "."], ["proof (state)\nthis:\n  lattice_of fs \\<subseteq> lattice_of gs\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have *: \"i < j\" \"j < length gs\" \"set gs \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j &&& j < length gs &&& set gs \\<subseteq> carrier_vec n", "using * fs"], ["proof (prove)\nusing this:\n  i < j\n  j < length fs\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. i < j &&& j < length gs &&& set gs \\<subseteq> carrier_vec n", "unfolding gs_def set_conv_nth"], ["proof (prove)\nusing this:\n  i < j\n  j < length fs\n  {fs ! i |i. i < length fs} \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. i < j &&&\n    j < length (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j]) &&&\n    {fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i |i.\n     i < length (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])}\n    \\<subseteq> carrier_vec n", "by (auto, rename_tac k, case_tac \"k = i\", (force intro!: add_carrier_vec)+)"], ["proof (state)\nthis:\n  i < j\n  j < length gs\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "from fs"], ["proof (chain)\npicking this:\n  set fs \\<subseteq> carrier_vec n", "have fs: \"\\<And> i. i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  {fs ! i |i. i < length fs} \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?i1 < length fs \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "from fs"], ["proof (chain)\npicking this:\n  ?i1 < length fs \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n", "have fsd: \"\\<And> i. i < length fs \\<Longrightarrow> dim_vec (fs ! i) = n\""], ["proof (prove)\nusing this:\n  ?i1 < length fs \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length fs \\<Longrightarrow> dim_vec (fs ! i) = n", "by auto"], ["proof (state)\nthis:\n  ?i1 < length fs \\<Longrightarrow> dim_vec (fs ! ?i1) = n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "from fsd[of i] fsd[of j] *"], ["proof (chain)\npicking this:\n  i < length fs \\<Longrightarrow> dim_vec (fs ! i) = n\n  j < length fs \\<Longrightarrow> dim_vec (fs ! j) = n\n  i < j\n  j < length gs\n  set gs \\<subseteq> carrier_vec n", "have fsd: \"dim_vec (fs ! i) = n\" \"dim_vec (fs ! j) = n\""], ["proof (prove)\nusing this:\n  i < length fs \\<Longrightarrow> dim_vec (fs ! i) = n\n  j < length fs \\<Longrightarrow> dim_vec (fs ! j) = n\n  i < j\n  j < length gs\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec (fs ! i) = n &&& dim_vec (fs ! j) = n", "by (auto simp: gs_def)"], ["proof (state)\nthis:\n  dim_vec (fs ! i) = n\n  dim_vec (fs ! j) = n\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "from main[OF *, of \"-l\"]"], ["proof (chain)\npicking this:\n  lattice_of gs\n  \\<subseteq> lattice_of\n               (gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j])", "have \"lattice_of gs \\<subseteq> lattice_of (gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j])\""], ["proof (prove)\nusing this:\n  lattice_of gs\n  \\<subseteq> lattice_of\n               (gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j])\n\ngoal (1 subgoal):\n 1. lattice_of gs\n    \\<subseteq> lattice_of\n                 (gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j])", "."], ["proof (state)\nthis:\n  lattice_of gs\n  \\<subseteq> lattice_of\n               (gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "also"], ["proof (state)\nthis:\n  lattice_of gs\n  \\<subseteq> lattice_of\n               (gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "have \"gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j] = fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j] = fs", "unfolding gs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j,\n       i := fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i +\n            of_int (- l) \\<cdot>\\<^sub>v\n            fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! j] =\n    fs", "by (rule nth_equalityI, auto, insert * fsd, rename_tac k, case_tac \"k = i\", auto)"], ["proof (state)\nthis:\n  gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j] = fs\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "ultimately"], ["proof (chain)\npicking this:\n  lattice_of gs\n  \\<subseteq> lattice_of\n               (gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j])\n  gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j] = fs", "have \"lattice_of fs = lattice_of ?gs\""], ["proof (prove)\nusing this:\n  lattice_of gs\n  \\<subseteq> lattice_of\n               (gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j])\n  gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j] = fs\n\ngoal (1 subgoal):\n 1. lattice_of fs =\n    lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])", "using one"], ["proof (prove)\nusing this:\n  lattice_of gs\n  \\<subseteq> lattice_of\n               (gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j])\n  gs[i := gs ! i + of_int (- l) \\<cdot>\\<^sub>v gs ! j] = fs\n  lattice_of fs \\<subseteq> lattice_of gs\n\ngoal (1 subgoal):\n 1. lattice_of fs =\n    lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])", "unfolding gs_def"], ["proof (prove)\nusing this:\n  lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])\n  \\<subseteq> lattice_of\n               (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j,\n                   i := fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] !\n                        i +\n                        of_int (- l) \\<cdot>\\<^sub>v\n                        fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] !\n                        j])\n  fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j,\n     i := fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! i +\n          of_int (- l) \\<cdot>\\<^sub>v\n          fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j] ! j] =\n  fs\n  lattice_of fs\n  \\<subseteq> lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])\n\ngoal (1 subgoal):\n 1. lattice_of fs =\n    lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])", "by auto"], ["proof (state)\nthis:\n  lattice_of fs =\n  lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ia3 < ?ja3; ?ja3 < length ?fsa3;\n   set ?fsa3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> lattice_of ?fsa3 =\n                    lattice_of\n                     (?fsa3\n                      [?ia3 :=\n                         ?fsa3 ! ?ia3 +\n                         of_int l \\<cdot>\\<^sub>v ?fsa3 ! ?ja3])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "note main = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ia3 < ?ja3; ?ja3 < length ?fsa3;\n   set ?fsa3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> lattice_of ?fsa3 =\n                    lattice_of\n                     (?fsa3\n                      [?ia3 :=\n                         ?fsa3 ! ?ia3 +\n                         of_int l \\<cdot>\\<^sub>v ?fsa3 ! ?ja3])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "proof (cases \"i < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> lattice_of gs = lattice_of fs\n 2. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "case True"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow> lattice_of gs = lattice_of fs\n 2. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "from main[OF this ij(2) fs]"], ["proof (chain)\npicking this:\n  lattice_of fs =\n  lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])", "show ?thesis"], ["proof (prove)\nusing this:\n  lattice_of fs =\n  lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "unfolding gs"], ["proof (prove)\nusing this:\n  lattice_of fs =\n  lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j])\n\ngoal (1 subgoal):\n 1. lattice_of (fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j]) =\n    lattice_of fs", "by simp"], ["proof (state)\nthis:\n  lattice_of gs = lattice_of fs\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "case False"], ["proof (state)\nthis:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "with ij"], ["proof (chain)\npicking this:\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  \\<not> i < j", "have ji: \"j < i\""], ["proof (prove)\nusing this:\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. j < i", "by auto"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "define hs where \"hs = fs[i := fs ! j, j := fs ! i]\""], ["proof (state)\nthis:\n  hs = fs[i := fs ! j, j := fs ! i]\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "define ks where \"ks = hs[j := hs ! j + of_int l \\<cdot>\\<^sub>v hs ! i]\""], ["proof (state)\nthis:\n  ks = hs[j := hs ! j + of_int l \\<cdot>\\<^sub>v hs ! i]\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "from ij fs"], ["proof (chain)\npicking this:\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  set fs \\<subseteq> carrier_vec n", "have ij': \"i < length hs\" \"set hs \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. i < length hs &&& set hs \\<subseteq> carrier_vec n", "unfolding hs_def"], ["proof (prove)\nusing this:\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. i < length (fs[i := fs ! j, j := fs ! i]) &&&\n    set (fs[i := fs ! j, j := fs ! i]) \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  i < length hs\n  set hs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "hence ij'': \"set ks \\<subseteq> carrier_vec n\" \"i < length ks\" \"j < length ks\" \"i \\<noteq> j\""], ["proof (prove)\nusing this:\n  i < length hs\n  set hs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (set ks \\<subseteq> carrier_vec n &&& i < length ks) &&&\n    j < length ks &&& i \\<noteq> j", "using ji"], ["proof (prove)\nusing this:\n  i < length hs\n  set hs \\<subseteq> carrier_vec n\n  j < i\n\ngoal (1 subgoal):\n 1. (set ks \\<subseteq> carrier_vec n &&& i < length ks) &&&\n    j < length ks &&& i \\<noteq> j", "unfolding ks_def set_conv_nth"], ["proof (prove)\nusing this:\n  i < length hs\n  {hs ! i |i. i < length hs} \\<subseteq> carrier_vec n\n  j < i\n\ngoal (1 subgoal):\n 1. ({hs[j := hs ! j + of_int l \\<cdot>\\<^sub>v hs ! i] ! ia |ia.\n      ia < length (hs[j := hs ! j + of_int l \\<cdot>\\<^sub>v hs ! i])}\n     \\<subseteq> carrier_vec n &&&\n     i < length (hs[j := hs ! j + of_int l \\<cdot>\\<^sub>v hs ! i])) &&&\n    j < length (hs[j := hs ! j + of_int l \\<cdot>\\<^sub>v hs ! i]) &&&\n    i \\<noteq> j", "by (auto, rename_tac k, case_tac \"k = i\", \n        force, case_tac \"k = j\", (force intro!: add_carrier_vec)+)"], ["proof (state)\nthis:\n  set ks \\<subseteq> carrier_vec n\n  i < length ks\n  j < length ks\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "from lattice_of_swap[OF fs ij refl]"], ["proof (chain)\npicking this:\n  lattice_of (fs[i := fs ! j, j := fs ! i]) = lattice_of fs", "have \"lattice_of fs = lattice_of hs\""], ["proof (prove)\nusing this:\n  lattice_of (fs[i := fs ! j, j := fs ! i]) = lattice_of fs\n\ngoal (1 subgoal):\n 1. lattice_of fs = lattice_of hs", "unfolding hs_def"], ["proof (prove)\nusing this:\n  lattice_of (fs[i := fs ! j, j := fs ! i]) = lattice_of fs\n\ngoal (1 subgoal):\n 1. lattice_of fs = lattice_of (fs[i := fs ! j, j := fs ! i])", "by auto"], ["proof (state)\nthis:\n  lattice_of fs = lattice_of hs\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "also"], ["proof (state)\nthis:\n  lattice_of fs = lattice_of hs\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "have \"\\<dots> = lattice_of ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of hs = lattice_of ks", "using main[OF ji ij']"], ["proof (prove)\nusing this:\n  lattice_of hs =\n  lattice_of (hs[j := hs ! j + of_int l \\<cdot>\\<^sub>v hs ! i])\n\ngoal (1 subgoal):\n 1. lattice_of hs = lattice_of ks", "unfolding ks_def"], ["proof (prove)\nusing this:\n  lattice_of hs =\n  lattice_of (hs[j := hs ! j + of_int l \\<cdot>\\<^sub>v hs ! i])\n\ngoal (1 subgoal):\n 1. lattice_of hs =\n    lattice_of (hs[j := hs ! j + of_int l \\<cdot>\\<^sub>v hs ! i])", "."], ["proof (state)\nthis:\n  lattice_of hs = lattice_of ks\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "also"], ["proof (state)\nthis:\n  lattice_of hs = lattice_of ks\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "have \"\\<dots> = lattice_of (ks[i := ks ! j, j := ks ! i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of ks = lattice_of (ks[i := ks ! j, j := ks ! i])", "by (rule sym, rule lattice_of_swap[OF ij'' refl])"], ["proof (state)\nthis:\n  lattice_of ks = lattice_of (ks[i := ks ! j, j := ks ! i])\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "also"], ["proof (state)\nthis:\n  lattice_of ks = lattice_of (ks[i := ks ! j, j := ks ! i])\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "have \"ks[i := ks ! j, j := ks ! i] = gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ks[i := ks ! j, j := ks ! i] = gs", "unfolding gs ks_def hs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs[i := fs ! j, j := fs ! i,\n       j := fs[i := fs ! j, j := fs ! i] ! j +\n            of_int l \\<cdot>\\<^sub>v fs[i := fs ! j, j := fs ! i] ! i,\n       i := fs[i := fs ! j, j := fs ! i,\n               j := fs[i := fs ! j, j := fs ! i] ! j +\n                    of_int l \\<cdot>\\<^sub>v\n                    fs[i := fs ! j, j := fs ! i] ! i] !\n            j,\n       j := fs[i := fs ! j, j := fs ! i,\n               j := fs[i := fs ! j, j := fs ! i] ! j +\n                    of_int l \\<cdot>\\<^sub>v\n                    fs[i := fs ! j, j := fs ! i] ! i] !\n            i] =\n    fs[i := fs ! i + of_int l \\<cdot>\\<^sub>v fs ! j]", "by (rule nth_equalityI, insert ij, auto, \n       rename_tac k, case_tac \"k = i\", force, case_tac \"k = j\", auto)"], ["proof (state)\nthis:\n  ks[i := ks ! j, j := ks ! i] = gs\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> lattice_of gs = lattice_of fs", "finally"], ["proof (chain)\npicking this:\n  lattice_of fs = lattice_of gs", "show ?thesis"], ["proof (prove)\nusing this:\n  lattice_of fs = lattice_of gs\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs", "by simp"], ["proof (state)\nthis:\n  lattice_of gs = lattice_of fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lattice_of gs = lattice_of fs\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"orthogonal_complement W = {x. x \\<in> carrier_vec n \\<and> (\\<forall>y \\<in> W. x \\<bullet> y = 0)}\""], ["", "lemma orthogonal_complement_subset:\n  assumes \"A \\<subseteq> B\"\n  shows \"orthogonal_complement B \\<subseteq> orthogonal_complement A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement B \\<subseteq> orthogonal_complement A", "unfolding orthogonal_complement_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> carrier_vec n. \\<forall>y\\<in>B. x \\<bullet> y = (0::'b)}\n    \\<subseteq> {x \\<in> carrier_vec n.\n                 \\<forall>y\\<in>A. x \\<bullet> y = (0::'b)}", "using assms"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. {x \\<in> carrier_vec n. \\<forall>y\\<in>B. x \\<bullet> y = (0::'b)}\n    \\<subseteq> {x \\<in> carrier_vec n.\n                 \\<forall>y\\<in>A. x \\<bullet> y = (0::'b)}", "by auto"], ["", "end"], ["", "context vec_space\nbegin"], ["", "lemma in_orthogonal_complement_span[simp]:\n  assumes [intro]:\"S \\<subseteq> carrier_vec n\"\n  shows \"orthogonal_complement (span S) = orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement (local.span S) = orthogonal_complement S", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. orthogonal_complement (local.span S) \\<subseteq> orthogonal_complement S\n 2. orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)", "show \"orthogonal_complement (span S) \\<subseteq> orthogonal_complement S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement (local.span S) \\<subseteq> orthogonal_complement S", "by(fact orthogonal_complement_subset[OF in_own_span[OF assms]])"], ["proof (state)\nthis:\n  orthogonal_complement (local.span S) \\<subseteq> orthogonal_complement S\n\ngoal (1 subgoal):\n 1. orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)", "{"], ["proof (state)\nthis:\n  orthogonal_complement (local.span S) \\<subseteq> orthogonal_complement S\n\ngoal (1 subgoal):\n 1. orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)", "fix x :: \"'a vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)", "fix A :: \"'a vec set\""], ["proof (state)\ngoal (1 subgoal):\n 1. orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)", "assume x [intro]:\"x \\<in> carrier_vec n\" and f: \"finite A\" and S:\"A \\<subseteq> S\""], ["proof (state)\nthis:\n  x \\<in> carrier_vec n\n  finite A\n  A \\<subseteq> S\n\ngoal (1 subgoal):\n 1. orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)", "assume i0:\"\\<forall>y\\<in>S. x \\<bullet> y = 0\""], ["proof (state)\nthis:\n  \\<forall>y\\<in>S. x \\<bullet> y = (0::'a)\n\ngoal (1 subgoal):\n 1. orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)", "have \"x \\<bullet> lincomb a A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bullet> lincomb a A = (0::'a)", "unfolding comm_scalar_prod[OF x lincomb_closed[OF subset_trans[OF S assms]]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a A \\<bullet> x = (0::'a)", "proof(insert S,atomize(full),rule finite_induct[OF f],goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<subseteq> S \\<longrightarrow> lincomb a {} \\<bullet> x = (0::'a)\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {} \\<subseteq> S \\<longrightarrow> lincomb a {} \\<bullet> x = (0::'a)\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> S \\<longrightarrow> lincomb a {} \\<bullet> x = (0::'a)", "using assms x"], ["proof (prove)\nusing this:\n  S \\<subseteq> carrier_vec n\n  x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. {} \\<subseteq> S \\<longrightarrow> lincomb a {} \\<bullet> x = (0::'a)", "by force"], ["proof (state)\nthis:\n  {} \\<subseteq> S \\<longrightarrow> lincomb a {} \\<bullet> x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "case (2 f F)"], ["proof (state)\nthis:\n  finite F\n  f \\<notin> F\n  F \\<subseteq> S \\<longrightarrow> lincomb a F \\<bullet> x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "{"], ["proof (state)\nthis:\n  finite F\n  f \\<notin> F\n  F \\<subseteq> S \\<longrightarrow> lincomb a F \\<bullet> x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "assume i:\"insert f F \\<subseteq> S\""], ["proof (state)\nthis:\n  insert f F \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "hence F:\"F \\<subseteq> S\" and f: \"f \\<in> S\""], ["proof (prove)\nusing this:\n  insert f F \\<subseteq> S\n\ngoal (1 subgoal):\n 1. F \\<subseteq> S &&& f \\<in> S", "by auto"], ["proof (state)\nthis:\n  F \\<subseteq> S\n  f \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "from F f assms"], ["proof (chain)\npicking this:\n  F \\<subseteq> S\n  f \\<in> S\n  S \\<subseteq> carrier_vec n", "have [intro]:\"F \\<subseteq> carrier_vec n\"\n          and fc[intro]:\"f \\<in> carrier_vec n\"\n          and [intro]:\"x \\<in> F \\<Longrightarrow> x \\<in> carrier_vec n\" for x"], ["proof (prove)\nusing this:\n  F \\<subseteq> S\n  f \\<in> S\n  S \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. F \\<subseteq> carrier_vec n &&&\n    f \\<in> carrier_vec n &&&\n    (x \\<in> F \\<Longrightarrow> x \\<in> carrier_vec n)", "by auto"], ["proof (state)\nthis:\n  F \\<subseteq> carrier_vec n\n  f \\<in> carrier_vec n\n  ?x1 \\<in> F \\<Longrightarrow> ?x1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "have laf:\"lincomb a F \\<bullet> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb a F \\<bullet> x = (0::'a)", "using F 2"], ["proof (prove)\nusing this:\n  F \\<subseteq> S\n  finite F\n  f \\<notin> F\n  F \\<subseteq> S \\<longrightarrow> lincomb a F \\<bullet> x = (0::'a)\n\ngoal (1 subgoal):\n 1. lincomb a F \\<bullet> x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  lincomb a F \\<bullet> x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "have [simp]:\"(\\<Sum>u\\<in>F. (a u \\<cdot>\\<^sub>v u) \\<bullet> x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>F. (a u \\<cdot>\\<^sub>v u) \\<bullet> x) = (0::'a)", "by(insert laf[unfolded lincomb_def],atomize(full),subst finsum_scalar_prod_sum) auto"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>F. (a u \\<cdot>\\<^sub>v u) \\<bullet> x) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "from f i0"], ["proof (chain)\npicking this:\n  f \\<in> S\n  \\<forall>y\\<in>S. x \\<bullet> y = (0::'a)", "have [simp]:\"f \\<bullet> x = 0\""], ["proof (prove)\nusing this:\n  f \\<in> S\n  \\<forall>y\\<in>S. x \\<bullet> y = (0::'a)\n\ngoal (1 subgoal):\n 1. f \\<bullet> x = (0::'a)", "by (subst comm_scalar_prod) auto"], ["proof (state)\nthis:\n  f \\<bullet> x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "from lincomb_closed[OF subset_trans[OF i assms]]"], ["proof (chain)\npicking this:\n  lincomb ?a (insert f F) \\<in> carrier_vec n", "have \"lincomb a (insert f F) \\<bullet> x = 0\""], ["proof (prove)\nusing this:\n  lincomb ?a (insert f F) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lincomb a (insert f F) \\<bullet> x = (0::'a)", "unfolding lincomb_def"], ["proof (prove)\nusing this:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert f F. ?a v \\<cdot>\\<^sub>v v)\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert f\n                                     F. a v \\<cdot>\\<^sub>v v) \\<bullet>\n    x =\n    (0::'a)", "apply(subst finsum_scalar_prod_sum,force,force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert f F. a v \\<cdot>\\<^sub>v v)\n        \\<in> carrier_vec n) \\<Longrightarrow>\n    (\\<Sum>u\\<in>insert f F. (a u \\<cdot>\\<^sub>v u) \\<bullet> x) = (0::'a)", "using 2(1,2) smult_scalar_prod_distrib[OF fc x]"], ["proof (prove)\nusing this:\n  finite F\n  f \\<notin> F\n  (?a \\<cdot>\\<^sub>v f) \\<bullet> x = ?a * (f \\<bullet> x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>insert f F. a v \\<cdot>\\<^sub>v v)\n        \\<in> carrier_vec n) \\<Longrightarrow>\n    (\\<Sum>u\\<in>insert f F. (a u \\<cdot>\\<^sub>v u) \\<bullet> x) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  lincomb a (insert f F) \\<bullet> x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "}"], ["proof (state)\nthis:\n  insert f F \\<subseteq> S \\<Longrightarrow>\n  lincomb a (insert f F) \\<bullet> x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<subseteq> S \\<longrightarrow>\n        lincomb a F \\<bullet> x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insert xa F \\<subseteq> S \\<longrightarrow>\n                         lincomb a (insert xa F) \\<bullet> x = (0::'a)", "thus ?case"], ["proof (prove)\nusing this:\n  insert f F \\<subseteq> S \\<Longrightarrow>\n  lincomb a (insert f F) \\<bullet> x = (0::'a)\n\ngoal (1 subgoal):\n 1. insert f F \\<subseteq> S \\<longrightarrow>\n    lincomb a (insert f F) \\<bullet> x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  insert f F \\<subseteq> S \\<longrightarrow>\n  lincomb a (insert f F) \\<bullet> x = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<bullet> lincomb a A = (0::'a)\n\ngoal (1 subgoal):\n 1. orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x3 \\<in> carrier_vec n; finite ?A3; ?A3 \\<subseteq> S;\n   \\<forall>y\\<in>S. ?x3 \\<bullet> y = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> ?x3 \\<bullet> lincomb ?a3 ?A3 = (0::'a)\n\ngoal (1 subgoal):\n 1. orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)", "thus \"orthogonal_complement S \\<subseteq> orthogonal_complement (span S)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 \\<in> carrier_vec n; finite ?A3; ?A3 \\<subseteq> S;\n   \\<forall>y\\<in>S. ?x3 \\<bullet> y = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> ?x3 \\<bullet> lincomb ?a3 ?A3 = (0::'a)\n\ngoal (1 subgoal):\n 1. orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)", "unfolding orthogonal_complement_def span_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 \\<in> carrier_vec n; finite ?A3; ?A3 \\<subseteq> S;\n   \\<forall>y\\<in>S. ?x3 \\<bullet> y = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> ?x3 \\<bullet> lincomb ?a3 ?A3 = (0::'a)\n\ngoal (1 subgoal):\n 1. {x \\<in> carrier_vec n. \\<forall>y\\<in>S. x \\<bullet> y = (0::'a)}\n    \\<subseteq> {x \\<in> carrier_vec n.\n                 \\<forall>y\\<in>{lincomb a A |a A.\n                                 finite A \\<and> A \\<subseteq> S}.\n                    x \\<bullet> y = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  orthogonal_complement S \\<subseteq> orthogonal_complement (local.span S)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context cof_vec_space\nbegin"], ["", "definition lin_indpt_list :: \"'a vec list \\<Rightarrow> bool\" where\n  \"lin_indpt_list fs = (set fs \\<subseteq> carrier_vec n \\<and> distinct fs \\<and> lin_indpt (set fs))\""], ["", "definition basis_list :: \"'a vec list \\<Rightarrow> bool\" where\n  \"basis_list fs = (set fs \\<subseteq> carrier_vec n \\<and> length fs = n \\<and> carrier_vec n \\<subseteq> span (set fs))\""], ["", "lemma upper_triangular_imp_lin_indpt_list:\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and tri: \"upper_triangular A\"\n    and diag: \"0 \\<notin> set (diag_mat A)\"\n  shows \"lin_indpt_list (rows A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt_list (rows A)", "using upper_triangular_imp_distinct[OF assms]"], ["proof (prove)\nusing this:\n  distinct (rows A)\n\ngoal (1 subgoal):\n 1. lin_indpt_list (rows A)", "using upper_triangular_imp_lin_indpt_rows[OF assms] A"], ["proof (prove)\nusing this:\n  distinct (rows A)\n  lin_indpt (set (rows A))\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. lin_indpt_list (rows A)", "unfolding lin_indpt_list_def"], ["proof (prove)\nusing this:\n  distinct (rows A)\n  lin_indpt (set (rows A))\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. set (rows A) \\<subseteq> carrier_vec n \\<and>\n    distinct (rows A) \\<and> lin_indpt (set (rows A))", "by (auto simp: rows_def)"], ["", "lemma basis_list_basis: assumes \"basis_list fs\" \n  shows \"distinct fs\" \"lin_indpt (set fs)\" \"basis (set fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct fs &&& lin_indpt (set fs) &&& basis (set fs)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct fs\n 2. lin_indpt (set fs)\n 3. basis (set fs)", "from assms[unfolded basis_list_def]"], ["proof (chain)\npicking this:\n  set fs \\<subseteq> carrier_vec n \\<and>\n  length fs = n \\<and> carrier_vec n \\<subseteq> local.span (set fs)", "have len: \"length fs = n\" and C: \"set fs \\<subseteq> carrier_vec n\" \n    and span: \"carrier_vec n \\<subseteq> span (set fs)\""], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n \\<and>\n  length fs = n \\<and> carrier_vec n \\<subseteq> local.span (set fs)\n\ngoal (1 subgoal):\n 1. length fs = n &&&\n    set fs \\<subseteq> carrier_vec n &&&\n    carrier_vec n \\<subseteq> local.span (set fs)", "by auto"], ["proof (state)\nthis:\n  length fs = n\n  set fs \\<subseteq> carrier_vec n\n  carrier_vec n \\<subseteq> local.span (set fs)\n\ngoal (3 subgoals):\n 1. distinct fs\n 2. lin_indpt (set fs)\n 3. basis (set fs)", "show b: \"basis (set fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis (set fs)", "proof (rule dim_gen_is_basis[OF finite_set C])"], ["proof (state)\ngoal (2 subgoals):\n 1. local.span (set fs) = carrier_vec n\n 2. card (set fs) \\<le> local.dim", "show \"card (set fs) \\<le> dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set fs) \\<le> local.dim", "unfolding dim_is_n"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set fs) \\<le> n", "unfolding len[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set fs) \\<le> length fs", "by (rule card_length)"], ["proof (state)\nthis:\n  card (set fs) \\<le> local.dim\n\ngoal (1 subgoal):\n 1. local.span (set fs) = carrier_vec n", "show \"span (set fs) = carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set fs) = carrier_vec n", "using span C"], ["proof (prove)\nusing this:\n  carrier_vec n \\<subseteq> local.span (set fs)\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. local.span (set fs) = carrier_vec n", "by auto"], ["proof (state)\nthis:\n  local.span (set fs) = carrier_vec n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  basis (set fs)\n\ngoal (2 subgoals):\n 1. distinct fs\n 2. lin_indpt (set fs)", "thus \"lin_indpt (set fs)\""], ["proof (prove)\nusing this:\n  basis (set fs)\n\ngoal (1 subgoal):\n 1. lin_indpt (set fs)", "unfolding basis_def"], ["proof (prove)\nusing this:\n  lin_indpt (set fs) \\<and>\n  local.span (set fs) = carrier_vec n \\<and>\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lin_indpt (set fs)", "by auto"], ["proof (state)\nthis:\n  lin_indpt (set fs)\n\ngoal (1 subgoal):\n 1. distinct fs", "show \"distinct fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct fs", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct fs \\<Longrightarrow> False", "assume \"\\<not> distinct fs\""], ["proof (state)\nthis:\n  \\<not> distinct fs\n\ngoal (1 subgoal):\n 1. \\<not> distinct fs \\<Longrightarrow> False", "hence \"card (set fs) < length fs\""], ["proof (prove)\nusing this:\n  \\<not> distinct fs\n\ngoal (1 subgoal):\n 1. card (set fs) < length fs", "using antisym_conv1 card_distinct card_length"], ["proof (prove)\nusing this:\n  \\<not> distinct fs\n  \\<not> ?x < ?y \\<Longrightarrow> (?x \\<le> ?y) = (?x = ?y)\n  card (set ?xs) = length ?xs \\<Longrightarrow> distinct ?xs\n  card (set ?xs) \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. card (set fs) < length fs", "by auto"], ["proof (state)\nthis:\n  card (set fs) < length fs\n\ngoal (1 subgoal):\n 1. \\<not> distinct fs \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card (set fs) < length fs\n\ngoal (1 subgoal):\n 1. \\<not> distinct fs \\<Longrightarrow> False", "have \"\\<dots> = dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length fs = local.dim", "unfolding len dim_is_n"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = n", ".."], ["proof (state)\nthis:\n  length fs = local.dim\n\ngoal (1 subgoal):\n 1. \\<not> distinct fs \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  card (set fs) < local.dim", "have \"card (set fs) < dim\""], ["proof (prove)\nusing this:\n  card (set fs) < local.dim\n\ngoal (1 subgoal):\n 1. card (set fs) < local.dim", "by auto"], ["proof (state)\nthis:\n  card (set fs) < local.dim\n\ngoal (1 subgoal):\n 1. \\<not> distinct fs \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card (set fs) < local.dim\n\ngoal (1 subgoal):\n 1. \\<not> distinct fs \\<Longrightarrow> False", "have \"\\<dots> \\<le> card (set fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim \\<le> card (set fs)", "using span finite_set[of fs]"], ["proof (prove)\nusing this:\n  carrier_vec n \\<subseteq> local.span (set fs)\n  finite (set fs)\n\ngoal (1 subgoal):\n 1. local.dim \\<le> card (set fs)", "using b basis_def gen_ge_dim"], ["proof (prove)\nusing this:\n  carrier_vec n \\<subseteq> local.span (set fs)\n  finite (set fs)\n  basis (set fs)\n  basis ?A =\n  (lin_indpt ?A \\<and>\n   local.span ?A = carrier_vec n \\<and> ?A \\<subseteq> carrier_vec n)\n  \\<lbrakk>finite ?A; ?A \\<subseteq> carrier_vec n;\n   local.span ?A = carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> local.dim \\<le> card ?A\n\ngoal (1 subgoal):\n 1. local.dim \\<le> card (set fs)", "by auto"], ["proof (state)\nthis:\n  local.dim \\<le> card (set fs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct fs \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  card (set fs) < card (set fs)", "show False"], ["proof (prove)\nusing this:\n  card (set fs) < card (set fs)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_list_imp_lin_indpt_list: assumes \"basis_list fs\" shows \"lin_indpt_list fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt_list fs", "using basis_list_basis[OF assms] assms"], ["proof (prove)\nusing this:\n  distinct fs\n  lin_indpt (set fs)\n  basis (set fs)\n  basis_list fs\n\ngoal (1 subgoal):\n 1. lin_indpt_list fs", "unfolding lin_indpt_list_def basis_list_def"], ["proof (prove)\nusing this:\n  distinct fs\n  lin_indpt (set fs)\n  basis (set fs)\n  set fs \\<subseteq> carrier_vec n \\<and>\n  length fs = n \\<and> carrier_vec n \\<subseteq> local.span (set fs)\n\ngoal (1 subgoal):\n 1. set fs \\<subseteq> carrier_vec n \\<and>\n    distinct fs \\<and> lin_indpt (set fs)", "by auto"], ["", "lemma basis_det_nonzero:\n  assumes db:\"basis (set G)\" and len:\"length G = n\"\n  shows \"det (mat_of_rows n G) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) \\<noteq> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) \\<noteq> (0::'a)", "have M_car1:\"mat_of_rows n G \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n G \\<in> carrier_mat n n", "using assms"], ["proof (prove)\nusing this:\n  basis (set G)\n  length G = n\n\ngoal (1 subgoal):\n 1. mat_of_rows n G \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  mat_of_rows n G \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) \\<noteq> (0::'a)", "hence M_car:\"(mat_of_rows n G)\\<^sup>T \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  mat_of_rows n G \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (mat_of_rows n G)\\<^sup>T \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  (mat_of_rows n G)\\<^sup>T \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) \\<noteq> (0::'a)", "have li:\"lin_indpt (set G)\"\n   and inc_2:\"set G \\<subseteq> carrier_vec n\"\n   and issp:\"carrier_vec n = span (set G)\"\n   and RG_in_carr:\"\\<And>i. i < length G \\<Longrightarrow> G ! i \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lin_indpt (set G) &&& set G \\<subseteq> carrier_vec n) &&&\n    carrier_vec n = local.span (set G) &&&\n    (\\<And>i. i < length G \\<Longrightarrow> G ! i \\<in> carrier_vec n)", "using assms[unfolded basis_def]"], ["proof (prove)\nusing this:\n  lin_indpt (set G) \\<and>\n  local.span (set G) = carrier_vec n \\<and> set G \\<subseteq> carrier_vec n\n  length G = n\n\ngoal (1 subgoal):\n 1. (lin_indpt (set G) &&& set G \\<subseteq> carrier_vec n) &&&\n    carrier_vec n = local.span (set G) &&&\n    (\\<And>i. i < length G \\<Longrightarrow> G ! i \\<in> carrier_vec n)", "by auto"], ["proof (state)\nthis:\n  lin_indpt (set G)\n  set G \\<subseteq> carrier_vec n\n  carrier_vec n = local.span (set G)\n  ?i1 < length G \\<Longrightarrow> G ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) \\<noteq> (0::'a)", "hence \"basis_list G\""], ["proof (prove)\nusing this:\n  lin_indpt (set G)\n  set G \\<subseteq> carrier_vec n\n  carrier_vec n = local.span (set G)\n  ?i1 < length G \\<Longrightarrow> G ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. basis_list G", "unfolding basis_list_def"], ["proof (prove)\nusing this:\n  lin_indpt (set G)\n  set G \\<subseteq> carrier_vec n\n  carrier_vec n = local.span (set G)\n  ?i1 < length G \\<Longrightarrow> G ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set G \\<subseteq> carrier_vec n \\<and>\n    length G = n \\<and> carrier_vec n \\<subseteq> local.span (set G)", "using len"], ["proof (prove)\nusing this:\n  lin_indpt (set G)\n  set G \\<subseteq> carrier_vec n\n  carrier_vec n = local.span (set G)\n  ?i1 < length G \\<Longrightarrow> G ! ?i1 \\<in> carrier_vec n\n  length G = n\n\ngoal (1 subgoal):\n 1. set G \\<subseteq> carrier_vec n \\<and>\n    length G = n \\<and> carrier_vec n \\<subseteq> local.span (set G)", "by auto"], ["proof (state)\nthis:\n  basis_list G\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) \\<noteq> (0::'a)", "from basis_list_basis[OF this]"], ["proof (chain)\npicking this:\n  distinct G\n  lin_indpt (set G)\n  basis (set G)", "have di:\"distinct G\""], ["proof (prove)\nusing this:\n  distinct G\n  lin_indpt (set G)\n  basis (set G)\n\ngoal (1 subgoal):\n 1. distinct G", "by auto"], ["proof (state)\nthis:\n  distinct G\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) \\<noteq> (0::'a)", "have \"det ((mat_of_rows n G)\\<^sup>T) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n G)\\<^sup>T \\<noteq> (0::'a)", "unfolding det_0_iff_vec_prod_zero[OF M_car]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "assume \"\\<exists>v. v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n", "obtain v where v:\"v \\<in> span (set G)\"\n                          \"v \\<noteq> 0\\<^sub>v n\" \"(mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> local.span (set G); v \\<noteq> 0\\<^sub>v n;\n         (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding issp"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     v \\<in> local.span (set G) \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> local.span (set G); v \\<noteq> 0\\<^sub>v n;\n         (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> local.span (set G)\n  v \\<noteq> 0\\<^sub>v n\n  (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "from finite_in_span[OF finite_set inc_2 v(1)]"], ["proof (chain)\npicking this:\n  \\<exists>a. True \\<and> lincomb a (set G) = v", "obtain a\n      where aA: \"v = lincomb a (set G)\""], ["proof (prove)\nusing this:\n  \\<exists>a. True \\<and> lincomb a (set G) = v\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        v = lincomb a (set G) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v = lincomb a (set G)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "from v(1,2)[folded issp]"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n", "obtain i where i:\"v $ i \\<noteq> 0\" \"i < n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>v $ i \\<noteq> (0::'a); i < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  v $ i \\<noteq> (0::'a)\n  i < n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "hence inG:\"G ! i \\<in> set G\""], ["proof (prove)\nusing this:\n  v $ i \\<noteq> (0::'a)\n  i < n\n\ngoal (1 subgoal):\n 1. G ! i \\<in> set G", "using len"], ["proof (prove)\nusing this:\n  v $ i \\<noteq> (0::'a)\n  i < n\n  length G = n\n\ngoal (1 subgoal):\n 1. G ! i \\<in> set G", "by auto"], ["proof (state)\nthis:\n  G ! i \\<in> set G\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "have di2: \"distinct [0..<length G]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [0..<length G]", "by auto"], ["proof (state)\nthis:\n  distinct [0..<length G]\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "define f where \"f = (\\<lambda>l. \\<Sum>i \\<in> set [0..<length G]. if l = G ! i then v $ i else 0)\""], ["proof (state)\nthis:\n  f =\n  (\\<lambda>l.\n      \\<Sum>i\\<in>set [0..<length G]. if l = G ! i then v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "hence f':\"f (G ! i) = (\\<Sum>ia\\<leftarrow>[0..<n]. if G ! ia = G ! i then v $ ia else 0)\""], ["proof (prove)\nusing this:\n  f =\n  (\\<lambda>l.\n      \\<Sum>i\\<in>set [0..<length G]. if l = G ! i then v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. f (G ! i) =\n    (\\<Sum>ia\\<leftarrow>[0..<\n                          n]. if G ! ia = G ! i then v $ ia else (0::'a))", "unfolding f_def sum.distinct_set_conv_list[OF di2]"], ["proof (prove)\nusing this:\n  (\\<lambda>l.\n      \\<Sum>i\\<leftarrow>[0..<\n                          length G]. if l = G ! i then v $ i else (0::'a)) =\n  (\\<lambda>l.\n      \\<Sum>i\\<leftarrow>[0..<\n                          length G]. if l = G ! i then v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<leftarrow>[0..<\n                          length\n                           G]. if G ! i = G ! ia then v $ ia else (0::'a)) =\n    (\\<Sum>ia\\<leftarrow>[0..<\n                          n]. if G ! ia = G ! i then v $ ia else (0::'a))", "unfolding len"], ["proof (prove)\nusing this:\n  (\\<lambda>l.\n      \\<Sum>i\\<leftarrow>[0..<n]. if l = G ! i then v $ i else (0::'a)) =\n  (\\<lambda>l.\n      \\<Sum>i\\<leftarrow>[0..<n]. if l = G ! i then v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<leftarrow>[0..<\n                          n]. if G ! i = G ! ia then v $ ia else (0::'a)) =\n    (\\<Sum>ia\\<leftarrow>[0..<\n                          n]. if G ! ia = G ! i then v $ ia else (0::'a))", "by metis"], ["proof (state)\nthis:\n  f (G ! i) =\n  (\\<Sum>ia\\<leftarrow>[0..<n]. if G ! ia = G ! i then v $ ia else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "from v"], ["proof (chain)\npicking this:\n  v \\<in> local.span (set G)\n  v \\<noteq> 0\\<^sub>v n\n  (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n", "have \"mat_of_cols n G *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v \\<in> local.span (set G)\n  v \\<noteq> 0\\<^sub>v n\n  (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. mat_of_cols n G *\\<^sub>v v = 0\\<^sub>v n", "unfolding transpose_mat_of_rows"], ["proof (prove)\nusing this:\n  v \\<in> local.span (set G)\n  v \\<noteq> 0\\<^sub>v n\n  mat_of_cols n G *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. mat_of_cols n G *\\<^sub>v v = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  mat_of_cols n G *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "with mat_of_cols_mult_as_finsum[OF v(1)[folded issp len] RG_in_carr]"], ["proof (chain)\npicking this:\n  (\\<And>i. i < length G \\<Longrightarrow> i < length G) \\<Longrightarrow>\n  mat_of_cols n G *\\<^sub>v v =\n  lincomb\n   (\\<lambda>l.\n       \\<Sum>i = 0..<length G. if l = G ! i then v $ i else (0::'a))\n   (set G)\n  mat_of_cols n G *\\<^sub>v v = 0\\<^sub>v n", "have f:\"lincomb f (set G) = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  (\\<And>i. i < length G \\<Longrightarrow> i < length G) \\<Longrightarrow>\n  mat_of_cols n G *\\<^sub>v v =\n  lincomb\n   (\\<lambda>l.\n       \\<Sum>i = 0..<length G. if l = G ! i then v $ i else (0::'a))\n   (set G)\n  mat_of_cols n G *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb f (set G) = 0\\<^sub>v n", "unfolding len f_def"], ["proof (prove)\nusing this:\n  (\\<And>i. i < n \\<Longrightarrow> i < n) \\<Longrightarrow>\n  mat_of_cols n G *\\<^sub>v v =\n  lincomb\n   (\\<lambda>l. \\<Sum>i = 0..<n. if l = G ! i then v $ i else (0::'a))\n   (set G)\n  mat_of_cols n G *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb\n     (\\<lambda>l.\n         \\<Sum>i\\<in>set [0..<n]. if l = G ! i then v $ i else (0::'a))\n     (set G) =\n    0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  lincomb f (set G) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "note [simp] = list_trisect[OF i(2)[folded len],unfolded len]"], ["proof (state)\nthis:\n  [0..<n] = [0..<i] @ i # [Suc i..<n]\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "note x = i(2)[folded len]"], ["proof (state)\nthis:\n  i < length G\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "have [simp]:\"(\\<Sum>x\\<leftarrow>[0..<i]. if G ! x = G ! i then v $ x else 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<i]. if G ! x = G ! i then v $ x else (0::'a)) =\n    (0::'a)", "by (rule sum_list_0,auto simp: nth_eq_iff_index_eq[OF di less_trans[OF _ x] x])"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>[0..<i]. if G ! x = G ! i then v $ x else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "have [simp]:\"(\\<Sum>x\\<leftarrow>[Suc i..<n]. if G ! x = G ! i then v $ x else 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[Suc i..<\n                         n]. if G ! x = G ! i then v $ x else (0::'a)) =\n    (0::'a)", "apply (rule sum_list_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>x.\n                            if G ! x = G ! i then v $ x else (0::'a))\n                     [Suc i..<n]) \\<Longrightarrow>\n       x = (0::'a)", "using nth_eq_iff_index_eq[OF di _ x] len"], ["proof (prove)\nusing this:\n  ?i < length G \\<Longrightarrow> (G ! ?i = G ! i) = (?i = i)\n  length G = n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>x.\n                            if G ! x = G ! i then v $ x else (0::'a))\n                     [Suc i..<n]) \\<Longrightarrow>\n       x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>[Suc i..<\n                       n]. if G ! x = G ! i then v $ x else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "from i(1)"], ["proof (chain)\npicking this:\n  v $ i \\<noteq> (0::'a)", "have \"f (G ! i) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. f (G ! i) \\<noteq> (0::'a)", "unfolding f'"], ["proof (prove)\nusing this:\n  v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<leftarrow>[0..<\n                          n]. if G ! ia = G ! i then v $ ia\n                              else (0::'a)) \\<noteq>\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  f (G ! i) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "from lin_dep_crit[OF finite_set subset_refl TrueI inG this f]"], ["proof (chain)\npicking this:\n  lin_dep (set G)", "have \"lin_dep (set G)\""], ["proof (prove)\nusing this:\n  lin_dep (set G)\n\ngoal (1 subgoal):\n 1. lin_dep (set G)", "."], ["proof (state)\nthis:\n  lin_dep (set G)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> carrier_vec n \\<and>\n       v \\<noteq> 0\\<^sub>v n \\<and>\n       (mat_of_rows n G)\\<^sup>T *\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  lin_dep (set G)\n\ngoal (1 subgoal):\n 1. False", "using li"], ["proof (prove)\nusing this:\n  lin_dep (set G)\n  lin_indpt (set G)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (mat_of_rows n G)\\<^sup>T \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) \\<noteq> (0::'a)", "thus det0:\"det (mat_of_rows n G) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  det (mat_of_rows n G)\\<^sup>T \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) \\<noteq> (0::'a)", "by (unfold det_transpose[OF M_car1])"], ["proof (state)\nthis:\n  det (mat_of_rows n G) \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lin_indpt_list_add_vec: assumes  \n      i: \"j < length us\" \"i < length us\" \"i \\<noteq> j\" \n   and indep: \"lin_indpt_list  us\" \nshows \"lin_indpt_list (us [i := us ! i + c \\<cdot>\\<^sub>v us ! j])\" (is \"lin_indpt_list ?V\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from indep[unfolded lin_indpt_list_def]"], ["proof (chain)\npicking this:\n  set us \\<subseteq> carrier_vec n \\<and>\n  distinct us \\<and> lin_indpt (set us)", "have us: \"set us \\<subseteq> carrier_vec n\" \n    and dist: \"distinct us\" and indep: \"lin_indpt (set us)\""], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n \\<and>\n  distinct us \\<and> lin_indpt (set us)\n\ngoal (1 subgoal):\n 1. set us \\<subseteq> carrier_vec n &&& distinct us &&& lin_indpt (set us)", "by auto"], ["proof (state)\nthis:\n  set us \\<subseteq> carrier_vec n\n  distinct us\n  lin_indpt (set us)\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "let ?E = \"set us - {us ! i}\""], ["proof (state)\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "let ?us = \"insert (us ! i) ?E\""], ["proof (state)\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "let ?v = \"us ! i + c \\<cdot>\\<^sub>v us ! j\""], ["proof (state)\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from us i"], ["proof (chain)\npicking this:\n  set us \\<subseteq> carrier_vec n\n  j < length us\n  i < length us\n  i \\<noteq> j", "have usi: \"us ! i \\<in> carrier_vec n\" \"us ! i \\<notin> ?E\" \"us ! i \\<in> set us\" \n    and usj: \"us ! j \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. (us ! i \\<in> carrier_vec n &&&\n     us ! i \\<notin> set us - {us ! i} &&& us ! i \\<in> set us) &&&\n    us ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  us ! i \\<in> carrier_vec n\n  us ! i \\<notin> set us - {us ! i}\n  us ! i \\<in> set us\n  us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from usi usj"], ["proof (chain)\npicking this:\n  us ! i \\<in> carrier_vec n\n  us ! i \\<notin> set us - {us ! i}\n  us ! i \\<in> set us\n  us ! j \\<in> carrier_vec n", "have v: \"?v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  us ! i \\<in> carrier_vec n\n  us ! i \\<notin> set us - {us ! i}\n  us ! i \\<in> set us\n  us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have fin: \"finite ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set us - {us ! i})", "by auto"], ["proof (state)\nthis:\n  finite (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have id: \"set us = insert (us ! i) (set us - {us ! i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set us = insert (us ! i) (set us - {us ! i})", "using i(2)"], ["proof (prove)\nusing this:\n  i < length us\n\ngoal (1 subgoal):\n 1. set us = insert (us ! i) (set us - {us ! i})", "by auto"], ["proof (state)\nthis:\n  set us = insert (us ! i) (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from dist i"], ["proof (chain)\npicking this:\n  distinct us\n  j < length us\n  i < length us\n  i \\<noteq> j", "have diff': \"us ! i \\<noteq> us ! j\""], ["proof (prove)\nusing this:\n  distinct us\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. us ! i \\<noteq> us ! j", "unfolding distinct_conv_nth"], ["proof (prove)\nusing this:\n  \\<forall>i<length us.\n     \\<forall>j<length us.\n        i \\<noteq> j \\<longrightarrow> us ! i \\<noteq> us ! j\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. us ! i \\<noteq> us ! j", "by auto"], ["proof (state)\nthis:\n  us ! i \\<noteq> us ! j\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from subset_li_is_li[OF indep]"], ["proof (chain)\npicking this:\n  ?B \\<subseteq> set us \\<Longrightarrow> lin_indpt ?B", "have indepE: \"lin_indpt ?E\""], ["proof (prove)\nusing this:\n  ?B \\<subseteq> set us \\<Longrightarrow> lin_indpt ?B\n\ngoal (1 subgoal):\n 1. lin_indpt (set us - {us ! i})", "by auto"], ["proof (state)\nthis:\n  lin_indpt (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have Vid: \"set ?V = insert ?v ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) =\n    insert (us ! i + c \\<cdot>\\<^sub>v us ! j) (set us - {us ! i})", "using set_update_distinct[OF dist i(2)]"], ["proof (prove)\nusing this:\n  set (us[i := ?x]) = insert ?x (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) =\n    insert (us ! i + c \\<cdot>\\<^sub>v us ! j) (set us - {us ! i})", "by auto"], ["proof (state)\nthis:\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) =\n  insert (us ! i + c \\<cdot>\\<^sub>v us ! j) (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have E: \"?E \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set us - {us ! i} \\<subseteq> carrier_vec n", "using us"], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. set us - {us ! i} \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set us - {us ! i} \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have V: \"set ?V \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n    \\<subseteq> carrier_vec n", "using us v"], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n    \\<subseteq> carrier_vec n", "unfolding Vid"], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. insert (us ! i + c \\<cdot>\\<^sub>v us ! j) (set us - {us ! i})\n    \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from dist i"], ["proof (chain)\npicking this:\n  distinct us\n  j < length us\n  i < length us\n  i \\<noteq> j", "have diff: \"us ! i \\<noteq> us ! j\""], ["proof (prove)\nusing this:\n  distinct us\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. us ! i \\<noteq> us ! j", "unfolding distinct_conv_nth"], ["proof (prove)\nusing this:\n  \\<forall>i<length us.\n     \\<forall>j<length us.\n        i \\<noteq> j \\<longrightarrow> us ! i \\<noteq> us ! j\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. us ! i \\<noteq> us ! j", "by auto"], ["proof (state)\nthis:\n  us ! i \\<noteq> us ! j\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "have vspan: \"?v \\<notin> span ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<notin> local.span (set us - {us ! i})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "assume mem: \"?v \\<in> span ?E\""], ["proof (state)\nthis:\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "from diff i"], ["proof (chain)\npicking this:\n  us ! i \\<noteq> us ! j\n  j < length us\n  i < length us\n  i \\<noteq> j", "have \"us ! j \\<in> ?E\""], ["proof (prove)\nusing this:\n  us ! i \\<noteq> us ! j\n  j < length us\n  i < length us\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. us ! j \\<in> set us - {us ! i}", "by auto"], ["proof (state)\nthis:\n  us ! j \\<in> set us - {us ! i}\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "hence \"us ! j \\<in> span ?E\""], ["proof (prove)\nusing this:\n  us ! j \\<in> set us - {us ! i}\n\ngoal (1 subgoal):\n 1. us ! j \\<in> local.span (set us - {us ! i})", "using E"], ["proof (prove)\nusing this:\n  us ! j \\<in> set us - {us ! i}\n  set us - {us ! i} \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. us ! j \\<in> local.span (set us - {us ! i})", "by (metis span_mem)"], ["proof (state)\nthis:\n  us ! j \\<in> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "hence \"- c \\<cdot>\\<^sub>v us ! j \\<in> span ?E\""], ["proof (prove)\nusing this:\n  us ! j \\<in> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. - c \\<cdot>\\<^sub>v us ! j \\<in> local.span (set us - {us ! i})", "using smult_in_span[OF E]"], ["proof (prove)\nusing this:\n  us ! j \\<in> local.span (set us - {us ! i})\n  ?x \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n  ?c \\<cdot>\\<^sub>v ?x \\<in> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. - c \\<cdot>\\<^sub>v us ! j \\<in> local.span (set us - {us ! i})", "by auto"], ["proof (state)\nthis:\n  - c \\<cdot>\\<^sub>v us ! j \\<in> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "from span_add1[OF E mem this]"], ["proof (chain)\npicking this:\n  us ! i + c \\<cdot>\\<^sub>v us ! j + - c \\<cdot>\\<^sub>v us ! j\n  \\<in> local.span (set us - {us ! i})", "have \"?v + (- c \\<cdot>\\<^sub>v us ! j) \\<in> span ?E\""], ["proof (prove)\nusing this:\n  us ! i + c \\<cdot>\\<^sub>v us ! j + - c \\<cdot>\\<^sub>v us ! j\n  \\<in> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j + - c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i})", "."], ["proof (state)\nthis:\n  us ! i + c \\<cdot>\\<^sub>v us ! j + - c \\<cdot>\\<^sub>v us ! j\n  \\<in> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  us ! i + c \\<cdot>\\<^sub>v us ! j + - c \\<cdot>\\<^sub>v us ! j\n  \\<in> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "have \"?v + (- c \\<cdot>\\<^sub>v us ! j) = us ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j + - c \\<cdot>\\<^sub>v us ! j = us ! i", "using usi usj"], ["proof (prove)\nusing this:\n  us ! i \\<in> carrier_vec n\n  us ! i \\<notin> set us - {us ! i}\n  us ! i \\<in> set us\n  us ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j + - c \\<cdot>\\<^sub>v us ! j = us ! i", "by auto"], ["proof (state)\nthis:\n  us ! i + c \\<cdot>\\<^sub>v us ! j + - c \\<cdot>\\<^sub>v us ! j = us ! i\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  us ! i \\<in> local.span (set us - {us ! i})", "have mem: \"us ! i \\<in> span ?E\""], ["proof (prove)\nusing this:\n  us ! i \\<in> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. us ! i \\<in> local.span (set us - {us ! i})", "."], ["proof (state)\nthis:\n  us ! i \\<in> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "from in_spanE[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>a A.\n     us ! i = lincomb a A \\<and>\n     finite A \\<and> A \\<subseteq> set us - {us ! i}", "obtain a A where lc: \"us ! i = lincomb a A\" and A: \"finite A\" \n      \"A \\<subseteq> set us - {us ! i}\""], ["proof (prove)\nusing this:\n  \\<exists>a A.\n     us ! i = lincomb a A \\<and>\n     finite A \\<and> A \\<subseteq> set us - {us ! i}\n\ngoal (1 subgoal):\n 1. (\\<And>a A.\n        \\<lbrakk>us ! i = lincomb a A; finite A;\n         A \\<subseteq> set us - {us ! i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  us ! i = lincomb a A\n  finite A\n  A \\<subseteq> set us - {us ! i}\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "let ?a = \"a (us ! i := -1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "let ?A = \"insert (us ! i) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "from A"], ["proof (chain)\npicking this:\n  finite A\n  A \\<subseteq> set us - {us ! i}", "have fin: \"finite ?A\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> set us - {us ! i}\n\ngoal (1 subgoal):\n 1. finite (insert (us ! i) A)", "by auto"], ["proof (state)\nthis:\n  finite (insert (us ! i) A)\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "have lc: \"lincomb ?a A = us ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (a(us ! i := - (1::'a))) A = us ! i", "unfolding lc"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (a(lincomb a A := - (1::'a))) A = lincomb a A", "by (rule lincomb_cong, insert A us lc, auto)"], ["proof (state)\nthis:\n  lincomb (a(us ! i := - (1::'a))) A = us ! i\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "have \"lincomb ?a ?A = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (a(us ! i := - (1::'a))) (insert (us ! i) A) = 0\\<^sub>v n", "by (subst lincomb_insert2[OF A(1)], insert A us lc usi diff, auto)"], ["proof (state)\nthis:\n  lincomb (a(us ! i := - (1::'a))) (insert (us ! i) A) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j\n    \\<in> local.span (set us - {us ! i}) \\<Longrightarrow>\n    False", "from not_lindepD[OF indep _ _ _ this] A usi"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite (insert (us ! i) A); insert (us ! i) A \\<subseteq> set us;\n   a(us ! i := - (1::'a))\n   \\<in> insert (us ! i) A \\<rightarrow> UNIV\\<rbrakk>\n  \\<Longrightarrow> a(us ! i := - (1::'a))\n                    \\<in> insert (us ! i) A \\<rightarrow> {0::'a}\n  finite A\n  A \\<subseteq> set us - {us ! i}\n  us ! i \\<in> carrier_vec n\n  us ! i \\<notin> set us - {us ! i}\n  us ! i \\<in> set us", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (insert (us ! i) A); insert (us ! i) A \\<subseteq> set us;\n   a(us ! i := - (1::'a))\n   \\<in> insert (us ! i) A \\<rightarrow> UNIV\\<rbrakk>\n  \\<Longrightarrow> a(us ! i := - (1::'a))\n                    \\<in> insert (us ! i) A \\<rightarrow> {0::'a}\n  finite A\n  A \\<subseteq> set us - {us ! i}\n  us ! i \\<in> carrier_vec n\n  us ! i \\<notin> set us - {us ! i}\n  us ! i \\<in> set us\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<notin> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "hence vmem: \"?v \\<notin> ?E\""], ["proof (prove)\nusing this:\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<notin> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j \\<notin> set us - {us ! i}", "using span_mem[OF E, of ?v]"], ["proof (prove)\nusing this:\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<notin> local.span (set us - {us ! i})\n  us ! i + c \\<cdot>\\<^sub>v us ! j\n  \\<in> set us - {us ! i} \\<Longrightarrow>\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. us ! i + c \\<cdot>\\<^sub>v us ! j \\<notin> set us - {us ! i}", "by auto"], ["proof (state)\nthis:\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<notin> set us - {us ! i}\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from lin_dep_iff_in_span[OF E indepE v this] vspan"], ["proof (chain)\npicking this:\n  (us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> local.span (set us - {us ! i})) =\n  lin_dep (set us - {us ! i} \\<union> {us ! i + c \\<cdot>\\<^sub>v us ! j})\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<notin> local.span (set us - {us ! i})", "have indep1: \"lin_indpt (set ?V)\""], ["proof (prove)\nusing this:\n  (us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> local.span (set us - {us ! i})) =\n  lin_dep (set us - {us ! i} \\<union> {us ! i + c \\<cdot>\\<^sub>v us ! j})\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<notin> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. lin_indpt (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "unfolding Vid"], ["proof (prove)\nusing this:\n  (us ! i + c \\<cdot>\\<^sub>v us ! j \\<in> local.span (set us - {us ! i})) =\n  lin_dep (set us - {us ! i} \\<union> {us ! i + c \\<cdot>\\<^sub>v us ! j})\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<notin> local.span (set us - {us ! i})\n\ngoal (1 subgoal):\n 1. lin_indpt\n     (insert (us ! i + c \\<cdot>\\<^sub>v us ! j) (set us - {us ! i}))", "by auto"], ["proof (state)\nthis:\n  lin_indpt (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "from vmem dist"], ["proof (chain)\npicking this:\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<notin> set us - {us ! i}\n  distinct us", "have \"distinct ?V\""], ["proof (prove)\nusing this:\n  us ! i + c \\<cdot>\\<^sub>v us ! j \\<notin> set us - {us ! i}\n  distinct us\n\ngoal (1 subgoal):\n 1. distinct (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "by (metis distinct_list_update)"], ["proof (state)\nthis:\n  distinct (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "with indep1 V"], ["proof (chain)\npicking this:\n  lin_indpt (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<subseteq> carrier_vec n\n  distinct (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "show ?thesis"], ["proof (prove)\nusing this:\n  lin_indpt (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<subseteq> carrier_vec n\n  distinct (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])", "unfolding lin_indpt_list_def"], ["proof (prove)\nusing this:\n  lin_indpt (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))\n  set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<subseteq> carrier_vec n\n  distinct (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal (1 subgoal):\n 1. set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n    \\<subseteq> carrier_vec n \\<and>\n    distinct (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]) \\<and>\n    lin_indpt (set (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j]))", "by auto"], ["proof (state)\nthis:\n  lin_indpt_list (us[i := us ! i + c \\<cdot>\\<^sub>v us ! j])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scalar_prod_lincomb_orthogonal: assumes ortho: \"orthogonal gs\" and gs: \"set gs \\<subseteq> carrier_vec n\"\n  shows \"k \\<le> length gs \\<Longrightarrow> sumlist (map (\\<lambda> i. g i \\<cdot>\\<^sub>v gs ! i) [0 ..< k]) \\<bullet> sumlist (map (\\<lambda> i. h i \\<cdot>\\<^sub>v gs ! i) [0 ..< k])\n  = sum_list (map (\\<lambda> i. g i * h i * (gs ! i \\<bullet> gs ! i)) [0 ..< k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "case (Suc k)"], ["proof (state)\nthis:\n  k \\<le> length gs \\<Longrightarrow>\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n  (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gs ! i \\<bullet> gs ! i))\n  Suc k \\<le> length gs\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "note ortho = orthogonalD[OF ortho]"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length gs; ?j < length gs\\<rbrakk>\n  \\<Longrightarrow> (gs ! ?i \\<bullet> gs ! ?j = (0::'a)) = (?i \\<noteq> ?j)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "let ?m = \"length gs\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "from gs Suc(2)"], ["proof (chain)\npicking this:\n  set gs \\<subseteq> carrier_vec n\n  Suc k \\<le> length gs", "have gsi[simp]: \"\\<And> i. i \\<le> k \\<Longrightarrow> gs ! i \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier_vec n\n  Suc k \\<le> length gs\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<le> k \\<Longrightarrow> gs ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?i1 \\<le> k \\<Longrightarrow> gs ! ?i1 \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "from Suc"], ["proof (chain)\npicking this:\n  k \\<le> length gs \\<Longrightarrow>\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n  (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gs ! i \\<bullet> gs ! i))\n  Suc k \\<le> length gs", "have kn: \"k \\<le> ?m\" and k: \"k < ?m\""], ["proof (prove)\nusing this:\n  k \\<le> length gs \\<Longrightarrow>\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n  (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gs ! i \\<bullet> gs ! i))\n  Suc k \\<le> length gs\n\ngoal (1 subgoal):\n 1. k \\<le> length gs &&& k < length gs", "by auto"], ["proof (state)\nthis:\n  k \\<le> length gs\n  k < length gs\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "let ?v1 = \"sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k])\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "let ?v2 = \"(g k \\<cdot>\\<^sub>v gs ! k)\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "let ?w1 = \"sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k])\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "let ?w2 = \"(h k \\<cdot>\\<^sub>v gs ! k)\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "from Suc"], ["proof (chain)\npicking this:\n  k \\<le> length gs \\<Longrightarrow>\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n  (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gs ! i \\<bullet> gs ! i))\n  Suc k \\<le> length gs", "have id: \"[0 ..< Suc k] = [0 ..< k] @ [k]\""], ["proof (prove)\nusing this:\n  k \\<le> length gs \\<Longrightarrow>\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n  (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gs ! i \\<bullet> gs ! i))\n  Suc k \\<le> length gs\n\ngoal (1 subgoal):\n 1. [0..<Suc k] = [0..<k] @ [k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc k] = [0..<k] @ [k]\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "have id: \"sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<Suc k]) = ?v1 + ?v2\"\n     \"sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<Suc k]) = ?w1 + ?w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<Suc k]) =\n    M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n    g k \\<cdot>\\<^sub>v gs ! k &&&\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<Suc k]) =\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n    h k \\<cdot>\\<^sub>v gs ! k", "unfolding id map_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k] @\n      map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [k]) =\n    M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n    g k \\<cdot>\\<^sub>v gs ! k &&&\n    M.sumlist\n     (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k] @\n      map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [k]) =\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n    h k \\<cdot>\\<^sub>v gs ! k", "by (subst sumlist_append, insert Suc(2), auto)+"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<Suc k]) =\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n  g k \\<cdot>\\<^sub>v gs ! k\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<Suc k]) =\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n  h k \\<cdot>\\<^sub>v gs ! k\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "have v1: \"?v1 \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k])\n    \\<in> carrier_vec n", "by (rule sumlist_carrier, insert Suc(2), auto)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k])\n  \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "have v2: \"?v2 \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g k \\<cdot>\\<^sub>v gs ! k \\<in> carrier_vec n", "by (insert Suc(2), auto)"], ["proof (state)\nthis:\n  g k \\<cdot>\\<^sub>v gs ! k \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "have w1: \"?w1 \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k])\n    \\<in> carrier_vec n", "by (rule sumlist_carrier, insert Suc(2), auto)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k])\n  \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "have w2: \"?w2 \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h k \\<cdot>\\<^sub>v gs ! k \\<in> carrier_vec n", "by (insert Suc(2), auto)"], ["proof (state)\nthis:\n  h k \\<cdot>\\<^sub>v gs ! k \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "have gsk: \"gs ! k \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs ! k \\<in> carrier_vec n", "by simp"], ["proof (state)\nthis:\n  gs ! k \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "have v12: \"?v1 + ?v2 \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n    g k \\<cdot>\\<^sub>v gs ! k\n    \\<in> carrier_vec n", "using v1 v2"], ["proof (prove)\nusing this:\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k])\n  \\<in> carrier_vec n\n  g k \\<cdot>\\<^sub>v gs ! k \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n    g k \\<cdot>\\<^sub>v gs ! k\n    \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n  g k \\<cdot>\\<^sub>v gs ! k\n  \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "have w12: \"?w1 + ?w2 \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n    h k \\<cdot>\\<^sub>v gs ! k\n    \\<in> carrier_vec n", "using w1 w2"], ["proof (prove)\nusing this:\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k])\n  \\<in> carrier_vec n\n  h k \\<cdot>\\<^sub>v gs ! k \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n    h k \\<cdot>\\<^sub>v gs ! k\n    \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n  h k \\<cdot>\\<^sub>v gs ! k\n  \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "have 0: \"\\<And> g h. i < k \\<Longrightarrow> (g \\<cdot>\\<^sub>v gs ! i) \\<bullet> (h \\<cdot>\\<^sub>v gs ! k) = 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g h.\n       i < k \\<Longrightarrow>\n       (g \\<cdot>\\<^sub>v gs ! i) \\<bullet> (h \\<cdot>\\<^sub>v gs ! k) =\n       (0::'a)", "by (subst scalar_prod_smult_distrib[OF _ gsk], (insert k, auto)[1],\n    subst smult_scalar_prod_distrib[OF _ gsk], (insert k, auto)[1], insert ortho[of i k] k, auto)"], ["proof (state)\nthis:\n  ?i2 < k \\<Longrightarrow>\n  (?g1 \\<cdot>\\<^sub>v gs ! ?i2) \\<bullet> (?h1 \\<cdot>\\<^sub>v gs ! k) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "have 1: \"?v1 \\<bullet> ?w2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n    (h k \\<cdot>\\<^sub>v gs ! k) =\n    (0::'a)", "by (subst scalar_prod_left_sum_distrib[OF _ w2], (insert Suc(2), auto)[1], rule sum_list_neutral, \n        insert 0, auto)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n  (h k \\<cdot>\\<^sub>v gs ! k) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "have 2: \"?v2 \\<bullet> ?w1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g k \\<cdot>\\<^sub>v gs ! k) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n    (0::'a)", "unfolding comm_scalar_prod[OF v2 w1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n    (g k \\<cdot>\\<^sub>v gs ! k) =\n    (0::'a)", "apply (subst scalar_prod_left_sum_distrib[OF _ v2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> set (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                     [0..<k]) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 2. (\\<Sum>v\\<leftarrow>map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                         [0..<\n                          k]. v \\<bullet> (g k \\<cdot>\\<^sub>v gs ! k)) =\n    (0::'a)", "apply ((insert gs, force)[1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<leftarrow>map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                         [0..<\n                          k]. v \\<bullet> (g k \\<cdot>\\<^sub>v gs ! k)) =\n    (0::'a)", "apply (rule sum_list_neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>v.\n                            v \\<bullet> (g k \\<cdot>\\<^sub>v gs ! k))\n                     (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                       [0..<k])) \\<Longrightarrow>\n       x = (0::'a)", "by (insert 0, auto)"], ["proof (state)\nthis:\n  (g k \\<cdot>\\<^sub>v gs ! k) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> length gs \\<Longrightarrow>\n                M.sumlist\n                 (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                   [0..<k]) \\<bullet>\n                M.sumlist\n                 (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n                (\\<Sum>i\\<leftarrow>[0..<\n                                     k]. g i * h i *\n   (gs ! i \\<bullet> gs ! i));\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) \\<bullet>\n                         M.sumlist\n                          (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i)\n                            [0..<Suc k]) =\n                         (\\<Sum>i\\<leftarrow>[0..<\n        Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<Suc k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<Suc k]) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n     g k \\<cdot>\\<^sub>v gs ! k) \\<bullet>\n    (M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n     h k \\<cdot>\\<^sub>v gs ! k) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "unfolding scalar_prod_add_distrib[OF v12 w1 w2]\n      add_scalar_prod_distrib[OF v1 v2 w1]\n      add_scalar_prod_distrib[OF v1 v2 w2]\n      scalar_prod_smult_distrib[OF w2 gsk]\n      smult_scalar_prod_distrib[OF gsk gsk]"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n    (g k \\<cdot>\\<^sub>v gs ! k) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n    (M.sumlist\n      (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n     (h k \\<cdot>\\<^sub>v gs ! k) +\n     (g k \\<cdot>\\<^sub>v gs ! k) \\<bullet> (h k \\<cdot>\\<^sub>v gs ! k)) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "unfolding Suc(1)[OF kn]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gs ! i \\<bullet> gs ! i)) +\n    (g k \\<cdot>\\<^sub>v gs ! k) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) +\n    (M.sumlist\n      (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n     (h k \\<cdot>\\<^sub>v gs ! k) +\n     (g k \\<cdot>\\<^sub>v gs ! k) \\<bullet> (h k \\<cdot>\\<^sub>v gs ! k)) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "by (simp add: 1 2 comm_scalar_prod[OF v2 w1])"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<Suc k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<Suc k]) =\n  (\\<Sum>i\\<leftarrow>[0..<Suc k]. g i * h i * (gs ! i \\<bullet> gs ! i))\n\ngoal (1 subgoal):\n 1. 0 \\<le> length gs \\<Longrightarrow>\n    M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<0]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<0]) =\n    (\\<Sum>i\\<leftarrow>[0..<0]. g i * h i * (gs ! i \\<bullet> gs ! i))", "qed auto"], ["", "end"], ["", "locale gram_schmidt = cof_vec_space n f_ty\n  for n :: nat and f_ty :: \"'a :: {trivial_conjugatable_linordered_field} itself\"\nbegin"], ["", "definition Gramian_matrix where\n  \"Gramian_matrix G k = (let M = mat k n (\\<lambda> (i,j). (G ! i) $ j) in M * M\\<^sup>T)\""], ["", "lemma Gramian_matrix_alt_def: \"k \\<le> length G \\<Longrightarrow> \n  Gramian_matrix G k = (let M = mat_of_rows n (take k G) in M * M\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> length G \\<Longrightarrow>\n    Gramian_matrix G k = (let M = mat_of_rows n (take k G) in M * M\\<^sup>T)", "unfolding Gramian_matrix_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> length G \\<Longrightarrow>\n    mat k n (\\<lambda>(i, y). G ! i $ y) *\n    (mat k n (\\<lambda>(i, y). G ! i $ y))\\<^sup>T =\n    mat_of_rows n (take k G) * (mat_of_rows n (take k G))\\<^sup>T", "by (rule arg_cong[of _ _ \"\\<lambda> x. x * x\\<^sup>T\"], unfold mat_of_rows_def, intro eq_matI, auto)"], ["", "definition Gramian_determinant where\n  \"Gramian_determinant G k = det (Gramian_matrix G k)\""], ["", "lemma Gramian_determinant_0 [simp]: \"Gramian_determinant G 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_determinant G 0 = (1::'b)", "unfolding Gramian_determinant_def Gramian_matrix_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat 0 n (\\<lambda>(i, y). G ! i $ y) *\n         (mat 0 n (\\<lambda>(i, y). G ! i $ y))\\<^sup>T) =\n    (1::'b)", "by (simp add: times_mat_def)"], ["", "lemma orthogonal_imp_lin_indpt_list: \n  assumes ortho: \"orthogonal gs\" and gs: \"set gs \\<subseteq> carrier_vec n\"\n  shows \"lin_indpt_list gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt_list gs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lin_indpt_list gs", "from corthogonal_distinct[of gs] ortho"], ["proof (chain)\npicking this:\n  corthogonal gs \\<Longrightarrow> distinct gs\n  orthogonal gs", "have dist: \"distinct gs\""], ["proof (prove)\nusing this:\n  corthogonal gs \\<Longrightarrow> distinct gs\n  orthogonal gs\n\ngoal (1 subgoal):\n 1. distinct gs", "by simp"], ["proof (state)\nthis:\n  distinct gs\n\ngoal (1 subgoal):\n 1. lin_indpt_list gs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt_list gs", "unfolding lin_indpt_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set gs \\<subseteq> carrier_vec n \\<and>\n    distinct gs \\<and> lin_indpt (set gs)", "proof (intro conjI gs dist finite_lin_indpt2 finite_set)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "fix lc"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "assume 0: \"lincomb lc (set gs) = 0\\<^sub>v n\" (is \"?lc = _\")"], ["proof (state)\nthis:\n  lincomb lc (set gs) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "have lc: \"?lc \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb lc (set gs) \\<in> carrier_vec n", "by (rule lincomb_closed[OF gs])"], ["proof (state)\nthis:\n  lincomb lc (set gs) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "let ?m = \"length gs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "from 0"], ["proof (chain)\npicking this:\n  lincomb lc (set gs) = 0\\<^sub>v n", "have \"0 = ?lc \\<bullet> ?lc\""], ["proof (prove)\nusing this:\n  lincomb lc (set gs) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (0::'a) = lincomb lc (set gs) \\<bullet> lincomb lc (set gs)", "by simp"], ["proof (state)\nthis:\n  (0::'a) = lincomb lc (set gs) \\<bullet> lincomb lc (set gs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "also"], ["proof (state)\nthis:\n  (0::'a) = lincomb lc (set gs) \\<bullet> lincomb lc (set gs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "have \"?lc = lincomb_list (\\<lambda>i. lc (gs ! i)) gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb lc (set gs) = lincomb_list (\\<lambda>i. lc (gs ! i)) gs", "unfolding lincomb_as_lincomb_list_distinct[OF gs dist]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list (\\<lambda>i. lc (gs ! i)) gs =\n    lincomb_list (\\<lambda>i. lc (gs ! i)) gs", ".."], ["proof (state)\nthis:\n  lincomb lc (set gs) = lincomb_list (\\<lambda>i. lc (gs ! i)) gs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "also"], ["proof (state)\nthis:\n  lincomb lc (set gs) = lincomb_list (\\<lambda>i. lc (gs ! i)) gs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "have \"\\<dots> = sumlist (map (\\<lambda>i. lc (gs ! i) \\<cdot>\\<^sub>v gs ! i) [0..< ?m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list (\\<lambda>i. lc (gs ! i)) gs =\n    M.sumlist\n     (map (\\<lambda>i. lc (gs ! i) \\<cdot>\\<^sub>v gs ! i) [0..<length gs])", "unfolding lincomb_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. lc (gs ! i) \\<cdot>\\<^sub>v gs ! i)\n       [0..<length gs]) =\n    M.sumlist\n     (map (\\<lambda>i. lc (gs ! i) \\<cdot>\\<^sub>v gs ! i) [0..<length gs])", "by auto"], ["proof (state)\nthis:\n  lincomb_list (\\<lambda>i. lc (gs ! i)) gs =\n  M.sumlist\n   (map (\\<lambda>i. lc (gs ! i) \\<cdot>\\<^sub>v gs ! i) [0..<length gs])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "also"], ["proof (state)\nthis:\n  lincomb_list (\\<lambda>i. lc (gs ! i)) gs =\n  M.sumlist\n   (map (\\<lambda>i. lc (gs ! i) \\<cdot>\\<^sub>v gs ! i) [0..<length gs])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "have \"\\<dots> \\<bullet> \\<dots> = (\\<Sum>i\\<leftarrow>[0..<?m]. (lc (gs ! i) * lc (gs ! i)) * sq_norm (gs ! i))\" (is \"_ = sum_list ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. lc (gs ! i) \\<cdot>\\<^sub>v gs ! i)\n       [0..<length gs]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>i. lc (gs ! i) \\<cdot>\\<^sub>v gs ! i)\n       [0..<length gs]) =\n    (\\<Sum>i\\<leftarrow>[0..<\n                         length\n                          gs]. lc (gs ! i) * lc (gs ! i) *\n                               \\<parallel>gs ! i\\<parallel>\\<^sup>2)", "unfolding scalar_prod_lincomb_orthogonal[OF ortho gs le_refl]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<\n                         length\n                          gs]. lc (gs ! i) * lc (gs ! i) *\n                               (gs ! i \\<bullet> gs ! i)) =\n    (\\<Sum>i\\<leftarrow>[0..<\n                         length\n                          gs]. lc (gs ! i) * lc (gs ! i) *\n                               \\<parallel>gs ! i\\<parallel>\\<^sup>2)", "by (auto simp: sq_norm_vec_as_cscalar_prod power2_eq_square)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. lc (gs ! i) \\<cdot>\\<^sub>v gs ! i)\n     [0..<length gs]) \\<bullet>\n  M.sumlist\n   (map (\\<lambda>i. lc (gs ! i) \\<cdot>\\<^sub>v gs ! i) [0..<length gs]) =\n  (\\<Sum>i\\<leftarrow>[0..<\n                       length\n                        gs]. lc (gs ! i) * lc (gs ! i) *\n                             \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (0::'a) =\n  (\\<Sum>i\\<leftarrow>[0..<\n                       length\n                        gs]. lc (gs ! i) * lc (gs ! i) *\n                             \\<parallel>gs ! i\\<parallel>\\<^sup>2)", "have sum_0: \"sum_list ?sum = 0\""], ["proof (prove)\nusing this:\n  (0::'a) =\n  (\\<Sum>i\\<leftarrow>[0..<\n                       length\n                        gs]. lc (gs ! i) * lc (gs ! i) *\n                             \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<\n                         length\n                          gs]. lc (gs ! i) * lc (gs ! i) *\n                               \\<parallel>gs ! i\\<parallel>\\<^sup>2) =\n    (0::'a)", ".."], ["proof (state)\nthis:\n  (\\<Sum>i\\<leftarrow>[0..<\n                       length\n                        gs]. lc (gs ! i) * lc (gs ! i) *\n                             \\<parallel>gs ! i\\<parallel>\\<^sup>2) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "have nonneg: \"\\<And> x. x \\<in> set ?sum \\<Longrightarrow> x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>i.\n                            lc (gs ! i) * lc (gs ! i) *\n                            \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n                     [0..<length gs]) \\<Longrightarrow>\n       (0::'a) \\<le> x", "using zero_le_square[of \"lc (gs ! i)\" for i] sq_norm_vec_ge_0[of \"gs ! i\" for i]"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> lc (gs ! ?i5) * lc (gs ! ?i5)\n  (0::'a) \\<le> \\<parallel>gs ! ?i5\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>i.\n                            lc (gs ! i) * lc (gs ! i) *\n                            \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n                     [0..<length gs]) \\<Longrightarrow>\n       (0::'a) \\<le> x", "by auto"], ["proof (state)\nthis:\n  ?x3\n  \\<in> set (map (\\<lambda>i.\n                     lc (gs ! i) * lc (gs ! i) *\n                     \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n              [0..<length gs]) \\<Longrightarrow>\n  (0::'a) \\<le> ?x3\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "{"], ["proof (state)\nthis:\n  ?x3\n  \\<in> set (map (\\<lambda>i.\n                     lc (gs ! i) * lc (gs ! i) *\n                     \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n              [0..<length gs]) \\<Longrightarrow>\n  (0::'a) \\<le> ?x3\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "assume x: \"x \\<in> set gs\""], ["proof (state)\nthis:\n  x \\<in> set gs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "then"], ["proof (chain)\npicking this:\n  x \\<in> set gs", "obtain i where i: \"i < ?m\" and x: \"x = gs ! i\""], ["proof (prove)\nusing this:\n  x \\<in> set gs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length gs; x = gs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  x \\<in> {gs ! i |i. i < length gs}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length gs; x = gs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length gs\n  x = gs ! i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "hence \"lc x * lc x * sq_norm x \\<in> set ?sum\""], ["proof (prove)\nusing this:\n  i < length gs\n  x = gs ! i\n\ngoal (1 subgoal):\n 1. lc x * lc x * \\<parallel>x\\<parallel>\\<^sup>2\n    \\<in> set (map (\\<lambda>i.\n                       lc (gs ! i) * lc (gs ! i) *\n                       \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n                [0..<length gs])", "by auto"], ["proof (state)\nthis:\n  lc x * lc x * \\<parallel>x\\<parallel>\\<^sup>2\n  \\<in> set (map (\\<lambda>i.\n                     lc (gs ! i) * lc (gs ! i) *\n                     \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n              [0..<length gs])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "with sum_list_nonneg_eq_0_iff[of ?sum, OF nonneg] sum_0"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> set (map (\\<lambda>i.\n                           lc (gs ! i) * lc (gs ! i) *\n                           \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n                    [0..<length gs]) \\<Longrightarrow>\n      x \\<in> set (map (\\<lambda>i.\n                           lc (gs ! i) * lc (gs ! i) *\n                           \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n                    [0..<length gs])) \\<Longrightarrow>\n  ((\\<Sum>i\\<leftarrow>[0..<\n                        length\n                         gs]. lc (gs ! i) * lc (gs ! i) *\n                              \\<parallel>gs ! i\\<parallel>\\<^sup>2) =\n   (0::'a)) =\n  (\\<forall>x\\<in>set (map (\\<lambda>i.\n                               lc (gs ! i) * lc (gs ! i) *\n                               \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n                        [0..<length gs]).\n      x = (0::'a))\n  (\\<Sum>i\\<leftarrow>[0..<\n                       length\n                        gs]. lc (gs ! i) * lc (gs ! i) *\n                             \\<parallel>gs ! i\\<parallel>\\<^sup>2) =\n  (0::'a)\n  lc x * lc x * \\<parallel>x\\<parallel>\\<^sup>2\n  \\<in> set (map (\\<lambda>i.\n                     lc (gs ! i) * lc (gs ! i) *\n                     \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n              [0..<length gs])", "have \"lc x = 0 \\<or> sq_norm x = 0\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set (map (\\<lambda>i.\n                           lc (gs ! i) * lc (gs ! i) *\n                           \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n                    [0..<length gs]) \\<Longrightarrow>\n      x \\<in> set (map (\\<lambda>i.\n                           lc (gs ! i) * lc (gs ! i) *\n                           \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n                    [0..<length gs])) \\<Longrightarrow>\n  ((\\<Sum>i\\<leftarrow>[0..<\n                        length\n                         gs]. lc (gs ! i) * lc (gs ! i) *\n                              \\<parallel>gs ! i\\<parallel>\\<^sup>2) =\n   (0::'a)) =\n  (\\<forall>x\\<in>set (map (\\<lambda>i.\n                               lc (gs ! i) * lc (gs ! i) *\n                               \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n                        [0..<length gs]).\n      x = (0::'a))\n  (\\<Sum>i\\<leftarrow>[0..<\n                       length\n                        gs]. lc (gs ! i) * lc (gs ! i) *\n                             \\<parallel>gs ! i\\<parallel>\\<^sup>2) =\n  (0::'a)\n  lc x * lc x * \\<parallel>x\\<parallel>\\<^sup>2\n  \\<in> set (map (\\<lambda>i.\n                     lc (gs ! i) * lc (gs ! i) *\n                     \\<parallel>gs ! i\\<parallel>\\<^sup>2)\n              [0..<length gs])\n\ngoal (1 subgoal):\n 1. lc x = (0::'a) \\<or> \\<parallel>x\\<parallel>\\<^sup>2 = (0::'a)", "by auto"], ["proof (state)\nthis:\n  lc x = (0::'a) \\<or> \\<parallel>x\\<parallel>\\<^sup>2 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "with orthogonalD[OF ortho, OF i i, folded x]"], ["proof (chain)\npicking this:\n  (x \\<bullet> x = (0::'a)) = (i \\<noteq> i)\n  lc x = (0::'a) \\<or> \\<parallel>x\\<parallel>\\<^sup>2 = (0::'a)", "have \"lc x = 0\""], ["proof (prove)\nusing this:\n  (x \\<bullet> x = (0::'a)) = (i \\<noteq> i)\n  lc x = (0::'a) \\<or> \\<parallel>x\\<parallel>\\<^sup>2 = (0::'a)\n\ngoal (1 subgoal):\n 1. lc x = (0::'a)", "by (auto simp: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  lc x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "}"], ["proof (state)\nthis:\n  ?x5 \\<in> set gs \\<Longrightarrow> lc ?x5 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>True; lincomb a (set gs) = 0\\<^sub>v n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set gs. a v = (0::'a)", "thus \"\\<forall>v\\<in>set gs. lc v = 0\""], ["proof (prove)\nusing this:\n  ?x5 \\<in> set gs \\<Longrightarrow> lc ?x5 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set gs. lc v = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set gs. lc v = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lin_indpt_list gs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthocompl_span:\n  assumes \"\\<And> x. x \\<in> S \\<Longrightarrow> v \\<bullet> x = 0\" \"S \\<subseteq> carrier_vec n\" and [intro]: \"v \\<in> carrier_vec n\"\n  and \"y \\<in> span S\" \n  shows \"v \\<bullet> y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "fix a A"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "assume \"y = lincomb a A\" \"finite A\" \"A \\<subseteq> S\""], ["proof (state)\nthis:\n  y = lincomb a A\n  finite A\n  A \\<subseteq> S\n\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "note assms = assms this"], ["proof (state)\nthis:\n  ?x3 \\<in> S \\<Longrightarrow> v \\<bullet> ?x3 = (0::'a)\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n\n  y \\<in> local.span S\n  y = lincomb a A\n  finite A\n  A \\<subseteq> S\n\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "hence [intro!]:\"lincomb a A \\<in> carrier_vec n\" \"(\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n\""], ["proof (prove)\nusing this:\n  ?x3 \\<in> S \\<Longrightarrow> v \\<bullet> ?x3 = (0::'a)\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n\n  y \\<in> local.span S\n  y = lincomb a A\n  finite A\n  A \\<subseteq> S\n\ngoal (1 subgoal):\n 1. lincomb a A \\<in> carrier_vec n &&&\n    (\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  lincomb a A \\<in> carrier_vec n\n  (\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "have \"\\<forall>x\\<in>A. (a x \\<cdot>\\<^sub>v x) \\<bullet> v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)", "assume \"x \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)", "note assms = assms this"], ["proof (state)\nthis:\n  ?x3 \\<in> S \\<Longrightarrow> v \\<bullet> ?x3 = (0::'a)\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n\n  y \\<in> local.span S\n  y = lincomb a A\n  finite A\n  A \\<subseteq> S\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)", "hence x:\"x \\<in> S\""], ["proof (prove)\nusing this:\n  ?x3 \\<in> S \\<Longrightarrow> v \\<bullet> ?x3 = (0::'a)\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n\n  y \\<in> local.span S\n  y = lincomb a A\n  finite A\n  A \\<subseteq> S\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<in> S", "by auto"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)", "with assms"], ["proof (chain)\npicking this:\n  ?x3 \\<in> S \\<Longrightarrow> v \\<bullet> ?x3 = (0::'a)\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n\n  y \\<in> local.span S\n  y = lincomb a A\n  finite A\n  A \\<subseteq> S\n  x \\<in> A\n  x \\<in> S", "have [intro]:\"x \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  ?x3 \\<in> S \\<Longrightarrow> v \\<bullet> ?x3 = (0::'a)\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n\n  y \\<in> local.span S\n  y = lincomb a A\n  finite A\n  A \\<subseteq> S\n  x \\<in> A\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)", "from assms(1)[OF x]"], ["proof (chain)\npicking this:\n  v \\<bullet> x = (0::'a)", "have \"x \\<bullet> v = 0\""], ["proof (prove)\nusing this:\n  v \\<bullet> x = (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<bullet> v = (0::'a)", "by(subst comm_scalar_prod) force+"], ["proof (state)\nthis:\n  x \\<bullet> v = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)", "thus \"(a x \\<cdot>\\<^sub>v x) \\<bullet> v = 0\""], ["proof (prove)\nusing this:\n  x \\<bullet> v = (0::'a)\n\ngoal (1 subgoal):\n 1. (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)", "apply(subst smult_scalar_prod_distrib)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<bullet> v = (0::'a) \\<Longrightarrow> x \\<in> carrier_vec ?n1\n 2. x \\<bullet> v = (0::'a) \\<Longrightarrow> v \\<in> carrier_vec ?n1\n 3. x \\<bullet> v = (0::'a) \\<Longrightarrow>\n    a x * (x \\<bullet> v) = (0::'a)", "by force+"], ["proof (state)\nthis:\n  (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>A. (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)\n\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "hence \"v \\<bullet> lincomb a A = 0\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>A. (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a)\n\ngoal (1 subgoal):\n 1. v \\<bullet> lincomb a A = (0::'a)", "apply(subst comm_scalar_prod)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>A.\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a) \\<Longrightarrow>\n    v \\<in> carrier_vec ?n1\n 2. \\<forall>x\\<in>A.\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a) \\<Longrightarrow>\n    lincomb a A \\<in> carrier_vec ?n1\n 3. \\<forall>x\\<in>A.\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a) \\<Longrightarrow>\n    lincomb a A \\<bullet> v = (0::'a)", "apply force+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a) \\<Longrightarrow>\n    lincomb a A \\<bullet> v = (0::'a)", "unfolding lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a) \\<Longrightarrow>\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. a v \\<cdot>\\<^sub>v v) \\<bullet> v =\n    (0::'a)", "apply(subst finsum_scalar_prod_sum)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>A.\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a) \\<Longrightarrow>\n    (\\<lambda>v. a v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n\n 2. \\<forall>x\\<in>A.\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a) \\<Longrightarrow>\n    v \\<in> carrier_vec n\n 3. \\<forall>x\\<in>A.\n       (a x \\<cdot>\\<^sub>v x) \\<bullet> v = (0::'a) \\<Longrightarrow>\n    (\\<Sum>u\\<in>A. (a u \\<cdot>\\<^sub>v u) \\<bullet> v) = (0::'a)", "by force+"], ["proof (state)\nthis:\n  v \\<bullet> lincomb a A = (0::'a)\n\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>y = lincomb ?a5 ?A5; finite ?A5; ?A5 \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> v \\<bullet> lincomb ?a5 ?A5 = (0::'a)\n\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>y = lincomb ?a5 ?A5; finite ?A5; ?A5 \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> v \\<bullet> lincomb ?a5 ?A5 = (0::'a)\n\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "using \\<open>y \\<in> span S\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>y = lincomb ?a5 ?A5; finite ?A5; ?A5 \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> v \\<bullet> lincomb ?a5 ?A5 = (0::'a)\n  y \\<in> local.span S\n\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "unfolding span_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>y = lincomb ?a5 ?A5; finite ?A5; ?A5 \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> v \\<bullet> lincomb ?a5 ?A5 = (0::'a)\n  y \\<in> {lincomb a A |a A. finite A \\<and> A \\<subseteq> S}\n\ngoal (1 subgoal):\n 1. v \\<bullet> y = (0::'a)", "by auto"], ["proof (state)\nthis:\n  v \\<bullet> y = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_sumlist:\n  assumes ortho: \"\\<And> x. x \\<in> set S \\<Longrightarrow> v \\<bullet> x = 0\" and S: \"set S \\<subseteq> carrier_vec n\" and v: \"v \\<in> carrier_vec n\"\n  shows \"v \\<bullet> sumlist S = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<bullet> M.sumlist S = (0::'a)", "by (rule orthocompl_span[OF ortho S v sumlist_in_span[OF S span_mem[OF S]]])"], ["", "lemma oc_projection_alt_def:\n  assumes carr:\"(W::'a vec set) \\<subseteq> carrier_vec n\" \"x \\<in> carrier_vec n\"\n      and alt1:\"y1 \\<in> W\" \"x - y1 \\<in> orthogonal_complement W\"\n      and alt2:\"y2 \\<in> W\" \"x - y2 \\<in> orthogonal_complement W\"\n  shows  \"y1 = y2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y1 = y2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y1 = y2", "have carr:\"y1 \\<in> carrier_vec n\" \"y2 \\<in> carrier_vec n\" \"x \\<in> carrier_vec n\" \"- y1 \\<in> carrier_vec n\" \n    \"0\\<^sub>v n \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y1 \\<in> carrier_vec n &&& y2 \\<in> carrier_vec n) &&&\n    x \\<in> carrier_vec n &&&\n    - y1 \\<in> carrier_vec n &&& 0\\<^sub>v n \\<in> carrier_vec n", "using alt1 alt2 carr"], ["proof (prove)\nusing this:\n  y1 \\<in> W\n  x - y1 \\<in> orthogonal_complement W\n  y2 \\<in> W\n  x - y2 \\<in> orthogonal_complement W\n  W \\<subseteq> carrier_vec n\n  x \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (y1 \\<in> carrier_vec n &&& y2 \\<in> carrier_vec n) &&&\n    x \\<in> carrier_vec n &&&\n    - y1 \\<in> carrier_vec n &&& 0\\<^sub>v n \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  y1 \\<in> carrier_vec n\n  y2 \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n  - y1 \\<in> carrier_vec n\n  0\\<^sub>v n \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. y1 = y2", "hence \"y1 - y2 \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  y1 \\<in> carrier_vec n\n  y2 \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n  - y1 \\<in> carrier_vec n\n  0\\<^sub>v n \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. y1 - y2 \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  y1 - y2 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. y1 = y2", "note carr = this carr"], ["proof (state)\nthis:\n  y1 - y2 \\<in> carrier_vec n\n  y1 \\<in> carrier_vec n\n  y2 \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n  - y1 \\<in> carrier_vec n\n  0\\<^sub>v n \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. y1 = y2", "from alt1"], ["proof (chain)\npicking this:\n  y1 \\<in> W\n  x - y1 \\<in> orthogonal_complement W", "have \"ya\\<in>W \\<Longrightarrow> (x - y1) \\<bullet> ya = 0\" for ya"], ["proof (prove)\nusing this:\n  y1 \\<in> W\n  x - y1 \\<in> orthogonal_complement W\n\ngoal (1 subgoal):\n 1. ya \\<in> W \\<Longrightarrow> (x - y1) \\<bullet> ya = (0::'a)", "unfolding orthogonal_complement_def"], ["proof (prove)\nusing this:\n  y1 \\<in> W\n  x - y1\n  \\<in> {x \\<in> carrier_vec n. \\<forall>y\\<in>W. x \\<bullet> y = (0::'a)}\n\ngoal (1 subgoal):\n 1. ya \\<in> W \\<Longrightarrow> (x - y1) \\<bullet> ya = (0::'a)", "by blast"], ["proof (state)\nthis:\n  ?ya4 \\<in> W \\<Longrightarrow> (x - y1) \\<bullet> ?ya4 = (0::'a)\n\ngoal (1 subgoal):\n 1. y1 = y2", "hence \"(x - y1) \\<bullet> y2 = 0\" \"(x - y1) \\<bullet> y1 = 0\""], ["proof (prove)\nusing this:\n  ?ya4 \\<in> W \\<Longrightarrow> (x - y1) \\<bullet> ?ya4 = (0::'a)\n\ngoal (1 subgoal):\n 1. (x - y1) \\<bullet> y2 = (0::'a) &&& (x - y1) \\<bullet> y1 = (0::'a)", "using alt2 alt1"], ["proof (prove)\nusing this:\n  ?ya4 \\<in> W \\<Longrightarrow> (x - y1) \\<bullet> ?ya4 = (0::'a)\n  y2 \\<in> W\n  x - y2 \\<in> orthogonal_complement W\n  y1 \\<in> W\n  x - y1 \\<in> orthogonal_complement W\n\ngoal (1 subgoal):\n 1. (x - y1) \\<bullet> y2 = (0::'a) &&& (x - y1) \\<bullet> y1 = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (x - y1) \\<bullet> y2 = (0::'a)\n  (x - y1) \\<bullet> y1 = (0::'a)\n\ngoal (1 subgoal):\n 1. y1 = y2", "hence eq1:\"y1 \\<bullet> y2 = x \\<bullet> y2\" \"y1 \\<bullet> y1 = x \\<bullet> y1\""], ["proof (prove)\nusing this:\n  (x - y1) \\<bullet> y2 = (0::'a)\n  (x - y1) \\<bullet> y1 = (0::'a)\n\ngoal (1 subgoal):\n 1. y1 \\<bullet> y2 = x \\<bullet> y2 &&& y1 \\<bullet> y1 = x \\<bullet> y1", "using carr minus_scalar_prod_distrib"], ["proof (prove)\nusing this:\n  (x - y1) \\<bullet> y2 = (0::'a)\n  (x - y1) \\<bullet> y1 = (0::'a)\n  y1 - y2 \\<in> carrier_vec n\n  y1 \\<in> carrier_vec n\n  y2 \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n  - y1 \\<in> carrier_vec n\n  0\\<^sub>v n \\<in> carrier_vec n\n  \\<lbrakk>?v\\<^sub>1 \\<in> carrier_vec ?n; ?v\\<^sub>2 \\<in> carrier_vec ?n;\n   ?v\\<^sub>3 \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> (?v\\<^sub>1 - ?v\\<^sub>2) \\<bullet> ?v\\<^sub>3 =\n                    ?v\\<^sub>1 \\<bullet> ?v\\<^sub>3 -\n                    ?v\\<^sub>2 \\<bullet> ?v\\<^sub>3\n\ngoal (1 subgoal):\n 1. y1 \\<bullet> y2 = x \\<bullet> y2 &&& y1 \\<bullet> y1 = x \\<bullet> y1", "by force+"], ["proof (state)\nthis:\n  y1 \\<bullet> y2 = x \\<bullet> y2\n  y1 \\<bullet> y1 = x \\<bullet> y1\n\ngoal (1 subgoal):\n 1. y1 = y2", "from this(1)"], ["proof (chain)\npicking this:\n  y1 \\<bullet> y2 = x \\<bullet> y2", "have eq2:\"y2 \\<bullet> y1 = x \\<bullet> y2\""], ["proof (prove)\nusing this:\n  y1 \\<bullet> y2 = x \\<bullet> y2\n\ngoal (1 subgoal):\n 1. y2 \\<bullet> y1 = x \\<bullet> y2", "using carr comm_scalar_prod"], ["proof (prove)\nusing this:\n  y1 \\<bullet> y2 = x \\<bullet> y2\n  y1 - y2 \\<in> carrier_vec n\n  y1 \\<in> carrier_vec n\n  y2 \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n  - y1 \\<in> carrier_vec n\n  0\\<^sub>v n \\<in> carrier_vec n\n  \\<lbrakk>?v\\<^sub>1 \\<in> carrier_vec ?n;\n   ?v\\<^sub>2 \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> ?v\\<^sub>1 \\<bullet> ?v\\<^sub>2 =\n                    ?v\\<^sub>2 \\<bullet> ?v\\<^sub>1\n\ngoal (1 subgoal):\n 1. y2 \\<bullet> y1 = x \\<bullet> y2", "by force"], ["proof (state)\nthis:\n  y2 \\<bullet> y1 = x \\<bullet> y2\n\ngoal (1 subgoal):\n 1. y1 = y2", "from alt2"], ["proof (chain)\npicking this:\n  y2 \\<in> W\n  x - y2 \\<in> orthogonal_complement W", "have \"ya\\<in>W \\<Longrightarrow> (x - y2) \\<bullet> ya = 0\" for ya"], ["proof (prove)\nusing this:\n  y2 \\<in> W\n  x - y2 \\<in> orthogonal_complement W\n\ngoal (1 subgoal):\n 1. ya \\<in> W \\<Longrightarrow> (x - y2) \\<bullet> ya = (0::'a)", "unfolding orthogonal_complement_def"], ["proof (prove)\nusing this:\n  y2 \\<in> W\n  x - y2\n  \\<in> {x \\<in> carrier_vec n. \\<forall>y\\<in>W. x \\<bullet> y = (0::'a)}\n\ngoal (1 subgoal):\n 1. ya \\<in> W \\<Longrightarrow> (x - y2) \\<bullet> ya = (0::'a)", "by blast"], ["proof (state)\nthis:\n  ?ya4 \\<in> W \\<Longrightarrow> (x - y2) \\<bullet> ?ya4 = (0::'a)\n\ngoal (1 subgoal):\n 1. y1 = y2", "hence \"(x - y2) \\<bullet> y1 = 0\" \"(x - y2) \\<bullet> y2 = 0\""], ["proof (prove)\nusing this:\n  ?ya4 \\<in> W \\<Longrightarrow> (x - y2) \\<bullet> ?ya4 = (0::'a)\n\ngoal (1 subgoal):\n 1. (x - y2) \\<bullet> y1 = (0::'a) &&& (x - y2) \\<bullet> y2 = (0::'a)", "using alt2 alt1"], ["proof (prove)\nusing this:\n  ?ya4 \\<in> W \\<Longrightarrow> (x - y2) \\<bullet> ?ya4 = (0::'a)\n  y2 \\<in> W\n  x - y2 \\<in> orthogonal_complement W\n  y1 \\<in> W\n  x - y1 \\<in> orthogonal_complement W\n\ngoal (1 subgoal):\n 1. (x - y2) \\<bullet> y1 = (0::'a) &&& (x - y2) \\<bullet> y2 = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (x - y2) \\<bullet> y1 = (0::'a)\n  (x - y2) \\<bullet> y2 = (0::'a)\n\ngoal (1 subgoal):\n 1. y1 = y2", "hence eq3:\"y2 \\<bullet> y2 = x \\<bullet> y2\" \"y2 \\<bullet> y1 = x \\<bullet> y1\""], ["proof (prove)\nusing this:\n  (x - y2) \\<bullet> y1 = (0::'a)\n  (x - y2) \\<bullet> y2 = (0::'a)\n\ngoal (1 subgoal):\n 1. y2 \\<bullet> y2 = x \\<bullet> y2 &&& y2 \\<bullet> y1 = x \\<bullet> y1", "using carr minus_scalar_prod_distrib"], ["proof (prove)\nusing this:\n  (x - y2) \\<bullet> y1 = (0::'a)\n  (x - y2) \\<bullet> y2 = (0::'a)\n  y1 - y2 \\<in> carrier_vec n\n  y1 \\<in> carrier_vec n\n  y2 \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n  - y1 \\<in> carrier_vec n\n  0\\<^sub>v n \\<in> carrier_vec n\n  \\<lbrakk>?v\\<^sub>1 \\<in> carrier_vec ?n; ?v\\<^sub>2 \\<in> carrier_vec ?n;\n   ?v\\<^sub>3 \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> (?v\\<^sub>1 - ?v\\<^sub>2) \\<bullet> ?v\\<^sub>3 =\n                    ?v\\<^sub>1 \\<bullet> ?v\\<^sub>3 -\n                    ?v\\<^sub>2 \\<bullet> ?v\\<^sub>3\n\ngoal (1 subgoal):\n 1. y2 \\<bullet> y2 = x \\<bullet> y2 &&& y2 \\<bullet> y1 = x \\<bullet> y1", "by force+"], ["proof (state)\nthis:\n  y2 \\<bullet> y2 = x \\<bullet> y2\n  y2 \\<bullet> y1 = x \\<bullet> y1\n\ngoal (1 subgoal):\n 1. y1 = y2", "with eq2"], ["proof (chain)\npicking this:\n  y2 \\<bullet> y1 = x \\<bullet> y2\n  y2 \\<bullet> y2 = x \\<bullet> y2\n  y2 \\<bullet> y1 = x \\<bullet> y1", "have eq4:\"x \\<bullet> y1 = x \\<bullet> y2\""], ["proof (prove)\nusing this:\n  y2 \\<bullet> y1 = x \\<bullet> y2\n  y2 \\<bullet> y2 = x \\<bullet> y2\n  y2 \\<bullet> y1 = x \\<bullet> y1\n\ngoal (1 subgoal):\n 1. x \\<bullet> y1 = x \\<bullet> y2", "by auto"], ["proof (state)\nthis:\n  x \\<bullet> y1 = x \\<bullet> y2\n\ngoal (1 subgoal):\n 1. y1 = y2", "have \"\\<parallel>(y1 - y2)\\<parallel>\\<^sup>2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>y1 - y2\\<parallel>\\<^sup>2 = (0::'a)", "unfolding sq_norm_vec_as_cscalar_prod cscalar_prod_is_scalar_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y1 - y2) \\<bullet> (y1 - y2) = (0::'a)", "using carr"], ["proof (prove)\nusing this:\n  y1 - y2 \\<in> carrier_vec n\n  y1 \\<in> carrier_vec n\n  y2 \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n  - y1 \\<in> carrier_vec n\n  0\\<^sub>v n \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (y1 - y2) \\<bullet> (y1 - y2) = (0::'a)", "apply(subst minus_scalar_prod_distrib)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> y1 \\<in> carrier_vec ?n11\n 2. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> y2 \\<in> carrier_vec ?n11\n 3. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> y1 - y2 \\<in> carrier_vec ?n11\n 4. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> y1 \\<bullet> (y1 - y2) - y2 \\<bullet> (y1 - y2) =\n                      (0::'a)", "apply force+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> y1 \\<bullet> (y1 - y2) - y2 \\<bullet> (y1 - y2) =\n                      (0::'a)", "apply(subst (0 0) scalar_prod_minus_distrib)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> y1 \\<in> carrier_vec ?n18\n 2. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> y2 \\<in> carrier_vec ?n18\n 3. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> y2 \\<in> carrier_vec ?n19\n 4. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> y1 \\<in> carrier_vec ?n19\n 5. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> y1 \\<bullet> y1 - y1 \\<bullet> y2 -\n                      (y2 \\<bullet> y1 - y2 \\<bullet> y2) =\n                      (0::'a)", "apply force+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> y1 \\<bullet> y1 - y1 \\<bullet> y2 -\n                      (y2 \\<bullet> y1 - y2 \\<bullet> y2) =\n                      (0::'a)", "unfolding eq1 eq2 eq3 eq4"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y1 - y2 \\<in> carrier_vec n; y1 \\<in> carrier_vec n;\n     y2 \\<in> carrier_vec n; x \\<in> carrier_vec n;\n     - y1 \\<in> carrier_vec n; 0\\<^sub>v n \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> x \\<bullet> y2 - x \\<bullet> y2 -\n                      (x \\<bullet> y2 - x \\<bullet> y2) =\n                      (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<parallel>y1 - y2\\<parallel>\\<^sup>2 = (0::'a)\n\ngoal (1 subgoal):\n 1. y1 = y2", "with sq_norm_vec_eq_0[of \"(y1 - y2)\"] carr"], ["proof (chain)\npicking this:\n  y1 - y2 \\<in> carrier_vec ?n \\<Longrightarrow>\n  (\\<parallel>y1 - y2\\<parallel>\\<^sup>2 = (0::'a)) =\n  (y1 - y2 = 0\\<^sub>v ?n)\n  y1 - y2 \\<in> carrier_vec n\n  y1 \\<in> carrier_vec n\n  y2 \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n  - y1 \\<in> carrier_vec n\n  0\\<^sub>v n \\<in> carrier_vec n\n  \\<parallel>y1 - y2\\<parallel>\\<^sup>2 = (0::'a)", "have \"y1 - y2 = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  y1 - y2 \\<in> carrier_vec ?n \\<Longrightarrow>\n  (\\<parallel>y1 - y2\\<parallel>\\<^sup>2 = (0::'a)) =\n  (y1 - y2 = 0\\<^sub>v ?n)\n  y1 - y2 \\<in> carrier_vec n\n  y1 \\<in> carrier_vec n\n  y2 \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n  - y1 \\<in> carrier_vec n\n  0\\<^sub>v n \\<in> carrier_vec n\n  \\<parallel>y1 - y2\\<parallel>\\<^sup>2 = (0::'a)\n\ngoal (1 subgoal):\n 1. y1 - y2 = 0\\<^sub>v n", "by fastforce"], ["proof (state)\nthis:\n  y1 - y2 = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. y1 = y2", "hence \"y1 - y2 + y2 = y2\""], ["proof (prove)\nusing this:\n  y1 - y2 = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. y1 - y2 + y2 = y2", "using carr"], ["proof (prove)\nusing this:\n  y1 - y2 = 0\\<^sub>v n\n  y1 - y2 \\<in> carrier_vec n\n  y1 \\<in> carrier_vec n\n  y2 \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n  - y1 \\<in> carrier_vec n\n  0\\<^sub>v n \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. y1 - y2 + y2 = y2", "by fastforce"], ["proof (state)\nthis:\n  y1 - y2 + y2 = y2\n\ngoal (1 subgoal):\n 1. y1 = y2", "also"], ["proof (state)\nthis:\n  y1 - y2 + y2 = y2\n\ngoal (1 subgoal):\n 1. y1 = y2", "have \"y1 - y2 + y2 = y1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y1 - y2 + y2 = y1", "using carr"], ["proof (prove)\nusing this:\n  y1 - y2 \\<in> carrier_vec n\n  y1 \\<in> carrier_vec n\n  y2 \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n  - y1 \\<in> carrier_vec n\n  0\\<^sub>v n \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. y1 - y2 + y2 = y1", "by auto"], ["proof (state)\nthis:\n  y1 - y2 + y2 = y1\n\ngoal (1 subgoal):\n 1. y1 = y2", "finally"], ["proof (chain)\npicking this:\n  y1 = y2", "show \"y1 = y2\""], ["proof (prove)\nusing this:\n  y1 = y2\n\ngoal (1 subgoal):\n 1. y1 = y2", "."], ["proof (state)\nthis:\n  y1 = y2\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"is_oc_projection w S v = (w \\<in> carrier_vec n \\<and> v - w \\<in> span S \\<and> (\\<forall> u. u \\<in> S \\<longrightarrow> w \\<bullet> u = 0))\""], ["", "lemma is_oc_projection_sq_norm: assumes \"is_oc_projection w S v\"\n  and S: \"S \\<subseteq> carrier_vec n\" \n  and v: \"v \\<in> carrier_vec n\" \nshows \"sq_norm w \\<le> sq_norm v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "from assms[unfolded is_oc_projection_def]"], ["proof (chain)\npicking this:\n  w \\<in> carrier_vec n \\<and>\n  v - w \\<in> local.span S \\<and>\n  (\\<forall>u. u \\<in> S \\<longrightarrow> w \\<bullet> u = (0::'a))\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n", "have w: \"w \\<in> carrier_vec n\" \n    and vw: \"v - w \\<in> span S\" and ortho: \"\\<And> u. u \\<in> S \\<Longrightarrow> w \\<bullet> u = 0\""], ["proof (prove)\nusing this:\n  w \\<in> carrier_vec n \\<and>\n  v - w \\<in> local.span S \\<and>\n  (\\<forall>u. u \\<in> S \\<longrightarrow> w \\<bullet> u = (0::'a))\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n &&&\n    v - w \\<in> local.span S &&&\n    (\\<And>u. u \\<in> S \\<Longrightarrow> w \\<bullet> u = (0::'a))", "by auto"], ["proof (state)\nthis:\n  w \\<in> carrier_vec n\n  v - w \\<in> local.span S\n  ?u3 \\<in> S \\<Longrightarrow> w \\<bullet> ?u3 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "have \"sq_norm v = sq_norm ((v - w) + w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>v\\<parallel>\\<^sup>2 =\n    \\<parallel>v - w + w\\<parallel>\\<^sup>2", "using v w"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<parallel>v\\<parallel>\\<^sup>2 =\n    \\<parallel>v - w + w\\<parallel>\\<^sup>2", "by (intro arg_cong[of _ _ sq_norm_vec], auto)"], ["proof (state)\nthis:\n  \\<parallel>v\\<parallel>\\<^sup>2 = \\<parallel>v - w + w\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>v\\<parallel>\\<^sup>2 = \\<parallel>v - w + w\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "have \"\\<dots> = ((v - w) + w) \\<bullet> ((v - w) + w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>v - w + w\\<parallel>\\<^sup>2 =\n    (v - w + w) \\<bullet> (v - w + w)", "unfolding sq_norm_vec_as_cscalar_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v - w + w) \\<bullet>c (v - w + w) = (v - w + w) \\<bullet> (v - w + w)", "by simp"], ["proof (state)\nthis:\n  \\<parallel>v - w + w\\<parallel>\\<^sup>2 =\n  (v - w + w) \\<bullet> (v - w + w)\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>v - w + w\\<parallel>\\<^sup>2 =\n  (v - w + w) \\<bullet> (v - w + w)\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "have \"\\<dots> = (v - w) \\<bullet> ((v - w) + w) + w \\<bullet> ((v - w) + w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v - w + w) \\<bullet> (v - w + w) =\n    (v - w) \\<bullet> (v - w + w) + w \\<bullet> (v - w + w)", "by (rule add_scalar_prod_distrib, insert v w, auto)"], ["proof (state)\nthis:\n  (v - w + w) \\<bullet> (v - w + w) =\n  (v - w) \\<bullet> (v - w + w) + w \\<bullet> (v - w + w)\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (v - w + w) \\<bullet> (v - w + w) =\n  (v - w) \\<bullet> (v - w + w) + w \\<bullet> (v - w + w)\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "have \"\\<dots> = ((v - w) \\<bullet> (v - w) + (v - w) \\<bullet> w) + (w \\<bullet> (v - w) + w \\<bullet> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v - w) \\<bullet> (v - w + w) + w \\<bullet> (v - w + w) =\n    (v - w) \\<bullet> (v - w) + (v - w) \\<bullet> w +\n    (w \\<bullet> (v - w) + w \\<bullet> w)", "by (subst (1 2) scalar_prod_add_distrib, insert v w, auto)"], ["proof (state)\nthis:\n  (v - w) \\<bullet> (v - w + w) + w \\<bullet> (v - w + w) =\n  (v - w) \\<bullet> (v - w) + (v - w) \\<bullet> w +\n  (w \\<bullet> (v - w) + w \\<bullet> w)\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (v - w) \\<bullet> (v - w + w) + w \\<bullet> (v - w + w) =\n  (v - w) \\<bullet> (v - w) + (v - w) \\<bullet> w +\n  (w \\<bullet> (v - w) + w \\<bullet> w)\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "have \"\\<dots> = sq_norm (v - w) + 2 * (w \\<bullet> (v - w)) + sq_norm w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v - w) \\<bullet> (v - w) + (v - w) \\<bullet> w +\n    (w \\<bullet> (v - w) + w \\<bullet> w) =\n    \\<parallel>v - w\\<parallel>\\<^sup>2 + (2::'a) * (w \\<bullet> (v - w)) +\n    \\<parallel>w\\<parallel>\\<^sup>2", "unfolding sq_norm_vec_as_cscalar_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v - w) \\<bullet> (v - w) + (v - w) \\<bullet> w +\n    (w \\<bullet> (v - w) + w \\<bullet> w) =\n    (v - w) \\<bullet>c (v - w) + (2::'a) * (w \\<bullet> (v - w)) +\n    w \\<bullet>c w", "using v w"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (v - w) \\<bullet> (v - w) + (v - w) \\<bullet> w +\n    (w \\<bullet> (v - w) + w \\<bullet> w) =\n    (v - w) \\<bullet>c (v - w) + (2::'a) * (w \\<bullet> (v - w)) +\n    w \\<bullet>c w", "by (auto simp: comm_scalar_prod[of w _ \"v - w\"])"], ["proof (state)\nthis:\n  (v - w) \\<bullet> (v - w) + (v - w) \\<bullet> w +\n  (w \\<bullet> (v - w) + w \\<bullet> w) =\n  \\<parallel>v - w\\<parallel>\\<^sup>2 + (2::'a) * (w \\<bullet> (v - w)) +\n  \\<parallel>w\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (v - w) \\<bullet> (v - w) + (v - w) \\<bullet> w +\n  (w \\<bullet> (v - w) + w \\<bullet> w) =\n  \\<parallel>v - w\\<parallel>\\<^sup>2 + (2::'a) * (w \\<bullet> (v - w)) +\n  \\<parallel>w\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "have \"\\<dots> \\<ge> 2 * (w \\<bullet> (v - w)) + sq_norm w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2::'a) * (w \\<bullet> (v - w)) + \\<parallel>w\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>v - w\\<parallel>\\<^sup>2 +\n          (2::'a) * (w \\<bullet> (v - w)) +\n          \\<parallel>w\\<parallel>\\<^sup>2", "using sq_norm_vec_ge_0[of \"v - w\"]"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> \\<parallel>v - w\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (2::'a) * (w \\<bullet> (v - w)) + \\<parallel>w\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>v - w\\<parallel>\\<^sup>2 +\n          (2::'a) * (w \\<bullet> (v - w)) +\n          \\<parallel>w\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  (2::'a) * (w \\<bullet> (v - w)) + \\<parallel>w\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>v - w\\<parallel>\\<^sup>2 +\n        (2::'a) * (w \\<bullet> (v - w)) +\n        \\<parallel>w\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (2::'a) * (w \\<bullet> (v - w)) + \\<parallel>w\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>v - w\\<parallel>\\<^sup>2 +\n        (2::'a) * (w \\<bullet> (v - w)) +\n        \\<parallel>w\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "have \"w \\<bullet> (v - w) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<bullet> (v - w) = (0::'a)", "using orthocompl_span[OF ortho S w vw]"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> S) \\<Longrightarrow>\n  w \\<bullet> (v - w) = (0::'a)\n\ngoal (1 subgoal):\n 1. w \\<bullet> (v - w) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  w \\<bullet> (v - w) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  (2::'a) * (0::'a) + \\<parallel>w\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  (2::'a) * (0::'a) + \\<parallel>w\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>v\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<parallel>w\\<parallel>\\<^sup>2 \\<le> \\<parallel>v\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "definition oc_projection where\n\"oc_projection S fi \\<equiv> (SOME v. is_oc_projection v S fi)\""], ["", "lemma inv_in_span:\n  assumes incarr[intro]:\"U \\<subseteq> carrier_vec n\" and insp:\"a \\<in> span U\"\n  shows \"- a \\<in> span U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a \\<in> local.span U", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - a \\<in> local.span U", "from insp[THEN in_spanE]"], ["proof (chain)\npicking this:\n  \\<exists>aa A. a = lincomb aa A \\<and> finite A \\<and> A \\<subseteq> U", "obtain aa A where a:\"a = lincomb aa A\" \"finite A\" \"A \\<subseteq> U\""], ["proof (prove)\nusing this:\n  \\<exists>aa A. a = lincomb aa A \\<and> finite A \\<and> A \\<subseteq> U\n\ngoal (1 subgoal):\n 1. (\\<And>aa A.\n        \\<lbrakk>a = lincomb aa A; finite A; A \\<subseteq> U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = lincomb aa A\n  finite A\n  A \\<subseteq> U\n\ngoal (1 subgoal):\n 1. - a \\<in> local.span U", "with assms"], ["proof (chain)\npicking this:\n  U \\<subseteq> carrier_vec n\n  a \\<in> local.span U\n  a = lincomb aa A\n  finite A\n  A \\<subseteq> U", "have [intro!]:\"(\\<lambda>v. aa v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n\""], ["proof (prove)\nusing this:\n  U \\<subseteq> carrier_vec n\n  a \\<in> local.span U\n  a = lincomb aa A\n  finite A\n  A \\<subseteq> U\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. aa v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. aa v \\<cdot>\\<^sub>v v) \\<in> A \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. - a \\<in> local.span U", "from a(1)"], ["proof (chain)\npicking this:\n  a = lincomb aa A", "have e1:\"- a = lincomb (\\<lambda> x. - 1 * aa x) A\""], ["proof (prove)\nusing this:\n  a = lincomb aa A\n\ngoal (1 subgoal):\n 1. - a = lincomb (\\<lambda>x. - (1::'a) * aa x) A", "unfolding smult_smult_assoc[symmetric] lincomb_def"], ["proof (prove)\nusing this:\n  a = (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. aa v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. - a =\n    (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>A. - (1::'a) \\<cdot>\\<^sub>v\n (aa v \\<cdot>\\<^sub>v v))", "by(subst finsum_smult[symmetric]) force+"], ["proof (state)\nthis:\n  - a = lincomb (\\<lambda>x. - (1::'a) * aa x) A\n\ngoal (1 subgoal):\n 1. - a \\<in> local.span U", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. - a \\<in> local.span U", "using e1 a span_def"], ["proof (prove)\nusing this:\n  - a = lincomb (\\<lambda>x. - (1::'a) * aa x) A\n  a = lincomb aa A\n  finite A\n  A \\<subseteq> U\n  local.span ?S = {lincomb a A |a A. finite A \\<and> A \\<subseteq> ?S}\n\ngoal (1 subgoal):\n 1. - a \\<in> local.span U", "by blast"], ["proof (state)\nthis:\n  - a \\<in> local.span U\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_span_det_zero:\n  assumes len: \"length G = n\"\n  and nonb:\"\\<not> (carrier_vec n \\<subseteq> span (set G))\"\n  and carr:\"set G \\<subseteq> carrier_vec n\"\n  shows \"det (mat_of_rows n G) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "unfolding det_0_iff_vec_prod_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "let ?A = \"(mat_of_rows n G)\\<^sup>T\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "let ?B = \"1\\<^sub>m n\""], ["proof (state)\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "from carr"], ["proof (chain)\npicking this:\n  set G \\<subseteq> carrier_vec n", "have carr_mat:\"?A \\<in> carrier_mat n n\" \"?B \\<in> carrier_mat n n\" \"mat_of_rows n G \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  set G \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. (mat_of_rows n G)\\<^sup>T \\<in> carrier_mat n n &&&\n    1\\<^sub>m n \\<in> carrier_mat n n &&&\n    mat_of_rows n G \\<in> carrier_mat n n", "using len mat_of_rows_carrier(1)"], ["proof (prove)\nusing this:\n  set G \\<subseteq> carrier_vec n\n  length G = n\n  mat_of_rows ?n ?vs \\<in> carrier_mat (length ?vs) ?n\n\ngoal (1 subgoal):\n 1. (mat_of_rows n G)\\<^sup>T \\<in> carrier_mat n n &&&\n    1\\<^sub>m n \\<in> carrier_mat n n &&&\n    mat_of_rows n G \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  (mat_of_rows n G)\\<^sup>T \\<in> carrier_mat n n\n  1\\<^sub>m n \\<in> carrier_mat n n\n  mat_of_rows n G \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "from carr"], ["proof (chain)\npicking this:\n  set G \\<subseteq> carrier_vec n", "have g_len:\"\\<And> i. i < length G \\<Longrightarrow> G ! i \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set G \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length G \\<Longrightarrow> G ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?i5 < length G \\<Longrightarrow> G ! ?i5 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "from nonb"], ["proof (chain)\npicking this:\n  \\<not> carrier_vec n \\<subseteq> local.span (set G)", "obtain v where v:\"v \\<in> carrier_vec n\" \"v \\<notin> span (set G)\""], ["proof (prove)\nusing this:\n  \\<not> carrier_vec n \\<subseteq> local.span (set G)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> carrier_vec n;\n         v \\<notin> local.span (set G)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  v \\<notin> local.span (set G)\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "hence \"v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<notin> local.span (set G)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n", "using span_zero"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<notin> local.span (set G)\n  0\\<^sub>v n \\<in> local.span ?U\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "obtain B C where gj:\"gauss_jordan ?A ?B = (B,C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B C.\n        gauss_jordan (mat_of_rows n G)\\<^sup>T (1\\<^sub>m n) =\n        (B, C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  gauss_jordan (mat_of_rows n G)\\<^sup>T (1\\<^sub>m n) = (B, C)\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "note gj = carr_mat(1,2) gj"], ["proof (state)\nthis:\n  (mat_of_rows n G)\\<^sup>T \\<in> carrier_mat n n\n  1\\<^sub>m n \\<in> carrier_mat n n\n  gauss_jordan (mat_of_rows n G)\\<^sup>T (1\\<^sub>m n) = (B, C)\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "hence B:\"B = fst (gauss_jordan ?A ?B)\""], ["proof (prove)\nusing this:\n  (mat_of_rows n G)\\<^sup>T \\<in> carrier_mat n n\n  1\\<^sub>m n \\<in> carrier_mat n n\n  gauss_jordan (mat_of_rows n G)\\<^sup>T (1\\<^sub>m n) = (B, C)\n\ngoal (1 subgoal):\n 1. B = fst (gauss_jordan (mat_of_rows n G)\\<^sup>T (1\\<^sub>m n))", "by auto"], ["proof (state)\nthis:\n  B = fst (gauss_jordan (mat_of_rows n G)\\<^sup>T (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "from gauss_jordan[OF gj]"], ["proof (chain)\npicking this:\n  ?x \\<in> carrier_vec n \\<Longrightarrow>\n  ((mat_of_rows n G)\\<^sup>T *\\<^sub>v ?x = 0\\<^sub>v n) =\n  (B *\\<^sub>v ?x = 0\\<^sub>v n)\n  ?X \\<in> carrier_mat n n \\<Longrightarrow>\n  ((mat_of_rows n G)\\<^sup>T * ?X = 1\\<^sub>m n) = (B * ?X = C)\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n", "have BC:\"B \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  ?x \\<in> carrier_vec n \\<Longrightarrow>\n  ((mat_of_rows n G)\\<^sup>T *\\<^sub>v ?x = 0\\<^sub>v n) =\n  (B *\\<^sub>v ?x = 0\\<^sub>v n)\n  ?X \\<in> carrier_mat n n \\<Longrightarrow>\n  ((mat_of_rows n G)\\<^sup>T * ?X = 1\\<^sub>m n) = (B * ?X = C)\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "from gauss_jordan_transform[OF gj]"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) n ?b).\n     B = P * (mat_of_rows n G)\\<^sup>T \\<and> C = P * 1\\<^sub>m n", "obtain P where\n   P:\"P\\<in>Units (ring_mat TYPE('a) n ?B)\"  \"B = P * ?A\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) n ?b).\n     B = P * (mat_of_rows n G)\\<^sup>T \\<and> C = P * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) n (1\\<^sub>m n));\n         B = P * (mat_of_rows n G)\\<^sup>T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) n (1\\<^sub>m n))\n  B = P * (mat_of_rows n G)\\<^sup>T\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "hence PC:\"P \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  P \\<in> Units (ring_mat TYPE('a) n (1\\<^sub>m n))\n  B = P * (mat_of_rows n G)\\<^sup>T\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n", "unfolding Units_def"], ["proof (prove)\nusing this:\n  P \\<in> {y \\<in> carrier (ring_mat TYPE('a) n (1\\<^sub>m n)).\n           \\<exists>x\\<in>carrier (ring_mat TYPE('a) n (1\\<^sub>m n)).\n              x \\<otimes>\\<^bsub>ring_mat TYPE('a) n (1\\<^sub>m n)\\<^esub>\n              y =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n (1\\<^sub>m n)\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>ring_mat TYPE('a) n (1\\<^sub>m n)\\<^esub>\n              x =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n (1\\<^sub>m n)\\<^esub>}\n  B = P * (mat_of_rows n G)\\<^sup>T\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n", "by (simp add: ring_mat_simps)"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "from mat_inverse[OF PC] P"], ["proof (chain)\npicking this:\n  mat_inverse P = None \\<Longrightarrow>\n  P \\<notin> Units (ring_mat TYPE('a) n ?b)\n  mat_inverse P = Some ?B \\<Longrightarrow>\n  P * ?B = 1\\<^sub>m n \\<and>\n  ?B * P = 1\\<^sub>m n \\<and> ?B \\<in> carrier_mat n n\n  P \\<in> Units (ring_mat TYPE('a) n (1\\<^sub>m n))\n  B = P * (mat_of_rows n G)\\<^sup>T", "obtain PI where \"mat_inverse P = Some PI\""], ["proof (prove)\nusing this:\n  mat_inverse P = None \\<Longrightarrow>\n  P \\<notin> Units (ring_mat TYPE('a) n ?b)\n  mat_inverse P = Some ?B \\<Longrightarrow>\n  P * ?B = 1\\<^sub>m n \\<and>\n  ?B * P = 1\\<^sub>m n \\<and> ?B \\<in> carrier_mat n n\n  P \\<in> Units (ring_mat TYPE('a) n (1\\<^sub>m n))\n  B = P * (mat_of_rows n G)\\<^sup>T\n\ngoal (1 subgoal):\n 1. (\\<And>PI.\n        mat_inverse P = Some PI \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  mat_inverse P = Some PI\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "from mat_inverse(2)[OF PC this]"], ["proof (chain)\npicking this:\n  P * PI = 1\\<^sub>m n \\<and>\n  PI * P = 1\\<^sub>m n \\<and> PI \\<in> carrier_mat n n", "have PI:\"P * PI = 1\\<^sub>m n\" \"PI * P = 1\\<^sub>m n\" \"PI \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  P * PI = 1\\<^sub>m n \\<and>\n  PI * P = 1\\<^sub>m n \\<and> PI \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * PI = 1\\<^sub>m n &&&\n    PI * P = 1\\<^sub>m n &&& PI \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  P * PI = 1\\<^sub>m n\n  PI * P = 1\\<^sub>m n\n  PI \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "have \"B \\<noteq> 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<noteq> 1\\<^sub>m n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow> False", "assume \"B = ?B\""], ["proof (state)\nthis:\n  B = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow> False", "hence \"?A * P = ?B\""], ["proof (prove)\nusing this:\n  B = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. (mat_of_rows n G)\\<^sup>T * P = 1\\<^sub>m n", "unfolding P"], ["proof (prove)\nusing this:\n  P * (mat_of_rows n G)\\<^sup>T = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. (mat_of_rows n G)\\<^sup>T * P = 1\\<^sub>m n", "using PC P(2) carr_mat(1) mat_mult_left_right_inverse"], ["proof (prove)\nusing this:\n  P * (mat_of_rows n G)\\<^sup>T = 1\\<^sub>m n\n  P \\<in> carrier_mat n n\n  B = P * (mat_of_rows n G)\\<^sup>T\n  (mat_of_rows n G)\\<^sup>T \\<in> carrier_mat n n\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   ?A * ?B = 1\\<^sub>m ?n\\<rbrakk>\n  \\<Longrightarrow> ?B * ?A = 1\\<^sub>m ?n\n\ngoal (1 subgoal):\n 1. (mat_of_rows n G)\\<^sup>T * P = 1\\<^sub>m n", "by blast"], ["proof (state)\nthis:\n  (mat_of_rows n G)\\<^sup>T * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow> False", "hence \"?A * P *\\<^sub>v v = v\""], ["proof (prove)\nusing this:\n  (mat_of_rows n G)\\<^sup>T * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. (mat_of_rows n G)\\<^sup>T * P *\\<^sub>v v = v", "using v"], ["proof (prove)\nusing this:\n  (mat_of_rows n G)\\<^sup>T * P = 1\\<^sub>m n\n  v \\<in> carrier_vec n\n  v \\<notin> local.span (set G)\n\ngoal (1 subgoal):\n 1. (mat_of_rows n G)\\<^sup>T * P *\\<^sub>v v = v", "by auto"], ["proof (state)\nthis:\n  (mat_of_rows n G)\\<^sup>T * P *\\<^sub>v v = v\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow> False", "hence \"?A *\\<^sub>v (P *\\<^sub>v v) = v\""], ["proof (prove)\nusing this:\n  (mat_of_rows n G)\\<^sup>T * P *\\<^sub>v v = v\n\ngoal (1 subgoal):\n 1. (mat_of_rows n G)\\<^sup>T *\\<^sub>v (P *\\<^sub>v v) = v", "unfolding assoc_mult_mat_vec[OF carr_mat(1) PC v(1)]"], ["proof (prove)\nusing this:\n  (mat_of_rows n G)\\<^sup>T *\\<^sub>v (P *\\<^sub>v v) = v\n\ngoal (1 subgoal):\n 1. (mat_of_rows n G)\\<^sup>T *\\<^sub>v (P *\\<^sub>v v) = v", "."], ["proof (state)\nthis:\n  (mat_of_rows n G)\\<^sup>T *\\<^sub>v (P *\\<^sub>v v) = v\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow> False", "hence v_eq:\"mat_of_cols n G *\\<^sub>v (P *\\<^sub>v v) = v\""], ["proof (prove)\nusing this:\n  (mat_of_rows n G)\\<^sup>T *\\<^sub>v (P *\\<^sub>v v) = v\n\ngoal (1 subgoal):\n 1. mat_of_cols n G *\\<^sub>v (P *\\<^sub>v v) = v", "unfolding transpose_mat_of_rows"], ["proof (prove)\nusing this:\n  mat_of_cols n G *\\<^sub>v (P *\\<^sub>v v) = v\n\ngoal (1 subgoal):\n 1. mat_of_cols n G *\\<^sub>v (P *\\<^sub>v v) = v", "by auto"], ["proof (state)\nthis:\n  mat_of_cols n G *\\<^sub>v (P *\\<^sub>v v) = v\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow> False", "have pvc:\"P *\\<^sub>v v \\<in> carrier_vec (length G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P *\\<^sub>v v \\<in> carrier_vec (length G)", "using PC v len"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  v \\<notin> local.span (set G)\n  length G = n\n\ngoal (1 subgoal):\n 1. P *\\<^sub>v v \\<in> carrier_vec (length G)", "by auto"], ["proof (state)\nthis:\n  P *\\<^sub>v v \\<in> carrier_vec (length G)\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow> False", "from mat_of_cols_mult_as_finsum[OF pvc g_len,unfolded v_eq]"], ["proof (chain)\npicking this:\n  (\\<And>i. i < length G \\<Longrightarrow> i < length G) \\<Longrightarrow>\n  v =\n  lincomb\n   (\\<lambda>l.\n       \\<Sum>i = 0..<length G.\n          if l = G ! i then (P *\\<^sub>v v) $ i else (0::'a))\n   (set G)", "obtain a where\n      \"v = lincomb a (set G)\""], ["proof (prove)\nusing this:\n  (\\<And>i. i < length G \\<Longrightarrow> i < length G) \\<Longrightarrow>\n  v =\n  lincomb\n   (\\<lambda>l.\n       \\<Sum>i = 0..<length G.\n          if l = G ! i then (P *\\<^sub>v v) $ i else (0::'a))\n   (set G)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        v = lincomb a (set G) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v = lincomb a (set G)\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow> False", "hence \"v \\<in> span (set G)\""], ["proof (prove)\nusing this:\n  v = lincomb a (set G)\n\ngoal (1 subgoal):\n 1. v \\<in> local.span (set G)", "by (intro in_spanI[OF _ finite_set subset_refl])"], ["proof (state)\nthis:\n  v \\<in> local.span (set G)\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v \\<in> local.span (set G)\n\ngoal (1 subgoal):\n 1. False", "using v"], ["proof (prove)\nusing this:\n  v \\<in> local.span (set G)\n  v \\<in> carrier_vec n\n  v \\<notin> local.span (set G)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B \\<noteq> 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "with det_non_zero_imp_unit[OF carr_mat(1)]"], ["proof (chain)\npicking this:\n  det (mat_of_rows n G)\\<^sup>T \\<noteq> (0::'a) \\<Longrightarrow>\n  (mat_of_rows n G)\\<^sup>T \\<in> Units (ring_mat TYPE('a) n ?b)\n  B \\<noteq> 1\\<^sub>m n", "show ?thesis"], ["proof (prove)\nusing this:\n  det (mat_of_rows n G)\\<^sup>T \\<noteq> (0::'a) \\<Longrightarrow>\n  (mat_of_rows n G)\\<^sup>T \\<in> Units (ring_mat TYPE('a) n ?b)\n  B \\<noteq> 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "unfolding gauss_jordan_check_invertable[OF carr_mat(1,2)] B det_transpose[OF carr_mat(3)]"], ["proof (prove)\nusing this:\n  det (mat_of_rows n G) \\<noteq> (0::'a) \\<Longrightarrow>\n  fst (gauss_jordan (mat_of_rows n G)\\<^sup>T (1\\<^sub>m n)) = 1\\<^sub>m n\n  fst (gauss_jordan (mat_of_rows n G)\\<^sup>T (1\\<^sub>m n)) \\<noteq>\n  1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) = (0::'a)", "by metis"], ["proof (state)\nthis:\n  det (mat_of_rows n G) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma span_basis_det_zero_iff:\nassumes \"length G = n\" \"set G \\<subseteq> carrier_vec n\"\nshows \"carrier_vec n \\<subseteq> span (set G) \\<longleftrightarrow> det (mat_of_rows n G) \\<noteq> 0\" (is ?q1)\n      \"carrier_vec n \\<subseteq> span (set G) \\<longleftrightarrow> basis (set G)\" (is ?q2)\n      \"det (mat_of_rows n G) \\<noteq> 0 \\<longleftrightarrow> basis (set G)\" (is ?q3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (carrier_vec n \\<subseteq> local.span (set G)) =\n    (det (mat_of_rows n G) \\<noteq> (0::'a)) &&&\n    (carrier_vec n \\<subseteq> local.span (set G)) = basis (set G) &&&\n    (det (mat_of_rows n G) \\<noteq> (0::'a)) = basis (set G)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. (carrier_vec n \\<subseteq> local.span (set G)) =\n    (det (mat_of_rows n G) \\<noteq> (0::'a))\n 2. (carrier_vec n \\<subseteq> local.span (set G)) = basis (set G)\n 3. (det (mat_of_rows n G) \\<noteq> (0::'a)) = basis (set G)", "have dc:\"det (mat_of_rows n G) \\<noteq> 0 \\<Longrightarrow> carrier_vec n \\<subseteq> span (set G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) \\<noteq> (0::'a) \\<Longrightarrow>\n    carrier_vec n \\<subseteq> local.span (set G)", "using assms non_span_det_zero"], ["proof (prove)\nusing this:\n  length G = n\n  set G \\<subseteq> carrier_vec n\n  \\<lbrakk>length ?G = n;\n   \\<not> carrier_vec n \\<subseteq> local.span (set ?G);\n   set ?G \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> det (mat_of_rows n ?G) = (0::'a)\n\ngoal (1 subgoal):\n 1. det (mat_of_rows n G) \\<noteq> (0::'a) \\<Longrightarrow>\n    carrier_vec n \\<subseteq> local.span (set G)", "by auto"], ["proof (state)\nthis:\n  det (mat_of_rows n G) \\<noteq> (0::'a) \\<Longrightarrow>\n  carrier_vec n \\<subseteq> local.span (set G)\n\ngoal (3 subgoals):\n 1. (carrier_vec n \\<subseteq> local.span (set G)) =\n    (det (mat_of_rows n G) \\<noteq> (0::'a))\n 2. (carrier_vec n \\<subseteq> local.span (set G)) = basis (set G)\n 3. (det (mat_of_rows n G) \\<noteq> (0::'a)) = basis (set G)", "have cb:\"carrier_vec n \\<subseteq> span (set G) \\<Longrightarrow> basis (set G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier_vec n \\<subseteq> local.span (set G) \\<Longrightarrow>\n    basis (set G)", "using assms basis_list_basis"], ["proof (prove)\nusing this:\n  length G = n\n  set G \\<subseteq> carrier_vec n\n  basis_list ?fs \\<Longrightarrow> distinct ?fs\n  basis_list ?fs \\<Longrightarrow> lin_indpt (set ?fs)\n  basis_list ?fs \\<Longrightarrow> basis (set ?fs)\n\ngoal (1 subgoal):\n 1. carrier_vec n \\<subseteq> local.span (set G) \\<Longrightarrow>\n    basis (set G)", "by (auto simp: basis_list_def)"], ["proof (state)\nthis:\n  carrier_vec n \\<subseteq> local.span (set G) \\<Longrightarrow>\n  basis (set G)\n\ngoal (3 subgoals):\n 1. (carrier_vec n \\<subseteq> local.span (set G)) =\n    (det (mat_of_rows n G) \\<noteq> (0::'a))\n 2. (carrier_vec n \\<subseteq> local.span (set G)) = basis (set G)\n 3. (det (mat_of_rows n G) \\<noteq> (0::'a)) = basis (set G)", "have bd:\"basis (set G) \\<Longrightarrow> det (mat_of_rows n G) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis (set G) \\<Longrightarrow> det (mat_of_rows n G) \\<noteq> (0::'a)", "using assms basis_det_nonzero"], ["proof (prove)\nusing this:\n  length G = n\n  set G \\<subseteq> carrier_vec n\n  \\<lbrakk>basis (set ?G); length ?G = n\\<rbrakk>\n  \\<Longrightarrow> det (mat_of_rows n ?G) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. basis (set G) \\<Longrightarrow> det (mat_of_rows n G) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  basis (set G) \\<Longrightarrow> det (mat_of_rows n G) \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. (carrier_vec n \\<subseteq> local.span (set G)) =\n    (det (mat_of_rows n G) \\<noteq> (0::'a))\n 2. (carrier_vec n \\<subseteq> local.span (set G)) = basis (set G)\n 3. (det (mat_of_rows n G) \\<noteq> (0::'a)) = basis (set G)", "show ?q1 ?q2 ?q3"], ["proof (prove)\ngoal (1 subgoal):\n 1. (carrier_vec n \\<subseteq> local.span (set G)) =\n    (det (mat_of_rows n G) \\<noteq> (0::'a)) &&&\n    (carrier_vec n \\<subseteq> local.span (set G)) = basis (set G) &&&\n    (det (mat_of_rows n G) \\<noteq> (0::'a)) = basis (set G)", "using dc cb bd"], ["proof (prove)\nusing this:\n  det (mat_of_rows n G) \\<noteq> (0::'a) \\<Longrightarrow>\n  carrier_vec n \\<subseteq> local.span (set G)\n  carrier_vec n \\<subseteq> local.span (set G) \\<Longrightarrow>\n  basis (set G)\n  basis (set G) \\<Longrightarrow> det (mat_of_rows n G) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (carrier_vec n \\<subseteq> local.span (set G)) =\n    (det (mat_of_rows n G) \\<noteq> (0::'a)) &&&\n    (carrier_vec n \\<subseteq> local.span (set G)) = basis (set G) &&&\n    (det (mat_of_rows n G) \\<noteq> (0::'a)) = basis (set G)", "by metis+"], ["proof (state)\nthis:\n  (carrier_vec n \\<subseteq> local.span (set G)) =\n  (det (mat_of_rows n G) \\<noteq> (0::'a))\n  (carrier_vec n \\<subseteq> local.span (set G)) = basis (set G)\n  (det (mat_of_rows n G) \\<noteq> (0::'a)) = basis (set G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lin_indpt_list_nonzero:\n  assumes \"lin_indpt_list G\" \n  shows \"0\\<^sub>v n \\<notin> set G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<notin> set G", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<notin> set G", "from assms[unfolded lin_indpt_list_def]"], ["proof (chain)\npicking this:\n  set G \\<subseteq> carrier_vec n \\<and> distinct G \\<and> lin_indpt (set G)", "have \"lin_indpt (set G)\""], ["proof (prove)\nusing this:\n  set G \\<subseteq> carrier_vec n \\<and> distinct G \\<and> lin_indpt (set G)\n\ngoal (1 subgoal):\n 1. lin_indpt (set G)", "by auto"], ["proof (state)\nthis:\n  lin_indpt (set G)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<notin> set G", "from vs_zero_lin_dep[OF _ this] assms[unfolded lin_indpt_list_def]"], ["proof (chain)\npicking this:\n  set G \\<subseteq> carrier_vec n \\<Longrightarrow>\n  0\\<^sub>v n \\<notin> set G\n  set G \\<subseteq> carrier_vec n \\<and> distinct G \\<and> lin_indpt (set G)", "show zero: \"0\\<^sub>v n \\<notin> set G\""], ["proof (prove)\nusing this:\n  set G \\<subseteq> carrier_vec n \\<Longrightarrow>\n  0\\<^sub>v n \\<notin> set G\n  set G \\<subseteq> carrier_vec n \\<and> distinct G \\<and> lin_indpt (set G)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<notin> set G", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v n \\<notin> set G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_oc_projection_eq:\n  assumes ispr:\"is_oc_projection a S v\" \"is_oc_projection b S v\" \n    and carr: \"S \\<subseteq> carrier_vec n\" \"v \\<in> carrier_vec n\"\n  shows \"a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = b", "from carr"], ["proof (chain)\npicking this:\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n", "have c2:\"span S \\<subseteq> carrier_vec n\" \"v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. local.span S \\<subseteq> carrier_vec n &&& v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  local.span S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. a = b", "have a:\"v - (v - a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - (v - a) = a", "using carr ispr"], ["proof (prove)\nusing this:\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n\n  is_oc_projection a S v\n  is_oc_projection b S v\n\ngoal (1 subgoal):\n 1. v - (v - a) = a", "by auto"], ["proof (state)\nthis:\n  v - (v - a) = a\n\ngoal (1 subgoal):\n 1. a = b", "have b:\"v - (v - b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - (v - b) = b", "using carr ispr"], ["proof (prove)\nusing this:\n  S \\<subseteq> carrier_vec n\n  v \\<in> carrier_vec n\n  is_oc_projection a S v\n  is_oc_projection b S v\n\ngoal (1 subgoal):\n 1. v - (v - b) = b", "by auto"], ["proof (state)\nthis:\n  v - (v - b) = b\n\ngoal (1 subgoal):\n 1. a = b", "have \"(v - a) = (v - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - a = v - b", "apply(rule oc_projection_alt_def[OF c2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. v - a \\<in> local.span S\n 2. v - (v - a) \\<in> orthogonal_complement (local.span S)\n 3. v - b \\<in> local.span S\n 4. v - (v - b) \\<in> orthogonal_complement (local.span S)", "using ispr a b"], ["proof (prove)\nusing this:\n  is_oc_projection a S v\n  is_oc_projection b S v\n  v - (v - a) = a\n  v - (v - b) = b\n\ngoal (4 subgoals):\n 1. v - a \\<in> local.span S\n 2. v - (v - a) \\<in> orthogonal_complement (local.span S)\n 3. v - b \\<in> local.span S\n 4. v - (v - b) \\<in> orthogonal_complement (local.span S)", "unfolding in_orthogonal_complement_span[OF carr(1)]"], ["proof (prove)\nusing this:\n  is_oc_projection a S v\n  is_oc_projection b S v\n  v - (v - a) = a\n  v - (v - b) = b\n\ngoal (4 subgoals):\n 1. v - a \\<in> local.span S\n 2. v - (v - a) \\<in> orthogonal_complement S\n 3. v - b \\<in> local.span S\n 4. v - (v - b) \\<in> orthogonal_complement S", "unfolding orthogonal_complement_def is_oc_projection_def"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec n \\<and>\n  v - a \\<in> local.span S \\<and>\n  (\\<forall>u. u \\<in> S \\<longrightarrow> a \\<bullet> u = (0::'a))\n  b \\<in> carrier_vec n \\<and>\n  v - b \\<in> local.span S \\<and>\n  (\\<forall>u. u \\<in> S \\<longrightarrow> b \\<bullet> u = (0::'a))\n  v - (v - a) = a\n  v - (v - b) = b\n\ngoal (4 subgoals):\n 1. v - a \\<in> local.span S\n 2. v - (v - a)\n    \\<in> {x \\<in> carrier_vec n. \\<forall>y\\<in>S. x \\<bullet> y = (0::'a)}\n 3. v - b \\<in> local.span S\n 4. v - (v - b)\n    \\<in> {x \\<in> carrier_vec n. \\<forall>y\\<in>S. x \\<bullet> y = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  v - a = v - b\n\ngoal (1 subgoal):\n 1. a = b", "hence \"v - (v - a) = v - (v - b)\""], ["proof (prove)\nusing this:\n  v - a = v - b\n\ngoal (1 subgoal):\n 1. v - (v - a) = v - (v - b)", "by metis"], ["proof (state)\nthis:\n  v - (v - a) = v - (v - b)\n\ngoal (1 subgoal):\n 1. a = b", "thus ?thesis"], ["proof (prove)\nusing this:\n  v - (v - a) = v - (v - b)\n\ngoal (1 subgoal):\n 1. a = b", "unfolding a b"], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. a = b", "."], ["proof (state)\nthis:\n  a = b\n\ngoal:\nNo subgoals!", "qed"], ["", "fun adjuster_wit :: \"'a list \\<Rightarrow> 'a vec \\<Rightarrow> 'a vec list \\<Rightarrow> 'a list \\<times> 'a vec\"\n  where \"adjuster_wit wits w [] = (wits, 0\\<^sub>v n)\"\n  |  \"adjuster_wit wits w (u#us) = (let a = (w \\<bullet> u)/ sq_norm u in \n            case adjuster_wit (a # wits) w us of (wit, v)\n         \\<Rightarrow> (wit, -a \\<cdot>\\<^sub>v u + v))\""], ["", "fun sub2_wit where\n    \"sub2_wit us [] = ([], [])\"\n  | \"sub2_wit us (w # ws) =\n     (case adjuster_wit [] w us of (wit,aw) \\<Rightarrow> let u = aw + w in\n      case sub2_wit (u # us) ws of (wits, vvs) \\<Rightarrow> (wit # wits, u # vvs))\""], ["", "definition main :: \"'a vec list \\<Rightarrow> 'a list list \\<times> 'a vec list\" where \n  \"main us = sub2_wit [] us\""], ["", "end"], ["", "locale gram_schmidt_fs = \n  fixes n :: nat and fs :: \"'a :: {trivial_conjugatable_linordered_field} vec list\"\nbegin"], ["", "sublocale gram_schmidt n \"TYPE('a)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "fun gso and \\<mu> where\n  \"gso i = fs ! i + sumlist (map (\\<lambda> j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0 ..< i])\" \n| \"\\<mu> i j = (if j < i then (fs ! i \\<bullet> gso j)/ sq_norm (gso j) else if i = j then 1 else 0)\""], ["", "declare gso.simps[simp del]"], ["", "declare \\<mu>.simps[simp del]"], ["", "lemma gso_carrier'[intro]:\n  assumes \"\\<And> i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n\"\n  shows \"gso j \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso j \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  ?i1 \\<le> j \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. gso j \\<in> carrier_vec n", "proof(induct j rule:nat_less_induct[rule_format])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < na;\n                    \\<And>i.\n                       i \\<le> m \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gso m \\<in> carrier_vec n;\n        \\<And>i.\n           i \\<le> na \\<Longrightarrow> fs ! i \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gso na \\<in> carrier_vec n", "case (1 j)"], ["proof (state)\nthis:\n  \\<lbrakk>?m1 < j;\n   \\<And>i.\n      i \\<le> ?m1 \\<Longrightarrow> fs ! i \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> gso ?m1 \\<in> carrier_vec n\n  ?i1 \\<le> j \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < na;\n                    \\<And>i.\n                       i \\<le> m \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gso m \\<in> carrier_vec n;\n        \\<And>i.\n           i \\<le> na \\<Longrightarrow> fs ! i \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gso na \\<in> carrier_vec n", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?m1 < j;\n   \\<And>i.\n      i \\<le> ?m1 \\<Longrightarrow> fs ! i \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> gso ?m1 \\<in> carrier_vec n\n  ?i1 \\<le> j \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m1 < j;\n   \\<And>i.\n      i \\<le> ?m1 \\<Longrightarrow> fs ! i \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> gso ?m1 \\<in> carrier_vec n\n  ?i1 \\<le> j \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. gso j \\<in> carrier_vec n", "unfolding gso.simps[of j]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m1 < j;\n   \\<And>i.\n      i \\<le> ?m1 \\<Longrightarrow> fs ! i \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> gso ?m1 \\<in> carrier_vec n\n  ?i1 \\<le> j \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. fs ! j +\n    sumlist (map (\\<lambda>j. - \\<mu> j j \\<cdot>\\<^sub>v gso j) [0..<j])\n    \\<in> carrier_vec n", "by (auto intro!:sumlist_carrier add_carrier_vec)"], ["proof (state)\nthis:\n  gso j \\<in> carrier_vec n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjuster_wit: assumes res: \"adjuster_wit wits w us = (wits',a)\"\n  and w: \"w \\<in> carrier_vec n\"\n    and us: \"\\<And> i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n\"\n    and us_gs: \"us = map gso (rev [0 ..< j])\" \n    and wits: \"wits = map (\\<mu> i) [j ..< i]\" \n    and j: \"j \\<le> n\" \"j \\<le> i\" \n    and wi: \"w = fs ! i\" \n  shows \"adjuster n w us = a \\<and> a \\<in> carrier_vec n \\<and> wits' = map (\\<mu> i) [0 ..< i] \\<and>\n      (a = sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjuster n w us = a \\<and>\n    a \\<in> carrier_vec n \\<and>\n    wits' = map (\\<mu> i) [0..<i] \\<and>\n    a =\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j])", "using res us us_gs wits j"], ["proof (prove)\nusing this:\n  adjuster_wit wits w us = (wits', a)\n  ?i1 \\<le> j \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n  us = map gso (rev [0..<j])\n  wits = map (\\<mu> i) [j..<i]\n  j \\<le> n\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. adjuster n w us = a \\<and>\n    a \\<in> carrier_vec n \\<and>\n    wits' = map (\\<mu> i) [0..<i] \\<and>\n    a =\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j])", "proof (induct us arbitrary: wits wits' a j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "case (Cons u us wits wits' a j)"], ["proof (state)\nthis:\n  \\<lbrakk>adjuster_wit ?wits1 w us = (?wits'1, ?a1);\n   \\<And>i. i \\<le> ?j1 \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n   us = map gso (rev [0..<?j1]); ?wits1 = map (\\<mu> i) [?j1..<i];\n   ?j1 \\<le> n; ?j1 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> adjuster n w us = ?a1 \\<and>\n                    ?a1 \\<in> carrier_vec n \\<and>\n                    ?wits'1 = map (\\<mu> i) [0..<i] \\<and>\n                    ?a1 =\n                    sumlist\n                     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<?j1])\n  adjuster_wit wits w (u # us) = (wits', a)\n  ?i1 \\<le> j \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n  u # us = map gso (rev [0..<j])\n  wits = map (\\<mu> i) [j..<i]\n  j \\<le> n\n  j \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "note us_gs = Cons(4)"], ["proof (state)\nthis:\n  u # us = map gso (rev [0..<j])\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "note wits = Cons(5)"], ["proof (state)\nthis:\n  wits = map (\\<mu> i) [j..<i]\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "note jn = Cons(6-7)"], ["proof (state)\nthis:\n  j \\<le> n\n  j \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "from us_gs"], ["proof (chain)\npicking this:\n  u # us = map gso (rev [0..<j])", "obtain jj where j: \"j = Suc jj\""], ["proof (prove)\nusing this:\n  u # us = map gso (rev [0..<j])\n\ngoal (1 subgoal):\n 1. (\\<And>jj. j = Suc jj \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases j, auto)"], ["proof (state)\nthis:\n  j = Suc jj\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "from jn j"], ["proof (chain)\npicking this:\n  j \\<le> n\n  j \\<le> i\n  j = Suc jj", "have jj: \"jj \\<le> n\" \"jj < n\" \"jj \\<le> i\" \"jj < i\""], ["proof (prove)\nusing this:\n  j \\<le> n\n  j \\<le> i\n  j = Suc jj\n\ngoal (1 subgoal):\n 1. (jj \\<le> n &&& jj < n) &&& jj \\<le> i &&& jj < i", "by auto"], ["proof (state)\nthis:\n  jj \\<le> n\n  jj < n\n  jj \\<le> i\n  jj < i\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "have zj: \"[0 ..< j] = [0 ..< jj] @ [jj]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<j] = [0..<jj] @ [jj]", "unfolding j"], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc jj] = [0..<jj] @ [jj]", "by simp"], ["proof (state)\nthis:\n  [0..<j] = [0..<jj] @ [jj]\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "have jjn: \"[jj ..< i] = jj # [j ..< i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [jj..<i] = jj # [j..<i]", "using jj"], ["proof (prove)\nusing this:\n  jj \\<le> n\n  jj < n\n  jj \\<le> i\n  jj < i\n\ngoal (1 subgoal):\n 1. [jj..<i] = jj # [j..<i]", "unfolding j"], ["proof (prove)\nusing this:\n  jj \\<le> n\n  jj < n\n  jj \\<le> i\n  jj < i\n\ngoal (1 subgoal):\n 1. [jj..<i] = jj # [Suc jj..<i]", "by (metis upt_conv_Cons)"], ["proof (state)\nthis:\n  [jj..<i] = jj # [j..<i]\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "from us_gs[unfolded zj]"], ["proof (chain)\npicking this:\n  u # us = map gso (rev ([0..<jj] @ [jj]))", "have ugs: \"u = gso jj\" and us: \"us = map gso (rev [0..<jj])\""], ["proof (prove)\nusing this:\n  u # us = map gso (rev ([0..<jj] @ [jj]))\n\ngoal (1 subgoal):\n 1. u = gso jj &&& us = map gso (rev [0..<jj])", "by auto"], ["proof (state)\nthis:\n  u = gso jj\n  us = map gso (rev [0..<jj])\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "let ?w = \"w \\<bullet> u / (u \\<bullet> u)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "have muij: \"?w = \\<mu> i jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<bullet> u / (u \\<bullet> u) = \\<mu> i jj", "unfolding \\<mu>.simps[of i jj] ugs wi sq_norm_vec_as_cscalar_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso jj / (gso jj \\<bullet> gso jj) =\n    (if jj < i then fs ! i \\<bullet> gso jj / (gso jj \\<bullet>c gso jj)\n     else if i = jj then 1::'a else (0::'a))", "using jj"], ["proof (prove)\nusing this:\n  jj \\<le> n\n  jj < n\n  jj \\<le> i\n  jj < i\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso jj / (gso jj \\<bullet> gso jj) =\n    (if jj < i then fs ! i \\<bullet> gso jj / (gso jj \\<bullet>c gso jj)\n     else if i = jj then 1::'a else (0::'a))", "by auto"], ["proof (state)\nthis:\n  w \\<bullet> u / (u \\<bullet> u) = \\<mu> i jj\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "have wwits: \"?w # wits = map (\\<mu> i) [jj..<i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<bullet> u / (u \\<bullet> u) # wits = map (\\<mu> i) [jj..<i]", "unfolding jjn wits muij"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> i jj # map (\\<mu> i) [j..<i] = map (\\<mu> i) (jj # [j..<i])", "by simp"], ["proof (state)\nthis:\n  w \\<bullet> u / (u \\<bullet> u) # wits = map (\\<mu> i) [jj..<i]\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "obtain wwits b where rec: \"adjuster_wit (?w # wits) w us = (wwits,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>wwits b.\n        adjuster_wit (w \\<bullet> u / (u \\<bullet> u) # wits) w us =\n        (wwits, b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  adjuster_wit (w \\<bullet> u / (u \\<bullet> u) # wits) w us = (wwits, b)\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "from Cons(1)[OF this Cons(3) us wwits jj(1,3),unfolded j]"], ["proof (chain)\npicking this:\n  (\\<And>i. i \\<le> jj \\<Longrightarrow> i \\<le> Suc jj) \\<Longrightarrow>\n  adjuster n w us = b \\<and>\n  b \\<in> carrier_vec n \\<and>\n  wwits = map (\\<mu> i) [0..<i] \\<and>\n  b = sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj])", "have IH: \n     \"adjuster n w us = b\" \"wwits = map (\\<mu> i) [0..<i]\"\n     \"b = sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj])\"\n      and b: \"b \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  (\\<And>i. i \\<le> jj \\<Longrightarrow> i \\<le> Suc jj) \\<Longrightarrow>\n  adjuster n w us = b \\<and>\n  b \\<in> carrier_vec n \\<and>\n  wwits = map (\\<mu> i) [0..<i] \\<and>\n  b = sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj])\n\ngoal (1 subgoal):\n 1. (adjuster n w us = b &&&\n     wwits = map (\\<mu> i) [0..<i] &&&\n     b =\n     sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj])) &&&\n    b \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  adjuster n w us = b\n  wwits = map (\\<mu> i) [0..<i]\n  b = sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj])\n  b \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "from Cons(2)[simplified, unfolded Let_def rec split sq_norm_vec_as_cscalar_prod \n      cscalar_prod_is_scalar_prod]"], ["proof (chain)\npicking this:\n  (wwits, - (w \\<bullet> u / (u \\<bullet> u)) \\<cdot>\\<^sub>v u + b) =\n  (wits', a)", "have id: \"wits' = wwits\" and a: \"a = - ?w \\<cdot>\\<^sub>v u + b\""], ["proof (prove)\nusing this:\n  (wwits, - (w \\<bullet> u / (u \\<bullet> u)) \\<cdot>\\<^sub>v u + b) =\n  (wits', a)\n\ngoal (1 subgoal):\n 1. wits' = wwits &&&\n    a = - (w \\<bullet> u / (u \\<bullet> u)) \\<cdot>\\<^sub>v u + b", "by auto"], ["proof (state)\nthis:\n  wits' = wwits\n  a = - (w \\<bullet> u / (u \\<bullet> u)) \\<cdot>\\<^sub>v u + b\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "have 1: \"adjuster n w (u # us) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjuster n w (u # us) = a", "unfolding a IH(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjuster n w (u # us) =\n    - (w \\<bullet> u / (u \\<bullet> u)) \\<cdot>\\<^sub>v u + adjuster n w us", "by auto"], ["proof (state)\nthis:\n  adjuster n w (u # us) = a\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "from id IH(2)"], ["proof (chain)\npicking this:\n  wits' = wwits\n  wwits = map (\\<mu> i) [0..<i]", "have wits': \"wits' =  map (\\<mu> i) [0..<i]\""], ["proof (prove)\nusing this:\n  wits' = wwits\n  wwits = map (\\<mu> i) [0..<i]\n\ngoal (1 subgoal):\n 1. wits' = map (\\<mu> i) [0..<i]", "by simp"], ["proof (state)\nthis:\n  wits' = map (\\<mu> i) [0..<i]\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "have carr:\"set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]) \\<subseteq> carrier_vec n\"\n            \"set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj]) \\<subseteq> carrier_vec n\" and u:\"u \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j])\n     \\<subseteq> carrier_vec n &&&\n     set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj])\n     \\<subseteq> carrier_vec n) &&&\n    u \\<in> carrier_vec n", "using Cons j"], ["proof (prove)\nusing this:\n  \\<lbrakk>adjuster_wit ?wits1 w us = (?wits'1, ?a1);\n   \\<And>i. i \\<le> ?j1 \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n   us = map gso (rev [0..<?j1]); ?wits1 = map (\\<mu> i) [?j1..<i];\n   ?j1 \\<le> n; ?j1 \\<le> i\\<rbrakk>\n  \\<Longrightarrow> adjuster n w us = ?a1 \\<and>\n                    ?a1 \\<in> carrier_vec n \\<and>\n                    ?wits'1 = map (\\<mu> i) [0..<i] \\<and>\n                    ?a1 =\n                    sumlist\n                     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<?j1])\n  adjuster_wit wits w (u # us) = (wits', a)\n  ?i1 \\<le> j \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n  u # us = map gso (rev [0..<j])\n  wits = map (\\<mu> i) [j..<i]\n  j \\<le> n\n  j \\<le> i\n  j = Suc jj\n\ngoal (1 subgoal):\n 1. (set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j])\n     \\<subseteq> carrier_vec n &&&\n     set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj])\n     \\<subseteq> carrier_vec n) &&&\n    u \\<in> carrier_vec n", "by (auto intro!:gso_carrier')"], ["proof (state)\nthis:\n  set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j])\n  \\<subseteq> carrier_vec n\n  set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj])\n  \\<subseteq> carrier_vec n\n  u \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "from u b a"], ["proof (chain)\npicking this:\n  u \\<in> carrier_vec n\n  b \\<in> carrier_vec n\n  a = - (w \\<bullet> u / (u \\<bullet> u)) \\<cdot>\\<^sub>v u + b", "have ac: \"a \\<in> carrier_vec n\" \"dim_vec (-?w \\<cdot>\\<^sub>v u) = n\" \"dim_vec b = n\" \"dim_vec u = n\""], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  b \\<in> carrier_vec n\n  a = - (w \\<bullet> u / (u \\<bullet> u)) \\<cdot>\\<^sub>v u + b\n\ngoal (1 subgoal):\n 1. (a \\<in> carrier_vec n &&&\n     dim_vec (- (w \\<bullet> u / (u \\<bullet> u)) \\<cdot>\\<^sub>v u) =\n     n) &&&\n    dim_vec b = n &&& dim_vec u = n", "by auto"], ["proof (state)\nthis:\n  a \\<in> carrier_vec n\n  dim_vec (- (w \\<bullet> u / (u \\<bullet> u)) \\<cdot>\\<^sub>v u) = n\n  dim_vec b = n\n  dim_vec u = n\n\ngoal (2 subgoals):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])\n 2. \\<And>a us wits wits' aa j.\n       \\<lbrakk>\\<And>wits wits' a j.\n                   \\<lbrakk>adjuster_wit wits w us = (wits', a);\n                    \\<And>i.\n                       i \\<le> j \\<Longrightarrow>\n                       fs ! i \\<in> carrier_vec n;\n                    us = map gso (rev [0..<j]);\n                    wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> adjuster n w us = a \\<and>\n                                     a \\<in> carrier_vec n \\<and>\n                                     wits' = map (\\<mu> i) [0..<i] \\<and>\n                                     a =\n                                     sumlist\n(map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j]);\n        adjuster_wit wits w (a # us) = (wits', aa);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        a # us = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i];\n        j \\<le> n; j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w (a # us) = aa \\<and>\n                         aa \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         aa =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjuster n w (u # us) = a \\<and>\n    a \\<in> carrier_vec n \\<and>\n    wits' = map (\\<mu> i) [0..<i] \\<and>\n    a =\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j])", "apply (intro conjI[OF 1] ac exI conjI wits')"], ["proof (prove)\ngoal (1 subgoal):\n 1. a =\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j])", "unfolding carr a IH zj muij ugs[symmetric] map_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<mu> i jj \\<cdot>\\<^sub>v u +\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj]) =\n    sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj] @\n      map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [jj])", "apply (subst sumlist_append)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj])\n    \\<subseteq> carrier_vec n\n 2. set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [jj])\n    \\<subseteq> carrier_vec n\n 3. - \\<mu> i jj \\<cdot>\\<^sub>v u +\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj]) =\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj]) +\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [jj])", "using Cons.prems j"], ["proof (prove)\nusing this:\n  adjuster_wit wits w (u # us) = (wits', a)\n  ?i1 \\<le> j \\<Longrightarrow> fs ! ?i1 \\<in> carrier_vec n\n  u # us = map gso (rev [0..<j])\n  wits = map (\\<mu> i) [j..<i]\n  j \\<le> n\n  j \\<le> i\n  j = Suc jj\n\ngoal (3 subgoals):\n 1. set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj])\n    \\<subseteq> carrier_vec n\n 2. set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [jj])\n    \\<subseteq> carrier_vec n\n 3. - \\<mu> i jj \\<cdot>\\<^sub>v u +\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj]) =\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj]) +\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [jj])", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [jj])\n    \\<subseteq> carrier_vec n\n 2. - \\<mu> i jj \\<cdot>\\<^sub>v u +\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj]) =\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj]) +\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [jj])", "using b u ugs IH(3)"], ["proof (prove)\nusing this:\n  b \\<in> carrier_vec n\n  u \\<in> carrier_vec n\n  u = gso jj\n  b = sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj])\n\ngoal (2 subgoals):\n 1. set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [jj])\n    \\<subseteq> carrier_vec n\n 2. - \\<mu> i jj \\<cdot>\\<^sub>v u +\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj]) =\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<jj]) +\n    sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [jj])", "by auto"], ["proof (state)\nthis:\n  adjuster n w (u # us) = a \\<and>\n  a \\<in> carrier_vec n \\<and>\n  wits' = map (\\<mu> i) [0..<i] \\<and>\n  a = sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<j])\n\ngoal (1 subgoal):\n 1. \\<And>wits wits' a j.\n       \\<lbrakk>adjuster_wit wits w [] = (wits', a);\n        \\<And>i. i \\<le> j \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n        [] = map gso (rev [0..<j]); wits = map (\\<mu> i) [j..<i]; j \\<le> n;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> adjuster n w [] = a \\<and>\n                         a \\<in> carrier_vec n \\<and>\n                         wits' = map (\\<mu> i) [0..<i] \\<and>\n                         a =\n                         sumlist\n                          (map (\\<lambda>j.\n                                   - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<j])", "qed auto"], ["", "lemma sub2_wit:\n  assumes \"set us \\<subseteq> carrier_vec n\" \"set ws \\<subseteq> carrier_vec n\" \"length us + length ws = m\" \n    and \"ws = map (\\<lambda> i. fs ! i) [i ..< m]\"\n    and \"us = map gso (rev [0 ..< i])\" \n    and us: \"\\<And> j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\"\n    and mn: \"m \\<le> n\" \n  shows \"sub2_wit us ws = (wits,vvs) \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \n    \\<and> vvs = map gso [i ..< m] \\<and> wits = map (\\<lambda> i. map (\\<mu> i) [0..<i]) [i ..< m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub2_wit us ws = (wits, vvs) \\<Longrightarrow>\n    gram_schmidt_sub2 n us ws = vvs \\<and>\n    vvs = map gso [i..<m] \\<and>\n    wits = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "using assms(1-6)"], ["proof (prove)\nusing this:\n  set us \\<subseteq> carrier_vec n\n  set ws \\<subseteq> carrier_vec n\n  length us + length ws = m\n  ws = map ((!) fs) [i..<m]\n  us = map gso (rev [0..<i])\n  ?j1 < m \\<Longrightarrow> fs ! ?j1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. sub2_wit us ws = (wits, vvs) \\<Longrightarrow>\n    gram_schmidt_sub2 n us ws = vvs \\<and>\n    vvs = map gso [i..<m] \\<and>\n    wits = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "proof (induct ws arbitrary: us vvs i wits)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "case (Cons w ws us vs)"], ["proof (state)\nthis:\n  \\<lbrakk>sub2_wit ?us1 ws = (?wits1, ?vvs1);\n   set ?us1 \\<subseteq> carrier_vec n; set ws \\<subseteq> carrier_vec n;\n   length ?us1 + length ws = m; ws = map ((!) fs) [?i1..<m];\n   ?us1 = map gso (rev [0..<?i1]);\n   \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_sub2 n ?us1 ws = ?vvs1 \\<and>\n                    ?vvs1 = map gso [?i1..<m] \\<and>\n                    ?wits1 =\n                    map (\\<lambda>i. map (\\<mu> i) [0..<i]) [?i1..<m]\n  sub2_wit us (w # ws) = (wits, vs)\n  set us \\<subseteq> carrier_vec n\n  set (w # ws) \\<subseteq> carrier_vec n\n  length us + length (w # ws) = m\n  w # ws = map ((!) fs) [i..<m]\n  us = map gso (rev [0..<i])\n  ?j1 < m \\<Longrightarrow> fs ! ?j1 \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "note us = Cons(3)"], ["proof (state)\nthis:\n  set us \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "note wws = Cons(4)"], ["proof (state)\nthis:\n  set (w # ws) \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "note wsf' = Cons(6)"], ["proof (state)\nthis:\n  w # ws = map ((!) fs) [i..<m]\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "note us_gs = Cons(7)"], ["proof (state)\nthis:\n  us = map gso (rev [0..<i])\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "from wsf'"], ["proof (chain)\npicking this:\n  w # ws = map ((!) fs) [i..<m]", "have \"i < m\" \"i \\<le> m\""], ["proof (prove)\nusing this:\n  w # ws = map ((!) fs) [i..<m]\n\ngoal (1 subgoal):\n 1. i < m &&& i \\<le> m", "by (cases \"i < m\", auto)+"], ["proof (state)\nthis:\n  i < m\n  i \\<le> m\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "hence i_m: \"[i ..< m] = i # [Suc i ..< m]\""], ["proof (prove)\nusing this:\n  i < m\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. [i..<m] = i # [Suc i..<m]", "by (metis upt_conv_Cons)"], ["proof (state)\nthis:\n  [i..<m] = i # [Suc i..<m]\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "from \\<open>i < m\\<close> mn"], ["proof (chain)\npicking this:\n  i < m\n  m \\<le> n", "have \"i < n\" \"i \\<le> n\" \"i \\<le> m\""], ["proof (prove)\nusing this:\n  i < m\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. i < n &&& i \\<le> n &&& i \\<le> m", "by auto"], ["proof (state)\nthis:\n  i < n\n  i \\<le> n\n  i \\<le> m\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "hence i_n: \"[i ..< n] = i # [Suc i ..< n]\""], ["proof (prove)\nusing this:\n  i < n\n  i \\<le> n\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. [i..<n] = i # [Suc i..<n]", "by (metis upt_conv_Cons)"], ["proof (state)\nthis:\n  [i..<n] = i # [Suc i..<n]\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "from wsf' i_m"], ["proof (chain)\npicking this:\n  w # ws = map ((!) fs) [i..<m]\n  [i..<m] = i # [Suc i..<m]", "have wsf: \"ws = map (\\<lambda> i. fs ! i) [Suc i ..< m]\" \n    and fiw: \"fs !  i = w\""], ["proof (prove)\nusing this:\n  w # ws = map ((!) fs) [i..<m]\n  [i..<m] = i # [Suc i..<m]\n\ngoal (1 subgoal):\n 1. ws = map ((!) fs) [Suc i..<m] &&& fs ! i = w", "by auto"], ["proof (state)\nthis:\n  ws = map ((!) fs) [Suc i..<m]\n  fs ! i = w\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "from wws"], ["proof (chain)\npicking this:\n  set (w # ws) \\<subseteq> carrier_vec n", "have w: \"w \\<in> carrier_vec n\" and ws: \"set ws \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  set (w # ws) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n &&& set ws \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  w \\<in> carrier_vec n\n  set ws \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "have list: \"map (\\<mu> i) [i ..< i] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<mu> i) [i..<i] = []", "by auto"], ["proof (state)\nthis:\n  map (\\<mu> i) [i..<i] = []\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "let ?a = \"adjuster_wit [] w us\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "obtain wit a where a: \"?a = (wit,a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>wit a.\n        adjuster_wit [] w us = (wit, a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  adjuster_wit [] w us = (wit, a)\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "obtain wits' vv where gs: \"sub2_wit ((a + w) # us) ws = (wits',vv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>wits' vv.\n        sub2_wit ((a + w) # us) ws = (wits', vv) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  sub2_wit ((a + w) # us) ws = (wits', vv)\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "from adjuster_wit[OF a w Cons(8) us_gs list[symmetric] \\<open>i \\<le> n\\<close> _ fiw[symmetric]] us wws \\<open>i < m\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>i. i \\<le> i \\<Longrightarrow> i < m; i \\<le> i\\<rbrakk>\n  \\<Longrightarrow> adjuster n w us = a \\<and>\n                    a \\<in> carrier_vec n \\<and>\n                    wit = map (\\<mu> i) [0..<i] \\<and>\n                    a =\n                    sumlist\n                     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i])\n  set us \\<subseteq> carrier_vec n\n  set (w # ws) \\<subseteq> carrier_vec n\n  i < m", "have awus: \"set ((a + w) # us) \\<subseteq> carrier_vec n\"  \n     and aa: \"adjuster n w us = a\" \"a \\<in> carrier_vec n\" \n     and aaa: \"a = sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\"  \n     and wit: \"wit = map (\\<mu> i) [0..<i]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i. i \\<le> i \\<Longrightarrow> i < m; i \\<le> i\\<rbrakk>\n  \\<Longrightarrow> adjuster n w us = a \\<and>\n                    a \\<in> carrier_vec n \\<and>\n                    wit = map (\\<mu> i) [0..<i] \\<and>\n                    a =\n                    sumlist\n                     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i])\n  set us \\<subseteq> carrier_vec n\n  set (w # ws) \\<subseteq> carrier_vec n\n  i < m\n\ngoal (1 subgoal):\n 1. (set ((a + w) # us) \\<subseteq> carrier_vec n &&&\n     adjuster n w us = a &&& a \\<in> carrier_vec n) &&&\n    a =\n    sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) &&&\n    wit = map (\\<mu> i) [0..<i]", "by auto"], ["proof (state)\nthis:\n  set ((a + w) # us) \\<subseteq> carrier_vec n\n  adjuster n w us = a\n  a \\<in> carrier_vec n\n  a = sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  wit = map (\\<mu> i) [0..<i]\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "have aw_gs: \"a + w = gso i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + w = gso i", "unfolding gso.simps[of i] fiw aaa[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + w = w + a", "using aa(2) w"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. a + w = w + a", "by auto"], ["proof (state)\nthis:\n  a + w = gso i\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "with us_gs"], ["proof (chain)\npicking this:\n  us = map gso (rev [0..<i])\n  a + w = gso i", "have us_gs': \"(a + w) # us = map gso (rev [0..<Suc i])\""], ["proof (prove)\nusing this:\n  us = map gso (rev [0..<i])\n  a + w = gso i\n\ngoal (1 subgoal):\n 1. (a + w) # us = map gso (rev [0..<Suc i])", "by auto"], ["proof (state)\nthis:\n  (a + w) # us = map gso (rev [0..<Suc i])\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "from Cons(1)[OF gs awus ws _ wsf us_gs' Cons(8)] Cons(5)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ((a + w) # us) + length ws = m;\n   \\<And>j. j < m \\<Longrightarrow> j < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_sub2 n ((a + w) # us) ws = vv \\<and>\n                    vv = map gso [Suc i..<m] \\<and>\n                    wits' =\n                    map (\\<lambda>i. map (\\<mu> i) [0..<i]) [Suc i..<m]\n  length us + length (w # ws) = m", "have IH: \"gram_schmidt_sub2 n ((a + w) # us) ws = vv\"  \n    and vv: \"vv = map gso [Suc i..<m]\" \n    and wits': \"wits' = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [Suc i ..< m]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ((a + w) # us) + length ws = m;\n   \\<And>j. j < m \\<Longrightarrow> j < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_sub2 n ((a + w) # us) ws = vv \\<and>\n                    vv = map gso [Suc i..<m] \\<and>\n                    wits' =\n                    map (\\<lambda>i. map (\\<mu> i) [0..<i]) [Suc i..<m]\n  length us + length (w # ws) = m\n\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n ((a + w) # us) ws = vv &&&\n    vv = map gso [Suc i..<m] &&&\n    wits' = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [Suc i..<m]", "by auto"], ["proof (state)\nthis:\n  gram_schmidt_sub2 n ((a + w) # us) ws = vv\n  vv = map gso [Suc i..<m]\n  wits' = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [Suc i..<m]\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "from gs a aa IH Cons(5)"], ["proof (chain)\npicking this:\n  sub2_wit ((a + w) # us) ws = (wits', vv)\n  adjuster_wit [] w us = (wit, a)\n  adjuster n w us = a\n  a \\<in> carrier_vec n\n  gram_schmidt_sub2 n ((a + w) # us) ws = vv\n  length us + length (w # ws) = m", "have gs_vs: \"gram_schmidt_sub2 n us (w # ws) = vs\" and vs: \"vs = (a + w) # vv\""], ["proof (prove)\nusing this:\n  sub2_wit ((a + w) # us) ws = (wits', vv)\n  adjuster_wit [] w us = (wit, a)\n  adjuster n w us = a\n  a \\<in> carrier_vec n\n  gram_schmidt_sub2 n ((a + w) # us) ws = vv\n  length us + length (w # ws) = m\n\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n us (w # ws) = vs &&& vs = (a + w) # vv", "using Cons(2)"], ["proof (prove)\nusing this:\n  sub2_wit ((a + w) # us) ws = (wits', vv)\n  adjuster_wit [] w us = (wit, a)\n  adjuster n w us = a\n  a \\<in> carrier_vec n\n  gram_schmidt_sub2 n ((a + w) # us) ws = vv\n  length us + length (w # ws) = m\n  sub2_wit us (w # ws) = (wits, vs)\n\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n us (w # ws) = vs &&& vs = (a + w) # vv", "by (auto simp add: Let_def snd_def split:prod.splits)"], ["proof (state)\nthis:\n  gram_schmidt_sub2 n us (w # ws) = vs\n  vs = (a + w) # vv\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "from Cons(2)[unfolded sub2_wit.simps a split Let_def gs]"], ["proof (chain)\npicking this:\n  (wit # wits', (a + w) # vv) = (wits, vs)", "have wits: \"wits = wit # wits'\""], ["proof (prove)\nusing this:\n  (wit # wits', (a + w) # vv) = (wits, vs)\n\ngoal (1 subgoal):\n 1. wits = wit # wits'", "by auto"], ["proof (state)\nthis:\n  wits = wit # wits'\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "from vs vv aw_gs"], ["proof (chain)\npicking this:\n  vs = (a + w) # vv\n  vv = map gso [Suc i..<m]\n  a + w = gso i", "have vs: \"vs = map gso [i ..< m]\""], ["proof (prove)\nusing this:\n  vs = (a + w) # vv\n  vv = map gso [Suc i..<m]\n  a + w = gso i\n\ngoal (1 subgoal):\n 1. vs = map gso [i..<m]", "unfolding i_m"], ["proof (prove)\nusing this:\n  vs = (a + w) # vv\n  vv = map gso [Suc i..<m]\n  a + w = gso i\n\ngoal (1 subgoal):\n 1. vs = map gso (i # [Suc i..<m])", "by auto"], ["proof (state)\nthis:\n  vs = map gso [i..<m]\n\ngoal (2 subgoals):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n 2. \\<And>a ws us vvs i wits.\n       \\<lbrakk>\\<And>us vvs i wits.\n                   \\<lbrakk>sub2_wit us ws = (wits, vvs);\n                    set us \\<subseteq> carrier_vec n;\n                    set ws \\<subseteq> carrier_vec n;\n                    length us + length ws = m; ws = map ((!) fs) [i..<m];\n                    us = map gso (rev [0..<i]);\n                    \\<And>j.\n                       j < m \\<Longrightarrow>\n                       fs ! j \\<in> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_sub2 n us ws = vvs \\<and>\n                                     vvs = map gso [i..<m] \\<and>\n                                     wits =\n                                     map (\\<lambda>i. map (\\<mu> i) [0..<i])\n[i..<m];\n        sub2_wit us (a # ws) = (wits, vvs);\n        set us \\<subseteq> carrier_vec n;\n        set (a # ws) \\<subseteq> carrier_vec n;\n        length us + length (a # ws) = m; a # ws = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us (a # ws) = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "with gs_vs"], ["proof (chain)\npicking this:\n  gram_schmidt_sub2 n us (w # ws) = vs\n  vs = map gso [i..<m]", "show ?case"], ["proof (prove)\nusing this:\n  gram_schmidt_sub2 n us (w # ws) = vs\n  vs = map gso [i..<m]\n\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n us (w # ws) = vs \\<and>\n    vs = map gso [i..<m] \\<and>\n    wits = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "unfolding wits wit wits'"], ["proof (prove)\nusing this:\n  gram_schmidt_sub2 n us (w # ws) = vs\n  vs = map gso [i..<m]\n\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n us (w # ws) = vs \\<and>\n    vs = map gso [i..<m] \\<and>\n    map (\\<mu> i) [0..<i] #\n    map (\\<lambda>i. map (\\<mu> i) [0..<i]) [Suc i..<m] =\n    map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "by (auto simp: i_m)"], ["proof (state)\nthis:\n  gram_schmidt_sub2 n us (w # ws) = vs \\<and>\n  vs = map gso [i..<m] \\<and>\n  wits = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]\n\ngoal (1 subgoal):\n 1. \\<And>us vvs i wits.\n       \\<lbrakk>sub2_wit us [] = (wits, vvs);\n        set us \\<subseteq> carrier_vec n; set [] \\<subseteq> carrier_vec n;\n        length us + length [] = m; [] = map ((!) fs) [i..<m];\n        us = map gso (rev [0..<i]);\n        \\<And>j. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_sub2 n us [] = vvs \\<and>\n                         vvs = map gso [i..<m] \\<and>\n                         wits =\n                         map (\\<lambda>i. map (\\<mu> i) [0..<i]) [i..<m]", "qed auto"], ["", "lemma partial_connect: fixes vs\n  assumes \"length fs = m\" \"k \\<le> m\" \"m \\<le> n\" \"set us \\<subseteq> carrier_vec n\" \"snd (main us) = vs\" \n  \"us = take k fs\" \"set fs \\<subseteq> carrier_vec n\"\nshows \"gram_schmidt n us = vs\" \n    \"vs = map gso [0..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt n us = vs &&& vs = map gso [0..<k]", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. gram_schmidt n us = vs\n 2. vs = map gso [0..<k]", "have [simp]: \"map ((!) fs) [0..<k] = take k fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) fs) [0..<k] = take k fs", "using assms(1,2)"], ["proof (prove)\nusing this:\n  length fs = m\n  k \\<le> m\n\ngoal (1 subgoal):\n 1. map ((!) fs) [0..<k] = take k fs", "by (intro nth_equalityI, auto)"], ["proof (state)\nthis:\n  map ((!) fs) [0..<k] = take k fs\n\ngoal (2 subgoals):\n 1. gram_schmidt n us = vs\n 2. vs = map gso [0..<k]", "have carr: \"j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  length fs = m\n  k \\<le> m\n  m \\<le> n\n  set us \\<subseteq> carrier_vec n\n  snd (main us) = vs\n  us = take k fs\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. j < m \\<Longrightarrow> fs ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?j1 < m \\<Longrightarrow> fs ! ?j1 \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. gram_schmidt n us = vs\n 2. vs = map gso [0..<k]", "note assms(5)[unfolded main_def]"], ["proof (state)\nthis:\n  snd (sub2_wit [] us) = vs\n\ngoal (2 subgoals):\n 1. gram_schmidt n us = vs\n 2. vs = map gso [0..<k]", "have \"gram_schmidt_sub2 n [] (take k fs) = vvs \\<and> vvs = map gso [0..<k] \\<and> wits = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<k]\"\n    if \"vvs = snd (sub2_wit [] (take k fs))\" \"wits = fst (sub2_wit [] (take k fs))\" for vvs wits"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n [] (take k fs) = vvs \\<and>\n    vvs = map gso [0..<k] \\<and>\n    wits = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<k]", "using assms that"], ["proof (prove)\nusing this:\n  length fs = m\n  k \\<le> m\n  m \\<le> n\n  set us \\<subseteq> carrier_vec n\n  snd (main us) = vs\n  us = take k fs\n  set fs \\<subseteq> carrier_vec n\n  vvs = snd (sub2_wit [] (take k fs))\n  wits = fst (sub2_wit [] (take k fs))\n\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n [] (take k fs) = vvs \\<and>\n    vvs = map gso [0..<k] \\<and>\n    wits = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<k]", "by (intro sub2_wit) (auto)"], ["proof (state)\nthis:\n  \\<lbrakk>?vvs1 = snd (sub2_wit [] (take k fs));\n   ?wits1 = fst (sub2_wit [] (take k fs))\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_sub2 n [] (take k fs) = ?vvs1 \\<and>\n                    ?vvs1 = map gso [0..<k] \\<and>\n                    ?wits1 = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<k]\n\ngoal (2 subgoals):\n 1. gram_schmidt n us = vs\n 2. vs = map gso [0..<k]", "with assms main_def"], ["proof (chain)\npicking this:\n  length fs = m\n  k \\<le> m\n  m \\<le> n\n  set us \\<subseteq> carrier_vec n\n  snd (main us) = vs\n  us = take k fs\n  set fs \\<subseteq> carrier_vec n\n  main ?us = sub2_wit [] ?us\n  \\<lbrakk>?vvs1 = snd (sub2_wit [] (take k fs));\n   ?wits1 = fst (sub2_wit [] (take k fs))\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_sub2 n [] (take k fs) = ?vvs1 \\<and>\n                    ?vvs1 = map gso [0..<k] \\<and>\n                    ?wits1 = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<k]", "show \"gram_schmidt n us = vs\" \"vs = map gso [0..<k]\""], ["proof (prove)\nusing this:\n  length fs = m\n  k \\<le> m\n  m \\<le> n\n  set us \\<subseteq> carrier_vec n\n  snd (main us) = vs\n  us = take k fs\n  set fs \\<subseteq> carrier_vec n\n  main ?us = sub2_wit [] ?us\n  \\<lbrakk>?vvs1 = snd (sub2_wit [] (take k fs));\n   ?wits1 = fst (sub2_wit [] (take k fs))\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_sub2 n [] (take k fs) = ?vvs1 \\<and>\n                    ?vvs1 = map gso [0..<k] \\<and>\n                    ?wits1 = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<k]\n\ngoal (1 subgoal):\n 1. gram_schmidt n us = vs &&& vs = map gso [0..<k]", "unfolding gram_schmidt_code"], ["proof (prove)\nusing this:\n  length fs = m\n  k \\<le> m\n  m \\<le> n\n  set us \\<subseteq> carrier_vec n\n  snd (main us) = vs\n  us = take k fs\n  set fs \\<subseteq> carrier_vec n\n  main ?us = sub2_wit [] ?us\n  \\<lbrakk>?vvs1 = snd (sub2_wit [] (take k fs));\n   ?wits1 = fst (sub2_wit [] (take k fs))\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_sub2 n [] (take k fs) = ?vvs1 \\<and>\n                    ?vvs1 = map gso [0..<k] \\<and>\n                    ?wits1 = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<k]\n\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n [] us = vs &&& vs = map gso [0..<k]", "by (auto simp add: main_def case_prod_beta')"], ["proof (state)\nthis:\n  gram_schmidt n us = vs\n  vs = map gso [0..<k]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjuster_wit_small:\n  \"(adjuster_wit v a xs) = (x1,x2)\n  \\<longleftrightarrow> (fst (adjuster_wit v a xs) = x1 \\<and> x2 = adjuster n a xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (adjuster_wit v a xs = (x1, x2)) =\n    (fst (adjuster_wit v a xs) = x1 \\<and> x2 = adjuster n a xs)", "proof(induct xs arbitrary: a v x1 x2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a v x1 x2.\n       (adjuster_wit v a [] = (x1, x2)) =\n       (fst (adjuster_wit v a []) = x1 \\<and> x2 = adjuster n a [])\n 2. \\<And>a xs aa v x1 x2.\n       (\\<And>a v x1 x2.\n           (adjuster_wit v a xs = (x1, x2)) =\n           (fst (adjuster_wit v a xs) = x1 \\<and>\n            x2 = adjuster n a xs)) \\<Longrightarrow>\n       (adjuster_wit v aa (a # xs) = (x1, x2)) =\n       (fst (adjuster_wit v aa (a # xs)) = x1 \\<and>\n        x2 = adjuster n aa (a # xs))", "case (Cons a xs)"], ["proof (state)\nthis:\n  (adjuster_wit ?v1 ?a1 xs = (?x1.1, ?x2.1)) =\n  (fst (adjuster_wit ?v1 ?a1 xs) = ?x1.1 \\<and> ?x2.1 = adjuster n ?a1 xs)\n\ngoal (2 subgoals):\n 1. \\<And>a v x1 x2.\n       (adjuster_wit v a [] = (x1, x2)) =\n       (fst (adjuster_wit v a []) = x1 \\<and> x2 = adjuster n a [])\n 2. \\<And>a xs aa v x1 x2.\n       (\\<And>a v x1 x2.\n           (adjuster_wit v a xs = (x1, x2)) =\n           (fst (adjuster_wit v a xs) = x1 \\<and>\n            x2 = adjuster n a xs)) \\<Longrightarrow>\n       (adjuster_wit v aa (a # xs) = (x1, x2)) =\n       (fst (adjuster_wit v aa (a # xs)) = x1 \\<and>\n        x2 = adjuster n aa (a # xs))", "then"], ["proof (chain)\npicking this:\n  (adjuster_wit ?v1 ?a1 xs = (?x1.1, ?x2.1)) =\n  (fst (adjuster_wit ?v1 ?a1 xs) = ?x1.1 \\<and> ?x2.1 = adjuster n ?a1 xs)", "show ?case"], ["proof (prove)\nusing this:\n  (adjuster_wit ?v1 ?a1 xs = (?x1.1, ?x2.1)) =\n  (fst (adjuster_wit ?v1 ?a1 xs) = ?x1.1 \\<and> ?x2.1 = adjuster n ?a1 xs)\n\ngoal (1 subgoal):\n 1. (adjuster_wit v a (aa__ # xs) = (x1, x2)) =\n    (fst (adjuster_wit v a (aa__ # xs)) = x1 \\<and>\n     x2 = adjuster n a (aa__ # xs))", "by (auto simp:Let_def sq_norm_vec_as_cscalar_prod split:prod.splits)"], ["proof (state)\nthis:\n  (adjuster_wit v a (aa__ # xs) = (x1, x2)) =\n  (fst (adjuster_wit v a (aa__ # xs)) = x1 \\<and>\n   x2 = adjuster n a (aa__ # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a v x1 x2.\n       (adjuster_wit v a [] = (x1, x2)) =\n       (fst (adjuster_wit v a []) = x1 \\<and> x2 = adjuster n a [])", "qed auto"], ["", "lemma sub2: \"rev xs @ snd (sub2_wit xs us) = rev (gram_schmidt_sub n xs us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs @ snd (sub2_wit xs us) = rev (gram_schmidt_sub n xs us)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rev xs @ snd (sub2_wit xs us) = rev (gram_schmidt_sub n xs us)", "have \"sub2_wit xs us = (x1, x2) \\<Longrightarrow> rev xs @ x2 = rev (gram_schmidt_sub n xs us)\"\n    for x1 x2 xs us"], ["proof (prove)\ngoal (1 subgoal):\n 1. sub2_wit xs us = (x1, x2) \\<Longrightarrow>\n    rev xs @ x2 = rev (gram_schmidt_sub n xs us)", "apply(induct us arbitrary: xs x1 x2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs x1 x2.\n       sub2_wit xs [] = (x1, x2) \\<Longrightarrow>\n       rev xs @ x2 = rev (gram_schmidt_sub n xs [])\n 2. \\<And>a us xs x1 x2.\n       \\<lbrakk>\\<And>xs x1 x2.\n                   sub2_wit xs us = (x1, x2) \\<Longrightarrow>\n                   rev xs @ x2 = rev (gram_schmidt_sub n xs us);\n        sub2_wit xs (a # us) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> rev xs @ x2 = rev (gram_schmidt_sub n xs (a # us))", "by (auto simp:Let_def rev_unsimp adjuster_wit_small split:prod.splits simp del:rev.simps)"], ["proof (state)\nthis:\n  sub2_wit ?xs1 ?us1 = (?x1.1, ?x2.1) \\<Longrightarrow>\n  rev ?xs1 @ ?x2.1 = rev (gram_schmidt_sub n ?xs1 ?us1)\n\ngoal (1 subgoal):\n 1. rev xs @ snd (sub2_wit xs us) = rev (gram_schmidt_sub n xs us)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sub2_wit ?xs1 ?us1 = (?x1.1, ?x2.1) \\<Longrightarrow>\n  rev ?xs1 @ ?x2.1 = rev (gram_schmidt_sub n ?xs1 ?us1)\n\ngoal (1 subgoal):\n 1. rev xs @ snd (sub2_wit xs us) = rev (gram_schmidt_sub n xs us)", "apply (cases us)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs us x1 x2.\n                sub2_wit xs us = (x1, x2) \\<Longrightarrow>\n                rev xs @ x2 = rev (gram_schmidt_sub n xs us);\n     us = []\\<rbrakk>\n    \\<Longrightarrow> rev xs @ snd (sub2_wit xs us) =\n                      rev (gram_schmidt_sub n xs us)\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>xs us x1 x2.\n                   sub2_wit xs us = (x1, x2) \\<Longrightarrow>\n                   rev xs @ x2 = rev (gram_schmidt_sub n xs us);\n        us = a # list\\<rbrakk>\n       \\<Longrightarrow> rev xs @ snd (sub2_wit xs us) =\n                         rev (gram_schmidt_sub n xs us)", "by (auto simp:Let_def rev_unsimp adjuster_wit_small split:prod.splits simp del:rev.simps)"], ["proof (state)\nthis:\n  rev xs @ snd (sub2_wit xs us) = rev (gram_schmidt_sub n xs us)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gso_connect: \"snd (main us) = gram_schmidt n us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (main us) = gram_schmidt n us", "unfolding main_def gram_schmidt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (sub2_wit [] us) = rev (gram_schmidt_sub n [] us)", "using sub2[of Nil us]"], ["proof (prove)\nusing this:\n  rev [] @ snd (sub2_wit [] us) = rev (gram_schmidt_sub n [] us)\n\ngoal (1 subgoal):\n 1. snd (sub2_wit [] us) = rev (gram_schmidt_sub n [] us)", "by auto"], ["", "definition weakly_reduced :: \"'a \\<Rightarrow> nat \\<Rightarrow> bool\" \n  (* for k = n, this is reduced according to \"Modern Computer Algebra\" *)\n  where \"weakly_reduced \\<alpha> k = (\\<forall> i. Suc i < k \\<longrightarrow> \n    sq_norm (gso i) \\<le> \\<alpha> * sq_norm (gso (Suc i)))\""], ["", "definition reduced :: \"'a \\<Rightarrow> nat \\<Rightarrow> bool\" \n  (* this is reduced according to LLL original paper *)\n  where \"reduced \\<alpha> k = (weakly_reduced \\<alpha> k \\<and> \n    (\\<forall> i j. i < k \\<longrightarrow> j < i \\<longrightarrow> abs (\\<mu> i j) \\<le> 1/2))\""], ["", "end"], ["", "(* gram_schmidt_fs *)"], ["", "locale gram_schmidt_fs_Rn = gram_schmidt_fs +\n  assumes fs_carrier: \"set fs \\<subseteq> carrier_vec n\"\nbegin"], ["", "abbreviation (input) m where \"m \\<equiv> length fs\""], ["", "definition M where \"M k = mat k k (\\<lambda> (i,j). \\<mu> i j)\""], ["", "lemma f_carrier[simp]: \"i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n", "using fs_carrier"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  {fs ! i |i. i < length fs} \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n", "by force"], ["", "lemma gso_carrier[simp]: \"i < m \\<Longrightarrow> gso i \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> gso i \\<in> carrier_vec n", "using gso_carrier' f_carrier"], ["proof (prove)\nusing this:\n  (\\<And>i.\n      i \\<le> ?j \\<Longrightarrow>\n      fs ! i \\<in> carrier_vec n) \\<Longrightarrow>\n  gso ?j \\<in> carrier_vec n\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> gso i \\<in> carrier_vec n", "by auto"], ["", "lemma gso_dim[simp]: \"i < m \\<Longrightarrow> dim_vec (gso i) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> dim_vec (gso i) = n", "by auto"], ["", "lemma f_dim[simp]: \"i < m \\<Longrightarrow> dim_vec (fs ! i) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length fs \\<Longrightarrow> dim_vec (fs ! i) = n", "by auto"], ["", "lemma fs0_gso0: \"0 < m \\<Longrightarrow> fs ! 0 = gso 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length fs \\<Longrightarrow> fs ! 0 = gso 0", "unfolding gso.simps[of 0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length fs \\<Longrightarrow>\n    fs ! 0 =\n    fs ! 0 +\n    M.sumlist (map (\\<lambda>j. - \\<mu> 0 j \\<cdot>\\<^sub>v gso j) [0..<0])", "using f_dim[of 0]"], ["proof (prove)\nusing this:\n  0 < length fs \\<Longrightarrow> dim_vec (fs ! 0) = n\n\ngoal (1 subgoal):\n 1. 0 < length fs \\<Longrightarrow>\n    fs ! 0 =\n    fs ! 0 +\n    M.sumlist (map (\\<lambda>j. - \\<mu> 0 j \\<cdot>\\<^sub>v gso j) [0..<0])", "by (cases fs, auto simp add: upt_rec)"], ["", "lemma fs_by_gso_def : \nassumes i: \"i < m\"\nshows \"fs ! i = gso i + M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\" (is \"_ = _ + ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "have a: \"M.sumlist (map (\\<lambda>ja. f ja \\<cdot>\\<^sub>v gso ja) [0..<i]) \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>ja. f ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n    \\<in> carrier_vec n", "using gso_carrier i"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  i < length fs\n\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>ja. f ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n    \\<in> carrier_vec n", "by (intro M.sumlist_carrier, auto)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>ja. f ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "hence \"dim_vec (M.sumlist (map (\\<lambda>ja. f ja \\<cdot>\\<^sub>v gso ja) [0..<i])) = n\""], ["proof (prove)\nusing this:\n  M.sumlist (map (\\<lambda>ja. f ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec\n     (M.sumlist (map (\\<lambda>ja. f ja \\<cdot>\\<^sub>v gso ja) [0..<i])) =\n    n", "by auto"], ["proof (state)\nthis:\n  dim_vec\n   (M.sumlist (map (\\<lambda>ja. f ja \\<cdot>\\<^sub>v gso ja) [0..<i])) =\n  n\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "note a this"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>ja. f ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n  \\<in> carrier_vec n\n  dim_vec\n   (M.sumlist (map (\\<lambda>ja. f ja \\<cdot>\\<^sub>v gso ja) [0..<i])) =\n  n\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "}"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>ja. ?f3 ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n  \\<in> carrier_vec n\n  dim_vec\n   (M.sumlist (map (\\<lambda>ja. ?f3 ja \\<cdot>\\<^sub>v gso ja) [0..<i])) =\n  n\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "note sum_carrier = this"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>ja. ?f3 ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n  \\<in> carrier_vec n\n  dim_vec\n   (M.sumlist (map (\\<lambda>ja. ?f3 ja \\<cdot>\\<^sub>v gso ja) [0..<i])) =\n  n\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "note [simp] = sum_carrier(2)"], ["proof (state)\nthis:\n  dim_vec\n   (M.sumlist (map (\\<lambda>ja. ?f3 ja \\<cdot>\\<^sub>v gso ja) [0..<i])) =\n  n\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "have f: \"fs ! i \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n", "using i"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n", "by simp"], ["proof (state)\nthis:\n  fs ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "have \"gso i + ?sum = fs ! i + M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) + ?sum \" \n    (is \"_ = _ + ?minus_sum + _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i +\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n    fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "unfolding gso.simps[of i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n    fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "by simp"], ["proof (state)\nthis:\n  gso i +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n  fs ! i +\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "also"], ["proof (state)\nthis:\n  gso i +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n  fs ! i +\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "have \"?minus_sum = - ?sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n    - M.sumlist\n       (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "using gso_carrier i sum_carrier"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  i < length fs\n  M.sumlist (map (\\<lambda>ja. ?f3 ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n  \\<in> carrier_vec n\n  dim_vec\n   (M.sumlist (map (\\<lambda>ja. ?f3 ja \\<cdot>\\<^sub>v gso ja) [0..<i])) =\n  n\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n    - M.sumlist\n       (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "by (intro eq_vecI, auto simp: sumlist_nth sum_negf)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n  - M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "also"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n  - M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "have \"fs ! i + (-?sum) + ?sum = fs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i +\n    - M.sumlist\n       (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) +\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n    fs ! i", "using sum_carrier fs_carrier f"], ["proof (prove)\nusing this:\n  M.sumlist (map (\\<lambda>ja. ?f3 ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n  \\<in> carrier_vec n\n  dim_vec\n   (M.sumlist (map (\\<lambda>ja. ?f3 ja \\<cdot>\\<^sub>v gso ja) [0..<i])) =\n  n\n  set fs \\<subseteq> carrier_vec n\n  fs ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. fs ! i +\n    - M.sumlist\n       (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) +\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n    fs ! i", "by simp"], ["proof (state)\nthis:\n  fs ! i +\n  - M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n  fs ! i\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "finally"], ["proof (chain)\npicking this:\n  gso i +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n  fs ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  gso i +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) =\n  fs ! i\n\ngoal (1 subgoal):\n 1. fs ! i =\n    gso i +\n    M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])", "by auto"], ["proof (state)\nthis:\n  fs ! i =\n  gso i +\n  M.sumlist (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma main_connect:\n  assumes \"m \\<le> n\"\n  shows \"gram_schmidt n fs = map gso [0..<m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt n fs = map gso [0..<length fs]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gram_schmidt n fs = map gso [0..<length fs]", "obtain vs where snd_main: \"snd (main fs) = vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        snd (main fs) = vs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd (main fs) = vs\n\ngoal (1 subgoal):\n 1. gram_schmidt n fs = map gso [0..<length fs]", "have \"gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and> snd (sub2_wit [] fs) = map gso [0..<length fs]\n        \\<and> wits = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]\" \n    if \"wits = fst (sub2_wit [] fs)\" for wits"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and>\n    snd (sub2_wit [] fs) = map gso [0..<length fs] \\<and>\n    wits = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]", "using assms that fs_carrier"], ["proof (prove)\nusing this:\n  length fs \\<le> n\n  wits = fst (sub2_wit [] fs)\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and>\n    snd (sub2_wit [] fs) = map gso [0..<length fs] \\<and>\n    wits = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]", "by (intro  sub2_wit) (auto simp add: map_nth)"], ["proof (state)\nthis:\n  ?wits1 = fst (sub2_wit [] fs) \\<Longrightarrow>\n  gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and>\n  snd (sub2_wit [] fs) = map gso [0..<length fs] \\<and>\n  ?wits1 = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]\n\ngoal (1 subgoal):\n 1. gram_schmidt n fs = map gso [0..<length fs]", "then"], ["proof (chain)\npicking this:\n  ?wits1 = fst (sub2_wit [] fs) \\<Longrightarrow>\n  gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and>\n  snd (sub2_wit [] fs) = map gso [0..<length fs] \\<and>\n  ?wits1 = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]", "have \"gram_schmidt_sub2 n [] fs = vs \\<and> vs = map gso [0..<m]\""], ["proof (prove)\nusing this:\n  ?wits1 = fst (sub2_wit [] fs) \\<Longrightarrow>\n  gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and>\n  snd (sub2_wit [] fs) = map gso [0..<length fs] \\<and>\n  ?wits1 = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]\n\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n [] fs = vs \\<and> vs = map gso [0..<length fs]", "using snd_main main_def"], ["proof (prove)\nusing this:\n  ?wits1 = fst (sub2_wit [] fs) \\<Longrightarrow>\n  gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and>\n  snd (sub2_wit [] fs) = map gso [0..<length fs] \\<and>\n  ?wits1 = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]\n  snd (main fs) = vs\n  main ?us = sub2_wit [] ?us\n\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n [] fs = vs \\<and> vs = map gso [0..<length fs]", "by auto"], ["proof (state)\nthis:\n  gram_schmidt_sub2 n [] fs = vs \\<and> vs = map gso [0..<length fs]\n\ngoal (1 subgoal):\n 1. gram_schmidt n fs = map gso [0..<length fs]", "thus \"gram_schmidt n fs = map gso [0..<m]\""], ["proof (prove)\nusing this:\n  gram_schmidt_sub2 n [] fs = vs \\<and> vs = map gso [0..<length fs]\n\ngoal (1 subgoal):\n 1. gram_schmidt n fs = map gso [0..<length fs]", "by (auto simp: gram_schmidt_code)"], ["proof (state)\nthis:\n  gram_schmidt n fs = map gso [0..<length fs]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduced_gso_E: \"weakly_reduced \\<alpha> k \\<Longrightarrow> k \\<le> m \\<Longrightarrow> Suc i < k \\<Longrightarrow> \n  sq_norm (gso i) \\<le> \\<alpha> * sq_norm (gso (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>weakly_reduced \\<alpha> k; k \\<le> length fs;\n     Suc i < k\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>gso i\\<parallel>\\<^sup>2\n                      \\<le> \\<alpha> *\n                            \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "unfolding weakly_reduced_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                Suc i < k \\<longrightarrow>\n                \\<parallel>gso i\\<parallel>\\<^sup>2\n                \\<le> \\<alpha> * \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2;\n     k \\<le> length fs; Suc i < k\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>gso i\\<parallel>\\<^sup>2\n                      \\<le> \\<alpha> *\n                            \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "by auto"], ["", "abbreviation (input) FF where \"FF \\<equiv> mat_of_rows n fs\""], ["", "abbreviation (input) Fs where \"Fs \\<equiv> mat_of_rows n (map gso [0..<m])\""], ["", "lemma FF_dim[simp]: \"dim_row FF = m\" \"dim_col FF = n\" \"FF \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat_of_rows n fs) = length fs &&&\n    dim_col (mat_of_rows n fs) = n &&&\n    mat_of_rows n fs \\<in> carrier_mat (length fs) n", "unfolding mat_of_rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat (length fs) n (\\<lambda>(i, y). fs ! i $ y)) =\n    length fs &&&\n    dim_col (mat (length fs) n (\\<lambda>(i, y). fs ! i $ y)) = n &&&\n    mat (length fs) n (\\<lambda>(i, y). fs ! i $ y)\n    \\<in> carrier_mat (length fs) n", "by (auto)"], ["", "lemma Fs_dim[simp]: \"dim_row Fs = m\" \"dim_col Fs = n\" \"Fs \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat_of_rows n (map gso [0..<length fs])) = length fs &&&\n    dim_col (mat_of_rows n (map gso [0..<length fs])) = n &&&\n    mat_of_rows n (map gso [0..<length fs]) \\<in> carrier_mat (length fs) n", "unfolding mat_of_rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (length (map gso [0..<length fs])) n\n       (\\<lambda>(i, y). map gso [0..<length fs] ! i $ y)) =\n    length fs &&&\n    dim_col\n     (mat (length (map gso [0..<length fs])) n\n       (\\<lambda>(i, y). map gso [0..<length fs] ! i $ y)) =\n    n &&&\n    mat (length (map gso [0..<length fs])) n\n     (\\<lambda>(i, y). map gso [0..<length fs] ! i $ y)\n    \\<in> carrier_mat (length fs) n", "by (auto simp: main_connect)"], ["", "lemma M_dim[simp]: \"dim_row (M m) = m\" \"dim_col (M m) = m\" \"(M m) \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (M (length fs)) = length fs &&&\n    dim_col (M (length fs)) = length fs &&&\n    M (length fs) \\<in> carrier_mat (length fs) (length fs)", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat (length fs) (length fs) (\\<lambda>(x, y). \\<mu> x y)) =\n    length fs &&&\n    dim_col (mat (length fs) (length fs) (\\<lambda>(x, y). \\<mu> x y)) =\n    length fs &&&\n    mat (length fs) (length fs) (\\<lambda>(x, y). \\<mu> x y)\n    \\<in> carrier_mat (length fs) (length fs)", "by auto"], ["", "lemma FF_index[simp]: \"i < m \\<Longrightarrow> j < n \\<Longrightarrow> FF $$ (i,j) = fs ! i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length fs; j < n\\<rbrakk>\n    \\<Longrightarrow> mat_of_rows n fs $$ (i, j) = fs ! i $ j", "unfolding mat_of_rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length fs; j < n\\<rbrakk>\n    \\<Longrightarrow> mat (length fs) n (\\<lambda>(i, y). fs ! i $ y) $$\n                      (i, j) =\n                      fs ! i $ j", "by auto"], ["", "lemma M_index[simp]:\"i < m \\<Longrightarrow> j < m \\<Longrightarrow> (M m) $$ (i,j) = \\<mu> i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n    \\<Longrightarrow> M (length fs) $$ (i, j) = \\<mu> i j", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length fs; j < length fs\\<rbrakk>\n    \\<Longrightarrow> mat (length fs) (length fs)\n                       (\\<lambda>(x, y). \\<mu> x y) $$\n                      (i, j) =\n                      \\<mu> i j", "by auto"], ["", "(* equation 2 on page 463 of textbook *)"], ["", "lemma matrix_equality: \"FF = (M m) * Fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n fs =\n    M (length fs) * mat_of_rows n (map gso [0..<length fs])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_rows n fs =\n    M (length fs) * mat_of_rows n (map gso [0..<length fs])", "let ?P = \"(M m) * Fs\""], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_rows n fs =\n    M (length fs) * mat_of_rows n (map gso [0..<length fs])", "have dim: \"dim_row FF = m\" \"dim_col FF = n\" \"dim_row ?P = m\" \"dim_col ?P = n\" \"dim_row (M m) = m\" \"dim_col (M m) = m\" \n      \"dim_row Fs = m\" \"dim_col Fs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((dim_row (mat_of_rows n fs) = length fs &&&\n      dim_col (mat_of_rows n fs) = n) &&&\n     dim_row (M (length fs) * mat_of_rows n (map gso [0..<length fs])) =\n     length fs &&&\n     dim_col (M (length fs) * mat_of_rows n (map gso [0..<length fs])) =\n     n) &&&\n    (dim_row (M (length fs)) = length fs &&&\n     dim_col (M (length fs)) = length fs) &&&\n    dim_row (mat_of_rows n (map gso [0..<length fs])) = length fs &&&\n    dim_col (mat_of_rows n (map gso [0..<length fs])) = n", "by (auto simp: mat_of_rows_def mat_of_rows_list_def main_connect)"], ["proof (state)\nthis:\n  dim_row (mat_of_rows n fs) = length fs\n  dim_col (mat_of_rows n fs) = n\n  dim_row (M (length fs) * mat_of_rows n (map gso [0..<length fs])) =\n  length fs\n  dim_col (M (length fs) * mat_of_rows n (map gso [0..<length fs])) = n\n  dim_row (M (length fs)) = length fs\n  dim_col (M (length fs)) = length fs\n  dim_row (mat_of_rows n (map gso [0..<length fs])) = length fs\n  dim_col (mat_of_rows n (map gso [0..<length fs])) = n\n\ngoal (1 subgoal):\n 1. mat_of_rows n fs =\n    M (length fs) * mat_of_rows n (map gso [0..<length fs])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n fs =\n    M (length fs) * mat_of_rows n (map gso [0..<length fs])", "proof (rule eq_matI; unfold dim)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "assume i: \"i < m\" and j: \"j < n\""], ["proof (state)\nthis:\n  i < length fs\n  j < n\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "from i"], ["proof (chain)\npicking this:\n  i < length fs", "have split: \"[0 ..< m] = [0 ..< i] @ [i] @ [Suc i ..< m]\""], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. [0..<length fs] = [0..<i] @ [i] @ [Suc i..<length fs]", "by (metis append_Cons append_self_conv2 less_Suc_eq_le less_imp_add_positive upt_add_eq_append upt_rec zero_less_Suc)"], ["proof (state)\nthis:\n  [0..<length fs] = [0..<i] @ [i] @ [Suc i..<length fs]\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "let ?prod = \"\\<lambda> k. \\<mu> i k * gso k $ j\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have dim2: \"dim_vec (col Fs j) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (col (mat_of_rows n (map gso [0..<length fs])) j) = length fs", "using j dim"], ["proof (prove)\nusing this:\n  j < n\n  dim_row (mat_of_rows n fs) = length fs\n  dim_col (mat_of_rows n fs) = n\n  dim_row (M (length fs) * mat_of_rows n (map gso [0..<length fs])) =\n  length fs\n  dim_col (M (length fs) * mat_of_rows n (map gso [0..<length fs])) = n\n  dim_row (M (length fs)) = length fs\n  dim_col (M (length fs)) = length fs\n  dim_row (mat_of_rows n (map gso [0..<length fs])) = length fs\n  dim_col (mat_of_rows n (map gso [0..<length fs])) = n\n\ngoal (1 subgoal):\n 1. dim_vec (col (mat_of_rows n (map gso [0..<length fs])) j) = length fs", "by auto"], ["proof (state)\nthis:\n  dim_vec (col (mat_of_rows n (map gso [0..<length fs])) j) = length fs\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "define idx where \"idx = [0..<i]\""], ["proof (state)\nthis:\n  idx = [0..<i]\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have idx: \"set idx \\<subseteq> {0 ..< i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set idx \\<subseteq> {0..<i}", "unfolding idx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [0..<i] \\<subseteq> {0..<i}", "using i"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. set [0..<i] \\<subseteq> {0..<i}", "by auto"], ["proof (state)\nthis:\n  set idx \\<subseteq> {0..<i}\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "let ?vec = \"sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) idx)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have vec: \"?vec \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) idx)\n    \\<in> carrier_vec n", "by (rule sumlist_carrier, insert idx gso_carrier i, auto)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) idx)\n  \\<in> carrier_vec n\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "hence dimv: \"dim_vec ?vec = n\""], ["proof (prove)\nusing this:\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) idx)\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec\n     (M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) idx)) =\n    n", "by auto"], ["proof (state)\nthis:\n  dim_vec\n   (M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) idx)) =\n  n\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have \"?P $$ (i,j) = row (M m) i \\<bullet> col Fs j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n    row (M (length fs)) i \\<bullet>\n    col (mat_of_rows n (map gso [0..<length fs])) j", "using dim i j"], ["proof (prove)\nusing this:\n  dim_row (mat_of_rows n fs) = length fs\n  dim_col (mat_of_rows n fs) = n\n  dim_row (M (length fs) * mat_of_rows n (map gso [0..<length fs])) =\n  length fs\n  dim_col (M (length fs) * mat_of_rows n (map gso [0..<length fs])) = n\n  dim_row (M (length fs)) = length fs\n  dim_col (M (length fs)) = length fs\n  dim_row (mat_of_rows n (map gso [0..<length fs])) = length fs\n  dim_col (mat_of_rows n (map gso [0..<length fs])) = n\n  i < length fs\n  j < n\n\ngoal (1 subgoal):\n 1. (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n    row (M (length fs)) i \\<bullet>\n    col (mat_of_rows n (map gso [0..<length fs])) j", "by auto"], ["proof (state)\nthis:\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n  row (M (length fs)) i \\<bullet>\n  col (mat_of_rows n (map gso [0..<length fs])) j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "also"], ["proof (state)\nthis:\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n  row (M (length fs)) i \\<bullet>\n  col (mat_of_rows n (map gso [0..<length fs])) j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have \"\\<dots> = (\\<Sum> k = 0..<m. row (M m) i $ k * col Fs j $ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (M (length fs)) i \\<bullet>\n    col (mat_of_rows n (map gso [0..<length fs])) j =\n    (\\<Sum>k = 0..<length fs.\n        row (M (length fs)) i $ k *\n        col (mat_of_rows n (map gso [0..<length fs])) j $ k)", "unfolding scalar_prod_def dim2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<length fs.\n        row (M (length fs)) i $ ia *\n        col (mat_of_rows n (map gso [0..<length fs])) j $ ia) =\n    (\\<Sum>k = 0..<length fs.\n        row (M (length fs)) i $ k *\n        col (mat_of_rows n (map gso [0..<length fs])) j $ k)", "by auto"], ["proof (state)\nthis:\n  row (M (length fs)) i \\<bullet>\n  col (mat_of_rows n (map gso [0..<length fs])) j =\n  (\\<Sum>k = 0..<length fs.\n      row (M (length fs)) i $ k *\n      col (mat_of_rows n (map gso [0..<length fs])) j $ k)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "also"], ["proof (state)\nthis:\n  row (M (length fs)) i \\<bullet>\n  col (mat_of_rows n (map gso [0..<length fs])) j =\n  (\\<Sum>k = 0..<length fs.\n      row (M (length fs)) i $ k *\n      col (mat_of_rows n (map gso [0..<length fs])) j $ k)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have \"\\<dots> = (\\<Sum> k = 0..<m. ?prod k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<length fs.\n        row (M (length fs)) i $ k *\n        col (mat_of_rows n (map gso [0..<length fs])) j $ k) =\n    (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j)", "by (rule sum.cong[OF refl], insert i j dim, auto simp: mat_of_rows_list_def mat_of_rows_def)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length fs.\n      row (M (length fs)) i $ k *\n      col (mat_of_rows n (map gso [0..<length fs])) j $ k) =\n  (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length fs.\n      row (M (length fs)) i $ k *\n      col (mat_of_rows n (map gso [0..<length fs])) j $ k) =\n  (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have \"\\<dots> = sum_list (map ?prod [0 ..< m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j) =\n    (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j)", "by (subst sum_list_distinct_conv_sum_set, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j) =\n  (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j) =\n  (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have \"\\<dots> = sum_list (map ?prod idx) + ?prod i + sum_list (map ?prod [Suc i ..< m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j) =\n    (\\<Sum>k\\<leftarrow>idx. \\<mu> i k * gso k $ j) +\n    \\<mu> i i * gso i $ j +\n    (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j)", "unfolding split idx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<leftarrow>[0..<i] @\n                        [i] @ [Suc i..<length fs]. \\<mu> i k * gso k $ j) =\n    (\\<Sum>k\\<leftarrow>[0..<i]. \\<mu> i k * gso k $ j) +\n    \\<mu> i i * gso i $ j +\n    (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j) =\n  (\\<Sum>k\\<leftarrow>idx. \\<mu> i k * gso k $ j) + \\<mu> i i * gso i $ j +\n  (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j) =\n  (\\<Sum>k\\<leftarrow>idx. \\<mu> i k * gso k $ j) + \\<mu> i i * gso i $ j +\n  (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have \"?prod i = gso i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> i i * gso i $ j = gso i $ j", "unfolding \\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < i\n     then fs ! i \\<bullet> gso i / \\<parallel>gso i\\<parallel>\\<^sup>2\n     else if i = i then 1::'a else (0::'a)) *\n    gso i $ j =\n    gso i $ j", "by simp"], ["proof (state)\nthis:\n  \\<mu> i i * gso i $ j = gso i $ j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "also"], ["proof (state)\nthis:\n  \\<mu> i i * gso i $ j = gso i $ j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have \"\\<dots> = fs ! i $ j + sum_list (map (\\<lambda>k. - \\<mu> i k * gso k $ j) idx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i $ j =\n    fs ! i $ j + (\\<Sum>k\\<leftarrow>idx. - \\<mu> i k * gso k $ j)", "unfolding gso.simps[of i] idx_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) idx)) $\n    j =\n    fs ! i $ j + (\\<Sum>k\\<leftarrow>idx. - \\<mu> i k * gso k $ j)", "by (subst index_add_vec, unfold dimv, rule j, subst sumlist_vec_index[OF _ j], insert idx gso_carrier i j, \n      auto simp: o_def intro!: arg_cong[OF map_cong])"], ["proof (state)\nthis:\n  gso i $ j = fs ! i $ j + (\\<Sum>k\\<leftarrow>idx. - \\<mu> i k * gso k $ j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "also"], ["proof (state)\nthis:\n  gso i $ j = fs ! i $ j + (\\<Sum>k\\<leftarrow>idx. - \\<mu> i k * gso k $ j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have \"sum_list (map (\\<lambda>k. - \\<mu> i k * gso k $ j) idx) = - sum_list (map (\\<lambda>k. \\<mu> i k * gso k $ j) idx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<leftarrow>idx. - \\<mu> i k * gso k $ j) =\n    - (\\<Sum>k\\<leftarrow>idx. \\<mu> i k * gso k $ j)", "by (induct idx, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>idx. - \\<mu> i k * gso k $ j) =\n  - (\\<Sum>k\\<leftarrow>idx. \\<mu> i k * gso k $ j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>idx. - \\<mu> i k * gso k $ j) =\n  - (\\<Sum>k\\<leftarrow>idx. \\<mu> i k * gso k $ j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "have \"sum_list (map ?prod [Suc i ..< m]) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j) =\n    (0::'a)", "by (rule sum_list_neutral, auto simp: \\<mu>.simps)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "finally"], ["proof (chain)\npicking this:\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n  (\\<Sum>k\\<leftarrow>idx. \\<mu> i k * gso k $ j) +\n  (fs ! i $ j + - (\\<Sum>k\\<leftarrow>idx. \\<mu> i k * gso k $ j)) +\n  (0::'a)", "have \"?P $$ (i,j) = fs ! i $ j\""], ["proof (prove)\nusing this:\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n  (\\<Sum>k\\<leftarrow>idx. \\<mu> i k * gso k $ j) +\n  (fs ! i $ j + - (\\<Sum>k\\<leftarrow>idx. \\<mu> i k * gso k $ j)) +\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n    fs ! i $ j", "by simp"], ["proof (state)\nthis:\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n  fs ! i $ j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs; j < n\\<rbrakk>\n       \\<Longrightarrow> mat_of_rows n fs $$ (i, j) =\n                         (M (length fs) *\n                          mat_of_rows n (map gso [0..<length fs])) $$\n                         (i, j)\n 2. length fs = length fs\n 3. n = n", "with FF_index[OF i j]"], ["proof (chain)\npicking this:\n  mat_of_rows n fs $$ (i, j) = fs ! i $ j\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n  fs ! i $ j", "show \"FF $$ (i,j) = ?P $$ (i,j)\""], ["proof (prove)\nusing this:\n  mat_of_rows n fs $$ (i, j) = fs ! i $ j\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n  fs ! i $ j\n\ngoal (1 subgoal):\n 1. mat_of_rows n fs $$ (i, j) =\n    (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j)", "by simp"], ["proof (state)\nthis:\n  mat_of_rows n fs $$ (i, j) =\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j)\n\ngoal (2 subgoals):\n 1. length fs = length fs\n 2. n = n", "qed auto"], ["proof (state)\nthis:\n  mat_of_rows n fs = M (length fs) * mat_of_rows n (map gso [0..<length fs])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fi_is_sum_of_mu_gso: assumes i: \"i < m\" \n  shows \"fs ! i = sumlist (map (\\<lambda> j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0 ..< Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])", "let ?l = \"sumlist (map (\\<lambda> j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0 ..< Suc i])\""], ["proof (state)\ngoal (1 subgoal):\n 1. fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])", "have \"?l \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])\n    \\<in> carrier_vec n", "by (rule sumlist_carrier, insert gso_carrier i, auto)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])", "hence dim: \"dim_vec ?l = n\""], ["proof (prove)\nusing this:\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec\n     (M.sumlist\n       (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])) =\n    n", "by (rule carrier_vecD)"], ["proof (state)\nthis:\n  dim_vec\n   (M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])) =\n  n\n\ngoal (1 subgoal):\n 1. fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])", "proof (rule eq_vecI, unfold dim f_dim[OF i])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "assume j: \"j < n\""], ["proof (state)\nthis:\n  j < n\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "from i"], ["proof (chain)\npicking this:\n  i < length fs", "have split: \"[0 ..< m] = [0 ..< Suc i] @ [Suc i ..< m]\""], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. [0..<length fs] = [0..<Suc i] @ [Suc i..<length fs]", "by (metis Suc_lessI append.assoc append_same_eq less_imp_add_positive order_refl upt_add_eq_append zero_le)"], ["proof (state)\nthis:\n  [0..<length fs] = [0..<Suc i] @ [Suc i..<length fs]\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "let ?prod = \"\\<lambda> k. \\<mu> i k * gso k $ j\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "have \"fs ! i $ j = FF $$ (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i $ j = mat_of_rows n fs $$ (i, j)", "using i j"], ["proof (prove)\nusing this:\n  i < length fs\n  j < n\n\ngoal (1 subgoal):\n 1. fs ! i $ j = mat_of_rows n fs $$ (i, j)", "by simp"], ["proof (state)\nthis:\n  fs ! i $ j = mat_of_rows n fs $$ (i, j)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "also"], ["proof (state)\nthis:\n  fs ! i $ j = mat_of_rows n fs $$ (i, j)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "have \"\\<dots> = ((M m) * Fs) $$ (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n fs $$ (i, j) =\n    (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j)", "using matrix_equality"], ["proof (prove)\nusing this:\n  mat_of_rows n fs = M (length fs) * mat_of_rows n (map gso [0..<length fs])\n\ngoal (1 subgoal):\n 1. mat_of_rows n fs $$ (i, j) =\n    (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j)", "by simp"], ["proof (state)\nthis:\n  mat_of_rows n fs $$ (i, j) =\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "also"], ["proof (state)\nthis:\n  mat_of_rows n fs $$ (i, j) =\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "have \"\\<dots> = row (M m) i \\<bullet> col Fs j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n    row (M (length fs)) i \\<bullet>\n    col (mat_of_rows n (map gso [0..<length fs])) j", "using i j"], ["proof (prove)\nusing this:\n  i < length fs\n  j < n\n\ngoal (1 subgoal):\n 1. (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n    row (M (length fs)) i \\<bullet>\n    col (mat_of_rows n (map gso [0..<length fs])) j", "by auto"], ["proof (state)\nthis:\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n  row (M (length fs)) i \\<bullet>\n  col (mat_of_rows n (map gso [0..<length fs])) j\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "also"], ["proof (state)\nthis:\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n  row (M (length fs)) i \\<bullet>\n  col (mat_of_rows n (map gso [0..<length fs])) j\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "have \"\\<dots> = (\\<Sum> k = 0..<m. row (M m) i $ k * col Fs j $ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (M (length fs)) i \\<bullet>\n    col (mat_of_rows n (map gso [0..<length fs])) j =\n    (\\<Sum>k = 0..<length fs.\n        row (M (length fs)) i $ k *\n        col (mat_of_rows n (map gso [0..<length fs])) j $ k)", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec\n                     (col (mat_of_rows n (map gso [0..<length fs])) j).\n        row (M (length fs)) i $ ia *\n        col (mat_of_rows n (map gso [0..<length fs])) j $ ia) =\n    (\\<Sum>k = 0..<length fs.\n        row (M (length fs)) i $ k *\n        col (mat_of_rows n (map gso [0..<length fs])) j $ k)", "by auto"], ["proof (state)\nthis:\n  row (M (length fs)) i \\<bullet>\n  col (mat_of_rows n (map gso [0..<length fs])) j =\n  (\\<Sum>k = 0..<length fs.\n      row (M (length fs)) i $ k *\n      col (mat_of_rows n (map gso [0..<length fs])) j $ k)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "also"], ["proof (state)\nthis:\n  row (M (length fs)) i \\<bullet>\n  col (mat_of_rows n (map gso [0..<length fs])) j =\n  (\\<Sum>k = 0..<length fs.\n      row (M (length fs)) i $ k *\n      col (mat_of_rows n (map gso [0..<length fs])) j $ k)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "have \"\\<dots> = (\\<Sum> k = 0..<m. ?prod k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<length fs.\n        row (M (length fs)) i $ k *\n        col (mat_of_rows n (map gso [0..<length fs])) j $ k) =\n    (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j)", "by (rule sum.cong[OF refl], insert i j dim, auto simp: mat_of_rows_list_def mat_of_rows_def)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length fs.\n      row (M (length fs)) i $ k *\n      col (mat_of_rows n (map gso [0..<length fs])) j $ k) =\n  (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length fs.\n      row (M (length fs)) i $ k *\n      col (mat_of_rows n (map gso [0..<length fs])) j $ k) =\n  (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "have \"\\<dots> = sum_list (map ?prod [0 ..< m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j) =\n    (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j)", "by (subst sum_list_distinct_conv_sum_set, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j) =\n  (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<length fs. \\<mu> i k * gso k $ j) =\n  (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "have \"\\<dots> = sum_list (map ?prod [0 ..< Suc i]) + sum_list (map ?prod [Suc i ..< m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j) =\n    (\\<Sum>k\\<leftarrow>[0..<Suc i]. \\<mu> i k * gso k $ j) +\n    (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j)", "unfolding split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<leftarrow>[0..<Suc i] @\n                        [Suc i..<length fs]. \\<mu> i k * gso k $ j) =\n    (\\<Sum>k\\<leftarrow>[0..<Suc i]. \\<mu> i k * gso k $ j) +\n    (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j) =\n  (\\<Sum>k\\<leftarrow>[0..<Suc i]. \\<mu> i k * gso k $ j) +\n  (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>[0..<length fs]. \\<mu> i k * gso k $ j) =\n  (\\<Sum>k\\<leftarrow>[0..<Suc i]. \\<mu> i k * gso k $ j) +\n  (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "have \"sum_list (map ?prod [Suc i ..< m]) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j) =\n    (0::'a)", "by (rule sum_list_neutral, auto simp: \\<mu>.simps)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>[Suc i..<length fs]. \\<mu> i k * gso k $ j) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "have \"sum_list (map ?prod [0 ..< Suc i]) = ?l $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<leftarrow>[0..<Suc i]. \\<mu> i k * gso k $ j) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n    j", "by (subst sumlist_vec_index[OF _ j], (insert i, auto simp: intro!: gso_carrier)[1], \n        rule arg_cong[of _ _ sum_list], insert i j, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<leftarrow>[0..<Suc i]. \\<mu> i k * gso k $ j) =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n  j\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < n \\<Longrightarrow>\n       fs ! i $ ia =\n       M.sumlist\n        (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n       ia\n 2. n = n", "finally"], ["proof (chain)\npicking this:\n  fs ! i $ j =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n  j +\n  (0::'a)", "show \"fs ! i $ j = ?l $ j\""], ["proof (prove)\nusing this:\n  fs ! i $ j =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n  j +\n  (0::'a)\n\ngoal (1 subgoal):\n 1. fs ! i $ j =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n    j", "by simp"], ["proof (state)\nthis:\n  fs ! i $ j =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) $\n  j\n\ngoal (1 subgoal):\n 1. n = n", "qed simp"], ["proof (state)\nthis:\n  fs ! i =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gi_is_fi_minus_sum_mu_gso:\n  assumes i: \"i < m\" \n  shows \"gso i = fs ! i - sumlist (map (\\<lambda> j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0 ..< i])\" (is \"_ = _ - ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i =\n    fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gso i =\n    fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "have sum: \"?sum \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n    \\<in> carrier_vec n", "by (rule sumlist_carrier, insert gso_carrier i, auto)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. gso i =\n    fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i =\n    fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "unfolding fs_by_gso_def[OF i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i =\n    gso i +\n    M.sumlist\n     (map (\\<lambda>ja. \\<mu> i ja \\<cdot>\\<^sub>v gso ja) [0..<i]) -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "by (intro eq_vecI, insert gso_carrier[OF i] sum, auto)"], ["proof (state)\nthis:\n  gso i =\n  fs ! i -\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Theorem 16.5 (iv) *)"], ["", "lemma det: assumes m: \"m = n\" shows \"det FF = det Fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n fs) = det (mat_of_rows n (map gso [0..<length fs]))", "unfolding matrix_equality"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (M (length fs) * mat_of_rows n (map gso [0..<length fs])) =\n    det (mat_of_rows n (map gso [0..<length fs]))", "apply (subst det_mult[OF M_dim(3)], (insert Fs_dim(3) m, auto)[1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (M (length fs)) * det (mat_of_rows n (map gso [0..<length fs])) =\n    det (mat_of_rows n (map gso [0..<length fs]))", "apply (subst det_lower_triangular[OF _ M_dim(3)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length fs\\<rbrakk>\n       \\<Longrightarrow> M (length fs) $$ (i, j) = (0::'a)\n 2. prod_list (diag_mat (M (length fs))) *\n    det (mat_of_rows n (map gso [0..<length fs])) =\n    det (mat_of_rows n (map gso [0..<length fs]))", "by (subst M_index, (auto simp: \\<mu>.simps)[3], unfold prod_list_diag_prod, auto simp: \\<mu>.simps)"], ["", "end"], ["", "locale gram_schmidt_fs_lin_indpt = gram_schmidt_fs_Rn +\n  assumes lin_indpt: \"lin_indpt (set fs)\" and dist: \"distinct fs\"\nbegin"], ["", "lemmas loc_assms = lin_indpt dist"], ["", "lemma mn:\n  shows \"m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length fs \\<le> n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length fs \\<le> n", "have n: \"n = dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = local.dim", "by (simp add: dim_is_n)"], ["proof (state)\nthis:\n  n = local.dim\n\ngoal (1 subgoal):\n 1. length fs \\<le> n", "have m: \"m = card (set fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length fs = card (set fs)", "using distinct_card loc_assms"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  lin_indpt (set fs)\n  distinct fs\n\ngoal (1 subgoal):\n 1. length fs = card (set fs)", "by metis"], ["proof (state)\nthis:\n  length fs = card (set fs)\n\ngoal (1 subgoal):\n 1. length fs \\<le> n", "from m n"], ["proof (chain)\npicking this:\n  length fs = card (set fs)\n  n = local.dim", "have mn: \"m \\<le> n \\<longleftrightarrow> card (set fs) \\<le> dim\""], ["proof (prove)\nusing this:\n  length fs = card (set fs)\n  n = local.dim\n\ngoal (1 subgoal):\n 1. (length fs \\<le> n) = (card (set fs) \\<le> local.dim)", "by simp"], ["proof (state)\nthis:\n  (length fs \\<le> n) = (card (set fs) \\<le> local.dim)\n\ngoal (1 subgoal):\n 1. length fs \\<le> n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length fs \\<le> n", "unfolding mn"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set fs) \\<le> local.dim", "by (rule li_le_dim, use loc_assms fs_carrier in auto)"], ["proof (state)\nthis:\n  length fs \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\nshows span_gso: \"span (gso ` {0..<m}) = span (set fs)\"\n  and orthogonal_gso: \"orthogonal (map gso [0..<m])\" \n  and dist_gso: \"distinct (map gso [0..<m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<length fs}) = local.span (set fs) &&&\n    orthogonal (map gso [0..<length fs]) &&&\n    distinct (map gso [0..<length fs])", "using gram_schmidt_result[OF fs_carrier _ _ main_connect[symmetric]] loc_assms mn"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct fs; lin_indpt (set fs); length fs \\<le> n\\<rbrakk>\n  \\<Longrightarrow> local.span (set fs) =\n                    local.span (set (map gso [0..<length fs]))\n  \\<lbrakk>distinct fs; lin_indpt (set fs); length fs \\<le> n\\<rbrakk>\n  \\<Longrightarrow> corthogonal (map gso [0..<length fs])\n  \\<lbrakk>distinct fs; lin_indpt (set fs); length fs \\<le> n\\<rbrakk>\n  \\<Longrightarrow> set (map gso [0..<length fs]) \\<subseteq> carrier_vec n\n  \\<lbrakk>distinct fs; lin_indpt (set fs); length fs \\<le> n\\<rbrakk>\n  \\<Longrightarrow> length (map gso [0..<length fs]) = length fs\n  \\<lbrakk>distinct fs; lin_indpt (set fs); length fs \\<le> n\\<rbrakk>\n  \\<Longrightarrow> distinct (map gso [0..<length fs])\n  lin_indpt (set fs)\n  distinct fs\n  length fs \\<le> n\n\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<length fs}) = local.span (set fs) &&&\n    orthogonal (map gso [0..<length fs]) &&&\n    distinct (map gso [0..<length fs])", "by auto"], ["", "lemma gso_inj[intro]:\n  assumes \"i < m\"\n  shows \"inj_on gso {0..<i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on gso {0..<i}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on gso {0..<i}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on gso {0..<i}", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on gso {0..<i}", "assume assms': \"i < m\" \"x \\<in> {0..<i}\" \"y \\<in> {0..<i}\" \"gso x = gso y\""], ["proof (state)\nthis:\n  i < length fs\n  x \\<in> {0..<i}\n  y \\<in> {0..<i}\n  gso x = gso y\n\ngoal (1 subgoal):\n 1. inj_on gso {0..<i}", "have \"distinct (map gso [0..<m])\" \"x < length (map gso [0..<m])\" \"y < length (map gso [0..<m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map gso [0..<length fs]) &&&\n    x < length (map gso [0..<length fs]) &&&\n    y < length (map gso [0..<length fs])", "using dist_gso assms mn assms'"], ["proof (prove)\nusing this:\n  distinct (map gso [0..<length fs])\n  i < length fs\n  length fs \\<le> n\n  i < length fs\n  x \\<in> {0..<i}\n  y \\<in> {0..<i}\n  gso x = gso y\n\ngoal (1 subgoal):\n 1. distinct (map gso [0..<length fs]) &&&\n    x < length (map gso [0..<length fs]) &&&\n    y < length (map gso [0..<length fs])", "by (auto intro!: dist_gso)"], ["proof (state)\nthis:\n  distinct (map gso [0..<length fs])\n  x < length (map gso [0..<length fs])\n  y < length (map gso [0..<length fs])\n\ngoal (1 subgoal):\n 1. inj_on gso {0..<i}", "from nth_eq_iff_index_eq[OF this] assms'"], ["proof (chain)\npicking this:\n  (map gso [0..<length fs] ! x = map gso [0..<length fs] ! y) = (x = y)\n  i < length fs\n  x \\<in> {0..<i}\n  y \\<in> {0..<i}\n  gso x = gso y", "have \"x = y\""], ["proof (prove)\nusing this:\n  (map gso [0..<length fs] ! x = map gso [0..<length fs] ! y) = (x = y)\n  i < length fs\n  x \\<in> {0..<i}\n  y \\<in> {0..<i}\n  gso x = gso y\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. inj_on gso {0..<i}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i < length fs; ?x3 \\<in> {0..<i}; ?y3 \\<in> {0..<i};\n   gso ?x3 = gso ?y3\\<rbrakk>\n  \\<Longrightarrow> ?x3 = ?y3\n\ngoal (1 subgoal):\n 1. inj_on gso {0..<i}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < length fs; ?x3 \\<in> {0..<i}; ?y3 \\<in> {0..<i};\n   gso ?x3 = gso ?y3\\<rbrakk>\n  \\<Longrightarrow> ?x3 = ?y3", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length fs; ?x3 \\<in> {0..<i}; ?y3 \\<in> {0..<i};\n   gso ?x3 = gso ?y3\\<rbrakk>\n  \\<Longrightarrow> ?x3 = ?y3\n\ngoal (1 subgoal):\n 1. inj_on gso {0..<i}", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length fs; ?x3 \\<in> {0..<i}; ?y3 \\<in> {0..<i};\n   gso ?x3 = gso ?y3\\<rbrakk>\n  \\<Longrightarrow> ?x3 = ?y3\n  i < length fs\n\ngoal (1 subgoal):\n 1. inj_on gso {0..<i}", "by (intro inj_onI) auto"], ["proof (state)\nthis:\n  inj_on gso {0..<i}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partial_span:\n  assumes i: \"i \\<le> m\" \n  shows \"span (gso ` {0 ..< i}) = span (set (take i fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "let ?f = \"\\<lambda> i. fs ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "let ?us = \"take i fs\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "have len: \"length ?us = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take i fs) = i", "using i"], ["proof (prove)\nusing this:\n  i \\<le> length fs\n\ngoal (1 subgoal):\n 1. length (take i fs) = i", "by auto"], ["proof (state)\nthis:\n  length (take i fs) = i\n\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "from fs_carrier i"], ["proof (chain)\npicking this:\n  set fs \\<subseteq> carrier_vec n\n  i \\<le> length fs", "have us: \"set ?us \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  i \\<le> length fs\n\ngoal (1 subgoal):\n 1. set (take i fs) \\<subseteq> carrier_vec n", "by (meson set_take_subset subset_trans)"], ["proof (state)\nthis:\n  set (take i fs) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "obtain vi where main: \"snd (main ?us) = vi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vi.\n        snd (main (take i fs)) = vi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  snd (main (take i fs)) = vi\n\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "from dist"], ["proof (chain)\npicking this:\n  distinct fs", "have dist: \"distinct ?us\""], ["proof (prove)\nusing this:\n  distinct fs\n\ngoal (1 subgoal):\n 1. distinct (take i fs)", "by auto"], ["proof (state)\nthis:\n  distinct (take i fs)\n\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "from lin_indpt"], ["proof (chain)\npicking this:\n  lin_indpt (set fs)", "have indpt: \"lin_indpt (set ?us)\""], ["proof (prove)\nusing this:\n  lin_indpt (set fs)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (take i fs))", "using supset_ld_is_ld[of \"set ?us\", of \"set (?us @ drop i fs)\"]"], ["proof (prove)\nusing this:\n  lin_indpt (set fs)\n  \\<lbrakk>lin_dep (set (take i fs));\n   set (take i fs) \\<subseteq> set (take i fs @ drop i fs)\\<rbrakk>\n  \\<Longrightarrow> lin_dep (set (take i fs @ drop i fs))\n\ngoal (1 subgoal):\n 1. lin_indpt (set (take i fs))", "by (auto simp: set_take_subset)"], ["proof (state)\nthis:\n  lin_indpt (set (take i fs))\n\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "from partial_connect[OF _ i mn us main refl fs_carrier] assms"], ["proof (chain)\npicking this:\n  length fs = length fs \\<Longrightarrow> gram_schmidt n (take i fs) = vi\n  length fs = length fs \\<Longrightarrow> vi = map gso [0..<i]\n  i \\<le> length fs", "have gso: \"vi = gram_schmidt n ?us\" and vi: \"vi = map gso [0 ..< i]\""], ["proof (prove)\nusing this:\n  length fs = length fs \\<Longrightarrow> gram_schmidt n (take i fs) = vi\n  length fs = length fs \\<Longrightarrow> vi = map gso [0..<i]\n  i \\<le> length fs\n\ngoal (1 subgoal):\n 1. vi = gram_schmidt n (take i fs) &&& vi = map gso [0..<i]", "by auto"], ["proof (state)\nthis:\n  vi = gram_schmidt n (take i fs)\n  vi = map gso [0..<i]\n\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "from cof_vec_space.gram_schmidt_result(1)[OF us dist indpt gso, unfolded vi]"], ["proof (chain)\npicking this:\n  local.span (set (take i fs)) = local.span (set (map gso [0..<i]))", "show ?thesis"], ["proof (prove)\nusing this:\n  local.span (set (take i fs)) = local.span (set (map gso [0..<i]))\n\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "by auto"], ["proof (state)\nthis:\n  local.span (gso ` {0..<i}) = local.span (set (take i fs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partial_span': \n  assumes i: \"i \\<le> m\" \n  shows \"span (gso ` {0 ..< i}) = span ((\\<lambda> j. fs ! j) ` {0 ..< i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span ((!) fs ` {0..<i})", "unfolding partial_span[OF i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set (take i fs)) = local.span ((!) fs ` {0..<i})", "by (rule arg_cong[of _ _ span], subst nth_image, insert i loc_assms, auto)"], ["", "(* Theorem 16.5 (iii) *)"], ["", "lemma orthogonal:\n  assumes \"i < m\" \"j < m\" \"i \\<noteq> j\"\n  shows \"gso i \\<bullet> gso j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i \\<bullet> gso j = (0::'a)", "using assms mn orthogonal_gso[unfolded orthogonal_def]"], ["proof (prove)\nusing this:\n  i < length fs\n  j < length fs\n  i \\<noteq> j\n  length fs \\<le> n\n  \\<forall>i j.\n     i < length (map gso [0..<length fs]) \\<longrightarrow>\n     j < length (map gso [0..<length fs]) \\<longrightarrow>\n     (map gso [0..<length fs] ! i \\<bullet> map gso [0..<length fs] ! j =\n      (0::'a)) =\n     (i \\<noteq> j)\n\ngoal (1 subgoal):\n 1. gso i \\<bullet> gso j = (0::'a)", "by auto"], ["", "(* Theorem 16.5 (i) not in full general form *)"], ["", "lemma same_base:\n  shows \"span (set fs) = span (gso ` {0..<m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set fs) = local.span (gso ` {0..<length fs})", "using span_gso loc_assms"], ["proof (prove)\nusing this:\n  local.span (gso ` {0..<length fs}) = local.span (set fs)\n  lin_indpt (set fs)\n  distinct fs\n\ngoal (1 subgoal):\n 1. local.span (set fs) = local.span (gso ` {0..<length fs})", "by simp"], ["", "(* Theorem 16.5 (ii), second half *)"], ["", "lemma sq_norm_gso_le_f:\n  assumes i: \"i < m\"\n  shows \"sq_norm (gso i) \\<le> sq_norm (fs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have id: \"[0 ..< Suc i] = [0 ..< i] @ [i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc i] = [0..<i] @ [i]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc i] = [0..<i] @ [i]\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "let ?sum = \"sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have sum: \"?sum \\<in> carrier_vec n\" and gsoi: \"gso i \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n    \\<in> carrier_vec n &&&\n    gso i \\<in> carrier_vec n", "using i"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n    \\<in> carrier_vec n &&&\n    gso i \\<in> carrier_vec n", "by (auto intro!: sumlist_carrier gso_carrier)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  \\<in> carrier_vec n\n  gso i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "from fi_is_sum_of_mu_gso[OF i, unfolded id]"], ["proof (chain)\npicking this:\n  fs ! i =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) ([0..<i] @ [i]))", "have \"sq_norm (fs ! i) = sq_norm (sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i] @ [gso i]))\""], ["proof (prove)\nusing this:\n  fs ! i =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) ([0..<i] @ [i]))\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    \\<parallel>M.sumlist\n                (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i] @\n                 [gso i])\\<parallel>\\<^sup>2", "by (simp add: \\<mu>.simps)"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i] @\n               [gso i])\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i] @\n               [gso i])\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have \"\\<dots> = sq_norm (?sum + gso i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>M.sumlist\n                (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i] @\n                 [gso i])\\<parallel>\\<^sup>2 =\n    \\<parallel>M.sumlist\n                (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                  [0..<i]) +\n               gso i\\<parallel>\\<^sup>2", "by (subst sumlist_append, insert gso_carrier i, auto)"], ["proof (state)\nthis:\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i] @\n               [gso i])\\<parallel>\\<^sup>2 =\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n             gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i] @\n               [gso i])\\<parallel>\\<^sup>2 =\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n             gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have \"\\<dots> = (?sum + gso i) \\<bullet> (?sum + gso i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>M.sumlist\n                (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                  [0..<i]) +\n               gso i\\<parallel>\\<^sup>2 =\n    (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n     gso i) \\<bullet>\n    (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n     gso i)", "by (simp add: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n             gso i\\<parallel>\\<^sup>2 =\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i)\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n             gso i\\<parallel>\\<^sup>2 =\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i)\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have \"\\<dots> = ?sum \\<bullet> (?sum + gso i) + gso i \\<bullet> (?sum + gso i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n     gso i) \\<bullet>\n    (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n     gso i) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n     gso i) +\n    gso i \\<bullet>\n    (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n     gso i)", "by (rule add_scalar_prod_distrib[OF sum gsoi], insert sum gsoi, auto)"], ["proof (state)\nthis:\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) +\n  gso i \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i)\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) +\n  gso i \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i)\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have \"\\<dots> = (?sum \\<bullet> ?sum + ?sum \\<bullet> gso i) + (gso i \\<bullet> ?sum + gso i \\<bullet> gso i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n     gso i) +\n    gso i \\<bullet>\n    (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n     gso i) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    gso i +\n    (gso i \\<bullet>\n     M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n     gso i \\<bullet> gso i)", "by (subst (1 2) scalar_prod_add_distrib[of _ n], insert sum gsoi, auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) +\n  gso i \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i +\n  (gso i \\<bullet>\n   M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i \\<bullet> gso i)\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) +\n  gso i \\<bullet>\n  (M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i) =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i +\n  (gso i \\<bullet>\n   M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) +\n   gso i \\<bullet> gso i)\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have \"?sum \\<bullet> ?sum = sq_norm ?sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n    \\<parallel>M.sumlist\n                (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                  [0..<i])\\<parallel>\\<^sup>2", "by (simp add: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                [0..<i])\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                [0..<i])\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have \"gso i \\<bullet> gso i = sq_norm (gso i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i \\<bullet> gso i = \\<parallel>gso i\\<parallel>\\<^sup>2", "by (simp add: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  gso i \\<bullet> gso i = \\<parallel>gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  gso i \\<bullet> gso i = \\<parallel>gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have \"gso i \\<bullet> ?sum = ?sum \\<bullet> gso i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i \\<bullet>\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    gso i", "using gsoi sum"], ["proof (prove)\nusing this:\n  gso i \\<in> carrier_vec n\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. gso i \\<bullet>\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    gso i", "by (simp add: comm_scalar_prod)"], ["proof (state)\nthis:\n  gso i \\<bullet>\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                [0..<i])\\<parallel>\\<^sup>2 +\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i +\n  (M.sumlist\n    (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n   gso i +\n   \\<parallel>gso i\\<parallel>\\<^sup>2)", "have \"sq_norm (fs ! i) = sq_norm ?sum + 2 * (?sum \\<bullet> gso i) + sq_norm (gso i)\""], ["proof (prove)\nusing this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                [0..<i])\\<parallel>\\<^sup>2 +\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i +\n  (M.sumlist\n    (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n   gso i +\n   \\<parallel>gso i\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    \\<parallel>M.sumlist\n                (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                  [0..<i])\\<parallel>\\<^sup>2 +\n    (2::'a) *\n    (M.sumlist\n      (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n     gso i) +\n    \\<parallel>gso i\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                [0..<i])\\<parallel>\\<^sup>2 +\n  (2::'a) *\n  (M.sumlist\n    (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n   gso i) +\n  \\<parallel>gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  \\<parallel>M.sumlist\n              (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                [0..<i])\\<parallel>\\<^sup>2 +\n  (2::'a) *\n  (M.sumlist\n    (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n   gso i) +\n  \\<parallel>gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have \"\\<dots> \\<ge> 2 * (?sum \\<bullet> gso i) + sq_norm (gso i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2::'a) *\n    (M.sumlist\n      (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n     gso i) +\n    \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>M.sumlist\n                      (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                        [0..<i])\\<parallel>\\<^sup>2 +\n          (2::'a) *\n          (M.sumlist\n            (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n              [0..<i]) \\<bullet>\n           gso i) +\n          \\<parallel>gso i\\<parallel>\\<^sup>2", "using sq_norm_vec_ge_0[of ?sum]"], ["proof (prove)\nusing this:\n  (0::'a)\n  \\<le> \\<parallel>M.sumlist\n                    (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                      [0..<i])\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (2::'a) *\n    (M.sumlist\n      (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n     gso i) +\n    \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>M.sumlist\n                      (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                        [0..<i])\\<parallel>\\<^sup>2 +\n          (2::'a) *\n          (M.sumlist\n            (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n              [0..<i]) \\<bullet>\n           gso i) +\n          \\<parallel>gso i\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (2::'a) *\n  (M.sumlist\n    (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n   gso i) +\n  \\<parallel>gso i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>M.sumlist\n                    (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                      [0..<i])\\<parallel>\\<^sup>2 +\n        (2::'a) *\n        (M.sumlist\n          (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n            [0..<i]) \\<bullet>\n         gso i) +\n        \\<parallel>gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (2::'a) *\n  (M.sumlist\n    (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n   gso i) +\n  \\<parallel>gso i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>M.sumlist\n                    (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                      [0..<i])\\<parallel>\\<^sup>2 +\n        (2::'a) *\n        (M.sumlist\n          (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n            [0..<i]) \\<bullet>\n         gso i) +\n        \\<parallel>gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have \"?sum \\<bullet> gso i = (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]. v \\<bullet> gso i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n    gso i =\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<i]. v \\<bullet> gso i)", "by (subst scalar_prod_left_sum_distrib[OF _ gsoi], insert i gso_carrier, auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i]. v \\<bullet> gso i)\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]) \\<bullet>\n  gso i =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i]. v \\<bullet> gso i)\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<i]. v \\<bullet> gso i) =\n    (0::'a)", "proof (rule sum_list_neutral, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>v. v \\<bullet> gso i)\n                     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i])) \\<Longrightarrow>\n       x = (0::'a)", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> set (map (\\<lambda>v. v \\<bullet> gso i)\n                (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>v. v \\<bullet> gso i)\n                     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i])) \\<Longrightarrow>\n       x = (0::'a)", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (map (\\<lambda>v. v \\<bullet> gso i)\n                (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]))", "obtain j where j: \"j < i\" and x: \"x = (\\<mu> i j \\<cdot>\\<^sub>v gso j) \\<bullet> gso i\""], ["proof (prove)\nusing this:\n  x \\<in> set (map (\\<lambda>v. v \\<bullet> gso i)\n                (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < i;\n         x = (\\<mu> i j \\<cdot>\\<^sub>v gso j) \\<bullet> gso i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j < i\n  x = (\\<mu> i j \\<cdot>\\<^sub>v gso j) \\<bullet> gso i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>v. v \\<bullet> gso i)\n                     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i])) \\<Longrightarrow>\n       x = (0::'a)", "from j i"], ["proof (chain)\npicking this:\n  j < i\n  i < length fs", "have gsoj: \"gso j \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  j < i\n  i < length fs\n\ngoal (1 subgoal):\n 1. gso j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  gso j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>v. v \\<bullet> gso i)\n                     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i])) \\<Longrightarrow>\n       x = (0::'a)", "have \"x = \\<mu> i j * (gso j \\<bullet> gso i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = \\<mu> i j * (gso j \\<bullet> gso i)", "using gsoi gsoj"], ["proof (prove)\nusing this:\n  gso i \\<in> carrier_vec n\n  gso j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. x = \\<mu> i j * (gso j \\<bullet> gso i)", "unfolding x"], ["proof (prove)\nusing this:\n  gso i \\<in> carrier_vec n\n  gso j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<mu> i j \\<cdot>\\<^sub>v gso j) \\<bullet> gso i =\n    \\<mu> i j * (gso j \\<bullet> gso i)", "by simp"], ["proof (state)\nthis:\n  x = \\<mu> i j * (gso j \\<bullet> gso i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>v. v \\<bullet> gso i)\n                     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i])) \\<Longrightarrow>\n       x = (0::'a)", "also"], ["proof (state)\nthis:\n  x = \\<mu> i j * (gso j \\<bullet> gso i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>v. v \\<bullet> gso i)\n                     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i])) \\<Longrightarrow>\n       x = (0::'a)", "have \"gso j \\<bullet> gso i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso j \\<bullet> gso i = (0::'a)", "by (rule orthogonal, insert j i assms, auto)"], ["proof (state)\nthis:\n  gso j \\<bullet> gso i = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>v. v \\<bullet> gso i)\n                     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i])) \\<Longrightarrow>\n       x = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  x = \\<mu> i j * (0::'a)", "show \"x = 0\""], ["proof (prove)\nusing this:\n  x = \\<mu> i j * (0::'a)\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "by simp"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<i]. v \\<bullet> gso i) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  (2::'a) * (0::'a) + \\<parallel>gso i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  (2::'a) * (0::'a) + \\<parallel>gso i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<parallel>gso i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Theorem 16.5 (ii), first half *)"], ["", "lemma oc_projection_exist:\n  assumes i: \"i < m\" \n  shows \"fs ! i - gso i \\<in> span (gso ` {0..<i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i - gso i \\<in> local.span (gso ` {0..<i})", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. fs ! i - gso i = lincomb ?a ?A\n 2. finite ?A\n 3. ?A \\<subseteq> gso ` {0..<i}", "let ?A = \"gso ` {0..<i}\""], ["proof (state)\ngoal (3 subgoals):\n 1. fs ! i - gso i = lincomb ?a ?A\n 2. finite ?A\n 3. ?A \\<subseteq> gso ` {0..<i}", "show finA:\"finite ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (gso ` {0..<i})", "by auto"], ["proof (state)\nthis:\n  finite (gso ` {0..<i})\n\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "have carA[intro!]:\"?A \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso ` {0..<i} \\<subseteq> carrier_vec n", "using gso_dim assms"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> dim_vec (gso ?i) = n\n  i < length fs\n\ngoal (1 subgoal):\n 1. gso ` {0..<i} \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  gso ` {0..<i} \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "let \"?a v\" = \"\\<Sum>n\\<leftarrow>[0..<i]. if v = gso n then \\<mu> i n else 0\""], ["proof (state)\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "have d:\"(sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n    \\<in> carrier_vec n", "using gso.simps[of i] gso_dim[OF i]"], ["proof (prove)\nusing this:\n  gso i =\n  fs ! i +\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  dim_vec (gso i) = n\n\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n    \\<in> carrier_vec n", "unfolding carrier_vec_def"], ["proof (prove)\nusing this:\n  gso i =\n  fs ! i +\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  dim_vec (gso i) = n\n\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n    \\<in> {v. dim_vec v = n}", "by auto"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "note [intro] = f_carrier[OF i] gso_carrier[OF i] d"], ["proof (state)\nthis:\n  fs ! i \\<in> carrier_vec n\n  gso i \\<in> carrier_vec n\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "have [intro!]:\"(\\<lambda>v. ?a v \\<cdot>\\<^sub>v v) \\<in> gso ` {0..<i} \\<rightarrow> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        (\\<Sum>n\\<leftarrow>[0..<\n                             i]. if v = gso n then \\<mu> i n\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n        v)\n    \\<in> gso ` {0..<i} \\<rightarrow> carrier_vec n", "using gso_carrier assms"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  i < length fs\n\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        (\\<Sum>n\\<leftarrow>[0..<\n                             i]. if v = gso n then \\<mu> i n\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n        v)\n    \\<in> gso ` {0..<i} \\<rightarrow> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v.\n      (\\<Sum>n\\<leftarrow>[0..<\n                           i]. if v = gso n then \\<mu> i n\n                               else (0::'a)) \\<cdot>\\<^sub>v\n      v)\n  \\<in> gso ` {0..<i} \\<rightarrow> carrier_vec n\n\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "{"], ["proof (state)\nthis:\n  (\\<lambda>v.\n      (\\<Sum>n\\<leftarrow>[0..<\n                           i]. if v = gso n then \\<mu> i n\n                               else (0::'a)) \\<cdot>\\<^sub>v\n      v)\n  \\<in> gso ` {0..<i} \\<rightarrow> carrier_vec n\n\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "fix ia"], ["proof (state)\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "assume ia[intro]:\"ia < n\""], ["proof (state)\nthis:\n  ia < n\n\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "have \"(\\<Sum>x\\<in>gso ` {0..<i}. (?a x \\<cdot>\\<^sub>v x) $ ia) =\n      - (\\<Sum>x\\<leftarrow>map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]. x $ ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>gso ` {0..<i}.\n       ((\\<Sum>n\\<leftarrow>[0..<\n                             i]. if x = gso n then \\<mu> i n\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n        x) $\n       ia) =\n    - (\\<Sum>x\\<leftarrow>map (\\<lambda>j.\n                                  - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                           [0..<i]. x $ ia)", "unfolding map_map comm_monoid_add_class.sum.reindex[OF gso_inj[OF assms]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>x.\n             ((\\<Sum>n\\<leftarrow>[0..<\n                                   i]. if x = gso n then \\<mu> i n\n else (0::'a)) \\<cdot>\\<^sub>v\n              x) $\n             ia) \\<circ>\n         gso)\n     {0..<i} =\n    - sum_list\n       (map ((\\<lambda>x. x $ ia) \\<circ>\n             (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j))\n         [0..<i])", "unfolding atLeastLessThan_upt sum_set_upt_conv_sum_list_nat uminus_sum_list_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<\n                         i]. ((\\<Sum>n\\<leftarrow>[0..<\n             i]. if gso x = gso n then \\<mu> i n\n                 else (0::'a)) \\<cdot>\\<^sub>v\n                              gso x) $\n                             ia) =\n    (\\<Sum>x\\<leftarrow>[0..<i]. - (- \\<mu> i x \\<cdot>\\<^sub>v gso x) $ ia)", "proof(rule arg_cong[OF map_cong, OF refl],goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [0..<i] \\<Longrightarrow>\n       ((\\<Sum>n\\<leftarrow>[0..<\n                             i]. if gso x = gso n then \\<mu> i n\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n        gso x) $\n       ia =\n       - (- \\<mu> i x \\<cdot>\\<^sub>v gso x) $ ia", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> set [0..<i]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [0..<i] \\<Longrightarrow>\n       ((\\<Sum>n\\<leftarrow>[0..<\n                             i]. if gso x = gso n then \\<mu> i n\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n        gso x) $\n       ia =\n       - (- \\<mu> i x \\<cdot>\\<^sub>v gso x) $ ia", "hence x:\"x < m\" \"x < i\""], ["proof (prove)\nusing this:\n  x \\<in> set [0..<i]\n\ngoal (1 subgoal):\n 1. x < length fs &&& x < i", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set [0..<i]\n  i < length fs\n\ngoal (1 subgoal):\n 1. x < length fs &&& x < i", "by auto"], ["proof (state)\nthis:\n  x < length fs\n  x < i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [0..<i] \\<Longrightarrow>\n       ((\\<Sum>n\\<leftarrow>[0..<\n                             i]. if gso x = gso n then \\<mu> i n\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n        gso x) $\n       ia =\n       - (- \\<mu> i x \\<cdot>\\<^sub>v gso x) $ ia", "hence d:\"insert x (set [0..<i]) = {0..<i}\"\n              \"count (mset [0..<i]) x = 1\""], ["proof (prove)\nusing this:\n  x < length fs\n  x < i\n\ngoal (1 subgoal):\n 1. insert x (set [0..<i]) = {0..<i} &&& count (mset [0..<i]) x = 1", "by auto"], ["proof (state)\nthis:\n  insert x (set [0..<i]) = {0..<i}\n  count (mset [0..<i]) x = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [0..<i] \\<Longrightarrow>\n       ((\\<Sum>n\\<leftarrow>[0..<\n                             i]. if gso x = gso n then \\<mu> i n\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n        gso x) $\n       ia =\n       - (- \\<mu> i x \\<cdot>\\<^sub>v gso x) $ ia", "hence \"inj_on gso (insert x (set [0..<i]))\""], ["proof (prove)\nusing this:\n  insert x (set [0..<i]) = {0..<i}\n  count (mset [0..<i]) x = 1\n\ngoal (1 subgoal):\n 1. inj_on gso (insert x (set [0..<i]))", "using gso_inj[OF assms]"], ["proof (prove)\nusing this:\n  insert x (set [0..<i]) = {0..<i}\n  count (mset [0..<i]) x = 1\n  inj_on gso {0..<i}\n\ngoal (1 subgoal):\n 1. inj_on gso (insert x (set [0..<i]))", "by auto"], ["proof (state)\nthis:\n  inj_on gso (insert x (set [0..<i]))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [0..<i] \\<Longrightarrow>\n       ((\\<Sum>n\\<leftarrow>[0..<\n                             i]. if gso x = gso n then \\<mu> i n\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n        gso x) $\n       ia =\n       - (- \\<mu> i x \\<cdot>\\<^sub>v gso x) $ ia", "from inj_on_filter_key_eq[OF this,folded replicate_count_mset_eq_filter_eq]"], ["proof (chain)\npicking this:\n  filter (\\<lambda>xa. gso x = gso xa) [0..<i] =\n  replicate (count (mset [0..<i]) x) x", "have \"[n\\<leftarrow>[0..<i] . gso x = gso n] = [x]\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>xa. gso x = gso xa) [0..<i] =\n  replicate (count (mset [0..<i]) x) x\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>n. gso x = gso n) [0..<i] = [x]", "using x assms d replicate.simps(2)[of 0]"], ["proof (prove)\nusing this:\n  filter (\\<lambda>xa. gso x = gso xa) [0..<i] =\n  replicate (count (mset [0..<i]) x) x\n  x < length fs\n  x < i\n  i < length fs\n  insert x (set [0..<i]) = {0..<i}\n  count (mset [0..<i]) x = 1\n  replicate (Suc 0) ?x = ?x # replicate 0 ?x\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>n. gso x = gso n) [0..<i] = [x]", "by auto"], ["proof (state)\nthis:\n  filter (\\<lambda>n. gso x = gso n) [0..<i] = [x]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [0..<i] \\<Longrightarrow>\n       ((\\<Sum>n\\<leftarrow>[0..<\n                             i]. if gso x = gso n then \\<mu> i n\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n        gso x) $\n       ia =\n       - (- \\<mu> i x \\<cdot>\\<^sub>v gso x) $ ia", "hence \"(\\<Sum>n\\<leftarrow>[0..<i]. if gso x = gso n then \\<mu> i n else 0) = \\<mu> i x\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>n. gso x = gso n) [0..<i] = [x]\n\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<leftarrow>[0..<\n                         i]. if gso x = gso n then \\<mu> i n else (0::'a)) =\n    \\<mu> i x", "unfolding sum_list_map_filter'[symmetric]"], ["proof (prove)\nusing this:\n  filter (\\<lambda>n. gso x = gso n) [0..<i] = [x]\n\ngoal (1 subgoal):\n 1. sum_list (map (\\<mu> i) (filter (\\<lambda>n. gso x = gso n) [0..<i])) =\n    \\<mu> i x", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>n\\<leftarrow>[0..<\n                       i]. if gso x = gso n then \\<mu> i n else (0::'a)) =\n  \\<mu> i x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [0..<i] \\<Longrightarrow>\n       ((\\<Sum>n\\<leftarrow>[0..<\n                             i]. if gso x = gso n then \\<mu> i n\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n        gso x) $\n       ia =\n       - (- \\<mu> i x \\<cdot>\\<^sub>v gso x) $ ia", "with ia gso_dim x"], ["proof (chain)\npicking this:\n  ia < n\n  ?i < length fs \\<Longrightarrow> dim_vec (gso ?i) = n\n  x < length fs\n  x < i\n  (\\<Sum>n\\<leftarrow>[0..<\n                       i]. if gso x = gso n then \\<mu> i n else (0::'a)) =\n  \\<mu> i x", "show ?case"], ["proof (prove)\nusing this:\n  ia < n\n  ?i < length fs \\<Longrightarrow> dim_vec (gso ?i) = n\n  x < length fs\n  x < i\n  (\\<Sum>n\\<leftarrow>[0..<\n                       i]. if gso x = gso n then \\<mu> i n else (0::'a)) =\n  \\<mu> i x\n\ngoal (1 subgoal):\n 1. ((\\<Sum>n\\<leftarrow>[0..<\n                          i]. if gso x = gso n then \\<mu> i n\n                              else (0::'a)) \\<cdot>\\<^sub>v\n     gso x) $\n    ia =\n    - (- \\<mu> i x \\<cdot>\\<^sub>v gso x) $ ia", "apply(subst index_smult_vec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ia < n;\n     \\<And>i. i < length fs \\<Longrightarrow> dim_vec (gso i) = n;\n     x < length fs; x < i;\n     (\\<Sum>n\\<leftarrow>[0..<\n                          i]. if gso x = gso n then \\<mu> i n\n                              else (0::'a)) =\n     \\<mu> i x\\<rbrakk>\n    \\<Longrightarrow> ia < dim_vec (gso x)\n 2. \\<lbrakk>ia < n;\n     \\<And>i. i < length fs \\<Longrightarrow> dim_vec (gso i) = n;\n     x < length fs; x < i;\n     (\\<Sum>n\\<leftarrow>[0..<\n                          i]. if gso x = gso n then \\<mu> i n\n                              else (0::'a)) =\n     \\<mu> i x\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>n\\<leftarrow>[0..<\n     i]. if gso x = gso n then \\<mu> i n else (0::'a)) *\n                      gso x $ ia =\n                      - (- \\<mu> i x \\<cdot>\\<^sub>v gso x) $ ia", "by force+"], ["proof (state)\nthis:\n  ((\\<Sum>n\\<leftarrow>[0..<\n                        i]. if gso x = gso n then \\<mu> i n\n                            else (0::'a)) \\<cdot>\\<^sub>v\n   gso x) $\n  ia =\n  - (- \\<mu> i x \\<cdot>\\<^sub>v gso x) $ ia\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>gso ` {0..<i}.\n     ((\\<Sum>n\\<leftarrow>[0..<\n                           i]. if x = gso n then \\<mu> i n\n                               else (0::'a)) \\<cdot>\\<^sub>v\n      x) $\n     ia) =\n  - (\\<Sum>x\\<leftarrow>map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<i]. x $ ia)\n\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "hence \"(\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>gso ` {0..<i}. ?a v \\<cdot>\\<^sub>v v) $ ia =\n          (- local.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) $ ia\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>gso ` {0..<i}.\n     ((\\<Sum>n\\<leftarrow>[0..<\n                           i]. if x = gso n then \\<mu> i n\n                               else (0::'a)) \\<cdot>\\<^sub>v\n      x) $\n     ia) =\n  - (\\<Sum>x\\<leftarrow>map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<i]. x $ ia)\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>gso `\n                                    {0..<i}. (\\<Sum>n\\<leftarrow>[0..<\n                            i]. if v = gso n then \\<mu> i n\n                                else (0::'a)) \\<cdot>\\<^sub>v\n       v) $\n    ia =\n    (- M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) $\n    ia", "using d assms"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>gso ` {0..<i}.\n     ((\\<Sum>n\\<leftarrow>[0..<\n                           i]. if x = gso n then \\<mu> i n\n                               else (0::'a)) \\<cdot>\\<^sub>v\n      x) $\n     ia) =\n  - (\\<Sum>x\\<leftarrow>map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<i]. x $ ia)\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  \\<in> carrier_vec n\n  i < length fs\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>gso `\n                                    {0..<i}. (\\<Sum>n\\<leftarrow>[0..<\n                            i]. if v = gso n then \\<mu> i n\n                                else (0::'a)) \\<cdot>\\<^sub>v\n       v) $\n    ia =\n    (- M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) $\n    ia", "apply (subst (0 0) finsum_index index_uminus_vec)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(\\<Sum>x\\<in>gso ` {0..<i}.\n                ((\\<Sum>n\\<leftarrow>[0..<\ni]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                 x) $\n                ia) =\n             - (\\<Sum>x\\<leftarrow>map (\\<lambda>j.\n     - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                                    [0..<i]. x $ ia);\n     M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n     \\<in> carrier_vec n;\n     i < length fs\\<rbrakk>\n    \\<Longrightarrow> ia < n\n 2. \\<lbrakk>(\\<Sum>x\\<in>gso ` {0..<i}.\n                ((\\<Sum>n\\<leftarrow>[0..<\ni]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                 x) $\n                ia) =\n             - (\\<Sum>x\\<leftarrow>map (\\<lambda>j.\n     - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                                    [0..<i]. x $ ia);\n     M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n     \\<in> carrier_vec n;\n     i < length fs\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>v.\n                          (\\<Sum>n\\<leftarrow>[0..<\n         i]. if v = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                          v)\n                      \\<in> gso ` {0..<i} \\<rightarrow> carrier_vec n\n 3. \\<lbrakk>(\\<Sum>x\\<in>gso ` {0..<i}.\n                ((\\<Sum>n\\<leftarrow>[0..<\ni]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                 x) $\n                ia) =\n             - (\\<Sum>x\\<leftarrow>map (\\<lambda>j.\n     - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                                    [0..<i]. x $ ia);\n     M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n     \\<in> carrier_vec n;\n     i < length fs\\<rbrakk>\n    \\<Longrightarrow> gso ` {0..<i} \\<subseteq> carrier_vec n\n 4. \\<lbrakk>(\\<Sum>x\\<in>gso ` {0..<i}.\n                ((\\<Sum>n\\<leftarrow>[0..<\ni]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                 x) $\n                ia) =\n             - (\\<Sum>x\\<leftarrow>map (\\<lambda>j.\n     - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                                    [0..<i]. x $ ia);\n     M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n     \\<in> carrier_vec n;\n     i < length fs\\<rbrakk>\n    \\<Longrightarrow> ia < dim_vec\n                            (M.sumlist\n                              (map (\\<lambda>j.\n - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                                [0..<i]))\n 5. \\<lbrakk>(\\<Sum>x\\<in>gso ` {0..<i}.\n                ((\\<Sum>n\\<leftarrow>[0..<\ni]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                 x) $\n                ia) =\n             - (\\<Sum>x\\<leftarrow>map (\\<lambda>j.\n     - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                                    [0..<i]. x $ ia);\n     M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n     \\<in> carrier_vec n;\n     i < length fs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>gso ` {0..<i}.\n                         ((\\<Sum>n\\<leftarrow>[0..<\n         i]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                          x) $\n                         ia) =\n                      - M.sumlist\n                         (map (\\<lambda>j.\n                                  - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                           [0..<i]) $\n                        ia", "apply force+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>x\\<in>gso ` {0..<i}.\n                ((\\<Sum>n\\<leftarrow>[0..<\ni]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                 x) $\n                ia) =\n             - (\\<Sum>x\\<leftarrow>map (\\<lambda>j.\n     - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                                    [0..<i]. x $ ia);\n     M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n     \\<in> carrier_vec n;\n     i < length fs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>gso ` {0..<i}.\n                         ((\\<Sum>n\\<leftarrow>[0..<\n         i]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                          x) $\n                         ia) =\n                      - M.sumlist\n                         (map (\\<lambda>j.\n                                  - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                           [0..<i]) $\n                        ia", "apply (subst sumlist_vec_index)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(\\<Sum>x\\<in>gso ` {0..<i}.\n                   ((\\<Sum>n\\<leftarrow>[0..<\n   i]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                    x) $\n                   ia) =\n                - (\\<Sum>x\\<leftarrow>map\n (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]. x $ ia);\n        M.sumlist\n         (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n        \\<in> carrier_vec n;\n        i < length fs;\n        x \\<in> set (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                      [0..<i])\\<rbrakk>\n       \\<Longrightarrow> x \\<in> carrier_vec n\n 2. \\<lbrakk>(\\<Sum>x\\<in>gso ` {0..<i}.\n                ((\\<Sum>n\\<leftarrow>[0..<\ni]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                 x) $\n                ia) =\n             - (\\<Sum>x\\<leftarrow>map (\\<lambda>j.\n     - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                                    [0..<i]. x $ ia);\n     M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n     \\<in> carrier_vec n;\n     i < length fs\\<rbrakk>\n    \\<Longrightarrow> ia < n\n 3. \\<lbrakk>(\\<Sum>x\\<in>gso ` {0..<i}.\n                ((\\<Sum>n\\<leftarrow>[0..<\ni]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                 x) $\n                ia) =\n             - (\\<Sum>x\\<leftarrow>map (\\<lambda>j.\n     - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                                    [0..<i]. x $ ia);\n     M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n     \\<in> carrier_vec n;\n     i < length fs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>gso ` {0..<i}.\n                         ((\\<Sum>n\\<leftarrow>[0..<\n         i]. if x = gso n then \\<mu> i n else (0::'a)) \\<cdot>\\<^sub>v\n                          x) $\n                         ia) =\n                      - (\\<Sum>x\\<leftarrow>map\n       (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i]. x $ ia)", "by force+"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>gso `\n                                  {0..<i}. (\\<Sum>n\\<leftarrow>[0..<\n                          i]. if v = gso n then \\<mu> i n\n                              else (0::'a)) \\<cdot>\\<^sub>v\n     v) $\n  ia =\n  (- M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) $\n  ia\n\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "}"], ["proof (state)\nthis:\n  ?ia3 < n \\<Longrightarrow>\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>gso `\n                                  {0..<i}. (\\<Sum>n\\<leftarrow>[0..<\n                          i]. if v = gso n then \\<mu> i n\n                              else (0::'a)) \\<cdot>\\<^sub>v\n     v) $\n  ?ia3 =\n  (- M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) $\n  ?ia3\n\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "hence id: \"(\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>?A. ?a v \\<cdot>\\<^sub>v v) = - sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\""], ["proof (prove)\nusing this:\n  ?ia3 < n \\<Longrightarrow>\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>gso `\n                                  {0..<i}. (\\<Sum>n\\<leftarrow>[0..<\n                          i]. if v = gso n then \\<mu> i n\n                              else (0::'a)) \\<cdot>\\<^sub>v\n     v) $\n  ?ia3 =\n  (- M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) $\n  ?ia3\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>gso `\n                                    {0..<i}. (\\<Sum>n\\<leftarrow>[0..<\n                            i]. if v = gso n then \\<mu> i n\n                                else (0::'a)) \\<cdot>\\<^sub>v\n       v) =\n    - M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "using d lincomb_dim[OF finA carA,unfolded lincomb_def]"], ["proof (prove)\nusing this:\n  ?ia3 < n \\<Longrightarrow>\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>gso `\n                                  {0..<i}. (\\<Sum>n\\<leftarrow>[0..<\n                          i]. if v = gso n then \\<mu> i n\n                              else (0::'a)) \\<cdot>\\<^sub>v\n     v) $\n  ?ia3 =\n  (- M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) $\n  ?ia3\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n  \\<in> carrier_vec n\n  dim_vec\n   (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>gso ` {0..<i}. ?a v \\<cdot>\\<^sub>v v) =\n  n\n\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>gso `\n                                    {0..<i}. (\\<Sum>n\\<leftarrow>[0..<\n                            i]. if v = gso n then \\<mu> i n\n                                else (0::'a)) \\<cdot>\\<^sub>v\n       v) =\n    - M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "by(intro eq_vecI,auto)"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>gso `\n                                  {0..<i}. (\\<Sum>n\\<leftarrow>[0..<\n                          i]. if v = gso n then \\<mu> i n\n                              else (0::'a)) \\<cdot>\\<^sub>v\n     v) =\n  - M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])\n\ngoal (2 subgoals):\n 1. fs ! i - gso i = lincomb ?a (gso ` {0..<i})\n 2. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "show \"fs ! i - gso i = lincomb ?a ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i - gso i =\n    lincomb\n     (\\<lambda>a.\n         \\<Sum>n\\<leftarrow>[0..<\n                             i]. if a = gso n then \\<mu> i n else (0::'a))\n     (gso ` {0..<i})", "unfolding lincomb_def gso.simps[of i] id"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i -\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])) =\n    - M.sumlist\n       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<i])", "by (rule eq_vecI, auto)"], ["proof (state)\nthis:\n  fs ! i - gso i =\n  lincomb\n   (\\<lambda>a.\n       \\<Sum>n\\<leftarrow>[0..<i]. if a = gso n then \\<mu> i n else (0::'a))\n   (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. gso ` {0..<i} \\<subseteq> gso ` {0..<i}", "qed auto"], ["", "lemma oc_projection_unique:\n  assumes \"i < m\" \n          \"v \\<in> carrier_vec n\"\n          \"\\<And> x. x \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> x = 0\"\n          \"fs ! i - v \\<in> span (gso ` {0..<i})\"\n  shows \"v = gso i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = gso i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = gso i", "from assms"], ["proof (chain)\npicking this:\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})", "have carr_span:\"span (gso ` {0..<i}) \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) \\<subseteq> carrier_vec n", "by(intro span_is_subset2) auto"], ["proof (state)\nthis:\n  local.span (gso ` {0..<i}) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. v = gso i", "from assms"], ["proof (chain)\npicking this:\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})", "have carr: \"gso ` {0..<i} \\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. gso ` {0..<i} \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  gso ` {0..<i} \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. v = gso i", "from assms"], ["proof (chain)\npicking this:\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})", "have eq:\"fs ! i - (fs ! i - v) = v\" for v"], ["proof (prove)\nusing this:\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. fs ! i - (fs ! i - v) = v", "by auto"], ["proof (state)\nthis:\n  fs ! i - (fs ! i - ?v1) = ?v1\n\ngoal (1 subgoal):\n 1. v = gso i", "from orthocompl_span[OF _ carr] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x.\n              x \\<in> gso ` {0..<i} \\<Longrightarrow>\n              ?v \\<bullet> x = (0::'a);\n   ?v \\<in> carrier_vec n; ?y \\<in> local.span (gso ` {0..<i})\\<rbrakk>\n  \\<Longrightarrow> ?v \\<bullet> ?y = (0::'a)\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})", "have \"y \\<in> span (gso ` {0..<i}) \\<Longrightarrow> v \\<bullet> y = 0\" for y"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x.\n              x \\<in> gso ` {0..<i} \\<Longrightarrow>\n              ?v \\<bullet> x = (0::'a);\n   ?v \\<in> carrier_vec n; ?y \\<in> local.span (gso ` {0..<i})\\<rbrakk>\n  \\<Longrightarrow> ?v \\<bullet> ?y = (0::'a)\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. y \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n    v \\<bullet> y = (0::'a)", "by auto"], ["proof (state)\nthis:\n  ?y1 \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n  v \\<bullet> ?y1 = (0::'a)\n\ngoal (1 subgoal):\n 1. v = gso i", "hence oc1:\"fs ! i - (fs ! i - v) \\<in> orthogonal_complement (span (gso ` {0..< i}))\""], ["proof (prove)\nusing this:\n  ?y1 \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n  v \\<bullet> ?y1 = (0::'a)\n\ngoal (1 subgoal):\n 1. fs ! i - (fs ! i - v)\n    \\<in> orthogonal_complement (local.span (gso ` {0..<i}))", "unfolding eq orthogonal_complement_def"], ["proof (prove)\nusing this:\n  ?y1 \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n  v \\<bullet> ?y1 = (0::'a)\n\ngoal (1 subgoal):\n 1. v \\<in> {x \\<in> carrier_vec n.\n             \\<forall>y\\<in>local.span (gso ` {0..<i}).\n                x \\<bullet> y = (0::'a)}", "using assms"], ["proof (prove)\nusing this:\n  ?y1 \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n  v \\<bullet> ?y1 = (0::'a)\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. v \\<in> {x \\<in> carrier_vec n.\n             \\<forall>y\\<in>local.span (gso ` {0..<i}).\n                x \\<bullet> y = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  fs ! i - (fs ! i - v)\n  \\<in> orthogonal_complement (local.span (gso ` {0..<i}))\n\ngoal (1 subgoal):\n 1. v = gso i", "have \"x \\<in> gso ` {0..<i} \\<Longrightarrow> gso i \\<bullet> x = 0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> gso ` {0..<i} \\<Longrightarrow> gso i \\<bullet> x = (0::'a)", "using assms orthogonal"], ["proof (prove)\nusing this:\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})\n  \\<lbrakk>?i < length fs; ?j < length fs; ?i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> gso ?i \\<bullet> gso ?j = (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> gso ` {0..<i} \\<Longrightarrow> gso i \\<bullet> x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> gso i \\<bullet> ?x1 = (0::'a)\n\ngoal (1 subgoal):\n 1. v = gso i", "hence \"y \\<in> span (gso ` {0..<i}) \\<Longrightarrow> gso i \\<bullet> y = 0\" for y"], ["proof (prove)\nusing this:\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> gso i \\<bullet> ?x1 = (0::'a)\n\ngoal (1 subgoal):\n 1. y \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n    gso i \\<bullet> y = (0::'a)", "by (rule orthocompl_span) (use carr gso_carrier assms in auto)"], ["proof (state)\nthis:\n  ?y1 \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n  gso i \\<bullet> ?y1 = (0::'a)\n\ngoal (1 subgoal):\n 1. v = gso i", "hence oc2:\"fs ! i - (fs ! i - gso i) \\<in> orthogonal_complement (span (gso ` {0..< i}))\""], ["proof (prove)\nusing this:\n  ?y1 \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n  gso i \\<bullet> ?y1 = (0::'a)\n\ngoal (1 subgoal):\n 1. fs ! i - (fs ! i - gso i)\n    \\<in> orthogonal_complement (local.span (gso ` {0..<i}))", "unfolding eq orthogonal_complement_def"], ["proof (prove)\nusing this:\n  ?y1 \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n  gso i \\<bullet> ?y1 = (0::'a)\n\ngoal (1 subgoal):\n 1. gso i\n    \\<in> {x \\<in> carrier_vec n.\n           \\<forall>y\\<in>local.span (gso ` {0..<i}).\n              x \\<bullet> y = (0::'a)}", "using assms"], ["proof (prove)\nusing this:\n  ?y1 \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n  gso i \\<bullet> ?y1 = (0::'a)\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. gso i\n    \\<in> {x \\<in> carrier_vec n.\n           \\<forall>y\\<in>local.span (gso ` {0..<i}).\n              x \\<bullet> y = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  fs ! i - (fs ! i - gso i)\n  \\<in> orthogonal_complement (local.span (gso ` {0..<i}))\n\ngoal (1 subgoal):\n 1. v = gso i", "note pe= oc_projection_exist[OF assms(1)]"], ["proof (state)\nthis:\n  fs ! i - gso i \\<in> local.span (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. v = gso i", "note prerec = carr_span f_carrier[OF assms(1)] assms(4) oc1 oc_projection_exist[OF assms(1)] oc2"], ["proof (state)\nthis:\n  local.span (gso ` {0..<i}) \\<subseteq> carrier_vec n\n  fs ! i \\<in> carrier_vec n\n  fs ! i - v \\<in> local.span (gso ` {0..<i})\n  fs ! i - (fs ! i - v)\n  \\<in> orthogonal_complement (local.span (gso ` {0..<i}))\n  fs ! i - gso i \\<in> local.span (gso ` {0..<i})\n  fs ! i - (fs ! i - gso i)\n  \\<in> orthogonal_complement (local.span (gso ` {0..<i}))\n\ngoal (1 subgoal):\n 1. v = gso i", "note prerec = carr_span f_carrier[OF assms(1)] assms(4) oc1 oc_projection_exist[OF assms(1)] oc2"], ["proof (state)\nthis:\n  local.span (gso ` {0..<i}) \\<subseteq> carrier_vec n\n  fs ! i \\<in> carrier_vec n\n  fs ! i - v \\<in> local.span (gso ` {0..<i})\n  fs ! i - (fs ! i - v)\n  \\<in> orthogonal_complement (local.span (gso ` {0..<i}))\n  fs ! i - gso i \\<in> local.span (gso ` {0..<i})\n  fs ! i - (fs ! i - gso i)\n  \\<in> orthogonal_complement (local.span (gso ` {0..<i}))\n\ngoal (1 subgoal):\n 1. v = gso i", "have gsoi: \"gso i \\<in> carrier_vec n\" \"fs ! i \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i \\<in> carrier_vec n &&& fs ! i \\<in> carrier_vec n", "by (rule gso_carrier[OF \\<open>i < m\\<close>], rule f_carrier[OF \\<open>i < m\\<close>])"], ["proof (state)\nthis:\n  gso i \\<in> carrier_vec n\n  fs ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v = gso i", "note main = arg_cong[OF oc_projection_alt_def[OF carr_span f_carrier[OF assms(1)] assms(4) oc1 pe oc2], \n     of \"\\<lambda> v. - v $ j + fs ! i $ j\" for j]"], ["proof (state)\nthis:\n  - (fs ! i - v) $ ?j3 + fs ! i $ ?j3 =\n  - (fs ! i - gso i) $ ?j3 + fs ! i $ ?j3\n\ngoal (1 subgoal):\n 1. v = gso i", "show \"v = gso i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = gso i", "proof (intro eq_vecI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia. ia < dim_vec (gso i) \\<Longrightarrow> v $ ia = gso i $ ia\n 2. dim_vec v = dim_vec (gso i)", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia. ia < dim_vec (gso i) \\<Longrightarrow> v $ ia = gso i $ ia\n 2. dim_vec v = dim_vec (gso i)", "show \"j < dim_vec (gso i) \\<Longrightarrow> v $ j = gso i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < dim_vec (gso i) \\<Longrightarrow> v $ j = gso i $ j", "using assms gsoi main[of j]"], ["proof (prove)\nusing this:\n  i < length fs\n  v \\<in> carrier_vec n\n  ?x1 \\<in> gso ` {0..<i} \\<Longrightarrow> v \\<bullet> ?x1 = (0::'a)\n  fs ! i - v \\<in> local.span (gso ` {0..<i})\n  gso i \\<in> carrier_vec n\n  fs ! i \\<in> carrier_vec n\n  - (fs ! i - v) $ j + fs ! i $ j = - (fs ! i - gso i) $ j + fs ! i $ j\n\ngoal (1 subgoal):\n 1. j < dim_vec (gso i) \\<Longrightarrow> v $ j = gso i $ j", "by (auto)"], ["proof (state)\nthis:\n  j < dim_vec (gso i) \\<Longrightarrow> v $ j = gso i $ j\n\ngoal (1 subgoal):\n 1. dim_vec v = dim_vec (gso i)", "qed (insert assms gsoi, auto)"], ["proof (state)\nthis:\n  v = gso i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gso_oc_projection:\n  assumes \"i < m\"\n  shows \"gso i = oc_projection (gso ` {0..<i}) (fs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i = oc_projection (gso ` {0..<i}) (fs ! i)", "unfolding oc_projection_def is_oc_projection_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i =\n    (SOME v.\n        v \\<in> carrier_vec n \\<and>\n        fs ! i - v \\<in> local.span (gso ` {0..<i}) \\<and>\n        (\\<forall>u.\n            u \\<in> gso ` {0..<i} \\<longrightarrow>\n            v \\<bullet> u = (0::'a)))", "proof (rule some_equality[symmetric,OF _ oc_projection_unique[OF assms]])"], ["proof (state)\ngoal (4 subgoals):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (gso ` {0..<i}) \\<and>\n    (\\<forall>u.\n        u \\<in> gso ` {0..<i} \\<longrightarrow> gso i \\<bullet> u = (0::'a))\n 2. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (gso ` {0..<i}) \\<and>\n       (\\<forall>u.\n           u \\<in> gso ` {0..<i} \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 3. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v \\<in> local.span (gso ` {0..<i}) \\<and>\n                (\\<forall>u.\n                    u \\<in> gso ` {0..<i} \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 4. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (gso ` {0..<i}) \\<and>\n       (\\<forall>u.\n           u \\<in> gso ` {0..<i} \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})", "have orthogonal:\"\\<And> xa. xa < i \\<Longrightarrow> gso i \\<bullet> gso xa = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. xa < i \\<Longrightarrow> gso i \\<bullet> gso xa = (0::'a)", "by (rule orthogonal,insert assms, auto)"], ["proof (state)\nthis:\n  ?xa1 < i \\<Longrightarrow> gso i \\<bullet> gso ?xa1 = (0::'a)\n\ngoal (4 subgoals):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (gso ` {0..<i}) \\<and>\n    (\\<forall>u.\n        u \\<in> gso ` {0..<i} \\<longrightarrow> gso i \\<bullet> u = (0::'a))\n 2. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (gso ` {0..<i}) \\<and>\n       (\\<forall>u.\n           u \\<in> gso ` {0..<i} \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 3. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v \\<in> local.span (gso ` {0..<i}) \\<and>\n                (\\<forall>u.\n                    u \\<in> gso ` {0..<i} \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 4. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (gso ` {0..<i}) \\<and>\n       (\\<forall>u.\n           u \\<in> gso ` {0..<i} \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})", "show \"gso i \\<in> carrier_vec n \\<and>\n        fs ! i - gso i \\<in> span (gso ` {0..<i}) \\<and>\n        (\\<forall>x. x \\<in> gso ` {0..<i} \\<longrightarrow> gso i \\<bullet> x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (gso ` {0..<i}) \\<and>\n    (\\<forall>x.\n        x \\<in> gso ` {0..<i} \\<longrightarrow> gso i \\<bullet> x = (0::'a))", "using gso_carrier oc_projection_exist assms orthogonal"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  ?i < length fs \\<Longrightarrow>\n  fs ! ?i - gso ?i \\<in> local.span (gso ` {0..<?i})\n  i < length fs\n  ?xa1 < i \\<Longrightarrow> gso i \\<bullet> gso ?xa1 = (0::'a)\n\ngoal (1 subgoal):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (gso ` {0..<i}) \\<and>\n    (\\<forall>x.\n        x \\<in> gso ` {0..<i} \\<longrightarrow> gso i \\<bullet> x = (0::'a))", "by auto"], ["proof (state)\nthis:\n  gso i \\<in> carrier_vec n \\<and>\n  fs ! i - gso i \\<in> local.span (gso ` {0..<i}) \\<and>\n  (\\<forall>x.\n      x \\<in> gso ` {0..<i} \\<longrightarrow> gso i \\<bullet> x = (0::'a))\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (gso ` {0..<i}) \\<and>\n       (\\<forall>u.\n           u \\<in> gso ` {0..<i} \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 2. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v \\<in> local.span (gso ` {0..<i}) \\<and>\n                (\\<forall>u.\n                    u \\<in> gso ` {0..<i} \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 3. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (gso ` {0..<i}) \\<and>\n       (\\<forall>u.\n           u \\<in> gso ` {0..<i} \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})", "qed auto"], ["", "lemma gso_oc_projection_span:\n  assumes \"i < m\"\n  shows \"gso i = oc_projection (span (gso ` {0..<i})) (fs ! i)\"\n    and \"is_oc_projection (gso i) (span (gso ` {0..<i})) (fs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i = oc_projection (local.span (gso ` {0..<i})) (fs ! i) &&&\n    is_oc_projection (gso i) (local.span (gso ` {0..<i})) (fs ! i)", "unfolding oc_projection_def is_oc_projection_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i =\n    (SOME v.\n        v \\<in> carrier_vec n \\<and>\n        fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n        (\\<forall>u.\n            u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n            v \\<bullet> u = (0::'a))) &&&\n    gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>u.\n        u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))", "proof (rule some_equality[symmetric,OF _ oc_projection_unique[OF assms]])"], ["proof (state)\ngoal (5 subgoals):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>u.\n        u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))\n 2. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 3. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 4. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})\n 5. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>u.\n        u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))", "let ?P = \"\\<lambda>v. v \\<in> carrier_vec n \\<and> fs ! i - v \\<in> span (span (gso ` {0..<i}))\n    \\<and> (\\<forall>x. x \\<in> span (gso ` {0..<i}) \\<longrightarrow> v \\<bullet> x = 0)\""], ["proof (state)\ngoal (5 subgoals):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>u.\n        u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))\n 2. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 3. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 4. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})\n 5. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>u.\n        u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))", "have carr:\"gso ` {0..<i} \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso ` {0..<i} \\<subseteq> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. gso ` {0..<i} \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  gso ` {0..<i} \\<subseteq> carrier_vec n\n\ngoal (5 subgoals):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>u.\n        u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))\n 2. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 3. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 4. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})\n 5. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>u.\n        u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))", "have *:  \"\\<And> xa. xa < i \\<Longrightarrow> gso i \\<bullet> gso xa = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. xa < i \\<Longrightarrow> gso i \\<bullet> gso xa = (0::'a)", "by (rule orthogonal,insert assms, auto)"], ["proof (state)\nthis:\n  ?xa1 < i \\<Longrightarrow> gso i \\<bullet> gso ?xa1 = (0::'a)\n\ngoal (5 subgoals):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>u.\n        u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))\n 2. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 3. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 4. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})\n 5. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>u.\n        u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))", "have orthogonal:\"\\<And>x. x \\<in> span (gso ` {0..<i}) \\<Longrightarrow> gso i \\<bullet> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n       gso i \\<bullet> x = (0::'a)", "apply(rule orthocompl_span)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> local.span (gso ` {0..<i}); xa \\<in> ?S x\\<rbrakk>\n       \\<Longrightarrow> gso i \\<bullet> xa = (0::'a)\n 2. \\<And>x.\n       x \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n       ?S x \\<subseteq> carrier_vec n\n 3. \\<And>x.\n       x \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n       gso i \\<in> carrier_vec n\n 4. \\<And>x.\n       x \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n       x \\<in> local.span (?S x)", "using assms *"], ["proof (prove)\nusing this:\n  i < length fs\n  ?xa1 < i \\<Longrightarrow> gso i \\<bullet> gso ?xa1 = (0::'a)\n\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> local.span (gso ` {0..<i}); xa \\<in> ?S x\\<rbrakk>\n       \\<Longrightarrow> gso i \\<bullet> xa = (0::'a)\n 2. \\<And>x.\n       x \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n       ?S x \\<subseteq> carrier_vec n\n 3. \\<And>x.\n       x \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n       gso i \\<in> carrier_vec n\n 4. \\<And>x.\n       x \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n       x \\<in> local.span (?S x)", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n  gso i \\<bullet> ?x1 = (0::'a)\n\ngoal (5 subgoals):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>u.\n        u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))\n 2. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 3. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 4. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})\n 5. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>u.\n        u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))", "show \"?P (gso i)\" \"?P (gso i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>x.\n        x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> x = (0::'a)) &&&\n    gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n    (\\<forall>x.\n        x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> x = (0::'a))", "unfolding span_span[OF carr]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (gso ` {0..<i}) \\<and>\n    (\\<forall>x.\n        x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> x = (0::'a)) &&&\n    gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (gso ` {0..<i}) \\<and>\n    (\\<forall>x.\n        x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> x = (0::'a))", "using gso_carrier oc_projection_exist assms orthogonal"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  ?i < length fs \\<Longrightarrow>\n  fs ! ?i - gso ?i \\<in> local.span (gso ` {0..<?i})\n  i < length fs\n  ?x1 \\<in> local.span (gso ` {0..<i}) \\<Longrightarrow>\n  gso i \\<bullet> ?x1 = (0::'a)\n\ngoal (1 subgoal):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (gso ` {0..<i}) \\<and>\n    (\\<forall>x.\n        x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> x = (0::'a)) &&&\n    gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (gso ` {0..<i}) \\<and>\n    (\\<forall>x.\n        x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n        gso i \\<bullet> x = (0::'a))", "by auto"], ["proof (state)\nthis:\n  gso i \\<in> carrier_vec n \\<and>\n  fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n  (\\<forall>x.\n      x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n      gso i \\<bullet> x = (0::'a))\n  gso i \\<in> carrier_vec n \\<and>\n  fs ! i - gso i \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n  (\\<forall>x.\n      x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n      gso i \\<bullet> x = (0::'a))\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 2. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 3. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})", "fix v"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 2. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 3. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})", "assume p:\"?P v\""], ["proof (state)\nthis:\n  v \\<in> carrier_vec n \\<and>\n  fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n  (\\<forall>x.\n      x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n      v \\<bullet> x = (0::'a))\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       v \\<in> carrier_vec n\n 2. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 3. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})", "then"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n \\<and>\n  fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n  (\\<forall>x.\n      x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n      v \\<bullet> x = (0::'a))", "show \"v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n \\<and>\n  fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n  (\\<forall>x.\n      x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n      v \\<bullet> x = (0::'a))\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)\n 2. \\<And>v.\n       v \\<in> carrier_vec n \\<and>\n       fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n       (\\<forall>u.\n           u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n           v \\<bullet> u = (0::'a)) \\<Longrightarrow>\n       fs ! i - v \\<in> local.span (gso ` {0..<i})", "from p"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n \\<and>\n  fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n  (\\<forall>x.\n      x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n      v \\<bullet> x = (0::'a))", "show \"fs ! i - v \\<in> span (gso ` {0..<i})\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n \\<and>\n  fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n  (\\<forall>x.\n      x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n      v \\<bullet> x = (0::'a))\n\ngoal (1 subgoal):\n 1. fs ! i - v \\<in> local.span (gso ` {0..<i})", "unfolding span_span[OF carr]"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n \\<and>\n  fs ! i - v \\<in> local.span (gso ` {0..<i}) \\<and>\n  (\\<forall>x.\n      x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n      v \\<bullet> x = (0::'a))\n\ngoal (1 subgoal):\n 1. fs ! i - v \\<in> local.span (gso ` {0..<i})", "by auto"], ["proof (state)\nthis:\n  fs ! i - v \\<in> local.span (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)", "fix xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)", "assume \"xa \\<in> gso ` {0..<i}\""], ["proof (state)\nthis:\n  xa \\<in> gso ` {0..<i}\n\ngoal (1 subgoal):\n 1. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)", "hence \"xa \\<in> span (gso ` {0..<i})\""], ["proof (prove)\nusing this:\n  xa \\<in> gso ` {0..<i}\n\ngoal (1 subgoal):\n 1. xa \\<in> local.span (gso ` {0..<i})", "using in_own_span[OF carr]"], ["proof (prove)\nusing this:\n  xa \\<in> gso ` {0..<i}\n  gso ` {0..<i} \\<subseteq> local.span (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. xa \\<in> local.span (gso ` {0..<i})", "by auto"], ["proof (state)\nthis:\n  xa \\<in> local.span (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. \\<And>v xa.\n       \\<lbrakk>v \\<in> carrier_vec n \\<and>\n                fs ! i - v\n                \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n                (\\<forall>u.\n                    u \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n                    v \\<bullet> u = (0::'a));\n        xa \\<in> gso ` {0..<i}\\<rbrakk>\n       \\<Longrightarrow> v \\<bullet> xa = (0::'a)", "thus \"v \\<bullet> xa = 0\""], ["proof (prove)\nusing this:\n  xa \\<in> local.span (gso ` {0..<i})\n\ngoal (1 subgoal):\n 1. v \\<bullet> xa = (0::'a)", "using p"], ["proof (prove)\nusing this:\n  xa \\<in> local.span (gso ` {0..<i})\n  v \\<in> carrier_vec n \\<and>\n  fs ! i - v \\<in> local.span (local.span (gso ` {0..<i})) \\<and>\n  (\\<forall>x.\n      x \\<in> local.span (gso ` {0..<i}) \\<longrightarrow>\n      v \\<bullet> x = (0::'a))\n\ngoal (1 subgoal):\n 1. v \\<bullet> xa = (0::'a)", "by auto"], ["proof (state)\nthis:\n  v \\<bullet> xa = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gso_is_oc_projection:\n  assumes \"i < m\"\n  shows \"is_oc_projection (gso i) (set (take i fs)) (fs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (set (take i fs)) (fs ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (set (take i fs)) (fs ! i)", "have [simp]: \"v \\<in> carrier_vec n\" if \"v \\<in> set (take i fs)\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "using that"], ["proof (prove)\nusing this:\n  v \\<in> set (take i fs)\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "by (meson contra_subsetD fs_carrier in_set_takeD)"], ["proof (state)\nthis:\n  ?v1 \\<in> set (take i fs) \\<Longrightarrow> ?v1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (set (take i fs)) (fs ! i)", "have \"span (gso ` {0..<i}) = span (set (take i fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (gso ` {0..<i}) = local.span (set (take i fs))", "by (rule partial_span) (auto simp add: assms less_or_eq_imp_le)"], ["proof (state)\nthis:\n  local.span (gso ` {0..<i}) = local.span (set (take i fs))\n\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (set (take i fs)) (fs ! i)", "moreover"], ["proof (state)\nthis:\n  local.span (gso ` {0..<i}) = local.span (set (take i fs))\n\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (set (take i fs)) (fs ! i)", "have \"is_oc_projection (gso i) (span (gso ` {0..<i})) (fs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (local.span (gso ` {0..<i})) (fs ! i)", "by (rule gso_oc_projection_span) (auto simp add: assms less_or_eq_imp_le)"], ["proof (state)\nthis:\n  is_oc_projection (gso i) (local.span (gso ` {0..<i})) (fs ! i)\n\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (set (take i fs)) (fs ! i)", "ultimately"], ["proof (chain)\npicking this:\n  local.span (gso ` {0..<i}) = local.span (set (take i fs))\n  is_oc_projection (gso i) (local.span (gso ` {0..<i})) (fs ! i)", "have \"is_oc_projection (gso i) (span (set (take i fs))) (fs ! i)\""], ["proof (prove)\nusing this:\n  local.span (gso ` {0..<i}) = local.span (set (take i fs))\n  is_oc_projection (gso i) (local.span (gso ` {0..<i})) (fs ! i)\n\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (local.span (set (take i fs))) (fs ! i)", "by auto"], ["proof (state)\nthis:\n  is_oc_projection (gso i) (local.span (set (take i fs))) (fs ! i)\n\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (set (take i fs)) (fs ! i)", "moreover"], ["proof (state)\nthis:\n  is_oc_projection (gso i) (local.span (set (take i fs))) (fs ! i)\n\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (set (take i fs)) (fs ! i)", "have \"set (take i fs) \\<subseteq> span (set (take i fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take i fs) \\<subseteq> local.span (set (take i fs))", "by (auto intro!: span_mem)"], ["proof (state)\nthis:\n  set (take i fs) \\<subseteq> local.span (set (take i fs))\n\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (set (take i fs)) (fs ! i)", "ultimately"], ["proof (chain)\npicking this:\n  is_oc_projection (gso i) (local.span (set (take i fs))) (fs ! i)\n  set (take i fs) \\<subseteq> local.span (set (take i fs))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_oc_projection (gso i) (local.span (set (take i fs))) (fs ! i)\n  set (take i fs) \\<subseteq> local.span (set (take i fs))\n\ngoal (1 subgoal):\n 1. is_oc_projection (gso i) (set (take i fs)) (fs ! i)", "unfolding is_oc_projection_def"], ["proof (prove)\nusing this:\n  gso i \\<in> carrier_vec n \\<and>\n  fs ! i - gso i \\<in> local.span (local.span (set (take i fs))) \\<and>\n  (\\<forall>u.\n      u \\<in> local.span (set (take i fs)) \\<longrightarrow>\n      gso i \\<bullet> u = (0::'a))\n  set (take i fs) \\<subseteq> local.span (set (take i fs))\n\ngoal (1 subgoal):\n 1. gso i \\<in> carrier_vec n \\<and>\n    fs ! i - gso i \\<in> local.span (set (take i fs)) \\<and>\n    (\\<forall>u.\n        u \\<in> set (take i fs) \\<longrightarrow>\n        gso i \\<bullet> u = (0::'a))", "by (subst (asm) span_span) (auto)"], ["proof (state)\nthis:\n  is_oc_projection (gso i) (set (take i fs)) (fs ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fi_scalar_prod_gso:\n  assumes i: \"i < m\" and j: \"j < m\" \n  shows \"fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "let ?mu = \"\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j\""], ["proof (state)\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "from i"], ["proof (chain)\npicking this:\n  i < length fs", "have list1: \"[0..< m] = [0..< Suc i] @ [Suc i ..< m]\""], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. [0..<length fs] = [0..<Suc i] @ [Suc i..<length fs]", "by (intro nth_equalityI, auto simp: nth_append, rename_tac j, case_tac \"j - i\", auto)"], ["proof (state)\nthis:\n  [0..<length fs] = [0..<Suc i] @ [Suc i..<length fs]\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "from j"], ["proof (chain)\npicking this:\n  j < length fs", "have list2: \"[0..< m] = [0..< j] @ [j] @ [Suc j ..< m]\""], ["proof (prove)\nusing this:\n  j < length fs\n\ngoal (1 subgoal):\n 1. [0..<length fs] = [0..<j] @ [j] @ [Suc j..<length fs]", "by (intro nth_equalityI, auto simp: nth_append, rename_tac k, case_tac \"k - j\", auto)"], ["proof (state)\nthis:\n  [0..<length fs] = [0..<j] @ [j] @ [Suc j..<length fs]\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "have \"fs ! i \\<bullet> gso j = sumlist (map ?mu [0..<Suc i]) \\<bullet> gso j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n       [0..<Suc i]) \\<bullet>\n    gso j", "unfolding fi_is_sum_of_mu_gso[OF i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n       [0..<Suc i]) \\<bullet>\n    gso j =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n       [0..<Suc i]) \\<bullet>\n    gso j", "by simp"], ["proof (state)\nthis:\n  fs ! i \\<bullet> gso j =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) \\<bullet>\n  gso j\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  fs ! i \\<bullet> gso j =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) \\<bullet>\n  gso j\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "have \"\\<dots> = (\\<Sum>v\\<leftarrow>map ?mu [0..<Suc i]. v \\<bullet> gso j) + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n       [0..<Suc i]) \\<bullet>\n    gso j =\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<Suc i]. v \\<bullet> gso j) +\n    (0::'a)", "by (subst scalar_prod_left_sum_distrib, insert gso_carrier assms, auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) \\<bullet>\n  gso j =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<Suc i]. v \\<bullet> gso j) +\n  (0::'a)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) \\<bullet>\n  gso j =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<Suc i]. v \\<bullet> gso j) +\n  (0::'a)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "have \"\\<dots> = (\\<Sum>v\\<leftarrow>map ?mu [0..<Suc i]. v \\<bullet> gso j) + (\\<Sum>v\\<leftarrow>map ?mu [Suc i..<m]. v \\<bullet> gso j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<Suc i]. v \\<bullet> gso j) +\n    (0::'a) =\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<Suc i]. v \\<bullet> gso j) +\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [Suc i..<length fs]. v \\<bullet> gso j)", "by (subst (3) sum_list_neutral, insert assms gso_carrier, auto intro!: orthogonal simp: \\<mu>.simps)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<Suc i]. v \\<bullet> gso j) +\n  (0::'a) =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<Suc i]. v \\<bullet> gso j) +\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [Suc i..<length fs]. v \\<bullet> gso j)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<Suc i]. v \\<bullet> gso j) +\n  (0::'a) =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<Suc i]. v \\<bullet> gso j) +\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [Suc i..<length fs]. v \\<bullet> gso j)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "have \"\\<dots> = (\\<Sum>v\\<leftarrow>map ?mu [0..< m]. v \\<bullet> gso j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<Suc i]. v \\<bullet> gso j) +\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [Suc i..<length fs]. v \\<bullet> gso j) =\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<length fs]. v \\<bullet> gso j)", "unfolding list1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<Suc i]. v \\<bullet> gso j) +\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [Suc i..<length fs]. v \\<bullet> gso j) =\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         ([0..<Suc i] @\n                          [Suc i..<length fs]). v \\<bullet> gso j)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<Suc i]. v \\<bullet> gso j) +\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [Suc i..<length fs]. v \\<bullet> gso j) =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<length fs]. v \\<bullet> gso j)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<Suc i]. v \\<bullet> gso j) +\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [Suc i..<length fs]. v \\<bullet> gso j) =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<length fs]. v \\<bullet> gso j)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "have \"\\<dots> = (\\<Sum>v\\<leftarrow>map ?mu [0..< j]. v \\<bullet> gso j) + ?mu j \\<bullet> gso j + (\\<Sum>v\\<leftarrow>map ?mu [Suc j..< m]. v \\<bullet> gso j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<length fs]. v \\<bullet> gso j) =\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<j]. v \\<bullet> gso j) +\n    (\\<mu> i j \\<cdot>\\<^sub>v gso j) \\<bullet> gso j +\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [Suc j..<length fs]. v \\<bullet> gso j)", "unfolding list2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         ([0..<j] @\n                          [j] @ [Suc j..<length fs]). v \\<bullet> gso j) =\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<j]. v \\<bullet> gso j) +\n    (\\<mu> i j \\<cdot>\\<^sub>v gso j) \\<bullet> gso j +\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [Suc j..<length fs]. v \\<bullet> gso j)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<length fs]. v \\<bullet> gso j) =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<j]. v \\<bullet> gso j) +\n  (\\<mu> i j \\<cdot>\\<^sub>v gso j) \\<bullet> gso j +\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [Suc j..<length fs]. v \\<bullet> gso j)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<length fs]. v \\<bullet> gso j) =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<j]. v \\<bullet> gso j) +\n  (\\<mu> i j \\<cdot>\\<^sub>v gso j) \\<bullet> gso j +\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [Suc j..<length fs]. v \\<bullet> gso j)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "have \"(\\<Sum>v\\<leftarrow>map ?mu [0..< j]. v \\<bullet> gso j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<j]. v \\<bullet> gso j) =\n    (0::'a)", "by (rule sum_list_neutral, insert assms gso_carrier, auto intro!: orthogonal)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<j]. v \\<bullet> gso j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [0..<j]. v \\<bullet> gso j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "have \"(\\<Sum>v\\<leftarrow>map ?mu [Suc j..< m]. v \\<bullet> gso j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [Suc j..<length fs]. v \\<bullet> gso j) =\n    (0::'a)", "by (rule sum_list_neutral, insert assms gso_carrier, auto intro!: orthogonal)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [Suc j..<length fs]. v \\<bullet> gso j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                       [Suc j..<length fs]. v \\<bullet> gso j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "have \"?mu j \\<bullet> gso j = \\<mu> i j * sq_norm (gso j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> i j \\<cdot>\\<^sub>v gso j) \\<bullet> gso j =\n    \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "using gso_carrier[OF j]"], ["proof (prove)\nusing this:\n  gso j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (\\<mu> i j \\<cdot>\\<^sub>v gso j) \\<bullet> gso j =\n    \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "by (simp add: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  (\\<mu> i j \\<cdot>\\<^sub>v gso j) \\<bullet> gso j =\n  \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  fs ! i \\<bullet> gso j =\n  (0::'a) + \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2 + (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  fs ! i \\<bullet> gso j =\n  (0::'a) + \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2 + (0::'a)\n\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  fs ! i \\<bullet> gso j = \\<mu> i j * \\<parallel>gso j\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gso_scalar_zero:\n  assumes \"k < m\" \"i < k\"\n  shows \"(gso k) \\<bullet> (fs ! i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso k \\<bullet> fs ! i = (0::'a)", "by (subst comm_scalar_prod[OF gso_carrier]; (subst fi_scalar_prod_gso)?,\n  insert assms, auto simp: \\<mu>.simps)"], ["", "lemma scalar_prod_lincomb_gso:\n  assumes k: \"k \\<le> m\"\n  shows \"sumlist (map (\\<lambda> i. g i \\<cdot>\\<^sub>v gso i) [0 ..< k]) \\<bullet> sumlist (map (\\<lambda> i. h i \\<cdot>\\<^sub>v gso i) [0 ..< k])\n    = sum_list (map (\\<lambda> i. g i * h i * (gso i \\<bullet> gso i)) [0 ..< k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "have id1: \"map (\\<lambda>i. g i \\<cdot>\\<^sub>v map (gso) [0..<m] ! i) [0..<k] = map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. g i \\<cdot>\\<^sub>v map gso [0..<length fs] ! i)\n     [0..<k] =\n    map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]", "using k"], ["proof (prove)\nusing this:\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. g i \\<cdot>\\<^sub>v map gso [0..<length fs] ! i)\n     [0..<k] =\n    map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>i. ?g1 i \\<cdot>\\<^sub>v map gso [0..<length fs] ! i)\n   [0..<k] =\n  map (\\<lambda>i. ?g1 i \\<cdot>\\<^sub>v gso i) [0..<k]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "have id2: \"(\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (map (gso) [0..<m] ! i \\<bullet> map (gso) [0..<m] ! i)) \n    = (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<\n                         k]. g i * h i *\n                             (map gso [0..<length fs] ! i \\<bullet>\n                              map gso [0..<length fs] ! i)) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "using k"], ["proof (prove)\nusing this:\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<\n                         k]. g i * h i *\n                             (map gso [0..<length fs] ! i \\<bullet>\n                              map gso [0..<length fs] ! i)) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "by (intro arg_cong[OF map_cong], auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<leftarrow>[0..<\n                       k]. g i * h i *\n                           (map gso [0..<length fs] ! i \\<bullet>\n                            map gso [0..<length fs] ! i)) =\n  (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "define gs where \"gs = map (gso) [0..<m]\""], ["proof (state)\nthis:\n  gs = map gso [0..<length fs]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "have gs_gso: \"gs ! i = gso i\" if \"i < k\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs ! i = gso i", "using that assms"], ["proof (prove)\nusing this:\n  i < k\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. gs ! i = gso i", "unfolding gs_def"], ["proof (prove)\nusing this:\n  i < k\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. map gso [0..<length fs] ! i = gso i", "by auto"], ["proof (state)\nthis:\n  ?i1 < k \\<Longrightarrow> gs ! ?i1 = gso ?i1\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "have \"M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet> M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) = \n        (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gs ! i \\<bullet> gs ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gs ! i \\<bullet> gs ! i))", "unfolding gs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v map gso [0..<length fs] ! i)\n       [0..<k]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>i. h i \\<cdot>\\<^sub>v map gso [0..<length fs] ! i)\n       [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<\n                         k]. g i * h i *\n                             (map gso [0..<length fs] ! i \\<bullet>\n                              map gso [0..<length fs] ! i))", "using  assms  orthogonal_gso"], ["proof (prove)\nusing this:\n  k \\<le> length fs\n  orthogonal (map gso [0..<length fs])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v map gso [0..<length fs] ! i)\n       [0..<k]) \\<bullet>\n    M.sumlist\n     (map (\\<lambda>i. h i \\<cdot>\\<^sub>v map gso [0..<length fs] ! i)\n       [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<\n                         k]. g i * h i *\n                             (map gso [0..<length fs] ! i \\<bullet>\n                              map gso [0..<length fs] ! i))", "by (intro scalar_prod_lincomb_orthogonal) auto"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n  (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gs ! i \\<bullet> gs ! i))\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "also"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k]) =\n  (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gs ! i \\<bullet> gs ! i))\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "have \"map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k] = map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k] =\n    map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]", "using gs_gso"], ["proof (prove)\nusing this:\n  ?i1 < k \\<Longrightarrow> gs ! ?i1 = gso ?i1\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k] =\n    map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]", "by (intro map_cong) (auto)"], ["proof (state)\nthis:\n  map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k] =\n  map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "also"], ["proof (state)\nthis:\n  map (\\<lambda>i. g i \\<cdot>\\<^sub>v gs ! i) [0..<k] =\n  map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "have \"map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k] = map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k] =\n    map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]", "using gs_gso"], ["proof (prove)\nusing this:\n  ?i1 < k \\<Longrightarrow> gs ! ?i1 = gso ?i1\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k] =\n    map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]", "by (intro map_cong) (auto)"], ["proof (state)\nthis:\n  map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k] =\n  map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "also"], ["proof (state)\nthis:\n  map (\\<lambda>i. h i \\<cdot>\\<^sub>v gs ! i) [0..<k] =\n  map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "have \"map (\\<lambda>i. g i * h i * (gs ! i \\<bullet> gs ! i)) [0..<k] = map (\\<lambda>i. g i * h i * (gso i \\<bullet> gso i)) [0..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. g i * h i * (gs ! i \\<bullet> gs ! i)) [0..<k] =\n    map (\\<lambda>i. g i * h i * (gso i \\<bullet> gso i)) [0..<k]", "using gs_gso"], ["proof (prove)\nusing this:\n  ?i1 < k \\<Longrightarrow> gs ! ?i1 = gso ?i1\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. g i * h i * (gs ! i \\<bullet> gs ! i)) [0..<k] =\n    map (\\<lambda>i. g i * h i * (gso i \\<bullet> gso i)) [0..<k]", "by (intro map_cong) (auto)"], ["proof (state)\nthis:\n  map (\\<lambda>i. g i * h i * (gs ! i \\<bullet> gs ! i)) [0..<k] =\n  map (\\<lambda>i. g i * h i * (gso i \\<bullet> gso i)) [0..<k]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "finally"], ["proof (chain)\npicking this:\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n  (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "show ?thesis"], ["proof (prove)\nusing this:\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n  (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n    (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))", "by simp"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. g i \\<cdot>\\<^sub>v gso i) [0..<k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. h i \\<cdot>\\<^sub>v gso i) [0..<k]) =\n  (\\<Sum>i\\<leftarrow>[0..<k]. g i * h i * (gso i \\<bullet> gso i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gso_times_self_is_norm:\n  assumes \"j < m\"\n  shows \"fs ! j \\<bullet> gso j = sq_norm (gso j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! j \\<bullet> gso j = \\<parallel>gso j\\<parallel>\\<^sup>2", "by (subst fi_scalar_prod_gso, insert assms, auto simp: \\<mu>.simps)"], ["", "(* Lemma 16.7 *)"], ["", "lemma gram_schmidt_short_vector: \n  assumes in_L: \"h \\<in> lattice_of fs - {0\\<^sub>v n}\" \n  shows \"\\<exists> i < m. \\<parallel>h\\<parallel>\\<^sup>2 \\<ge> \\<parallel>gso i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "from in_L"], ["proof (chain)\npicking this:\n  h \\<in> lattice_of fs - {0\\<^sub>v n}", "have non_0: \"h \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  h \\<in> lattice_of fs - {0\\<^sub>v n}\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  h \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "from in_L[unfolded lattice_of_def]"], ["proof (chain)\npicking this:\n  h \\<in> range\n           (\\<lambda>c.\n               M.sumlist\n                (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n                  [0..<length fs])) -\n          {0\\<^sub>v n}", "obtain lam where \n    h: \"h =  sumlist (map (\\<lambda> i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) [0 ..< length fs])\""], ["proof (prove)\nusing this:\n  h \\<in> range\n           (\\<lambda>c.\n               M.sumlist\n                (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n                  [0..<length fs])) -\n          {0\\<^sub>v n}\n\ngoal (1 subgoal):\n 1. (\\<And>lam.\n        h =\n        M.sumlist\n         (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n           [0..<length fs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  h =\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have in_L: \"h = sumlist (map (\\<lambda> i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) [0 ..< m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h =\n    M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [0..<length fs])", "unfolding length_map h"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [0..<length fs]) =\n    M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [0..<length fs])", "by (rule arg_cong[of _ _ sumlist], rule map_cong, auto)"], ["proof (state)\nthis:\n  h =\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "let ?n = \"[0 ..< m]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "let ?f = \"(\\<lambda> i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "let ?vs = \"map ?f ?n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "let ?P = \"\\<lambda> k. k < m \\<and> lam k \\<noteq> 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "define k where \"k = (GREATEST kk. ?P kk)\""], ["proof (state)\nthis:\n  k = (GREATEST kk. kk < length fs \\<and> lam kk \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "{"], ["proof (state)\nthis:\n  k = (GREATEST kk. kk < length fs \\<and> lam kk \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "assume *: \"\\<forall> i < m. lam i = 0\""], ["proof (state)\nthis:\n  \\<forall>i<length fs. lam i = 0\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have vs: \"?vs = map (\\<lambda> i. 0\\<^sub>v n) ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n     [0..<length fs] =\n    map (\\<lambda>i. 0\\<^sub>v n) [0..<length fs]", "by (rule map_cong, insert f_dim *, auto)"], ["proof (state)\nthis:\n  map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs] =\n  map (\\<lambda>i. 0\\<^sub>v n) [0..<length fs]\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"h = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h = 0\\<^sub>v n", "unfolding in_L vs"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. 0\\<^sub>v n) [0..<length fs]) = 0\\<^sub>v n", "by (rule sumlist_neutral, auto)"], ["proof (state)\nthis:\n  h = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "with non_0"], ["proof (chain)\npicking this:\n  h \\<noteq> 0\\<^sub>v n\n  h = 0\\<^sub>v n", "have False"], ["proof (prove)\nusing this:\n  h \\<noteq> 0\\<^sub>v n\n  h = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "}"], ["proof (state)\nthis:\n  \\<forall>i<length fs. lam i = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length fs. lam i = 0 \\<Longrightarrow> False", "obtain kk where \"?P kk\""], ["proof (prove)\nusing this:\n  \\<forall>i<length fs. lam i = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>kk.\n        kk < length fs \\<and> lam kk \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  kk < length fs \\<and> lam kk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "from GreatestI_nat[of ?P, OF this, of m]"], ["proof (chain)\npicking this:\n  (\\<And>y.\n      y < length fs \\<and> lam y \\<noteq> 0 \\<Longrightarrow>\n      y \\<le> length fs) \\<Longrightarrow>\n  (GREATEST k. k < length fs \\<and> lam k \\<noteq> 0) < length fs \\<and>\n  lam (GREATEST k. k < length fs \\<and> lam k \\<noteq> 0) \\<noteq> 0", "have Pk: \"?P k\""], ["proof (prove)\nusing this:\n  (\\<And>y.\n      y < length fs \\<and> lam y \\<noteq> 0 \\<Longrightarrow>\n      y \\<le> length fs) \\<Longrightarrow>\n  (GREATEST k. k < length fs \\<and> lam k \\<noteq> 0) < length fs \\<and>\n  lam (GREATEST k. k < length fs \\<and> lam k \\<noteq> 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k < length fs \\<and> lam k \\<noteq> 0", "unfolding k_def"], ["proof (prove)\nusing this:\n  (\\<And>y.\n      y < length fs \\<and> lam y \\<noteq> 0 \\<Longrightarrow>\n      y \\<le> length fs) \\<Longrightarrow>\n  (GREATEST k. k < length fs \\<and> lam k \\<noteq> 0) < length fs \\<and>\n  lam (GREATEST k. k < length fs \\<and> lam k \\<noteq> 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (GREATEST kk. kk < length fs \\<and> lam kk \\<noteq> 0)\n    < length fs \\<and>\n    lam (GREATEST kk. kk < length fs \\<and> lam kk \\<noteq> 0) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k < length fs \\<and> lam k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "hence kn: \"k < m\""], ["proof (prove)\nusing this:\n  k < length fs \\<and> lam k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k < length fs", "by auto"], ["proof (state)\nthis:\n  k < length fs\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "let ?gso = \"(\\<lambda>i j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have k: \"k < i \\<Longrightarrow> i < m \\<Longrightarrow> lam i = 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < i; i < length fs\\<rbrakk> \\<Longrightarrow> lam i = 0", "using Greatest_le_nat[of ?P i m, folded k_def]"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length fs \\<and> lam i \\<noteq> 0;\n   \\<And>y.\n      y < length fs \\<and> lam y \\<noteq> 0 \\<Longrightarrow>\n      y \\<le> length fs\\<rbrakk>\n  \\<Longrightarrow> i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < i; i < length fs\\<rbrakk> \\<Longrightarrow> lam i = 0", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>k < ?i1; ?i1 < length fs\\<rbrakk> \\<Longrightarrow> lam ?i1 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "define l where \"l = lam k\""], ["proof (state)\nthis:\n  l = lam k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "from Pk"], ["proof (chain)\npicking this:\n  k < length fs \\<and> lam k \\<noteq> 0", "have l: \"l \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k < length fs \\<and> lam k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0", "unfolding l_def"], ["proof (prove)\nusing this:\n  k < length fs \\<and> lam k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lam k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "define idx where \"idx = [0 ..< k]\""], ["proof (state)\nthis:\n  idx = [0..<k]\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have idx: \"\\<And> i. i \\<in> set idx \\<Longrightarrow> i < k\" \"\\<And> i. i \\<in> set idx \\<Longrightarrow> i < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> set idx \\<Longrightarrow> i < k) &&&\n    (\\<And>i. i \\<in> set idx \\<Longrightarrow> i < length fs)", "unfolding idx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> set [0..<k] \\<Longrightarrow> i < k) &&&\n    (\\<And>i. i \\<in> set [0..<k] \\<Longrightarrow> i < length fs)", "using kn"], ["proof (prove)\nusing this:\n  k < length fs\n\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> set [0..<k] \\<Longrightarrow> i < k) &&&\n    (\\<And>i. i \\<in> set [0..<k] \\<Longrightarrow> i < length fs)", "by auto"], ["proof (state)\nthis:\n  ?i1 \\<in> set idx \\<Longrightarrow> ?i1 < k\n  ?i1 \\<in> set idx \\<Longrightarrow> ?i1 < length fs\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "from Pk"], ["proof (chain)\npicking this:\n  k < length fs \\<and> lam k \\<noteq> 0", "have split: \"[0 ..< m] = idx @ [k] @ [Suc k ..< m]\""], ["proof (prove)\nusing this:\n  k < length fs \\<and> lam k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [0..<length fs] = idx @ [k] @ [Suc k..<length fs]", "unfolding idx_def"], ["proof (prove)\nusing this:\n  k < length fs \\<and> lam k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [0..<length fs] = [0..<k] @ [k] @ [Suc k..<length fs]", "by (metis append_Cons append_self_conv2 less_Suc_eq_le less_imp_add_positive upt_add_eq_append \n        upt_rec zero_less_Suc)"], ["proof (state)\nthis:\n  [0..<length fs] = idx @ [k] @ [Suc k..<length fs]\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "define gg where \"gg = sumlist \n    (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) + of_int l \\<cdot>\\<^sub>v sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx)\""], ["proof (state)\nthis:\n  gg =\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n  of_int l \\<cdot>\\<^sub>v\n  M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"h = sumlist ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h =\n    M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [0..<length fs])", "unfolding in_L"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [0..<length fs]) =\n    M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [0..<length fs])", ".."], ["proof (state)\nthis:\n  h =\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  h =\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> = sumlist ((map ?f idx @ [?f k]) @ map ?f [Suc k ..< m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [0..<length fs]) =\n    M.sumlist\n     ((map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n       [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) @\n      map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [Suc k..<length fs])", "unfolding split"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       (idx @ [k] @ [Suc k..<length fs])) =\n    M.sumlist\n     ((map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n       [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) @\n      map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [Suc k..<length fs])", "by auto"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n     [0..<length fs]) =\n  M.sumlist\n   ((map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n     [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) @\n    map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n     [Suc k..<length fs])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n     [0..<length fs]) =\n  M.sumlist\n   ((map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n     [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) @\n    map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n     [Suc k..<length fs])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> = sumlist (map ?f idx @ [?f k]) + sumlist (map ?f [Suc k ..< m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     ((map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n       [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) @\n      map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [Suc k..<length fs]) =\n    M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n      [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) +\n    M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [Suc k..<length fs])", "by (rule sumlist_append, auto intro!: f_carrier, insert Pk idx, auto)"], ["proof (state)\nthis:\n  M.sumlist\n   ((map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n     [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) @\n    map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n     [Suc k..<length fs]) =\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n    [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) +\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n     [Suc k..<length fs])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   ((map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n     [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) @\n    map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n     [Suc k..<length fs]) =\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n    [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) +\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n     [Suc k..<length fs])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"sumlist (map ?f [Suc k ..< m]) = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n       [Suc k..<length fs]) =\n    0\\<^sub>v n", "by (rule sumlist_neutral, auto simp: k)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n     [Suc k..<length fs]) =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n     [Suc k..<length fs]) =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"sumlist (map ?f idx @ [?f k]) = sumlist (map ?f idx) + ?f k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n      [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) =\n    M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n    of_int (lam k) \\<cdot>\\<^sub>v fs ! k", "by (subst sumlist_append, auto intro!: f_carrier, insert Pk idx, auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n    [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) =\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n  of_int (lam k) \\<cdot>\\<^sub>v fs ! k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx @\n    [of_int (lam k) \\<cdot>\\<^sub>v fs ! k]) =\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n  of_int (lam k) \\<cdot>\\<^sub>v fs ! k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"fs ! k = sumlist (map (?gso k) [0..<Suc k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! k =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) [0..<Suc k])", "using fi_is_sum_of_mu_gso[OF kn]"], ["proof (prove)\nusing this:\n  fs ! k =\n  M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. fs ! k =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) [0..<Suc k])", "by simp"], ["proof (state)\nthis:\n  fs ! k =\n  M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  fs ! k =\n  M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> = sumlist (map (?gso k) idx @ [gso k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) [0..<Suc k]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx @ [gso k])", "by (simp add: \\<mu>.simps[of k k] idx_def)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) [0..<Suc k]) =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx @ [gso k])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) [0..<Suc k]) =\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx @ [gso k])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> = sumlist (map (?gso k) idx) + gso k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx @ [gso k]) =\n    M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n    gso k", "by (subst sumlist_append, auto intro!: f_carrier, insert Pk idx, auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx @ [gso k]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) + gso k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx @ [gso k]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) + gso k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"of_int (lam k) \\<cdot>\\<^sub>v \\<dots> = of_int (lam k) \\<cdot>\\<^sub>v (sumlist (map (?gso k) idx)) \n    + of_int (lam k) \\<cdot>\\<^sub>v gso k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (lam k) \\<cdot>\\<^sub>v\n    (M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n     gso k) =\n    of_int (lam k) \\<cdot>\\<^sub>v\n    M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n    of_int (lam k) \\<cdot>\\<^sub>v gso k", "unfolding idx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (lam k) \\<cdot>\\<^sub>v\n    (M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) [0..<k]) +\n     gso k) =\n    of_int (lam k) \\<cdot>\\<^sub>v\n    M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) [0..<k]) +\n    of_int (lam k) \\<cdot>\\<^sub>v gso k", "by (rule smult_add_distrib_vec[OF sumlist_carrier], auto intro!: gso_carrier, insert kn, auto)"], ["proof (state)\nthis:\n  of_int (lam k) \\<cdot>\\<^sub>v\n  (M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n   gso k) =\n  of_int (lam k) \\<cdot>\\<^sub>v\n  M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n  of_int (lam k) \\<cdot>\\<^sub>v gso k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  h =\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n  (of_int (lam k) \\<cdot>\\<^sub>v\n   M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n   of_int (lam k) \\<cdot>\\<^sub>v gso k) +\n  0\\<^sub>v n", "have \"h = sumlist (map ?f idx) +\n       (of_int (lam k) \\<cdot>\\<^sub>v sumlist (map (?gso k) idx) + of_int (lam k) \\<cdot>\\<^sub>v gso k) + 0\\<^sub>v n \""], ["proof (prove)\nusing this:\n  h =\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n  (of_int (lam k) \\<cdot>\\<^sub>v\n   M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n   of_int (lam k) \\<cdot>\\<^sub>v gso k) +\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. h =\n    M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n    (of_int (lam k) \\<cdot>\\<^sub>v\n     M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n     of_int (lam k) \\<cdot>\\<^sub>v gso k) +\n    0\\<^sub>v n", "by simp"], ["proof (state)\nthis:\n  h =\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n  (of_int (lam k) \\<cdot>\\<^sub>v\n   M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n   of_int (lam k) \\<cdot>\\<^sub>v gso k) +\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  h =\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n  (of_int (lam k) \\<cdot>\\<^sub>v\n   M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n   of_int (lam k) \\<cdot>\\<^sub>v gso k) +\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> = gg + of_int l \\<cdot>\\<^sub>v gso k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n    (of_int (lam k) \\<cdot>\\<^sub>v\n     M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n     of_int (lam k) \\<cdot>\\<^sub>v gso k) +\n    0\\<^sub>v n =\n    gg + of_int l \\<cdot>\\<^sub>v gso k", "unfolding gg_def l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n    (of_int (lam k) \\<cdot>\\<^sub>v\n     M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n     of_int (lam k) \\<cdot>\\<^sub>v gso k) +\n    0\\<^sub>v n =\n    M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n    of_int (lam k) \\<cdot>\\<^sub>v\n    M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n    of_int (lam k) \\<cdot>\\<^sub>v gso k", "by (rule eq_vecI, insert idx kn, auto simp: sumlist_vec_index,\n      subst index_add_vec, auto simp: sumlist_dim kn, subst sumlist_dim, auto)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n  (of_int (lam k) \\<cdot>\\<^sub>v\n   M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) +\n   of_int (lam k) \\<cdot>\\<^sub>v gso k) +\n  0\\<^sub>v n =\n  gg + of_int l \\<cdot>\\<^sub>v gso k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  h = gg + of_int l \\<cdot>\\<^sub>v gso k", "have hgg: \"h = gg + of_int l \\<cdot>\\<^sub>v gso k\""], ["proof (prove)\nusing this:\n  h = gg + of_int l \\<cdot>\\<^sub>v gso k\n\ngoal (1 subgoal):\n 1. h = gg + of_int l \\<cdot>\\<^sub>v gso k", "."], ["proof (state)\nthis:\n  h = gg + of_int l \\<cdot>\\<^sub>v gso k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "let ?k = \"[0 ..< k]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "define R where \"R = {gg. \\<exists> nu. gg = sumlist (map (\\<lambda> i. nu i \\<cdot>\\<^sub>v gso i) idx)}\""], ["proof (state)\nthis:\n  R =\n  {gg.\n   \\<exists>nu.\n      gg = M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)}\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "{"], ["proof (state)\nthis:\n  R =\n  {gg.\n   \\<exists>nu.\n      gg = M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)}\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "fix nu"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"dim_vec (sumlist (map (\\<lambda> i. nu i \\<cdot>\\<^sub>v gso i) idx)) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)) =\n    n", "by (rule sumlist_dim, insert kn, auto simp: idx_def)"], ["proof (state)\nthis:\n  dim_vec (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)) = n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "}"], ["proof (state)\nthis:\n  dim_vec (M.sumlist (map (\\<lambda>i. ?nu3 i \\<cdot>\\<^sub>v gso i) idx)) =\n  n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "note dim_nu[simp] = this"], ["proof (state)\nthis:\n  dim_vec (M.sumlist (map (\\<lambda>i. ?nu3 i \\<cdot>\\<^sub>v gso i) idx)) =\n  n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "define kk where \"kk = ?k\""], ["proof (state)\nthis:\n  kk = [0..<k]\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "{"], ["proof (state)\nthis:\n  kk = [0..<k]\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "assume \"v \\<in> R\""], ["proof (state)\nthis:\n  v \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  v \\<in> R", "obtain nu where v: \"v = sumlist (map (\\<lambda> i. nu i \\<cdot>\\<^sub>v gso i) idx)\""], ["proof (prove)\nusing this:\n  v \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>nu.\n        v =\n        M.sumlist\n         (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i)\n           idx) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding R_def"], ["proof (prove)\nusing this:\n  v \\<in> {gg.\n           \\<exists>nu.\n              gg =\n              M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)}\n\ngoal (1 subgoal):\n 1. (\\<And>nu.\n        v =\n        M.sumlist\n         (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i)\n           idx) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v = M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"dim_vec v = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec v = n", "unfolding gg_def v"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)) =\n    n", "by simp"], ["proof (state)\nthis:\n  dim_vec v = n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "}"], ["proof (state)\nthis:\n  ?v3 \\<in> R \\<Longrightarrow> dim_vec ?v3 = n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "note dim_R = this"], ["proof (state)\nthis:\n  ?v3 \\<in> R \\<Longrightarrow> dim_vec ?v3 = n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "{"], ["proof (state)\nthis:\n  ?v3 \\<in> R \\<Longrightarrow> dim_vec ?v3 = n\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "fix v1 v2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "assume \"v1 \\<in> R\" \"v2 \\<in> R\""], ["proof (state)\nthis:\n  v1 \\<in> R\n  v2 \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  v1 \\<in> R\n  v2 \\<in> R", "obtain nu1 nu2 where v1: \"v1 = sumlist (map (\\<lambda> i. nu1 i \\<cdot>\\<^sub>v gso i) idx)\" and\n      v2: \"v2 = sumlist (map (\\<lambda> i. nu2 i \\<cdot>\\<^sub>v gso i) idx)\""], ["proof (prove)\nusing this:\n  v1 \\<in> R\n  v2 \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>nu1 nu2.\n        \\<lbrakk>v1 =\n                 M.sumlist\n                  (map (\\<lambda>i. nu1 i \\<cdot>\\<^sub>v gso i) idx);\n         v2 =\n         M.sumlist\n          (map (\\<lambda>i. nu2 i \\<cdot>\\<^sub>v gso i) idx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding R_def"], ["proof (prove)\nusing this:\n  v1 \\<in> {gg.\n            \\<exists>nu.\n               gg =\n               M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)}\n  v2 \\<in> {gg.\n            \\<exists>nu.\n               gg =\n               M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)}\n\ngoal (1 subgoal):\n 1. (\\<And>nu1 nu2.\n        \\<lbrakk>v1 =\n                 M.sumlist\n                  (map (\\<lambda>i. nu1 i \\<cdot>\\<^sub>v gso i) idx);\n         v2 =\n         M.sumlist\n          (map (\\<lambda>i. nu2 i \\<cdot>\\<^sub>v gso i) idx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v1 = M.sumlist (map (\\<lambda>i. nu1 i \\<cdot>\\<^sub>v gso i) idx)\n  v2 = M.sumlist (map (\\<lambda>i. nu2 i \\<cdot>\\<^sub>v gso i) idx)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"v1 + v2 \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 + v2 \\<in> R", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 + v2\n    \\<in> {gg.\n           \\<exists>nu.\n              gg =\n              M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)}", "by (standard, rule exI[of _ \"\\<lambda> i. nu1 i + nu2 i\"], unfold v1 v2, rule eq_vecI, \n        (subst sumlist_vec_index, insert idx, auto intro!: gso_carrier simp: o_def)+, \n        unfold sum_list_addf[symmetric], induct idx, auto simp: algebra_simps)"], ["proof (state)\nthis:\n  v1 + v2 \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v1.3 \\<in> R; ?v2.3 \\<in> R\\<rbrakk>\n  \\<Longrightarrow> ?v1.3 + ?v2.3 \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "note add_R = this"], ["proof (state)\nthis:\n  \\<lbrakk>?v1.3 \\<in> R; ?v2.3 \\<in> R\\<rbrakk>\n  \\<Longrightarrow> ?v1.3 + ?v2.3 \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"gg \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gg \\<in> R", "unfolding gg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx) +\n    of_int l \\<cdot>\\<^sub>v\n    M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx)\n    \\<in> R", "proof (rule add_R)"], ["proof (state)\ngoal (2 subgoals):\n 1. M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx)\n    \\<in> R\n 2. of_int l \\<cdot>\\<^sub>v\n    M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx)\n    \\<in> R", "show \"of_int l \\<cdot>\\<^sub>v sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l \\<cdot>\\<^sub>v\n    M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx)\n    \\<in> R", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l \\<cdot>\\<^sub>v\n    M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx)\n    \\<in> {gg.\n           \\<exists>nu.\n              gg =\n              M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)}", "by (standard, rule exI[of _ \"\\<lambda>i. of_int l * \\<mu> k i\"], rule eq_vecI,\n       (subst sumlist_vec_index, insert idx, auto intro!: gso_carrier simp: o_def)+, \n       induct idx, auto simp: algebra_simps)"], ["proof (state)\nthis:\n  of_int l \\<cdot>\\<^sub>v\n  M.sumlist (map (\\<lambda>j. \\<mu> k j \\<cdot>\\<^sub>v gso j) idx)\n  \\<in> R\n\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx)\n    \\<in> R", "show \"sumlist (map ?f idx) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx)\n    \\<in> R", "using idx"], ["proof (prove)\nusing this:\n  ?i1 \\<in> set idx \\<Longrightarrow> ?i1 < k\n  ?i1 \\<in> set idx \\<Longrightarrow> ?i1 < length fs\n\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx)\n    \\<in> R", "proof (induct idx)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i. i \\<in> set [] \\<Longrightarrow> i < k;\n     \\<And>i. i \\<in> set [] \\<Longrightarrow> i < length fs\\<rbrakk>\n    \\<Longrightarrow> M.sumlist\n                       (map (\\<lambda>i.\n                                of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                         [])\n                      \\<in> R\n 2. \\<And>a idx.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i \\<in> set idx \\<Longrightarrow> i < k;\n                 \\<And>i.\n                    i \\<in> set idx \\<Longrightarrow> i < length fs\\<rbrakk>\n                \\<Longrightarrow> M.sumlist\n                                   (map (\\<lambda>i.\n      of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                                     idx)\n                                  \\<in> R;\n        \\<And>i. i \\<in> set (a # idx) \\<Longrightarrow> i < k;\n        \\<And>i.\n           i \\<in> set (a # idx) \\<Longrightarrow> i < length fs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i.\n                                   of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                            (a # idx))\n                         \\<in> R", "case Nil"], ["proof (state)\nthis:\n  ?i1 \\<in> set [] \\<Longrightarrow> ?i1 < k\n  ?i1 \\<in> set [] \\<Longrightarrow> ?i1 < length fs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i. i \\<in> set [] \\<Longrightarrow> i < k;\n     \\<And>i. i \\<in> set [] \\<Longrightarrow> i < length fs\\<rbrakk>\n    \\<Longrightarrow> M.sumlist\n                       (map (\\<lambda>i.\n                                of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                         [])\n                      \\<in> R\n 2. \\<And>a idx.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i \\<in> set idx \\<Longrightarrow> i < k;\n                 \\<And>i.\n                    i \\<in> set idx \\<Longrightarrow> i < length fs\\<rbrakk>\n                \\<Longrightarrow> M.sumlist\n                                   (map (\\<lambda>i.\n      of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                                     idx)\n                                  \\<in> R;\n        \\<And>i. i \\<in> set (a # idx) \\<Longrightarrow> i < k;\n        \\<And>i.\n           i \\<in> set (a # idx) \\<Longrightarrow> i < length fs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i.\n                                   of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                            (a # idx))\n                         \\<in> R", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) [])\n    \\<in> R", "by (simp add: R_def, intro exI[of _ \"\\<lambda> i. 0\"], rule eq_vecI,\n        (subst sumlist_vec_index, insert idx, auto intro!: gso_carrier simp: o_def)+, \n        induct idx, auto)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) [])\n  \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>a idx.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i \\<in> set idx \\<Longrightarrow> i < k;\n                 \\<And>i.\n                    i \\<in> set idx \\<Longrightarrow> i < length fs\\<rbrakk>\n                \\<Longrightarrow> M.sumlist\n                                   (map (\\<lambda>i.\n      of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                                     idx)\n                                  \\<in> R;\n        \\<And>i. i \\<in> set (a # idx) \\<Longrightarrow> i < k;\n        \\<And>i.\n           i \\<in> set (a # idx) \\<Longrightarrow> i < length fs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i.\n                                   of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                            (a # idx))\n                         \\<in> R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a idx.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i \\<in> set idx \\<Longrightarrow> i < k;\n                 \\<And>i.\n                    i \\<in> set idx \\<Longrightarrow> i < length fs\\<rbrakk>\n                \\<Longrightarrow> M.sumlist\n                                   (map (\\<lambda>i.\n      of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                                     idx)\n                                  \\<in> R;\n        \\<And>i. i \\<in> set (a # idx) \\<Longrightarrow> i < k;\n        \\<And>i.\n           i \\<in> set (a # idx) \\<Longrightarrow> i < length fs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i.\n                                   of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                            (a # idx))\n                         \\<in> R", "case (Cons i idxs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i. i \\<in> set idxs \\<Longrightarrow> i < k;\n   \\<And>i. i \\<in> set idxs \\<Longrightarrow> i < length fs\\<rbrakk>\n  \\<Longrightarrow> M.sumlist\n                     (map (\\<lambda>i.\n                              of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                       idxs)\n                    \\<in> R\n  ?i1 \\<in> set (i # idxs) \\<Longrightarrow> ?i1 < k\n  ?i1 \\<in> set (i # idxs) \\<Longrightarrow> ?i1 < length fs\n\ngoal (1 subgoal):\n 1. \\<And>a idx.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i \\<in> set idx \\<Longrightarrow> i < k;\n                 \\<And>i.\n                    i \\<in> set idx \\<Longrightarrow> i < length fs\\<rbrakk>\n                \\<Longrightarrow> M.sumlist\n                                   (map (\\<lambda>i.\n      of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                                     idx)\n                                  \\<in> R;\n        \\<And>i. i \\<in> set (a # idx) \\<Longrightarrow> i < k;\n        \\<And>i.\n           i \\<in> set (a # idx) \\<Longrightarrow> i < length fs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i.\n                                   of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                            (a # idx))\n                         \\<in> R", "have \"sumlist (map ?f (i # idxs)) = sumlist ([?f i] @ map ?f idxs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) (i # idxs)) =\n    M.sumlist\n     ([of_int (lam i) \\<cdot>\\<^sub>v fs ! i] @\n      map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs)", "by simp"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) (i # idxs)) =\n  M.sumlist\n   ([of_int (lam i) \\<cdot>\\<^sub>v fs ! i] @\n    map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs)\n\ngoal (1 subgoal):\n 1. \\<And>a idx.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i \\<in> set idx \\<Longrightarrow> i < k;\n                 \\<And>i.\n                    i \\<in> set idx \\<Longrightarrow> i < length fs\\<rbrakk>\n                \\<Longrightarrow> M.sumlist\n                                   (map (\\<lambda>i.\n      of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                                     idx)\n                                  \\<in> R;\n        \\<And>i. i \\<in> set (a # idx) \\<Longrightarrow> i < k;\n        \\<And>i.\n           i \\<in> set (a # idx) \\<Longrightarrow> i < length fs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i.\n                                   of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                            (a # idx))\n                         \\<in> R", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) (i # idxs)) =\n  M.sumlist\n   ([of_int (lam i) \\<cdot>\\<^sub>v fs ! i] @\n    map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs)\n\ngoal (1 subgoal):\n 1. \\<And>a idx.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i \\<in> set idx \\<Longrightarrow> i < k;\n                 \\<And>i.\n                    i \\<in> set idx \\<Longrightarrow> i < length fs\\<rbrakk>\n                \\<Longrightarrow> M.sumlist\n                                   (map (\\<lambda>i.\n      of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                                     idx)\n                                  \\<in> R;\n        \\<And>i. i \\<in> set (a # idx) \\<Longrightarrow> i < k;\n        \\<And>i.\n           i \\<in> set (a # idx) \\<Longrightarrow> i < length fs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i.\n                                   of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                            (a # idx))\n                         \\<in> R", "have \"\\<dots> = ?f i + sumlist (map ?f idxs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     ([of_int (lam i) \\<cdot>\\<^sub>v fs ! i] @\n      map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs) =\n    of_int (lam i) \\<cdot>\\<^sub>v fs ! i +\n    M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs)", "by (subst sumlist_append, insert Cons(3), auto intro!: f_carrier)"], ["proof (state)\nthis:\n  M.sumlist\n   ([of_int (lam i) \\<cdot>\\<^sub>v fs ! i] @\n    map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs) =\n  of_int (lam i) \\<cdot>\\<^sub>v fs ! i +\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs)\n\ngoal (1 subgoal):\n 1. \\<And>a idx.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i \\<in> set idx \\<Longrightarrow> i < k;\n                 \\<And>i.\n                    i \\<in> set idx \\<Longrightarrow> i < length fs\\<rbrakk>\n                \\<Longrightarrow> M.sumlist\n                                   (map (\\<lambda>i.\n      of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                                     idx)\n                                  \\<in> R;\n        \\<And>i. i \\<in> set (a # idx) \\<Longrightarrow> i < k;\n        \\<And>i.\n           i \\<in> set (a # idx) \\<Longrightarrow> i < length fs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i.\n                                   of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                            (a # idx))\n                         \\<in> R", "finally"], ["proof (chain)\npicking this:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) (i # idxs)) =\n  of_int (lam i) \\<cdot>\\<^sub>v fs ! i +\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs)", "have id: \"sumlist (map ?f (i # idxs)) = ?f i + sumlist (map ?f idxs)\""], ["proof (prove)\nusing this:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) (i # idxs)) =\n  of_int (lam i) \\<cdot>\\<^sub>v fs ! i +\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs)\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) (i # idxs)) =\n    of_int (lam i) \\<cdot>\\<^sub>v fs ! i +\n    M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs)", "."], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) (i # idxs)) =\n  of_int (lam i) \\<cdot>\\<^sub>v fs ! i +\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs)\n\ngoal (1 subgoal):\n 1. \\<And>a idx.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i \\<in> set idx \\<Longrightarrow> i < k;\n                 \\<And>i.\n                    i \\<in> set idx \\<Longrightarrow> i < length fs\\<rbrakk>\n                \\<Longrightarrow> M.sumlist\n                                   (map (\\<lambda>i.\n      of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                                     idx)\n                                  \\<in> R;\n        \\<And>i. i \\<in> set (a # idx) \\<Longrightarrow> i < k;\n        \\<And>i.\n           i \\<in> set (a # idx) \\<Longrightarrow> i < length fs\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map (\\<lambda>i.\n                                   of_int (lam i) \\<cdot>\\<^sub>v fs ! i)\n                            (a # idx))\n                         \\<in> R", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) (i # idxs))\n    \\<in> R", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i +\n    M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idxs)\n    \\<in> R", "proof (rule add_R[OF _ Cons(1)[OF Cons(2-3)]])"], ["proof (state)\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)\n 3. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)", "from Cons(2-3)"], ["proof (chain)\npicking this:\n  ?i1 \\<in> set (i # idxs) \\<Longrightarrow> ?i1 < k\n  ?i1 \\<in> set (i # idxs) \\<Longrightarrow> ?i1 < length fs", "have i: \"i < m\" \"i < k\""], ["proof (prove)\nusing this:\n  ?i1 \\<in> set (i # idxs) \\<Longrightarrow> ?i1 < k\n  ?i1 \\<in> set (i # idxs) \\<Longrightarrow> ?i1 < length fs\n\ngoal (1 subgoal):\n 1. i < length fs &&& i < k", "by auto"], ["proof (state)\nthis:\n  i < length fs\n  i < k\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)\n 3. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)", "hence idx_split: \"idx = [0 ..< Suc i] @ [Suc i ..< k]\""], ["proof (prove)\nusing this:\n  i < length fs\n  i < k\n\ngoal (1 subgoal):\n 1. idx = [0..<Suc i] @ [Suc i..<k]", "unfolding idx_def"], ["proof (prove)\nusing this:\n  i < length fs\n  i < k\n\ngoal (1 subgoal):\n 1. [0..<k] = [0..<Suc i] @ [Suc i..<k]", "by (metis Suc_lessI append_Nil2 less_imp_add_positive upt_add_eq_append upt_rec zero_le)"], ["proof (state)\nthis:\n  idx = [0..<Suc i] @ [Suc i..<k]\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)\n 3. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)", "{"], ["proof (state)\nthis:\n  idx = [0..<Suc i] @ [Suc i..<k]\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)\n 3. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)", "fix j"], ["proof (state)\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)\n 3. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)", "assume j: \"j < n\""], ["proof (state)\nthis:\n  j < n\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)\n 3. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)", "define idxs where \"idxs = [0 ..< Suc i]\""], ["proof (state)\nthis:\n  idxs = [0..<Suc i]\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)\n 3. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)", "let ?f = \"\\<lambda> x. ((if x < Suc i then of_int (lam i) * \\<mu> i x else 0) \\<cdot>\\<^sub>v gso x) $ j\""], ["proof (state)\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)\n 3. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)", "have \"(\\<Sum>x\\<leftarrow>idx. ?f x) = (\\<Sum>x\\<leftarrow>[0 ..< Suc i]. ?f x) + (\\<Sum>x\\<leftarrow> [Suc i ..< k]. ?f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>idx. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                               else (0::'a)) \\<cdot>\\<^sub>v\n                              gso x) $\n                             j) =\n    (\\<Sum>x\\<leftarrow>[0..<\n                         Suc i]. ((if x < Suc i\n                                   then of_int (lam i) * \\<mu> i x\n                                   else (0::'a)) \\<cdot>\\<^sub>v\n                                  gso x) $\n                                 j) +\n    (\\<Sum>x\\<leftarrow>[Suc i..<\n                         k]. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                               else (0::'a)) \\<cdot>\\<^sub>v\n                              gso x) $\n                             j)", "unfolding idx_split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<Suc i] @\n                        [Suc i..<\n                         k]. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                               else (0::'a)) \\<cdot>\\<^sub>v\n                              gso x) $\n                             j) =\n    (\\<Sum>x\\<leftarrow>[0..<\n                         Suc i]. ((if x < Suc i\n                                   then of_int (lam i) * \\<mu> i x\n                                   else (0::'a)) \\<cdot>\\<^sub>v\n                                  gso x) $\n                                 j) +\n    (\\<Sum>x\\<leftarrow>[Suc i..<\n                         k]. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                               else (0::'a)) \\<cdot>\\<^sub>v\n                              gso x) $\n                             j)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>idx. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                             else (0::'a)) \\<cdot>\\<^sub>v\n                            gso x) $\n                           j) =\n  (\\<Sum>x\\<leftarrow>[0..<\n                       Suc i]. ((if x < Suc i\n                                 then of_int (lam i) * \\<mu> i x\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n                                gso x) $\n                               j) +\n  (\\<Sum>x\\<leftarrow>[Suc i..<\n                       k]. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                             else (0::'a)) \\<cdot>\\<^sub>v\n                            gso x) $\n                           j)\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)\n 3. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>idx. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                             else (0::'a)) \\<cdot>\\<^sub>v\n                            gso x) $\n                           j) =\n  (\\<Sum>x\\<leftarrow>[0..<\n                       Suc i]. ((if x < Suc i\n                                 then of_int (lam i) * \\<mu> i x\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n                                gso x) $\n                               j) +\n  (\\<Sum>x\\<leftarrow>[Suc i..<\n                       k]. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                             else (0::'a)) \\<cdot>\\<^sub>v\n                            gso x) $\n                           j)\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)\n 3. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)", "have \"(\\<Sum>x\\<leftarrow> [Suc i ..< k]. ?f x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[Suc i..<\n                         k]. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                               else (0::'a)) \\<cdot>\\<^sub>v\n                              gso x) $\n                             j) =\n    (0::'a)", "by (rule sum_list_neutral, insert j kn, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>[Suc i..<\n                       k]. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                             else (0::'a)) \\<cdot>\\<^sub>v\n                            gso x) $\n                           j) =\n  (0::'a)\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)\n 3. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>[Suc i..<\n                       k]. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                             else (0::'a)) \\<cdot>\\<^sub>v\n                            gso x) $\n                           j) =\n  (0::'a)\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)\n 3. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)", "have \"(\\<Sum>x\\<leftarrow>[0 ..< Suc i]. ?f x) = (\\<Sum>x\\<leftarrow>idxs. of_int (lam i) * (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<\n                         Suc i]. ((if x < Suc i\n                                   then of_int (lam i) * \\<mu> i x\n                                   else (0::'a)) \\<cdot>\\<^sub>v\n                                  gso x) $\n                                 j) =\n    (\\<Sum>x\\<leftarrow>idxs. of_int (lam i) *\n                              (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j)", "unfolding idxs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>[0..<\n                         Suc i]. ((if x < Suc i\n                                   then of_int (lam i) * \\<mu> i x\n                                   else (0::'a)) \\<cdot>\\<^sub>v\n                                  gso x) $\n                                 j) =\n    (\\<Sum>x\\<leftarrow>[0..<\n                         Suc i]. of_int (lam i) *\n                                 (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j)", "by (rule arg_cong[of _ _ sum_list], rule map_cong[OF refl], \n                subst index_smult_vec, insert j i kn, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>[0..<\n                       Suc i]. ((if x < Suc i\n                                 then of_int (lam i) * \\<mu> i x\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n                                gso x) $\n                               j) =\n  (\\<Sum>x\\<leftarrow>idxs. of_int (lam i) *\n                            (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j)\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)\n 3. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>[0..<\n                       Suc i]. ((if x < Suc i\n                                 then of_int (lam i) * \\<mu> i x\n                                 else (0::'a)) \\<cdot>\\<^sub>v\n                                gso x) $\n                               j) =\n  (\\<Sum>x\\<leftarrow>idxs. of_int (lam i) *\n                            (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j)\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)\n 3. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)", "have \"\\<dots> = of_int (lam i) * ((\\<Sum>x\\<leftarrow>[0..<Suc i]. (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>idxs. of_int (lam i) *\n                              (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j) =\n    of_int (lam i) *\n    (\\<Sum>x\\<leftarrow>[0..<Suc i]. (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j)", "unfolding idxs_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>idxs. of_int (lam i) *\n                              (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j) =\n    of_int (lam i) *\n    (\\<Sum>x\\<leftarrow>idxs. (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j)", "by (induct idxs, auto simp: algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>idxs. of_int (lam i) *\n                            (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j) =\n  of_int (lam i) *\n  (\\<Sum>x\\<leftarrow>[0..<Suc i]. (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j)\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)\n 3. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<leftarrow>idx. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                             else (0::'a)) \\<cdot>\\<^sub>v\n                            gso x) $\n                           j) =\n  of_int (lam i) *\n  (\\<Sum>x\\<leftarrow>[0..<Suc i]. (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j) +\n  (0::'a)", "have \"(\\<Sum>x\\<leftarrow>idx. ?f x) = of_int (lam i) * ((\\<Sum>x\\<leftarrow>[0..<Suc i]. (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j))\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<leftarrow>idx. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                             else (0::'a)) \\<cdot>\\<^sub>v\n                            gso x) $\n                           j) =\n  of_int (lam i) *\n  (\\<Sum>x\\<leftarrow>[0..<Suc i]. (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j) +\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>idx. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                               else (0::'a)) \\<cdot>\\<^sub>v\n                              gso x) $\n                             j) =\n    of_int (lam i) *\n    (\\<Sum>x\\<leftarrow>[0..<Suc i]. (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>idx. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                             else (0::'a)) \\<cdot>\\<^sub>v\n                            gso x) $\n                           j) =\n  of_int (lam i) *\n  (\\<Sum>x\\<leftarrow>[0..<Suc i]. (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ j)\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)\n 3. \\<And>ia.\n       ia \\<in> set idxs__ \\<Longrightarrow> ia \\<in> set (i # idxs__)", "}"], ["proof (state)\nthis:\n  ?j3 < n \\<Longrightarrow>\n  (\\<Sum>x\\<leftarrow>idx. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                             else (0::'a)) \\<cdot>\\<^sub>v\n                            gso x) $\n                           ?j3) =\n  of_int (lam i) *\n  (\\<Sum>x\\<leftarrow>[0..<Suc i]. (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ ?j3)\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)\n 3. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)", "note main = this"], ["proof (state)\nthis:\n  ?j3 < n \\<Longrightarrow>\n  (\\<Sum>x\\<leftarrow>idx. ((if x < Suc i then of_int (lam i) * \\<mu> i x\n                             else (0::'a)) \\<cdot>\\<^sub>v\n                            gso x) $\n                           ?j3) =\n  of_int (lam i) *\n  (\\<Sum>x\\<leftarrow>[0..<Suc i]. (\\<mu> i x \\<cdot>\\<^sub>v gso x) $ ?j3)\n\ngoal (3 subgoals):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n 2. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)\n 3. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)", "show \"?f i \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R", "unfolding fi_is_sum_of_mu_gso[OF i(1)] R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (lam i) \\<cdot>\\<^sub>v\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])\n    \\<in> {gg.\n           \\<exists>nu.\n              gg =\n              M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)}", "apply (standard, rule exI[of _ \"\\<lambda> j. if j < Suc i then of_int (lam i) * \\<mu> i j else 0\"], rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec\n             (M.sumlist\n               (map (\\<lambda>ia.\n                        (if ia < Suc i then of_int (lam i) * \\<mu> i ia\n                         else (0::'a)) \\<cdot>\\<^sub>v\n                        gso ia)\n                 idx)) \\<Longrightarrow>\n       (of_int (lam i) \\<cdot>\\<^sub>v\n        M.sumlist\n         (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])) $\n       ia =\n       M.sumlist\n        (map (\\<lambda>ia.\n                 (if ia < Suc i then of_int (lam i) * \\<mu> i ia\n                  else (0::'a)) \\<cdot>\\<^sub>v\n                 gso ia)\n          idx) $\n       ia\n 2. dim_vec\n     (of_int (lam i) \\<cdot>\\<^sub>v\n      M.sumlist\n       (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])) =\n    dim_vec\n     (M.sumlist\n       (map (\\<lambda>ia.\n                (if ia < Suc i then of_int (lam i) * \\<mu> i ia\n                 else (0::'a)) \\<cdot>\\<^sub>v\n                gso ia)\n         idx))", "apply (subst sumlist_vec_index, insert idx i, auto intro!: gso_carrier sumlist_dim simp: o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>ia < n; \\<And>i. i \\<in> set idx \\<Longrightarrow> i < k;\n        \\<And>i. i \\<in> set idx \\<Longrightarrow> i < length fs;\n        i < length fs; i < k\\<rbrakk>\n       \\<Longrightarrow> (of_int (lam i) \\<cdot>\\<^sub>v\n                          M.sumlist\n                           (map (\\<lambda>j.\n                                    \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                             [0..<i] @\n                            [\\<mu> i i \\<cdot>\\<^sub>v gso i])) $\n                         ia =\n                         (\\<Sum>x\\<leftarrow>idx. ((if x < Suc i\n              then of_int (lam i) * \\<mu> i x else (0::'a)) \\<cdot>\\<^sub>v\n             gso x) $\n            ia)", "apply (subst index_smult_vec, subst sumlist_dim, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>ia < n; \\<And>i. i \\<in> set idx \\<Longrightarrow> i < k;\n        \\<And>i. i \\<in> set idx \\<Longrightarrow> i < length fs;\n        i < length fs; i < k\\<rbrakk>\n       \\<Longrightarrow> of_int (lam i) *\n                         M.sumlist\n                          (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                            [0..<i] @\n                           [\\<mu> i i \\<cdot>\\<^sub>v gso i]) $\n                         ia =\n                         (\\<Sum>x\\<leftarrow>idx. ((if x < Suc i\n              then of_int (lam i) * \\<mu> i x else (0::'a)) \\<cdot>\\<^sub>v\n             gso x) $\n            ia)", "apply (subst sumlist_vec_index, auto, insert idx i main, auto simp: o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  of_int (lam i) \\<cdot>\\<^sub>v fs ! i \\<in> R\n\ngoal (2 subgoals):\n 1. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)\n 2. \\<And>ia. ia \\<in> set idxs \\<Longrightarrow> ia \\<in> set (i # idxs)", "qed auto"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) (i # idxs))\n  \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. of_int (lam i) \\<cdot>\\<^sub>v fs ! i) idx)\n  \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gg \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  gg \\<in> R", "obtain nu where gg: \"gg = sumlist (map (\\<lambda> i. nu i \\<cdot>\\<^sub>v gso i) idx)\""], ["proof (prove)\nusing this:\n  gg \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>nu.\n        gg =\n        M.sumlist\n         (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i)\n           idx) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding R_def"], ["proof (prove)\nusing this:\n  gg \\<in> {gg.\n            \\<exists>nu.\n               gg =\n               M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)}\n\ngoal (1 subgoal):\n 1. (\\<And>nu.\n        gg =\n        M.sumlist\n         (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i)\n           idx) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gg = M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "let ?ff = \"sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) + of_int l \\<cdot>\\<^sub>v gso k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "define hh where \"hh = (\\<lambda> i. (if i < k then nu i else of_int l))\""], ["proof (state)\nthis:\n  hh = (\\<lambda>i. if i < k then nu i else of_int l)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "let ?hh = \"sumlist (map (\\<lambda> i. hh i \\<cdot>\\<^sub>v gso i) [0 ..< Suc k])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have ffhh: \"?hh = sumlist (map (\\<lambda> i. hh i \\<cdot>\\<^sub>v gso i) [0 ..< k] @ [hh k \\<cdot>\\<^sub>v gso k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) =\n    M.sumlist\n     (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<k] @\n      [hh k \\<cdot>\\<^sub>v gso k])", "by simp"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) =\n  M.sumlist\n   (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<k] @\n    [hh k \\<cdot>\\<^sub>v gso k])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) =\n  M.sumlist\n   (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<k] @\n    [hh k \\<cdot>\\<^sub>v gso k])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> = sumlist (map (\\<lambda> i. hh i \\<cdot>\\<^sub>v gso i) [0 ..< k]) + sumlist [hh k \\<cdot>\\<^sub>v gso k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<k] @\n      [hh k \\<cdot>\\<^sub>v gso k]) =\n    M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<k]) +\n    M.sumlist [hh k \\<cdot>\\<^sub>v gso k]", "by (rule sumlist_append, insert kn, auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<k] @\n    [hh k \\<cdot>\\<^sub>v gso k]) =\n  M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<k]) +\n  M.sumlist [hh k \\<cdot>\\<^sub>v gso k]\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<k] @\n    [hh k \\<cdot>\\<^sub>v gso k]) =\n  M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<k]) +\n  M.sumlist [hh k \\<cdot>\\<^sub>v gso k]\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"sumlist [hh k \\<cdot>\\<^sub>v gso k] = hh k \\<cdot>\\<^sub>v gso k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist [hh k \\<cdot>\\<^sub>v gso k] = hh k \\<cdot>\\<^sub>v gso k", "using kn"], ["proof (prove)\nusing this:\n  k < length fs\n\ngoal (1 subgoal):\n 1. M.sumlist [hh k \\<cdot>\\<^sub>v gso k] = hh k \\<cdot>\\<^sub>v gso k", "by auto"], ["proof (state)\nthis:\n  M.sumlist [hh k \\<cdot>\\<^sub>v gso k] = hh k \\<cdot>\\<^sub>v gso k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist [hh k \\<cdot>\\<^sub>v gso k] = hh k \\<cdot>\\<^sub>v gso k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> = of_int l \\<cdot>\\<^sub>v gso k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hh k \\<cdot>\\<^sub>v gso k = of_int l \\<cdot>\\<^sub>v gso k", "unfolding hh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k < k then nu k else of_int l) \\<cdot>\\<^sub>v gso k =\n    of_int l \\<cdot>\\<^sub>v gso k", "by auto"], ["proof (state)\nthis:\n  hh k \\<cdot>\\<^sub>v gso k = of_int l \\<cdot>\\<^sub>v gso k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  hh k \\<cdot>\\<^sub>v gso k = of_int l \\<cdot>\\<^sub>v gso k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"map (\\<lambda> i. hh i \\<cdot>\\<^sub>v gso i) [0 ..< k] = map (\\<lambda> i. nu i \\<cdot>\\<^sub>v gso i) [0 ..< k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<k] =\n    map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) [0..<k]", "by (rule map_cong, auto simp: hh_def)"], ["proof (state)\nthis:\n  map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<k] =\n  map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) [0..<k]\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) =\n  M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) [0..<k]) +\n  of_int l \\<cdot>\\<^sub>v gso k", "have ffhh: \"?ff = ?hh\""], ["proof (prove)\nusing this:\n  M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) =\n  M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) [0..<k]) +\n  of_int l \\<cdot>\\<^sub>v gso k\n\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n    of_int l \\<cdot>\\<^sub>v gso k =\n    M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k])", "by (simp add: idx_def)"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n  of_int l \\<cdot>\\<^sub>v gso k =\n  M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "from hgg[unfolded gg]"], ["proof (chain)\npicking this:\n  h =\n  M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n  of_int l \\<cdot>\\<^sub>v gso k", "have h: \"h = ?ff\""], ["proof (prove)\nusing this:\n  h =\n  M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n  of_int l \\<cdot>\\<^sub>v gso k\n\ngoal (1 subgoal):\n 1. h =\n    M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n    of_int l \\<cdot>\\<^sub>v gso k", "by auto"], ["proof (state)\nthis:\n  h =\n  M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n  of_int l \\<cdot>\\<^sub>v gso k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"gso k \\<bullet> gso k \\<le> 1 * (gso k \\<bullet> gso k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso k \\<bullet> gso k \\<le> (1::'a) * (gso k \\<bullet> gso k)", "by simp"], ["proof (state)\nthis:\n  gso k \\<bullet> gso k \\<le> (1::'a) * (gso k \\<bullet> gso k)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  gso k \\<bullet> gso k \\<le> (1::'a) * (gso k \\<bullet> gso k)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> \\<le> of_int (l * l) * (gso k \\<bullet> gso k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) * (gso k \\<bullet> gso k)\n    \\<le> of_int (l * l) * (gso k \\<bullet> gso k)", "proof (rule mult_right_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. (1::'a) \\<le> of_int (l * l)\n 2. (0::'a) \\<le> gso k \\<bullet> gso k", "from l"], ["proof (chain)\npicking this:\n  l \\<noteq> 0", "have \"l * l \\<ge> 1\""], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> l * l", "by (meson eq_iff int_one_le_iff_zero_less mult_le_0_iff not_le)"], ["proof (state)\nthis:\n  1 \\<le> l * l\n\ngoal (2 subgoals):\n 1. (1::'a) \\<le> of_int (l * l)\n 2. (0::'a) \\<le> gso k \\<bullet> gso k", "thus \"1 \\<le> (of_int (l * l) :: 'a)\""], ["proof (prove)\nusing this:\n  1 \\<le> l * l\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> of_int (l * l)", "by presburger"], ["proof (state)\nthis:\n  (1::'a) \\<le> of_int (l * l)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> gso k \\<bullet> gso k", "show \"0 \\<le> gso k \\<bullet> gso k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> gso k \\<bullet> gso k", "by (rule scalar_prod_ge_0)"], ["proof (state)\nthis:\n  (0::'a) \\<le> gso k \\<bullet> gso k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (1::'a) * (gso k \\<bullet> gso k)\n  \\<le> of_int (l * l) * (gso k \\<bullet> gso k)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (1::'a) * (gso k \\<bullet> gso k)\n  \\<le> of_int (l * l) * (gso k \\<bullet> gso k)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> = 0 + of_int (l * l) * (gso k \\<bullet> gso k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (l * l) * (gso k \\<bullet> gso k) =\n    (0::'a) + of_int (l * l) * (gso k \\<bullet> gso k)", "by simp"], ["proof (state)\nthis:\n  of_int (l * l) * (gso k \\<bullet> gso k) =\n  (0::'a) + of_int (l * l) * (gso k \\<bullet> gso k)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  of_int (l * l) * (gso k \\<bullet> gso k) =\n  (0::'a) + of_int (l * l) * (gso k \\<bullet> gso k)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> \\<le> sum_list (map (\\<lambda> i. (nu i * nu i) * (gso i \\<bullet> gso i)) idx) + of_int (l * l) * (gso k \\<bullet> gso k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) + of_int (l * l) * (gso k \\<bullet> gso k)\n    \\<le> (\\<Sum>i\\<leftarrow>idx. nu i * nu i * (gso i \\<bullet> gso i)) +\n          of_int (l * l) * (gso k \\<bullet> gso k)", "by (rule add_right_mono, rule sum_list_nonneg, auto, rule mult_nonneg_nonneg, auto simp: scalar_prod_ge_0)"], ["proof (state)\nthis:\n  (0::'a) + of_int (l * l) * (gso k \\<bullet> gso k)\n  \\<le> (\\<Sum>i\\<leftarrow>idx. nu i * nu i * (gso i \\<bullet> gso i)) +\n        of_int (l * l) * (gso k \\<bullet> gso k)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (0::'a) + of_int (l * l) * (gso k \\<bullet> gso k)\n  \\<le> (\\<Sum>i\\<leftarrow>idx. nu i * nu i * (gso i \\<bullet> gso i)) +\n        of_int (l * l) * (gso k \\<bullet> gso k)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"map (\\<lambda> i. (nu i * nu i) * (gso i \\<bullet> gso i)) idx = map (\\<lambda> i. hh i * hh i * (gso i \\<bullet> gso i)) [0..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. nu i * nu i * (gso i \\<bullet> gso i)) idx =\n    map (\\<lambda>i. hh i * hh i * (gso i \\<bullet> gso i)) [0..<k]", "unfolding idx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. nu i * nu i * (gso i \\<bullet> gso i)) [0..<k] =\n    map (\\<lambda>i. hh i * hh i * (gso i \\<bullet> gso i)) [0..<k]", "by (rule map_cong, auto simp: hh_def)"], ["proof (state)\nthis:\n  map (\\<lambda>i. nu i * nu i * (gso i \\<bullet> gso i)) idx =\n  map (\\<lambda>i. hh i * hh i * (gso i \\<bullet> gso i)) [0..<k]\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  map (\\<lambda>i. nu i * nu i * (gso i \\<bullet> gso i)) idx =\n  map (\\<lambda>i. hh i * hh i * (gso i \\<bullet> gso i)) [0..<k]\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"of_int (l * l) = hh k * hh k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (l * l) = hh k * hh k", "unfolding hh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (l * l) =\n    (if k < k then nu k else of_int l) * (if k < k then nu k else of_int l)", "by auto"], ["proof (state)\nthis:\n  of_int (l * l) = hh k * hh k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  of_int (l * l) = hh k * hh k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"(\\<Sum>i\\<leftarrow>[0..<k]. hh i * hh i * (gso i \\<bullet> gso i)) + hh k * hh k * (gso k \\<bullet> gso k)\n     = (\\<Sum>i\\<leftarrow>[0..<Suc k]. hh i * hh i * (gso i \\<bullet> gso i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<k]. hh i * hh i * (gso i \\<bullet> gso i)) +\n    hh k * hh k * (gso k \\<bullet> gso k) =\n    (\\<Sum>i\\<leftarrow>[0..<Suc k]. hh i * hh i * (gso i \\<bullet> gso i))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<leftarrow>[0..<k]. hh i * hh i * (gso i \\<bullet> gso i)) +\n  hh k * hh k * (gso k \\<bullet> gso k) =\n  (\\<Sum>i\\<leftarrow>[0..<Suc k]. hh i * hh i * (gso i \\<bullet> gso i))\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<leftarrow>[0..<k]. hh i * hh i * (gso i \\<bullet> gso i)) +\n  hh k * hh k * (gso k \\<bullet> gso k) =\n  (\\<Sum>i\\<leftarrow>[0..<Suc k]. hh i * hh i * (gso i \\<bullet> gso i))\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> = ?hh \\<bullet> ?hh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<leftarrow>[0..<\n                         Suc k]. hh i * hh i * (gso i \\<bullet> gso i)) =\n    M.sumlist\n     (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k])", "by (rule sym, rule scalar_prod_lincomb_gso, insert kn assms, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<leftarrow>[0..<Suc k]. hh i * hh i * (gso i \\<bullet> gso i)) =\n  M.sumlist\n   (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<leftarrow>[0..<Suc k]. hh i * hh i * (gso i \\<bullet> gso i)) =\n  M.sumlist\n   (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> = ?ff \\<bullet> ?ff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) \\<bullet>\n    M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) =\n    (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n     of_int l \\<cdot>\\<^sub>v gso k) \\<bullet>\n    (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n     of_int l \\<cdot>\\<^sub>v gso k)", "by (simp add: ffhh)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) =\n  (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n   of_int l \\<cdot>\\<^sub>v gso k) \\<bullet>\n  (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n   of_int l \\<cdot>\\<^sub>v gso k)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) \\<bullet>\n  M.sumlist (map (\\<lambda>i. hh i \\<cdot>\\<^sub>v gso i) [0..<Suc k]) =\n  (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n   of_int l \\<cdot>\\<^sub>v gso k) \\<bullet>\n  (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n   of_int l \\<cdot>\\<^sub>v gso k)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> = h \\<bullet> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n     of_int l \\<cdot>\\<^sub>v gso k) \\<bullet>\n    (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n     of_int l \\<cdot>\\<^sub>v gso k) =\n    h \\<bullet> h", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n     of_int l \\<cdot>\\<^sub>v gso k) \\<bullet>\n    (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n     of_int l \\<cdot>\\<^sub>v gso k) =\n    (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n     of_int l \\<cdot>\\<^sub>v gso k) \\<bullet>\n    (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n     of_int l \\<cdot>\\<^sub>v gso k)", ".."], ["proof (state)\nthis:\n  (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n   of_int l \\<cdot>\\<^sub>v gso k) \\<bullet>\n  (M.sumlist (map (\\<lambda>i. nu i \\<cdot>\\<^sub>v gso i) idx) +\n   of_int l \\<cdot>\\<^sub>v gso k) =\n  h \\<bullet> h\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  gso k \\<bullet> gso k \\<le> h \\<bullet> h", "show ?thesis"], ["proof (prove)\nusing this:\n  gso k \\<bullet> gso k \\<le> h \\<bullet> h\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "using kn"], ["proof (prove)\nusing this:\n  gso k \\<bullet> gso k \\<le> h \\<bullet> h\n  k < length fs\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs.\n       \\<parallel>gso i\\<parallel>\\<^sup>2\n       \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "unfolding sq_norm_vec_as_cscalar_prod"], ["proof (prove)\nusing this:\n  gso k \\<bullet> gso k \\<le> h \\<bullet> h\n  k < length fs\n\ngoal (1 subgoal):\n 1. \\<exists>i<length fs. gso i \\<bullet>c gso i \\<le> h \\<bullet>c h", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length fs.\n     \\<parallel>gso i\\<parallel>\\<^sup>2\n     \\<le> \\<parallel>h\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Theorem 16.9 \n  (bound in textbook looks better as it uses 2^((n-1)/2), but this difference\n  is caused by the fact that we here we look at the squared norms) *)"], ["", "lemma weakly_reduced_imp_short_vector: \n  assumes \"weakly_reduced \\<alpha> m\"\n    and in_L: \"h \\<in> lattice_of fs - {0\\<^sub>v n}\" and \\<alpha>_pos:\"\\<alpha> \\<ge> 1\"\n  shows \"fs \\<noteq> [] \\<and> sq_norm (fs ! 0) \\<le> \\<alpha>^(m-1) * sq_norm h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<and>\n    \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<and>\n    \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2", "from gram_schmidt_short_vector assms"], ["proof (chain)\npicking this:\n  ?h \\<in> lattice_of fs - {0\\<^sub>v n} \\<Longrightarrow>\n  \\<exists>i<length fs.\n     \\<parallel>gso i\\<parallel>\\<^sup>2\n     \\<le> \\<parallel>?h\\<parallel>\\<^sup>2\n  weakly_reduced \\<alpha> (length fs)\n  h \\<in> lattice_of fs - {0\\<^sub>v n}\n  (1::'a) \\<le> \\<alpha>", "obtain i where \n    i: \"i < m\" and le: \"sq_norm (gso i) \\<le> sq_norm h\""], ["proof (prove)\nusing this:\n  ?h \\<in> lattice_of fs - {0\\<^sub>v n} \\<Longrightarrow>\n  \\<exists>i<length fs.\n     \\<parallel>gso i\\<parallel>\\<^sup>2\n     \\<le> \\<parallel>?h\\<parallel>\\<^sup>2\n  weakly_reduced \\<alpha> (length fs)\n  h \\<in> lattice_of fs - {0\\<^sub>v n}\n  (1::'a) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length fs;\n         \\<parallel>gso i\\<parallel>\\<^sup>2\n         \\<le> \\<parallel>h\\<parallel>\\<^sup>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length fs\n  \\<parallel>gso i\\<parallel>\\<^sup>2 \\<le> \\<parallel>h\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<and>\n    \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2", "have small: \"sq_norm (fs ! 0) \\<le> \\<alpha>^i * sq_norm (gso i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2", "using i"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length fs \\<Longrightarrow>\n    \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ 0 * \\<parallel>gso 0\\<parallel>\\<^sup>2\n 2. \\<And>i.\n       \\<lbrakk>i < length fs \\<Longrightarrow>\n                \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2;\n        Suc i < length fs\\<rbrakk>\n       \\<Longrightarrow> \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                         \\<le> \\<alpha> ^ Suc i *\n                               \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "case 0"], ["proof (state)\nthis:\n  0 < length fs\n\ngoal (2 subgoals):\n 1. 0 < length fs \\<Longrightarrow>\n    \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ 0 * \\<parallel>gso 0\\<parallel>\\<^sup>2\n 2. \\<And>i.\n       \\<lbrakk>i < length fs \\<Longrightarrow>\n                \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2;\n        Suc i < length fs\\<rbrakk>\n       \\<Longrightarrow> \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                         \\<le> \\<alpha> ^ Suc i *\n                               \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ 0 * \\<parallel>gso 0\\<parallel>\\<^sup>2", "unfolding fs0_gso0[OF 0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gso 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ 0 * \\<parallel>gso 0\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ 0 * \\<parallel>gso 0\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs \\<Longrightarrow>\n                \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2;\n        Suc i < length fs\\<rbrakk>\n       \\<Longrightarrow> \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                         \\<le> \\<alpha> ^ Suc i *\n                               \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs \\<Longrightarrow>\n                \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2;\n        Suc i < length fs\\<rbrakk>\n       \\<Longrightarrow> \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                         \\<le> \\<alpha> ^ Suc i *\n                               \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "case (Suc i)"], ["proof (state)\nthis:\n  i < length fs \\<Longrightarrow>\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2\n  Suc i < length fs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs \\<Longrightarrow>\n                \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2;\n        Suc i < length fs\\<rbrakk>\n       \\<Longrightarrow> \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                         \\<le> \\<alpha> ^ Suc i *\n                               \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "hence \"sq_norm (fs ! 0) \\<le> \\<alpha>^i * sq_norm (gso i)\""], ["proof (prove)\nusing this:\n  i < length fs \\<Longrightarrow>\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2\n  Suc i < length fs\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs \\<Longrightarrow>\n                \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2;\n        Suc i < length fs\\<rbrakk>\n       \\<Longrightarrow> \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                         \\<le> \\<alpha> ^ Suc i *\n                               \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs \\<Longrightarrow>\n                \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2;\n        Suc i < length fs\\<rbrakk>\n       \\<Longrightarrow> \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                         \\<le> \\<alpha> ^ Suc i *\n                               \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "have \"\\<dots> \\<le> \\<alpha>^i * (\\<alpha> * (sq_norm (gso (Suc i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ i *\n          (\\<alpha> * \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2)", "using reduced_gso_E[OF assms(1) le_refl Suc(2)] \\<alpha>_pos"], ["proof (prove)\nusing this:\n  \\<parallel>gso i\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> * \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2\n  (1::'a) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ i *\n          (\\<alpha> * \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ i *\n        (\\<alpha> * \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs \\<Longrightarrow>\n                \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2;\n        Suc i < length fs\\<rbrakk>\n       \\<Longrightarrow> \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n                         \\<le> \\<alpha> ^ Suc i *\n                               \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ i *\n        (\\<alpha> * \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2)", "show ?case"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ i *\n        (\\<alpha> * \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ Suc i * \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "unfolding class_semiring.nat_pow_Suc[of \\<alpha> i]"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ i *\n        (\\<alpha> * \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ i * \\<alpha> *\n          \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ Suc i * \\<parallel>gso (Suc i)\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<and>\n    \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<and>\n    \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2", "have \"\\<dots> \\<le> \\<alpha>^(m-1) * sq_norm h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2", "by (rule mult_mono[OF power_increasing le], insert i \\<alpha>_pos, auto)"], ["proof (state)\nthis:\n  \\<alpha> ^ i * \\<parallel>gso i\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<and>\n    \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<and>\n    \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2", "using i"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2\n  i < length fs\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<and>\n    \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2", "by (cases fs, auto)"], ["proof (state)\nthis:\n  fs \\<noteq> [] \\<and>\n  \\<parallel>fs ! 0\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (length fs - 1) * \\<parallel>h\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sq_norm_pos: \n  assumes j: \"j < m\" \n  shows \"sq_norm (gso j) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < \\<parallel>gso j\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) < \\<parallel>gso j\\<parallel>\\<^sup>2", "from j"], ["proof (chain)\npicking this:\n  j < length fs", "have jj: \"j < m - 0\""], ["proof (prove)\nusing this:\n  j < length fs\n\ngoal (1 subgoal):\n 1. j < length fs - 0", "by simp"], ["proof (state)\nthis:\n  j < length fs - 0\n\ngoal (1 subgoal):\n 1. (0::'a) < \\<parallel>gso j\\<parallel>\\<^sup>2", "from orthogonalD[OF orthogonal_gso, unfolded length_map length_upt, OF jj jj] assms"], ["proof (chain)\npicking this:\n  (map gso [0..<length fs] ! j \\<bullet> map gso [0..<length fs] ! j =\n   (0::'a)) =\n  (j \\<noteq> j)\n  j < length fs", "have \"sq_norm (gso j) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (map gso [0..<length fs] ! j \\<bullet> map gso [0..<length fs] ! j =\n   (0::'a)) =\n  (j \\<noteq> j)\n  j < length fs\n\ngoal (1 subgoal):\n 1. \\<parallel>gso j\\<parallel>\\<^sup>2 \\<noteq> (0::'a)", "using j"], ["proof (prove)\nusing this:\n  (map gso [0..<length fs] ! j \\<bullet> map gso [0..<length fs] ! j =\n   (0::'a)) =\n  (j \\<noteq> j)\n  j < length fs\n  j < length fs\n\ngoal (1 subgoal):\n 1. \\<parallel>gso j\\<parallel>\\<^sup>2 \\<noteq> (0::'a)", "by (simp add: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  \\<parallel>gso j\\<parallel>\\<^sup>2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) < \\<parallel>gso j\\<parallel>\\<^sup>2", "moreover"], ["proof (state)\nthis:\n  \\<parallel>gso j\\<parallel>\\<^sup>2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) < \\<parallel>gso j\\<parallel>\\<^sup>2", "have \"sq_norm (gso j) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> \\<parallel>gso j\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> \\<parallel>gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (0::'a) < \\<parallel>gso j\\<parallel>\\<^sup>2", "ultimately"], ["proof (chain)\npicking this:\n  \\<parallel>gso j\\<parallel>\\<^sup>2 \\<noteq> (0::'a)\n  (0::'a) \\<le> \\<parallel>gso j\\<parallel>\\<^sup>2", "show \"0 < sq_norm (gso j)\""], ["proof (prove)\nusing this:\n  \\<parallel>gso j\\<parallel>\\<^sup>2 \\<noteq> (0::'a)\n  (0::'a) \\<le> \\<parallel>gso j\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (0::'a) < \\<parallel>gso j\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  (0::'a) < \\<parallel>gso j\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gramian_determinant: \n  assumes k: \"k \\<le> m\" \n  shows \"Gramian_determinant fs k = (\\<Prod> j<k. sq_norm (gso j))\"\n    \"Gramian_determinant fs k > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2) &&&\n    (0::'a) < Gramian_determinant fs k", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "define Gk where \"Gk = mat k n (\\<lambda> (i,j). fs ! i $ j)\""], ["proof (state)\nthis:\n  Gk = mat k n (\\<lambda>(i, j). fs ! i $ j)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have Gk: \"Gk \\<in> carrier_mat k n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gk \\<in> carrier_mat k n", "unfolding Gk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, y). fs ! i $ y) \\<in> carrier_mat k n", "by auto"], ["proof (state)\nthis:\n  Gk \\<in> carrier_mat k n\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "define Mk where \"Mk = mat k k (\\<lambda> (i,j). \\<mu> i j)\""], ["proof (state)\nthis:\n  Mk = mat k k (\\<lambda>(x, y). \\<mu> x y)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have Mk_\\<mu>: \"i < k \\<Longrightarrow> j < k \\<Longrightarrow> Mk $$ (i,j) = \\<mu> i j\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < k; j < k\\<rbrakk>\n    \\<Longrightarrow> Mk $$ (i, j) = \\<mu> i j", "unfolding Mk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < k; j < k\\<rbrakk>\n    \\<Longrightarrow> mat k k (\\<lambda>(x, y). \\<mu> x y) $$ (i, j) =\n                      \\<mu> i j", "using k"], ["proof (prove)\nusing this:\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < k; j < k\\<rbrakk>\n    \\<Longrightarrow> mat k k (\\<lambda>(x, y). \\<mu> x y) $$ (i, j) =\n                      \\<mu> i j", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < k; ?j1 < k\\<rbrakk>\n  \\<Longrightarrow> Mk $$ (?i1, ?j1) = \\<mu> ?i1 ?j1\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have Mk: \"Mk \\<in> carrier_mat k k\" and [simp]: \"dim_row Mk = k\" \"dim_col Mk = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mk \\<in> carrier_mat k k &&& dim_row Mk = k &&& dim_col Mk = k", "unfolding Mk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k k (\\<lambda>(x, y). \\<mu> x y) \\<in> carrier_mat k k &&&\n    dim_row (mat k k (\\<lambda>(x, y). \\<mu> x y)) = k &&&\n    dim_col (mat k k (\\<lambda>(x, y). \\<mu> x y)) = k", "by auto"], ["proof (state)\nthis:\n  Mk \\<in> carrier_mat k k\n  dim_row Mk = k\n  dim_col Mk = k\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"det Mk = prod_list (diag_mat Mk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det Mk = prod_list (diag_mat Mk)", "by (rule det_lower_triangular[OF _ Mk], auto simp: Mk_\\<mu> \\<mu>.simps)"], ["proof (state)\nthis:\n  det Mk = prod_list (diag_mat Mk)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  det Mk = prod_list (diag_mat Mk)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (diag_mat Mk) = (1::'a)", "by (rule prod_list_neutral, auto simp: diag_mat_def Mk_\\<mu> \\<mu>.simps)"], ["proof (state)\nthis:\n  prod_list (diag_mat Mk) = (1::'a)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "finally"], ["proof (chain)\npicking this:\n  det Mk = (1::'a)", "have detMk: \"det Mk = 1\""], ["proof (prove)\nusing this:\n  det Mk = (1::'a)\n\ngoal (1 subgoal):\n 1. det Mk = (1::'a)", "."], ["proof (state)\nthis:\n  det Mk = (1::'a)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "define Gsk where \"Gsk = mat k n (\\<lambda> (i,j). gso i $ j)\""], ["proof (state)\nthis:\n  Gsk = mat k n (\\<lambda>(i, j). gso i $ j)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have Gsk: \"Gsk \\<in> carrier_mat k n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gsk \\<in> carrier_mat k n", "unfolding Gsk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, y). gso i $ y) \\<in> carrier_mat k n", "by auto"], ["proof (state)\nthis:\n  Gsk \\<in> carrier_mat k n\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have Gsk': \"Gsk\\<^sup>T \\<in> carrier_mat n k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gsk\\<^sup>T \\<in> carrier_mat n k", "using Gsk"], ["proof (prove)\nusing this:\n  Gsk \\<in> carrier_mat k n\n\ngoal (1 subgoal):\n 1. Gsk\\<^sup>T \\<in> carrier_mat n k", "by auto"], ["proof (state)\nthis:\n  Gsk\\<^sup>T \\<in> carrier_mat n k\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "let ?Rn = \"carrier_vec n\""], ["proof (state)\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have id: \"Gk = Mk * Gsk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gk = Mk * Gsk", "proof (rule eq_matI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)\n 2. dim_row Gk = dim_row (Mk * Gsk)\n 3. dim_col Gk = dim_col (Mk * Gsk)", "from Gk Mk Gsk"], ["proof (chain)\npicking this:\n  Gk \\<in> carrier_mat k n\n  Mk \\<in> carrier_mat k k\n  Gsk \\<in> carrier_mat k n", "have dim: \"dim_row Gk = k\" \"dim_row (Mk * Gsk) = k\" \"dim_col Gk = n\" \"dim_col (Mk * Gsk) = n\""], ["proof (prove)\nusing this:\n  Gk \\<in> carrier_mat k n\n  Mk \\<in> carrier_mat k k\n  Gsk \\<in> carrier_mat k n\n\ngoal (1 subgoal):\n 1. (dim_row Gk = k &&& dim_row (Mk * Gsk) = k) &&&\n    dim_col Gk = n &&& dim_col (Mk * Gsk) = n", "by auto"], ["proof (state)\nthis:\n  dim_row Gk = k\n  dim_row (Mk * Gsk) = k\n  dim_col Gk = n\n  dim_col (Mk * Gsk) = n\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)\n 2. dim_row Gk = dim_row (Mk * Gsk)\n 3. dim_col Gk = dim_col (Mk * Gsk)", "from dim"], ["proof (chain)\npicking this:\n  dim_row Gk = k\n  dim_row (Mk * Gsk) = k\n  dim_col Gk = n\n  dim_col (Mk * Gsk) = n", "show \"dim_row Gk = dim_row (Mk * Gsk)\" \"dim_col Gk = dim_col (Mk * Gsk)\""], ["proof (prove)\nusing this:\n  dim_row Gk = k\n  dim_row (Mk * Gsk) = k\n  dim_col Gk = n\n  dim_col (Mk * Gsk) = n\n\ngoal (1 subgoal):\n 1. dim_row Gk = dim_row (Mk * Gsk) &&& dim_col Gk = dim_col (Mk * Gsk)", "by auto"], ["proof (state)\nthis:\n  dim_row Gk = dim_row (Mk * Gsk)\n  dim_col Gk = dim_col (Mk * Gsk)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "assume \"i < dim_row (Mk * Gsk)\" \"j < dim_col (Mk * Gsk)\""], ["proof (state)\nthis:\n  i < dim_row (Mk * Gsk)\n  j < dim_col (Mk * Gsk)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "hence ij: \"i < k\" \"j < n\" and i: \"i < m\""], ["proof (prove)\nusing this:\n  i < dim_row (Mk * Gsk)\n  j < dim_col (Mk * Gsk)\n\ngoal (1 subgoal):\n 1. (i < k &&& j < n) &&& i < length fs", "using dim k"], ["proof (prove)\nusing this:\n  i < dim_row (Mk * Gsk)\n  j < dim_col (Mk * Gsk)\n  dim_row Gk = k\n  dim_row (Mk * Gsk) = k\n  dim_col Gk = n\n  dim_col (Mk * Gsk) = n\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. (i < k &&& j < n) &&& i < length fs", "by auto"], ["proof (state)\nthis:\n  i < k\n  j < n\n  i < length fs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have Gi: \"fs ! i \\<in> ?Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n", "using i"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n", "by simp"], ["proof (state)\nthis:\n  fs ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"Gk $$ (i, j) = fs ! i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gk $$ (i, j) = fs ! i $ j", "unfolding Gk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, y). fs ! i $ y) $$ (i, j) = fs ! i $ j", "using ij k Gi"], ["proof (prove)\nusing this:\n  i < k\n  j < n\n  k \\<le> length fs\n  fs ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, y). fs ! i $ y) $$ (i, j) = fs ! i $ j", "by auto"], ["proof (state)\nthis:\n  Gk $$ (i, j) = fs ! i $ j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  Gk $$ (i, j) = fs ! i $ j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"... = FF $$ (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i $ j = mat_of_rows n fs $$ (i, j)", "using ij i"], ["proof (prove)\nusing this:\n  i < k\n  j < n\n  i < length fs\n\ngoal (1 subgoal):\n 1. fs ! i $ j = mat_of_rows n fs $$ (i, j)", "by simp"], ["proof (state)\nthis:\n  fs ! i $ j = mat_of_rows n fs $$ (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  fs ! i $ j = mat_of_rows n fs $$ (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"FF = (M m) * Fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n fs =\n    M (length fs) * mat_of_rows n (map gso [0..<length fs])", "by (rule matrix_equality)"], ["proof (state)\nthis:\n  mat_of_rows n fs = M (length fs) * mat_of_rows n (map gso [0..<length fs])\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  mat_of_rows n fs = M (length fs) * mat_of_rows n (map gso [0..<length fs])\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"\\<dots> $$ (i,j) = row (M m) i \\<bullet> col Fs j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n    row (M (length fs)) i \\<bullet>\n    col (mat_of_rows n (map gso [0..<length fs])) j", "by (rule index_mult_mat(1), insert i ij, auto simp: mat_of_rows_list_def)"], ["proof (state)\nthis:\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n  row (M (length fs)) i \\<bullet>\n  col (mat_of_rows n (map gso [0..<length fs])) j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  (M (length fs) * mat_of_rows n (map gso [0..<length fs])) $$ (i, j) =\n  row (M (length fs)) i \\<bullet>\n  col (mat_of_rows n (map gso [0..<length fs])) j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"row (M m) i = vec m (\\<lambda> j. if j < k then Mk $$ (i,j) else 0)\" \n      (is \"_ = vec m ?Mk\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (M (length fs)) i =\n    vec (length fs) (\\<lambda>j. if j < k then Mk $$ (i, j) else (0::'a))", "unfolding Mk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (M (length fs)) i =\n    vec (length fs)\n     (\\<lambda>j.\n         if j < k then mat k k (\\<lambda>(x, y). \\<mu> x y) $$ (i, j)\n         else (0::'a))", "using ij i"], ["proof (prove)\nusing this:\n  i < k\n  j < n\n  i < length fs\n\ngoal (1 subgoal):\n 1. row (M (length fs)) i =\n    vec (length fs)\n     (\\<lambda>j.\n         if j < k then mat k k (\\<lambda>(x, y). \\<mu> x y) $$ (i, j)\n         else (0::'a))", "by (auto simp: mat_of_rows_list_def \\<mu>.simps)"], ["proof (state)\nthis:\n  row (M (length fs)) i =\n  vec (length fs) (\\<lambda>j. if j < k then Mk $$ (i, j) else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  row (M (length fs)) i =\n  vec (length fs) (\\<lambda>j. if j < k then Mk $$ (i, j) else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"col Fs j = vec m (\\<lambda> i'. if i' < k then Gsk $$ (i',j) else (Fs $$ (i',j)))\" \n      (is \"_ = vec m ?Gsk\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mat_of_rows n (map gso [0..<length fs])) j =\n    vec (length fs)\n     (\\<lambda>i'.\n         if i' < k then Gsk $$ (i', j)\n         else mat_of_rows n (map gso [0..<length fs]) $$ (i', j))", "unfolding Gsk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mat_of_rows n (map gso [0..<length fs])) j =\n    vec (length fs)\n     (\\<lambda>i'.\n         if i' < k then mat k n (\\<lambda>(i, y). gso i $ y) $$ (i', j)\n         else mat_of_rows n (map gso [0..<length fs]) $$ (i', j))", "using ij i"], ["proof (prove)\nusing this:\n  i < k\n  j < n\n  i < length fs\n\ngoal (1 subgoal):\n 1. col (mat_of_rows n (map gso [0..<length fs])) j =\n    vec (length fs)\n     (\\<lambda>i'.\n         if i' < k then mat k n (\\<lambda>(i, y). gso i $ y) $$ (i', j)\n         else mat_of_rows n (map gso [0..<length fs]) $$ (i', j))", "by (auto simp: mat_of_rows_def)"], ["proof (state)\nthis:\n  col (mat_of_rows n (map gso [0..<length fs])) j =\n  vec (length fs)\n   (\\<lambda>i'.\n       if i' < k then Gsk $$ (i', j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (i', j))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  col (mat_of_rows n (map gso [0..<length fs])) j =\n  vec (length fs)\n   (\\<lambda>i'.\n       if i' < k then Gsk $$ (i', j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (i', j))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"vec m ?Mk \\<bullet> vec m ?Gsk = (\\<Sum> i \\<in> {0 ..< m}. ?Mk i * ?Gsk i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (length fs)\n     (\\<lambda>j. if j < k then Mk $$ (i, j) else (0::'a)) \\<bullet>\n    vec (length fs)\n     (\\<lambda>i'.\n         if i' < k then Gsk $$ (i', j)\n         else mat_of_rows n (map gso [0..<length fs]) $$ (i', j)) =\n    (\\<Sum>ia = 0..<length fs.\n        (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n        (if ia < k then Gsk $$ (ia, j)\n         else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j)))", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec\n                     (vec (length fs)\n                       (\\<lambda>i'.\n                           if i' < k then Gsk $$ (i', j)\n                           else mat_of_rows n (map gso [0..<length fs]) $$\n                                (i', j))).\n        vec (length fs)\n         (\\<lambda>j. if j < k then Mk $$ (i, j) else (0::'a)) $\n        ia *\n        vec (length fs)\n         (\\<lambda>i'.\n             if i' < k then Gsk $$ (i', j)\n             else mat_of_rows n (map gso [0..<length fs]) $$ (i', j)) $\n        ia) =\n    (\\<Sum>ia = 0..<length fs.\n        (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n        (if ia < k then Gsk $$ (ia, j)\n         else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j)))", "by auto"], ["proof (state)\nthis:\n  vec (length fs)\n   (\\<lambda>j. if j < k then Mk $$ (i, j) else (0::'a)) \\<bullet>\n  vec (length fs)\n   (\\<lambda>i'.\n       if i' < k then Gsk $$ (i', j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (i', j)) =\n  (\\<Sum>ia = 0..<length fs.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  vec (length fs)\n   (\\<lambda>j. if j < k then Mk $$ (i, j) else (0::'a)) \\<bullet>\n  vec (length fs)\n   (\\<lambda>i'.\n       if i' < k then Gsk $$ (i', j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (i', j)) =\n  (\\<Sum>ia = 0..<length fs.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"\\<dots> = (\\<Sum> i \\<in> {0 ..< k} \\<union> {k ..< m}. ?Mk i * ?Gsk i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<length fs.\n        (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n        (if ia < k then Gsk $$ (ia, j)\n         else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n    (\\<Sum>ia\\<in>{0..<k} \\<union> {k..<length fs}.\n       (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n       (if ia < k then Gsk $$ (ia, j)\n        else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j)))", "by (rule sum.cong, insert k, auto)"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<length fs.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n  (\\<Sum>ia\\<in>{0..<k} \\<union> {k..<length fs}.\n     (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n     (if ia < k then Gsk $$ (ia, j)\n      else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<length fs.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n  (\\<Sum>ia\\<in>{0..<k} \\<union> {k..<length fs}.\n     (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n     (if ia < k then Gsk $$ (ia, j)\n      else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"\\<dots> = (\\<Sum> i \\<in> {0 ..< k}. ?Mk i * ?Gsk i) + (\\<Sum> i \\<in> {k ..< m}. ?Mk i * ?Gsk i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{0..<k} \\<union> {k..<length fs}.\n       (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n       (if ia < k then Gsk $$ (ia, j)\n        else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n    (\\<Sum>ia = 0..<k.\n        (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n        (if ia < k then Gsk $$ (ia, j)\n         else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) +\n    (\\<Sum>ia = k..<length fs.\n        (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n        (if ia < k then Gsk $$ (ia, j)\n         else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j)))", "by (rule sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>ia\\<in>{0..<k} \\<union> {k..<length fs}.\n     (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n     (if ia < k then Gsk $$ (ia, j)\n      else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n  (\\<Sum>ia = 0..<k.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) +\n  (\\<Sum>ia = k..<length fs.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ia\\<in>{0..<k} \\<union> {k..<length fs}.\n     (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n     (if ia < k then Gsk $$ (ia, j)\n      else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n  (\\<Sum>ia = 0..<k.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) +\n  (\\<Sum>ia = k..<length fs.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"(\\<Sum> i \\<in> {k ..< m}. ?Mk i * ?Gsk i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = k..<length fs.\n        (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n        (if ia < k then Gsk $$ (ia, j)\n         else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n    (0::'a)", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>ia = k..<length fs.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ia = k..<length fs.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"(\\<Sum> i \\<in> {0 ..< k}. ?Mk i * ?Gsk i) = (\\<Sum> i' \\<in> {0 ..< k}. Mk $$ (i,i') * Gsk $$ (i',j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<k.\n        (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n        (if ia < k then Gsk $$ (ia, j)\n         else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n    (\\<Sum>i' = 0..<k. Mk $$ (i, i') * Gsk $$ (i', j))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<k.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n  (\\<Sum>i' = 0..<k. Mk $$ (i, i') * Gsk $$ (i', j))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<k.\n      (if ia < k then Mk $$ (i, ia) else (0::'a)) *\n      (if ia < k then Gsk $$ (ia, j)\n       else mat_of_rows n (map gso [0..<length fs]) $$ (ia, j))) =\n  (\\<Sum>i' = 0..<k. Mk $$ (i, i') * Gsk $$ (i', j))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"\\<dots> = row Mk i \\<bullet> col Gsk j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i' = 0..<k. Mk $$ (i, i') * Gsk $$ (i', j)) =\n    row Mk i \\<bullet> col Gsk j", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i' = 0..<k. Mk $$ (i, i') * Gsk $$ (i', j)) =\n    (\\<Sum>ia = 0..<dim_vec (col Gsk j). row Mk i $ ia * col Gsk j $ ia)", "using ij"], ["proof (prove)\nusing this:\n  i < k\n  j < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i' = 0..<k. Mk $$ (i, i') * Gsk $$ (i', j)) =\n    (\\<Sum>ia = 0..<dim_vec (col Gsk j). row Mk i $ ia * col Gsk j $ ia)", "by (auto simp: Gsk_def Mk_def)"], ["proof (state)\nthis:\n  (\\<Sum>i' = 0..<k. Mk $$ (i, i') * Gsk $$ (i', j)) =\n  row Mk i \\<bullet> col Gsk j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i' = 0..<k. Mk $$ (i, i') * Gsk $$ (i', j)) =\n  row Mk i \\<bullet> col Gsk j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "have \"\\<dots> = (Mk * Gsk) $$ (i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row Mk i \\<bullet> col Gsk j = (Mk * Gsk) $$ (i, j)", "using ij Mk Gsk"], ["proof (prove)\nusing this:\n  i < k\n  j < n\n  Mk \\<in> carrier_mat k k\n  Gsk \\<in> carrier_mat k n\n\ngoal (1 subgoal):\n 1. row Mk i \\<bullet> col Gsk j = (Mk * Gsk) $$ (i, j)", "by simp"], ["proof (state)\nthis:\n  row Mk i \\<bullet> col Gsk j = (Mk * Gsk) $$ (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (Mk * Gsk); j < dim_col (Mk * Gsk)\\<rbrakk>\n       \\<Longrightarrow> Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "finally"], ["proof (chain)\npicking this:\n  Gk $$ (i, j) = (Mk * Gsk) $$ (i, j) + (0::'a)", "show \"Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)\""], ["proof (prove)\nusing this:\n  Gk $$ (i, j) = (Mk * Gsk) $$ (i, j) + (0::'a)\n\ngoal (1 subgoal):\n 1. Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)", "by simp"], ["proof (state)\nthis:\n  Gk $$ (i, j) = (Mk * Gsk) $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gk = Mk * Gsk\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have cong: \"\\<And> a b c d. a = b \\<Longrightarrow> c = d \\<Longrightarrow> a * c = b * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a = b; c = d\\<rbrakk> \\<Longrightarrow> a * c = b * d", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a2 = ?b2; ?c2 = ?d2\\<rbrakk>\n  \\<Longrightarrow> ?a2 * ?c2 = ?b2 * ?d2\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"Gramian_determinant fs k = det (Gk * Gk\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_determinant fs k = det (Gk * Gk\\<^sup>T)", "unfolding Gramian_determinant_def Gramian_matrix_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat k n (\\<lambda>(i, y). fs ! i $ y) *\n         (mat k n (\\<lambda>(i, y). fs ! i $ y))\\<^sup>T) =\n    det (Gk * Gk\\<^sup>T)", "by (rule arg_cong[of _ _ det], rule cong, insert k, auto simp: Gk_def)"], ["proof (state)\nthis:\n  Gramian_determinant fs k = det (Gk * Gk\\<^sup>T)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  Gramian_determinant fs k = det (Gk * Gk\\<^sup>T)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"Gk\\<^sup>T = Gsk\\<^sup>T * Mk\\<^sup>T\" (is \"_ = ?TGsk * ?TMk\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gk\\<^sup>T = Gsk\\<^sup>T * Mk\\<^sup>T", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mk * Gsk)\\<^sup>T = Gsk\\<^sup>T * Mk\\<^sup>T", "by (rule transpose_mult[OF Mk Gsk])"], ["proof (state)\nthis:\n  Gk\\<^sup>T = Gsk\\<^sup>T * Mk\\<^sup>T\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  Gk\\<^sup>T = Gsk\\<^sup>T * Mk\\<^sup>T\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"Gk = Mk * Gsk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gk = Mk * Gsk", "by fact"], ["proof (state)\nthis:\n  Gk = Mk * Gsk\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  Gk = Mk * Gsk\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"\\<dots> * (?TGsk * ?TMk) = Mk * (Gsk * (?TGsk * ?TMk))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mk * Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T) =\n    Mk * (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))", "by (rule assoc_mult_mat[OF Mk Gsk, of _ k], insert Gsk Mk, auto)"], ["proof (state)\nthis:\n  Mk * Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T) =\n  Mk * (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  Mk * Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T) =\n  Mk * (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"det \\<dots> = det Mk * det (Gsk * (?TGsk * ?TMk))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Mk * (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))) =\n    det Mk * det (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))", "by (rule det_mult[OF Mk], insert Gsk Mk, auto)"], ["proof (state)\nthis:\n  det (Mk * (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))) =\n  det Mk * det (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  det (Mk * (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))) =\n  det Mk * det (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"\\<dots> = det (Gsk * (?TGsk * ?TMk))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det Mk * det (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T)) =\n    det (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))", "using detMk"], ["proof (prove)\nusing this:\n  det Mk = (1::'a)\n\ngoal (1 subgoal):\n 1. det Mk * det (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T)) =\n    det (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))", "by simp"], ["proof (state)\nthis:\n  det Mk * det (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T)) =\n  det (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  det Mk * det (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T)) =\n  det (Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T))\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"Gsk * (?TGsk * ?TMk) = (Gsk * ?TGsk) * ?TMk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T) = Gsk * Gsk\\<^sup>T * Mk\\<^sup>T", "by (rule assoc_mult_mat[symmetric, OF Gsk], insert Gsk Mk, auto)"], ["proof (state)\nthis:\n  Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T) = Gsk * Gsk\\<^sup>T * Mk\\<^sup>T\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  Gsk * (Gsk\\<^sup>T * Mk\\<^sup>T) = Gsk * Gsk\\<^sup>T * Mk\\<^sup>T\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"det \\<dots> = det (Gsk * ?TGsk) * det ?TMk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Gsk * Gsk\\<^sup>T * Mk\\<^sup>T) =\n    det (Gsk * Gsk\\<^sup>T) * det Mk\\<^sup>T", "by (rule det_mult, insert Gsk Mk, auto)"], ["proof (state)\nthis:\n  det (Gsk * Gsk\\<^sup>T * Mk\\<^sup>T) =\n  det (Gsk * Gsk\\<^sup>T) * det Mk\\<^sup>T\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  det (Gsk * Gsk\\<^sup>T * Mk\\<^sup>T) =\n  det (Gsk * Gsk\\<^sup>T) * det Mk\\<^sup>T\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"\\<dots> = det (Gsk * ?TGsk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Gsk * Gsk\\<^sup>T) * det Mk\\<^sup>T = det (Gsk * Gsk\\<^sup>T)", "using detMk det_transpose[OF Mk]"], ["proof (prove)\nusing this:\n  det Mk = (1::'a)\n  det Mk\\<^sup>T = det Mk\n\ngoal (1 subgoal):\n 1. det (Gsk * Gsk\\<^sup>T) * det Mk\\<^sup>T = det (Gsk * Gsk\\<^sup>T)", "by simp"], ["proof (state)\nthis:\n  det (Gsk * Gsk\\<^sup>T) * det Mk\\<^sup>T = det (Gsk * Gsk\\<^sup>T)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  det (Gsk * Gsk\\<^sup>T) * det Mk\\<^sup>T = det (Gsk * Gsk\\<^sup>T)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"Gsk * ?TGsk = mat k k (\\<lambda> (i,j). if i = j then sq_norm (gso j) else 0)\" (is \"_ = ?M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gsk * Gsk\\<^sup>T =\n    mat k k\n     (\\<lambda>(i, j).\n         if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))", "proof (rule eq_matI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)\n 2. dim_row (Gsk * Gsk\\<^sup>T) =\n    dim_row\n     (mat k k\n       (\\<lambda>(i, j).\n           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)))\n 3. dim_col (Gsk * Gsk\\<^sup>T) =\n    dim_col\n     (mat k k\n       (\\<lambda>(i, j).\n           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)))", "show \"dim_row (Gsk * ?TGsk) = dim_row ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (Gsk * Gsk\\<^sup>T) =\n    dim_row\n     (mat k k\n       (\\<lambda>(i, j).\n           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)))", "unfolding Gsk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat k n (\\<lambda>(i, y). gso i $ y) *\n      (mat k n (\\<lambda>(i, y). gso i $ y))\\<^sup>T) =\n    dim_row\n     (mat k k\n       (\\<lambda>(i, j).\n           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)))", "by auto"], ["proof (state)\nthis:\n  dim_row (Gsk * Gsk\\<^sup>T) =\n  dim_row\n   (mat k k\n     (\\<lambda>(i, j).\n         if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)))\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)\n 2. dim_col (Gsk * Gsk\\<^sup>T) =\n    dim_col\n     (mat k k\n       (\\<lambda>(i, j).\n           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)))", "show \"dim_col (Gsk * ?TGsk) = dim_col ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (Gsk * Gsk\\<^sup>T) =\n    dim_col\n     (mat k k\n       (\\<lambda>(i, j).\n           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)))", "unfolding Gsk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     (mat k n (\\<lambda>(i, y). gso i $ y) *\n      (mat k n (\\<lambda>(i, y). gso i $ y))\\<^sup>T) =\n    dim_col\n     (mat k k\n       (\\<lambda>(i, j).\n           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)))", "by auto"], ["proof (state)\nthis:\n  dim_col (Gsk * Gsk\\<^sup>T) =\n  dim_col\n   (mat k k\n     (\\<lambda>(i, j).\n         if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "assume \"i < dim_row ?M\" \"j < dim_col ?M\""], ["proof (state)\nthis:\n  i < dim_row\n       (mat k k\n         (\\<lambda>(i, j).\n             if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n             else (0::'a)))\n  j < dim_col\n       (mat k k\n         (\\<lambda>(i, j).\n             if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n             else (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "hence ij: \"i < k\" \"j < k\" and ijn: \"i < m\" \"j < m\""], ["proof (prove)\nusing this:\n  i < dim_row\n       (mat k k\n         (\\<lambda>(i, j).\n             if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n             else (0::'a)))\n  j < dim_col\n       (mat k k\n         (\\<lambda>(i, j).\n             if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n             else (0::'a)))\n\ngoal (1 subgoal):\n 1. (i < k &&& j < k) &&& i < length fs &&& j < length fs", "using k"], ["proof (prove)\nusing this:\n  i < dim_row\n       (mat k k\n         (\\<lambda>(i, j).\n             if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n             else (0::'a)))\n  j < dim_col\n       (mat k k\n         (\\<lambda>(i, j).\n             if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n             else (0::'a)))\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. (i < k &&& j < k) &&& i < length fs &&& j < length fs", "by auto"], ["proof (state)\nthis:\n  i < k\n  j < k\n  i < length fs\n  j < length fs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "{"], ["proof (state)\nthis:\n  i < k\n  j < k\n  i < length fs\n  j < length fs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "assume \"i < k\""], ["proof (state)\nthis:\n  i < k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "hence \"i < m\""], ["proof (prove)\nusing this:\n  i < k\n\ngoal (1 subgoal):\n 1. i < length fs", "using k"], ["proof (prove)\nusing this:\n  i < k\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. i < length fs", "by auto"], ["proof (state)\nthis:\n  i < length fs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "hence Gs: \"gso i \\<in> ?Rn\""], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. gso i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  gso i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "have \"row Gsk i = gso i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row Gsk i = gso i", "unfolding row_def Gsk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (dim_col (mat k n (\\<lambda>(i, y). gso i $ y)))\n     (\\<lambda>j. mat k n (\\<lambda>(i, y). gso i $ y) $$ (i, j)) =\n    gso i", "by (rule eq_vecI, insert Gs \\<open>i < k\\<close>, auto)"], ["proof (state)\nthis:\n  row Gsk i = gso i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "}"], ["proof (state)\nthis:\n  ?ia5 < k \\<Longrightarrow> row Gsk ?ia5 = gso ?ia5\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "note row = this"], ["proof (state)\nthis:\n  ?ia5 < k \\<Longrightarrow> row Gsk ?ia5 = gso ?ia5\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "have \"(Gsk * ?TGsk) $$ (i,j) = row Gsk i \\<bullet> row Gsk j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Gsk * Gsk\\<^sup>T) $$ (i, j) = row Gsk i \\<bullet> row Gsk j", "using ij Gsk"], ["proof (prove)\nusing this:\n  i < k\n  j < k\n  Gsk \\<in> carrier_mat k n\n\ngoal (1 subgoal):\n 1. (Gsk * Gsk\\<^sup>T) $$ (i, j) = row Gsk i \\<bullet> row Gsk j", "by auto"], ["proof (state)\nthis:\n  (Gsk * Gsk\\<^sup>T) $$ (i, j) = row Gsk i \\<bullet> row Gsk j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "also"], ["proof (state)\nthis:\n  (Gsk * Gsk\\<^sup>T) $$ (i, j) = row Gsk i \\<bullet> row Gsk j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "have \"\\<dots> = gso i \\<bullet> gso j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row Gsk i \\<bullet> row Gsk j = gso i \\<bullet> gso j", "using row ij"], ["proof (prove)\nusing this:\n  ?ia5 < k \\<Longrightarrow> row Gsk ?ia5 = gso ?ia5\n  i < k\n  j < k\n\ngoal (1 subgoal):\n 1. row Gsk i \\<bullet> row Gsk j = gso i \\<bullet> gso j", "by simp"], ["proof (state)\nthis:\n  row Gsk i \\<bullet> row Gsk j = gso i \\<bullet> gso j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "also"], ["proof (state)\nthis:\n  row Gsk i \\<bullet> row Gsk j = gso i \\<bullet> gso j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "have \"\\<dots> = (if i = j then sq_norm (gso j) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso i \\<bullet> gso j =\n    (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    gso i \\<bullet> gso j =\n    (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))\n 2. i \\<noteq> j \\<Longrightarrow>\n    gso i \\<bullet> gso j =\n    (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    gso i \\<bullet> gso j =\n    (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))\n 2. i \\<noteq> j \\<Longrightarrow>\n    gso i \\<bullet> gso j =\n    (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. gso i \\<bullet> gso j =\n    (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))", "by (simp add: sq_norm_vec_as_cscalar_prod)"], ["proof (state)\nthis:\n  gso i \\<bullet> gso j =\n  (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    gso i \\<bullet> gso j =\n    (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    gso i \\<bullet> gso j =\n    (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))", "assume \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    gso i \\<bullet> gso j =\n    (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))", "from \\<open>i \\<noteq> j\\<close> orthogonalD[OF orthogonal_gso] ijn assms"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  \\<lbrakk>?i < length (map gso [0..<length fs]);\n   ?j < length (map gso [0..<length fs])\\<rbrakk>\n  \\<Longrightarrow> (map gso [0..<length fs] ! ?i \\<bullet>\n                     map gso [0..<length fs] ! ?j =\n                     (0::'a)) =\n                    (?i \\<noteq> ?j)\n  i < length fs\n  j < length fs\n  k \\<le> length fs", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  \\<lbrakk>?i < length (map gso [0..<length fs]);\n   ?j < length (map gso [0..<length fs])\\<rbrakk>\n  \\<Longrightarrow> (map gso [0..<length fs] ! ?i \\<bullet>\n                     map gso [0..<length fs] ! ?j =\n                     (0::'a)) =\n                    (?i \\<noteq> ?j)\n  i < length fs\n  j < length fs\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. gso i \\<bullet> gso j =\n    (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))", "by auto"], ["proof (state)\nthis:\n  gso i \\<bullet> gso j =\n  (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gso i \\<bullet> gso j =\n  (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "also"], ["proof (state)\nthis:\n  gso i \\<bullet> gso j =\n  (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "have \"\\<dots> = ?M $$ (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)) =\n    mat k k\n     (\\<lambda>(i, j).\n         if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)) $$\n    (i, j)", "using ij"], ["proof (prove)\nusing this:\n  i < k\n  j < k\n\ngoal (1 subgoal):\n 1. (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)) =\n    mat k k\n     (\\<lambda>(i, j).\n         if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)) $$\n    (i, j)", "by simp"], ["proof (state)\nthis:\n  (if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)) =\n  mat k k\n   (\\<lambda>(i, j).\n       if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)) $$\n  (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat k k\n                       (\\<lambda>(i, j).\n                           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                           else (0::'a)));\n        j < dim_col\n             (mat k k\n               (\\<lambda>(i, j).\n                   if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                   else (0::'a)))\\<rbrakk>\n       \\<Longrightarrow> (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n                         mat k k\n                          (\\<lambda>(i, j).\n                              if i = j\n                              then \\<parallel>gso j\\<parallel>\\<^sup>2\n                              else (0::'a)) $$\n                         (i, j)", "finally"], ["proof (chain)\npicking this:\n  (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n  mat k k\n   (\\<lambda>(i, j).\n       if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)) $$\n  (i, j)", "show \"(Gsk * ?TGsk) $$ (i,j) = ?M $$ (i,j)\""], ["proof (prove)\nusing this:\n  (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n  mat k k\n   (\\<lambda>(i, j).\n       if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)) $$\n  (i, j)\n\ngoal (1 subgoal):\n 1. (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n    mat k k\n     (\\<lambda>(i, j).\n         if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)) $$\n    (i, j)", "."], ["proof (state)\nthis:\n  (Gsk * Gsk\\<^sup>T) $$ (i, j) =\n  mat k k\n   (\\<lambda>(i, j).\n       if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a)) $$\n  (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gsk * Gsk\\<^sup>T =\n  mat k k\n   (\\<lambda>(i, j).\n       if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  Gsk * Gsk\\<^sup>T =\n  mat k k\n   (\\<lambda>(i, j).\n       if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"det ?M = prod_list (diag_mat ?M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat k k\n          (\\<lambda>(i, j).\n              if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n              else (0::'a))) =\n    prod_list\n     (diag_mat\n       (mat k k\n         (\\<lambda>(i, j).\n             if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n             else (0::'a))))", "by (rule det_upper_triangular, auto)"], ["proof (state)\nthis:\n  det (mat k k\n        (\\<lambda>(i, j).\n            if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n            else (0::'a))) =\n  prod_list\n   (diag_mat\n     (mat k k\n       (\\<lambda>(i, j).\n           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))))\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  det (mat k k\n        (\\<lambda>(i, j).\n            if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n            else (0::'a))) =\n  prod_list\n   (diag_mat\n     (mat k k\n       (\\<lambda>(i, j).\n           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))))\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"diag_mat ?M = map (\\<lambda> j. sq_norm (gso j)) [0 ..< k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat\n     (mat k k\n       (\\<lambda>(i, j).\n           if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n           else (0::'a))) =\n    map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<k]", "unfolding diag_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            mat k k\n             (\\<lambda>(i, j).\n                 if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n                 else (0::'a)) $$\n            (i, i))\n     [0..<\n      dim_row\n       (mat k k\n         (\\<lambda>(i, j).\n             if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2\n             else (0::'a)))] =\n    map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<k]", "by auto"], ["proof (state)\nthis:\n  diag_mat\n   (mat k k\n     (\\<lambda>(i, j).\n         if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))) =\n  map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<k]\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  diag_mat\n   (mat k k\n     (\\<lambda>(i, j).\n         if i = j then \\<parallel>gso j\\<parallel>\\<^sup>2 else (0::'a))) =\n  map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<k]\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "have \"prod_list \\<dots> = (\\<Prod> j < k. sq_norm (gso j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j\\<leftarrow>[0..<k]. \\<parallel>gso j\\<parallel>\\<^sup>2) =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)", "by (subst prod.distinct_set_conv_list[symmetric], force, rule prod.cong, auto)"], ["proof (state)\nthis:\n  (\\<Prod>j\\<leftarrow>[0..<k]. \\<parallel>gso j\\<parallel>\\<^sup>2) =\n  (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n 2. (0::'a) < Gramian_determinant fs k", "finally"], ["proof (chain)\npicking this:\n  Gramian_determinant fs k =\n  (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)", "show \"Gramian_determinant fs k = (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\""], ["proof (prove)\nusing this:\n  Gramian_determinant fs k =\n  (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs k =\n    (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)", "."], ["proof (state)\nthis:\n  Gramian_determinant fs k =\n  (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (0::'a) < Gramian_determinant fs k", "also"], ["proof (state)\nthis:\n  Gramian_determinant fs k =\n  (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (0::'a) < Gramian_determinant fs k", "have \"\\<dots> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)", "by (rule prod_pos, intro ballI sq_norm_pos, insert k assms, auto)"], ["proof (state)\nthis:\n  (0::'a) < (\\<Prod>j<k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (0::'a) < Gramian_determinant fs k", "finally"], ["proof (chain)\npicking this:\n  (0::'a) < Gramian_determinant fs k", "show \"0 < Gramian_determinant fs k\""], ["proof (prove)\nusing this:\n  (0::'a) < Gramian_determinant fs k\n\ngoal (1 subgoal):\n 1. (0::'a) < Gramian_determinant fs k", "by auto"], ["proof (state)\nthis:\n  (0::'a) < Gramian_determinant fs k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gramian_determinant_div:\n  assumes \"l < m\"\n  shows \"Gramian_determinant fs (Suc l) / Gramian_determinant fs l = \\<parallel>gso l\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc l) / Gramian_determinant fs l =\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc l) / Gramian_determinant fs l =\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "note gram = Gramian_determinant(1)[symmetric]"], ["proof (state)\nthis:\n  ?k \\<le> length fs \\<Longrightarrow>\n  (\\<Prod>j<?k. \\<parallel>gso j\\<parallel>\\<^sup>2) =\n  Gramian_determinant fs ?k\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc l) / Gramian_determinant fs l =\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "from assms"], ["proof (chain)\npicking this:\n  l < length fs", "have le: \"Suc l \\<le> m\" \"l \\<le> m\""], ["proof (prove)\nusing this:\n  l < length fs\n\ngoal (1 subgoal):\n 1. Suc l \\<le> length fs &&& l \\<le> length fs", "by auto"], ["proof (state)\nthis:\n  Suc l \\<le> length fs\n  l \\<le> length fs\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc l) / Gramian_determinant fs l =\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "have \"(\\<Prod>j<Suc l. \\<parallel>gso j\\<parallel>\\<^sup>2) = (\\<Prod>j \\<in> {0..<l} \\<union> {l}. \\<parallel>gso j\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<Suc l. \\<parallel>gso j\\<parallel>\\<^sup>2) =\n    (\\<Prod>j\\<in>{0..<l} \\<union> {l}. \\<parallel>gso j\\<parallel>\\<^sup>2)", "using assms"], ["proof (prove)\nusing this:\n  l < length fs\n\ngoal (1 subgoal):\n 1. (\\<Prod>j<Suc l. \\<parallel>gso j\\<parallel>\\<^sup>2) =\n    (\\<Prod>j\\<in>{0..<l} \\<union> {l}. \\<parallel>gso j\\<parallel>\\<^sup>2)", "by (intro prod.cong) (auto)"], ["proof (state)\nthis:\n  (\\<Prod>j<Suc l. \\<parallel>gso j\\<parallel>\\<^sup>2) =\n  (\\<Prod>j\\<in>{0..<l} \\<union> {l}. \\<parallel>gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc l) / Gramian_determinant fs l =\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Prod>j<Suc l. \\<parallel>gso j\\<parallel>\\<^sup>2) =\n  (\\<Prod>j\\<in>{0..<l} \\<union> {l}. \\<parallel>gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc l) / Gramian_determinant fs l =\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "have \"\\<dots> = (\\<Prod>j<l. \\<parallel>gso j\\<parallel>\\<^sup>2) * \\<parallel>gso l\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j\\<in>{0..<l} \\<union> {l}.\n       \\<parallel>gso j\\<parallel>\\<^sup>2) =\n    (\\<Prod>j<l. \\<parallel>gso j\\<parallel>\\<^sup>2) *\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "using assms"], ["proof (prove)\nusing this:\n  l < length fs\n\ngoal (1 subgoal):\n 1. (\\<Prod>j\\<in>{0..<l} \\<union> {l}.\n       \\<parallel>gso j\\<parallel>\\<^sup>2) =\n    (\\<Prod>j<l. \\<parallel>gso j\\<parallel>\\<^sup>2) *\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "by (subst prod_Un) (auto simp add: atLeast0LessThan)"], ["proof (state)\nthis:\n  (\\<Prod>j\\<in>{0..<l} \\<union> {l}. \\<parallel>gso j\\<parallel>\\<^sup>2) =\n  (\\<Prod>j<l. \\<parallel>gso j\\<parallel>\\<^sup>2) *\n  \\<parallel>gso l\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc l) / Gramian_determinant fs l =\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>j<Suc l. \\<parallel>gso j\\<parallel>\\<^sup>2) =\n  (\\<Prod>j<l. \\<parallel>gso j\\<parallel>\\<^sup>2) *\n  \\<parallel>gso l\\<parallel>\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Prod>j<Suc l. \\<parallel>gso j\\<parallel>\\<^sup>2) =\n  (\\<Prod>j<l. \\<parallel>gso j\\<parallel>\\<^sup>2) *\n  \\<parallel>gso l\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc l) / Gramian_determinant fs l =\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "unfolding gram[OF le(1)] gram[OF le(2)]"], ["proof (prove)\nusing this:\n  Gramian_determinant fs (Suc l) =\n  Gramian_determinant fs l * \\<parallel>gso l\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc l) / Gramian_determinant fs l =\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "using Gramian_determinant(2)[OF le(2)] assms"], ["proof (prove)\nusing this:\n  Gramian_determinant fs (Suc l) =\n  Gramian_determinant fs l * \\<parallel>gso l\\<parallel>\\<^sup>2\n  (0::'a) < Gramian_determinant fs l\n  l < length fs\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs (Suc l) / Gramian_determinant fs l =\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  Gramian_determinant fs (Suc l) / Gramian_determinant fs l =\n  \\<parallel>gso l\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma (in gram_schmidt_fs_Rn) Gramian_determinant_Ints:\n  assumes \"k \\<le> m\" \"\\<And>i j. i < n \\<Longrightarrow> j < m \\<Longrightarrow> fs ! j $ i \\<in> \\<int>\"\n  shows \"Gramian_determinant fs k \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_determinant fs k \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gramian_determinant fs k \\<in> \\<int>", "let ?oi = \"of_int :: int \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. Gramian_determinant fs k \\<in> \\<int>", "from assms"], ["proof (chain)\npicking this:\n  k \\<le> length fs\n  \\<lbrakk>?i1 < n; ?j1 < length fs\\<rbrakk>\n  \\<Longrightarrow> fs ! ?j1 $ ?i1 \\<in> \\<int>", "have \"\\<And> i. i < n \\<Longrightarrow> \\<forall>j. \\<exists> c. j < m \\<longrightarrow> fs ! j $ i = ?oi c\""], ["proof (prove)\nusing this:\n  k \\<le> length fs\n  \\<lbrakk>?i1 < n; ?j1 < length fs\\<rbrakk>\n  \\<Longrightarrow> fs ! ?j1 $ ?i1 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<forall>j.\n          \\<exists>c. j < length fs \\<longrightarrow> fs ! j $ i = of_int c", "unfolding Ints_def"], ["proof (prove)\nusing this:\n  k \\<le> length fs\n  \\<lbrakk>?i1 < n; ?j1 < length fs\\<rbrakk>\n  \\<Longrightarrow> fs ! ?j1 $ ?i1 \\<in> range of_int\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<forall>j.\n          \\<exists>c. j < length fs \\<longrightarrow> fs ! j $ i = of_int c", "by auto"], ["proof (state)\nthis:\n  ?i1 < n \\<Longrightarrow>\n  \\<forall>j.\n     \\<exists>c. j < length fs \\<longrightarrow> fs ! j $ ?i1 = of_int c\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs k \\<in> \\<int>", "from choice[OF this]"], ["proof (chain)\npicking this:\n  ?i2 < n \\<Longrightarrow>\n  \\<exists>f. \\<forall>x<length fs. fs ! x $ ?i2 = of_int (f x)", "have \"\\<forall> i. \\<exists> c. \\<forall> j. i < n \\<longrightarrow> j < m \\<longrightarrow> fs ! j $ i = ?oi (c j)\""], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow>\n  \\<exists>f. \\<forall>x<length fs. fs ! x $ ?i2 = of_int (f x)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>c.\n          \\<forall>j.\n             i < n \\<longrightarrow>\n             j < length fs \\<longrightarrow> fs ! j $ i = of_int (c j)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<exists>c.\n        \\<forall>j.\n           i < n \\<longrightarrow>\n           j < length fs \\<longrightarrow> fs ! j $ i = of_int (c j)\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs k \\<in> \\<int>", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x j.\n        x < n \\<longrightarrow>\n        j < length fs \\<longrightarrow> fs ! j $ x = of_int (f x j)", "obtain c where c: \"\\<And> i j. i < n \\<Longrightarrow> j < m \\<Longrightarrow> fs ! j $ i = ?oi (c i j)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x j.\n        x < n \\<longrightarrow>\n        j < length fs \\<longrightarrow> fs ! j $ x = of_int (f x j)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (\\<And>i j.\n            \\<lbrakk>i < n; j < length fs\\<rbrakk>\n            \\<Longrightarrow> fs ! j $ i = of_int (c i j)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < n; ?j1 < length fs\\<rbrakk>\n  \\<Longrightarrow> fs ! ?j1 $ ?i1 = of_int (c ?i1 ?j1)\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs k \\<in> \\<int>", "define d where \"d = map (\\<lambda> j. vec n (\\<lambda> i. c i j)) [0..<m]\""], ["proof (state)\nthis:\n  d = map (\\<lambda>j. vec n (\\<lambda>i. c i j)) [0..<length fs]\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs k \\<in> \\<int>", "have fs: \"fs = map (map_vec ?oi) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs = map of_int_hom.vec_hom d", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs =\n    map of_int_hom.vec_hom\n     (map (\\<lambda>j. vec n (\\<lambda>i. c i j)) [0..<length fs])", "by (rule nth_equalityI, auto intro!: eq_vecI c)"], ["proof (state)\nthis:\n  fs = map of_int_hom.vec_hom d\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs k \\<in> \\<int>", "have id: \"mat k n (\\<lambda>(i, y). map (map_vec ?oi) d ! i $ y) = map_mat of_int (mat k n (\\<lambda>(i, y). d ! i $ y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, y). map of_int_hom.vec_hom d ! i $ y) =\n    of_int_hom.mat_hom (mat k n (\\<lambda>(i, y). d ! i $ y))", "by (rule eq_matI, insert \\<open>k \\<le> m\\<close>, auto simp: d_def o_def)"], ["proof (state)\nthis:\n  mat k n (\\<lambda>(i, y). map of_int_hom.vec_hom d ! i $ y) =\n  of_int_hom.mat_hom (mat k n (\\<lambda>(i, y). d ! i $ y))\n\ngoal (1 subgoal):\n 1. Gramian_determinant fs k \\<in> \\<int>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_determinant fs k \\<in> \\<int>", "unfolding fs Gramian_determinant_def Gramian_matrix_def Let_def id\n    map_mat_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom (mat k n (\\<lambda>(i, y). d ! i $ y)) *\n         of_int_hom.mat_hom (mat k n (\\<lambda>(i, y). d ! i $ y))\\<^sup>T)\n    \\<in> \\<int>", "by (subst of_int_hom.mat_hom_mult[symmetric], auto)"], ["proof (state)\nthis:\n  Gramian_determinant fs k \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "locale gram_schmidt_fs_int = gram_schmidt_fs_lin_indpt +\n  assumes fs_int: \"\\<And>i j. i < n \\<Longrightarrow> j < m \\<Longrightarrow> fs ! j $ i \\<in> \\<int>\"\nbegin"], ["", "lemma Gramian_determinant_ge1:\n  assumes \"k \\<le> m\"\n  shows \"1 \\<le> Gramian_determinant fs k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> Gramian_determinant fs k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> Gramian_determinant fs k", "have \"0 < Gramian_determinant fs k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < Gramian_determinant fs k", "by (simp add: assms Gramian_determinant(2) less_or_eq_imp_le)"], ["proof (state)\nthis:\n  (0::'a) < Gramian_determinant fs k\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> Gramian_determinant fs k", "moreover"], ["proof (state)\nthis:\n  (0::'a) < Gramian_determinant fs k\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> Gramian_determinant fs k", "have \"Gramian_determinant fs k \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_determinant fs k \\<in> \\<int>", "by (simp add: Gramian_determinant_Ints assms fs_int)"], ["proof (state)\nthis:\n  Gramian_determinant fs k \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> Gramian_determinant fs k", "ultimately"], ["proof (chain)\npicking this:\n  (0::'a) < Gramian_determinant fs k\n  Gramian_determinant fs k \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) < Gramian_determinant fs k\n  Gramian_determinant fs k \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> Gramian_determinant fs k", "using Ints_nonzero_abs_ge1"], ["proof (prove)\nusing this:\n  (0::'a) < Gramian_determinant fs k\n  Gramian_determinant fs k \\<in> \\<int>\n  \\<lbrakk>?x \\<in> \\<int>; ?x \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> (1::?'a) \\<le> \\<bar>?x\\<bar>\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> Gramian_determinant fs k", "by fastforce"], ["proof (state)\nthis:\n  (1::'a) \\<le> Gramian_determinant fs k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mu_bound_Gramian_determinant:\n  assumes \"l < k\" \"k < m\"\n  shows \"(\\<mu> k l)\\<^sup>2 \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "have \"(\\<mu> k l)\\<^sup>2  = (fs ! k \\<bullet> gso l)\\<^sup>2 / (\\<parallel>gso l\\<parallel>\\<^sup>2)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2 =\n    (fs ! k \\<bullet> gso l)\\<^sup>2 /\n    \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2", "using assms"], ["proof (prove)\nusing this:\n  l < k\n  k < length fs\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2 =\n    (fs ! k \\<bullet> gso l)\\<^sup>2 /\n    \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2", "by (simp add: power_divide \\<mu>.simps)"], ["proof (state)\nthis:\n  (\\<mu> k l)\\<^sup>2 =\n  (fs ! k \\<bullet> gso l)\\<^sup>2 /\n  \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<mu> k l)\\<^sup>2 =\n  (fs ! k \\<bullet> gso l)\\<^sup>2 /\n  \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "have \"\\<dots> \\<le> (\\<parallel>fs ! k\\<parallel>\\<^sup>2 * \\<parallel>gso l\\<parallel>\\<^sup>2) / (\\<parallel>gso l\\<parallel>\\<^sup>2)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! k \\<bullet> gso l)\\<^sup>2 /\n    \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2\n    \\<le> \\<parallel>fs ! k\\<parallel>\\<^sup>2 *\n          \\<parallel>gso l\\<parallel>\\<^sup>2 /\n          \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2", "using assms"], ["proof (prove)\nusing this:\n  l < k\n  k < length fs\n\ngoal (1 subgoal):\n 1. (fs ! k \\<bullet> gso l)\\<^sup>2 /\n    \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2\n    \\<le> \\<parallel>fs ! k\\<parallel>\\<^sup>2 *\n          \\<parallel>gso l\\<parallel>\\<^sup>2 /\n          \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2", "by (auto intro!: scalar_prod_Cauchy divide_right_mono)"], ["proof (state)\nthis:\n  (fs ! k \\<bullet> gso l)\\<^sup>2 /\n  \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2\n  \\<le> \\<parallel>fs ! k\\<parallel>\\<^sup>2 *\n        \\<parallel>gso l\\<parallel>\\<^sup>2 /\n        \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (fs ! k \\<bullet> gso l)\\<^sup>2 /\n  \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2\n  \\<le> \\<parallel>fs ! k\\<parallel>\\<^sup>2 *\n        \\<parallel>gso l\\<parallel>\\<^sup>2 /\n        \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "have \"\\<dots> = \\<parallel>fs ! k\\<parallel>\\<^sup>2 / \\<parallel>gso l\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! k\\<parallel>\\<^sup>2 *\n    \\<parallel>gso l\\<parallel>\\<^sup>2 /\n    \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2 =\n    \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "by (auto simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  \\<parallel>fs ! k\\<parallel>\\<^sup>2 *\n  \\<parallel>gso l\\<parallel>\\<^sup>2 /\n  \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2 =\n  \\<parallel>fs ! k\\<parallel>\\<^sup>2 / \\<parallel>gso l\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>fs ! k\\<parallel>\\<^sup>2 *\n  \\<parallel>gso l\\<parallel>\\<^sup>2 /\n  \\<parallel>gso l\\<parallel>\\<^sup>2\\<^sup>2 =\n  \\<parallel>fs ! k\\<parallel>\\<^sup>2 / \\<parallel>gso l\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "have \"\\<dots> =  \\<parallel>fs ! k\\<parallel>\\<^sup>2 / (Gramian_determinant fs (Suc l) / Gramian_determinant fs l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n    \\<parallel>gso l\\<parallel>\\<^sup>2 =\n    \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n    (Gramian_determinant fs (Suc l) / Gramian_determinant fs l)", "using assms"], ["proof (prove)\nusing this:\n  l < k\n  k < length fs\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n    \\<parallel>gso l\\<parallel>\\<^sup>2 =\n    \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n    (Gramian_determinant fs (Suc l) / Gramian_determinant fs l)", "by (subst Gramian_determinant_div[symmetric]) auto"], ["proof (state)\nthis:\n  \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n  \\<parallel>gso l\\<parallel>\\<^sup>2 =\n  \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n  (Gramian_determinant fs (Suc l) / Gramian_determinant fs l)\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n  \\<parallel>gso l\\<parallel>\\<^sup>2 =\n  \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n  (Gramian_determinant fs (Suc l) / Gramian_determinant fs l)\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "have \"\\<dots> =  Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2 / Gramian_determinant fs (Suc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n    (Gramian_determinant fs (Suc l) / Gramian_determinant fs l) =\n    Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n    Gramian_determinant fs (Suc l)", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n  (Gramian_determinant fs (Suc l) / Gramian_determinant fs l) =\n  Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n  Gramian_determinant fs (Suc l)\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n  (Gramian_determinant fs (Suc l) / Gramian_determinant fs l) =\n  Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n  Gramian_determinant fs (Suc l)\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "have \"\\<dots> \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2 / 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n    Gramian_determinant fs (Suc l)\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n          (1::'a)", "by (rule divide_left_mono, insert Gramian_determinant_ge1[of l] Gramian_determinant_ge1[of \"Suc l\"] assms,\n    auto intro!: mult_nonneg_nonneg)"], ["proof (state)\nthis:\n  Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n  Gramian_determinant fs (Suc l)\n  \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n        (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  (\\<mu> k l)\\<^sup>2\n  \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n        (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<mu> k l)\\<^sup>2\n  \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2 /\n        (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<mu> k l)\\<^sup>2\n    \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (\\<mu> k l)\\<^sup>2\n  \\<le> Gramian_determinant fs l * \\<parallel>fs ! k\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* gram_schmidt_fs_int *)"], ["", "context gram_schmidt\nbegin"], ["", "lemma gso_cong:\n  fixes f1 f2 :: \"'a vec list\"\n  assumes \"\\<And> i. i \\<le> x \\<Longrightarrow> f1 ! i = f2 ! i\"\n  shows \"gram_schmidt_fs.gso n f1 x = gram_schmidt_fs.gso n f2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.gso n f1 x = gram_schmidt_fs.gso n f2 x", "using assms"], ["proof (prove)\nusing this:\n  ?i3 \\<le> x \\<Longrightarrow> f1 ! ?i3 = f2 ! ?i3\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.gso n f1 x = gram_schmidt_fs.gso n f2 x", "proof(induct x rule:nat_less_induct[rule_format])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < na;\n                    \\<And>i.\n                       i \\<le> m \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_fs.gso n f1 m =\n                                     gram_schmidt_fs.gso n f2 m;\n        \\<And>i. i \\<le> na \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.gso n f1 na =\n                         gram_schmidt_fs.gso n f2 na", "case (1 x)"], ["proof (state)\nthis:\n  \\<lbrakk>?m3 < x;\n   \\<And>i. i \\<le> ?m3 \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.gso n f1 ?m3 =\n                    gram_schmidt_fs.gso n f2 ?m3\n  ?i3 \\<le> x \\<Longrightarrow> f1 ! ?i3 = f2 ! ?i3\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < na;\n                    \\<And>i.\n                       i \\<le> m \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n                   \\<Longrightarrow> gram_schmidt_fs.gso n f1 m =\n                                     gram_schmidt_fs.gso n f2 m;\n        \\<And>i. i \\<le> na \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n       \\<Longrightarrow> gram_schmidt_fs.gso n f1 na =\n                         gram_schmidt_fs.gso n f2 na", "interpret f1: gram_schmidt_fs n f1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < na;\n                    \\<And>i.\n                       i \\<le> m \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n                   \\<Longrightarrow> f1.gso m = gram_schmidt_fs.gso n f2 m;\n        \\<And>i. i \\<le> na \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n       \\<Longrightarrow> f1.gso na = gram_schmidt_fs.gso n f2 na", "interpret f2: gram_schmidt_fs n f2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < n;\n                    \\<And>i.\n                       i \\<le> m \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n                   \\<Longrightarrow> f1.gso m = f2.gso m;\n        \\<And>i. i \\<le> n \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n       \\<Longrightarrow> f1.gso n = f2.gso n", "have *: \"map (\\<lambda>j. - f1.\\<mu> x j \\<cdot>\\<^sub>v f1.gso j) [0..<x] = map (\\<lambda>j. - f2.\\<mu> x j \\<cdot>\\<^sub>v f2.gso j) [0..<x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>j. - f1.\\<mu> x j \\<cdot>\\<^sub>v f1.gso j) [0..<x] =\n    map (\\<lambda>j. - f2.\\<mu> x j \\<cdot>\\<^sub>v f2.gso j) [0..<x]", "using 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m3 < x;\n   \\<And>i. i \\<le> ?m3 \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n  \\<Longrightarrow> f1.gso ?m3 = f2.gso ?m3\n  ?i3 \\<le> x \\<Longrightarrow> f1 ! ?i3 = f2 ! ?i3\n\ngoal (1 subgoal):\n 1. map (\\<lambda>j. - f1.\\<mu> x j \\<cdot>\\<^sub>v f1.gso j) [0..<x] =\n    map (\\<lambda>j. - f2.\\<mu> x j \\<cdot>\\<^sub>v f2.gso j) [0..<x]", "by (intro map_cong) (auto simp add: f1.\\<mu>.simps f2.\\<mu>.simps)"], ["proof (state)\nthis:\n  map (\\<lambda>j. - f1.\\<mu> x j \\<cdot>\\<^sub>v f1.gso j) [0..<x] =\n  map (\\<lambda>j. - f2.\\<mu> x j \\<cdot>\\<^sub>v f2.gso j) [0..<x]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>m < n;\n                    \\<And>i.\n                       i \\<le> m \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n                   \\<Longrightarrow> f1.gso m = f2.gso m;\n        \\<And>i. i \\<le> n \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n       \\<Longrightarrow> f1.gso n = f2.gso n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f1.gso x = f2.gso x", "using 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m3 < x;\n   \\<And>i. i \\<le> ?m3 \\<Longrightarrow> f1 ! i = f2 ! i\\<rbrakk>\n  \\<Longrightarrow> f1.gso ?m3 = f2.gso ?m3\n  ?i3 \\<le> x \\<Longrightarrow> f1 ! ?i3 = f2 ! ?i3\n\ngoal (1 subgoal):\n 1. f1.gso x = f2.gso x", "by (subst f1.gso.simps, subst f2.gso.simps, subst *) auto"], ["proof (state)\nthis:\n  f1.gso x = f2.gso x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<mu>_cong:\n  fixes f1 f2 :: \"'a vec list\"\n  assumes \"\\<And> k. j < i \\<Longrightarrow> k \\<le> j \\<Longrightarrow> f1 ! k = f2 ! k\"\n    and \"j < i \\<Longrightarrow> f1 ! i = f2 ! i\" \n  shows \"gram_schmidt_fs.\\<mu> n f1 i j = gram_schmidt_fs.\\<mu> n f2 i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.\\<mu> n f1 i j = gram_schmidt_fs.\\<mu> n f2 i j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.\\<mu> n f1 i j = gram_schmidt_fs.\\<mu> n f2 i j", "interpret f1: gram_schmidt_fs n f1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. f1.\\<mu> i j = gram_schmidt_fs.\\<mu> n f2 i j", "interpret f2: gram_schmidt_fs n f2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. f1.\\<mu> i j = f2.\\<mu> i j", "from gso_cong[of j f1 f2] assms"], ["proof (chain)\npicking this:\n  (\\<And>i. i \\<le> j \\<Longrightarrow> f1 ! i = f2 ! i) \\<Longrightarrow>\n  f1.gso j = f2.gso j\n  \\<lbrakk>j < i; ?k3 \\<le> j\\<rbrakk> \\<Longrightarrow> f1 ! ?k3 = f2 ! ?k3\n  j < i \\<Longrightarrow> f1 ! i = f2 ! i", "have id: \"j < i \\<Longrightarrow> f1.gso j = f2.gso j\""], ["proof (prove)\nusing this:\n  (\\<And>i. i \\<le> j \\<Longrightarrow> f1 ! i = f2 ! i) \\<Longrightarrow>\n  f1.gso j = f2.gso j\n  \\<lbrakk>j < i; ?k3 \\<le> j\\<rbrakk> \\<Longrightarrow> f1 ! ?k3 = f2 ! ?k3\n  j < i \\<Longrightarrow> f1 ! i = f2 ! i\n\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow> f1.gso j = f2.gso j", "by auto"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow> f1.gso j = f2.gso j\n\ngoal (1 subgoal):\n 1. f1.\\<mu> i j = f2.\\<mu> i j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f1.\\<mu> i j = f2.\\<mu> i j", "unfolding f1.\\<mu>.simps f2.\\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j < i\n     then f1 ! i \\<bullet> f1.gso j / \\<parallel>f1.gso j\\<parallel>\\<^sup>2\n     else if i = j then 1::'a else (0::'a)) =\n    (if j < i\n     then f2 ! i \\<bullet> f2.gso j / \\<parallel>f2.gso j\\<parallel>\\<^sup>2\n     else if i = j then 1::'a else (0::'a))", "using assms id"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < i; ?k3 \\<le> j\\<rbrakk> \\<Longrightarrow> f1 ! ?k3 = f2 ! ?k3\n  j < i \\<Longrightarrow> f1 ! i = f2 ! i\n  j < i \\<Longrightarrow> f1.gso j = f2.gso j\n\ngoal (1 subgoal):\n 1. (if j < i\n     then f1 ! i \\<bullet> f1.gso j / \\<parallel>f1.gso j\\<parallel>\\<^sup>2\n     else if i = j then 1::'a else (0::'a)) =\n    (if j < i\n     then f2 ! i \\<bullet> f2.gso j / \\<parallel>f2.gso j\\<parallel>\\<^sup>2\n     else if i = j then 1::'a else (0::'a))", "by auto"], ["proof (state)\nthis:\n  f1.\\<mu> i j = f2.\\<mu> i j\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma prod_list_le_mono: fixes us :: \"'a :: {linordered_nonzero_semiring,ordered_ring} list\" \n  assumes \"length us = length vs\" \n  and \"\\<And> i. i < length vs \\<Longrightarrow> 0 \\<le> us ! i \\<and> us ! i \\<le> vs ! i\" \nshows \"0 \\<le> prod_list us \\<and> prod_list us \\<le> prod_list vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> prod_list us \\<and> prod_list us \\<le> prod_list vs", "using assms"], ["proof (prove)\nusing this:\n  length us = length vs\n  ?i < length vs \\<Longrightarrow>\n  (0::'a) \\<le> us ! ?i \\<and> us ! ?i \\<le> vs ! ?i\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> prod_list us \\<and> prod_list us \\<le> prod_list vs", "proof (induction us vs rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        (0::'a) \\<le> [] ! i \\<and> [] ! i \\<le> [] ! i) \\<Longrightarrow>\n    (0::'a) \\<le> prod_list [] \\<and> prod_list [] \\<le> prod_list []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length ys \\<Longrightarrow>\n            (0::'a) \\<le> xs ! i \\<and>\n            xs ! i \\<le> ys ! i) \\<Longrightarrow>\n        (0::'a) \\<le> prod_list xs \\<and> prod_list xs \\<le> prod_list ys;\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           (0::'a) \\<le> (x # xs) ! i \\<and>\n           (x # xs) ! i \\<le> (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> (0::'a) \\<le> prod_list (x # xs) \\<and>\n                         prod_list (x # xs) \\<le> prod_list (y # ys)", "case (Cons u us v vs)"], ["proof (state)\nthis:\n  length us = length vs\n  (\\<And>i.\n      i < length vs \\<Longrightarrow>\n      (0::'a) \\<le> us ! i \\<and> us ! i \\<le> vs ! i) \\<Longrightarrow>\n  (0::'a) \\<le> prod_list us \\<and> prod_list us \\<le> prod_list vs\n  ?i < length (v # vs) \\<Longrightarrow>\n  (0::'a) \\<le> (u # us) ! ?i \\<and> (u # us) ! ?i \\<le> (v # vs) ! ?i\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        (0::'a) \\<le> [] ! i \\<and> [] ! i \\<le> [] ! i) \\<Longrightarrow>\n    (0::'a) \\<le> prod_list [] \\<and> prod_list [] \\<le> prod_list []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length ys \\<Longrightarrow>\n            (0::'a) \\<le> xs ! i \\<and>\n            xs ! i \\<le> ys ! i) \\<Longrightarrow>\n        (0::'a) \\<le> prod_list xs \\<and> prod_list xs \\<le> prod_list ys;\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           (0::'a) \\<le> (x # xs) ! i \\<and>\n           (x # xs) ! i \\<le> (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> (0::'a) \\<le> prod_list (x # xs) \\<and>\n                         prod_list (x # xs) \\<le> prod_list (y # ys)", "have \"0 \\<le> prod_list us \\<and> prod_list us \\<le> prod_list vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> prod_list us \\<and> prod_list us \\<le> prod_list vs", "by (rule Cons.IH, insert Cons.prems[of \"Suc i\" for i], auto)"], ["proof (state)\nthis:\n  (0::'a) \\<le> prod_list us \\<and> prod_list us \\<le> prod_list vs\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        (0::'a) \\<le> [] ! i \\<and> [] ! i \\<le> [] ! i) \\<Longrightarrow>\n    (0::'a) \\<le> prod_list [] \\<and> prod_list [] \\<le> prod_list []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length ys \\<Longrightarrow>\n            (0::'a) \\<le> xs ! i \\<and>\n            xs ! i \\<le> ys ! i) \\<Longrightarrow>\n        (0::'a) \\<le> prod_list xs \\<and> prod_list xs \\<le> prod_list ys;\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           (0::'a) \\<le> (x # xs) ! i \\<and>\n           (x # xs) ! i \\<le> (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> (0::'a) \\<le> prod_list (x # xs) \\<and>\n                         prod_list (x # xs) \\<le> prod_list (y # ys)", "moreover"], ["proof (state)\nthis:\n  (0::'a) \\<le> prod_list us \\<and> prod_list us \\<le> prod_list vs\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        (0::'a) \\<le> [] ! i \\<and> [] ! i \\<le> [] ! i) \\<Longrightarrow>\n    (0::'a) \\<le> prod_list [] \\<and> prod_list [] \\<le> prod_list []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length ys \\<Longrightarrow>\n            (0::'a) \\<le> xs ! i \\<and>\n            xs ! i \\<le> ys ! i) \\<Longrightarrow>\n        (0::'a) \\<le> prod_list xs \\<and> prod_list xs \\<le> prod_list ys;\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           (0::'a) \\<le> (x # xs) ! i \\<and>\n           (x # xs) ! i \\<le> (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> (0::'a) \\<le> prod_list (x # xs) \\<and>\n                         prod_list (x # xs) \\<le> prod_list (y # ys)", "have \"0 \\<le> u \\<and> u \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> u \\<and> u \\<le> v", "using Cons.prems[of 0]"], ["proof (prove)\nusing this:\n  0 < length (v # vs) \\<Longrightarrow>\n  (0::'a) \\<le> (u # us) ! 0 \\<and> (u # us) ! 0 \\<le> (v # vs) ! 0\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> u \\<and> u \\<le> v", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> u \\<and> u \\<le> v\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        (0::'a) \\<le> [] ! i \\<and> [] ! i \\<le> [] ! i) \\<Longrightarrow>\n    (0::'a) \\<le> prod_list [] \\<and> prod_list [] \\<le> prod_list []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (\\<And>i.\n            i < length ys \\<Longrightarrow>\n            (0::'a) \\<le> xs ! i \\<and>\n            xs ! i \\<le> ys ! i) \\<Longrightarrow>\n        (0::'a) \\<le> prod_list xs \\<and> prod_list xs \\<le> prod_list ys;\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           (0::'a) \\<le> (x # xs) ! i \\<and>\n           (x # xs) ! i \\<le> (y # ys) ! i\\<rbrakk>\n       \\<Longrightarrow> (0::'a) \\<le> prod_list (x # xs) \\<and>\n                         prod_list (x # xs) \\<le> prod_list (y # ys)", "ultimately"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> prod_list us \\<and> prod_list us \\<le> prod_list vs\n  (0::'a) \\<le> u \\<and> u \\<le> v", "show ?case"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> prod_list us \\<and> prod_list us \\<le> prod_list vs\n  (0::'a) \\<le> u \\<and> u \\<le> v\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> prod_list (u # us) \\<and>\n    prod_list (u # us) \\<le> prod_list (v # vs)", "by (auto intro: mult_mono)"], ["proof (state)\nthis:\n  (0::'a) \\<le> prod_list (u # us) \\<and>\n  prod_list (u # us) \\<le> prod_list (v # vs)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length [] \\<Longrightarrow>\n        (0::'a) \\<le> [] ! i \\<and> [] ! i \\<le> [] ! i) \\<Longrightarrow>\n    (0::'a) \\<le> prod_list [] \\<and> prod_list [] \\<le> prod_list []", "qed simp"], ["", "lemma lattice_of_of_int: assumes G: \"set F \\<subseteq> carrier_vec n\" \n  and \"f \\<in> vec_module.lattice_of n F\"     \nshows \"map_vec rat_of_int f \\<in> vec_module.lattice_of n (map (map_vec of_int) F)\" \n  (is \"?f \\<in> vec_module.lattice_of _ ?F\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)", "let ?sl = \"abelian_monoid.sumlist (module_vec TYPE('a::semiring_1) n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)", "note d = vec_module.lattice_of_def"], ["proof (state)\nthis:\n  vec_module.lattice_of ?n ?fs =\n  range\n   (\\<lambda>c.\n       abelian_monoid.sumlist (module_vec TYPE(?'a) ?n)\n        (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v ?fs ! i)\n          [0..<length ?fs]))\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)", "note dim = vec_module.sumlist_dim"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> set ?xs \\<Longrightarrow>\n      x \\<in> carrier_vec ?n) \\<Longrightarrow>\n  dim_vec (abelian_monoid.sumlist (module_vec TYPE(?'a) ?n) ?xs) = ?n\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)", "note sumlist_vec_index = vec_module.sumlist_vec_index"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x.\n              x \\<in> set ?xs \\<Longrightarrow> x \\<in> carrier_vec ?n;\n   ?i < ?n\\<rbrakk>\n  \\<Longrightarrow> abelian_monoid.sumlist (module_vec TYPE(?'a) ?n) ?xs $\n                    ?i =\n                    (\\<Sum>x\\<leftarrow>?xs. x $ ?i)\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)", "from G"], ["proof (chain)\npicking this:\n  set F \\<subseteq> carrier_vec n", "have Gi: \"\\<And> i. i < length F \\<Longrightarrow> F ! i \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set F \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length F \\<Longrightarrow> F ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?i1 < length F \\<Longrightarrow> F ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)", "from Gi"], ["proof (chain)\npicking this:\n  ?i1 < length F \\<Longrightarrow> F ! ?i1 \\<in> carrier_vec n", "have Gid: \"\\<And> i. i < length F \\<Longrightarrow> dim_vec (F ! i) = n\""], ["proof (prove)\nusing this:\n  ?i1 < length F \\<Longrightarrow> F ! ?i1 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length F \\<Longrightarrow> dim_vec (F ! i) = n", "by auto"], ["proof (state)\nthis:\n  ?i1 < length F \\<Longrightarrow> dim_vec (F ! ?i1) = n\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)", "from assms(2)[unfolded d]"], ["proof (chain)\npicking this:\n  f \\<in> range\n           (\\<lambda>c.\n               abelian_monoid.sumlist (module_vec TYPE(int) n)\n                (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v F ! i)\n                  [0..<length F]))", "obtain c where \n    ffc: \"f = ?sl (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v F ! i) [0..<length F])\" (is \"_ = ?g\")"], ["proof (prove)\nusing this:\n  f \\<in> range\n           (\\<lambda>c.\n               abelian_monoid.sumlist (module_vec TYPE(int) n)\n                (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v F ! i)\n                  [0..<length F]))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f =\n        abelian_monoid.sumlist (module_vec TYPE(int) n)\n         (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v F ! i)\n           [0..<length F]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f =\n  abelian_monoid.sumlist (module_vec TYPE(int) n)\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v F ! i) [0..<length F])\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)", "have \"?f = ?sl (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v ?F ! i) [0..<length ?F])\" (is \"_ = ?gg\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f =\n    abelian_monoid.sumlist (module_vec TYPE(rat) n)\n     (map (\\<lambda>i.\n              rat_of_int (c i) \\<cdot>\\<^sub>v map of_int_hom.vec_hom F ! i)\n       [0..<length (map of_int_hom.vec_hom F)])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f =\n    abelian_monoid.sumlist (module_vec TYPE(rat) n)\n     (map (\\<lambda>i.\n              rat_of_int (c i) \\<cdot>\\<^sub>v map of_int_hom.vec_hom F ! i)\n       [0..<length (map of_int_hom.vec_hom F)])", "have d1[simp]: \"dim_vec ?g = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (abelian_monoid.sumlist (module_vec TYPE(int) n)\n       (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v F ! i)\n         [0..<length F])) =\n    n", "by (subst dim, auto simp: Gi)"], ["proof (state)\nthis:\n  dim_vec\n   (abelian_monoid.sumlist (module_vec TYPE(int) n)\n     (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v F ! i)\n       [0..<length F])) =\n  n\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f =\n    abelian_monoid.sumlist (module_vec TYPE(rat) n)\n     (map (\\<lambda>i.\n              rat_of_int (c i) \\<cdot>\\<^sub>v map of_int_hom.vec_hom F ! i)\n       [0..<length (map of_int_hom.vec_hom F)])", "have d2[simp]: \"dim_vec ?gg = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (abelian_monoid.sumlist (module_vec TYPE(rat) n)\n       (map (\\<lambda>i.\n                rat_of_int (c i) \\<cdot>\\<^sub>v\n                map of_int_hom.vec_hom F ! i)\n         [0..<length (map of_int_hom.vec_hom F)])) =\n    n", "unfolding length_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (abelian_monoid.sumlist (module_vec TYPE(rat) n)\n       (map (\\<lambda>i.\n                rat_of_int (c i) \\<cdot>\\<^sub>v\n                map of_int_hom.vec_hom F ! i)\n         [0..<length F])) =\n    n", "by (subst vec_module.sumlist_dim, auto simp: Gi G)"], ["proof (state)\nthis:\n  dim_vec\n   (abelian_monoid.sumlist (module_vec TYPE(rat) n)\n     (map (\\<lambda>i.\n              rat_of_int (c i) \\<cdot>\\<^sub>v map of_int_hom.vec_hom F ! i)\n       [0..<length (map of_int_hom.vec_hom F)])) =\n  n\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f =\n    abelian_monoid.sumlist (module_vec TYPE(rat) n)\n     (map (\\<lambda>i.\n              rat_of_int (c i) \\<cdot>\\<^sub>v map of_int_hom.vec_hom F ! i)\n       [0..<length (map of_int_hom.vec_hom F)])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f =\n    abelian_monoid.sumlist (module_vec TYPE(rat) n)\n     (map (\\<lambda>i.\n              rat_of_int (c i) \\<cdot>\\<^sub>v map of_int_hom.vec_hom F ! i)\n       [0..<length (map of_int_hom.vec_hom F)])", "unfolding ffc length_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom\n     (abelian_monoid.sumlist (module_vec TYPE(int) n)\n       (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v F ! i)\n         [0..<length F])) =\n    abelian_monoid.sumlist (module_vec TYPE(rat) n)\n     (map (\\<lambda>i.\n              rat_of_int (c i) \\<cdot>\\<^sub>v map of_int_hom.vec_hom F ! i)\n       [0..<length F])", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (abelian_monoid.sumlist (module_vec TYPE(rat) n)\n              (map (\\<lambda>i.\n                       rat_of_int (c i) \\<cdot>\\<^sub>v\n                       map of_int_hom.vec_hom F ! i)\n                [0..<length F])) \\<Longrightarrow>\n       of_int_hom.vec_hom\n        (abelian_monoid.sumlist (module_vec TYPE(int) n)\n          (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v F ! i)\n            [0..<length F])) $\n       i =\n       abelian_monoid.sumlist (module_vec TYPE(rat) n)\n        (map (\\<lambda>i.\n                 rat_of_int (c i) \\<cdot>\\<^sub>v\n                 map of_int_hom.vec_hom F ! i)\n          [0..<length F]) $\n       i\n 2. dim_vec\n     (of_int_hom.vec_hom\n       (abelian_monoid.sumlist (module_vec TYPE(int) n)\n         (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v F ! i)\n           [0..<length F]))) =\n    dim_vec\n     (abelian_monoid.sumlist (module_vec TYPE(rat) n)\n       (map (\\<lambda>i.\n                rat_of_int (c i) \\<cdot>\\<^sub>v\n                map of_int_hom.vec_hom F ! i)\n         [0..<length F]))", "apply (insert d1 d2, auto)[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < n;\n        dim_vec\n         (abelian_monoid.sumlist (module_vec TYPE(int) n)\n           (map (\\<lambda>i. c i \\<cdot>\\<^sub>v F ! i) [0..<length F])) =\n        n;\n        dim_vec\n         (abelian_monoid.sumlist (module_vec TYPE(rat) n)\n           (map (\\<lambda>i.\n                    rat_of_int (c i) \\<cdot>\\<^sub>v\n                    map of_int_hom.vec_hom F ! i)\n             [0..<length F])) =\n        n\\<rbrakk>\n       \\<Longrightarrow> rat_of_int\n                          (abelian_monoid.sumlist (module_vec TYPE(int) n)\n                            (map (\\<lambda>i. c i \\<cdot>\\<^sub>v F ! i)\n                              [0..<length F]) $\n                           i) =\n                         abelian_monoid.sumlist (module_vec TYPE(rat) n)\n                          (map (\\<lambda>i.\n                                   rat_of_int (c i) \\<cdot>\\<^sub>v\n                                   map of_int_hom.vec_hom F ! i)\n                            [0..<length F]) $\n                         i", "apply (subst (1 2) sumlist_vec_index, auto simp: o_def Gi G)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < n;\n        dim_vec\n         (abelian_monoid.sumlist (module_vec TYPE(int) n)\n           (map (\\<lambda>i. c i \\<cdot>\\<^sub>v F ! i) [0..<length F])) =\n        n;\n        dim_vec\n         (abelian_monoid.sumlist (module_vec TYPE(rat) n)\n           (map (\\<lambda>i.\n                    rat_of_int (c i) \\<cdot>\\<^sub>v\n                    map of_int_hom.vec_hom F ! i)\n             [0..<length F])) =\n        n\\<rbrakk>\n       \\<Longrightarrow> rat_of_int\n                          (\\<Sum>x\\<leftarrow>[0..<\n         length F]. (c x \\<cdot>\\<^sub>v F ! x) $ i) =\n                         (\\<Sum>x\\<leftarrow>[0..<\n        length\n         F]. (rat_of_int (c x) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom F ! x) $\n             i)", "apply (unfold of_int_hom.hom_sum_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < n;\n        dim_vec\n         (abelian_monoid.sumlist (module_vec TYPE(int) n)\n           (map (\\<lambda>i. c i \\<cdot>\\<^sub>v F ! i) [0..<length F])) =\n        n;\n        dim_vec\n         (abelian_monoid.sumlist (module_vec TYPE(rat) n)\n           (map (\\<lambda>i.\n                    rat_of_int (c i) \\<cdot>\\<^sub>v\n                    map of_int_hom.vec_hom F ! i)\n             [0..<length F])) =\n        n\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map rat_of_int\n                            (map (\\<lambda>x.\n                                     (c x \\<cdot>\\<^sub>v F ! x) $ i)\n                              [0..<length F])) =\n                         (\\<Sum>x\\<leftarrow>[0..<\n        length\n         F]. (rat_of_int (c x) \\<cdot>\\<^sub>v\n              map of_int_hom.vec_hom F ! x) $\n             i)", "apply (intro arg_cong[of _ _ sum_list] map_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < n;\n        dim_vec\n         (abelian_monoid.sumlist (module_vec TYPE(int) n)\n           (map (\\<lambda>i. c i \\<cdot>\\<^sub>v F ! i) [0..<length F])) =\n        n;\n        dim_vec\n         (abelian_monoid.sumlist (module_vec TYPE(rat) n)\n           (map (\\<lambda>i.\n                    rat_of_int (c i) \\<cdot>\\<^sub>v\n                    map of_int_hom.vec_hom F ! i)\n             [0..<length F])) =\n        n\\<rbrakk>\n       \\<Longrightarrow> map rat_of_int\n                          (map (\\<lambda>x. (c x \\<cdot>\\<^sub>v F ! x) $ i)\n                            [0..<length F]) =\n                         map (\\<lambda>x.\n                                 (rat_of_int (c x) \\<cdot>\\<^sub>v\n                                  map of_int_hom.vec_hom F ! x) $\n                                 i)\n                          [0..<length F]", "by (auto simp: G Gi, (subst index_smult_vec, simp add: Gid)+,\n         subst index_map_vec, auto simp: Gid)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom f =\n  abelian_monoid.sumlist (module_vec TYPE(rat) n)\n   (map (\\<lambda>i.\n            rat_of_int (c i) \\<cdot>\\<^sub>v map of_int_hom.vec_hom F ! i)\n     [0..<length (map of_int_hom.vec_hom F)])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_int_hom.vec_hom f =\n  abelian_monoid.sumlist (module_vec TYPE(rat) n)\n   (map (\\<lambda>i.\n            rat_of_int (c i) \\<cdot>\\<^sub>v map of_int_hom.vec_hom F ! i)\n     [0..<length (map of_int_hom.vec_hom F)])\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)", "thus \"?f \\<in> vec_module.lattice_of n ?F\""], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom f =\n  abelian_monoid.sumlist (module_vec TYPE(rat) n)\n   (map (\\<lambda>i.\n            rat_of_int (c i) \\<cdot>\\<^sub>v map of_int_hom.vec_hom F ! i)\n     [0..<length (map of_int_hom.vec_hom F)])\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)", "unfolding d"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom f =\n  abelian_monoid.sumlist (module_vec TYPE(rat) n)\n   (map (\\<lambda>i.\n            rat_of_int (c i) \\<cdot>\\<^sub>v map of_int_hom.vec_hom F ! i)\n     [0..<length (map of_int_hom.vec_hom F)])\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom f\n    \\<in> range\n           (\\<lambda>c.\n               abelian_monoid.sumlist (module_vec TYPE(rat) n)\n                (map (\\<lambda>i.\n                         rat_of_int (c i) \\<cdot>\\<^sub>v\n                         map of_int_hom.vec_hom F ! i)\n                  [0..<length (map of_int_hom.vec_hom F)]))", "by auto"], ["proof (state)\nthis:\n  of_int_hom.vec_hom f\n  \\<in> vec_module.lattice_of n (map of_int_hom.vec_hom F)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Theorem 16.6, difficult part *)"], ["", "lemma Hadamard's_inequality: \n  fixes A::\"real mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" \n  shows  \"abs (det A) \\<le> sqrt (prod_list (map sq_norm (rows A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "let ?us = \"map (row A) [0 ..< n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "interpret gso: gram_schmidt_fs n ?us"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have len: \"length ?us = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (row A) [0..<n]) = n", "by simp"], ["proof (state)\nthis:\n  length (map (row A) [0..<n]) = n\n\ngoal (1 subgoal):\n 1. \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have us: \"set ?us \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (row A) [0..<n]) \\<subseteq> carrier_vec n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. set (map (row A) [0..<n]) \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (map (row A) [0..<n]) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "let ?vs = \"map gso.gso [0..<n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "proof (cases \"carrier_vec n \\<subseteq> gso.span (set ?us)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "case True"], ["proof (state)\nthis:\n  carrier_vec n \\<subseteq> gso.span (set (map (row A) [0..<n]))\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "with us len"], ["proof (chain)\npicking this:\n  set (map (row A) [0..<n]) \\<subseteq> carrier_vec n\n  length (map (row A) [0..<n]) = n\n  carrier_vec n \\<subseteq> gso.span (set (map (row A) [0..<n]))", "have basis: \"gso.basis_list ?us\""], ["proof (prove)\nusing this:\n  set (map (row A) [0..<n]) \\<subseteq> carrier_vec n\n  length (map (row A) [0..<n]) = n\n  carrier_vec n \\<subseteq> gso.span (set (map (row A) [0..<n]))\n\ngoal (1 subgoal):\n 1. gso.basis_list (map (row A) [0..<n])", "unfolding gso.basis_list_def"], ["proof (prove)\nusing this:\n  set (map (row A) [0..<n]) \\<subseteq> carrier_vec n\n  length (map (row A) [0..<n]) = n\n  carrier_vec n \\<subseteq> gso.span (set (map (row A) [0..<n]))\n\ngoal (1 subgoal):\n 1. set (map (row A) [0..<n]) \\<subseteq> carrier_vec n \\<and>\n    length (map (row A) [0..<n]) = n \\<and>\n    carrier_vec n \\<subseteq> gso.span (set (map (row A) [0..<n]))", "by auto"], ["proof (state)\nthis:\n  gso.basis_list (map (row A) [0..<n])\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "note in_dep = gso.basis_list_imp_lin_indpt_list[OF basis]"], ["proof (state)\nthis:\n  gso.lin_indpt_list (map (row A) [0..<n])\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "interpret gso: gram_schmidt_fs_lin_indpt n ?us"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_lin_indpt n (map (row A) [0..<n])", "by (standard) (use in_dep gso.lin_indpt_list_def in auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have last: \"0 \\<le> prod_list (map sq_norm ?vs) \\<and> prod_list (map sq_norm ?vs) \\<le> prod_list (map sq_norm ?us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> prod_list (map sq_norm (map gso.gso [0..<n])) \\<and>\n    prod_list (map sq_norm (map gso.gso [0..<n]))\n    \\<le> prod_list (map sq_norm (map (row A) [0..<n]))", "proof (rule prod_list_le_mono, force, unfold length_map length_upt)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n - 0 \\<Longrightarrow>\n       0 \\<le> map sq_norm (map gso.gso [0..<n]) ! i \\<and>\n       map sq_norm (map gso.gso [0..<n]) ! i\n       \\<le> map sq_norm (map (row A) [0..<n]) ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n - 0 \\<Longrightarrow>\n       0 \\<le> map sq_norm (map gso.gso [0..<n]) ! i \\<and>\n       map sq_norm (map gso.gso [0..<n]) ! i\n       \\<le> map sq_norm (map (row A) [0..<n]) ! i", "assume \"i < n - 0\""], ["proof (state)\nthis:\n  i < n - 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n - 0 \\<Longrightarrow>\n       0 \\<le> map sq_norm (map gso.gso [0..<n]) ! i \\<and>\n       map sq_norm (map gso.gso [0..<n]) ! i\n       \\<le> map sq_norm (map (row A) [0..<n]) ! i", "hence i: \"i < n\""], ["proof (prove)\nusing this:\n  i < n - 0\n\ngoal (1 subgoal):\n 1. i < n", "by simp"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n - 0 \\<Longrightarrow>\n       0 \\<le> map sq_norm (map gso.gso [0..<n]) ! i \\<and>\n       map sq_norm (map gso.gso [0..<n]) ! i\n       \\<le> map sq_norm (map (row A) [0..<n]) ! i", "have vsi: \"map sq_norm ?vs ! i = sq_norm (?vs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map sq_norm (map gso.gso [0..<n]) ! i =\n    \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. map sq_norm (map gso.gso [0..<n]) ! i =\n    \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  map sq_norm (map gso.gso [0..<n]) ! i =\n  \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n - 0 \\<Longrightarrow>\n       0 \\<le> map sq_norm (map gso.gso [0..<n]) ! i \\<and>\n       map sq_norm (map gso.gso [0..<n]) ! i\n       \\<le> map sq_norm (map (row A) [0..<n]) ! i", "have usi: \"map sq_norm ?us ! i = sq_norm (row A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map sq_norm (map (row A) [0..<n]) ! i =\n    \\<parallel>row A i\\<parallel>\\<^sup>2", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. map sq_norm (map (row A) [0..<n]) ! i =\n    \\<parallel>row A i\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  map sq_norm (map (row A) [0..<n]) ! i =\n  \\<parallel>row A i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n - 0 \\<Longrightarrow>\n       0 \\<le> map sq_norm (map gso.gso [0..<n]) ! i \\<and>\n       map sq_norm (map gso.gso [0..<n]) ! i\n       \\<le> map sq_norm (map (row A) [0..<n]) ! i", "have zero: \"0 \\<le> sq_norm (?vs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  0 \\<le> \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n - 0 \\<Longrightarrow>\n       0 \\<le> map sq_norm (map gso.gso [0..<n]) ! i \\<and>\n       map sq_norm (map gso.gso [0..<n]) ! i\n       \\<le> map sq_norm (map (row A) [0..<n]) ! i", "have le: \"sq_norm (?vs ! i) \\<le> sq_norm (row A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>row A i\\<parallel>\\<^sup>2", "using gso.sq_norm_gso_le_f i"], ["proof (prove)\nusing this:\n  ?i < length (map (row A) [0..<n]) \\<Longrightarrow>\n  \\<parallel>gso.gso ?i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>map (row A) [0..<n] ! ?i\\<parallel>\\<^sup>2\n  i < n\n\ngoal (1 subgoal):\n 1. \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>row A i\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>row A i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n - 0 \\<Longrightarrow>\n       0 \\<le> map sq_norm (map gso.gso [0..<n]) ! i \\<and>\n       map sq_norm (map gso.gso [0..<n]) ! i\n       \\<le> map sq_norm (map (row A) [0..<n]) ! i", "show \"0 \\<le> map sq_norm ?vs ! i \\<and> map sq_norm ?vs ! i \\<le> map sq_norm ?us ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> map sq_norm (map gso.gso [0..<n]) ! i \\<and>\n    map sq_norm (map gso.gso [0..<n]) ! i\n    \\<le> map sq_norm (map (row A) [0..<n]) ! i", "unfolding vsi usi"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2 \\<and>\n    \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>row A i\\<parallel>\\<^sup>2", "using zero le"], ["proof (prove)\nusing this:\n  0 \\<le> \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2\n  \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>row A i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2 \\<and>\n    \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>row A i\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  0 \\<le> map sq_norm (map gso.gso [0..<n]) ! i \\<and>\n  map sq_norm (map gso.gso [0..<n]) ! i\n  \\<le> map sq_norm (map (row A) [0..<n]) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> prod_list (map sq_norm (map gso.gso [0..<n])) \\<and>\n  prod_list (map sq_norm (map gso.gso [0..<n]))\n  \\<le> prod_list (map sq_norm (map (row A) [0..<n]))\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have Fs: \"gso.FF \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n (map (row A) [0..<n]) \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  mat_of_rows n (map (row A) [0..<n]) \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have A_Fs: \"A = gso.FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = mat_of_rows n (map (row A) [0..<n])", "by (rule eq_matI, subst gso.FF_index, insert A, auto)"], ["proof (state)\nthis:\n  A = mat_of_rows n (map (row A) [0..<n])\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "hence \"abs (det A) = abs (det (gso.FF))\""], ["proof (prove)\nusing this:\n  A = mat_of_rows n (map (row A) [0..<n])\n\ngoal (1 subgoal):\n 1. \\<bar>det A\\<bar> =\n    \\<bar>det (mat_of_rows n (map (row A) [0..<n]))\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>det A\\<bar> = \\<bar>det (mat_of_rows n (map (row A) [0..<n]))\\<bar>\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "(* the following three steps are based on a discussion with Bertram Felgenhauer *)"], ["proof (state)\nthis:\n  \\<bar>det A\\<bar> = \\<bar>det (mat_of_rows n (map (row A) [0..<n]))\\<bar>\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "also"], ["proof (state)\nthis:\n  \\<bar>det A\\<bar> = \\<bar>det (mat_of_rows n (map (row A) [0..<n]))\\<bar>\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have \"\\<dots> = abs (sqrt (det (gso.FF) * det (gso.FF)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>det (mat_of_rows n (map (row A) [0..<n]))\\<bar> =\n    \\<bar>sqrt\n           (det (mat_of_rows n (map (row A) [0..<n])) *\n            det (mat_of_rows n (map (row A) [0..<n])))\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>det (mat_of_rows n (map (row A) [0..<n]))\\<bar> =\n  \\<bar>sqrt\n         (det (mat_of_rows n (map (row A) [0..<n])) *\n          det (mat_of_rows n (map (row A) [0..<n])))\\<bar>\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "also"], ["proof (state)\nthis:\n  \\<bar>det (mat_of_rows n (map (row A) [0..<n]))\\<bar> =\n  \\<bar>sqrt\n         (det (mat_of_rows n (map (row A) [0..<n])) *\n          det (mat_of_rows n (map (row A) [0..<n])))\\<bar>\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have \"det (gso.FF) * det (gso.FF) = det (gso.FF) * det (gso.FF)\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n (map (row A) [0..<n])) *\n    det (mat_of_rows n (map (row A) [0..<n])) =\n    det (mat_of_rows n (map (row A) [0..<n])) *\n    det (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T", "unfolding det_transpose[OF Fs]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n (map (row A) [0..<n])) *\n    det (mat_of_rows n (map (row A) [0..<n])) =\n    det (mat_of_rows n (map (row A) [0..<n])) *\n    det (mat_of_rows n (map (row A) [0..<n]))", ".."], ["proof (state)\nthis:\n  det (mat_of_rows n (map (row A) [0..<n])) *\n  det (mat_of_rows n (map (row A) [0..<n])) =\n  det (mat_of_rows n (map (row A) [0..<n])) *\n  det (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "also"], ["proof (state)\nthis:\n  det (mat_of_rows n (map (row A) [0..<n])) *\n  det (mat_of_rows n (map (row A) [0..<n])) =\n  det (mat_of_rows n (map (row A) [0..<n])) *\n  det (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have \"\\<dots> = det (gso.FF * (gso.FF)\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n (map (row A) [0..<n])) *\n    det (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T =\n    det (mat_of_rows n (map (row A) [0..<n]) *\n         (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T)", "by (subst det_mult[OF Fs], insert Fs, auto)"], ["proof (state)\nthis:\n  det (mat_of_rows n (map (row A) [0..<n])) *\n  det (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T =\n  det (mat_of_rows n (map (row A) [0..<n]) *\n       (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T)\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "also"], ["proof (state)\nthis:\n  det (mat_of_rows n (map (row A) [0..<n])) *\n  det (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T =\n  det (mat_of_rows n (map (row A) [0..<n]) *\n       (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T)\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have \"\\<dots> = gso.Gramian_determinant ?us n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_of_rows n (map (row A) [0..<n]) *\n         (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T) =\n    gso.Gramian_determinant (map (row A) [0..<n]) n", "unfolding gso.Gramian_matrix_def gso.Gramian_determinant_def Let_def A_Fs[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (A * A\\<^sup>T) =\n    det (mat n n (\\<lambda>(i, y). map (row A) [0..<n] ! i $ y) *\n         (mat n n (\\<lambda>(i, y). map (row A) [0..<n] ! i $ y))\\<^sup>T)", "by (rule arg_cong[of _ _ det], rule arg_cong2[of _ _ _ _ \"(*)\"], insert A, auto)"], ["proof (state)\nthis:\n  det (mat_of_rows n (map (row A) [0..<n]) *\n       (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T) =\n  gso.Gramian_determinant (map (row A) [0..<n]) n\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "also"], ["proof (state)\nthis:\n  det (mat_of_rows n (map (row A) [0..<n]) *\n       (mat_of_rows n (map (row A) [0..<n]))\\<^sup>T) =\n  gso.Gramian_determinant (map (row A) [0..<n]) n\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have \"\\<dots> = (\\<Prod>j \\<in> set [0 ..< n]. \\<parallel>?vs ! j\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso.Gramian_determinant (map (row A) [0..<n]) n =\n    (\\<Prod>j\\<in>set [0..<n].\n       \\<parallel>map gso.gso [0..<n] ! j\\<parallel>\\<^sup>2)", "by (subst gso.Gramian_determinant) (auto intro!: prod.cong)"], ["proof (state)\nthis:\n  gso.Gramian_determinant (map (row A) [0..<n]) n =\n  (\\<Prod>j\\<in>set [0..<n].\n     \\<parallel>map gso.gso [0..<n] ! j\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "also"], ["proof (state)\nthis:\n  gso.Gramian_determinant (map (row A) [0..<n]) n =\n  (\\<Prod>j\\<in>set [0..<n].\n     \\<parallel>map gso.gso [0..<n] ! j\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have \"\\<dots> = prod_list (map (\\<lambda> i. sq_norm (?vs ! i)) [0 ..< n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j\\<in>set [0..<n].\n       \\<parallel>map gso.gso [0..<n] ! j\\<parallel>\\<^sup>2) =\n    (\\<Prod>i\\<leftarrow>[0..<\n                          n]. \\<parallel>map gso.gso [0..<n] !\n   i\\<parallel>\\<^sup>2)", "by (subst prod.distinct_set_conv_list, auto)"], ["proof (state)\nthis:\n  (\\<Prod>j\\<in>set [0..<n].\n     \\<parallel>map gso.gso [0..<n] ! j\\<parallel>\\<^sup>2) =\n  (\\<Prod>i\\<leftarrow>[0..<\n                        n]. \\<parallel>map gso.gso [0..<n] !\n i\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "also"], ["proof (state)\nthis:\n  (\\<Prod>j\\<in>set [0..<n].\n     \\<parallel>map gso.gso [0..<n] ! j\\<parallel>\\<^sup>2) =\n  (\\<Prod>i\\<leftarrow>[0..<\n                        n]. \\<parallel>map gso.gso [0..<n] !\n i\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have \"map (\\<lambda> i. sq_norm (?vs ! i)) [0 ..< n] = map sq_norm ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2)\n     [0..<n] =\n    map sq_norm (map gso.gso [0..<n])", "by (intro nth_equalityI, auto)"], ["proof (state)\nthis:\n  map (\\<lambda>i. \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2)\n   [0..<n] =\n  map sq_norm (map gso.gso [0..<n])\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "also"], ["proof (state)\nthis:\n  map (\\<lambda>i. \\<parallel>map gso.gso [0..<n] ! i\\<parallel>\\<^sup>2)\n   [0..<n] =\n  map sq_norm (map gso.gso [0..<n])\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have \"abs (sqrt (prod_list \\<dots>)) \\<le> sqrt (prod_list (map sq_norm ?us))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>sqrt (prod_list (map sq_norm (map gso.gso [0..<n])))\\<bar>\n    \\<le> sqrt (prod_list (map sq_norm (map (row A) [0..<n])))", "using last"], ["proof (prove)\nusing this:\n  0 \\<le> prod_list (map sq_norm (map gso.gso [0..<n])) \\<and>\n  prod_list (map sq_norm (map gso.gso [0..<n]))\n  \\<le> prod_list (map sq_norm (map (row A) [0..<n]))\n\ngoal (1 subgoal):\n 1. \\<bar>sqrt (prod_list (map sq_norm (map gso.gso [0..<n])))\\<bar>\n    \\<le> sqrt (prod_list (map sq_norm (map (row A) [0..<n])))", "by simp"], ["proof (state)\nthis:\n  \\<bar>sqrt (prod_list (map sq_norm (map gso.gso [0..<n])))\\<bar>\n  \\<le> sqrt (prod_list (map sq_norm (map (row A) [0..<n])))\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "also"], ["proof (state)\nthis:\n  \\<bar>sqrt (prod_list (map sq_norm (map gso.gso [0..<n])))\\<bar>\n  \\<le> sqrt (prod_list (map sq_norm (map (row A) [0..<n])))\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have \"?us = rows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (row A) [0..<n] = rows A", "unfolding rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (row A) [0..<n] = map (row A) [0..<dim_row A]", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. map (row A) [0..<n] = map (row A) [0..<dim_row A]", "by simp"], ["proof (state)\nthis:\n  map (row A) [0..<n] = rows A\n\ngoal (2 subgoals):\n 1. carrier_vec n\n    \\<subseteq> gso.span (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n 2. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "finally"], ["proof (chain)\npicking this:\n  \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n\ngoal (1 subgoal):\n 1. \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "."], ["proof (state)\nthis:\n  \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n\ngoal (1 subgoal):\n 1. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "case False"], ["proof (state)\nthis:\n  \\<not> carrier_vec n \\<subseteq> gso.span (set (map (row A) [0..<n]))\n\ngoal (1 subgoal):\n 1. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "from mat_of_rows_rows[unfolded rows_def,of A] A gram_schmidt.non_span_det_zero[OF len False us]"], ["proof (chain)\npicking this:\n  mat_of_rows (dim_col A) (map (row A) [0..<dim_row A]) = A\n  A \\<in> carrier_mat n n\n  det (mat_of_rows n (map (row A) [0..<n])) = 0", "have zero: \"det A = 0\""], ["proof (prove)\nusing this:\n  mat_of_rows (dim_col A) (map (row A) [0..<dim_row A]) = A\n  A \\<in> carrier_mat n n\n  det (mat_of_rows n (map (row A) [0..<n])) = 0\n\ngoal (1 subgoal):\n 1. det A = 0", "by auto"], ["proof (state)\nthis:\n  det A = 0\n\ngoal (1 subgoal):\n 1. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "have ge: \"prod_list (map sq_norm (rows A)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> prod_list (map sq_norm (rows A))", "by (rule prod_list_nonneg, auto simp: sq_norm_vec_ge_0)"], ["proof (state)\nthis:\n  0 \\<le> prod_list (map sq_norm (rows A))\n\ngoal (1 subgoal):\n 1. \\<not> carrier_vec n\n           \\<subseteq> gso.span\n                        (set (map (row A) [0..<n])) \\<Longrightarrow>\n    \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "unfolding zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>0\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "using ge"], ["proof (prove)\nusing this:\n  0 \\<le> prod_list (map sq_norm (rows A))\n\ngoal (1 subgoal):\n 1. \\<bar>0\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))", "by simp"], ["proof (state)\nthis:\n  \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>det A\\<bar> \\<le> sqrt (prod_list (map sq_norm (rows A)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"gram_schmidt_wit = gram_schmidt.main\""], ["", "declare gram_schmidt.adjuster_wit.simps[code]"], ["", "declare gram_schmidt.sub2_wit.simps[code]"], ["", "declare gram_schmidt.main_def[code]"], ["", "definition gram_schmidt_int :: \"nat \\<Rightarrow> int vec list \\<Rightarrow> rat list list \\<times> rat vec list\" where\n  \"gram_schmidt_int n us = gram_schmidt_wit n (map (map_vec of_int) us)\""], ["", "lemma snd_gram_schmidt_int : \"snd (gram_schmidt_int n us) = gram_schmidt n (map (map_vec of_int) us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (gram_schmidt_int n us) = gram_schmidt n (map of_int_hom.vec_hom us)", "unfolding gram_schmidt_int_def gram_schmidt_wit_def gram_schmidt_fs.gso_connect"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt n (map of_int_hom.vec_hom us) =\n    gram_schmidt n (map of_int_hom.vec_hom us)", "by metis"], ["", "text \\<open>Faster implementation for rational vectors which also avoid recomputations\n  of square-norms\\<close>"], ["", "fun adjuster_triv :: \"nat \\<Rightarrow> rat vec \\<Rightarrow> (rat vec \\<times> rat) list \\<Rightarrow> rat vec\"\n  where \"adjuster_triv n w [] = 0\\<^sub>v n\"\n    |  \"adjuster_triv n w ((u,nu)#us) = -(w \\<bullet> u)/ nu \\<cdot>\\<^sub>v u + adjuster_triv n w us\""], ["", "fun gram_schmidt_sub_triv\n  where \"gram_schmidt_sub_triv n us [] = us\"\n  | \"gram_schmidt_sub_triv n us (w # ws) = (let u = adjuster_triv n w us + w in\n     gram_schmidt_sub_triv n ((u, sq_norm_vec_rat u) # us) ws)\""], ["", "definition gram_schmidt_triv :: \"nat \\<Rightarrow> rat vec list \\<Rightarrow> (rat vec \\<times> rat) list\"\n  where \"gram_schmidt_triv n ws = rev (gram_schmidt_sub_triv n [] ws)\""], ["", "lemma adjuster_triv: \"adjuster_triv n w (map (\\<lambda> x. (x,sq_norm x)) us) = adjuster n w us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjuster_triv n w\n     (map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) us) =\n    adjuster n w us", "by (induct us, auto simp: sq_norm_vec_as_cscalar_prod)"], ["", "lemma gram_schmidt_sub_triv: \"gram_schmidt_sub_triv n ((map (\\<lambda> x. (x,sq_norm x)) us)) ws = \n  map (\\<lambda> x. (x, sq_norm x)) (gram_schmidt_sub n us ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_sub_triv n\n     (map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) us) ws =\n    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n     (gram_schmidt_sub n us ws)", "by (rule sym, induct ws arbitrary: us, auto simp: adjuster_triv o_def Let_def)"], ["", "lemma gram_schmidt_triv[simp]: \"gram_schmidt_triv n ws = map (\\<lambda> x. (x,sq_norm x)) (gram_schmidt n ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_triv n ws =\n    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n     (gram_schmidt n ws)", "unfolding gram_schmidt_def gram_schmidt_triv_def rev_map[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (gram_schmidt_sub_triv n [] ws) =\n    rev (map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n          (gram_schmidt_sub n [] ws))", "by (auto simp: gram_schmidt_sub_triv[symmetric])"], ["", "context gram_schmidt\nbegin"], ["", "fun mus_adjuster :: \"'a vec \\<Rightarrow> ('a vec \\<times> 'a) list \\<Rightarrow> 'a list \\<Rightarrow> 'a vec \\<Rightarrow> 'a list \\<times> 'a vec\"\n  where\n  \"mus_adjuster f []           mus g' = (mus, g')\" |\n  \"mus_adjuster f ((g, ng)#n_gs) mus g' = (let a = (f \\<bullet> g) / ng in\n                                             mus_adjuster f n_gs (a # mus) (-a \\<cdot>\\<^sub>v g + g'))\""], ["", "fun norms_mus' where\n  \"norms_mus' []       n_gs mus = (map snd n_gs, mus)\" |\n  \"norms_mus' (f # fs) n_gs mus =\n    (let (mus_row, g') = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                     g = g' + f in\n      norms_mus' fs ((g, sq_norm_vec g) # n_gs) (mus_row#mus))\""], ["", "lemma adjuster_wit_carrier_vec:\n  assumes \"f \\<in> carrier_vec n\" \"set gs \\<subseteq> carrier_vec n\"\n  shows \"snd (adjuster_wit mus f gs) \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (adjuster_wit mus f gs) \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. snd (adjuster_wit mus f gs) \\<in> carrier_vec n", "by (induction mus f gs rule: adjuster_wit.induct) (auto simp add: Let_def case_prod_beta')"], ["", "lemma adjuster_wit'':\n  assumes \"adjuster_wit mus_acc f gs = (mus, g')\" \"n_gs = map (\\<lambda>x. (x, sq_norm_vec x)) gs\"\n \"f \\<in> carrier_vec n\" \"acc \\<in> carrier_vec n\" \"set gs \\<subseteq> carrier_vec n\"\n  shows \"mus_adjuster f n_gs mus_acc acc = (mus, acc + g')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs mus_acc acc = (mus, acc + g')", "using assms"], ["proof (prove)\nusing this:\n  adjuster_wit mus_acc f gs = (mus, g')\n  n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  f \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs mus_acc acc = (mus, acc + g')", "proof(induction f n_gs mus_acc acc arbitrary: g' gs mus rule: mus_adjuster.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f mus g' g'a gs musa.\n       \\<lbrakk>adjuster_wit mus f gs = (musa, g'a);\n        [] = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f [] mus g' = (musa, g' + g'a)\n 2. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "case (1 mus' f acc g)"], ["proof (state)\nthis:\n  adjuster_wit f mus' gs = (mus, g)\n  [] = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  mus' \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>f mus g' g'a gs musa.\n       \\<lbrakk>adjuster_wit mus f gs = (musa, g'a);\n        [] = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f [] mus g' = (musa, g' + g'a)\n 2. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "then"], ["proof (chain)\npicking this:\n  adjuster_wit f mus' gs = (mus, g)\n  [] = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  mus' \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n", "show ?case"], ["proof (prove)\nusing this:\n  adjuster_wit f mus' gs = (mus, g)\n  [] = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  mus' \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. mus_adjuster mus' [] f acc = (mus, acc + g)", "by auto"], ["proof (state)\nthis:\n  mus_adjuster mus' [] f acc = (mus, acc + g)\n\ngoal (1 subgoal):\n 1. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "case (2 f g n_g n_gs mus_acc acc g' gs mus)"], ["proof (state)\nthis:\n  \\<lbrakk>?x3 = f \\<bullet> g / n_g;\n   adjuster_wit (?x3 # mus_acc) f ?gs3 = (?mus3, ?g'3);\n   n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs3;\n   f \\<in> carrier_vec n; - ?x3 \\<cdot>\\<^sub>v g + acc \\<in> carrier_vec n;\n   set ?gs3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> mus_adjuster f n_gs (?x3 # mus_acc)\n                     (- ?x3 \\<cdot>\\<^sub>v g + acc) =\n                    (?mus3, - ?x3 \\<cdot>\\<^sub>v g + acc + ?g'3)\n  adjuster_wit mus_acc f gs = (mus, g')\n  (g, n_g) # n_gs =\n  map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  f \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "let ?gg = \"snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x3 = f \\<bullet> g / n_g;\n   adjuster_wit (?x3 # mus_acc) f ?gs3 = (?mus3, ?g'3);\n   n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs3;\n   f \\<in> carrier_vec n; - ?x3 \\<cdot>\\<^sub>v g + acc \\<in> carrier_vec n;\n   set ?gs3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> mus_adjuster f n_gs (?x3 # mus_acc)\n                     (- ?x3 \\<cdot>\\<^sub>v g + acc) =\n                    (?mus3, - ?x3 \\<cdot>\\<^sub>v g + acc + ?g'3)\n  adjuster_wit mus_acc f gs = (mus, g')\n  (g, n_g) # n_gs =\n  map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  f \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n", "have l: \"gs = g # tl gs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 = f \\<bullet> g / n_g;\n   adjuster_wit (?x3 # mus_acc) f ?gs3 = (?mus3, ?g'3);\n   n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs3;\n   f \\<in> carrier_vec n; - ?x3 \\<cdot>\\<^sub>v g + acc \\<in> carrier_vec n;\n   set ?gs3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> mus_adjuster f n_gs (?x3 # mus_acc)\n                     (- ?x3 \\<cdot>\\<^sub>v g + acc) =\n                    (?mus3, - ?x3 \\<cdot>\\<^sub>v g + acc + ?g'3)\n  adjuster_wit mus_acc f gs = (mus, g')\n  (g, n_g) # n_gs =\n  map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  f \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. gs = g # tl gs", "by auto"], ["proof (state)\nthis:\n  gs = g # tl gs\n\ngoal (1 subgoal):\n 1. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "have gg: \"?gg \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs))\n    \\<in> carrier_vec n", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 = f \\<bullet> g / n_g;\n   adjuster_wit (?x3 # mus_acc) f ?gs3 = (?mus3, ?g'3);\n   n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs3;\n   f \\<in> carrier_vec n; - ?x3 \\<cdot>\\<^sub>v g + acc \\<in> carrier_vec n;\n   set ?gs3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> mus_adjuster f n_gs (?x3 # mus_acc)\n                     (- ?x3 \\<cdot>\\<^sub>v g + acc) =\n                    (?mus3, - ?x3 \\<cdot>\\<^sub>v g + acc + ?g'3)\n  adjuster_wit mus_acc f gs = (mus, g')\n  (g, n_g) # n_gs =\n  map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  f \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs))\n    \\<in> carrier_vec n", "by (auto intro!: adjuster_wit_carrier_vec)"], ["proof (state)\nthis:\n  snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs))\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "then"], ["proof (chain)\npicking this:\n  snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs))\n  \\<in> carrier_vec n", "have [simp]: \"g' = (- (f \\<bullet> g / \\<parallel>g\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v g + ?gg)\""], ["proof (prove)\nusing this:\n  snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs))\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. g' =\n    - (f \\<bullet> g / \\<parallel>g\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v g +\n    snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs))", "using 2"], ["proof (prove)\nusing this:\n  snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs))\n  \\<in> carrier_vec n\n  \\<lbrakk>?x3 = f \\<bullet> g / n_g;\n   adjuster_wit (?x3 # mus_acc) f ?gs3 = (?mus3, ?g'3);\n   n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs3;\n   f \\<in> carrier_vec n; - ?x3 \\<cdot>\\<^sub>v g + acc \\<in> carrier_vec n;\n   set ?gs3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> mus_adjuster f n_gs (?x3 # mus_acc)\n                     (- ?x3 \\<cdot>\\<^sub>v g + acc) =\n                    (?mus3, - ?x3 \\<cdot>\\<^sub>v g + acc + ?g'3)\n  adjuster_wit mus_acc f gs = (mus, g')\n  (g, n_g) # n_gs =\n  map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  f \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. g' =\n    - (f \\<bullet> g / \\<parallel>g\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v g +\n    snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs))", "by (auto simp add: Let_def case_prod_beta')"], ["proof (state)\nthis:\n  g' =\n  - (f \\<bullet> g / \\<parallel>g\\<parallel>\\<^sup>2) \\<cdot>\\<^sub>v g +\n  snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs))\n\ngoal (1 subgoal):\n 1. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "have \"mus_adjuster f ((g, n_g) # n_gs) mus_acc acc =\n        mus_adjuster f n_gs (f \\<bullet> g / n_g # mus_acc) (- (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mus_adjuster f ((g, n_g) # n_gs) mus_acc acc =\n    mus_adjuster f n_gs (f \\<bullet> g / n_g # mus_acc)\n     (- (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc)", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  mus_adjuster f ((g, n_g) # n_gs) mus_acc acc =\n  mus_adjuster f n_gs (f \\<bullet> g / n_g # mus_acc)\n   (- (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc)\n\ngoal (1 subgoal):\n 1. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "also"], ["proof (state)\nthis:\n  mus_adjuster f ((g, n_g) # n_gs) mus_acc acc =\n  mus_adjuster f n_gs (f \\<bullet> g / n_g # mus_acc)\n   (- (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc)\n\ngoal (1 subgoal):\n 1. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "have \"\\<dots> = (mus, - (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc + ?gg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs (f \\<bullet> g / n_g # mus_acc)\n     (- (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc) =\n    (mus,\n     - (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc +\n     snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs (f \\<bullet> g / n_g # mus_acc)\n     (- (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc) =\n    (mus,\n     - (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc +\n     snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))", "have \"adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs) = (mus, ?gg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs) =\n    (mus, snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 = f \\<bullet> g / n_g;\n   adjuster_wit (?x3 # mus_acc) f ?gs3 = (?mus3, ?g'3);\n   n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs3;\n   f \\<in> carrier_vec n; - ?x3 \\<cdot>\\<^sub>v g + acc \\<in> carrier_vec n;\n   set ?gs3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> mus_adjuster f n_gs (?x3 # mus_acc)\n                     (- ?x3 \\<cdot>\\<^sub>v g + acc) =\n                    (?mus3, - ?x3 \\<cdot>\\<^sub>v g + acc + ?g'3)\n  adjuster_wit mus_acc f gs = (mus, g')\n  (g, n_g) # n_gs =\n  map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  f \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs) =\n    (mus, snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))", "by (subst (asm) l) (auto simp add: Let_def case_prod_beta')"], ["proof (state)\nthis:\n  adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs) =\n  (mus, snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))\n\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs (f \\<bullet> g / n_g # mus_acc)\n     (- (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc) =\n    (mus,\n     - (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc +\n     snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))", "then"], ["proof (chain)\npicking this:\n  adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs) =\n  (mus, snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs) =\n  (mus, snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))\n\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs (f \\<bullet> g / n_g # mus_acc)\n     (- (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc) =\n    (mus,\n     - (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc +\n     snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))", "using 2"], ["proof (prove)\nusing this:\n  adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs) =\n  (mus, snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))\n  \\<lbrakk>?x3 = f \\<bullet> g / n_g;\n   adjuster_wit (?x3 # mus_acc) f ?gs3 = (?mus3, ?g'3);\n   n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs3;\n   f \\<in> carrier_vec n; - ?x3 \\<cdot>\\<^sub>v g + acc \\<in> carrier_vec n;\n   set ?gs3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> mus_adjuster f n_gs (?x3 # mus_acc)\n                     (- ?x3 \\<cdot>\\<^sub>v g + acc) =\n                    (?mus3, - ?x3 \\<cdot>\\<^sub>v g + acc + ?g'3)\n  adjuster_wit mus_acc f gs = (mus, g')\n  (g, n_g) # n_gs =\n  map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  f \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs (f \\<bullet> g / n_g # mus_acc)\n     (- (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc) =\n    (mus,\n     - (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc +\n     snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))", "by (subst 2(1)[of _ \"tl gs\"]) (auto simp add: Let_def case_prod_beta')"], ["proof (state)\nthis:\n  mus_adjuster f n_gs (f \\<bullet> g / n_g # mus_acc)\n   (- (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc) =\n  (mus,\n   - (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc +\n   snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mus_adjuster f n_gs (f \\<bullet> g / n_g # mus_acc)\n   (- (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc) =\n  (mus,\n   - (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc +\n   snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))\n\ngoal (1 subgoal):\n 1. \\<And>f g ng n_gs mus g' g'a gs musa.\n       \\<lbrakk>\\<And>x g'a gs musa.\n                   \\<lbrakk>x = f \\<bullet> g / ng;\n                    adjuster_wit (x # mus) f gs = (musa, g'a);\n                    n_gs =\n                    map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2))\n                     gs;\n                    f \\<in> carrier_vec n;\n                    - x \\<cdot>\\<^sub>v g + g' \\<in> carrier_vec n;\n                    set gs \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> mus_adjuster f n_gs (x # mus)\n(- x \\<cdot>\\<^sub>v g + g') =\n                                     (musa,\n- x \\<cdot>\\<^sub>v g + g' + g'a);\n        adjuster_wit mus f gs = (musa, g'a);\n        (g, ng) # n_gs =\n        map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs;\n        f \\<in> carrier_vec n; g' \\<in> carrier_vec n;\n        set gs \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> mus_adjuster f ((g, ng) # n_gs) mus g' =\n                         (musa, g' + g'a)", "finally"], ["proof (chain)\npicking this:\n  mus_adjuster f ((g, n_g) # n_gs) mus_acc acc =\n  (mus,\n   - (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc +\n   snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))", "show ?case"], ["proof (prove)\nusing this:\n  mus_adjuster f ((g, n_g) # n_gs) mus_acc acc =\n  (mus,\n   - (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc +\n   snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))\n\ngoal (1 subgoal):\n 1. mus_adjuster f ((g, n_g) # n_gs) mus_acc acc = (mus, acc + g')", "using 2 gg"], ["proof (prove)\nusing this:\n  mus_adjuster f ((g, n_g) # n_gs) mus_acc acc =\n  (mus,\n   - (f \\<bullet> g / n_g) \\<cdot>\\<^sub>v g + acc +\n   snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs)))\n  \\<lbrakk>?x3 = f \\<bullet> g / n_g;\n   adjuster_wit (?x3 # mus_acc) f ?gs3 = (?mus3, ?g'3);\n   n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs3;\n   f \\<in> carrier_vec n; - ?x3 \\<cdot>\\<^sub>v g + acc \\<in> carrier_vec n;\n   set ?gs3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> mus_adjuster f n_gs (?x3 # mus_acc)\n                     (- ?x3 \\<cdot>\\<^sub>v g + acc) =\n                    (?mus3, - ?x3 \\<cdot>\\<^sub>v g + acc + ?g'3)\n  adjuster_wit mus_acc f gs = (mus, g')\n  (g, n_g) # n_gs =\n  map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  f \\<in> carrier_vec n\n  acc \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n  snd (adjuster_wit (f \\<bullet> g / n_g # mus_acc) f (tl gs))\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. mus_adjuster f ((g, n_g) # n_gs) mus_acc acc = (mus, acc + g')", "by auto"], ["proof (state)\nthis:\n  mus_adjuster f ((g, n_g) # n_gs) mus_acc acc = (mus, acc + g')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjuster_wit':\n  assumes \"n_gs = map (\\<lambda>x. (x, sq_norm_vec x)) gs\" \"f \\<in> carrier_vec n\" \"set gs \\<subseteq> carrier_vec n\"\n  shows \"mus_adjuster f n_gs mus_acc (0\\<^sub>v n) = adjuster_wit mus_acc f gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs mus_acc (0\\<^sub>v n) = adjuster_wit mus_acc f gs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs mus_acc (0\\<^sub>v n) = adjuster_wit mus_acc f gs", "let ?g = \"snd (adjuster_wit mus_acc f gs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs mus_acc (0\\<^sub>v n) = adjuster_wit mus_acc f gs", "let ?mus = \"fst (adjuster_wit mus_acc f gs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs mus_acc (0\\<^sub>v n) = adjuster_wit mus_acc f gs", "have \"?g \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (adjuster_wit mus_acc f gs) \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  f \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. snd (adjuster_wit mus_acc f gs) \\<in> carrier_vec n", "by (auto intro!: adjuster_wit_carrier_vec)"], ["proof (state)\nthis:\n  snd (adjuster_wit mus_acc f gs) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs mus_acc (0\\<^sub>v n) = adjuster_wit mus_acc f gs", "then"], ["proof (chain)\npicking this:\n  snd (adjuster_wit mus_acc f gs) \\<in> carrier_vec n", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (adjuster_wit mus_acc f gs) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs mus_acc (0\\<^sub>v n) = adjuster_wit mus_acc f gs", "using assms"], ["proof (prove)\nusing this:\n  snd (adjuster_wit mus_acc f gs) \\<in> carrier_vec n\n  n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs\n  f \\<in> carrier_vec n\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs mus_acc (0\\<^sub>v n) = adjuster_wit mus_acc f gs", "by (subst adjuster_wit''[of _ _ gs ?mus ?g]) (auto simp add: case_prod_beta')"], ["proof (state)\nthis:\n  mus_adjuster f n_gs mus_acc (0\\<^sub>v n) = adjuster_wit mus_acc f gs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sub2_wit_norms_mus':\n  assumes \"n_gs' = map (\\<lambda>v. (v, sq_norm_vec v)) gs'\"\n   \"sub2_wit gs' fs = (mus, gs)\" \"set fs \\<subseteq> carrier_vec n\" \"set gs' \\<subseteq> carrier_vec n\"\n shows \"norms_mus' fs n_gs' mus_acc = (map sq_norm_vec (rev gs @ gs'), rev mus @ mus_acc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norms_mus' fs n_gs' mus_acc =\n    (map sq_norm (rev gs @ gs'), rev mus @ mus_acc)", "using assms"], ["proof (prove)\nusing this:\n  n_gs' = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' fs = (mus, gs)\n  set fs \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. norms_mus' fs n_gs' mus_acc =\n    (map sq_norm (rev gs @ gs'), rev mus @ mus_acc)", "proof (induction fs n_gs' mus_acc arbitrary: gs' mus gs rule: norms_mus'.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n_gs mus gs' musa gs.\n       \\<lbrakk>n_gs =\n                map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' [] = (musa, gs); set [] \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' [] n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)\n 2. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "case (1 n_gs mus_acc)"], ["proof (state)\nthis:\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' [] = (mus, gs)\n  set [] \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<And>n_gs mus gs' musa gs.\n       \\<lbrakk>n_gs =\n                map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' [] = (musa, gs); set [] \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' [] n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)\n 2. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "then"], ["proof (chain)\npicking this:\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' [] = (mus, gs)\n  set [] \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n", "show ?case"], ["proof (prove)\nusing this:\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' [] = (mus, gs)\n  set [] \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. norms_mus' [] n_gs mus_acc =\n    (map sq_norm (rev gs @ gs'), rev mus @ mus_acc)", "by (auto simp add: rev_map)"], ["proof (state)\nthis:\n  norms_mus' [] n_gs mus_acc =\n  (map sq_norm (rev gs @ gs'), rev mus @ mus_acc)\n\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "case (2  f fs n_gs mus_acc)"], ["proof (state)\nthis:\n  \\<lbrakk>?x3 = mus_adjuster f n_gs [] (0\\<^sub>v n); (?xa3, ?y3) = ?x3;\n   ?xb3 = ?y3 + f;\n   (?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs =\n   map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) ?gs'3;\n   sub2_wit ?gs'3 fs = (?mus3, ?gs3); set fs \\<subseteq> carrier_vec n;\n   set ?gs'3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> norms_mus' fs\n                     ((?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs)\n                     (?xa3 # mus_acc) =\n                    (map sq_norm (rev ?gs3 @ ?gs'3),\n                     rev ?mus3 @ ?xa3 # mus_acc)\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' (f # fs) = (mus, gs)\n  set (f # fs) \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "note aw1 = conjunct1[OF conjunct2[OF gram_schmidt_fs.adjuster_wit]]"], ["proof (state)\nthis:\n  \\<lbrakk>gram_schmidt.adjuster_wit ?n2 ?wits2 ?w2 ?us2 = (?wits'2, ?a2);\n   ?w2 \\<in> carrier_vec ?n2;\n   \\<And>i. i \\<le> ?j2 \\<Longrightarrow> ?fs2 ! i \\<in> carrier_vec ?n2;\n   ?us2 = map (gram_schmidt_fs.gso ?n2 ?fs2) (rev [0..<?j2]);\n   ?wits2 = map (gram_schmidt_fs.\\<mu> ?n2 ?fs2 ?i2) [?j2..<?i2];\n   ?j2 \\<le> ?n2; ?j2 \\<le> ?i2; ?w2 = ?fs2 ! ?i2\\<rbrakk>\n  \\<Longrightarrow> ?a2 \\<in> carrier_vec ?n2\n\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "let ?aw = \"mus_adjuster f n_gs [] (0\\<^sub>v n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "have aw: \"?aw = adjuster_wit [] f gs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mus_adjuster f n_gs [] (0\\<^sub>v n) = adjuster_wit [] f gs'", "apply(subst adjuster_wit')"], ["proof (prove)\ngoal (4 subgoals):\n 1. n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs\n 2. f \\<in> carrier_vec n\n 3. set ?gs \\<subseteq> carrier_vec n\n 4. adjuster_wit [] f ?gs = adjuster_wit [] f gs'", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 = mus_adjuster f n_gs [] (0\\<^sub>v n); (?xa3, ?y3) = ?x3;\n   ?xb3 = ?y3 + f;\n   (?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs =\n   map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) ?gs'3;\n   sub2_wit ?gs'3 fs = (?mus3, ?gs3); set fs \\<subseteq> carrier_vec n;\n   set ?gs'3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> norms_mus' fs\n                     ((?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs)\n                     (?xa3 # mus_acc) =\n                    (map sq_norm (rev ?gs3 @ ?gs'3),\n                     rev ?mus3 @ ?xa3 # mus_acc)\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' (f # fs) = (mus, gs)\n  set (f # fs) \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n\ngoal (4 subgoals):\n 1. n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs\n 2. f \\<in> carrier_vec n\n 3. set ?gs \\<subseteq> carrier_vec n\n 4. adjuster_wit [] f ?gs = adjuster_wit [] f gs'", "by auto"], ["proof (state)\nthis:\n  mus_adjuster f n_gs [] (0\\<^sub>v n) = adjuster_wit [] f gs'\n\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "have \"sub2_wit ((snd ?aw + f) # gs') fs = sub2_wit ((snd (adjuster_wit [] f gs') + f) # gs') fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n    sub2_wit ((snd (adjuster_wit [] f gs') + f) # gs') fs", "apply(subst adjuster_wit')"], ["proof (prove)\ngoal (4 subgoals):\n 1. n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs\n 2. f \\<in> carrier_vec n\n 3. set ?gs \\<subseteq> carrier_vec n\n 4. sub2_wit ((snd (adjuster_wit [] f ?gs) + f) # gs') fs =\n    sub2_wit ((snd (adjuster_wit [] f gs') + f) # gs') fs", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 = mus_adjuster f n_gs [] (0\\<^sub>v n); (?xa3, ?y3) = ?x3;\n   ?xb3 = ?y3 + f;\n   (?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs =\n   map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) ?gs'3;\n   sub2_wit ?gs'3 fs = (?mus3, ?gs3); set fs \\<subseteq> carrier_vec n;\n   set ?gs'3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> norms_mus' fs\n                     ((?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs)\n                     (?xa3 # mus_acc) =\n                    (map sq_norm (rev ?gs3 @ ?gs'3),\n                     rev ?mus3 @ ?xa3 # mus_acc)\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' (f # fs) = (mus, gs)\n  set (f # fs) \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n\ngoal (4 subgoals):\n 1. n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) ?gs\n 2. f \\<in> carrier_vec n\n 3. set ?gs \\<subseteq> carrier_vec n\n 4. sub2_wit ((snd (adjuster_wit [] f ?gs) + f) # gs') fs =\n    sub2_wit ((snd (adjuster_wit [] f gs') + f) # gs') fs", "by auto"], ["proof (state)\nthis:\n  sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n  sub2_wit ((snd (adjuster_wit [] f gs') + f) # gs') fs\n\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "also"], ["proof (state)\nthis:\n  sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n  sub2_wit ((snd (adjuster_wit [] f gs') + f) # gs') fs\n\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "have \"\\<dots> = (tl mus, tl gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub2_wit ((snd (adjuster_wit [] f gs') + f) # gs') fs = (tl mus, tl gs)", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 = mus_adjuster f n_gs [] (0\\<^sub>v n); (?xa3, ?y3) = ?x3;\n   ?xb3 = ?y3 + f;\n   (?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs =\n   map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) ?gs'3;\n   sub2_wit ?gs'3 fs = (?mus3, ?gs3); set fs \\<subseteq> carrier_vec n;\n   set ?gs'3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> norms_mus' fs\n                     ((?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs)\n                     (?xa3 # mus_acc) =\n                    (map sq_norm (rev ?gs3 @ ?gs'3),\n                     rev ?mus3 @ ?xa3 # mus_acc)\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' (f # fs) = (mus, gs)\n  set (f # fs) \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. sub2_wit ((snd (adjuster_wit [] f gs') + f) # gs') fs = (tl mus, tl gs)", "by (auto simp add: Let_def case_prod_beta')"], ["proof (state)\nthis:\n  sub2_wit ((snd (adjuster_wit [] f gs') + f) # gs') fs = (tl mus, tl gs)\n\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "finally"], ["proof (chain)\npicking this:\n  sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n  (tl mus, tl gs)", "have sub_tl: \"sub2_wit ((snd ?aw + f) # gs') fs = (tl mus, tl gs)\""], ["proof (prove)\nusing this:\n  sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n  (tl mus, tl gs)\n\ngoal (1 subgoal):\n 1. sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n    (tl mus, tl gs)", "by simp"], ["proof (state)\nthis:\n  sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n  (tl mus, tl gs)\n\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "have aw_c: \"snd ?aw \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) \\<in> carrier_vec n", "apply(subst adjuster_wit'[of _ gs'])"], ["proof (prove)\ngoal (4 subgoals):\n 1. n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs'\n 2. f \\<in> carrier_vec n\n 3. set gs' \\<subseteq> carrier_vec n\n 4. snd (adjuster_wit [] f gs') \\<in> carrier_vec n", "using 2 adjuster_wit_carrier_vec"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 = mus_adjuster f n_gs [] (0\\<^sub>v n); (?xa3, ?y3) = ?x3;\n   ?xb3 = ?y3 + f;\n   (?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs =\n   map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) ?gs'3;\n   sub2_wit ?gs'3 fs = (?mus3, ?gs3); set fs \\<subseteq> carrier_vec n;\n   set ?gs'3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> norms_mus' fs\n                     ((?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs)\n                     (?xa3 # mus_acc) =\n                    (map sq_norm (rev ?gs3 @ ?gs'3),\n                     rev ?mus3 @ ?xa3 # mus_acc)\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' (f # fs) = (mus, gs)\n  set (f # fs) \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n  \\<lbrakk>?f \\<in> carrier_vec n;\n   set ?gs \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> snd (adjuster_wit ?mus ?f ?gs) \\<in> carrier_vec n\n\ngoal (4 subgoals):\n 1. n_gs = map (\\<lambda>x. (x, \\<parallel>x\\<parallel>\\<^sup>2)) gs'\n 2. f \\<in> carrier_vec n\n 3. set gs' \\<subseteq> carrier_vec n\n 4. snd (adjuster_wit [] f gs') \\<in> carrier_vec n", "by (auto)"], ["proof (state)\nthis:\n  snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "have gs: \"gs = (snd ?aw + f) # tl gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs = (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # tl gs", "apply(subst aw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs = (snd (adjuster_wit [] f gs') + f) # tl gs", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 = mus_adjuster f n_gs [] (0\\<^sub>v n); (?xa3, ?y3) = ?x3;\n   ?xb3 = ?y3 + f;\n   (?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs =\n   map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) ?gs'3;\n   sub2_wit ?gs'3 fs = (?mus3, ?gs3); set fs \\<subseteq> carrier_vec n;\n   set ?gs'3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> norms_mus' fs\n                     ((?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs)\n                     (?xa3 # mus_acc) =\n                    (map sq_norm (rev ?gs3 @ ?gs'3),\n                     rev ?mus3 @ ?xa3 # mus_acc)\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' (f # fs) = (mus, gs)\n  set (f # fs) \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. gs = (snd (adjuster_wit [] f gs') + f) # tl gs", "by (auto simp add: Let_def case_prod_beta')"], ["proof (state)\nthis:\n  gs = (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # tl gs\n\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "have mus: \"mus = fst ?aw # tl mus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mus = fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # tl mus", "apply(subst aw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mus = fst (adjuster_wit [] f gs') # tl mus", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 = mus_adjuster f n_gs [] (0\\<^sub>v n); (?xa3, ?y3) = ?x3;\n   ?xb3 = ?y3 + f;\n   (?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs =\n   map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) ?gs'3;\n   sub2_wit ?gs'3 fs = (?mus3, ?gs3); set fs \\<subseteq> carrier_vec n;\n   set ?gs'3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> norms_mus' fs\n                     ((?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs)\n                     (?xa3 # mus_acc) =\n                    (map sq_norm (rev ?gs3 @ ?gs'3),\n                     rev ?mus3 @ ?xa3 # mus_acc)\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' (f # fs) = (mus, gs)\n  set (f # fs) \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. mus = fst (adjuster_wit [] f gs') # tl mus", "by (auto simp add: Let_def case_prod_beta')"], ["proof (state)\nthis:\n  mus = fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # tl mus\n\ngoal (1 subgoal):\n 1. \\<And>f fs n_gs mus gs' musa gs.\n       \\<lbrakk>\\<And>x xa y xb gs' musa gs.\n                   \\<lbrakk>x = mus_adjuster f n_gs [] (0\\<^sub>v n);\n                    (xa, y) = x; xb = y + f;\n                    (xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs =\n                    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n                     gs';\n                    sub2_wit gs' fs = (musa, gs);\n                    set fs \\<subseteq> carrier_vec n;\n                    set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n                   \\<Longrightarrow> norms_mus' fs\n((xb, \\<parallel>xb\\<parallel>\\<^sup>2) # n_gs) (xa # mus) =\n                                     (map sq_norm (rev gs @ gs'),\nrev musa @ xa # mus);\n        n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs';\n        sub2_wit gs' (f # fs) = (musa, gs);\n        set (f # fs) \\<subseteq> carrier_vec n;\n        set gs' \\<subseteq> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> norms_mus' (f # fs) n_gs mus =\n                         (map sq_norm (rev gs @ gs'), rev musa @ mus)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. norms_mus' (f # fs) n_gs mus_acc =\n    (map sq_norm (rev gs @ gs'), rev mus @ mus_acc)", "apply(simp add: Let_def case_prod_beta')"], ["proof (prove)\ngoal (1 subgoal):\n 1. norms_mus' fs\n     ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f,\n       \\<parallel>snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) +\n                  f\\<parallel>\\<^sup>2) #\n      n_gs)\n     (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)", "apply(subst 2(1)[of _ _ _ _ \"(snd ?aw + f)#gs'\"  \"tl mus\" \"tl gs\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. ?x = mus_adjuster f n_gs [] (0\\<^sub>v n)\n 2. (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)), ?y) = ?x\n 3. snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f = ?y + f\n 4. (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f,\n     \\<parallel>snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) +\n                f\\<parallel>\\<^sup>2) #\n    n_gs =\n    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n     ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n 5. sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n    (tl mus, tl gs)\n 6. set fs \\<subseteq> carrier_vec n\n 7. set ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n    \\<subseteq> carrier_vec n\n 8. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)", "apply(simp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)), ?y) =\n    mus_adjuster f n_gs [] (0\\<^sub>v n)\n 2. snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f = ?y + f\n 3. (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f,\n     \\<parallel>snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) +\n                f\\<parallel>\\<^sup>2) #\n    n_gs =\n    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n     ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n 4. sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n    (tl mus, tl gs)\n 5. set fs \\<subseteq> carrier_vec n\n 6. set ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n    \\<subseteq> carrier_vec n\n 7. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)", "defer"], ["proof (prove)\ngoal (7 subgoals):\n 1. snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f = ?y + f\n 2. (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f,\n     \\<parallel>snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) +\n                f\\<parallel>\\<^sup>2) #\n    n_gs =\n    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n     ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n 3. sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n    (tl mus, tl gs)\n 4. set fs \\<subseteq> carrier_vec n\n 5. set ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n    \\<subseteq> carrier_vec n\n 6. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)\n 7. (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)), ?y) =\n    mus_adjuster f n_gs [] (0\\<^sub>v n)", "apply(simp)"], ["proof (prove)\ngoal (6 subgoals):\n 1. (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f,\n     \\<parallel>snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) +\n                f\\<parallel>\\<^sup>2) #\n    n_gs =\n    map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2))\n     ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n 2. sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n    (tl mus, tl gs)\n 3. set fs \\<subseteq> carrier_vec n\n 4. set ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n    \\<subseteq> carrier_vec n\n 5. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)\n 6. (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)),\n     snd (mus_adjuster f n_gs [] (0\\<^sub>v n))) =\n    mus_adjuster f n_gs [] (0\\<^sub>v n)", "apply (simp add: \"2.prems\"(1))"], ["proof (prove)\ngoal (5 subgoals):\n 1. sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n    (tl mus, tl gs)\n 2. set fs \\<subseteq> carrier_vec n\n 3. set ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n    \\<subseteq> carrier_vec n\n 4. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)\n 5. (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)),\n     snd (mus_adjuster f n_gs [] (0\\<^sub>v n))) =\n    mus_adjuster f n_gs [] (0\\<^sub>v n)", "using sub_tl"], ["proof (prove)\nusing this:\n  sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n  (tl mus, tl gs)\n\ngoal (5 subgoals):\n 1. sub2_wit ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs') fs =\n    (tl mus, tl gs)\n 2. set fs \\<subseteq> carrier_vec n\n 3. set ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n    \\<subseteq> carrier_vec n\n 4. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)\n 5. (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)),\n     snd (mus_adjuster f n_gs [] (0\\<^sub>v n))) =\n    mus_adjuster f n_gs [] (0\\<^sub>v n)", "apply(simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. set fs \\<subseteq> carrier_vec n\n 2. set ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n    \\<subseteq> carrier_vec n\n 3. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)\n 4. (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)),\n     snd (mus_adjuster f n_gs [] (0\\<^sub>v n))) =\n    mus_adjuster f n_gs [] (0\\<^sub>v n)", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 = mus_adjuster f n_gs [] (0\\<^sub>v n); (?xa3, ?y3) = ?x3;\n   ?xb3 = ?y3 + f;\n   (?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs =\n   map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) ?gs'3;\n   sub2_wit ?gs'3 fs = (?mus3, ?gs3); set fs \\<subseteq> carrier_vec n;\n   set ?gs'3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> norms_mus' fs\n                     ((?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs)\n                     (?xa3 # mus_acc) =\n                    (map sq_norm (rev ?gs3 @ ?gs'3),\n                     rev ?mus3 @ ?xa3 # mus_acc)\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' (f # fs) = (mus, gs)\n  set (f # fs) \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n\ngoal (4 subgoals):\n 1. set fs \\<subseteq> carrier_vec n\n 2. set ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n    \\<subseteq> carrier_vec n\n 3. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)\n 4. (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)),\n     snd (mus_adjuster f n_gs [] (0\\<^sub>v n))) =\n    mus_adjuster f n_gs [] (0\\<^sub>v n)", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n    \\<subseteq> carrier_vec n\n 2. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)\n 3. (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)),\n     snd (mus_adjuster f n_gs [] (0\\<^sub>v n))) =\n    mus_adjuster f n_gs [] (0\\<^sub>v n)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n    \\<subseteq> carrier_vec n", "using 2 aw_c"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 = mus_adjuster f n_gs [] (0\\<^sub>v n); (?xa3, ?y3) = ?x3;\n   ?xb3 = ?y3 + f;\n   (?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs =\n   map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) ?gs'3;\n   sub2_wit ?gs'3 fs = (?mus3, ?gs3); set fs \\<subseteq> carrier_vec n;\n   set ?gs'3 \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> norms_mus' fs\n                     ((?xb3, \\<parallel>?xb3\\<parallel>\\<^sup>2) # n_gs)\n                     (?xa3 # mus_acc) =\n                    (map sq_norm (rev ?gs3 @ ?gs'3),\n                     rev ?mus3 @ ?xa3 # mus_acc)\n  n_gs = map (\\<lambda>v. (v, \\<parallel>v\\<parallel>\\<^sup>2)) gs'\n  sub2_wit gs' (f # fs) = (mus, gs)\n  set (f # fs) \\<subseteq> carrier_vec n\n  set gs' \\<subseteq> carrier_vec n\n  snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs')\n    \\<subseteq> carrier_vec n", "by (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)\n 2. (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)),\n     snd (mus_adjuster f n_gs [] (0\\<^sub>v n))) =\n    mus_adjuster f n_gs [] (0\\<^sub>v n)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. (fst (mus_adjuster f n_gs [] (0\\<^sub>v n)),\n     snd (mus_adjuster f n_gs [] (0\\<^sub>v n))) =\n    mus_adjuster f n_gs [] (0\\<^sub>v n)\n 2. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map sq_norm\n      (rev (tl gs) @\n       (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # gs'),\n     rev (tl mus) @ fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # mus_acc) =\n    (map sq_norm (rev gs) @ map sq_norm gs', rev mus @ mus_acc)", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map sq_norm (rev (tl gs)) @\n    [\\<parallel>snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) +\n                f\\<parallel>\\<^sup>2] =\n    map sq_norm (rev gs)\n 2. rev (tl mus) @ [fst (mus_adjuster f n_gs [] (0\\<^sub>v n))] = rev mus", "using gs"], ["proof (prove)\nusing this:\n  gs = (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # tl gs\n\ngoal (2 subgoals):\n 1. map sq_norm (rev (tl gs)) @\n    [\\<parallel>snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) +\n                f\\<parallel>\\<^sup>2] =\n    map sq_norm (rev gs)\n 2. rev (tl mus) @ [fst (mus_adjuster f n_gs [] (0\\<^sub>v n))] = rev mus", "apply(subst gs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gs =\n    (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) #\n    tl gs \\<Longrightarrow>\n    map sq_norm\n     (rev (tl ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # tl gs))) @\n    [\\<parallel>snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) +\n                f\\<parallel>\\<^sup>2] =\n    map sq_norm (rev gs)\n 2. rev (tl mus) @ [fst (mus_adjuster f n_gs [] (0\\<^sub>v n))] = rev mus", "apply(subst (2) gs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gs =\n    (snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) #\n    tl gs \\<Longrightarrow>\n    map sq_norm\n     (rev (tl ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # tl gs))) @\n    [\\<parallel>snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) +\n                f\\<parallel>\\<^sup>2] =\n    map sq_norm\n     (rev ((snd (mus_adjuster f n_gs [] (0\\<^sub>v n)) + f) # tl gs))\n 2. rev (tl mus) @ [fst (mus_adjuster f n_gs [] (0\\<^sub>v n))] = rev mus", "apply (metis list.simps(9) rev.simps(2) rev_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (tl mus) @ [fst (mus_adjuster f n_gs [] (0\\<^sub>v n))] = rev mus", "using mus"], ["proof (prove)\nusing this:\n  mus = fst (mus_adjuster f n_gs [] (0\\<^sub>v n)) # tl mus\n\ngoal (1 subgoal):\n 1. rev (tl mus) @ [fst (mus_adjuster f n_gs [] (0\\<^sub>v n))] = rev mus", "by (metis rev.simps(2))"], ["proof (state)\nthis:\n  norms_mus' (f # fs) n_gs mus_acc =\n  (map sq_norm (rev gs @ gs'), rev mus @ mus_acc)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sub2_wit_gram_schmidt_sub_triv'':\n  assumes \"sub2_wit [] fs = (mus, gs)\" \"set fs \\<subseteq> carrier_vec n\"\n  shows \"norms_mus' fs [] [] = (map sq_norm_vec (rev gs), rev mus)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norms_mus' fs [] [] = (map sq_norm (rev gs), rev mus)", "using assms"], ["proof (prove)\nusing this:\n  sub2_wit [] fs = (mus, gs)\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. norms_mus' fs [] [] = (map sq_norm (rev gs), rev mus)", "by (subst sub2_wit_norms_mus') (simp)+"], ["", "definition norms_mus where\n  \"norms_mus fs = (let (n_gs, mus) = norms_mus' fs [] [] in (rev n_gs, rev mus))\""], ["", "lemma sub2_wit_gram_schmidt_norm_mus:\n  assumes \"sub2_wit [] fs = (mus, gs)\" \"set fs \\<subseteq> carrier_vec n\"\n  shows \"norms_mus fs = (map sq_norm_vec gs, mus)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norms_mus fs = (map sq_norm gs, mus)", "unfolding norms_mus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (n_gs, mus) = norms_mus' fs [] [] in (rev n_gs, rev mus)) =\n    (map sq_norm gs, mus)", "using assms sub2_wit_gram_schmidt_sub_triv''"], ["proof (prove)\nusing this:\n  sub2_wit [] fs = (mus, gs)\n  set fs \\<subseteq> carrier_vec n\n  \\<lbrakk>sub2_wit [] ?fs = (?mus, ?gs);\n   set ?fs \\<subseteq> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> norms_mus' ?fs [] [] = (map sq_norm (rev ?gs), rev ?mus)\n\ngoal (1 subgoal):\n 1. (let (n_gs, mus) = norms_mus' fs [] [] in (rev n_gs, rev mus)) =\n    (map sq_norm gs, mus)", "by (auto simp add: Let_def case_prod_beta' rev_map)"], ["", "lemma (in gram_schmidt_fs_Rn) norms_mus: assumes \"set fs \\<subseteq> carrier_vec n\" \"length fs \\<le> n\"\n  shows \"norms_mus fs = (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs], map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norms_mus fs =\n    (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs],\n     map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norms_mus fs =\n    (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs],\n     map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])", "let ?s = \"sub2_wit [] fs\""], ["proof (state)\ngoal (1 subgoal):\n 1. norms_mus fs =\n    (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs],\n     map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])", "have \"gram_schmidt_sub2 n [] fs = snd ?s \\<and> snd ?s = map (gso) [0..<length fs] \\<and> fst ?s = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and>\n    snd (sub2_wit [] fs) = map gso [0..<length fs] \\<and>\n    fst (sub2_wit [] fs) =\n    map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]", "using assms"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  length fs \\<le> n\n\ngoal (1 subgoal):\n 1. gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and>\n    snd (sub2_wit [] fs) = map gso [0..<length fs] \\<and>\n    fst (sub2_wit [] fs) =\n    map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]", "by (intro sub2_wit) (auto simp add: map_nth)"], ["proof (state)\nthis:\n  gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and>\n  snd (sub2_wit [] fs) = map gso [0..<length fs] \\<and>\n  fst (sub2_wit [] fs) =\n  map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]\n\ngoal (1 subgoal):\n 1. norms_mus fs =\n    (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs],\n     map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])", "then"], ["proof (chain)\npicking this:\n  gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and>\n  snd (sub2_wit [] fs) = map gso [0..<length fs] \\<and>\n  fst (sub2_wit [] fs) =\n  map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]", "have 1: \"snd ?s = map (gso) [0..<length fs]\" and 2: \"fst ?s = map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]\""], ["proof (prove)\nusing this:\n  gram_schmidt_sub2 n [] fs = snd (sub2_wit [] fs) \\<and>\n  snd (sub2_wit [] fs) = map gso [0..<length fs] \\<and>\n  fst (sub2_wit [] fs) =\n  map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]\n\ngoal (1 subgoal):\n 1. snd (sub2_wit [] fs) = map gso [0..<length fs] &&&\n    fst (sub2_wit [] fs) =\n    map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]", "by auto"], ["proof (state)\nthis:\n  snd (sub2_wit [] fs) = map gso [0..<length fs]\n  fst (sub2_wit [] fs) =\n  map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]\n\ngoal (1 subgoal):\n 1. norms_mus fs =\n    (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs],\n     map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])", "have s: \"?s = (fst ?s, snd ?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub2_wit [] fs = (fst (sub2_wit [] fs), snd (sub2_wit [] fs))", "by auto"], ["proof (state)\nthis:\n  sub2_wit [] fs = (fst (sub2_wit [] fs), snd (sub2_wit [] fs))\n\ngoal (1 subgoal):\n 1. norms_mus fs =\n    (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs],\n     map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. norms_mus fs =\n    (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs],\n     map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])", "unfolding sub2_wit_gram_schmidt_norm_mus[OF s assms(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map sq_norm (snd (sub2_wit [] fs)), fst (sub2_wit [] fs)) =\n    (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs],\n     map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])", "unfolding 1 2 o_def map_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>x. \\<parallel>gso x\\<parallel>\\<^sup>2) [0..<length fs],\n     map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs]) =\n    (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs],\n     map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])", "by auto"], ["proof (state)\nthis:\n  norms_mus fs =\n  (map (\\<lambda>j. \\<parallel>gso j\\<parallel>\\<^sup>2) [0..<length fs],\n   map (\\<lambda>i. map (\\<mu> i) [0..<i]) [0..<length fs])\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun mus_adjuster_rat :: \"rat vec \\<Rightarrow> (rat vec \\<times> rat) list \\<Rightarrow> rat list \\<Rightarrow> rat vec \\<Rightarrow> rat list \\<times> rat vec\"\n  where\n  \"mus_adjuster_rat f []           mus g' = (mus, g')\" |\n  \"mus_adjuster_rat f ((g, ng)#n_gs) mus g' = (let a = (f \\<bullet> g) / ng in\n                                             mus_adjuster_rat f n_gs (a # mus) (-a \\<cdot>\\<^sub>v g + g'))\""], ["", "fun norms_mus_rat' where\n  \"norms_mus_rat' n []       n_gs mus = (map snd n_gs, mus)\" |\n  \"norms_mus_rat' n (f # fs) n_gs mus =\n    (let (mus_row, g') = mus_adjuster_rat f n_gs [] (0\\<^sub>v n);\n                     g = g' + f in\n      norms_mus_rat' n fs ((g, sq_norm_vec g) # n_gs) (mus_row#mus))\""], ["", "definition norms_mus_rat where\n  \"norms_mus_rat n fs = (let (n_gs, mus) = norms_mus_rat' n fs [] [] in (rev n_gs, rev mus))\""], ["", "lemma norms_mus_rat_norms_mus:\n  \"norms_mus_rat n fs = gram_schmidt.norms_mus n fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norms_mus_rat n fs = gram_schmidt.norms_mus n fs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norms_mus_rat n fs = gram_schmidt.norms_mus n fs", "have \"mus_adjuster_rat f n_gs mus_acc g_acc = gram_schmidt.mus_adjuster f n_gs mus_acc g_acc\"\n    for f n_gs mus_acc g_acc"], ["proof (prove)\ngoal (1 subgoal):\n 1. mus_adjuster_rat f n_gs mus_acc g_acc =\n    gram_schmidt.mus_adjuster f n_gs mus_acc g_acc", "by(induction f n_gs mus_acc g_acc rule: mus_adjuster_rat.induct)\n      (auto simp add: gram_schmidt.mus_adjuster.simps)"], ["proof (state)\nthis:\n  mus_adjuster_rat ?f ?n_gs ?mus_acc ?g_acc =\n  gram_schmidt.mus_adjuster ?f ?n_gs ?mus_acc ?g_acc\n\ngoal (1 subgoal):\n 1. norms_mus_rat n fs = gram_schmidt.norms_mus n fs", "then"], ["proof (chain)\npicking this:\n  mus_adjuster_rat ?f ?n_gs ?mus_acc ?g_acc =\n  gram_schmidt.mus_adjuster ?f ?n_gs ?mus_acc ?g_acc", "have \"norms_mus_rat' n fs n_gs mus = gram_schmidt.norms_mus' n fs n_gs mus\" for n fs n_gs mus"], ["proof (prove)\nusing this:\n  mus_adjuster_rat ?f ?n_gs ?mus_acc ?g_acc =\n  gram_schmidt.mus_adjuster ?f ?n_gs ?mus_acc ?g_acc\n\ngoal (1 subgoal):\n 1. norms_mus_rat' n fs n_gs mus = gram_schmidt.norms_mus' n fs n_gs mus", "by(induction n fs n_gs mus rule: norms_mus_rat'.induct)\n      (auto simp add: gram_schmidt.norms_mus'.simps case_prod_beta')"], ["proof (state)\nthis:\n  norms_mus_rat' ?n ?fs ?n_gs ?mus =\n  gram_schmidt.norms_mus' ?n ?fs ?n_gs ?mus\n\ngoal (1 subgoal):\n 1. norms_mus_rat n fs = gram_schmidt.norms_mus n fs", "then"], ["proof (chain)\npicking this:\n  norms_mus_rat' ?n ?fs ?n_gs ?mus =\n  gram_schmidt.norms_mus' ?n ?fs ?n_gs ?mus", "show ?thesis"], ["proof (prove)\nusing this:\n  norms_mus_rat' ?n ?fs ?n_gs ?mus =\n  gram_schmidt.norms_mus' ?n ?fs ?n_gs ?mus\n\ngoal (1 subgoal):\n 1. norms_mus_rat n fs = gram_schmidt.norms_mus n fs", "unfolding norms_mus_rat_def gram_schmidt.norms_mus_def"], ["proof (prove)\nusing this:\n  norms_mus_rat' ?n ?fs ?n_gs ?mus =\n  gram_schmidt.norms_mus' ?n ?fs ?n_gs ?mus\n\ngoal (1 subgoal):\n 1. (let (n_gs, mus) = norms_mus_rat' n fs [] [] in (rev n_gs, rev mus)) =\n    (let (n_gs, mus) = gram_schmidt.norms_mus' n fs [] []\n     in (rev n_gs, rev mus))", "by auto"], ["proof (state)\nthis:\n  norms_mus_rat n fs = gram_schmidt.norms_mus n fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_int_dvd:\n  \"b dvd a\" if \"of_int a / (of_int b :: 'a :: field_char_0) \\<in> \\<int>\" \"b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b dvd a", "using that"], ["proof (prove)\nusing this:\n  of_int a / of_int b \\<in> \\<int>\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b dvd a", "by (cases rule: Ints_cases)\n    (simp add: field_simps flip: of_int_mult)"], ["", "lemma denom_dvd_ints:\n  fixes i::int\n  assumes \"quotient_of r = (z, n)\" \"of_int i * r \\<in> \\<int>\"\n  shows \"n dvd i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n dvd i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n dvd i", "have \"rat_of_int i * (rat_of_int z / rat_of_int n) \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int i * (rat_of_int z / rat_of_int n) \\<in> \\<int>", "using assms quotient_of_div"], ["proof (prove)\nusing this:\n  quotient_of r = (z, n)\n  rat_of_int i * r \\<in> \\<int>\n  quotient_of ?r = (?n, ?d) \\<Longrightarrow>\n  ?r = rat_of_int ?n / rat_of_int ?d\n\ngoal (1 subgoal):\n 1. rat_of_int i * (rat_of_int z / rat_of_int n) \\<in> \\<int>", "by blast"], ["proof (state)\nthis:\n  rat_of_int i * (rat_of_int z / rat_of_int n) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. n dvd i", "then"], ["proof (chain)\npicking this:\n  rat_of_int i * (rat_of_int z / rat_of_int n) \\<in> \\<int>", "have \"n dvd i * z\""], ["proof (prove)\nusing this:\n  rat_of_int i * (rat_of_int z / rat_of_int n) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. n dvd i * z", "using quotient_of_denom_pos assms"], ["proof (prove)\nusing this:\n  rat_of_int i * (rat_of_int z / rat_of_int n) \\<in> \\<int>\n  quotient_of ?r = (?p, ?q) \\<Longrightarrow> 0 < ?q\n  quotient_of r = (z, n)\n  rat_of_int i * r \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. n dvd i * z", "by (auto intro!: of_int_dvd)"], ["proof (state)\nthis:\n  n dvd i * z\n\ngoal (1 subgoal):\n 1. n dvd i", "then"], ["proof (chain)\npicking this:\n  n dvd i * z", "show \"n dvd i\""], ["proof (prove)\nusing this:\n  n dvd i * z\n\ngoal (1 subgoal):\n 1. n dvd i", "using assms algebraic_semidom_class.coprime_commute \n      quotient_of_coprime coprime_dvd_mult_left_iff"], ["proof (prove)\nusing this:\n  n dvd i * z\n  quotient_of r = (z, n)\n  rat_of_int i * r \\<in> \\<int>\n  algebraic_semidom_class.coprime ?b ?a =\n  algebraic_semidom_class.coprime ?a ?b\n  quotient_of ?r = (?p, ?q) \\<Longrightarrow>\n  algebraic_semidom_class.coprime ?p ?q\n  algebraic_semidom_class.coprime ?a ?c \\<Longrightarrow>\n  (?a dvd ?b * ?c) = (?a dvd ?b)\n\ngoal (1 subgoal):\n 1. n dvd i", "by blast"], ["proof (state)\nthis:\n  n dvd i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quotient_of_bounds: \n  assumes \"quotient_of r = (n, d)\" \"rat_of_int i * r \\<in> \\<int>\" \"0 < i\" \"\\<bar>r\\<bar> \\<le> b\"\n  shows \"of_int \\<bar>n\\<bar> \\<le> of_int i * b\" \"d \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b &&& d \\<le> i", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b\n 2. d \\<le> i", "show ni: \"d \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> i", "using assms denom_dvd_ints"], ["proof (prove)\nusing this:\n  quotient_of r = (n, d)\n  rat_of_int i * r \\<in> \\<int>\n  0 < i\n  \\<bar>r\\<bar> \\<le> b\n  \\<lbrakk>quotient_of ?r = (?z, ?n);\n   rat_of_int ?i * ?r \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> ?n dvd ?i\n\ngoal (1 subgoal):\n 1. d \\<le> i", "by (intro zdvd_imp_le) blast+"], ["proof (state)\nthis:\n  d \\<le> i\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b", "have \"\\<bar>r\\<bar> = \\<bar>rat_of_int n / rat_of_int d\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>r\\<bar> = \\<bar>rat_of_int n / rat_of_int d\\<bar>", "using assms quotient_of_div"], ["proof (prove)\nusing this:\n  quotient_of r = (n, d)\n  rat_of_int i * r \\<in> \\<int>\n  0 < i\n  \\<bar>r\\<bar> \\<le> b\n  quotient_of ?r = (?n, ?d) \\<Longrightarrow>\n  ?r = rat_of_int ?n / rat_of_int ?d\n\ngoal (1 subgoal):\n 1. \\<bar>r\\<bar> = \\<bar>rat_of_int n / rat_of_int d\\<bar>", "by blast"], ["proof (state)\nthis:\n  \\<bar>r\\<bar> = \\<bar>rat_of_int n / rat_of_int d\\<bar>\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b", "also"], ["proof (state)\nthis:\n  \\<bar>r\\<bar> = \\<bar>rat_of_int n / rat_of_int d\\<bar>\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b", "have \"\\<dots> = rat_of_int \\<bar>n\\<bar> / rat_of_int d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>rat_of_int n / rat_of_int d\\<bar> =\n    rat_of_int \\<bar>n\\<bar> / rat_of_int d", "using assms"], ["proof (prove)\nusing this:\n  quotient_of r = (n, d)\n  rat_of_int i * r \\<in> \\<int>\n  0 < i\n  \\<bar>r\\<bar> \\<le> b\n\ngoal (1 subgoal):\n 1. \\<bar>rat_of_int n / rat_of_int d\\<bar> =\n    rat_of_int \\<bar>n\\<bar> / rat_of_int d", "using quotient_of_denom_pos"], ["proof (prove)\nusing this:\n  quotient_of r = (n, d)\n  rat_of_int i * r \\<in> \\<int>\n  0 < i\n  \\<bar>r\\<bar> \\<le> b\n  quotient_of ?r = (?p, ?q) \\<Longrightarrow> 0 < ?q\n\ngoal (1 subgoal):\n 1. \\<bar>rat_of_int n / rat_of_int d\\<bar> =\n    rat_of_int \\<bar>n\\<bar> / rat_of_int d", "by force"], ["proof (state)\nthis:\n  \\<bar>rat_of_int n / rat_of_int d\\<bar> =\n  rat_of_int \\<bar>n\\<bar> / rat_of_int d\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b", "finally"], ["proof (chain)\npicking this:\n  \\<bar>r\\<bar> = rat_of_int \\<bar>n\\<bar> / rat_of_int d", "have \"of_int \\<bar>n\\<bar> = rat_of_int d * \\<bar>r\\<bar>\""], ["proof (prove)\nusing this:\n  \\<bar>r\\<bar> = rat_of_int \\<bar>n\\<bar> / rat_of_int d\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> = rat_of_int d * \\<bar>r\\<bar>", "using assms"], ["proof (prove)\nusing this:\n  \\<bar>r\\<bar> = rat_of_int \\<bar>n\\<bar> / rat_of_int d\n  quotient_of r = (n, d)\n  rat_of_int i * r \\<in> \\<int>\n  0 < i\n  \\<bar>r\\<bar> \\<le> b\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> = rat_of_int d * \\<bar>r\\<bar>", "by auto"], ["proof (state)\nthis:\n  rat_of_int \\<bar>n\\<bar> = rat_of_int d * \\<bar>r\\<bar>\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b", "also"], ["proof (state)\nthis:\n  rat_of_int \\<bar>n\\<bar> = rat_of_int d * \\<bar>r\\<bar>\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b", "have \"\\<dots> \\<le> rat_of_int d * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int d * \\<bar>r\\<bar> \\<le> rat_of_int d * b", "using assms quotient_of_denom_pos"], ["proof (prove)\nusing this:\n  quotient_of r = (n, d)\n  rat_of_int i * r \\<in> \\<int>\n  0 < i\n  \\<bar>r\\<bar> \\<le> b\n  quotient_of ?r = (?p, ?q) \\<Longrightarrow> 0 < ?q\n\ngoal (1 subgoal):\n 1. rat_of_int d * \\<bar>r\\<bar> \\<le> rat_of_int d * b", "by auto"], ["proof (state)\nthis:\n  rat_of_int d * \\<bar>r\\<bar> \\<le> rat_of_int d * b\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b", "also"], ["proof (state)\nthis:\n  rat_of_int d * \\<bar>r\\<bar> \\<le> rat_of_int d * b\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b", "have \"\\<dots> \\<le> rat_of_int i * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int d * b \\<le> rat_of_int i * b", "using ni assms of_int_le_iff"], ["proof (prove)\nusing this:\n  d \\<le> i\n  quotient_of r = (n, d)\n  rat_of_int i * r \\<in> \\<int>\n  0 < i\n  \\<bar>r\\<bar> \\<le> b\n  (of_int ?w \\<le> of_int ?z) = (?w \\<le> ?z)\n\ngoal (1 subgoal):\n 1. rat_of_int d * b \\<le> rat_of_int i * b", "by (auto intro!: mult_right_mono)"], ["proof (state)\nthis:\n  rat_of_int d * b \\<le> rat_of_int i * b\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b", "finally"], ["proof (chain)\npicking this:\n  rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b", "show \"rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b\""], ["proof (prove)\nusing this:\n  rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b", "by simp"], ["proof (state)\nthis:\n  rat_of_int \\<bar>n\\<bar> \\<le> rat_of_int i * b\n\ngoal:\nNo subgoals!", "qed"], ["", "context gram_schmidt_fs_Rn\nbegin"], ["", "(* Lemma 16.17 *)"], ["", "lemma ex_\\<kappa>:\n  assumes \"i < length fs\" \"l \\<le> i\"\n  shows \"\\<exists>\\<kappa>. sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0 ..< l]) =\n             sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0 ..< l])\" (is \"\\<exists>\\<kappa>. ?Prop l i \\<kappa>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<kappa>.\n       M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n       M.sumlist\n        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n\ngoal (1 subgoal):\n 1. \\<exists>\\<kappa>.\n       M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n       M.sumlist\n        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "proof (induction l arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "case (Suc l)"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i1 j \\<cdot>\\<^sub>v gso j)\n                          [0..<l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<l])\n  i < length fs\n  Suc l \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i1 j \\<cdot>\\<^sub>v gso j)\n                          [0..<l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<l])\n  i < length fs\n  Suc l \\<le> i", "obtain \\<kappa>\\<^sub>i where \\<kappa>\\<^sub>i_def: \"?Prop l i \\<kappa>\\<^sub>i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i1 j \\<cdot>\\<^sub>v gso j)\n                          [0..<l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<l])\n  i < length fs\n  Suc l \\<le> i\n\ngoal (1 subgoal):\n 1. (\\<And>\\<kappa>\\<^sub>i.\n        M.sumlist\n         (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n        M.sumlist\n         (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n           [0..<l]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i1 j \\<cdot>\\<^sub>v gso j)\n                          [0..<l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<l])\n  i < length fs\n  Suc l \\<le> i", "obtain \\<kappa>\\<^sub>l where \\<kappa>\\<^sub>l_def: \"?Prop l l \\<kappa>\\<^sub>l\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i1 j \\<cdot>\\<^sub>v gso j)\n                          [0..<l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<l])\n  i < length fs\n  Suc l \\<le> i\n\ngoal (1 subgoal):\n 1. (\\<And>\\<kappa>\\<^sub>l.\n        M.sumlist\n         (map (\\<lambda>j. - \\<mu> l j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n        M.sumlist\n         (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n           [0..<l]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. - \\<mu> l j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "have [simp]: \"dim_vec (M.sumlist (map (\\<lambda>j. f j \\<cdot>\\<^sub>v fs ! j) [0..<y])) = n\" if \"y \\<le> Suc l\" for f y"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (M.sumlist (map (\\<lambda>j. f j \\<cdot>\\<^sub>v fs ! j) [0..<y])) =\n    n", "using Suc that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i1 j \\<cdot>\\<^sub>v gso j)\n                          [0..<l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<l])\n  i < length fs\n  Suc l \\<le> i\n  y \\<le> Suc l\n\ngoal (1 subgoal):\n 1. dim_vec\n     (M.sumlist (map (\\<lambda>j. f j \\<cdot>\\<^sub>v fs ! j) [0..<y])) =\n    n", "by (auto intro!: dim_sumlist)"], ["proof (state)\nthis:\n  ?y1 \\<le> Suc l \\<Longrightarrow>\n  dim_vec\n   (M.sumlist (map (\\<lambda>j. ?f1 j \\<cdot>\\<^sub>v fs ! j) [0..<?y1])) =\n  n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "define \\<kappa> where \"\\<kappa> = (\\<lambda>x. (if x < l then \\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l else  - \\<mu> i l))\""], ["proof (state)\nthis:\n  \\<kappa> =\n  (\\<lambda>x.\n      if x < l then \\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l\n      else - \\<mu> i l)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "let ?sum = \"\\<lambda>i. sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "have \"M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]) = \n        M.sumlist (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) + - \\<mu> i l \\<cdot>\\<^sub>v gso l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n    - \\<mu> i l \\<cdot>\\<^sub>v gso l", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i1 j \\<cdot>\\<^sub>v gso j)\n                          [0..<l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<l])\n  i < length fs\n  Suc l \\<le> i\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n    - \\<mu> i l \\<cdot>\\<^sub>v gso l", "by (subst \\<kappa>\\<^sub>i_def[symmetric], subst sumlist_snoc[symmetric]) (auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]) =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n  - \\<mu> i l \\<cdot>\\<^sub>v gso l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]) =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n  - \\<mu> i l \\<cdot>\\<^sub>v gso l\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "have \"gso l = fs ! l + M.sumlist (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso l =\n    fs ! l +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "by (subst gso.simps) (auto simp add: \\<kappa>\\<^sub>l_def)"], ["proof (state)\nthis:\n  gso l =\n  fs ! l +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "also"], ["proof (state)\nthis:\n  gso l =\n  fs ! l +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "have \"M.sumlist (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n             - \\<mu> i l \\<cdot>\\<^sub>v (fs ! l + M.sumlist (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l]))\n             = M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n    - \\<mu> i l \\<cdot>\\<^sub>v\n    (fs ! l +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n    - \\<mu> i l \\<cdot>\\<^sub>v\n    (fs ! l +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])", "have \"?lhs $ k = ?rhs $ k\" if \"k < n\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "have \"(M.sumlist (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) + \n                - \\<mu> i l \\<cdot>\\<^sub>v (fs ! l + M.sumlist (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l]))) $ k\n          = (M.sumlist (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $ k + \n                - \\<mu> i l * (fs ! l $ k + M.sumlist (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $ k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n    k +\n    - \\<mu> i l *\n    (fs ! l $ k +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) $\n     k)", "using that"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n    k +\n    - \\<mu> i l *\n    (fs ! l $ k +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) $\n     k)", "by auto"], ["proof (state)\nthis:\n  (M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v\n   (fs ! l +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]))) $\n  k =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n  k +\n  - \\<mu> i l *\n  (fs ! l $ k +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n   k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "also"], ["proof (state)\nthis:\n  (M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v\n   (fs ! l +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]))) $\n  k =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n  k +\n  - \\<mu> i l *\n  (fs ! l $ k +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n   k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "have \"\\<dots> = (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>i j * fs ! j $ k) \n                 + (- \\<mu> i l * (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>l j * fs ! j $ k)) - \\<mu> i l * fs ! l $ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n    k +\n    - \\<mu> i l *\n    (fs ! l $ k +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) $\n     k) =\n    (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>i j * fs ! j $ k) +\n    - \\<mu> i l * (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>l j * fs ! j $ k) -\n    \\<mu> i l * fs ! l $ k", "using that Suc"], ["proof (prove)\nusing this:\n  k < n\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i1 j \\<cdot>\\<^sub>v gso j)\n                          [0..<l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<l])\n  i < length fs\n  Suc l \\<le> i\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n    k +\n    - \\<mu> i l *\n    (fs ! l $ k +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) $\n     k) =\n    (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>i j * fs ! j $ k) +\n    - \\<mu> i l * (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>l j * fs ! j $ k) -\n    \\<mu> i l * fs ! l $ k", "by (auto simp add: algebra_simps sumlist_nth)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n  k +\n  - \\<mu> i l *\n  (fs ! l $ k +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n   k) =\n  (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>i j * fs ! j $ k) +\n  - \\<mu> i l * (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>l j * fs ! j $ k) -\n  \\<mu> i l * fs ! l $ k\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n  k +\n  - \\<mu> i l *\n  (fs ! l $ k +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) $\n   k) =\n  (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>i j * fs ! j $ k) +\n  - \\<mu> i l * (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>l j * fs ! j $ k) -\n  \\<mu> i l * fs ! l $ k\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "have \"- \\<mu> i l * (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>l j * fs ! j $ k) \n               = (\\<Sum>j = 0..<l. - \\<mu> i l * (\\<kappa>\\<^sub>l j * fs ! j $ k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<mu> i l * (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>l j * fs ! j $ k) =\n    (\\<Sum>j = 0..<l. - \\<mu> i l * (\\<kappa>\\<^sub>l j * fs ! j $ k))", "using sum_distrib_left"], ["proof (prove)\nusing this:\n  ?r * sum ?f ?A = (\\<Sum>n\\<in>?A. ?r * ?f n)\n\ngoal (1 subgoal):\n 1. - \\<mu> i l * (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>l j * fs ! j $ k) =\n    (\\<Sum>j = 0..<l. - \\<mu> i l * (\\<kappa>\\<^sub>l j * fs ! j $ k))", "by blast"], ["proof (state)\nthis:\n  - \\<mu> i l * (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>l j * fs ! j $ k) =\n  (\\<Sum>j = 0..<l. - \\<mu> i l * (\\<kappa>\\<^sub>l j * fs ! j $ k))\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "also"], ["proof (state)\nthis:\n  - \\<mu> i l * (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>l j * fs ! j $ k) =\n  (\\<Sum>j = 0..<l. - \\<mu> i l * (\\<kappa>\\<^sub>l j * fs ! j $ k))\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "have \"(\\<Sum>j = 0..<l. \\<kappa>\\<^sub>i j * fs ! j $ k) + (\\<Sum>j = 0..<l. - \\<mu> i l * (\\<kappa>\\<^sub>l j * fs ! j $ k)) =\n               (\\<Sum>x = 0..<l. (\\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l) * fs ! x $ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>i j * fs ! j $ k) +\n    (\\<Sum>j = 0..<l. - \\<mu> i l * (\\<kappa>\\<^sub>l j * fs ! j $ k)) =\n    (\\<Sum>x = 0..<l.\n        (\\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l) * fs ! x $ k)", "by (subst sum.distrib[symmetric]) (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>i j * fs ! j $ k) +\n  (\\<Sum>j = 0..<l. - \\<mu> i l * (\\<kappa>\\<^sub>l j * fs ! j $ k)) =\n  (\\<Sum>x = 0..<l.\n      (\\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l) * fs ! x $ k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<l. \\<kappa>\\<^sub>i j * fs ! j $ k) +\n  (\\<Sum>j = 0..<l. - \\<mu> i l * (\\<kappa>\\<^sub>l j * fs ! j $ k)) =\n  (\\<Sum>x = 0..<l.\n      (\\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l) * fs ! x $ k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "have \"\\<dots> = (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<l.\n        (\\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l) *\n        fs ! x $ k) =\n    (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k)", "unfolding \\<kappa>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<l.\n        (\\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l) *\n        fs ! x $ k) =\n    (\\<Sum>x = 0..<l.\n        (if x < l then \\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l\n         else - \\<mu> i l) *\n        fs ! x $ k)", "by (rule sum.cong) (auto)"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      (\\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l) * fs ! x $ k) =\n  (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l.\n      (\\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l) * fs ! x $ k) =\n  (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "have \"(\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k) - \\<mu> i l * fs ! l $ k =\n                 (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k) + (\\<Sum>x = l..<Suc l. \\<kappa> x * fs ! x $ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k) - \\<mu> i l * fs ! l $ k =\n    (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k) +\n    (\\<Sum>x = l..<Suc l. \\<kappa> x * fs ! x $ k)", "unfolding \\<kappa>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<l.\n        (if x < l then \\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l\n         else - \\<mu> i l) *\n        fs ! x $ k) -\n    \\<mu> i l * fs ! l $ k =\n    (\\<Sum>x = 0..<l.\n        (if x < l then \\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l\n         else - \\<mu> i l) *\n        fs ! x $ k) +\n    (\\<Sum>x = l..<Suc l.\n        (if x < l then \\<kappa>\\<^sub>i x - \\<kappa>\\<^sub>l x * \\<mu> i l\n         else - \\<mu> i l) *\n        fs ! x $ k)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k) - \\<mu> i l * fs ! l $ k =\n  (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k) +\n  (\\<Sum>x = l..<Suc l. \\<kappa> x * fs ! x $ k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k) - \\<mu> i l * fs ! l $ k =\n  (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k) +\n  (\\<Sum>x = l..<Suc l. \\<kappa> x * fs ! x $ k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "have \"\\<dots> = (\\<Sum>x = 0..<Suc l. \\<kappa> x * fs ! x $ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k) +\n    (\\<Sum>x = l..<Suc l. \\<kappa> x * fs ! x $ k) =\n    (\\<Sum>x = 0..<Suc l. \\<kappa> x * fs ! x $ k)", "by (subst sum.union_disjoint[symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k) +\n  (\\<Sum>x = l..<Suc l. \\<kappa> x * fs ! x $ k) =\n  (\\<Sum>x = 0..<Suc l. \\<kappa> x * fs ! x $ k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<l. \\<kappa> x * fs ! x $ k) +\n  (\\<Sum>x = l..<Suc l. \\<kappa> x * fs ! x $ k) =\n  (\\<Sum>x = 0..<Suc l. \\<kappa> x * fs ! x $ k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "have \"\\<dots> = (\\<Sum>x = 0..<Suc l. (\\<kappa> x \\<cdot>\\<^sub>v fs ! x) $ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<Suc l. \\<kappa> x * fs ! x $ k) =\n    (\\<Sum>x = 0..<Suc l. (\\<kappa> x \\<cdot>\\<^sub>v fs ! x) $ k)", "using that Suc"], ["proof (prove)\nusing this:\n  k < n\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i1 j \\<cdot>\\<^sub>v gso j)\n                          [0..<l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<l])\n  i < length fs\n  Suc l \\<le> i\n\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<Suc l. \\<kappa> x * fs ! x $ k) =\n    (\\<Sum>x = 0..<Suc l. (\\<kappa> x \\<cdot>\\<^sub>v fs ! x) $ k)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<Suc l. \\<kappa> x * fs ! x $ k) =\n  (\\<Sum>x = 0..<Suc l. (\\<kappa> x \\<cdot>\\<^sub>v fs ! x) $ k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<Suc l. \\<kappa> x * fs ! x $ k) =\n  (\\<Sum>x = 0..<Suc l. (\\<kappa> x \\<cdot>\\<^sub>v fs ! x) $ k)\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "have \"\\<dots> = M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<Suc l. (\\<kappa> x \\<cdot>\\<^sub>v fs ! x) $ k) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "by (subst sumlist_nth, insert that Suc, auto simp: nth_append)"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<Suc l. (\\<kappa> x \\<cdot>\\<^sub>v fs ! x) $ k) =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n  k\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "finally"], ["proof (chain)\npicking this:\n  (M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v\n   (fs ! l +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]))) $\n  k =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n  k", "show ?thesis"], ["proof (prove)\nusing this:\n  (M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v\n   (fs ! l +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]))) $\n  k =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n  k\n\ngoal (1 subgoal):\n 1. (M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l]) +\n     - \\<mu> i l \\<cdot>\\<^sub>v\n     (fs ! l +\n      M.sumlist\n       (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n         [0..<l]))) $\n    k =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n    k", "by simp"], ["proof (state)\nthis:\n  (M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v\n   (fs ! l +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]))) $\n  k =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n  k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k1 < n \\<Longrightarrow>\n  (M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v\n   (fs ! l +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]))) $\n  ?k1 =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n  ?k1\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n    - \\<mu> i l \\<cdot>\\<^sub>v\n    (fs ! l +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])", "then"], ["proof (chain)\npicking this:\n  ?k1 < n \\<Longrightarrow>\n  (M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v\n   (fs ! l +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]))) $\n  ?k1 =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n  ?k1", "show ?thesis"], ["proof (prove)\nusing this:\n  ?k1 < n \\<Longrightarrow>\n  (M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v\n   (fs ! l +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]))) $\n  ?k1 =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n  ?k1\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n    - \\<mu> i l \\<cdot>\\<^sub>v\n    (fs ! l +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])", "using Suc"], ["proof (prove)\nusing this:\n  ?k1 < n \\<Longrightarrow>\n  (M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n   - \\<mu> i l \\<cdot>\\<^sub>v\n   (fs ! l +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]))) $\n  ?k1 =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l]) $\n  ?k1\n  \\<lbrakk>?i1 < length fs; l \\<le> ?i1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i1 j \\<cdot>\\<^sub>v gso j)\n                          [0..<l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<l])\n  i < length fs\n  Suc l \\<le> i\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n    - \\<mu> i l \\<cdot>\\<^sub>v\n    (fs ! l +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])", "by (auto simp add: dim_sumlist)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n  - \\<mu> i l \\<cdot>\\<^sub>v\n  (fs ! l +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l])) =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa>\\<^sub>i j \\<cdot>\\<^sub>v fs ! j) [0..<l]) +\n  - \\<mu> i l \\<cdot>\\<^sub>v\n  (fs ! l +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa>\\<^sub>l j \\<cdot>\\<^sub>v fs ! j) [0..<l])) =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])\n 2. \\<And>l i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length fs; l \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>\\<kappa>.\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]);\n        i < length fs; Suc l \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<Suc l]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<Suc l])", "finally"], ["proof (chain)\npicking this:\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]) =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])", "show ?case"], ["proof (prove)\nusing this:\n  M.sumlist\n   (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]) =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])\n\ngoal (1 subgoal):\n 1. \\<exists>\\<kappa>.\n       M.sumlist\n        (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]) =\n       M.sumlist\n        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])", "by (intro exI[of _ \\<kappa>]) simp"], ["proof (state)\nthis:\n  \\<exists>\\<kappa>.\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc l]) =\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<Suc l])\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length fs; 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<kappa>.\n                            M.sumlist\n                             (map (\\<lambda>j.\n- \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                               [0..<0]) =\n                            M.sumlist\n                             (map (\\<lambda>j.\n\\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                               [0..<0])", "qed auto"], ["", "definition \\<kappa>_SOME_def:\n  \"\\<kappa> = (SOME \\<kappa>. \\<forall>i l. i < length fs \\<longrightarrow> l \\<le> i \\<longrightarrow>\n        sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n        sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]))\""], ["", "lemma \\<kappa>_def:\n  assumes \"i < length fs\" \"l \\<le> i\"\n  shows \"sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n         sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "let ?P = \"\\<lambda> i l \\<kappa>. (i < length fs \\<longrightarrow> l \\<le> i \\<longrightarrow>\n                  sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n                  sumlist (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l]))\""], ["proof (state)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "from ex_\\<kappa>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i j \\<cdot>\\<^sub>v gso j)\n                          [0..<?l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<?l])", "have \"\\<And> i. \\<forall> l. \\<exists>\\<kappa>. ?P i l \\<kappa>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<kappa>.\n                       M.sumlist\n                        (map (\\<lambda>j.\n                                 - \\<mu> ?i j \\<cdot>\\<^sub>v gso j)\n                          [0..<?l]) =\n                       M.sumlist\n                        (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j)\n                          [0..<?l])\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<forall>l.\n          \\<exists>\\<kappa>.\n             i < length fs \\<longrightarrow>\n             l \\<le> i \\<longrightarrow>\n             M.sumlist\n              (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                [0..<l]) =\n             M.sumlist\n              (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "by blast"], ["proof (state)\nthis:\n  \\<forall>l.\n     \\<exists>\\<kappa>.\n        ?i1 < length fs \\<longrightarrow>\n        l \\<le> ?i1 \\<longrightarrow>\n        M.sumlist\n         (map (\\<lambda>j. - \\<mu> ?i1 j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n        M.sumlist\n         (map (\\<lambda>j. \\<kappa> j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x.\n        ?i2 < length fs \\<longrightarrow>\n        x \\<le> ?i2 \\<longrightarrow>\n        M.sumlist\n         (map (\\<lambda>j. - \\<mu> ?i2 j \\<cdot>\\<^sub>v gso j) [0..<x]) =\n        M.sumlist (map (\\<lambda>j. f x j \\<cdot>\\<^sub>v fs ! j) [0..<x])", "have \"\\<forall>i. \\<exists>\\<kappa>. \\<forall> l. ?P i l (\\<kappa> l)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x.\n        ?i2 < length fs \\<longrightarrow>\n        x \\<le> ?i2 \\<longrightarrow>\n        M.sumlist\n         (map (\\<lambda>j. - \\<mu> ?i2 j \\<cdot>\\<^sub>v gso j) [0..<x]) =\n        M.sumlist (map (\\<lambda>j. f x j \\<cdot>\\<^sub>v fs ! j) [0..<x])\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>\\<kappa>.\n          \\<forall>l.\n             i < length fs \\<longrightarrow>\n             l \\<le> i \\<longrightarrow>\n             M.sumlist\n              (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                [0..<l]) =\n             M.sumlist\n              (map (\\<lambda>j. \\<kappa> l j \\<cdot>\\<^sub>v fs ! j)\n                [0..<l])", "by blast"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<exists>\\<kappa>.\n        \\<forall>l.\n           i < length fs \\<longrightarrow>\n           l \\<le> i \\<longrightarrow>\n           M.sumlist\n            (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n           M.sumlist\n            (map (\\<lambda>j. \\<kappa> l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x l.\n        x < length fs \\<longrightarrow>\n        l \\<le> x \\<longrightarrow>\n        M.sumlist\n         (map (\\<lambda>j. - \\<mu> x j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n        M.sumlist (map (\\<lambda>j. f x l j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "have \"\\<exists>\\<kappa>. \\<forall>i l. ?P i l (\\<kappa> i l)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x l.\n        x < length fs \\<longrightarrow>\n        l \\<le> x \\<longrightarrow>\n        M.sumlist\n         (map (\\<lambda>j. - \\<mu> x j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n        M.sumlist (map (\\<lambda>j. f x l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n\ngoal (1 subgoal):\n 1. \\<exists>\\<kappa>.\n       \\<forall>i l.\n          i < length fs \\<longrightarrow>\n          l \\<le> i \\<longrightarrow>\n          M.sumlist\n           (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n          M.sumlist\n           (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<kappa>.\n     \\<forall>i l.\n        i < length fs \\<longrightarrow>\n        l \\<le> i \\<longrightarrow>\n        M.sumlist\n         (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n        M.sumlist\n         (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "from someI_ex[OF this]"], ["proof (chain)\npicking this:\n  \\<forall>i l.\n     i < length fs \\<longrightarrow>\n     l \\<le> i \\<longrightarrow>\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n     M.sumlist\n      (map (\\<lambda>j.\n               (SOME x.\n                   \\<forall>i l.\n                      i < length fs \\<longrightarrow>\n                      l \\<le> i \\<longrightarrow>\n                      M.sumlist\n                       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<l]) =\n                      M.sumlist\n                       (map (\\<lambda>j. x i l j \\<cdot>\\<^sub>v fs ! j)\n                         [0..<l]))\n                i l j \\<cdot>\\<^sub>v\n               fs ! j)\n        [0..<l])", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i l.\n     i < length fs \\<longrightarrow>\n     l \\<le> i \\<longrightarrow>\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n     M.sumlist\n      (map (\\<lambda>j.\n               (SOME x.\n                   \\<forall>i l.\n                      i < length fs \\<longrightarrow>\n                      l \\<le> i \\<longrightarrow>\n                      M.sumlist\n                       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<l]) =\n                      M.sumlist\n                       (map (\\<lambda>j. x i l j \\<cdot>\\<^sub>v fs ! j)\n                         [0..<l]))\n                i l j \\<cdot>\\<^sub>v\n               fs ! j)\n        [0..<l])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])", "unfolding \\<kappa>_SOME_def"], ["proof (prove)\nusing this:\n  \\<forall>i l.\n     i < length fs \\<longrightarrow>\n     l \\<le> i \\<longrightarrow>\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n     M.sumlist\n      (map (\\<lambda>j.\n               (SOME x.\n                   \\<forall>i l.\n                      i < length fs \\<longrightarrow>\n                      l \\<le> i \\<longrightarrow>\n                      M.sumlist\n                       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<l]) =\n                      M.sumlist\n                       (map (\\<lambda>j. x i l j \\<cdot>\\<^sub>v fs ! j)\n                         [0..<l]))\n                i l j \\<cdot>\\<^sub>v\n               fs ! j)\n        [0..<l])\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j.\n              (SOME \\<kappa>.\n                  \\<forall>i l.\n                     i < length fs \\<longrightarrow>\n                     l \\<le> i \\<longrightarrow>\n                     M.sumlist\n                      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                        [0..<l]) =\n                     M.sumlist\n                      (map (\\<lambda>j.\n                               \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n                        [0..<l]))\n               i l j \\<cdot>\\<^sub>v\n              fs ! j)\n       [0..<l])", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i l.\n     i < length fs \\<longrightarrow>\n     l \\<le> i \\<longrightarrow>\n     M.sumlist\n      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n     M.sumlist\n      (map (\\<lambda>j.\n               (SOME x.\n                   \\<forall>i l.\n                      i < length fs \\<longrightarrow>\n                      l \\<le> i \\<longrightarrow>\n                      M.sumlist\n                       (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                         [0..<l]) =\n                      M.sumlist\n                       (map (\\<lambda>j. x i l j \\<cdot>\\<^sub>v fs ! j)\n                         [0..<l]))\n                i l j \\<cdot>\\<^sub>v\n               fs ! j)\n        [0..<l])\n  i < length fs\n  l \\<le> i\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j.\n              (SOME \\<kappa>.\n                  \\<forall>i l.\n                     i < length fs \\<longrightarrow>\n                     l \\<le> i \\<longrightarrow>\n                     M.sumlist\n                      (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j)\n                        [0..<l]) =\n                     M.sumlist\n                      (map (\\<lambda>j.\n                               \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n                        [0..<l]))\n               i l j \\<cdot>\\<^sub>v\n              fs ! j)\n       [0..<l])", "by blast"], ["proof (state)\nthis:\n  M.sumlist (map (\\<lambda>j. - \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in gram_schmidt_fs_lin_indpt) fs_i_sumlist_\\<kappa>:\n  assumes \"i < m\" \"l \\<le> i\" \"j < l\"\n  shows \"(fs ! i + sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])) \\<bullet> fs ! j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "have \"fs ! i + sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n        = fs ! i - M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n    fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])", "using assms gso_carrier assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n    fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])", "by (subst \\<kappa>_def[symmetric]) (auto simp add: dim_sumlist sumlist_nth sum_negf)"], ["proof (state)\nthis:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  fs ! i -\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  fs ! i -\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l])\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "have \"\\<dots> = M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "have \"fs ! i = M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. fs ! i =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])", "by (intro fi_is_sum_of_mu_gso) auto"], ["proof (state)\nthis:\n  fs ! i =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])\n\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "also"], ["proof (state)\nthis:\n  fs ! i =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i])\n\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "have \"\\<dots> = M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n                  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "have *: \"[0..<Suc i] = [0..<l] @ [l..<Suc i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc i] = [0..<l] @ [l..<Suc i]", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. [0..<Suc i] = [0..<l] @ [l..<Suc i]", "by (metis diff_zero le_imp_less_Suc length_upt list_trisect upt_conv_Cons)"], ["proof (state)\nthis:\n  [0..<Suc i] = [0..<l] @ [l..<Suc i]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "by (subst *, subst map_append, subst sumlist_append) (use gso_carrier assms in auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<Suc i]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "finally"], ["proof (chain)\npicking this:\n  fs ! i =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "show ?thesis"], ["proof (prove)\nusing this:\n  fs ! i =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "using assms gso_carrier assms"], ["proof (prove)\nusing this:\n  fs ! i =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) +\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n  i < length fs\n  l \\<le> i\n  j < l\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. fs ! i -\n    M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "by (auto simp add: algebra_simps dim_sumlist)"], ["proof (state)\nthis:\n  fs ! i -\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fs ! i -\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "have \"fs ! i + M.sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n                M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\""], ["proof (prove)\nusing this:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. fs ! i +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n    M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])", "by simp"], ["proof (state)\nthis:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "moreover"], ["proof (state)\nthis:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "have \"\\<dots> \\<bullet> (fs ! j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n       [l..<Suc i]) \\<bullet>\n    fs ! j =\n    (0::'a)", "using assms gso_carrier assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n       [l..<Suc i]) \\<bullet>\n    fs ! j =\n    (0::'a)", "unfolding lin_indpt_list_def"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n  ?i < length fs \\<Longrightarrow> gso ?i \\<in> carrier_vec n\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j)\n       [l..<Suc i]) \\<bullet>\n    fs ! j =\n    (0::'a)", "by (subst scalar_prod_left_sum_distrib)\n       (auto simp add: algebra_simps dim_sumlist gso_scalar_zero intro!: sum_list_zero)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i]) \\<bullet>\n  fs ! j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i]) \\<bullet>\n  fs ! j =\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i]) \\<bullet>\n  fs ! j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  fs ! i +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) =\n  M.sumlist (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i])\n  M.sumlist\n   (map (\\<lambda>j. \\<mu> i j \\<cdot>\\<^sub>v gso j) [l..<Suc i]) \\<bullet>\n  fs ! j =\n  (0::'a)\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n      [0..<l])) \\<bullet>\n  fs ! j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* gram_schmidt_fs_Rn *)"], ["", "lemma Ints_sum:\n  assumes \"\\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> \\<int>\"\n  shows \"sum f A \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f A \\<in> \\<int>", "using assms"], ["proof (prove)\nusing this:\n  ?a \\<in> A \\<Longrightarrow> f ?a \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. sum f A \\<in> \\<int>", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma Ints_prod:\n  assumes \"\\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> \\<int>\"\n  shows \"prod f A \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f A \\<in> \\<int>", "using assms"], ["proof (prove)\nusing this:\n  ?a \\<in> A \\<Longrightarrow> f ?a \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. prod f A \\<in> \\<int>", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma Ints_scalar_prod: \n  \"v \\<in> carrier_vec n \\<Longrightarrow> w \\<in> carrier_vec n\n   \\<Longrightarrow> (\\<And> i. i < n \\<Longrightarrow> v $ i \\<in> \\<int>) \\<Longrightarrow> (\\<And> i. i < n \\<Longrightarrow> w $ i \\<in> \\<int>) \\<Longrightarrow> v \\<bullet> w \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> carrier_vec n; w \\<in> carrier_vec n;\n     \\<And>i. i < n \\<Longrightarrow> v $ i \\<in> \\<int>;\n     \\<And>i. i < n \\<Longrightarrow> w $ i \\<in> \\<int>\\<rbrakk>\n    \\<Longrightarrow> v \\<bullet> w \\<in> \\<int>", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> carrier_vec n; w \\<in> carrier_vec n;\n     \\<And>i. i < n \\<Longrightarrow> v $ i \\<in> \\<int>;\n     \\<And>i. i < n \\<Longrightarrow> w $ i \\<in> \\<int>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<dim_vec w. v $ i * w $ i) \\<in> \\<int>", "by (intro Ints_sum Ints_mult, auto)"], ["", "lemma Ints_det: assumes \"\\<And> i j. i < dim_row A \\<Longrightarrow> j < dim_col A \n  \\<Longrightarrow> A $$ (i,j) \\<in> \\<int>\"\n  shows \"det A \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A \\<in> \\<int>", "proof (cases \"dim_row A = dim_col A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_row A = dim_col A \\<Longrightarrow> det A \\<in> \\<int>\n 2. dim_row A \\<noteq> dim_col A \\<Longrightarrow> det A \\<in> \\<int>", "case True"], ["proof (state)\nthis:\n  dim_row A = dim_col A\n\ngoal (2 subgoals):\n 1. dim_row A = dim_col A \\<Longrightarrow> det A \\<in> \\<int>\n 2. dim_row A \\<noteq> dim_col A \\<Longrightarrow> det A \\<in> \\<int>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A \\<in> \\<int>", "unfolding Determinant.det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row A = dim_col A\n     then \\<Sum>p | p permutes {0..<dim_row A}.\n            signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n     else (0::'a))\n    \\<in> \\<int>", "using True assms"], ["proof (prove)\nusing this:\n  dim_row A = dim_col A\n  \\<lbrakk>?i < dim_row A; ?j < dim_col A\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (if dim_row A = dim_col A\n     then \\<Sum>p | p permutes {0..<dim_row A}.\n            signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n     else (0::'a))\n    \\<in> \\<int>", "by (auto intro!: Ints_sum Ints_mult Ints_prod simp: signof_def)"], ["proof (state)\nthis:\n  det A \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. dim_row A \\<noteq> dim_col A \\<Longrightarrow> det A \\<in> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dim_row A \\<noteq> dim_col A \\<Longrightarrow> det A \\<in> \\<int>", "case False"], ["proof (state)\nthis:\n  dim_row A \\<noteq> dim_col A\n\ngoal (1 subgoal):\n 1. dim_row A \\<noteq> dim_col A \\<Longrightarrow> det A \\<in> \\<int>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A \\<in> \\<int>", "unfolding Determinant.det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row A = dim_col A\n     then \\<Sum>p | p permutes {0..<dim_row A}.\n            signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n     else (0::'a))\n    \\<in> \\<int>", "using False"], ["proof (prove)\nusing this:\n  dim_row A \\<noteq> dim_col A\n\ngoal (1 subgoal):\n 1. (if dim_row A = dim_col A\n     then \\<Sum>p | p permutes {0..<dim_row A}.\n            signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n     else (0::'a))\n    \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  det A \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in gram_schmidt_fs_Rn) Gramian_matrix_alt_alt_def:\n  assumes \"k \\<le> m\"\n  shows \"Gramian_matrix fs k = mat k k (\\<lambda>(i,j). fs ! i \\<bullet> fs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_matrix fs k = mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gramian_matrix fs k = mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "have *: \"vec n (($) (fs ! i)) = fs ! i\" if \"i < m\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (($) (fs ! i)) = fs ! i", "using that"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. vec n (($) (fs ! i)) = fs ! i", "by auto"], ["proof (state)\nthis:\n  ?i1 < length fs \\<Longrightarrow> vec n (($) (fs ! ?i1)) = fs ! ?i1\n\ngoal (1 subgoal):\n 1. Gramian_matrix fs k = mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "then"], ["proof (chain)\npicking this:\n  ?i1 < length fs \\<Longrightarrow> vec n (($) (fs ! ?i1)) = fs ! ?i1", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i1 < length fs \\<Longrightarrow> vec n (($) (fs ! ?i1)) = fs ! ?i1\n\ngoal (1 subgoal):\n 1. Gramian_matrix fs k = mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "unfolding Gramian_matrix_def"], ["proof (prove)\nusing this:\n  ?i1 < length fs \\<Longrightarrow> vec n (($) (fs ! ?i1)) = fs ! ?i1\n\ngoal (1 subgoal):\n 1. (let M = mat k n (\\<lambda>(i, y). fs ! i $ y) in M * M\\<^sup>T) =\n    mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "using assms"], ["proof (prove)\nusing this:\n  ?i1 < length fs \\<Longrightarrow> vec n (($) (fs ! ?i1)) = fs ! ?i1\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. (let M = mat k n (\\<lambda>(i, y). fs ! i $ y) in M * M\\<^sup>T) =\n    mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)", "by (intro eq_matI) (auto simp add: Let_def)"], ["proof (state)\nthis:\n  Gramian_matrix fs k = mat k k (\\<lambda>(i, j). fs ! i \\<bullet> fs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in gram_schmidt_fs_int) fs_scalar_Ints:\n  assumes \"i < m\" \"j < m\"\n  shows \"fs ! i \\<bullet> fs ! j \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<bullet> fs ! j \\<in> \\<int>", "by (rule Ints_scalar_prod[of _ n], insert fs_int assms, auto)"], ["", "abbreviation (in gram_schmidt_fs_lin_indpt) d where \"d \\<equiv> Gramian_determinant fs\""], ["", "lemma (in gram_schmidt_fs_lin_indpt) fs_i_fs_j_sum_\\<kappa> :\n  assumes \"i < m\" \"l \\<le> i\" \"j < l\"\n  shows \"- (fs ! i \\<bullet> fs ! j) = (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "have [simp]: \"M.sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n    \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n    \\<in> carrier_vec n", "by (auto intro!: sumlist_carrier simp add: dim_sumlist)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "have \"0  = (fs ! i + M.sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l])) \\<bullet> fs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) =\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j", "using fs_i_sumlist_\\<kappa> assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i; ?j < ?l\\<rbrakk>\n  \\<Longrightarrow> (fs ! ?i +\n                     M.sumlist\n                      (map (\\<lambda>j.\n                               \\<kappa> ?i ?l j \\<cdot>\\<^sub>v fs ! j)\n                        [0..<?l])) \\<bullet>\n                    fs ! ?j =\n                    (0::'a)\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j", "by simp"], ["proof (state)\nthis:\n  (0::'a) =\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n      [0..<l])) \\<bullet>\n  fs ! j\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "also"], ["proof (state)\nthis:\n  (0::'a) =\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n      [0..<l])) \\<bullet>\n  fs ! j\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "have \"\\<dots> = fs ! i \\<bullet> fs ! j + M.sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) \\<bullet> fs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    fs ! i \\<bullet> fs ! j +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]) \\<bullet>\n    fs ! j", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. (fs ! i +\n     M.sumlist\n      (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n        [0..<l])) \\<bullet>\n    fs ! j =\n    fs ! i \\<bullet> fs ! j +\n    M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]) \\<bullet>\n    fs ! j", "by (subst add_scalar_prod_distrib[of _ n]) (auto)"], ["proof (state)\nthis:\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n      [0..<l])) \\<bullet>\n  fs ! j =\n  fs ! i \\<bullet> fs ! j +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n     [0..<l]) \\<bullet>\n  fs ! j\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "also"], ["proof (state)\nthis:\n  (fs ! i +\n   M.sumlist\n    (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n      [0..<l])) \\<bullet>\n  fs ! j =\n  fs ! i \\<bullet> fs ! j +\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n     [0..<l]) \\<bullet>\n  fs ! j\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "have \"M.sumlist (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]) \\<bullet> fs ! j =\n             (\\<Sum>v\\<leftarrow>map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j) [0..<l]. v \\<bullet> fs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]) \\<bullet>\n    fs ! j =\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j.\n                                \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n                         [0..<l]. v \\<bullet> fs ! j)", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n       [0..<l]) \\<bullet>\n    fs ! j =\n    (\\<Sum>v\\<leftarrow>map (\\<lambda>j.\n                                \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n                         [0..<l]. v \\<bullet> fs ! j)", "by (intro scalar_prod_left_sum_distrib) (auto)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n     [0..<l]) \\<bullet>\n  fs ! j =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j.\n                              \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n                       [0..<l]. v \\<bullet> fs ! j)\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>j. \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n     [0..<l]) \\<bullet>\n  fs ! j =\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j.\n                              \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n                       [0..<l]. v \\<bullet> fs ! j)\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "have \"\\<dots> = (\\<Sum>t\\<leftarrow>[0..<l]. (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet> fs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<leftarrow>map (\\<lambda>j.\n                                \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n                         [0..<l]. v \\<bullet> fs ! j) =\n    (\\<Sum>t\\<leftarrow>[0..<\n                         l]. (\\<kappa> i l t \\<cdot>\\<^sub>v\n                              fs ! t) \\<bullet>\n                             fs ! j)", "by (rule arg_cong[where f=sum_list]) (auto)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j.\n                              \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n                       [0..<l]. v \\<bullet> fs ! j) =\n  (\\<Sum>t\\<leftarrow>[0..<\n                       l]. (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet>\n                           fs ! j)\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<leftarrow>map (\\<lambda>j.\n                              \\<kappa> i l j \\<cdot>\\<^sub>v fs ! j)\n                       [0..<l]. v \\<bullet> fs ! j) =\n  (\\<Sum>t\\<leftarrow>[0..<\n                       l]. (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet>\n                           fs ! j)\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "have \"\\<dots> =  (\\<Sum>t = 0..<l. (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet> fs ! j) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<leftarrow>[0..<\n                         l]. (\\<kappa> i l t \\<cdot>\\<^sub>v\n                              fs ! t) \\<bullet>\n                             fs ! j) =\n    (\\<Sum>t = 0..<l.\n        (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet> fs ! j)", "by (subst interv_sum_list_conv_sum_set_nat) (auto)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<leftarrow>[0..<\n                       l]. (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet>\n                           fs ! j) =\n  (\\<Sum>t = 0..<l.\n      (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet> fs ! j)\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<leftarrow>[0..<\n                       l]. (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet>\n                           fs ! j) =\n  (\\<Sum>t = 0..<l.\n      (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet> fs ! j)\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "have \"\\<dots> = (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t = 0..<l.\n        (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. (\\<Sum>t = 0..<l.\n        (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>t = 0..<l.\n      (\\<kappa> i l t \\<cdot>\\<^sub>v fs ! t) \\<bullet> fs ! j) =\n  (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "finally"], ["proof (chain)\npicking this:\n  (0::'a) =\n  fs ! i \\<bullet> fs ! j +\n  (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) =\n  fs ! i \\<bullet> fs ! j +\n  (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  - (fs ! i \\<bullet> fs ! j) =\n  (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in gram_schmidt_fs_lin_indpt) Gramian_matrix_times_\\<kappa> :\n  assumes \"i < m\" \"l \\<le> i\"\n  shows \"Gramian_matrix fs l *\\<^sub>v (vec l (\\<lambda>t. \\<kappa> i l t)) = (vec l (\\<lambda>j. - (fs ! i \\<bullet> fs ! j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l) =\n    vec l (\\<lambda>j. - (fs ! i \\<bullet> fs ! j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l) =\n    vec l (\\<lambda>j. - (fs ! i \\<bullet> fs ! j))", "have \"- (fs ! i \\<bullet> fs ! j) = (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)\" if \"j < l\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "using fs_i_fs_j_sum_\\<kappa> assms that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i; ?j < ?l\\<rbrakk>\n  \\<Longrightarrow> - (fs ! ?i \\<bullet> fs ! ?j) =\n                    (\\<Sum>t = 0..<?l.\n                        fs ! t \\<bullet> fs ! ?j * \\<kappa> ?i ?l t)\n  i < length fs\n  l \\<le> i\n  j < l\n\ngoal (1 subgoal):\n 1. - (fs ! i \\<bullet> fs ! j) =\n    (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! j * \\<kappa> i l t)", "by simp"], ["proof (state)\nthis:\n  ?j1 < l \\<Longrightarrow>\n  - (fs ! i \\<bullet> fs ! ?j1) =\n  (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! ?j1 * \\<kappa> i l t)\n\ngoal (1 subgoal):\n 1. Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l) =\n    vec l (\\<lambda>j. - (fs ! i \\<bullet> fs ! j))", "then"], ["proof (chain)\npicking this:\n  ?j1 < l \\<Longrightarrow>\n  - (fs ! i \\<bullet> fs ! ?j1) =\n  (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! ?j1 * \\<kappa> i l t)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?j1 < l \\<Longrightarrow>\n  - (fs ! i \\<bullet> fs ! ?j1) =\n  (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! ?j1 * \\<kappa> i l t)\n\ngoal (1 subgoal):\n 1. Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l) =\n    vec l (\\<lambda>j. - (fs ! i \\<bullet> fs ! j))", "using assms"], ["proof (prove)\nusing this:\n  ?j1 < l \\<Longrightarrow>\n  - (fs ! i \\<bullet> fs ! ?j1) =\n  (\\<Sum>t = 0..<l. fs ! t \\<bullet> fs ! ?j1 * \\<kappa> i l t)\n  i < length fs\n  l \\<le> i\n\ngoal (1 subgoal):\n 1. Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l) =\n    vec l (\\<lambda>j. - (fs ! i \\<bullet> fs ! j))", "by (subst Gramian_matrix_alt_alt_def) (auto simp add: scalar_prod_def algebra_simps)"], ["proof (state)\nthis:\n  Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l) =\n  vec l (\\<lambda>j. - (fs ! i \\<bullet> fs ! j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in gram_schmidt_fs_int) d_\\<kappa>_Ints :\n  assumes \"i < m\" \"l \\<le> i\" \"t < l\"\n  shows \"d l * \\<kappa> i l t \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d l * \\<kappa> i l t \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d l * \\<kappa> i l t \\<in> \\<int>", "let ?A = \"Gramian_matrix fs l\""], ["proof (state)\ngoal (1 subgoal):\n 1. d l * \\<kappa> i l t \\<in> \\<int>", "let ?B = \"replace_col ?A (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t\""], ["proof (state)\ngoal (1 subgoal):\n 1. d l * \\<kappa> i l t \\<in> \\<int>", "have deteq: \"d l = det ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d l = det (Gramian_matrix fs l)", "unfolding Gramian_determinant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Gramian_matrix fs l) = det (Gramian_matrix fs l)", "using Gramian_determinant_Ints"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k \\<le> length fs;\n   \\<And>i j.\n      \\<lbrakk>i < n; j < length fs\\<rbrakk>\n      \\<Longrightarrow> fs ! j $ i \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> d ?k \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. det (Gramian_matrix fs l) = det (Gramian_matrix fs l)", "by auto"], ["proof (state)\nthis:\n  d l = det (Gramian_matrix fs l)\n\ngoal (1 subgoal):\n 1. d l * \\<kappa> i l t \\<in> \\<int>", "have **: \"Gramian_matrix fs l \\<in> carrier_mat l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gramian_matrix fs l \\<in> carrier_mat l l", "unfolding Gramian_matrix_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat l n (\\<lambda>(i, y). fs ! i $ y) *\n    (mat l n (\\<lambda>(i, y). fs ! i $ y))\\<^sup>T\n    \\<in> carrier_mat l l", "using fs_carrier"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat l n (\\<lambda>(i, y). fs ! i $ y) *\n    (mat l n (\\<lambda>(i, y). fs ! i $ y))\\<^sup>T\n    \\<in> carrier_mat l l", "by auto"], ["proof (state)\nthis:\n  Gramian_matrix fs l \\<in> carrier_mat l l\n\ngoal (1 subgoal):\n 1. d l * \\<kappa> i l t \\<in> \\<int>", "then"], ["proof (chain)\npicking this:\n  Gramian_matrix fs l \\<in> carrier_mat l l", "have \" \\<kappa> i l t * det ?A = det ?B\""], ["proof (prove)\nusing this:\n  Gramian_matrix fs l \\<in> carrier_mat l l\n\ngoal (1 subgoal):\n 1. \\<kappa> i l t * det (Gramian_matrix fs l) =\n    det (replace_col (Gramian_matrix fs l)\n          (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)", "using assms fs_carrier cramer_lemma_mat[of ?A l \" (vec l (\\<lambda>t. \\<kappa> i l t))\" t]"], ["proof (prove)\nusing this:\n  Gramian_matrix fs l \\<in> carrier_mat l l\n  i < length fs\n  l \\<le> i\n  t < l\n  set fs \\<subseteq> carrier_vec n\n  \\<lbrakk>Gramian_matrix fs l \\<in> carrier_mat l l;\n   vec l (\\<kappa> i l) \\<in> carrier_vec l; t < l\\<rbrakk>\n  \\<Longrightarrow> det (replace_col (Gramian_matrix fs l)\n                          (Gramian_matrix fs l *\\<^sub>v\n                           vec l (\\<kappa> i l))\n                          t) =\n                    vec l (\\<kappa> i l) $ t * det (Gramian_matrix fs l)\n\ngoal (1 subgoal):\n 1. \\<kappa> i l t * det (Gramian_matrix fs l) =\n    det (replace_col (Gramian_matrix fs l)\n          (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)", "by auto"], ["proof (state)\nthis:\n  \\<kappa> i l t * det (Gramian_matrix fs l) =\n  det (replace_col (Gramian_matrix fs l)\n        (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n\ngoal (1 subgoal):\n 1. d l * \\<kappa> i l t \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  \\<kappa> i l t * det (Gramian_matrix fs l) =\n  det (replace_col (Gramian_matrix fs l)\n        (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n\ngoal (1 subgoal):\n 1. d l * \\<kappa> i l t \\<in> \\<int>", "have \" ... \\<in> \\<int> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (replace_col (Gramian_matrix fs l)\n          (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n    \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (replace_col (Gramian_matrix fs l)\n          (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n    \\<in> \\<int>", "have *: \"t<l \\<Longrightarrow> (?A *\\<^sub>v vec l (\\<kappa> i l)) $ t \\<in> \\<int>\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t < l \\<Longrightarrow>\n    (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) $ t \\<in> \\<int>", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n  l \\<le> i\n  t < l\n\ngoal (1 subgoal):\n 1. t < l \\<Longrightarrow>\n    (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) $ t \\<in> \\<int>", "apply(subst Gramian_matrix_times_\\<kappa>, force, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < l; i < length fs; l \\<le> i; t < l\\<rbrakk>\n    \\<Longrightarrow> vec l (\\<lambda>j. - (fs ! i \\<bullet> fs ! j)) $ t\n                      \\<in> \\<int>", "using fs_int fs_carrier"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < n; ?j < length fs\\<rbrakk>\n  \\<Longrightarrow> fs ! ?j $ ?i \\<in> \\<int>\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t < l; i < length fs; l \\<le> i; t < l\\<rbrakk>\n    \\<Longrightarrow> vec l (\\<lambda>j. - (fs ! i \\<bullet> fs ! j)) $ t\n                      \\<in> \\<int>", "by (auto intro!: fs_scalar_Ints Ints_minus)"], ["proof (state)\nthis:\n  ?t1 < l \\<Longrightarrow>\n  (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) $ ?t1 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. det (replace_col (Gramian_matrix fs l)\n          (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n    \\<in> \\<int>", "define B where \"B = ?B\""], ["proof (state)\nthis:\n  B =\n  replace_col (Gramian_matrix fs l)\n   (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t\n\ngoal (1 subgoal):\n 1. det (replace_col (Gramian_matrix fs l)\n          (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n    \\<in> \\<int>", "have Bint: \"t1<l \\<longrightarrow> s1 < l \\<longrightarrow> B $$ (t1,s1) \\<in> \\<int>\" for t1 s1"], ["proof (prove)\ngoal (1 subgoal):\n 1. t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>", "proof (cases \"s1 = t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s1 = t \\<Longrightarrow>\n    t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>\n 2. s1 \\<noteq> t \\<Longrightarrow>\n    t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>", "case True"], ["proof (state)\nthis:\n  s1 = t\n\ngoal (2 subgoals):\n 1. s1 = t \\<Longrightarrow>\n    t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>\n 2. s1 \\<noteq> t \\<Longrightarrow>\n    t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>", "from * ** this"], ["proof (chain)\npicking this:\n  ?t1 < l \\<Longrightarrow>\n  (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) $ ?t1 \\<in> \\<int>\n  Gramian_matrix fs l \\<in> carrier_mat l l\n  s1 = t", "show ?thesis"], ["proof (prove)\nusing this:\n  ?t1 < l \\<Longrightarrow>\n  (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) $ ?t1 \\<in> \\<int>\n  Gramian_matrix fs l \\<in> carrier_mat l l\n  s1 = t\n\ngoal (1 subgoal):\n 1. t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>", "unfolding replace_col_def B_def"], ["proof (prove)\nusing this:\n  ?t1 < l \\<Longrightarrow>\n  (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) $ ?t1 \\<in> \\<int>\n  Gramian_matrix fs l \\<in> carrier_mat l l\n  s1 = t\n\ngoal (1 subgoal):\n 1. t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow>\n    mat (dim_row (Gramian_matrix fs l)) (dim_col (Gramian_matrix fs l))\n     (\\<lambda>(ia, j).\n         if j = t\n         then (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) $ ia\n         else Gramian_matrix fs l $$ (ia, j)) $$\n    (t1, s1)\n    \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  t1 < l \\<longrightarrow>\n  s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. s1 \\<noteq> t \\<Longrightarrow>\n    t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s1 \\<noteq> t \\<Longrightarrow>\n    t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>", "case False"], ["proof (state)\nthis:\n  s1 \\<noteq> t\n\ngoal (1 subgoal):\n 1. s1 \\<noteq> t \\<Longrightarrow>\n    t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>", "from * ** Gramian_matrix_def this fs_carrier assms"], ["proof (chain)\npicking this:\n  ?t1 < l \\<Longrightarrow>\n  (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) $ ?t1 \\<in> \\<int>\n  Gramian_matrix fs l \\<in> carrier_mat l l\n  Gramian_matrix ?G ?k =\n  (let M = mat ?k n (\\<lambda>(i, j). ?G ! i $ j) in M * M\\<^sup>T)\n  s1 \\<noteq> t\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  l \\<le> i\n  t < l", "show ?thesis"], ["proof (prove)\nusing this:\n  ?t1 < l \\<Longrightarrow>\n  (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) $ ?t1 \\<in> \\<int>\n  Gramian_matrix fs l \\<in> carrier_mat l l\n  Gramian_matrix ?G ?k =\n  (let M = mat ?k n (\\<lambda>(i, j). ?G ! i $ j) in M * M\\<^sup>T)\n  s1 \\<noteq> t\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  l \\<le> i\n  t < l\n\ngoal (1 subgoal):\n 1. t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>", "unfolding replace_col_def B_def"], ["proof (prove)\nusing this:\n  ?t1 < l \\<Longrightarrow>\n  (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) $ ?t1 \\<in> \\<int>\n  Gramian_matrix fs l \\<in> carrier_mat l l\n  Gramian_matrix ?G ?k =\n  (let M = mat ?k n (\\<lambda>(i, j). ?G ! i $ j) in M * M\\<^sup>T)\n  s1 \\<noteq> t\n  set fs \\<subseteq> carrier_vec n\n  i < length fs\n  l \\<le> i\n  t < l\n\ngoal (1 subgoal):\n 1. t1 < l \\<longrightarrow>\n    s1 < l \\<longrightarrow>\n    mat (dim_row (Gramian_matrix fs l)) (dim_col (Gramian_matrix fs l))\n     (\\<lambda>(ia, j).\n         if j = t\n         then (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) $ ia\n         else Gramian_matrix fs l $$ (ia, j)) $$\n    (t1, s1)\n    \\<in> \\<int>", "by (auto simp: Gramian_matrix_def Let_def scalar_prod_def intro!: Ints_sum Ints_mult fs_int)"], ["proof (state)\nthis:\n  t1 < l \\<longrightarrow>\n  s1 < l \\<longrightarrow> B $$ (t1, s1) \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t1.1 < l \\<longrightarrow>\n  ?s1.1 < l \\<longrightarrow> B $$ (?t1.1, ?s1.1) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. det (replace_col (Gramian_matrix fs l)\n          (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n    \\<in> \\<int>", "have B: \"B \\<in> carrier_mat l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat l l", "using ** replace_col_def"], ["proof (prove)\nusing this:\n  Gramian_matrix fs l \\<in> carrier_mat l l\n  replace_col ?A ?b ?k =\n  mat (dim_row ?A) (dim_col ?A)\n   (\\<lambda>(i, j). if j = ?k then ?b $ i else ?A $$ (i, j))\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat l l", "unfolding B_def"], ["proof (prove)\nusing this:\n  Gramian_matrix fs l \\<in> carrier_mat l l\n  replace_col ?A ?b ?k =\n  mat (dim_row ?A) (dim_col ?A)\n   (\\<lambda>(i, j). if j = ?k then ?b $ i else ?A $$ (i, j))\n\ngoal (1 subgoal):\n 1. replace_col (Gramian_matrix fs l)\n     (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t\n    \\<in> carrier_mat l l", "by (auto simp: replace_col_def)"], ["proof (state)\nthis:\n  B \\<in> carrier_mat l l\n\ngoal (1 subgoal):\n 1. det (replace_col (Gramian_matrix fs l)\n          (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n    \\<in> \\<int>", "have \"det B \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det B \\<in> \\<int>", "using B Bint assms  det_col[of B l]"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat l l\n  ?t1.1 < l \\<longrightarrow>\n  ?s1.1 < l \\<longrightarrow> B $$ (?t1.1, ?s1.1) \\<in> \\<int>\n  i < length fs\n  l \\<le> i\n  t < l\n  B \\<in> carrier_mat l l \\<Longrightarrow>\n  det B =\n  (\\<Sum>p | p permutes {0..<l}. signof p * (\\<Prod>j<l. B $$ (p j, j)))\n\ngoal (1 subgoal):\n 1. det B \\<in> \\<int>", "by (auto intro!: Ints_sum Ints_mult Ints_prod simp: signof_def)"], ["proof (state)\nthis:\n  det B \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. det (replace_col (Gramian_matrix fs l)\n          (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n    \\<in> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  det B \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. det (replace_col (Gramian_matrix fs l)\n          (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n    \\<in> \\<int>", "unfolding B_def"], ["proof (prove)\nusing this:\n  det (replace_col (Gramian_matrix fs l)\n        (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. det (replace_col (Gramian_matrix fs l)\n          (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n    \\<in> \\<int>", "."], ["proof (state)\nthis:\n  det (replace_col (Gramian_matrix fs l)\n        (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n  \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (replace_col (Gramian_matrix fs l)\n        (Gramian_matrix fs l *\\<^sub>v vec l (\\<kappa> i l)) t)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. d l * \\<kappa> i l t \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  \\<kappa> i l t * det (Gramian_matrix fs l) \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<kappa> i l t * det (Gramian_matrix fs l) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. d l * \\<kappa> i l t \\<in> \\<int>", "using deteq"], ["proof (prove)\nusing this:\n  \\<kappa> i l t * det (Gramian_matrix fs l) \\<in> \\<int>\n  d l = det (Gramian_matrix fs l)\n\ngoal (1 subgoal):\n 1. d l * \\<kappa> i l t \\<in> \\<int>", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  d l * \\<kappa> i l t \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in gram_schmidt_fs_int) d_gso_Ints:\n  assumes \"i < n\" \"k < m\"\n  shows \"(d k \\<cdot>\\<^sub>v (gso k)) $ i \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>", "note d_\\<kappa>_Ints[intro!]"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i; ?t < ?l\\<rbrakk>\n  \\<Longrightarrow> d ?l * \\<kappa> ?i ?l ?t \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i; ?t < ?l\\<rbrakk>\n  \\<Longrightarrow> d ?l * \\<kappa> ?i ?l ?t \\<in> \\<int>", "have \"(d k * \\<kappa> k k j) * fs ! j $ i \\<in> \\<int>\" if \"j < k\" for j"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i; ?t < ?l\\<rbrakk>\n  \\<Longrightarrow> d ?l * \\<kappa> ?i ?l ?t \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. d k * \\<kappa> k k j * fs ! j $ i \\<in> \\<int>", "using that fs_int assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length fs; ?l \\<le> ?i; ?t < ?l\\<rbrakk>\n  \\<Longrightarrow> d ?l * \\<kappa> ?i ?l ?t \\<in> \\<int>\n  j < k\n  \\<lbrakk>?i < n; ?j < length fs\\<rbrakk>\n  \\<Longrightarrow> fs ! ?j $ ?i \\<in> \\<int>\n  i < n\n  k < length fs\n\ngoal (1 subgoal):\n 1. d k * \\<kappa> k k j * fs ! j $ i \\<in> \\<int>", "by (auto intro: Ints_mult )"], ["proof (state)\nthis:\n  ?j1 < k \\<Longrightarrow>\n  d k * \\<kappa> k k ?j1 * fs ! ?j1 $ i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>", "moreover"], ["proof (state)\nthis:\n  ?j1 < k \\<Longrightarrow>\n  d k * \\<kappa> k k ?j1 * fs ! ?j1 $ i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>", "have \"(d k * \\<kappa> k k j) * fs ! j $ i = d k * \\<kappa> k k j * fs ! j $ i\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. d k * \\<kappa> k k j * fs ! j $ i = d k * \\<kappa> k k j * fs ! j $ i", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  d k * \\<kappa> k k ?j1 * fs ! ?j1 $ i =\n  d k * \\<kappa> k k ?j1 * fs ! ?j1 $ i\n\ngoal (1 subgoal):\n 1. (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>", "ultimately"], ["proof (chain)\npicking this:\n  ?j1 < k \\<Longrightarrow>\n  d k * \\<kappa> k k ?j1 * fs ! ?j1 $ i \\<in> \\<int>\n  d k * \\<kappa> k k ?j1 * fs ! ?j1 $ i =\n  d k * \\<kappa> k k ?j1 * fs ! ?j1 $ i", "have \"d k * (\\<Sum>j = 0..<k. \\<kappa> k k j * fs ! j $ i) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  ?j1 < k \\<Longrightarrow>\n  d k * \\<kappa> k k ?j1 * fs ! ?j1 $ i \\<in> \\<int>\n  d k * \\<kappa> k k ?j1 * fs ! ?j1 $ i =\n  d k * \\<kappa> k k ?j1 * fs ! ?j1 $ i\n\ngoal (1 subgoal):\n 1. d k * (\\<Sum>j = 0..<k. \\<kappa> k k j * fs ! j $ i) \\<in> \\<int>", "by (subst sum_distrib_left) (auto simp add: field_simps intro!: Ints_sum)"], ["proof (state)\nthis:\n  d k * (\\<Sum>j = 0..<k. \\<kappa> k k j * fs ! j $ i) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>", "moreover"], ["proof (state)\nthis:\n  d k * (\\<Sum>j = 0..<k. \\<kappa> k k j * fs ! j $ i) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>", "have \"(gso k) $ i = fs ! k $ i + sum (\\<lambda>j. (\\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) $ i) {0..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gso k $ i =\n    fs ! k $ i +\n    (\\<Sum>j = 0..<k. (\\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) $ i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gso k $ i =\n    fs ! k $ i +\n    (\\<Sum>j = 0..<k. (\\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) $ i)", "have \" i < dim_vec (M.sumlist (map (\\<lambda>j. \\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) [0..<k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_vec\n         (M.sumlist\n           (map (\\<lambda>j. \\<kappa> k k j \\<cdot>\\<^sub>v fs ! j)\n             [0..<k]))", "using assms"], ["proof (prove)\nusing this:\n  i < n\n  k < length fs\n\ngoal (1 subgoal):\n 1. i < dim_vec\n         (M.sumlist\n           (map (\\<lambda>j. \\<kappa> k k j \\<cdot>\\<^sub>v fs ! j)\n             [0..<k]))", "by (subst sumlist_dim) auto"], ["proof (state)\nthis:\n  i < dim_vec\n       (M.sumlist\n         (map (\\<lambda>j. \\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) [0..<k]))\n\ngoal (1 subgoal):\n 1. gso k $ i =\n    fs ! k $ i +\n    (\\<Sum>j = 0..<k. (\\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) $ i)", "then"], ["proof (chain)\npicking this:\n  i < dim_vec\n       (M.sumlist\n         (map (\\<lambda>j. \\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) [0..<k]))", "show ?thesis"], ["proof (prove)\nusing this:\n  i < dim_vec\n       (M.sumlist\n         (map (\\<lambda>j. \\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) [0..<k]))\n\ngoal (1 subgoal):\n 1. gso k $ i =\n    fs ! k $ i +\n    (\\<Sum>j = 0..<k. (\\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) $ i)", "using assms"], ["proof (prove)\nusing this:\n  i < dim_vec\n       (M.sumlist\n         (map (\\<lambda>j. \\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) [0..<k]))\n  i < n\n  k < length fs\n\ngoal (1 subgoal):\n 1. gso k $ i =\n    fs ! k $ i +\n    (\\<Sum>j = 0..<k. (\\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) $ i)", "by (subst gso.simps) (auto simp add: sumlist_nth sumlist_dim \\<kappa>_def)"], ["proof (state)\nthis:\n  gso k $ i =\n  fs ! k $ i +\n  (\\<Sum>j = 0..<k. (\\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) $ i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gso k $ i =\n  fs ! k $ i +\n  (\\<Sum>j = 0..<k. (\\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) $ i)\n\ngoal (1 subgoal):\n 1. (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>", "ultimately"], ["proof (chain)\npicking this:\n  d k * (\\<Sum>j = 0..<k. \\<kappa> k k j * fs ! j $ i) \\<in> \\<int>\n  gso k $ i =\n  fs ! k $ i +\n  (\\<Sum>j = 0..<k. (\\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) $ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  d k * (\\<Sum>j = 0..<k. \\<kappa> k k j * fs ! j $ i) \\<in> \\<int>\n  gso k $ i =\n  fs ! k $ i +\n  (\\<Sum>j = 0..<k. (\\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) $ i)\n\ngoal (1 subgoal):\n 1. (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>", "using assms"], ["proof (prove)\nusing this:\n  d k * (\\<Sum>j = 0..<k. \\<kappa> k k j * fs ! j $ i) \\<in> \\<int>\n  gso k $ i =\n  fs ! k $ i +\n  (\\<Sum>j = 0..<k. (\\<kappa> k k j \\<cdot>\\<^sub>v fs ! j) $ i)\n  i < n\n  k < length fs\n\ngoal (1 subgoal):\n 1. (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>", "by (auto simp add: distrib_left Gramian_determinant_Ints fs_int intro!: Ints_mult Ints_add)"], ["proof (state)\nthis:\n  (d k \\<cdot>\\<^sub>v gso k) $ i \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in gram_schmidt_fs_int) d_mu_Ints:\n  assumes \"l \\<le> k\" \"k < m\"\n  shows \"d (Suc l) * \\<mu> k l \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc l) * \\<mu> k l \\<in> \\<int>", "proof (cases \"l < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>\n 2. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "case True"], ["proof (state)\nthis:\n  l < k\n\ngoal (2 subgoals):\n 1. l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>\n 2. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "have ll: \"d l * gso l $ i = (d l \\<cdot>\\<^sub>v gso l) $ i\" if \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. d l * gso l $ i = (d l \\<cdot>\\<^sub>v gso l) $ i", "using that assms"], ["proof (prove)\nusing this:\n  i < n\n  l \\<le> k\n  k < length fs\n\ngoal (1 subgoal):\n 1. d l * gso l $ i = (d l \\<cdot>\\<^sub>v gso l) $ i", "by auto"], ["proof (state)\nthis:\n  ?i1 < n \\<Longrightarrow>\n  d l * gso l $ ?i1 = (d l \\<cdot>\\<^sub>v gso l) $ ?i1\n\ngoal (2 subgoals):\n 1. l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>\n 2. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "have \"d (Suc l) * \\<mu> k l =d (Suc l) * (fs ! k \\<bullet> gso l) / \\<parallel>gso l\\<parallel>\\<^sup>2 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc l) * \\<mu> k l =\n    d (Suc l) * (fs ! k \\<bullet> gso l) /\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "using assms True"], ["proof (prove)\nusing this:\n  l \\<le> k\n  k < length fs\n  l < k\n\ngoal (1 subgoal):\n 1. d (Suc l) * \\<mu> k l =\n    d (Suc l) * (fs ! k \\<bullet> gso l) /\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "unfolding \\<mu>.simps"], ["proof (prove)\nusing this:\n  l \\<le> k\n  k < length fs\n  l < k\n\ngoal (1 subgoal):\n 1. d (Suc l) *\n    (if l < k\n     then fs ! k \\<bullet> gso l / \\<parallel>gso l\\<parallel>\\<^sup>2\n     else if k = l then 1::'a else (0::'a)) =\n    d (Suc l) * (fs ! k \\<bullet> gso l) /\n    \\<parallel>gso l\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  d (Suc l) * \\<mu> k l =\n  d (Suc l) * (fs ! k \\<bullet> gso l) / \\<parallel>gso l\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>\n 2. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  d (Suc l) * \\<mu> k l =\n  d (Suc l) * (fs ! k \\<bullet> gso l) / \\<parallel>gso l\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>\n 2. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "have \"\\<dots> = fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc l) * (fs ! k \\<bullet> gso l) /\n    \\<parallel>gso l\\<parallel>\\<^sup>2 =\n    fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l)", "using assms Gramian_determinant(2)[of \"Suc l\"]"], ["proof (prove)\nusing this:\n  l \\<le> k\n  k < length fs\n  Suc l \\<le> length fs \\<Longrightarrow> (0::'a) < d (Suc l)\n\ngoal (1 subgoal):\n 1. d (Suc l) * (fs ! k \\<bullet> gso l) /\n    \\<parallel>gso l\\<parallel>\\<^sup>2 =\n    fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l)", "by (subst Gramian_determinant_div[symmetric]) (auto)"], ["proof (state)\nthis:\n  d (Suc l) * (fs ! k \\<bullet> gso l) /\n  \\<parallel>gso l\\<parallel>\\<^sup>2 =\n  fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l)\n\ngoal (2 subgoals):\n 1. l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>\n 2. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  d (Suc l) * (fs ! k \\<bullet> gso l) /\n  \\<parallel>gso l\\<parallel>\\<^sup>2 =\n  fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l)\n\ngoal (2 subgoals):\n 1. l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>\n 2. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "have \"\\<dots> \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l) \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l) \\<in> \\<int>", "have \"d l * gso l $ i \\<in> \\<int>\" if \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. d l * gso l $ i \\<in> \\<int>", "using assms d_gso_Ints that ll"], ["proof (prove)\nusing this:\n  l \\<le> k\n  k < length fs\n  \\<lbrakk>?i < n; ?k < length fs\\<rbrakk>\n  \\<Longrightarrow> (d ?k \\<cdot>\\<^sub>v gso ?k) $ ?i \\<in> \\<int>\n  i < n\n  ?i1 < n \\<Longrightarrow>\n  d l * gso l $ ?i1 = (d l \\<cdot>\\<^sub>v gso l) $ ?i1\n\ngoal (1 subgoal):\n 1. d l * gso l $ i \\<in> \\<int>", "by (simp)"], ["proof (state)\nthis:\n  ?i1 < n \\<Longrightarrow> d l * gso l $ ?i1 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l) \\<in> \\<int>", "then"], ["proof (chain)\npicking this:\n  ?i1 < n \\<Longrightarrow> d l * gso l $ ?i1 \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i1 < n \\<Longrightarrow> d l * gso l $ ?i1 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l) \\<in> \\<int>", "using assms"], ["proof (prove)\nusing this:\n  ?i1 < n \\<Longrightarrow> d l * gso l $ ?i1 \\<in> \\<int>\n  l \\<le> k\n  k < length fs\n\ngoal (1 subgoal):\n 1. fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l) \\<in> \\<int>", "by (auto intro!: Ints_sum simp add: fs_int scalar_prod_def)"], ["proof (state)\nthis:\n  fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l) \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fs ! k \\<bullet> (d l \\<cdot>\\<^sub>v gso l) \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>\n 2. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  d (Suc l) * \\<mu> k l \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  d (Suc l) * \\<mu> k l \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. d (Suc l) * \\<mu> k l \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  d (Suc l) * \\<mu> k l \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "case False"], ["proof (state)\nthis:\n  \\<not> l < k\n\ngoal (1 subgoal):\n 1. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "with assms"], ["proof (chain)\npicking this:\n  l \\<le> k\n  k < length fs\n  \\<not> l < k", "have l: \"l = k\""], ["proof (prove)\nusing this:\n  l \\<le> k\n  k < length fs\n  \\<not> l < k\n\ngoal (1 subgoal):\n 1. l = k", "by auto"], ["proof (state)\nthis:\n  l = k\n\ngoal (1 subgoal):\n 1. \\<not> l < k \\<Longrightarrow> d (Suc l) * \\<mu> k l \\<in> \\<int>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc l) * \\<mu> k l \\<in> \\<int>", "unfolding l \\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (Suc k) *\n    (if k < k\n     then fs ! k \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2\n     else if k = k then 1::'a else (0::'a))\n    \\<in> \\<int>", "using Gramian_determinant_Ints fs_int assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k \\<le> length fs;\n   \\<And>i j.\n      \\<lbrakk>i < n; j < length fs\\<rbrakk>\n      \\<Longrightarrow> fs ! j $ i \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> d ?k \\<in> \\<int>\n  \\<lbrakk>?i < n; ?j < length fs\\<rbrakk>\n  \\<Longrightarrow> fs ! ?j $ ?i \\<in> \\<int>\n  l \\<le> k\n  k < length fs\n\ngoal (1 subgoal):\n 1. d (Suc k) *\n    (if k < k\n     then fs ! k \\<bullet> gso k / \\<parallel>gso k\\<parallel>\\<^sup>2\n     else if k = k then 1::'a else (0::'a))\n    \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  d (Suc l) * \\<mu> k l \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_list_Max: \"ls \\<noteq> [] \\<Longrightarrow> max_list ls = Max (set ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<noteq> [] \\<Longrightarrow>\n    Missing_Lemmas.max_list ls = Max (set ls)", "by (induction ls) (auto simp add: max_list_Cons)"], ["", "subsection \\<open>Explicit Bounds for Size of Numbers that Occur During GSO Algorithm \\<close>"], ["", "context gram_schmidt_fs_lin_indpt\nbegin"], ["", "definition \"N = Max (sq_norm ` set fs)\""], ["", "lemma N_ge_0:\n  assumes \"0 < m\"\n  shows \"0 \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> N", "have \"x \\<in> sq_norm ` set fs \\<Longrightarrow> 0 \\<le> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> sq_norm ` set fs \\<Longrightarrow> (0::'a) \\<le> x", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> sq_norm ` set fs \\<Longrightarrow> (0::'a) \\<le> ?x1\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> N", "then"], ["proof (chain)\npicking this:\n  ?x1 \\<in> sq_norm ` set fs \\<Longrightarrow> (0::'a) \\<le> ?x1", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x1 \\<in> sq_norm ` set fs \\<Longrightarrow> (0::'a) \\<le> ?x1\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> N", "using assms"], ["proof (prove)\nusing this:\n  ?x1 \\<in> sq_norm ` set fs \\<Longrightarrow> (0::'a) \\<le> ?x1\n  0 < length fs\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> N", "unfolding N_def"], ["proof (prove)\nusing this:\n  ?x1 \\<in> sq_norm ` set fs \\<Longrightarrow> (0::'a) \\<le> ?x1\n  0 < length fs\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> Max (sq_norm ` set fs)", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma N_fs:\n  assumes \"i < m\"\n  shows \"\\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> N", "using assms"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> N", "unfolding N_def"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> Max (sq_norm ` set fs)", "by (auto)"], ["", "lemma N_gso:\n  assumes \"i < m\"\n  shows \"\\<parallel>gso i\\<parallel>\\<^sup>2 \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2 \\<le> N", "using assms N_fs sq_norm_gso_le_f"], ["proof (prove)\nusing this:\n  i < length fs\n  ?i < length fs \\<Longrightarrow>\n  \\<parallel>fs ! ?i\\<parallel>\\<^sup>2 \\<le> N\n  ?i < length fs \\<Longrightarrow>\n  \\<parallel>gso ?i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>fs ! ?i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gso i\\<parallel>\\<^sup>2 \\<le> N", "by fastforce"], ["", "lemma N_d:\n  assumes \"i \\<le> m\"\n  shows \"Gramian_determinant fs i \\<le> N ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d i \\<le> N ^ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d i \\<le> N ^ i", "have \"(\\<Prod>j<i. \\<parallel>gso j\\<parallel>\\<^sup>2) \\<le> (\\<Prod>j<i. N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<i. \\<parallel>gso j\\<parallel>\\<^sup>2) \\<le> (\\<Prod>j<i. N)", "using assms N_gso"], ["proof (prove)\nusing this:\n  i \\<le> length fs\n  ?i < length fs \\<Longrightarrow>\n  \\<parallel>gso ?i\\<parallel>\\<^sup>2 \\<le> N\n\ngoal (1 subgoal):\n 1. (\\<Prod>j<i. \\<parallel>gso j\\<parallel>\\<^sup>2) \\<le> (\\<Prod>j<i. N)", "by (intro prod_mono) auto"], ["proof (state)\nthis:\n  (\\<Prod>j<i. \\<parallel>gso j\\<parallel>\\<^sup>2) \\<le> (\\<Prod>j<i. N)\n\ngoal (1 subgoal):\n 1. d i \\<le> N ^ i", "then"], ["proof (chain)\npicking this:\n  (\\<Prod>j<i. \\<parallel>gso j\\<parallel>\\<^sup>2) \\<le> (\\<Prod>j<i. N)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Prod>j<i. \\<parallel>gso j\\<parallel>\\<^sup>2) \\<le> (\\<Prod>j<i. N)\n\ngoal (1 subgoal):\n 1. d i \\<le> N ^ i", "using assms Gramian_determinant"], ["proof (prove)\nusing this:\n  (\\<Prod>j<i. \\<parallel>gso j\\<parallel>\\<^sup>2) \\<le> (\\<Prod>j<i. N)\n  i \\<le> length fs\n  ?k \\<le> length fs \\<Longrightarrow>\n  d ?k = (\\<Prod>j<?k. \\<parallel>gso j\\<parallel>\\<^sup>2)\n  ?k \\<le> length fs \\<Longrightarrow> (0::'a) < d ?k\n\ngoal (1 subgoal):\n 1. d i \\<le> N ^ i", "by auto"], ["proof (state)\nthis:\n  d i \\<le> N ^ i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma ex_MAXIMUM: assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"\\<exists>a \\<in> A. Max (f ` A) = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. Max (f ` A) = f a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. Max (f ` A) = f a", "have \"Max (f ` A) \\<in> f ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (f ` A) \\<in> f ` A", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (f ` A) \\<in> f ` A", "by (auto intro!: Max_in)"], ["proof (state)\nthis:\n  Max (f ` A) \\<in> f ` A\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. Max (f ` A) = f a", "then"], ["proof (chain)\npicking this:\n  Max (f ` A) \\<in> f ` A", "show ?thesis"], ["proof (prove)\nusing this:\n  Max (f ` A) \\<in> f ` A\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. Max (f ` A) = f a", "using assms imageE"], ["proof (prove)\nusing this:\n  Max (f ` A) \\<in> f ` A\n  finite A\n  A \\<noteq> {}\n  \\<lbrakk>?b \\<in> ?f ` ?A;\n   \\<And>x.\n      \\<lbrakk>?b = ?f x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. Max (f ` A) = f a", "by blast"], ["proof (state)\nthis:\n  \\<exists>a\\<in>A. Max (f ` A) = f a\n\ngoal:\nNo subgoals!", "qed"], ["", "context gram_schmidt_fs_int\nbegin"], ["", "lemma fs_int': \"k < n \\<Longrightarrow> f \\<in> set fs \\<Longrightarrow> f $ k \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < n; f \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> f $ k \\<in> \\<int>", "by (metis fs_int in_set_conv_nth)"], ["", "lemma\n  assumes \"i < m\"\n  shows fs_sq_norm_Ints: \"\\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<in> \\<int>\" and fs_sq_norm_ge_1: \"1 \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<in> \\<int> &&&\n    (1::'a) \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<in> \\<int>\n 2. (1::'a) \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "show fs_Ints: \"\\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<in> \\<int>", "using assms fs_int' carrier_vecD fs_carrier"], ["proof (prove)\nusing this:\n  i < length fs\n  \\<lbrakk>?k < n; ?f \\<in> set fs\\<rbrakk>\n  \\<Longrightarrow> ?f $ ?k \\<in> \\<int>\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> dim_vec ?v = ?n\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<in> \\<int>", "by (auto simp add: sq_norm_vec_as_cscalar_prod scalar_prod_def intro!: Ints_sum Ints_mult)"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "have \"fs ! i \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i \\<noteq> 0\\<^sub>v n", "using assms fs_carrier loc_assms nth_mem vs_zero_lin_dep"], ["proof (prove)\nusing this:\n  i < length fs\n  set fs \\<subseteq> carrier_vec n\n  lin_indpt (set fs)\n  distinct fs\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  \\<lbrakk>?S \\<subseteq> carrier_vec n; lin_indpt ?S\\<rbrakk>\n  \\<Longrightarrow> 0\\<^sub>v n \\<notin> ?S\n\ngoal (1 subgoal):\n 1. fs ! i \\<noteq> 0\\<^sub>v n", "by force"], ["proof (state)\nthis:\n  fs ! i \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  fs ! i \\<noteq> 0\\<^sub>v n", "have *: \"0 \\<noteq> \\<parallel>fs ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\nusing this:\n  fs ! i \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (0::'a) \\<noteq> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "using assms sq_norm_vec_eq_0 f_carrier"], ["proof (prove)\nusing this:\n  fs ! i \\<noteq> 0\\<^sub>v n\n  i < length fs\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow>\n  (\\<parallel>?v\\<parallel>\\<^sup>2 = (0::?'a)) = (?v = 0\\<^sub>v ?n)\n  ?i < length fs \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (0::'a) \\<noteq> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "by metis"], ["proof (state)\nthis:\n  (0::'a) \\<noteq> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "show \"1 \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "by (rule Ints_cases[OF fs_Ints]) (use * sq_norm_vec_ge_0[of \"fs ! i\"] assms in auto)"], ["proof (state)\nthis:\n  (1::'a) \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  assumes \"set fs \\<noteq> {}\"\n  shows N_Ints: \"N \\<in> \\<int>\" and N_1: \"1 \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<in> \\<int> &&& (1::'a) \\<le> N", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. N \\<in> \\<int>\n 2. (1::'a) \\<le> N", "have \"\\<exists>v\\<^sub>m \\<in> set fs. N = sq_norm v\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>m\\<in>set fs.\n       N = \\<parallel>v\\<^sub>m\\<parallel>\\<^sup>2", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>m\\<in>set fs.\n       Max (sq_norm ` set fs) = \\<parallel>v\\<^sub>m\\<parallel>\\<^sup>2", "using assms"], ["proof (prove)\nusing this:\n  set fs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>m\\<in>set fs.\n       Max (sq_norm ` set fs) = \\<parallel>v\\<^sub>m\\<parallel>\\<^sup>2", "by (auto intro!: ex_MAXIMUM)"], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>m\\<in>set fs. N = \\<parallel>v\\<^sub>m\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. N \\<in> \\<int>\n 2. (1::'a) \\<le> N", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<^sub>m\\<in>set fs. N = \\<parallel>v\\<^sub>m\\<parallel>\\<^sup>2", "obtain v\\<^sub>m::\"'a vec\" where v\\<^sub>m_def: \"v\\<^sub>m \\<in> set fs\" \"N = sq_norm v\\<^sub>m\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<^sub>m\\<in>set fs. N = \\<parallel>v\\<^sub>m\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>m.\n        \\<lbrakk>v\\<^sub>m \\<in> set fs;\n         N = \\<parallel>v\\<^sub>m\\<parallel>\\<^sup>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v\\<^sub>m \\<in> set fs\n  N = \\<parallel>v\\<^sub>m\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. N \\<in> \\<int>\n 2. (1::'a) \\<le> N", "then"], ["proof (chain)\npicking this:\n  v\\<^sub>m \\<in> set fs\n  N = \\<parallel>v\\<^sub>m\\<parallel>\\<^sup>2", "show N_Ints: \"N \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  v\\<^sub>m \\<in> set fs\n  N = \\<parallel>v\\<^sub>m\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. N \\<in> \\<int>", "using fs_int' carrier_vecD fs_carrier"], ["proof (prove)\nusing this:\n  v\\<^sub>m \\<in> set fs\n  N = \\<parallel>v\\<^sub>m\\<parallel>\\<^sup>2\n  \\<lbrakk>?k < n; ?f \\<in> set fs\\<rbrakk>\n  \\<Longrightarrow> ?f $ ?k \\<in> \\<int>\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> dim_vec ?v = ?n\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. N \\<in> \\<int>", "by (auto simp add: sq_norm_vec_as_cscalar_prod scalar_prod_def intro!: Ints_sum Ints_mult)"], ["proof (state)\nthis:\n  N \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> N", "have *: \"0 \\<noteq> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<noteq> N", "using N_gso sq_norm_pos assms"], ["proof (prove)\nusing this:\n  ?i < length fs \\<Longrightarrow>\n  \\<parallel>gso ?i\\<parallel>\\<^sup>2 \\<le> N\n  ?j < length fs \\<Longrightarrow>\n  (0::'a) < \\<parallel>gso ?j\\<parallel>\\<^sup>2\n  set fs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<noteq> N", "by fastforce"], ["proof (state)\nthis:\n  (0::'a) \\<noteq> N\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> N", "show \"1 \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> N", "by (rule Ints_cases[OF N_Ints]) (use * N_ge_0 assms in force)+"], ["proof (state)\nthis:\n  (1::'a) \\<le> N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma N_mu:\n  assumes \"i < m\" \"j \\<le> i\"\n  shows \"(\\<mu> i j)\\<^sup>2 \\<le> N ^ (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "assume ji: \"j < i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "have \"(\\<mu> i j)\\<^sup>2 \\<le> Gramian_determinant fs j * \\<parallel>fs ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> d j * \\<parallel>fs ! i\\<parallel>\\<^sup>2", "using assms ji"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  j < i\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> d j * \\<parallel>fs ! i\\<parallel>\\<^sup>2", "by (intro mu_bound_Gramian_determinant) auto"], ["proof (state)\nthis:\n  (\\<mu> i j)\\<^sup>2 \\<le> d j * \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "also"], ["proof (state)\nthis:\n  (\\<mu> i j)\\<^sup>2 \\<le> d j * \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "have \"\\<dots> \\<le> N ^ j * \\<parallel>fs ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d j * \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> N ^ j * \\<parallel>fs ! i\\<parallel>\\<^sup>2", "using assms N_d N_ge_0"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  ?i \\<le> length fs \\<Longrightarrow> d ?i \\<le> N ^ ?i\n  0 < length fs \\<Longrightarrow> (0::'a) \\<le> N\n\ngoal (1 subgoal):\n 1. d j * \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> N ^ j * \\<parallel>fs ! i\\<parallel>\\<^sup>2", "by (intro mult_mono) fastforce+"], ["proof (state)\nthis:\n  d j * \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> N ^ j * \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "also"], ["proof (state)\nthis:\n  d j * \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> N ^ j * \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "have \"N ^ j * \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> N ^ j * N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N ^ j * \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> N ^ j * N", "using assms N_fs N_ge_0"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  ?i < length fs \\<Longrightarrow>\n  \\<parallel>fs ! ?i\\<parallel>\\<^sup>2 \\<le> N\n  0 < length fs \\<Longrightarrow> (0::'a) \\<le> N\n\ngoal (1 subgoal):\n 1. N ^ j * \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> N ^ j * N", "by (intro mult_mono) fastforce+"], ["proof (state)\nthis:\n  N ^ j * \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> N ^ j * N\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "also"], ["proof (state)\nthis:\n  N ^ j * \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> N ^ j * N\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "have \"\\<dots> = N ^ (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N ^ j * N = N ^ Suc j", "by auto"], ["proof (state)\nthis:\n  N ^ j * N = N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "finally"], ["proof (chain)\npicking this:\n  (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "have ?thesis"], ["proof (prove)\nusing this:\n  (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "by simp"], ["proof (state)\nthis:\n  (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "}"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "moreover"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "{"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "assume ji: \"j = i\""], ["proof (state)\nthis:\n  j = i\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "have \"(\\<mu> i j)\\<^sup>2 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 = (1::'a)", "using ji"], ["proof (prove)\nusing this:\n  j = i\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 = (1::'a)", "by (simp add: \\<mu>.simps)"], ["proof (state)\nthis:\n  (\\<mu> i j)\\<^sup>2 = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "also"], ["proof (state)\nthis:\n  (\\<mu> i j)\\<^sup>2 = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "have \"\\<dots> \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> N", "using assms N_1"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  set fs \\<noteq> {} \\<Longrightarrow> (1::'a) \\<le> N\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> N", "by fastforce"], ["proof (state)\nthis:\n  (1::'a) \\<le> N\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "also"], ["proof (state)\nthis:\n  (1::'a) \\<le> N\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "have \"\\<dots> \\<le> N ^ (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<le> N ^ Suc j", "using assms N_1"], ["proof (prove)\nusing this:\n  i < length fs\n  j \\<le> i\n  set fs \\<noteq> {} \\<Longrightarrow> (1::'a) \\<le> N\n\ngoal (1 subgoal):\n 1. N \\<le> N ^ Suc j", "by fastforce"], ["proof (state)\nthis:\n  N \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "finally"], ["proof (chain)\npicking this:\n  (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "have ?thesis"], ["proof (prove)\nusing this:\n  (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "by simp"], ["proof (state)\nthis:\n  (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "}"], ["proof (state)\nthis:\n  j = i \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "ultimately"], ["proof (chain)\npicking this:\n  j < i \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n  j = i \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  j < i \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n  j = i \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "using assms"], ["proof (prove)\nusing this:\n  j < i \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n  j = i \\<Longrightarrow> (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n  i < length fs\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j", "by fastforce"], ["proof (state)\nthis:\n  (\\<mu> i j)\\<^sup>2 \\<le> N ^ Suc j\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma vec_hom_Ints:\n  assumes \"i < n\" \"xs \\<in> carrier_vec n\"\n  shows \"of_int_hom.vec_hom xs $ i \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom xs $ i \\<in> \\<int>", "using assms"], ["proof (prove)\nusing this:\n  i < n\n  xs \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom xs $ i \\<in> \\<int>", "by auto"], ["", "lemma division_to_div: \"(of_int x  :: 'a :: floor_ceiling) = of_int y / of_int z \\<Longrightarrow> x = y div z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int x = of_int y / of_int z \\<Longrightarrow> x = y div z", "by (metis floor_divide_of_int_eq floor_of_int)"], ["", "lemma exact_division: assumes \"of_int x / (of_int y  :: 'a :: floor_ceiling) \\<in> \\<int>\"\n  shows \"of_int (x div y) = of_int x / (of_int y :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (x div y) = of_int x / of_int y", "using assms"], ["proof (prove)\nusing this:\n  of_int x / of_int y \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. of_int (x div y) = of_int x / of_int y", "by (metis Ints_cases division_to_div)"], ["", "lemma int_via_rat_eqI: \"rat_of_int x = rat_of_int y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int x = rat_of_int y \\<Longrightarrow> x = y", "by auto"], ["", "locale fs_int =\n  fixes\n    n :: nat (* n-dimensional vectors, *) and\n    fs_init :: \"int vec list\" (* initial basis *)\nbegin"], ["", "sublocale vec_module \"TYPE(int)\" n"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation RAT where \"RAT \\<equiv> map (map_vec rat_of_int)\""], ["", "abbreviation (input) m where \"m \\<equiv> length fs_init\""], ["", "sublocale gs: gram_schmidt_fs n \"RAT fs_init\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition d :: \"int vec list \\<Rightarrow> nat \\<Rightarrow> int\" where \"d fs k = gs.Gramian_determinant fs k\""], ["", "definition D :: \"int vec list \\<Rightarrow> nat\" where \"D fs = nat (\\<Prod> i < length fs. d fs i)\""], ["", "lemma of_int_Gramian_determinant:\n  assumes \"k \\<le> length F\" \"\\<And>i. i < length F \\<Longrightarrow> dim_vec (F ! i) = n\"\n  shows \"gs.Gramian_determinant (map of_int_hom.vec_hom F) k = of_int (gs.Gramian_determinant F k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.Gramian_determinant (map of_int_hom.vec_hom F) k =\n    of_int (gs.Gramian_determinant F k)", "unfolding gs.Gramian_determinant_def of_int_hom.hom_det[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (gs.Gramian_matrix (map of_int_hom.vec_hom F) k) =\n    det (of_int_hom.mat_hom (gs.Gramian_matrix F k))", "proof (rule arg_cong[of _ _ det])"], ["proof (state)\ngoal (1 subgoal):\n 1. gs.Gramian_matrix (map of_int_hom.vec_hom F) k =\n    of_int_hom.mat_hom (gs.Gramian_matrix F k)", "let ?F = \"map of_int_hom.vec_hom F\""], ["proof (state)\ngoal (1 subgoal):\n 1. gs.Gramian_matrix (map of_int_hom.vec_hom F) k =\n    of_int_hom.mat_hom (gs.Gramian_matrix F k)", "have cong: \"\\<And> a b c d. a = b \\<Longrightarrow> c = d \\<Longrightarrow> a * c = b * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a = b; c = d\\<rbrakk> \\<Longrightarrow> a * c = b * d", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a2 = ?b2; ?c2 = ?d2\\<rbrakk>\n  \\<Longrightarrow> ?a2 * ?c2 = ?b2 * ?d2\n\ngoal (1 subgoal):\n 1. gs.Gramian_matrix (map of_int_hom.vec_hom F) k =\n    of_int_hom.mat_hom (gs.Gramian_matrix F k)", "show \"gs.Gramian_matrix ?F k = map_mat of_int (gs.Gramian_matrix F k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.Gramian_matrix (map of_int_hom.vec_hom F) k =\n    of_int_hom.mat_hom (gs.Gramian_matrix F k)", "unfolding gs.Gramian_matrix_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, y). map of_int_hom.vec_hom F ! i $ y) *\n    (mat k n (\\<lambda>(i, y). map of_int_hom.vec_hom F ! i $ y))\\<^sup>T =\n    of_int_hom.mat_hom\n     (mat k n (\\<lambda>(i, y). F ! i $ y) *\n      (mat k n (\\<lambda>(i, y). F ! i $ y))\\<^sup>T)", "proof (subst of_int_hom.mat_hom_mult[of _ k n _ k], (auto)[2], rule cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. mat k n (\\<lambda>(i, y). map of_int_hom.vec_hom F ! i $ y) =\n    of_int_hom.mat_hom (mat k n (\\<lambda>(i, y). F ! i $ y))\n 2. (mat k n (\\<lambda>(i, y). map of_int_hom.vec_hom F ! i $ y))\\<^sup>T =\n    of_int_hom.mat_hom (mat k n (\\<lambda>(i, y). F ! i $ y))\\<^sup>T", "show id: \"mat k n (\\<lambda> (i,j). ?F ! i $ j) = map_mat of_int (mat k n (\\<lambda> (i, j). F ! i $ j))\" (is \"?L = map_mat _ ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j) =\n    of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j))", "proof (rule eq_matI, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (of_int_hom.mat_hom\n                       (mat k n (\\<lambda>(i, j). F ! i $ j)));\n        j < dim_col\n             (of_int_hom.mat_hom\n               (mat k n (\\<lambda>(i, j). F ! i $ j)))\\<rbrakk>\n       \\<Longrightarrow> mat k n\n                          (\\<lambda>(i, j).\n                              map of_int_hom.vec_hom F ! i $ j) $$\n                         (i, j) =\n                         of_int_hom.mat_hom\n                          (mat k n (\\<lambda>(i, j). F ! i $ j)) $$\n                         (i, j)\n 2. dim_row (mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j)) =\n    dim_row (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))\n 3. dim_col (mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j)) =\n    dim_col (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))", "case (1 i j)"], ["proof (state)\nthis:\n  i < dim_row (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))\n  j < dim_col (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (of_int_hom.mat_hom\n                       (mat k n (\\<lambda>(i, j). F ! i $ j)));\n        j < dim_col\n             (of_int_hom.mat_hom\n               (mat k n (\\<lambda>(i, j). F ! i $ j)))\\<rbrakk>\n       \\<Longrightarrow> mat k n\n                          (\\<lambda>(i, j).\n                              map of_int_hom.vec_hom F ! i $ j) $$\n                         (i, j) =\n                         of_int_hom.mat_hom\n                          (mat k n (\\<lambda>(i, j). F ! i $ j)) $$\n                         (i, j)\n 2. dim_row (mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j)) =\n    dim_row (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))\n 3. dim_col (mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j)) =\n    dim_col (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))", "hence ij: \"i < k\" \"j < n\" \"i < length F\" \"dim_vec (F ! i) = n\""], ["proof (prove)\nusing this:\n  i < dim_row (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))\n  j < dim_col (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))\n\ngoal (1 subgoal):\n 1. (i < k &&& j < n) &&& i < length F &&& dim_vec (F ! i) = n", "using assms"], ["proof (prove)\nusing this:\n  i < dim_row (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))\n  j < dim_col (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))\n  k \\<le> length F\n  ?i1 < length F \\<Longrightarrow> dim_vec (F ! ?i1) = n\n\ngoal (1 subgoal):\n 1. (i < k &&& j < n) &&& i < length F &&& dim_vec (F ! i) = n", "by auto"], ["proof (state)\nthis:\n  i < k\n  j < n\n  i < length F\n  dim_vec (F ! i) = n\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (of_int_hom.mat_hom\n                       (mat k n (\\<lambda>(i, j). F ! i $ j)));\n        j < dim_col\n             (of_int_hom.mat_hom\n               (mat k n (\\<lambda>(i, j). F ! i $ j)))\\<rbrakk>\n       \\<Longrightarrow> mat k n\n                          (\\<lambda>(i, j).\n                              map of_int_hom.vec_hom F ! i $ j) $$\n                         (i, j) =\n                         of_int_hom.mat_hom\n                          (mat k n (\\<lambda>(i, j). F ! i $ j)) $$\n                         (i, j)\n 2. dim_row (mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j)) =\n    dim_row (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))\n 3. dim_col (mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j)) =\n    dim_col (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j) $$ (i, j) =\n    of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)) $$ (i, j)", "using ij"], ["proof (prove)\nusing this:\n  i < k\n  j < n\n  i < length F\n  dim_vec (F ! i) = n\n\ngoal (1 subgoal):\n 1. mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j) $$ (i, j) =\n    of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)) $$ (i, j)", "by simp"], ["proof (state)\nthis:\n  mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j) $$ (i, j) =\n  of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)) $$ (i, j)\n\ngoal (2 subgoals):\n 1. dim_row (mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j)) =\n    dim_row (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))\n 2. dim_col (mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j)) =\n    dim_col (of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j)))", "qed auto"], ["proof (state)\nthis:\n  mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j) =\n  of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j))\n\ngoal (1 subgoal):\n 1. (mat k n (\\<lambda>(i, y). map of_int_hom.vec_hom F ! i $ y))\\<^sup>T =\n    of_int_hom.mat_hom (mat k n (\\<lambda>(i, y). F ! i $ y))\\<^sup>T", "show \"?L\\<^sup>T = map_mat of_int ?R\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j))\\<^sup>T =\n    of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j))\\<^sup>T", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_hom.mat_hom (mat k n (\\<lambda>(i, y). F ! i $ y)))\\<^sup>T =\n    of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j))\\<^sup>T", "by (rule eq_matI, auto)"], ["proof (state)\nthis:\n  (mat k n (\\<lambda>(i, j). map of_int_hom.vec_hom F ! i $ j))\\<^sup>T =\n  of_int_hom.mat_hom (mat k n (\\<lambda>(i, j). F ! i $ j))\\<^sup>T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs.Gramian_matrix (map of_int_hom.vec_hom F) k =\n  of_int_hom.mat_hom (gs.Gramian_matrix F k)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale fs_int_indpt = fs_int n fs for n fs +\n  assumes lin_indep: \"gs.lin_indpt_list (RAT fs)\"\nbegin"], ["", "sublocale gs: gram_schmidt_fs_lin_indpt n \"RAT fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_lin_indpt n (map of_int_hom.vec_hom fs)", "by (standard) (use lin_indep gs.lin_indpt_list_def in auto)"], ["", "sublocale gs: gram_schmidt_fs_int n \"RAT fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_int n (map of_int_hom.vec_hom fs)", "by (standard) (use gs.f_carrier lin_indep gs.lin_indpt_list_def in \\<open>auto intro!: vec_hom_Ints\\<close>)"], ["", "lemma f_carrier[dest]: \"i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n\"\n  and fs_carrier [simp]: \"set fs \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n) &&&\n    set fs \\<subseteq> carrier_vec n", "using lin_indep gs.f_carrier gs.gso_carrier"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i \\<in> carrier_vec n\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs.gso ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n) &&&\n    set fs \\<subseteq> carrier_vec n", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs) \\<subseteq> carrier_vec n \\<and>\n  distinct (map of_int_hom.vec_hom fs) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i \\<in> carrier_vec n\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs.gso ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n) &&&\n    set fs \\<subseteq> carrier_vec n", "by auto"], ["", "lemma Gramian_determinant:\n  assumes k: \"k \\<le> m\" \n  shows \"of_int (gs.Gramian_determinant fs k) = (\\<Prod> j<k. sq_norm (gs.gso j))\" (is ?g1)\n    \"gs.Gramian_determinant fs k > 0\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs k) =\n    (\\<Prod>j<k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2) &&&\n    0 < gs.Gramian_determinant fs k", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. rat_of_int (gs.Gramian_determinant fs k) =\n    (\\<Prod>j<k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\n 2. 0 < gs.Gramian_determinant fs k", "have hom: \"gs.Gramian_determinant (RAT fs) k = of_int (gs.Gramian_determinant fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.d k = rat_of_int (gs.Gramian_determinant fs k)", "using k"], ["proof (prove)\nusing this:\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. gs.d k = rat_of_int (gs.Gramian_determinant fs k)", "by (intro of_int_Gramian_determinant) auto"], ["proof (state)\nthis:\n  gs.d k = rat_of_int (gs.Gramian_determinant fs k)\n\ngoal (2 subgoals):\n 1. rat_of_int (gs.Gramian_determinant fs k) =\n    (\\<Prod>j<k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\n 2. 0 < gs.Gramian_determinant fs k", "show ?g1"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs k) =\n    (\\<Prod>j<k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "unfolding hom[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.d k = (\\<Prod>j<k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "using gs.Gramian_determinant assms"], ["proof (prove)\nusing this:\n  ?k \\<le> length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs.d ?k = (\\<Prod>j<?k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\n  ?k \\<le> length (map of_int_hom.vec_hom fs) \\<Longrightarrow> 0 < gs.d ?k\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. gs.d k = (\\<Prod>j<k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  rat_of_int (gs.Gramian_determinant fs k) =\n  (\\<Prod>j<k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 0 < gs.Gramian_determinant fs k", "show ?g2"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < gs.Gramian_determinant fs k", "using hom gs.Gramian_determinant assms"], ["proof (prove)\nusing this:\n  gs.d k = rat_of_int (gs.Gramian_determinant fs k)\n  ?k \\<le> length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs.d ?k = (\\<Prod>j<?k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\n  ?k \\<le> length (map of_int_hom.vec_hom fs) \\<Longrightarrow> 0 < gs.d ?k\n  k \\<le> length fs\n\ngoal (1 subgoal):\n 1. 0 < gs.Gramian_determinant fs k", "by fastforce"], ["proof (state)\nthis:\n  0 < gs.Gramian_determinant fs k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fs_int_d_pos [intro]:\n  assumes k: \"k \\<le> m\" \nshows \"d fs k > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d fs k", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < gs.Gramian_determinant fs k", "using Gramian_determinant[OF k]"], ["proof (prove)\nusing this:\n  rat_of_int (gs.Gramian_determinant fs k) =\n  (\\<Prod>j<k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\n  0 < gs.Gramian_determinant fs k\n\ngoal (1 subgoal):\n 1. 0 < gs.Gramian_determinant fs k", "by auto"], ["", "lemma fs_int_d_Suc:\n  assumes k: \"k < m\" \nshows \"of_int (d fs (Suc k)) = sq_norm (gs.gso k) * of_int (d fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) =\n    \\<parallel>gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) =\n    \\<parallel>gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k)", "from k"], ["proof (chain)\npicking this:\n  k < length fs", "have k: \"k \\<le> m\" \"Suc k \\<le> m\""], ["proof (prove)\nusing this:\n  k < length fs\n\ngoal (1 subgoal):\n 1. k \\<le> length fs &&& Suc k \\<le> length fs", "by auto"], ["proof (state)\nthis:\n  k \\<le> length fs\n  Suc k \\<le> length fs\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) =\n    \\<parallel>gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) =\n    \\<parallel>gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k)", "unfolding Gramian_determinant[OF k(1)] Gramian_determinant[OF k(2)] d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j<Suc k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2) =\n    \\<parallel>gs.gso k\\<parallel>\\<^sup>2 *\n    (\\<Prod>j<k. \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "by (subst prod.remove[of _ k], force+, rule arg_cong[of _ _ \"\\<lambda> x. _ * x\"], rule prod.cong, auto)"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc k)) =\n  \\<parallel>gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fs_int_D_pos:\nshows \"D fs > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < D fs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < D fs", "have \"(\\<Prod> j < m. d fs j) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < prod (d fs) {..<length fs}", "by (rule prod_pos, insert fs_int_d_pos, auto)"], ["proof (state)\nthis:\n  0 < prod (d fs) {..<length fs}\n\ngoal (1 subgoal):\n 1. 0 < D fs", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < prod (d fs) {..<length fs}\n\ngoal (1 subgoal):\n 1. 0 < D fs", "unfolding D_def"], ["proof (prove)\nusing this:\n  0 < prod (d fs) {..<length fs}\n\ngoal (1 subgoal):\n 1. 0 < nat (prod (d fs) {..<length fs})", "by auto"], ["proof (state)\nthis:\n  0 < D fs\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"d\\<mu> i j = int_of_rat (of_int (d fs (Suc j)) * gs.\\<mu> i j)\""], ["", "lemma fs_int_mu_d_Z:\n  assumes j: \"j \\<le> ii\" and ii: \"ii < m\" \n  shows \"of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "have id: \"of_int (d fs (Suc j)) = gs.Gramian_determinant (RAT fs) (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) = gs.d (Suc j)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs (Suc j)) = gs.d (Suc j)", "by (rule of_int_Gramian_determinant[symmetric], insert j ii , auto)"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc j)) = gs.d (Suc j)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "have \"of_int_hom.vec_hom (fs ! j) $ i \\<in> \\<int>\" if \"i < n\" \"j < length fs\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! j) $ i \\<in> \\<int>", "using that"], ["proof (prove)\nusing this:\n  i < n\n  j < length fs\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! j) $ i \\<in> \\<int>", "by (intro vec_hom_Ints) auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < length fs\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < n; ?j2 < length fs\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < length fs\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "unfolding id"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < length fs\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. gs.d (Suc j) * gs.\\<mu> ii j \\<in> \\<int>", "using j ii"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < length fs\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>\n  j \\<le> ii\n  ii < length fs\n\ngoal (1 subgoal):\n 1. gs.d (Suc j) * gs.\\<mu> ii j \\<in> \\<int>", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < length fs\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>\n  j \\<le> ii\n  ii < length fs\n\ngoal (1 subgoal):\n 1. gs.d (Suc j) * gs.\\<mu> ii j \\<in> \\<int>", "by (intro gs.d_mu_Ints) (auto)"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fs_int_mu_d_Z_m_m:\n  assumes j: \"j < m\" and ii: \"ii < m\" \n  shows \"of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "proof (cases \"j \\<le> ii\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j \\<le> ii \\<Longrightarrow>\n    rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>\n 2. \\<not> j \\<le> ii \\<Longrightarrow>\n    rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "case True"], ["proof (state)\nthis:\n  j \\<le> ii\n\ngoal (2 subgoals):\n 1. j \\<le> ii \\<Longrightarrow>\n    rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>\n 2. \\<not> j \\<le> ii \\<Longrightarrow>\n    rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  j \\<le> ii\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "using fs_int_mu_d_Z[OF True ii]"], ["proof (prove)\nusing this:\n  j \\<le> ii\n  rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> ii \\<Longrightarrow>\n    rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j \\<le> ii \\<Longrightarrow>\n    rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "case False"], ["proof (state)\nthis:\n  \\<not> j \\<le> ii\n\ngoal (1 subgoal):\n 1. \\<not> j \\<le> ii \\<Longrightarrow>\n    rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> j \\<le> ii\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>", "by (simp add: gs.\\<mu>.simps)"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sq_norm_fs_via_sum_mu_gso: assumes i: \"i < m\" \n  shows \"of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 = (\\<Sum>j\\<leftarrow>[0..<Suc i]. (gs.\\<mu> i j)\\<^sup>2 * \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "let ?G = \"map (gs.gso) [0 ..< m]\""], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "let ?gso = \"\\<lambda> fs j. ?G ! j\""], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "have \"of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 = \\<parallel>RAT fs ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2", "unfolding sq_norm_of_int[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>of_int_hom.vec_hom (fs ! i)\\<parallel>\\<^sup>2 =\n    \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2", "using insert i"], ["proof (prove)\nusing this:\n  ListMem ?x ?xs \\<Longrightarrow> ListMem ?x (?y # ?xs)\n  i < length fs\n\ngoal (1 subgoal):\n 1. \\<parallel>of_int_hom.vec_hom (fs ! i)\\<parallel>\\<^sup>2 =\n    \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "also"], ["proof (state)\nthis:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "have \"RAT fs ! i = gs.sumlist (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i =\n    gs.M.sumlist\n     (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i])", "using gs.fi_is_sum_of_mu_gso i"], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  map of_int_hom.vec_hom fs ! ?i =\n  gs.M.sumlist\n   (map (\\<lambda>j. gs.\\<mu> ?i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc ?i])\n  i < length fs\n\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! i =\n    gs.M.sumlist\n     (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i])", "by auto"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i =\n  gs.M.sumlist\n   (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i])\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! i =\n  gs.M.sumlist\n   (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i])\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "have id: \"map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i] = map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v ?gso fs j) [0..<Suc i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i] =\n    map (\\<lambda>j.\n            gs.\\<mu> i j \\<cdot>\\<^sub>v map gs.gso [0..<length fs] ! j)\n     [0..<Suc i]", "by (rule nth_equalityI, insert i, auto simp: nth_append)"], ["proof (state)\nthis:\n  map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i] =\n  map (\\<lambda>j.\n          gs.\\<mu> i j \\<cdot>\\<^sub>v map gs.gso [0..<length fs] ! j)\n   [0..<Suc i]\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "also"], ["proof (state)\nthis:\n  map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i] =\n  map (\\<lambda>j.\n          gs.\\<mu> i j \\<cdot>\\<^sub>v map gs.gso [0..<length fs] ! j)\n   [0..<Suc i]\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "have \"sq_norm (gs.sumlist \\<dots>) = sum_list (map sq_norm (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs.M.sumlist\n                (map (\\<lambda>j.\n                         gs.\\<mu> i j \\<cdot>\\<^sub>v\n                         map gs.gso [0..<length fs] ! j)\n                  [0..<Suc i])\\<parallel>\\<^sup>2 =\n    sum_list\n     (map sq_norm\n       (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j)\n         [0..<Suc i]))", "unfolding map_map o_def sq_norm_smult_vec"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs.M.sumlist\n                (map (\\<lambda>j.\n                         gs.\\<mu> i j \\<cdot>\\<^sub>v\n                         map gs.gso [0..<length fs] ! j)\n                  [0..<Suc i])\\<parallel>\\<^sup>2 =\n    (\\<Sum>x\\<leftarrow>[0..<\n                         Suc i]. sq_norm_conjugate (gs.\\<mu> i x) *\n                                 \\<parallel>gs.gso x\\<parallel>\\<^sup>2)", "unfolding sq_norm_vec_as_cscalar_prod cscalar_prod_is_scalar_prod conjugate_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j.\n              gs.\\<mu> i j \\<cdot>\\<^sub>v map gs.gso [0..<length fs] ! j)\n       [0..<Suc i]) \\<bullet>\n    gs.M.sumlist\n     (map (\\<lambda>j.\n              gs.\\<mu> i j \\<cdot>\\<^sub>v map gs.gso [0..<length fs] ! j)\n       [0..<Suc i]) =\n    (\\<Sum>x\\<leftarrow>[0..<\n                         Suc i]. gs.\\<mu> i x * gs.\\<mu> i x *\n                                 (gs.gso x \\<bullet> gs.gso x))", "proof (subst gs.scalar_prod_lincomb_orthogonal)"], ["proof (state)\ngoal (4 subgoals):\n 1. orthogonal (map gs.gso [0..<length fs])\n 2. set (map gs.gso [0..<length fs]) \\<subseteq> carrier_vec n\n 3. Suc i \\<le> length (map gs.gso [0..<length fs])\n 4. (\\<Sum>ia\\<leftarrow>[0..<\n                          Suc i]. gs.\\<mu> i ia * gs.\\<mu> i ia *\n                                  (map gs.gso [0..<length fs] ! ia \\<bullet>\n                                   map gs.gso [0..<length fs] ! ia)) =\n    (\\<Sum>x\\<leftarrow>[0..<\n                         Suc i]. gs.\\<mu> i x * gs.\\<mu> i x *\n                                 (gs.gso x \\<bullet> gs.gso x))", "show \"Suc i \\<le> length ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i \\<le> length (map gs.gso [0..<length fs])", "using i"], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. Suc i \\<le> length (map gs.gso [0..<length fs])", "by auto"], ["proof (state)\nthis:\n  Suc i \\<le> length (map gs.gso [0..<length fs])\n\ngoal (3 subgoals):\n 1. orthogonal (map gs.gso [0..<length fs])\n 2. set (map gs.gso [0..<length fs]) \\<subseteq> carrier_vec n\n 3. (\\<Sum>ia\\<leftarrow>[0..<\n                          Suc i]. gs.\\<mu> i ia * gs.\\<mu> i ia *\n                                  (map gs.gso [0..<length fs] ! ia \\<bullet>\n                                   map gs.gso [0..<length fs] ! ia)) =\n    (\\<Sum>x\\<leftarrow>[0..<\n                         Suc i]. gs.\\<mu> i x * gs.\\<mu> i x *\n                                 (gs.gso x \\<bullet> gs.gso x))", "show \"set ?G \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map gs.gso [0..<length fs]) \\<subseteq> carrier_vec n", "using gs.gso_carrier"], ["proof (prove)\nusing this:\n  ?i < length (map of_int_hom.vec_hom fs) \\<Longrightarrow>\n  gs.gso ?i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (map gs.gso [0..<length fs]) \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (map gs.gso [0..<length fs]) \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. orthogonal (map gs.gso [0..<length fs])\n 2. (\\<Sum>ia\\<leftarrow>[0..<\n                          Suc i]. gs.\\<mu> i ia * gs.\\<mu> i ia *\n                                  (map gs.gso [0..<length fs] ! ia \\<bullet>\n                                   map gs.gso [0..<length fs] ! ia)) =\n    (\\<Sum>x\\<leftarrow>[0..<\n                         Suc i]. gs.\\<mu> i x * gs.\\<mu> i x *\n                                 (gs.gso x \\<bullet> gs.gso x))", "show \"orthogonal ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal (map gs.gso [0..<length fs])", "using gs.orthogonal_gso"], ["proof (prove)\nusing this:\n  orthogonal (map gs.gso [0..<length (map of_int_hom.vec_hom fs)])\n\ngoal (1 subgoal):\n 1. orthogonal (map gs.gso [0..<length fs])", "by auto"], ["proof (state)\nthis:\n  orthogonal (map gs.gso [0..<length fs])\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<leftarrow>[0..<\n                          Suc i]. gs.\\<mu> i ia * gs.\\<mu> i ia *\n                                  (map gs.gso [0..<length fs] ! ia \\<bullet>\n                                   map gs.gso [0..<length fs] ! ia)) =\n    (\\<Sum>x\\<leftarrow>[0..<\n                         Suc i]. gs.\\<mu> i x * gs.\\<mu> i x *\n                                 (gs.gso x \\<bullet> gs.gso x))", "qed (rule arg_cong[of _ _ sum_list], intro nth_equalityI, insert i, auto simp: nth_append)"], ["proof (state)\nthis:\n  \\<parallel>gs.M.sumlist\n              (map (\\<lambda>j.\n                       gs.\\<mu> i j \\<cdot>\\<^sub>v\n                       map gs.gso [0..<length fs] ! j)\n                [0..<Suc i])\\<parallel>\\<^sup>2 =\n  sum_list\n   (map sq_norm\n     (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i]))\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "also"], ["proof (state)\nthis:\n  \\<parallel>gs.M.sumlist\n              (map (\\<lambda>j.\n                       gs.\\<mu> i j \\<cdot>\\<^sub>v\n                       map gs.gso [0..<length fs] ! j)\n                [0..<Suc i])\\<parallel>\\<^sup>2 =\n  sum_list\n   (map sq_norm\n     (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i]))\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "have \"map sq_norm (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i]) = map (\\<lambda>j. (gs.\\<mu> i j)^2 * sq_norm (gs.gso j)) [0..<Suc i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map sq_norm\n     (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i]) =\n    map (\\<lambda>j.\n            (gs.\\<mu> i j)\\<^sup>2 * \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\n     [0..<Suc i]", "unfolding map_map o_def sq_norm_smult_vec"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x.\n            sq_norm_conjugate (gs.\\<mu> i x) *\n            \\<parallel>gs.gso x\\<parallel>\\<^sup>2)\n     [0..<Suc i] =\n    map (\\<lambda>j.\n            (gs.\\<mu> i j)\\<^sup>2 * \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\n     [0..<Suc i]", "by (rule map_cong, auto simp: power2_eq_square)"], ["proof (state)\nthis:\n  map sq_norm\n   (map (\\<lambda>j. gs.\\<mu> i j \\<cdot>\\<^sub>v gs.gso j) [0..<Suc i]) =\n  map (\\<lambda>j.\n          (gs.\\<mu> i j)\\<^sup>2 * \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\n   [0..<Suc i]\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                               \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                               \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>gs.gso j\\<parallel>\\<^sup>2)", "."], ["proof (state)\nthis:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc i]. (gs.\\<mu> i j)\\<^sup>2 *\n                               \\<parallel>gs.gso j\\<parallel>\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d\\<mu>: assumes \"j < m\" \"ii < m\" \n  shows \"of_int (d\\<mu> ii j) = of_int (d fs (Suc j)) * gs.\\<mu> ii j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d\\<mu> ii j) = rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j", "unfolding d\\<mu>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (int_of_rat (rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j)) =\n    rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j", "using fs_int_mu_d_Z_m_m assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j < length fs; ?ii < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (d fs (Suc ?j)) * gs.\\<mu> ?ii ?j\n                    \\<in> \\<int>\n  j < length fs\n  ii < length fs\n\ngoal (1 subgoal):\n 1. rat_of_int (int_of_rat (rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j)) =\n    rat_of_int (d fs (Suc j)) * gs.\\<mu> ii j", "by auto"], ["", "end"], ["", "end"]]}