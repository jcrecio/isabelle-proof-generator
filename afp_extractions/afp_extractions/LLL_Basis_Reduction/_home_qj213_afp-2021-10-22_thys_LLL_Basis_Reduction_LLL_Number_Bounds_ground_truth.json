{"file_name": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction/LLL_Number_Bounds.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction", "problem_names": ["lemma bound_invD: assumes \"LLL_bound_invariant outside upw i fs\" \n  shows \"LLL_invariant upw i fs\" \"f_bound outside i fs\" \"g_bound fs\"", "lemma bound_invI: assumes \"LLL_invariant upw i fs\" \"f_bound outside i fs\" \"g_bound fs\" \n  shows \"LLL_bound_invariant outside upw i fs\"", "lemma \\<mu>_bound_rowI: assumes \"\\<And> j. j \\<le> i \\<Longrightarrow> (\\<mu> fs i j)^2 \\<le> bnd\"\n  shows \"\\<mu>_bound_row fs bnd i\"", "lemma \\<mu>_bound_rowD: assumes \"\\<mu>_bound_row fs bnd i\" \"j \\<le> i\"\n  shows \"(\\<mu> fs i j)^2 \\<le> bnd\"", "lemma \\<mu>_bound_row_1: assumes \"\\<mu>_bound_row fs bnd i\" \n  shows \"bnd \\<ge> 1\"", "lemma reduced_\\<mu>_bound_row: assumes red: \"reduced fs i\"  \n  and ii: \"ii < i\" \nshows \"\\<mu>_bound_row fs 1 ii\"", "lemma f_bound_True_arbitrary: assumes \"f_bound True ii fs\"\n  shows \"f_bound outside j fs\"", "lemma sq_norm_fs_mu_g_bound: assumes i: \"i < m\" \n  and mu_bound: \"\\<mu>_bound_row fs bnd i\" \n  and g_bound: \"g_bound fs\" \nshows \"of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> of_nat (Suc i * N) * bnd\"", "lemma increase_i_bound: assumes LLL: \"LLL_bound_invariant True upw i fs\" \n  and i: \"i < m\" \n  and upw: \"upw \\<Longrightarrow> i = 0\" \n  and red_i: \"i \\<noteq> 0 \\<Longrightarrow> sq_norm (gso fs (i - 1)) \\<le> \\<alpha> * sq_norm (gso fs i)\"\nshows \"LLL_bound_invariant True True (Suc i) fs\"", "lemma basis_reduction_add_row_main_bound: assumes Linv: \"LLL_bound_invariant False True i fs\"\n  and i: \"i < m\"  and j: \"j < i\" \n  and c: \"c = round (\\<mu> fs i j)\" \n  and fs': \"fs' = fs[ i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]\" \n  and mu_small: \"\\<mu>_small_row i fs (Suc j)\" \n  and mu_bnd: \"\\<mu>_bound_row_inner fs i (Suc j)\" \nshows \"LLL_bound_invariant False True i fs'\"\n  \"\\<mu>_bound_row_inner fs' i j\"", "lemma basis_reduction_add_rows_enter_bound: assumes binv: \"LLL_bound_invariant True True i fs\"\n  and i: \"i < m\"   \nshows \"LLL_bound_invariant False True i fs\"\n  \"\\<mu>_bound_row_inner fs i i\"", "lemma basis_basis_reduction_add_rows_loop_leave:\n  assumes binv: \"LLL_bound_invariant False True i fs\" \n  and mu_small: \"\\<mu>_small_row i fs 0\"\n  and mu_bnd: \"\\<mu>_bound_row_inner fs i 0\" \n  and i: \"i < m\" \nshows \"LLL_bound_invariant True False i fs\"", "lemma basis_reduction_add_rows_loop_bound: assumes\n  binv: \"LLL_bound_invariant False True i fs\" \n  and mu_small: \"\\<mu>_small_row i fs j\"\n  and mu_bnd: \"\\<mu>_bound_row_inner fs i j\" \n  and res: \"basis_reduction_add_rows_loop i fs j = fs'\" \n  and i: \"i < m\" \n  and j: \"j \\<le> i\" \nshows \"LLL_bound_invariant True False i fs'\"", "lemma basis_reduction_add_rows_bound: assumes \n  binv: \"LLL_bound_invariant True upw i fs\" \n  and res: \"basis_reduction_add_rows upw i fs = fs'\" \n  and i: \"i < m\" \nshows \"LLL_bound_invariant True False i fs'\"", "lemma g_bnd_swap:  \n  assumes i: \"i < m\" \"i \\<noteq> 0\"\n  and Linv: \"LLL_invariant_weak fs\"\n  and mu_F1_i: \"\\<bar>\\<mu> fs i (i-1)\\<bar> \\<le> 1 / 2\"\n  and cond: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\" \n  and fs'_def: \"fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]\" \n  and g_bnd: \"g_bnd B fs\" \nshows \"g_bnd B fs'\"", "lemma basis_reduction_swap_bound: assumes \n  binv: \"LLL_bound_invariant True False i fs\" \n  and res: \"basis_reduction_swap i fs = (upw',i',fs')\" \n  and cond: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\" \n  and i: \"i < m\" \"i \\<noteq> 0\" \nshows \"LLL_bound_invariant True upw' i' fs'\"", "lemma basis_reduction_step_bound: assumes \n  binv: \"LLL_bound_invariant True upw i fs\" \n  and res: \"basis_reduction_step upw i fs = (upw',i',fs')\" \n  and i: \"i < m\" \nshows \"LLL_bound_invariant True upw' i' fs'\"", "lemma basis_reduction_main_bound: assumes \"LLL_bound_invariant True upw i fs\" \n  and res: \"basis_reduction_main (upw,i,fs) = fs'\" \nshows \"LLL_bound_invariant True True m fs'\"", "lemma LLL_inv_initial_state_bound: \"LLL_bound_invariant True True 0 fs_init\"", "lemma reduce_basis_bound: assumes res: \"reduce_basis = fs\" \n  shows \"LLL_bound_invariant True True m fs\"", "lemma f_bnd_mono: \"f_bnd outside \\<le> f_bnd False\"", "lemma aux_bnd_mono: \"N * m \\<le> (4 ^ (m - 1) * N ^ m * m * m)\"", "lemma LLL_f_bnd: \n  assumes i: \"i < m\" and j: \"j < n\" \nshows \"\\<bar>fs ! i $ j\\<bar> \\<le> f_bnd outside\"", "lemma LLL_gso_bound:\n  assumes i: \"i < m\" and j: \"j < n\" \n  and quot: \"quotient_of (gso fs i $ j) = (num, denom)\" \nshows \"\\<bar>num\\<bar>   \\<le> N ^ m\" \n  and \"\\<bar>denom\\<bar> \\<le> N ^ m\"", "lemma LLL_f_bound:\n  assumes i: \"i < m\" and j: \"j < n\" \nshows \"\\<bar>fs ! i $ j\\<bar> \\<le> N ^ m * 2 ^ (m - 1) * m\"", "lemma LLL_d_bound: \n  assumes i: \"i \\<le> m\"   \nshows \"abs (d fs i) \\<le> N ^ i \\<and> abs (d fs i) \\<le> N ^ m\"", "lemma LLL_mu_abs_bound: \n  assumes i: \"i < m\"\n  and j: \"j < i\" \nshows \"\\<bar>\\<mu> fs i j\\<bar> \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\"", "lemma LLL_d\\<mu>_bound: \n  assumes i: \"i < m\" and j: \"j < i\"  \nshows \"abs (d\\<mu> fs i j) \\<le> N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m\"", "lemma LLL_mu_num_denom_bound: \n  assumes i: \"i < m\"                 \n  and quot: \"quotient_of (\\<mu> fs i j) = (num, denom)\" \nshows \"\\<bar>num\\<bar>   \\<le> N ^ (2 * m) * 2 ^ m * m\" \n  and \"\\<bar>denom\\<bar> \\<le> N ^ m\"", "lemma logN_le_2log_Mn: assumes m: \"m \\<noteq> 0\" \"n \\<noteq> 0\" and N: \"N > 0\" \n  shows \"log 2 N \\<le> 2 * log 2 (M * n)\"", "lemma combined_size_bound: fixes number :: int \n  assumes i: \"i < m\" and j: \"j < n\"\n  and x: \"x \\<in> {of_int (fs ! i $ j), gso fs i $ j, \\<mu> fs i j}\" \n  and quot: \"quotient_of x = (num, denom)\" \n  and number: \"number \\<in> {num, denom}\" \n  and number0: \"number \\<noteq> 0\" \nshows \"log 2 \\<bar>number\\<bar> \\<le> 2 * m * log 2 N       + m + log 2 m\" \n      \"log 2 \\<bar>number\\<bar> \\<le> 4 * m * log 2 (M * n) + m + log 2 m\"", "lemma fs_gs_N_N': assumes \"m \\<noteq> 0\"\n  shows \"fs.gs.N = of_nat N\"", "lemma fs_gs_N_N: \"m \\<noteq> 0 \\<Longrightarrow> real_of_rat fs.gs.N = real N\"", "lemma combined_size_bound_gso_integer:\n  assumes \"x \\<in> \n    {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union> \n    {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\"\n  and m: \"m \\<noteq> 0\" and \"x \\<noteq> 0\" \"n \\<noteq> 0\"\nshows \"log 2 \\<bar>real_of_int x\\<bar> \\<le> (6 + 6 * m) * log 2 (M * n) + log 2 m + m\"", "lemma combined_size_bound_integer':  \n  assumes x: \"x \\<in> {fs ! i $ j | i j. i < m \\<and> j < n} \n    \\<union> {d\\<mu> fs i j | i j. j < i \\<and> i < m} \n    \\<union> {d fs i | i. i \\<le> m}\" \n    (is \"x \\<in> ?fs \\<union> ?d\\<mu> \\<union> ?d\")\n  and m: \"m \\<noteq> 0\" and n: \"n \\<noteq> 0\" \nshows \"abs x \\<le> N ^ (2 * m) * 2 ^ m * m\"\n  \"x \\<noteq> 0 \\<Longrightarrow> log 2 \\<bar>x\\<bar> \\<le> 2 * m * log 2 N       + m + log 2 m\" (is \"_ \\<Longrightarrow> ?l1 \\<le> ?b1\")\n  \"x \\<noteq> 0 \\<Longrightarrow> log 2 \\<bar>x\\<bar> \\<le> 4 * m * log 2 (M * n) + m + log 2 m\" (is \"_ \\<Longrightarrow> _ \\<le> ?b2\")", "lemma combined_size_bound_integer:  \n  assumes x: \"x \\<in> \n      {fs ! i $ j | i j. i < m \\<and> j < n} \n    \\<union> {d\\<mu> fs i j | i j. j < i \\<and> i < m} \n    \\<union> {d fs i | i. i \\<le> m}\n    \\<union> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m}\n    \\<union> {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\"\n    (is \"?x \\<in> ?s1 \\<union> ?s2 \\<union> ?s3 \\<union> ?g1 \\<union> ?g2\")\n  and m: \"m \\<noteq> 0\" and n: \"n \\<noteq> 0\" and \"x \\<noteq> 0\" and \"0 < M\"\nshows \"log 2 \\<bar>x\\<bar> \\<le> (6 + 6 * m) * log 2 (M * n) + log 2 m + m\""], "translations": [["", "lemma bound_invD: assumes \"LLL_bound_invariant outside upw i fs\" \n  shows \"LLL_invariant upw i fs\" \"f_bound outside i fs\" \"g_bound fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant upw i fs &&& f_bound outside i fs &&& g_bound fs", "using assms"], ["proof (prove)\nusing this:\n  LLL_bound_invariant outside upw i fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw i fs &&& f_bound outside i fs &&& g_bound fs", "unfolding LLL_bound_invariant_def"], ["proof (prove)\nusing this:\n  LLL_invariant upw i fs \\<and> f_bound outside i fs \\<and> g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw i fs &&& f_bound outside i fs &&& g_bound fs", "by auto"], ["", "lemma bound_invI: assumes \"LLL_invariant upw i fs\" \"f_bound outside i fs\" \"g_bound fs\" \n  shows \"LLL_bound_invariant outside upw i fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant outside upw i fs", "using assms"], ["proof (prove)\nusing this:\n  LLL_invariant upw i fs\n  f_bound outside i fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant outside upw i fs", "unfolding LLL_bound_invariant_def"], ["proof (prove)\nusing this:\n  LLL_invariant upw i fs\n  f_bound outside i fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw i fs \\<and> f_bound outside i fs \\<and> g_bound fs", "by auto"], ["", "lemma \\<mu>_bound_rowI: assumes \"\\<And> j. j \\<le> i \\<Longrightarrow> (\\<mu> fs i j)^2 \\<le> bnd\"\n  shows \"\\<mu>_bound_row fs bnd i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>_bound_row fs bnd i", "using assms"], ["proof (prove)\nusing this:\n  ?j1 \\<le> i \\<Longrightarrow>\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i ?j1)\\<^sup>2\n  \\<le> bnd\n\ngoal (1 subgoal):\n 1. \\<mu>_bound_row fs bnd i", "unfolding \\<mu>_bound_row_def"], ["proof (prove)\nusing this:\n  ?j1 \\<le> i \\<Longrightarrow>\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i ?j1)\\<^sup>2\n  \\<le> bnd\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>i.\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n       \\<le> bnd", "by auto"], ["", "lemma \\<mu>_bound_rowD: assumes \"\\<mu>_bound_row fs bnd i\" \"j \\<le> i\"\n  shows \"(\\<mu> fs i j)^2 \\<le> bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n    \\<le> bnd", "using assms"], ["proof (prove)\nusing this:\n  \\<mu>_bound_row fs bnd i\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n    \\<le> bnd", "unfolding \\<mu>_bound_row_def"], ["proof (prove)\nusing this:\n  \\<forall>j\\<le>i.\n     (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n     \\<le> bnd\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n    \\<le> bnd", "by auto"], ["", "lemma \\<mu>_bound_row_1: assumes \"\\<mu>_bound_row fs bnd i\" \n  shows \"bnd \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> bnd", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> bnd", "interpret gs1: gram_schmidt_fs n \"RAT fs\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> bnd", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> bnd", "using \\<mu>_bound_rowD[OF assms, of i]"], ["proof (prove)\nusing this:\n  i \\<le> i \\<Longrightarrow> (gs1.\\<mu> i i)\\<^sup>2 \\<le> bnd\n\ngoal (1 subgoal):\n 1. 1 \\<le> bnd", "by (auto simp: gs1.\\<mu>.simps)"], ["proof (state)\nthis:\n  1 \\<le> bnd\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduced_\\<mu>_bound_row: assumes red: \"reduced fs i\"  \n  and ii: \"ii < i\" \nshows \"\\<mu>_bound_row fs 1 ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>_bound_row fs 1 ii", "proof (intro \\<mu>_bound_rowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> ii \\<Longrightarrow>\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii j)\\<^sup>2\n       \\<le> 1", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> ii \\<Longrightarrow>\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii j)\\<^sup>2\n       \\<le> 1", "assume \"j \\<le> ii\""], ["proof (state)\nthis:\n  j \\<le> ii\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> ii \\<Longrightarrow>\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ii j)\\<^sup>2\n       \\<le> 1", "interpret gs1: gram_schmidt_fs n \"RAT fs\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. j \\<le> ii \\<Longrightarrow> (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1", "show \"(\\<mu> fs ii j)^2 \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1", "proof (cases \"j < ii\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < ii \\<Longrightarrow> (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1\n 2. \\<not> j < ii \\<Longrightarrow> (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1", "case True"], ["proof (state)\nthis:\n  j < ii\n\ngoal (2 subgoals):\n 1. j < ii \\<Longrightarrow> (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1\n 2. \\<not> j < ii \\<Longrightarrow> (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1", "from red[unfolded gram_schmidt_fs.reduced_def, THEN conjunct2, rule_format, OF ii True]"], ["proof (chain)\npicking this:\n  \\<bar>gs1.\\<mu> ii j\\<bar> \\<le> 1 / 2", "have \"abs (\\<mu> fs ii j) \\<le> 1/2\""], ["proof (prove)\nusing this:\n  \\<bar>gs1.\\<mu> ii j\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<bar>gs1.\\<mu> ii j\\<bar> \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>gs1.\\<mu> ii j\\<bar> \\<le> 1 / 2\n\ngoal (2 subgoals):\n 1. j < ii \\<Longrightarrow> (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1\n 2. \\<not> j < ii \\<Longrightarrow> (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1", "from mult_mono[OF this this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> 1 / 2; 0 \\<le> \\<bar>gs1.\\<mu> ii j\\<bar>\\<rbrakk>\n  \\<Longrightarrow> \\<bar>gs1.\\<mu> ii j\\<bar> * \\<bar>gs1.\\<mu> ii j\\<bar>\n                    \\<le> 1 / 2 * (1 / 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1 / 2; 0 \\<le> \\<bar>gs1.\\<mu> ii j\\<bar>\\<rbrakk>\n  \\<Longrightarrow> \\<bar>gs1.\\<mu> ii j\\<bar> * \\<bar>gs1.\\<mu> ii j\\<bar>\n                    \\<le> 1 / 2 * (1 / 2)\n\ngoal (1 subgoal):\n 1. (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1", "by (auto simp: power2_eq_square)"], ["proof (state)\nthis:\n  (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> j < ii \\<Longrightarrow> (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1", "qed (auto simp: gs1.\\<mu>.simps)"], ["proof (state)\nthis:\n  (gs1.\\<mu> ii j)\\<^sup>2 \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma f_bound_True_arbitrary: assumes \"f_bound True ii fs\"\n  shows \"f_bound outside j fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_bound outside j fs", "unfolding f_bound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<m.\n       \\<parallel>fs ! i\\<parallel>\\<^sup>2\n       \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n              else int (4 ^ (m - 1) * N ^ m * m * m))", "proof (intro allI impI, rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "case (1 i)"], ["proof (state)\nthis:\n  i < m\n  \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n         \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "from 1"], ["proof (chain)\npicking this:\n  i < m\n  \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n         \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                else int (4 ^ (m - 1) * N ^ m * m * m))", "have nz: \"\\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i < m\n  \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n         \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<noteq> 0", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "hence gt: \"\\<parallel>fs ! i\\<parallel>\\<^sup>2 > 0\""], ["proof (prove)\nusing this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < \\<parallel>fs ! i\\<parallel>\\<^sup>2", "using sq_norm_vec_ge_0[of \"fs ! i\"]"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<noteq> 0\n  0 \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 < \\<parallel>fs ! i\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  0 < \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "from assms(1)[unfolded f_bound_def, rule_format, OF 1(1)]"], ["proof (chain)\npicking this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> (if i \\<noteq> ii \\<or> True then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))", "have one: \"\\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (N * m) * 1\""], ["proof (prove)\nusing this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> (if i \\<noteq> ii \\<or> True then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (N * m) * 1", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (N * m) * 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "from less_le_trans[OF gt one]"], ["proof (chain)\npicking this:\n  0 < int (N * m) * 1", "have N0: \"N \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < int (N * m) * 1\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0", "by (cases \"N = 0\", auto)"], ["proof (state)\nthis:\n  N \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "note one"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (N * m) * 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (N * m) * 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "have \"int (N * m) * 1 \\<le> int (N * m) * int (4 ^ (m - 1) * N ^ (m - 1) * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (N * m) * 1 \\<le> int (N * m) * int (4 ^ (m - 1) * N ^ (m - 1) * m)", "by (rule mult_left_mono, unfold of_nat_mult, intro mult_ge_one, insert 1 N0, auto)"], ["proof (state)\nthis:\n  int (N * m) * 1 \\<le> int (N * m) * int (4 ^ (m - 1) * N ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  int (N * m) * 1 \\<le> int (N * m) * int (4 ^ (m - 1) * N ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = int (4 ^ (m - 1) * N ^ (Suc (m - 1)) * m * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (N * m) * int (4 ^ (m - 1) * N ^ (m - 1) * m) =\n    int (4 ^ (m - 1) * N ^ Suc (m - 1) * m * m)", "unfolding of_nat_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. int N * int m * (int (4 ^ (m - 1)) * int (N ^ (m - 1)) * int m) =\n    int (4 ^ (m - 1)) * int (N ^ Suc (m - 1)) * int m * int m", "by simp"], ["proof (state)\nthis:\n  int (N * m) * int (4 ^ (m - 1) * N ^ (m - 1) * m) =\n  int (4 ^ (m - 1) * N ^ Suc (m - 1) * m * m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  int (N * m) * int (4 ^ (m - 1) * N ^ (m - 1) * m) =\n  int (4 ^ (m - 1) * N ^ Suc (m - 1) * m * m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "have \"Suc (m - 1) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (m - 1) = m", "using 1"], ["proof (prove)\nusing this:\n  i < m\n  \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n         \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. Suc (m - 1) = m", "by simp"], ["proof (state)\nthis:\n  Suc (m - 1) = m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < m;\n        \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n               \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                      else int (4 ^ (m - 1) * N ^ m * m * m))\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> int (4 ^ (m - 1) * N ^ m * m * m)", "show ?case"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> int (4 ^ (m - 1) * N ^ m * m * m)\n\ngoal (1 subgoal):\n 1. False", "using one 1"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> int (4 ^ (m - 1) * N ^ m * m * m)\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (N * m) * 1\n  i < m\n  \\<not> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n         \\<le> (if i \\<noteq> j \\<or> outside then int (N * m)\n                else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. False", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "context fixes fs :: \"int vec list\" \n  assumes lin_indep: \"lin_indep fs\" \n  and len: \"length fs = m\" \nbegin"], ["", "interpretation fs: fs_int_indpt n fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int_indpt n fs", "by (standard) (use lin_indep in simp)"], ["", "lemma sq_norm_fs_mu_g_bound: assumes i: \"i < m\" \n  and mu_bound: \"\\<mu>_bound_row fs bnd i\" \n  and g_bound: \"g_bound fs\" \nshows \"of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> of_nat (Suc i * N) * bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) * bnd", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) * bnd", "have \"of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 = (\\<Sum>j\\<leftarrow>[0..<Suc i]. (\\<mu> fs i j)\\<^sup>2 * \\<parallel>gso fs j\\<parallel>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (fs.gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)", "by (rule fs.sq_norm_fs_via_sum_mu_gso) (use assms lin_indep len in auto)"], ["proof (state)\nthis:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc i]. (fs.gs.\\<mu> i j)\\<^sup>2 *\n                               \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) * bnd", "also"], ["proof (state)\nthis:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc i]. (fs.gs.\\<mu> i j)\\<^sup>2 *\n                               \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) * bnd", "have \"\\<dots> \\<le> (\\<Sum>j\\<leftarrow>[0..<Suc i]. bnd * of_nat N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<\n                         Suc i]. (fs.gs.\\<mu> i j)\\<^sup>2 *\n                                 \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n    \\<le> (\\<Sum>j\\<leftarrow>[0..<Suc i]. bnd * rat_of_nat N)", "proof (rule sum_list_ge_mono, force, unfold length_map length_upt,\n    subst (1 2) nth_map_upt, force, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < Suc i - 0 \\<Longrightarrow>\n       (fs.gs.\\<mu> i (0 + ia))\\<^sup>2 *\n       \\<parallel>fs.gs.gso (0 + ia)\\<parallel>\\<^sup>2\n       \\<le> bnd * rat_of_nat N", "case (1 j)"], ["proof (state)\nthis:\n  j < Suc i - 0\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < Suc i - 0 \\<Longrightarrow>\n       (fs.gs.\\<mu> i (0 + ia))\\<^sup>2 *\n       \\<parallel>fs.gs.gso (0 + ia)\\<parallel>\\<^sup>2\n       \\<le> bnd * rat_of_nat N", "hence ji: \"j \\<le> i\""], ["proof (prove)\nusing this:\n  j < Suc i - 0\n\ngoal (1 subgoal):\n 1. j \\<le> i", "by auto"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < Suc i - 0 \\<Longrightarrow>\n       (fs.gs.\\<mu> i (0 + ia))\\<^sup>2 *\n       \\<parallel>fs.gs.gso (0 + ia)\\<parallel>\\<^sup>2\n       \\<le> bnd * rat_of_nat N", "from g_bound[unfolded g_bound_def] i ji"], ["proof (chain)\npicking this:\n  \\<forall>i<m. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n  i < m\n  j \\<le> i", "have GB: \"sq_norm (gso fs j) \\<le> of_nat N\""], ["proof (prove)\nusing this:\n  \\<forall>i<m. \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n  i < m\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2 \\<le> rat_of_nat N", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2 \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < Suc i - 0 \\<Longrightarrow>\n       (fs.gs.\\<mu> i (0 + ia))\\<^sup>2 *\n       \\<parallel>fs.gs.gso (0 + ia)\\<parallel>\\<^sup>2\n       \\<le> bnd * rat_of_nat N", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i (0 + j))\\<^sup>2 *\n    \\<parallel>fs.gs.gso (0 + j)\\<parallel>\\<^sup>2\n    \\<le> bnd * rat_of_nat N", "by (rule mult_mono, insert \\<mu>_bound_rowD[OF mu_bound ji]\n          GB order.trans[OF zero_le_power2], auto)"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i (0 + j))\\<^sup>2 *\n  \\<parallel>fs.gs.gso (0 + j)\\<parallel>\\<^sup>2\n  \\<le> bnd * rat_of_nat N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc i]. (fs.gs.\\<mu> i j)\\<^sup>2 *\n                               \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n  \\<le> (\\<Sum>j\\<leftarrow>[0..<Suc i]. bnd * rat_of_nat N)\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) * bnd", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>[0..<\n                       Suc i]. (fs.gs.\\<mu> i j)\\<^sup>2 *\n                               \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n  \\<le> (\\<Sum>j\\<leftarrow>[0..<Suc i]. bnd * rat_of_nat N)\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) * bnd", "have \"\\<dots> = of_nat (Suc i) * (bnd * of_nat N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>[0..<Suc i]. bnd * rat_of_nat N) =\n    rat_of_nat (Suc i) * (bnd * rat_of_nat N)", "unfolding sum_list_triv length_upt"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (Suc i - 0) * (bnd * rat_of_nat N) =\n    rat_of_nat (Suc i) * (bnd * rat_of_nat N)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>[0..<Suc i]. bnd * rat_of_nat N) =\n  rat_of_nat (Suc i) * (bnd * rat_of_nat N)\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) * bnd", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>[0..<Suc i]. bnd * rat_of_nat N) =\n  rat_of_nat (Suc i) * (bnd * rat_of_nat N)\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) * bnd", "have \"\\<dots> = of_nat (Suc i * N) * bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (Suc i) * (bnd * rat_of_nat N) = rat_of_nat (Suc i * N) * bnd", "unfolding of_nat_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (Suc i) * (bnd * rat_of_nat N) =\n    rat_of_nat (Suc i) * rat_of_nat N * bnd", "by simp"], ["proof (state)\nthis:\n  rat_of_nat (Suc i) * (bnd * rat_of_nat N) = rat_of_nat (Suc i * N) * bnd\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) * bnd", "finally"], ["proof (chain)\npicking this:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (Suc i * N) * bnd", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (Suc i * N) * bnd\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) * bnd", "."], ["proof (state)\nthis:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (Suc i * N) * bnd\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma increase_i_bound: assumes LLL: \"LLL_bound_invariant True upw i fs\" \n  and i: \"i < m\" \n  and upw: \"upw \\<Longrightarrow> i = 0\" \n  and red_i: \"i \\<noteq> 0 \\<Longrightarrow> sq_norm (gso fs (i - 1)) \\<le> \\<alpha> * sq_norm (gso fs i)\"\nshows \"LLL_bound_invariant True True (Suc i) fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True (Suc i) fs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True (Suc i) fs", "from bound_invD[OF LLL]"], ["proof (chain)\npicking this:\n  LLL_invariant upw i fs\n  f_bound True i fs\n  g_bound fs", "have LLL: \"LLL_invariant upw i fs\" \n    and \"f_bound True i fs\" and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw i fs\n  f_bound True i fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw i fs &&& f_bound True i fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw i fs\n  f_bound True i fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True (Suc i) fs", "hence fbnd: \"f_bound True (Suc i) fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw i fs\n  f_bound True i fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. f_bound True (Suc i) fs", "by (auto simp: f_bound_def)"], ["proof (state)\nthis:\n  f_bound True (Suc i) fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True (Suc i) fs", "from increase_i[OF LLL i upw red_i]"], ["proof (chain)\npicking this:\n  \\<lbrakk>upw \\<Longrightarrow> upw;\n   i \\<noteq> 0 \\<Longrightarrow> i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant True (Suc i) fs\n  \\<lbrakk>upw \\<Longrightarrow> upw;\n   i \\<noteq> 0 \\<Longrightarrow> i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> LLL_measure (Suc i) fs < LLL_measure i fs", "have inv: \"LLL_invariant True (Suc i) fs\" and \"LLL_measure (Suc i) fs < LLL_measure i fs\" (is ?g2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>upw \\<Longrightarrow> upw;\n   i \\<noteq> 0 \\<Longrightarrow> i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> LLL_invariant True (Suc i) fs\n  \\<lbrakk>upw \\<Longrightarrow> upw;\n   i \\<noteq> 0 \\<Longrightarrow> i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> LLL_measure (Suc i) fs < LLL_measure i fs\n\ngoal (1 subgoal):\n 1. LLL_invariant True (Suc i) fs &&&\n    LLL_measure (Suc i) fs < LLL_measure i fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant True (Suc i) fs\n  LLL_measure (Suc i) fs < LLL_measure i fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True (Suc i) fs", "show \"LLL_bound_invariant True True (Suc i) fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True (Suc i) fs", "by (rule bound_invI[OF inv fbnd gbnd])"], ["proof (state)\nthis:\n  LLL_bound_invariant True True (Suc i) fs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Addition step preserves @{term \"LLL_bound_invariant False\"}\\<close>"], ["", "lemma basis_reduction_add_row_main_bound: assumes Linv: \"LLL_bound_invariant False True i fs\"\n  and i: \"i < m\"  and j: \"j < i\" \n  and c: \"c = round (\\<mu> fs i j)\" \n  and fs': \"fs' = fs[ i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]\" \n  and mu_small: \"\\<mu>_small_row i fs (Suc j)\" \n  and mu_bnd: \"\\<mu>_bound_row_inner fs i (Suc j)\" \nshows \"LLL_bound_invariant False True i fs'\"\n  \"\\<mu>_bound_row_inner fs' i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant False True i fs' &&& \\<mu>_bound_row_inner fs' i j", "proof (rule bound_invI)"], ["proof (state)\ngoal (4 subgoals):\n 1. LLL_invariant True i fs'\n 2. f_bound False i fs'\n 3. g_bound fs'\n 4. \\<mu>_bound_row_inner fs' i j", "from bound_invD[OF Linv]"], ["proof (chain)\npicking this:\n  LLL_invariant True i fs\n  f_bound False i fs\n  g_bound fs", "have Linv: \"LLL_invariant True i fs\" and fbnd: \"f_bound False i fs\" and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant True i fs\n  f_bound False i fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant True i fs &&& f_bound False i fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n  f_bound False i fs\n  g_bound fs\n\ngoal (4 subgoals):\n 1. LLL_invariant True i fs'\n 2. f_bound False i fs'\n 3. g_bound fs'\n 4. \\<mu>_bound_row_inner fs' i j", "note Linvw = LLL_inv_imp_w[OF Linv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (4 subgoals):\n 1. LLL_invariant True i fs'\n 2. f_bound False i fs'\n 3. g_bound fs'\n 4. \\<mu>_bound_row_inner fs' i j", "note main = basis_reduction_add_row_main[OF Linvw i j fs']"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n  LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n  \\<lbrakk>c =\n           round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n   \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i fs' j\n  c =\n  round\n   (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n     j) \\<Longrightarrow>\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n  \\<le> 1 / 2\n  LLL_measure i fs' = LLL_measure i fs\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?i =\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i\n  \\<lbrakk>?i' < m; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') ?i'\n                     ?j' =\n                    (if ?i' = i \\<and> ?j' \\<le> j\n                     then gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) i ?j' -\n                          rat_of_int c *\n                          gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) j ?j'\n                     else gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) ?i' ?j')\n  ?ii \\<le> m \\<Longrightarrow> d fs' ?ii = d fs ?ii\n\ngoal (4 subgoals):\n 1. LLL_invariant True i fs'\n 2. f_bound False i fs'\n 3. g_bound fs'\n 4. \\<mu>_bound_row_inner fs' i j", "note main = main(2)[OF Linv] main(3,5-)"], ["proof (state)\nthis:\n  LLL_invariant True i fs'\n  \\<lbrakk>c =\n           round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n   \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i fs' j\n  LLL_measure i fs' = LLL_measure i fs\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?i =\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i\n  \\<lbrakk>?i' < m; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') ?i'\n                     ?j' =\n                    (if ?i' = i \\<and> ?j' \\<le> j\n                     then gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) i ?j' -\n                          rat_of_int c *\n                          gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) j ?j'\n                     else gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) ?i' ?j')\n  ?ii \\<le> m \\<Longrightarrow> d fs' ?ii = d fs ?ii\n\ngoal (4 subgoals):\n 1. LLL_invariant True i fs'\n 2. f_bound False i fs'\n 3. g_bound fs'\n 4. \\<mu>_bound_row_inner fs' i j", "note main = main(1) main(2)[OF c mu_small] main(3-)"], ["proof (state)\nthis:\n  LLL_invariant True i fs'\n  \\<mu>_small_row i fs' j\n  LLL_measure i fs' = LLL_measure i fs\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?i =\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i\n  \\<lbrakk>?i' < m; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') ?i'\n                     ?j' =\n                    (if ?i' = i \\<and> ?j' \\<le> j\n                     then gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) i ?j' -\n                          rat_of_int c *\n                          gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) j ?j'\n                     else gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) ?i' ?j')\n  ?ii \\<le> m \\<Longrightarrow> d fs' ?ii = d fs ?ii\n\ngoal (4 subgoals):\n 1. LLL_invariant True i fs'\n 2. f_bound False i fs'\n 3. g_bound fs'\n 4. \\<mu>_bound_row_inner fs' i j", "show Linv': \"LLL_invariant True i fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True i fs'", "by fact"], ["proof (state)\nthis:\n  LLL_invariant True i fs'\n\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "define bnd :: rat where bnd: \"bnd = 4 ^ (m - 1 - Suc j) * of_nat (N ^ (m - 1) * m)\""], ["proof (state)\nthis:\n  bnd = 4 ^ (m - 1 - Suc j) * rat_of_nat (N ^ (m - 1) * m)\n\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "note mu_bnd = mu_bnd[folded bnd]"], ["proof (state)\nthis:\n  \\<mu>_bound_row fs bnd i\n\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "note inv = LLL_invD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "let ?mu = \"\\<mu> fs\""], ["proof (state)\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "let ?mu' = \"\\<mu> fs'\""], ["proof (state)\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "from j"], ["proof (chain)\npicking this:\n  j < i", "have \"j \\<le> i\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. j \\<le> i", "by simp"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "let ?R = rat_of_int"], ["proof (state)\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "(* (squared) mu bound will increase at most by factor 4 *)"], ["proof (state)\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "have mu_bound_factor: \"\\<mu>_bound_row fs' (4 * bnd) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>_bound_row fs' (4 * bnd) i", "proof (intro \\<mu>_bound_rowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j)\\<^sup>2\n       \\<le> 4 * bnd", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j)\\<^sup>2\n       \\<le> 4 * bnd", "assume ki: \"k \\<le> i\""], ["proof (state)\nthis:\n  k \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j)\\<^sup>2\n       \\<le> 4 * bnd", "from \\<mu>_bound_rowD[OF mu_bnd]"], ["proof (chain)\npicking this:\n  ?j \\<le> i \\<Longrightarrow>\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i ?j)\\<^sup>2\n  \\<le> bnd", "have bnd_i: \"\\<And> j. j \\<le> i \\<Longrightarrow> (?mu i j)^2 \\<le> bnd\""], ["proof (prove)\nusing this:\n  ?j \\<le> i \\<Longrightarrow>\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i ?j)\\<^sup>2\n  \\<le> bnd\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n       \\<le> bnd", "by auto"], ["proof (state)\nthis:\n  ?j1 \\<le> i \\<Longrightarrow>\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i ?j1)\\<^sup>2\n  \\<le> bnd\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j)\\<^sup>2\n       \\<le> 4 * bnd", "have bnd_ik: \"(?mu i k)\\<^sup>2 \\<le> bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k)\\<^sup>2\n    \\<le> bnd", "using bnd_i[OF ki]"], ["proof (prove)\nusing this:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k)\\<^sup>2\n  \\<le> bnd\n\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k)\\<^sup>2\n    \\<le> bnd", "by auto"], ["proof (state)\nthis:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k)\\<^sup>2\n  \\<le> bnd\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j)\\<^sup>2\n       \\<le> 4 * bnd", "have bnd_ij: \"(?mu i j)\\<^sup>2 \\<le> bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n    \\<le> bnd", "using bnd_i[OF \\<open>j \\<le> i\\<close>]"], ["proof (prove)\nusing this:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n  \\<le> bnd\n\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n    \\<le> bnd", "by auto"], ["proof (state)\nthis:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n  \\<le> bnd\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j)\\<^sup>2\n       \\<le> 4 * bnd", "from \\<mu>_bound_row_1[OF mu_bnd]"], ["proof (chain)\npicking this:\n  1 \\<le> bnd", "have bnd1: \"bnd \\<ge> 1\" \"bnd \\<ge> 0\""], ["proof (prove)\nusing this:\n  1 \\<le> bnd\n\ngoal (1 subgoal):\n 1. 1 \\<le> bnd &&& 0 \\<le> bnd", "by auto"], ["proof (state)\nthis:\n  1 \\<le> bnd\n  0 \\<le> bnd\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j)\\<^sup>2\n       \\<le> 4 * bnd", "show \"(?mu' i k)\\<^sup>2 \\<le> 4 * bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "proof (cases \"k > j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd\n 2. \\<not> j < k \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "case True"], ["proof (state)\nthis:\n  j < k\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd\n 2. \\<not> j < k \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "by (subst main(5), (insert True ki i bnd1, auto)[3], intro order.trans[OF bnd_ik], auto)"], ["proof (state)\nthis:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n  \\<le> 4 * bnd\n\ngoal (1 subgoal):\n 1. \\<not> j < k \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < k \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "case False"], ["proof (state)\nthis:\n  \\<not> j < k\n\ngoal (1 subgoal):\n 1. \\<not> j < k \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "hence kj: \"k \\<le> j\""], ["proof (prove)\nusing this:\n  \\<not> j < k\n\ngoal (1 subgoal):\n 1. k \\<le> j", "by auto"], ["proof (state)\nthis:\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> j < k \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "proof (cases \"k = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd\n 2. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "case True"], ["proof (state)\nthis:\n  k = j\n\ngoal (2 subgoals):\n 1. k = j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd\n 2. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "have small: \"abs (?mu' i k) \\<le> 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k\\<bar>\n    \\<le> 1 / 2", "using main(2) j"], ["proof (prove)\nusing this:\n  \\<mu>_small_row i fs' j\n  j < i\n\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k\\<bar>\n    \\<le> 1 / 2", "unfolding True \\<mu>_small_row_def"], ["proof (prove)\nusing this:\n  \\<forall>j'\\<ge>j.\n     j' < i \\<longrightarrow>\n     \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j'\\<bar>\n     \\<le> inverse 2\n  j < i\n\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n    \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k\\<bar>\n  \\<le> 1 / 2\n\ngoal (2 subgoals):\n 1. k = j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd\n 2. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "using mult_mono[OF small small]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1 / 2;\n   0 \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i\n                  k\\<bar>\\<rbrakk>\n  \\<Longrightarrow> \\<bar>gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs') i k\\<bar> *\n                    \\<bar>gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs') i k\\<bar>\n                    \\<le> 1 / 2 * (1 / 2)\n\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "using bnd1"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1 / 2;\n   0 \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i\n                  k\\<bar>\\<rbrakk>\n  \\<Longrightarrow> \\<bar>gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs') i k\\<bar> *\n                    \\<bar>gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs') i k\\<bar>\n                    \\<le> 1 / 2 * (1 / 2)\n  1 \\<le> bnd\n  0 \\<le> bnd\n\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "by (auto simp: power2_eq_square)"], ["proof (state)\nthis:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n  \\<le> 4 * bnd\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "case False"], ["proof (state)\nthis:\n  k \\<noteq> j\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "with kj"], ["proof (chain)\npicking this:\n  k \\<le> j\n  k \\<noteq> j", "have k_j: \"k < j\""], ["proof (prove)\nusing this:\n  k \\<le> j\n  k \\<noteq> j\n\ngoal (1 subgoal):\n 1. k < j", "by auto"], ["proof (state)\nthis:\n  k < j\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "define M where \"M = max (abs (?mu i k)) (max (abs (?mu i j)) (1/2))\""], ["proof (state)\nthis:\n  M =\n  max \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar>\n   (max \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n     (1 / 2))\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "have M0: \"M \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> M", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> max \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                       k\\<bar>\n             (max \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs)\n                         i j\\<bar>\n               (1 / 2))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> M\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "let ?new_mu = \"?mu i k - ?R c * ?mu j k\""], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "have \"abs ?new_mu \\<le> abs (?mu i k) + abs (?R c * ?mu j k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n          rat_of_int c *\n          gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n    \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                 k\\<bar> +\n          \\<bar>rat_of_int c *\n                gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j\n                 k\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n        rat_of_int c *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n  \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n               k\\<bar> +\n        \\<bar>rat_of_int c *\n              gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "also"], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n        rat_of_int c *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n  \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n               k\\<bar> +\n        \\<bar>rat_of_int c *\n              gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "have \"\\<dots> = abs (?mu i k) + abs (?R c) * abs (?mu j k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n    \\<bar>rat_of_int c *\n          gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar> =\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n    \\<bar>rat_of_int c\\<bar> *\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>", "unfolding abs_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n    \\<bar>rat_of_int c\\<bar> *\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar> =\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n    \\<bar>rat_of_int c\\<bar> *\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>", ".."], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n  \\<bar>rat_of_int c *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar> =\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n  \\<bar>rat_of_int c\\<bar> *\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "also"], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n  \\<bar>rat_of_int c *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar> =\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n  \\<bar>rat_of_int c\\<bar> *\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "have \"\\<dots> \\<le> abs (?mu i k) + (abs (?mu i j) + 1/2) * (1/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n    \\<bar>rat_of_int c\\<bar> *\n    \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n    \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                 k\\<bar> +\n          (\\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                  j\\<bar> +\n           1 / 2) *\n          (1 / 2)", "proof (rule add_left_mono[OF mult_mono], unfold c)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<bar>rat_of_int\n           (round\n             (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n               j))\\<bar>\n    \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                 j\\<bar> +\n          1 / 2\n 2. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n    \\<le> 1 / 2\n 3. 0 \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                   j\\<bar> +\n            1 / 2\n 4. 0 \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j\n                   k\\<bar>", "show \"\\<bar>?R (round (?mu i j))\\<bar> \\<le> \\<bar>?mu i j\\<bar> + 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>rat_of_int\n           (round\n             (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n               j))\\<bar>\n    \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                 j\\<bar> +\n          1 / 2", "unfolding round_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>rat_of_int\n           \\<lfloor>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                     j +\n                    1 / 2\\<rfloor>\\<bar>\n    \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                 j\\<bar> +\n          1 / 2", "by linarith"], ["proof (state)\nthis:\n  \\<bar>rat_of_int\n         (round\n           (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j))\\<bar>\n  \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n               j\\<bar> +\n        1 / 2\n\ngoal (3 subgoals):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n    \\<le> 1 / 2\n 2. 0 \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                   j\\<bar> +\n            1 / 2\n 3. 0 \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j\n                   k\\<bar>", "from inv(10)[unfolded gram_schmidt_fs.reduced_def, THEN conjunct2, rule_format, OF \\<open>j < i\\<close> k_j]"], ["proof (chain)\npicking this:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n  \\<le> 1 / 2", "show \"\\<bar>?mu j k\\<bar> \\<le> 1/2\""], ["proof (prove)\nusing this:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n  \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n    \\<le> 1 / 2", "."], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n  \\<le> 1 / 2\n\ngoal (2 subgoals):\n 1. 0 \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                   j\\<bar> +\n            1 / 2\n 2. 0 \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j\n                   k\\<bar>", "qed auto"], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n  \\<bar>rat_of_int c\\<bar> *\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n  \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n               k\\<bar> +\n        (\\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                j\\<bar> +\n         1 / 2) *\n        (1 / 2)\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "also"], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n  \\<bar>rat_of_int c\\<bar> *\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n  \\<le> \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n               k\\<bar> +\n        (\\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                j\\<bar> +\n         1 / 2) *\n        (1 / 2)\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "have \"\\<dots> \\<le> M + (M + M) * (1/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n    (\\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar> +\n     1 / 2) *\n    (1 / 2)\n    \\<le> M + (M + M) * (1 / 2)", "by (rule add_mono[OF _ mult_right_mono[OF add_mono]], auto simp: M_def)"], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n  (\\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar> +\n   1 / 2) *\n  (1 / 2)\n  \\<le> M + (M + M) * (1 / 2)\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "also"], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar> +\n  (\\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar> +\n   1 / 2) *\n  (1 / 2)\n  \\<le> M + (M + M) * (1 / 2)\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "have \"\\<dots> = 2 * M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M + (M + M) * (1 / 2) = 2 * M", "by auto"], ["proof (state)\nthis:\n  M + (M + M) * (1 / 2) = 2 * M\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "finally"], ["proof (chain)\npicking this:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n        rat_of_int c *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n  \\<le> 2 * M", "have le: \"abs ?new_mu \\<le> 2 * M\""], ["proof (prove)\nusing this:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n        rat_of_int c *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n  \\<le> 2 * M\n\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n          rat_of_int c *\n          gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n    \\<le> 2 * M", "."], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n        rat_of_int c *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n  \\<le> 2 * M\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "have \"(?mu' i k)\\<^sup>2 = ?new_mu\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2 =\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n     rat_of_int c *\n     gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k)\\<^sup>2", "by (subst main(5), insert kj False i j, auto)"], ["proof (state)\nthis:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2 =\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n   rat_of_int c *\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k)\\<^sup>2\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "also"], ["proof (state)\nthis:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2 =\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n   rat_of_int c *\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k)\\<^sup>2\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "have \"\\<dots> \\<le> (2 * M)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n     rat_of_int c *\n     gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k)\\<^sup>2\n    \\<le> (2 * M)\\<^sup>2", "unfolding abs_le_square_iff[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n          rat_of_int c *\n          gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n    \\<le> \\<bar>2 * M\\<bar>", "using le M0"], ["proof (prove)\nusing this:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n        rat_of_int c *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n  \\<le> 2 * M\n  0 \\<le> M\n\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n          rat_of_int c *\n          gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k\\<bar>\n    \\<le> \\<bar>2 * M\\<bar>", "by auto"], ["proof (state)\nthis:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n   rat_of_int c *\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k)\\<^sup>2\n  \\<le> (2 * M)\\<^sup>2\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "also"], ["proof (state)\nthis:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k -\n   rat_of_int c *\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) j k)\\<^sup>2\n  \\<le> (2 * M)\\<^sup>2\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "have \"\\<dots> = 4 * M^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * M)\\<^sup>2 = 4 * M\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (2 * M)\\<^sup>2 = 4 * M\\<^sup>2\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "also"], ["proof (state)\nthis:\n  (2 * M)\\<^sup>2 = 4 * M\\<^sup>2\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "have \"\\<dots> \\<le> 4 * bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * M\\<^sup>2 \\<le> 4 * bnd", "proof (rule mult_left_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sup>2 \\<le> bnd\n 2. 0 \\<le> 4", "show \"M^2 \\<le> bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M\\<^sup>2 \\<le> bnd", "using bnd_ij bnd_ik bnd1"], ["proof (prove)\nusing this:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n  \\<le> bnd\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k)\\<^sup>2\n  \\<le> bnd\n  1 \\<le> bnd\n  0 \\<le> bnd\n\ngoal (1 subgoal):\n 1. M\\<^sup>2 \\<le> bnd", "unfolding M_def"], ["proof (prove)\nusing this:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j)\\<^sup>2\n  \\<le> bnd\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k)\\<^sup>2\n  \\<le> bnd\n  1 \\<le> bnd\n  0 \\<le> bnd\n\ngoal (1 subgoal):\n 1. (max \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i k\\<bar>\n      (max \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                  j\\<bar>\n        (1 / 2)))\\<^sup>2\n    \\<le> bnd", "by (auto simp: max_def power2_eq_square)"], ["proof (state)\nthis:\n  M\\<^sup>2 \\<le> bnd\n\ngoal (1 subgoal):\n 1. 0 \\<le> 4", "qed auto"], ["proof (state)\nthis:\n  4 * M\\<^sup>2 \\<le> 4 * bnd\n\ngoal (1 subgoal):\n 1. k \\<noteq> j \\<Longrightarrow>\n    (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "finally"], ["proof (chain)\npicking this:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n  \\<le> 4 * bnd", "show ?thesis"], ["proof (prove)\nusing this:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n  \\<le> 4 * bnd\n\ngoal (1 subgoal):\n 1. (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n    \\<le> 4 * bnd", "."], ["proof (state)\nthis:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n  \\<le> 4 * bnd\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n  \\<le> 4 * bnd\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i k)\\<^sup>2\n  \\<le> 4 * bnd\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<mu>_bound_row fs' (4 * bnd) i\n\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "also"], ["proof (state)\nthis:\n  \\<mu>_bound_row fs' (4 * bnd) i\n\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "have \"4 * bnd = (4 ^ (1 + (m - 1 - Suc j)) * of_nat (N ^ (m - 1) * m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * bnd = 4 ^ (1 + (m - 1 - Suc j)) * rat_of_nat (N ^ (m - 1) * m)", "unfolding bnd"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (4 ^ (m - 1 - Suc j) * rat_of_nat (N ^ (m - 1) * m)) =\n    4 ^ (1 + (m - 1 - Suc j)) * rat_of_nat (N ^ (m - 1) * m)", "by simp"], ["proof (state)\nthis:\n  4 * bnd = 4 ^ (1 + (m - 1 - Suc j)) * rat_of_nat (N ^ (m - 1) * m)\n\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "also"], ["proof (state)\nthis:\n  4 * bnd = 4 ^ (1 + (m - 1 - Suc j)) * rat_of_nat (N ^ (m - 1) * m)\n\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "have \"1 + (m - 1 - Suc j) = m - 1 - j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + (m - 1 - Suc j) = m - 1 - j", "using i j"], ["proof (prove)\nusing this:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. 1 + (m - 1 - Suc j) = m - 1 - j", "by auto"], ["proof (state)\nthis:\n  1 + (m - 1 - Suc j) = m - 1 - j\n\ngoal (3 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'\n 3. \\<mu>_bound_row_inner fs' i j", "finally"], ["proof (chain)\npicking this:\n  \\<mu>_bound_row_inner fs' i j", "show bnd: \"\\<mu>_bound_row_inner fs' i j\""], ["proof (prove)\nusing this:\n  \\<mu>_bound_row_inner fs' i j\n\ngoal (1 subgoal):\n 1. \\<mu>_bound_row_inner fs' i j", "by auto"], ["proof (state)\nthis:\n  \\<mu>_bound_row_inner fs' i j\n\ngoal (2 subgoals):\n 1. f_bound False i fs'\n 2. g_bound fs'", "show gbnd: \"g_bound fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_bound fs'", "using gbnd"], ["proof (prove)\nusing this:\n  g_bound fs\n\ngoal (1 subgoal):\n 1. g_bound fs'", "unfolding g_bound_def"], ["proof (prove)\nusing this:\n  \\<forall>i<m.\n     \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                 i\\<parallel>\\<^sup>2\n     \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. \\<forall>i<m.\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   i\\<parallel>\\<^sup>2\n       \\<le> rat_of_nat N", "using main(4)"], ["proof (prove)\nusing this:\n  \\<forall>i<m.\n     \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                 i\\<parallel>\\<^sup>2\n     \\<le> rat_of_nat N\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?i =\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i<m.\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   i\\<parallel>\\<^sup>2\n       \\<le> rat_of_nat N", "by auto"], ["proof (state)\nthis:\n  g_bound fs'\n\ngoal (1 subgoal):\n 1. f_bound False i fs'", "note inv' = LLL_invD[OF Linv']"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs') \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs') \\<alpha> i\n  True \\<or> \\<mu>_small fs' i\n\ngoal (1 subgoal):\n 1. f_bound False i fs'", "show \"f_bound False i fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_bound False i fs'", "unfolding f_bound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ia<m.\n       \\<parallel>fs' ! ia\\<parallel>\\<^sup>2\n       \\<le> (if ia \\<noteq> i \\<or> False then int (N * m)\n              else int (4 ^ (m - 1) * N ^ m * m * m))", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < m \\<Longrightarrow>\n       \\<parallel>fs' ! ia\\<parallel>\\<^sup>2\n       \\<le> (if ia \\<noteq> i \\<or> False then int (N * m)\n              else int (4 ^ (m - 1) * N ^ m * m * m))", "case (1 jj)"], ["proof (state)\nthis:\n  jj < m\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < m \\<Longrightarrow>\n       \\<parallel>fs' ! ia\\<parallel>\\<^sup>2\n       \\<le> (if ia \\<noteq> i \\<or> False then int (N * m)\n              else int (4 ^ (m - 1) * N ^ m * m * m))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "proof (cases \"jj = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))\n 2. jj \\<noteq> i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "case False"], ["proof (state)\nthis:\n  jj \\<noteq> i\n\ngoal (2 subgoals):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))\n 2. jj \\<noteq> i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "with 1 fbnd[unfolded f_bound_def]"], ["proof (chain)\npicking this:\n  jj < m\n  \\<forall>ia<m.\n     \\<parallel>fs ! ia\\<parallel>\\<^sup>2\n     \\<le> (if ia \\<noteq> i \\<or> False then int (N * m)\n            else int (4 ^ (m - 1) * N ^ m * m * m))\n  jj \\<noteq> i", "have \"\\<parallel>fs ! jj\\<parallel>\\<^sup>2 \\<le> int (N * m)\""], ["proof (prove)\nusing this:\n  jj < m\n  \\<forall>ia<m.\n     \\<parallel>fs ! ia\\<parallel>\\<^sup>2\n     \\<le> (if ia \\<noteq> i \\<or> False then int (N * m)\n            else int (4 ^ (m - 1) * N ^ m * m * m))\n  jj \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! jj\\<parallel>\\<^sup>2 \\<le> int (N * m)", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs ! jj\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (2 subgoals):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))\n 2. jj \\<noteq> i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! jj\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "unfolding fs'"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! jj\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j] !\n               jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "using False 1 inv(2-)"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! jj\\<parallel>\\<^sup>2 \\<le> int (N * m)\n  jj \\<noteq> i\n  jj < m\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. \\<parallel>fs[i := fs ! i - c \\<cdot>\\<^sub>v fs ! j] !\n               jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n  \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "case True"], ["proof (state)\nthis:\n  jj = i\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "have \"of_int \\<parallel>fs' ! i\\<parallel>\\<^sup>2 = \\<parallel>RAT fs' ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs' ! i\\<parallel>\\<^sup>2 =\n    \\<parallel>map of_int_hom.vec_hom fs' ! i\\<parallel>\\<^sup>2", "using i inv'"], ["proof (prove)\nusing this:\n  i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs') \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs') \\<alpha> i\n  True \\<or> \\<mu>_small fs' i\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs' ! i\\<parallel>\\<^sup>2 =\n    \\<parallel>map of_int_hom.vec_hom fs' ! i\\<parallel>\\<^sup>2", "by (auto simp: sq_norm_of_int)"], ["proof (state)\nthis:\n  rat_of_int \\<parallel>fs' ! i\\<parallel>\\<^sup>2 =\n  \\<parallel>map of_int_hom.vec_hom fs' ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "also"], ["proof (state)\nthis:\n  rat_of_int \\<parallel>fs' ! i\\<parallel>\\<^sup>2 =\n  \\<parallel>map of_int_hom.vec_hom fs' ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "have \"... \\<le> rat_of_nat (Suc i * N) * (4 ^ (m - 1 - j) * rat_of_nat (N ^ (m - 1) * m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>map of_int_hom.vec_hom fs' ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) *\n          (4 ^ (m - 1 - j) * rat_of_nat (N ^ (m - 1) * m))", "using sq_norm_fs_mu_g_bound[OF inv'(1,6) i bnd gbnd] i inv'"], ["proof (prove)\nusing this:\n  rat_of_int \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (Suc i * N) *\n        (4 ^ (m - 1 - j) * rat_of_nat (N ^ (m - 1) * m))\n  i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs') \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs') \\<alpha> i\n  True \\<or> \\<mu>_small fs' i\n\ngoal (1 subgoal):\n 1. \\<parallel>map of_int_hom.vec_hom fs' ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) *\n          (4 ^ (m - 1 - j) * rat_of_nat (N ^ (m - 1) * m))", "unfolding sq_norm_of_int[symmetric]"], ["proof (prove)\nusing this:\n  \\<parallel>of_int_hom.vec_hom (fs' ! i)\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (Suc i * N) *\n        (4 ^ (m - 1 - j) * rat_of_nat (N ^ (m - 1) * m))\n  i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs') \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs') \\<alpha> i\n  True \\<or> \\<mu>_small fs' i\n\ngoal (1 subgoal):\n 1. \\<parallel>map of_int_hom.vec_hom fs' ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (Suc i * N) *\n          (4 ^ (m - 1 - j) * rat_of_nat (N ^ (m - 1) * m))", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  \\<parallel>map of_int_hom.vec_hom fs' ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (Suc i * N) *\n        (4 ^ (m - 1 - j) * rat_of_nat (N ^ (m - 1) * m))\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "also"], ["proof (state)\nthis:\n  \\<parallel>map of_int_hom.vec_hom fs' ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (Suc i * N) *\n        (4 ^ (m - 1 - j) * rat_of_nat (N ^ (m - 1) * m))\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "have \"\\<dots> = rat_of_int ( int (Suc i * N) * (4 ^ (m - 1 - j) * (N ^ (m - 1) * m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (Suc i * N) *\n    (4 ^ (m - 1 - j) * rat_of_nat (N ^ (m - 1) * m)) =\n    rat_of_int (int (Suc i * N) * int (4 ^ (m - 1 - j) * (N ^ (m - 1) * m)))", "by simp"], ["proof (state)\nthis:\n  rat_of_nat (Suc i * N) *\n  (4 ^ (m - 1 - j) * rat_of_nat (N ^ (m - 1) * m)) =\n  rat_of_int (int (Suc i * N) * int (4 ^ (m - 1 - j) * (N ^ (m - 1) * m)))\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "finally"], ["proof (chain)\npicking this:\n  rat_of_int \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_int\n         (int (Suc i * N) * int (4 ^ (m - 1 - j) * (N ^ (m - 1) * m)))", "have \"\\<parallel>fs' ! i\\<parallel>\\<^sup>2 \\<le> int (Suc i * N) * (4 ^ (m - 1 - j) * (N ^ (m - 1) * m))\""], ["proof (prove)\nusing this:\n  rat_of_int \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_int\n         (int (Suc i * N) * int (4 ^ (m - 1 - j) * (N ^ (m - 1) * m)))\n\ngoal (1 subgoal):\n 1. \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n    \\<le> int (Suc i * N) * int (4 ^ (m - 1 - j) * (N ^ (m - 1) * m))", "by linarith"], ["proof (state)\nthis:\n  \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n  \\<le> int (Suc i * N) * int (4 ^ (m - 1 - j) * (N ^ (m - 1) * m))\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "also"], ["proof (state)\nthis:\n  \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n  \\<le> int (Suc i * N) * int (4 ^ (m - 1 - j) * (N ^ (m - 1) * m))\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "have \"\\<dots> = int (Suc i) * 4 ^ (m - 1 - j) * (int N ^ (Suc (m - 1))) * int m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (Suc i * N) * int (4 ^ (m - 1 - j) * (N ^ (m - 1) * m)) =\n    int (Suc i) * 4 ^ (m - 1 - j) * int N ^ Suc (m - 1) * int m", "unfolding of_nat_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (Suc i) * int N *\n    (int (4 ^ (m - 1 - j)) * (int (N ^ (m - 1)) * int m)) =\n    int (Suc i) * 4 ^ (m - 1 - j) * int N ^ Suc (m - 1) * int m", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  int (Suc i * N) * int (4 ^ (m - 1 - j) * (N ^ (m - 1) * m)) =\n  int (Suc i) * 4 ^ (m - 1 - j) * int N ^ Suc (m - 1) * int m\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "also"], ["proof (state)\nthis:\n  int (Suc i * N) * int (4 ^ (m - 1 - j) * (N ^ (m - 1) * m)) =\n  int (Suc i) * 4 ^ (m - 1 - j) * int N ^ Suc (m - 1) * int m\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "have \"\\<dots> = int (Suc i) * 4 ^ (m - 1 - j) * int N ^ m * int m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (Suc i) * 4 ^ (m - 1 - j) * int N ^ Suc (m - 1) * int m =\n    int (Suc i) * 4 ^ (m - 1 - j) * int N ^ m * int m", "using i j"], ["proof (prove)\nusing this:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. int (Suc i) * 4 ^ (m - 1 - j) * int N ^ Suc (m - 1) * int m =\n    int (Suc i) * 4 ^ (m - 1 - j) * int N ^ m * int m", "by simp"], ["proof (state)\nthis:\n  int (Suc i) * 4 ^ (m - 1 - j) * int N ^ Suc (m - 1) * int m =\n  int (Suc i) * 4 ^ (m - 1 - j) * int N ^ m * int m\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "also"], ["proof (state)\nthis:\n  int (Suc i) * 4 ^ (m - 1 - j) * int N ^ Suc (m - 1) * int m =\n  int (Suc i) * 4 ^ (m - 1 - j) * int N ^ m * int m\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "have \"\\<dots> \\<le> int m * 4 ^ (m - 1) * int N ^ m * int m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (Suc i) * 4 ^ (m - 1 - j) * int N ^ m * int m\n    \\<le> int m * 4 ^ (m - 1) * int N ^ m * int m", "by (rule mult_right_mono[OF mult_right_mono[OF mult_mono[OF _ pow_mono_exp]]], insert i, auto)"], ["proof (state)\nthis:\n  int (Suc i) * 4 ^ (m - 1 - j) * int N ^ m * int m\n  \\<le> int m * 4 ^ (m - 1) * int N ^ m * int m\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n  \\<le> int m * 4 ^ (m - 1) * int N ^ m * int m", "have \"\\<parallel>fs' ! i\\<parallel>\\<^sup>2 \\<le> int (4 ^ (m - 1) * N ^ m * m * m)\""], ["proof (prove)\nusing this:\n  \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n  \\<le> int m * 4 ^ (m - 1) * int N ^ m * int m\n\ngoal (1 subgoal):\n 1. \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n    \\<le> int (4 ^ (m - 1) * N ^ m * m * m)", "unfolding of_nat_mult"], ["proof (prove)\nusing this:\n  \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n  \\<le> int m * 4 ^ (m - 1) * int N ^ m * int m\n\ngoal (1 subgoal):\n 1. \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n    \\<le> int (4 ^ (m - 1)) * int (N ^ m) * int m * int m", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n  \\<le> int (4 ^ (m - 1) * N ^ m * m * m)\n\ngoal (1 subgoal):\n 1. jj = i \\<Longrightarrow>\n    \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n  \\<le> int (4 ^ (m - 1) * N ^ m * m * m)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n    \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "unfolding True"], ["proof (prove)\nusing this:\n  \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n  \\<le> int (4 ^ (m - 1) * N ^ m * m * m)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs' ! i\\<parallel>\\<^sup>2\n    \\<le> (if i \\<noteq> i \\<or> False then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n  \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<parallel>fs' ! jj\\<parallel>\\<^sup>2\n  \\<le> (if jj \\<noteq> i \\<or> False then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f_bound False i fs'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context LLL_with_assms\nbegin"], ["", "subsubsection \\<open>@{const LLL_bound_invariant} is maintained during execution of @{const reduce_basis}\\<close>"], ["", "lemma basis_reduction_add_rows_enter_bound: assumes binv: \"LLL_bound_invariant True True i fs\"\n  and i: \"i < m\"   \nshows \"LLL_bound_invariant False True i fs\"\n  \"\\<mu>_bound_row_inner fs i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant False True i fs &&& \\<mu>_bound_row_inner fs i i", "proof (rule bound_invI)"], ["proof (state)\ngoal (4 subgoals):\n 1. LLL_invariant True i fs\n 2. f_bound False i fs\n 3. g_bound fs\n 4. \\<mu>_bound_row_inner fs i i", "from bound_invD[OF binv]"], ["proof (chain)\npicking this:\n  LLL_invariant True i fs\n  f_bound True i fs\n  g_bound fs", "have Linv: \"LLL_invariant True i fs\" (is ?g1) and fbnd: \"f_bound True i fs\" \n    and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant True i fs\n  f_bound True i fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant True i fs &&& f_bound True i fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n  f_bound True i fs\n  g_bound fs\n\ngoal (4 subgoals):\n 1. LLL_invariant True i fs\n 2. f_bound False i fs\n 3. g_bound fs\n 4. \\<mu>_bound_row_inner fs i i", "note Linvw = LLL_inv_imp_w[OF Linv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (4 subgoals):\n 1. LLL_invariant True i fs\n 2. f_bound False i fs\n 3. g_bound fs\n 4. \\<mu>_bound_row_inner fs i i", "interpret fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by standard (use Linvw in auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. LLL_invariant True i fs\n 2. f_bound False i fs\n 3. g_bound fs\n 4. \\<mu>_bound_row_inner fs i i", "note inv = LLL_invD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs.gs.reduced \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (4 subgoals):\n 1. LLL_invariant True i fs\n 2. f_bound False i fs\n 3. g_bound fs\n 4. \\<mu>_bound_row_inner fs i i", "show \"LLL_invariant True i fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True i fs", "by fact"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n\ngoal (3 subgoals):\n 1. f_bound False i fs\n 2. g_bound fs\n 3. \\<mu>_bound_row_inner fs i i", "show fbndF: \"f_bound False i fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_bound False i fs", "using f_bound_True_arbitrary[OF fbnd]"], ["proof (prove)\nusing this:\n  f_bound ?outside ?j fs\n\ngoal (1 subgoal):\n 1. f_bound False i fs", "."], ["proof (state)\nthis:\n  f_bound False i fs\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "have N0: \"N > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < N", "using LLL_inv_N_pos[OF Linvw gbnd] i"], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  i < m\n\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "{"], ["proof (state)\nthis:\n  0 < N\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "assume ji: \"j < i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "have \"(\\<mu> fs i j)\\<^sup>2 \\<le> gs.Gramian_determinant (RAT fs) j * \\<parallel>RAT fs ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2\n    \\<le> fs.gs.d j *\n          \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2", "using ji i inv"], ["proof (prove)\nusing this:\n  j < i\n  i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs.gs.reduced \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2\n    \\<le> fs.gs.d j *\n          \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2", "by (intro fs.gs.mu_bound_Gramian_determinant) (auto)"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2\n  \\<le> fs.gs.d j *\n        \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "also"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2\n  \\<le> fs.gs.d j *\n        \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "have \"gs.Gramian_determinant (RAT fs) j = of_int (d fs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.d j = rat_of_int (d fs j)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.d j = rat_of_int (gs.Gramian_determinant fs j)", "by (subst fs.of_int_Gramian_determinant, insert ji i inv(2-), auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  fs.gs.d j = rat_of_int (d fs j)\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "also"], ["proof (state)\nthis:\n  fs.gs.d j = rat_of_int (d fs j)\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "have \"\\<parallel>RAT fs ! i\\<parallel>\\<^sup>2 = of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2 =\n    rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2", "using i inv(2-)"], ["proof (prove)\nusing this:\n  i < m\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs.gs.reduced \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2 =\n    rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2", "by (auto simp: sq_norm_of_int)"], ["proof (state)\nthis:\n  \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2 =\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "also"], ["proof (state)\nthis:\n  \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2 =\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "have \"of_int (d fs j) * \\<dots> \\<le> rat_of_nat (N^j) * of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs j) * rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (N ^ j) *\n          rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2", "by (rule mult_right_mono, insert ji i d_approx[OF Linvw gbnd, of j], auto)"], ["proof (state)\nthis:\n  rat_of_int (d fs j) * rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (N ^ j) * rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs j) * rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (N ^ j) * rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "have \"\\<dots> \\<le> rat_of_nat (N^(m-2)) * of_int (int (N * m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (N ^ j) * rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_nat (N ^ (m - 2)) * rat_of_int (int (N * m))", "by (intro mult_mono, unfold of_nat_le_iff of_int_le_iff, rule pow_mono_exp,\n      insert fbnd[unfolded f_bound_def, rule_format, of i] N0 ji i, auto)"], ["proof (state)\nthis:\n  rat_of_nat (N ^ j) * rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (N ^ (m - 2)) * rat_of_int (int (N * m))\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "also"], ["proof (state)\nthis:\n  rat_of_nat (N ^ j) * rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (N ^ (m - 2)) * rat_of_int (int (N * m))\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "have \"\\<dots> = rat_of_nat (N^(m-2) * N * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (N ^ (m - 2)) * rat_of_int (int (N * m)) =\n    rat_of_nat (N ^ (m - 2) * N * m)", "by simp"], ["proof (state)\nthis:\n  rat_of_nat (N ^ (m - 2)) * rat_of_int (int (N * m)) =\n  rat_of_nat (N ^ (m - 2) * N * m)\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "also"], ["proof (state)\nthis:\n  rat_of_nat (N ^ (m - 2)) * rat_of_int (int (N * m)) =\n  rat_of_nat (N ^ (m - 2) * N * m)\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "have \"N^(m-2) * N = N^(Suc (m - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N ^ (m - 2) * N = N ^ Suc (m - 2)", "by simp"], ["proof (state)\nthis:\n  N ^ (m - 2) * N = N ^ Suc (m - 2)\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "also"], ["proof (state)\nthis:\n  N ^ (m - 2) * N = N ^ Suc (m - 2)\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "have \"Suc (m - 2) = m - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (m - 2) = m - 1", "using ji i"], ["proof (prove)\nusing this:\n  j < i\n  i < m\n\ngoal (1 subgoal):\n 1. Suc (m - 2) = m - 1", "by auto"], ["proof (state)\nthis:\n  Suc (m - 2) = m - 1\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "finally"], ["proof (chain)\npicking this:\n  (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> rat_of_nat (N ^ (m - 1) * m)", "have \"(\\<mu> fs i j)\\<^sup>2 \\<le> of_nat (N ^ (m - 1) * m)\""], ["proof (prove)\nusing this:\n  (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> rat_of_nat (N ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> rat_of_nat (N ^ (m - 1) * m)", "."], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> rat_of_nat (N ^ (m - 1) * m)\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "}"], ["proof (state)\nthis:\n  ?j3 < i \\<Longrightarrow>\n  (fs.gs.\\<mu> i ?j3)\\<^sup>2 \\<le> rat_of_nat (N ^ (m - 1) * m)\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "note mu_bound = this"], ["proof (state)\nthis:\n  ?j3 < i \\<Longrightarrow>\n  (fs.gs.\\<mu> i ?j3)\\<^sup>2 \\<le> rat_of_nat (N ^ (m - 1) * m)\n\ngoal (2 subgoals):\n 1. g_bound fs\n 2. \\<mu>_bound_row_inner fs i i", "show mu_bnd: \"\\<mu>_bound_row_inner fs i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>_bound_row_inner fs i i", "proof (rule \\<mu>_bound_rowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (fs.gs.\\<mu> i j)\\<^sup>2\n       \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (fs.gs.\\<mu> i j)\\<^sup>2\n       \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)", "assume j: \"j \\<le> i\""], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (fs.gs.\\<mu> i j)\\<^sup>2\n       \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)", "have \"(\\<mu> fs i j)\\<^sup>2 \\<le> 1 * of_nat (N ^ (m - 1) * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)", "proof (cases \"j = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow>\n    (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)\n 2. j \\<noteq> i \\<Longrightarrow>\n    (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)", "case False"], ["proof (state)\nthis:\n  j \\<noteq> i\n\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow>\n    (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)\n 2. j \\<noteq> i \\<Longrightarrow>\n    (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)", "with mu_bound[of j] j"], ["proof (chain)\npicking this:\n  j < i \\<Longrightarrow>\n  (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> rat_of_nat (N ^ (m - 1) * m)\n  j \\<le> i\n  j \\<noteq> i", "show ?thesis"], ["proof (prove)\nusing this:\n  j < i \\<Longrightarrow>\n  (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> rat_of_nat (N ^ (m - 1) * m)\n  j \\<le> i\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)", "by auto"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow>\n    (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow>\n    (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)", "case True"], ["proof (state)\nthis:\n  j = i\n\ngoal (1 subgoal):\n 1. j = i \\<Longrightarrow>\n    (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)", "unfolding True fs.gs.\\<mu>.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < i\n     then map of_int_hom.vec_hom fs ! i \\<bullet> fs.gs.gso i /\n          \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n     else if i = i then 1 else 0)\\<^sup>2\n    \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)", "using i N0"], ["proof (prove)\nusing this:\n  i < m\n  0 < N\n\ngoal (1 subgoal):\n 1. (if i < i\n     then map of_int_hom.vec_hom fs ! i \\<bullet> fs.gs.gso i /\n          \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2\n     else if i = i then 1 else 0)\\<^sup>2\n    \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)", "by auto"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (fs.gs.\\<mu> i j)\\<^sup>2\n       \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2 \\<le> 1 * rat_of_nat (N ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (fs.gs.\\<mu> i j)\\<^sup>2\n       \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)", "have \"\\<dots> \\<le> 4 ^ (m - 1 - i) * of_nat (N ^ (m - 1) * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * rat_of_nat (N ^ (m - 1) * m)\n    \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)", "by (rule mult_right_mono, auto)"], ["proof (state)\nthis:\n  1 * rat_of_nat (N ^ (m - 1) * m)\n  \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<le> i \\<Longrightarrow>\n       (fs.gs.\\<mu> i j)\\<^sup>2\n       \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)", "finally"], ["proof (chain)\npicking this:\n  (fs.gs.\\<mu> i j)\\<^sup>2\n  \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)", "show \"(\\<mu> fs i j)\\<^sup>2 \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)\""], ["proof (prove)\nusing this:\n  (fs.gs.\\<mu> i j)\\<^sup>2\n  \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2\n    \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)", "."], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2\n  \\<le> 4 ^ (m - 1 - i) * rat_of_nat (N ^ (m - 1) * m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<mu>_bound_row_inner fs i i\n\ngoal (1 subgoal):\n 1. g_bound fs", "show \"g_bound fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_bound fs", "by fact"], ["proof (state)\nthis:\n  g_bound fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_basis_reduction_add_rows_loop_leave:\n  assumes binv: \"LLL_bound_invariant False True i fs\" \n  and mu_small: \"\\<mu>_small_row i fs 0\"\n  and mu_bnd: \"\\<mu>_bound_row_inner fs i 0\" \n  and i: \"i < m\" \nshows \"LLL_bound_invariant True False i fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "note Linv = bound_invD(1)[OF binv]"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "from mu_small"], ["proof (chain)\npicking this:\n  \\<mu>_small_row i fs 0", "have mu_small: \"\\<mu>_small fs i\""], ["proof (prove)\nusing this:\n  \\<mu>_small_row i fs 0\n\ngoal (1 subgoal):\n 1. \\<mu>_small fs i", "unfolding \\<mu>_small_row_def \\<mu>_small_def"], ["proof (prove)\nusing this:\n  \\<forall>j'\\<ge>0.\n     j' < i \\<longrightarrow>\n     \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j'\\<bar>\n     \\<le> inverse 2\n\ngoal (1 subgoal):\n 1. \\<forall>j<i.\n       \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n       \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "note inv = LLL_invD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "interpret gs1: gram_schmidt_fs_int n \"RAT fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_int n (map of_int_hom.vec_hom fs)", "by (standard) (use inv gs.lin_indpt_list_def in \\<open>auto simp add: vec_hom_Ints\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "note fbnd = bound_invD(2)[OF binv]"], ["proof (state)\nthis:\n  f_bound False i fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "note gbnd = bound_invD(3)[OF binv]"], ["proof (state)\nthis:\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "{"], ["proof (state)\nthis:\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "fix ii"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "assume ii: \"ii < m\""], ["proof (state)\nthis:\n  ii < m\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "have \"\\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "proof (cases \"ii = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)\n 2. ii \\<noteq> i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "case False"], ["proof (state)\nthis:\n  ii \\<noteq> i\n\ngoal (2 subgoals):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)\n 2. ii \\<noteq> i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ii \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "using ii fbnd[unfolded f_bound_def]"], ["proof (prove)\nusing this:\n  ii \\<noteq> i\n  ii < m\n  \\<forall>ia<m.\n     \\<parallel>fs ! ia\\<parallel>\\<^sup>2\n     \\<le> (if ia \\<noteq> i \\<or> False then int (N * m)\n            else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "case True"], ["proof (state)\nthis:\n  ii = i\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "have row: \"\\<mu>_bound_row fs 1 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>_bound_row fs 1 i", "proof (intro \\<mu>_bound_rowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. j \\<le> i \\<Longrightarrow> (gs1.\\<mu> i j)\\<^sup>2 \\<le> 1", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. j \\<le> i \\<Longrightarrow> (gs1.\\<mu> i j)\\<^sup>2 \\<le> 1", "assume j: \"j \\<le> i\""], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>j. j \\<le> i \\<Longrightarrow> (gs1.\\<mu> i j)\\<^sup>2 \\<le> 1", "from mu_small[unfolded \\<mu>_small_def, rule_format, of j]"], ["proof (chain)\npicking this:\n  j < i \\<Longrightarrow> \\<bar>gs1.\\<mu> i j\\<bar> \\<le> 1 / 2", "have \"abs (\\<mu> fs i j) \\<le> 1\""], ["proof (prove)\nusing this:\n  j < i \\<Longrightarrow> \\<bar>gs1.\\<mu> i j\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<bar>gs1.\\<mu> i j\\<bar> \\<le> 1", "using j"], ["proof (prove)\nusing this:\n  j < i \\<Longrightarrow> \\<bar>gs1.\\<mu> i j\\<bar> \\<le> 1 / 2\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<bar>gs1.\\<mu> i j\\<bar> \\<le> 1", "unfolding \\<mu>_small_def"], ["proof (prove)\nusing this:\n  j < i \\<Longrightarrow> \\<bar>gs1.\\<mu> i j\\<bar> \\<le> 1 / 2\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<bar>gs1.\\<mu> i j\\<bar> \\<le> 1", "by (cases \"j = i\", force simp: gs1.\\<mu>.simps, auto)"], ["proof (state)\nthis:\n  \\<bar>gs1.\\<mu> i j\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>j. j \\<le> i \\<Longrightarrow> (gs1.\\<mu> i j)\\<^sup>2 \\<le> 1", "from mult_mono[OF this this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> 1; 0 \\<le> \\<bar>gs1.\\<mu> i j\\<bar>\\<rbrakk>\n  \\<Longrightarrow> \\<bar>gs1.\\<mu> i j\\<bar> * \\<bar>gs1.\\<mu> i j\\<bar>\n                    \\<le> 1 * 1", "show \"(\\<mu> fs i j)\\<^sup>2 \\<le> 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1; 0 \\<le> \\<bar>gs1.\\<mu> i j\\<bar>\\<rbrakk>\n  \\<Longrightarrow> \\<bar>gs1.\\<mu> i j\\<bar> * \\<bar>gs1.\\<mu> i j\\<bar>\n                    \\<le> 1 * 1\n\ngoal (1 subgoal):\n 1. (gs1.\\<mu> i j)\\<^sup>2 \\<le> 1", "by (auto simp: power2_eq_square)"], ["proof (state)\nthis:\n  (gs1.\\<mu> i j)\\<^sup>2 \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<mu>_bound_row fs 1 i\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "have \"rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> rat_of_int (int (Suc i * N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_int (int (Suc i * N))", "using sq_norm_fs_mu_g_bound[OF inv(1,6) i row gbnd]"], ["proof (prove)\nusing this:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_nat (Suc i * N) * 1\n\ngoal (1 subgoal):\n 1. rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> rat_of_int (int (Suc i * N))", "by auto"], ["proof (state)\nthis:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_int (int (Suc i * N))\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "hence \"\\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (Suc i * N)\""], ["proof (prove)\nusing this:\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> rat_of_int (int (Suc i * N))\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (Suc i * N)", "by linarith"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (Suc i * N)\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "also"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (Suc i * N)\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "have \"\\<dots> = int N * int (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (Suc i * N) = int N * int (Suc i)", "unfolding of_nat_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (Suc i) * int N = int N * int (Suc i)", "by simp"], ["proof (state)\nthis:\n  int (Suc i * N) = int N * int (Suc i)\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "also"], ["proof (state)\nthis:\n  int (Suc i * N) = int N * int (Suc i)\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "have \"\\<dots> \\<le> int N * int m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int N * int (Suc i) \\<le> int N * int m", "by (rule mult_left_mono, insert i, auto)"], ["proof (state)\nthis:\n  int N * int (Suc i) \\<le> int N * int m\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "also"], ["proof (state)\nthis:\n  int N * int (Suc i) \\<le> int N * int m\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "have \"\\<dots> = int (N * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int N * int m = int (N * m)", "by simp"], ["proof (state)\nthis:\n  int N * int m = int (N * m)\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)", "unfolding True"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)", "."], ["proof (state)\nthis:\n  \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<parallel>fs ! ii\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "}"], ["proof (state)\nthis:\n  ?ii3 < m \\<Longrightarrow>\n  \\<parallel>fs ! ?ii3\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "hence f_bound: \"f_bound True i fs\""], ["proof (prove)\nusing this:\n  ?ii3 < m \\<Longrightarrow>\n  \\<parallel>fs ! ?ii3\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. f_bound True i fs", "unfolding f_bound_def"], ["proof (prove)\nusing this:\n  ?ii3 < m \\<Longrightarrow>\n  \\<parallel>fs ! ?ii3\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. \\<forall>ia<m.\n       \\<parallel>fs ! ia\\<parallel>\\<^sup>2\n       \\<le> (if ia \\<noteq> i \\<or> True then int (N * m)\n              else int (4 ^ (m - 1) * N ^ m * m * m))", "by auto"], ["proof (state)\nthis:\n  f_bound True i fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "with binv"], ["proof (chain)\npicking this:\n  LLL_bound_invariant False True i fs\n  f_bound True i fs", "show ?thesis"], ["proof (prove)\nusing this:\n  LLL_bound_invariant False True i fs\n  f_bound True i fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "using basis_reduction_add_row_done[OF Linv i assms(2)]"], ["proof (prove)\nusing this:\n  LLL_bound_invariant False True i fs\n  f_bound True i fs\n  LLL_invariant False i fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs", "by (auto simp: LLL_bound_invariant_def)"], ["proof (state)\nthis:\n  LLL_bound_invariant True False i fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_add_rows_loop_bound: assumes\n  binv: \"LLL_bound_invariant False True i fs\" \n  and mu_small: \"\\<mu>_small_row i fs j\"\n  and mu_bnd: \"\\<mu>_bound_row_inner fs i j\" \n  and res: \"basis_reduction_add_rows_loop i fs j = fs'\" \n  and i: \"i < m\" \n  and j: \"j \\<le> i\" \nshows \"LLL_bound_invariant True False i fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "using assms"], ["proof (prove)\nusing this:\n  LLL_bound_invariant False True i fs\n  \\<mu>_small_row i fs j\n  \\<mu>_bound_row_inner fs i j\n  basis_reduction_add_rows_loop i fs j = fs'\n  i < m\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "proof (induct j arbitrary: fs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fs.\n       \\<lbrakk>LLL_bound_invariant False True i fs; \\<mu>_small_row i fs 0;\n        \\<mu>_bound_row_inner fs i 0;\n        basis_reduction_add_rows_loop i fs 0 = fs'; i < m;\n        0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'\n 2. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "case (0 fs)"], ["proof (state)\nthis:\n  LLL_bound_invariant False True i fs\n  \\<mu>_small_row i fs 0\n  \\<mu>_bound_row_inner fs i 0\n  basis_reduction_add_rows_loop i fs 0 = fs'\n  i < m\n  0 \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>fs.\n       \\<lbrakk>LLL_bound_invariant False True i fs; \\<mu>_small_row i fs 0;\n        \\<mu>_bound_row_inner fs i 0;\n        basis_reduction_add_rows_loop i fs 0 = fs'; i < m;\n        0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'\n 2. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "note binv = 0(1)"], ["proof (state)\nthis:\n  LLL_bound_invariant False True i fs\n\ngoal (2 subgoals):\n 1. \\<And>fs.\n       \\<lbrakk>LLL_bound_invariant False True i fs; \\<mu>_small_row i fs 0;\n        \\<mu>_bound_row_inner fs i 0;\n        basis_reduction_add_rows_loop i fs 0 = fs'; i < m;\n        0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'\n 2. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "from basis_basis_reduction_add_rows_loop_leave[OF 0(1-3) i] 0(4)"], ["proof (chain)\npicking this:\n  LLL_bound_invariant True False i fs\n  basis_reduction_add_rows_loop i fs 0 = fs'", "show ?case"], ["proof (prove)\nusing this:\n  LLL_bound_invariant True False i fs\n  basis_reduction_add_rows_loop i fs 0 = fs'\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "by auto"], ["proof (state)\nthis:\n  LLL_bound_invariant True False i fs'\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "case (Suc j fs)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_bound_invariant False True i ?fs1; \\<mu>_small_row i ?fs1 j;\n   \\<mu>_bound_row_inner ?fs1 i j;\n   basis_reduction_add_rows_loop i ?fs1 j = fs'; i < m; j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> LLL_bound_invariant True False i fs'\n  LLL_bound_invariant False True i fs\n  \\<mu>_small_row i fs (Suc j)\n  \\<mu>_bound_row_inner fs i (Suc j)\n  basis_reduction_add_rows_loop i fs (Suc j) = fs'\n  i < m\n  Suc j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "note binv = Suc(2)"], ["proof (state)\nthis:\n  LLL_bound_invariant False True i fs\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "note Linv = bound_invD(1)[OF binv]"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "note Linvw = LLL_inv_imp_w[OF Linv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>LLL_bound_invariant False True i ?fs1; \\<mu>_small_row i ?fs1 j;\n   \\<mu>_bound_row_inner ?fs1 i j;\n   basis_reduction_add_rows_loop i ?fs1 j = fs'; i < m; j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> LLL_bound_invariant True False i fs'\n  LLL_bound_invariant False True i fs\n  \\<mu>_small_row i fs (Suc j)\n  \\<mu>_bound_row_inner fs i (Suc j)\n  basis_reduction_add_rows_loop i fs (Suc j) = fs'\n  i < m\n  Suc j \\<le> i", "have j: \"j < i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_bound_invariant False True i ?fs1; \\<mu>_small_row i ?fs1 j;\n   \\<mu>_bound_row_inner ?fs1 i j;\n   basis_reduction_add_rows_loop i ?fs1 j = fs'; i < m; j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> LLL_bound_invariant True False i fs'\n  LLL_bound_invariant False True i fs\n  \\<mu>_small_row i fs (Suc j)\n  \\<mu>_bound_row_inner fs i (Suc j)\n  basis_reduction_add_rows_loop i fs (Suc j) = fs'\n  i < m\n  Suc j \\<le> i\n\ngoal (1 subgoal):\n 1. j < i", "by auto"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "let ?c = \"round (\\<mu> fs i j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "note step = basis_reduction_add_row_main_bound[OF Suc(2) i j refl refl Suc(3-4)]"], ["proof (state)\nthis:\n  LLL_bound_invariant False True i\n   (fs[i := fs ! i -\n            round\n             (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n               j) \\<cdot>\\<^sub>v\n            fs ! j])\n  \\<mu>_bound_row_inner\n   (fs[i := fs ! i -\n            round\n             (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n               j) \\<cdot>\\<^sub>v\n            fs ! j])\n   i j\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "note step' = basis_reduction_add_row_main(2,3,5)[OF Linvw i j refl]"], ["proof (state)\nthis:\n  LLL_invariant True i fs \\<Longrightarrow>\n  LLL_invariant True i (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j])\n  \\<lbrakk>?c =\n           round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n   \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i\n                     (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) j\n  LLL_measure i (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) =\n  LLL_measure i fs\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "note step' = step'(1)[OF Linv] step'(2-)"], ["proof (state)\nthis:\n  LLL_invariant True i (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j])\n  \\<lbrakk>?c =\n           round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n   \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i\n                     (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) j\n  LLL_measure i (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) =\n  LLL_measure i fs\n\ngoal (1 subgoal):\n 1. \\<And>j fs.\n       \\<lbrakk>\\<And>fs.\n                   \\<lbrakk>LLL_bound_invariant False True i fs;\n                    \\<mu>_small_row i fs j; \\<mu>_bound_row_inner fs i j;\n                    basis_reduction_add_rows_loop i fs j = fs'; i < m;\n                    j \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True False i fs';\n        LLL_bound_invariant False True i fs; \\<mu>_small_row i fs (Suc j);\n        \\<mu>_bound_row_inner fs i (Suc j);\n        basis_reduction_add_rows_loop i fs (Suc j) = fs'; i < m;\n        Suc j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True False i fs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "proof (cases \"?c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) =\n    0 \\<Longrightarrow>\n    LLL_bound_invariant True False i fs'\n 2. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_bound_invariant True False i fs'", "case True"], ["proof (state)\nthis:\n  round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) = 0\n\ngoal (2 subgoals):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) =\n    0 \\<Longrightarrow>\n    LLL_bound_invariant True False i fs'\n 2. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_bound_invariant True False i fs'", "note inv = LLL_invD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (2 subgoals):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) =\n    0 \\<Longrightarrow>\n    LLL_bound_invariant True False i fs'\n 2. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_bound_invariant True False i fs'", "from inv(5)[OF i] inv(5)[of j] i j"], ["proof (chain)\npicking this:\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i \\<in> Rn\n  j < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) j \\<in> Rn\n  i < m\n  j < i", "have id: \"fs[i := fs ! i - 0 \\<cdot>\\<^sub>v fs ! j] = fs\""], ["proof (prove)\nusing this:\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i \\<in> Rn\n  j < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) j \\<in> Rn\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. fs[i := fs ! i - 0 \\<cdot>\\<^sub>v fs ! j] = fs", "by (intro nth_equalityI, insert inv i, auto)"], ["proof (state)\nthis:\n  fs[i := fs ! i - 0 \\<cdot>\\<^sub>v fs ! j] = fs\n\ngoal (2 subgoals):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) =\n    0 \\<Longrightarrow>\n    LLL_bound_invariant True False i fs'\n 2. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_bound_invariant True False i fs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "by (rule Suc(1), insert step step' id True Suc(2-), auto)"], ["proof (state)\nthis:\n  LLL_bound_invariant True False i fs'\n\ngoal (1 subgoal):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_bound_invariant True False i fs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_bound_invariant True False i fs'", "case False"], ["proof (state)\nthis:\n  round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq>\n    0 \\<Longrightarrow>\n    LLL_bound_invariant True False i fs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "using Suc(1)[OF step(1) step'(2) step(2)] Suc(2-) False step'(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) =\n           round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j);\n   \\<mu>_small_row i fs (Suc j);\n   basis_reduction_add_rows_loop i\n    (fs[i := fs ! i -\n             round\n              (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n                j) \\<cdot>\\<^sub>v\n             fs ! j])\n    j =\n   fs';\n   i < m; j \\<le> i\\<rbrakk>\n  \\<Longrightarrow> LLL_bound_invariant True False i fs'\n  LLL_bound_invariant False True i fs\n  \\<mu>_small_row i fs (Suc j)\n  \\<mu>_bound_row_inner fs i (Suc j)\n  basis_reduction_add_rows_loop i fs (Suc j) = fs'\n  i < m\n  Suc j \\<le> i\n  round (gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j) \\<noteq> 0\n  LLL_measure i (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) =\n  LLL_measure i fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "by auto"], ["proof (state)\nthis:\n  LLL_bound_invariant True False i fs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_bound_invariant True False i fs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_add_rows_bound: assumes \n  binv: \"LLL_bound_invariant True upw i fs\" \n  and res: \"basis_reduction_add_rows upw i fs = fs'\" \n  and i: \"i < m\" \nshows \"LLL_bound_invariant True False i fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "note def = basis_reduction_add_rows_def"], ["proof (state)\nthis:\n  basis_reduction_add_rows ?upw ?i ?fs =\n  (if ?upw then basis_reduction_add_rows_loop ?i ?fs ?i else ?fs)\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "proof (cases upw)"], ["proof (state)\ngoal (2 subgoals):\n 1. upw \\<Longrightarrow> LLL_bound_invariant True False i fs'\n 2. \\<not> upw \\<Longrightarrow> LLL_bound_invariant True False i fs'", "case False"], ["proof (state)\nthis:\n  \\<not> upw\n\ngoal (2 subgoals):\n 1. upw \\<Longrightarrow> LLL_bound_invariant True False i fs'\n 2. \\<not> upw \\<Longrightarrow> LLL_bound_invariant True False i fs'", "with res binv"], ["proof (chain)\npicking this:\n  basis_reduction_add_rows upw i fs = fs'\n  LLL_bound_invariant True upw i fs\n  \\<not> upw", "show ?thesis"], ["proof (prove)\nusing this:\n  basis_reduction_add_rows upw i fs = fs'\n  LLL_bound_invariant True upw i fs\n  \\<not> upw\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "by (simp add: def)"], ["proof (state)\nthis:\n  LLL_bound_invariant True False i fs'\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow> LLL_bound_invariant True False i fs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow> LLL_bound_invariant True False i fs'", "case True"], ["proof (state)\nthis:\n  upw\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow> LLL_bound_invariant True False i fs'", "with binv"], ["proof (chain)\npicking this:\n  LLL_bound_invariant True upw i fs\n  upw", "have binv: \"LLL_bound_invariant True True i fs\""], ["proof (prove)\nusing this:\n  LLL_bound_invariant True upw i fs\n  upw\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True i fs", "by auto"], ["proof (state)\nthis:\n  LLL_bound_invariant True True i fs\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow> LLL_bound_invariant True False i fs'", "note start = basis_reduction_add_rows_enter_bound[OF this i]"], ["proof (state)\nthis:\n  LLL_bound_invariant False True i fs\n  \\<mu>_bound_row_inner fs i i\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow> LLL_bound_invariant True False i fs'", "from res[unfolded def] True"], ["proof (chain)\npicking this:\n  (if upw then basis_reduction_add_rows_loop i fs i else fs) = fs'\n  upw", "have \"basis_reduction_add_rows_loop i fs i = fs'\""], ["proof (prove)\nusing this:\n  (if upw then basis_reduction_add_rows_loop i fs i else fs) = fs'\n  upw\n\ngoal (1 subgoal):\n 1. basis_reduction_add_rows_loop i fs i = fs'", "by auto"], ["proof (state)\nthis:\n  basis_reduction_add_rows_loop i fs i = fs'\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow> LLL_bound_invariant True False i fs'", "from basis_reduction_add_rows_loop_bound[OF start(1) \\<mu>_small_row_refl start(2) this i le_refl]"], ["proof (chain)\npicking this:\n  LLL_bound_invariant True False i fs'", "show ?thesis"], ["proof (prove)\nusing this:\n  LLL_bound_invariant True False i fs'\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs'", "by auto"], ["proof (state)\nthis:\n  LLL_bound_invariant True False i fs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_bound_invariant True False i fs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_bnd_swap:  \n  assumes i: \"i < m\" \"i \\<noteq> 0\"\n  and Linv: \"LLL_invariant_weak fs\"\n  and mu_F1_i: \"\\<bar>\\<mu> fs i (i-1)\\<bar> \\<le> 1 / 2\"\n  and cond: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\" \n  and fs'_def: \"fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]\" \n  and g_bnd: \"g_bnd B fs\" \nshows \"g_bnd B fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "note inv = LLL_inv_wD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "have choice: \"fs' ! k = fs ! k \\<or> fs' ! k = fs ! i \\<or> fs' ! k = fs ! (i - 1)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs' ! k = fs ! k \\<or> fs' ! k = fs ! i \\<or> fs' ! k = fs ! (i - 1)", "unfolding fs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs[i := fs ! (i - 1), i - 1 := fs ! i] ! k = fs ! k \\<or>\n    fs[i := fs ! (i - 1), i - 1 := fs ! i] ! k = fs ! i \\<or>\n    fs[i := fs ! (i - 1), i - 1 := fs ! i] ! k = fs ! (i - 1)", "using i inv(6)"], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n  length fs = m\n\ngoal (1 subgoal):\n 1. fs[i := fs ! (i - 1), i - 1 := fs ! i] ! k = fs ! k \\<or>\n    fs[i := fs ! (i - 1), i - 1 := fs ! i] ! k = fs ! i \\<or>\n    fs[i := fs ! (i - 1), i - 1 := fs ! i] ! k = fs ! (i - 1)", "by (cases \"k = i\"; cases \"k = i - 1\", auto)"], ["proof (state)\nthis:\n  fs' ! ?k1 = fs ! ?k1 \\<or>\n  fs' ! ?k1 = fs ! i \\<or> fs' ! ?k1 = fs ! (i - 1)\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "let ?g1 = \"\\<lambda> i. gso fs i\""], ["proof (state)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "let ?g2 = \"\\<lambda> i. gso fs' i\""], ["proof (state)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "let ?n1 = \"\\<lambda> i. sq_norm (?g1 i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "let ?n2 = \"\\<lambda> i. sq_norm (?g2 i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "from g_bnd[unfolded g_bnd_def]"], ["proof (chain)\npicking this:\n  \\<forall>i<m.\n     \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                 i\\<parallel>\\<^sup>2\n     \\<le> B", "have short: \"\\<And> k. k < m \\<Longrightarrow> ?n1 k \\<le> B\""], ["proof (prove)\nusing this:\n  \\<forall>i<m.\n     \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                 i\\<parallel>\\<^sup>2\n     \\<le> B\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < m \\<Longrightarrow>\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                   k\\<parallel>\\<^sup>2\n       \\<le> B", "by auto"], ["proof (state)\nthis:\n  ?k1 < m \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n              ?k1\\<parallel>\\<^sup>2\n  \\<le> B\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "from short[of \"i - 1\"] i"], ["proof (chain)\npicking this:\n  i - 1 < m \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> B\n  i < m\n  i \\<noteq> 0", "have short_im1: \"?n1 (i - 1) \\<le> B\""], ["proof (prove)\nusing this:\n  i - 1 < m \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> B\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                (i - 1)\\<parallel>\\<^sup>2\n    \\<le> B", "by auto"], ["proof (state)\nthis:\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> B\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "note swap = basis_reduction_swap_main[OF Linv disjI2[OF mu_F1_i] i cond fs'_def]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n  LLL_invariant False i fs \\<Longrightarrow> LLL_invariant False (i - 1) fs'\n  LLL_measure (i - 1) fs' < LLL_measure i fs\n  ?k < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?k =\n  (if ?k = i - 1\n   then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n         (i - 1) \\<cdot>\\<^sub>v\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (i - 1)\n   else if ?k = i\n        then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (i - 1) -\n             map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1) /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n        else gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?k)\n  ?k < m \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n              ?k\\<parallel>\\<^sup>2 =\n  (if ?k = i - 1\n   then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    i\\<parallel>\\<^sup>2 +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    (i - 1)\\<parallel>\\<^sup>2\n   else if ?k = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         i\\<parallel>\\<^sup>2 *\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2\n        else \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         ?k\\<parallel>\\<^sup>2)\n  \\<lbrakk>?ii < m; ?j < ?ii\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') ?ii\n                     ?j =\n                    (if ?ii = i - 1\n                     then gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) i ?j\n                     else if ?ii = i\n                          then if ?j = i - 1\n                               then gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) i (i - 1) *\n                                    \\<parallel>gram_schmidt_fs.gso n\n          (map of_int_hom.vec_hom fs) (i - 1)\\<parallel>\\<^sup>2 /\n                                    \\<parallel>gram_schmidt_fs.gso n\n          (map of_int_hom.vec_hom fs') (i - 1)\\<parallel>\\<^sup>2\n                               else gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) (i - 1) ?j\n                          else if i < ?ii \\<and> ?j = i\n                               then gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) ?ii\n                                     (i - 1) -\n                                    gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) i (i - 1) *\n                                    gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) ?ii i\n                               else if i < ?ii \\<and> ?j = i - 1\n                                    then gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ?ii (i - 1) *\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i (i - 1) +\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ?ii i *\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               i\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ?ii ?j)\n  ?ii \\<le> m \\<Longrightarrow>\n  rat_of_int (d fs' ?ii) =\n  (if ?ii = i\n   then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (i - 1)\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    (i - 1)\\<parallel>\\<^sup>2 *\n        rat_of_int (d fs i)\n   else rat_of_int (d fs ?ii))\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "note updates = swap(4,5)"], ["proof (state)\nthis:\n  ?k < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?k =\n  (if ?k = i - 1\n   then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n         (i - 1) \\<cdot>\\<^sub>v\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (i - 1)\n   else if ?k = i\n        then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (i - 1) -\n             map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1) /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (i - 1)\n        else gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?k)\n  ?k < m \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n              ?k\\<parallel>\\<^sup>2 =\n  (if ?k = i - 1\n   then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    i\\<parallel>\\<^sup>2 +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    (i - 1)\\<parallel>\\<^sup>2\n   else if ?k = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         i\\<parallel>\\<^sup>2 *\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (i - 1)\\<parallel>\\<^sup>2\n        else \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         ?k\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "note Linv' = swap(1)"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "note inv' = LLL_inv_wD[OF Linv']"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "note inv = LLL_inv_wD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "interpret gs1: gram_schmidt_fs_int n \"RAT fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_int n (map of_int_hom.vec_hom fs)", "by (standard) (use inv gs.lin_indpt_list_def in \\<open>auto simp add: vec_hom_Ints\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "interpret gs2: gram_schmidt_fs_int n \"RAT fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs_int n (map of_int_hom.vec_hom fs')", "by (standard) (use inv' gs.lin_indpt_list_def in \\<open>auto simp add: vec_hom_Ints\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "let ?mu1 = \"\\<mu> fs\""], ["proof (state)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "let ?mu2 = \"\\<mu> fs'\""], ["proof (state)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "let ?mu = \"?mu1 i (i - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "have mu: \"abs ?mu \\<le> 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gs1.\\<mu> i (i - 1)\\<bar> \\<le> 1 / 2", "using mu_F1_i"], ["proof (prove)\nusing this:\n  \\<bar>gs1.\\<mu> i (i - 1)\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<bar>gs1.\\<mu> i (i - 1)\\<bar> \\<le> 1 / 2", "."], ["proof (state)\nthis:\n  \\<bar>gs1.\\<mu> i (i - 1)\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "have \"?n2 (i - 1) = ?n1 i + ?mu * ?mu * ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n    \\<parallel>gs1.gso i\\<parallel>\\<^sup>2 +\n    gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n    \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "by (subst updates(2), insert i, auto)"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>gs1.gso i\\<parallel>\\<^sup>2 +\n  gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "also"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>gs1.gso i\\<parallel>\\<^sup>2 +\n  gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "have \"\\<dots> = inverse \\<alpha> * (\\<alpha> * ?n1 i) + (?mu * ?mu) * ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs1.gso i\\<parallel>\\<^sup>2 +\n    gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n    \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 =\n    inverse \\<alpha> *\n    (\\<alpha> * \\<parallel>gs1.gso i\\<parallel>\\<^sup>2) +\n    gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n    \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "using \\<alpha>"], ["proof (prove)\nusing this:\n  4 / 3 \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<parallel>gs1.gso i\\<parallel>\\<^sup>2 +\n    gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n    \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 =\n    inverse \\<alpha> *\n    (\\<alpha> * \\<parallel>gs1.gso i\\<parallel>\\<^sup>2) +\n    gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n    \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<parallel>gs1.gso i\\<parallel>\\<^sup>2 +\n  gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 =\n  inverse \\<alpha> * (\\<alpha> * \\<parallel>gs1.gso i\\<parallel>\\<^sup>2) +\n  gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "also"], ["proof (state)\nthis:\n  \\<parallel>gs1.gso i\\<parallel>\\<^sup>2 +\n  gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 =\n  inverse \\<alpha> * (\\<alpha> * \\<parallel>gs1.gso i\\<parallel>\\<^sup>2) +\n  gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "have \"\\<dots> \\<le> inverse \\<alpha> * ?n1 (i - 1) + (abs ?mu * abs ?mu) * ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse \\<alpha> *\n    (\\<alpha> * \\<parallel>gs1.gso i\\<parallel>\\<^sup>2) +\n    gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n    \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> inverse \\<alpha> * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 +\n          \\<bar>gs1.\\<mu> i (i - 1)\\<bar> *\n          \\<bar>gs1.\\<mu> i (i - 1)\\<bar> *\n          \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "by (rule add_mono[OF mult_left_mono], insert cond \\<alpha>, auto)"], ["proof (state)\nthis:\n  inverse \\<alpha> * (\\<alpha> * \\<parallel>gs1.gso i\\<parallel>\\<^sup>2) +\n  gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> inverse \\<alpha> * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 +\n        \\<bar>gs1.\\<mu> i (i - 1)\\<bar> * \\<bar>gs1.\\<mu> i (i - 1)\\<bar> *\n        \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "also"], ["proof (state)\nthis:\n  inverse \\<alpha> * (\\<alpha> * \\<parallel>gs1.gso i\\<parallel>\\<^sup>2) +\n  gs1.\\<mu> i (i - 1) * gs1.\\<mu> i (i - 1) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> inverse \\<alpha> * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 +\n        \\<bar>gs1.\\<mu> i (i - 1)\\<bar> * \\<bar>gs1.\\<mu> i (i - 1)\\<bar> *\n        \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "have \"\\<dots> = (inverse \\<alpha> + abs ?mu * abs ?mu) * ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse \\<alpha> * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 +\n    \\<bar>gs1.\\<mu> i (i - 1)\\<bar> * \\<bar>gs1.\\<mu> i (i - 1)\\<bar> *\n    \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 =\n    (inverse \\<alpha> +\n     \\<bar>gs1.\\<mu> i (i - 1)\\<bar> * \\<bar>gs1.\\<mu> i (i - 1)\\<bar>) *\n    \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  inverse \\<alpha> * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 +\n  \\<bar>gs1.\\<mu> i (i - 1)\\<bar> * \\<bar>gs1.\\<mu> i (i - 1)\\<bar> *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 =\n  (inverse \\<alpha> +\n   \\<bar>gs1.\\<mu> i (i - 1)\\<bar> * \\<bar>gs1.\\<mu> i (i - 1)\\<bar>) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "also"], ["proof (state)\nthis:\n  inverse \\<alpha> * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 +\n  \\<bar>gs1.\\<mu> i (i - 1)\\<bar> * \\<bar>gs1.\\<mu> i (i - 1)\\<bar> *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 =\n  (inverse \\<alpha> +\n   \\<bar>gs1.\\<mu> i (i - 1)\\<bar> * \\<bar>gs1.\\<mu> i (i - 1)\\<bar>) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "have \"\\<dots> \\<le> (inverse \\<alpha> + (1/2) * (1/2)) * ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse \\<alpha> +\n     \\<bar>gs1.\\<mu> i (i - 1)\\<bar> * \\<bar>gs1.\\<mu> i (i - 1)\\<bar>) *\n    \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> (inverse \\<alpha> + 1 / 2 * (1 / 2)) *\n          \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "by (rule mult_right_mono[OF add_left_mono[OF mult_mono]], insert mu, auto)"], ["proof (state)\nthis:\n  (inverse \\<alpha> +\n   \\<bar>gs1.\\<mu> i (i - 1)\\<bar> * \\<bar>gs1.\\<mu> i (i - 1)\\<bar>) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> (inverse \\<alpha> + 1 / 2 * (1 / 2)) *\n        \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "also"], ["proof (state)\nthis:\n  (inverse \\<alpha> +\n   \\<bar>gs1.\\<mu> i (i - 1)\\<bar> * \\<bar>gs1.\\<mu> i (i - 1)\\<bar>) *\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> (inverse \\<alpha> + 1 / 2 * (1 / 2)) *\n        \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "have \"inverse \\<alpha> + (1/2) * (1/2) = reduction\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse \\<alpha> + 1 / 2 * (1 / 2) = reduction", "unfolding reduction_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse \\<alpha> + 1 / 2 * (1 / 2) = (4 + \\<alpha>) / (4 * \\<alpha>)", "using \\<alpha>0"], ["proof (prove)\nusing this:\n  0 < \\<alpha>\n  \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inverse \\<alpha> + 1 / 2 * (1 / 2) = (4 + \\<alpha>) / (4 * \\<alpha>)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  inverse \\<alpha> + 1 / 2 * (1 / 2) = reduction\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "also"], ["proof (state)\nthis:\n  inverse \\<alpha> + 1 / 2 * (1 / 2) = reduction\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "have \"\\<dots> * ?n1 (i - 1) \\<le> 1 * ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduction * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> 1 * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "by (rule mult_right_mono, auto simp: reduction)"], ["proof (state)\nthis:\n  reduction * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> 1 * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> 1 * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have n2im1: \"?n2 (i - 1) \\<le> ?n1 (i - 1)\""], ["proof (prove)\nusing this:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> 1 * \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. g_bnd B fs'", "show \"g_bnd B fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_bnd B fs'", "unfolding g_bnd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<m. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<le> B", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<le> B", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<le> B", "assume km: \"k < m\""], ["proof (state)\nthis:\n  k < m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<le> B", "consider (ki) \"k = i\" | (im1) \"k = i - 1\" | (other) \"k \\<noteq> i\" \"k \\<noteq> i-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k = i \\<Longrightarrow> thesis;\n     k = i - 1 \\<Longrightarrow> thesis;\n     \\<lbrakk>k \\<noteq> i; k \\<noteq> i - 1\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>k = i \\<Longrightarrow> ?thesis1;\n   k = i - 1 \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>k \\<noteq> i; k \\<noteq> i - 1\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 \\<le> B", "thus \"?n2 k \\<le> B\""], ["proof (prove)\nusing this:\n  \\<lbrakk>k = i \\<Longrightarrow> ?thesis1;\n   k = i - 1 \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>k \\<noteq> i; k \\<noteq> i - 1\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 3. \\<lbrakk>k \\<noteq> i; k \\<noteq> i - 1\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "case other"], ["proof (state)\nthis:\n  k \\<noteq> i\n  k \\<noteq> i - 1\n\ngoal (3 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 3. \\<lbrakk>k \\<noteq> i; k \\<noteq> i - 1\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "from short[OF km]"], ["proof (chain)\npicking this:\n  \\<parallel>gs1.gso k\\<parallel>\\<^sup>2 \\<le> B", "have \"?n1 k \\<le> B\""], ["proof (prove)\nusing this:\n  \\<parallel>gs1.gso k\\<parallel>\\<^sup>2 \\<le> B\n\ngoal (1 subgoal):\n 1. \\<parallel>gs1.gso k\\<parallel>\\<^sup>2 \\<le> B", "by auto"], ["proof (state)\nthis:\n  \\<parallel>gs1.gso k\\<parallel>\\<^sup>2 \\<le> B\n\ngoal (3 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 3. \\<lbrakk>k \\<noteq> i; k \\<noteq> i - 1\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "also"], ["proof (state)\nthis:\n  \\<parallel>gs1.gso k\\<parallel>\\<^sup>2 \\<le> B\n\ngoal (3 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 3. \\<lbrakk>k \\<noteq> i; k \\<noteq> i - 1\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "have \"?n1 k = ?n2 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs1.gso k\\<parallel>\\<^sup>2 =\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2", "using km other"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> i\n  k \\<noteq> i - 1\n\ngoal (1 subgoal):\n 1. \\<parallel>gs1.gso k\\<parallel>\\<^sup>2 =\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2", "by (subst updates(2), auto)"], ["proof (state)\nthis:\n  \\<parallel>gs1.gso k\\<parallel>\\<^sup>2 =\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2\n\ngoal (3 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 3. \\<lbrakk>k \\<noteq> i; k \\<noteq> i - 1\\<rbrakk>\n    \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "by simp"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "case im1"], ["proof (state)\nthis:\n  k = i - 1\n\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "have \"?n2 k = ?n2 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", "unfolding im1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2 =\n    \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2", ".."], ["proof (state)\nthis:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "also"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "have \"\\<dots> \\<le> ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "by fact"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "also"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "have \"\\<dots> \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 \\<le> B", "using short_im1"], ["proof (prove)\nusing this:\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 \\<le> B\n\ngoal (1 subgoal):\n 1. \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 \\<le> B", "by auto"], ["proof (state)\nthis:\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 \\<le> B\n\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n 2. k = i - 1 \\<Longrightarrow>\n    \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "by simp"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "case ki"], ["proof (state)\nthis:\n  k = i\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "have \"?n2 k = ?n2 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n    \\<parallel>gs2.gso i\\<parallel>\\<^sup>2", "unfolding ki"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n    \\<parallel>gs2.gso i\\<parallel>\\<^sup>2", "using i"], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2 =\n    \\<parallel>gs2.gso i\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "also"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 =\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "have \"\\<dots> \\<le> ?n1 (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "let ?f1 = \"\\<lambda> i. RAT fs ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "let ?f2 = \"\\<lambda> i. RAT fs' ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "define u where \"u = gs.sumlist (map (\\<lambda>j. ?mu1 (i - 1) j \\<cdot>\\<^sub>v ?g1 j) [0..<i - 1])\""], ["proof (state)\nthis:\n  u =\n  gs.M.sumlist\n   (map (\\<lambda>j. gs1.\\<mu> (i - 1) j \\<cdot>\\<^sub>v gs1.gso j)\n     [0..<i - 1])\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "define U where \"U = ?f1 ` {0 ..< i - 1} \\<union> {?f1 i}\""], ["proof (state)\nthis:\n  U =\n  (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1} \\<union>\n  {map of_int_hom.vec_hom fs ! i}\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have g2i: \"?g2 i \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs2.gso i \\<in> Rn", "using i inv'"], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs2.gso ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n\ngoal (1 subgoal):\n 1. gs2.gso i \\<in> Rn", "by simp"], ["proof (state)\nthis:\n  gs2.gso i \\<in> Rn\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have U: \"U \\<subseteq> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> Rn", "unfolding U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1} \\<union>\n    {map of_int_hom.vec_hom fs ! i}\n    \\<subseteq> Rn", "using inv i"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1} \\<union>\n    {map of_int_hom.vec_hom fs ! i}\n    \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  U \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have uU: \"u \\<in> gs.span U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> gs.span U", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> gs.span U", "have im1: \"i - 1 \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - 1 \\<le> m", "using i"], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i - 1 \\<le> m", "by auto"], ["proof (state)\nthis:\n  i - 1 \\<le> m\n\ngoal (1 subgoal):\n 1. u \\<in> gs.span U", "have G1: \"?g1 ` {0..< i - 1} \\<subseteq> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs1.gso ` {0..<i - 1} \\<subseteq> Rn", "using inv(5) i"], ["proof (prove)\nusing this:\n  ?i < m \\<Longrightarrow> gs1.gso ?i \\<in> Rn\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gs1.gso ` {0..<i - 1} \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  gs1.gso ` {0..<i - 1} \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. u \\<in> gs.span U", "have \"u \\<in> gs.span (?g1 ` {0 ..< i - 1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> gs.span (gs1.gso ` {0..<i - 1})", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.M.sumlist\n     (map (\\<lambda>j. gs1.\\<mu> (i - 1) j \\<cdot>\\<^sub>v gs1.gso j)\n       [0..<i - 1])\n    \\<in> gs.span (gs1.gso ` {0..<i - 1})", "by (rule gs.sumlist_in_span[OF G1], unfold set_map, insert G1,\n              auto intro!: gs.smult_in_span intro: gs.span_mem)"], ["proof (state)\nthis:\n  u \\<in> gs.span (gs1.gso ` {0..<i - 1})\n\ngoal (1 subgoal):\n 1. u \\<in> gs.span U", "also"], ["proof (state)\nthis:\n  u \\<in> gs.span (gs1.gso ` {0..<i - 1})\n\ngoal (1 subgoal):\n 1. u \\<in> gs.span U", "have \"gs.span (?g1 ` {0 ..< i - 1}) = gs.span (?f1 ` {0 ..< i - 1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (gs1.gso ` {0..<i - 1}) =\n    gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})", "apply(subst gs1.partial_span, insert im1 inv, unfold gs.lin_indpt_list_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i - 1 \\<le> m;\n     set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n     distinct (map of_int_hom.vec_hom fs) \\<and>\n     gs.lin_indpt (set (map of_int_hom.vec_hom fs));\n     length (map of_int_hom.vec_hom fs) = m;\n     set fs \\<subseteq> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> gs1.gso i \\<in> Rn; length fs = m;\n     lattice_of fs = L\\<rbrakk>\n    \\<Longrightarrow> i - 1 \\<le> length (map of_int_hom.vec_hom fs)\n 2. \\<lbrakk>i - 1 \\<le> m;\n     set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n     distinct (map of_int_hom.vec_hom fs) \\<and>\n     gs.lin_indpt (set (map of_int_hom.vec_hom fs));\n     length (map of_int_hom.vec_hom fs) = m;\n     set fs \\<subseteq> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> gs1.gso i \\<in> Rn; length fs = m;\n     lattice_of fs = L\\<rbrakk>\n    \\<Longrightarrow> gs.span\n                       (set (take (i - 1) (map of_int_hom.vec_hom fs))) =\n                      gs.span\n                       ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i - 1 \\<le> m;\n     set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n     distinct (map of_int_hom.vec_hom fs) \\<and>\n     gs.lin_indpt (set (map of_int_hom.vec_hom fs));\n     length (map of_int_hom.vec_hom fs) = m;\n     set fs \\<subseteq> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> gs1.gso i \\<in> Rn; length fs = m;\n     lattice_of fs = L\\<rbrakk>\n    \\<Longrightarrow> gs.span\n                       (set (take (i - 1) (map of_int_hom.vec_hom fs))) =\n                      gs.span\n                       ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})", "apply(rule arg_cong[of _ _ gs.span])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i - 1 \\<le> m;\n     set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n     distinct (map of_int_hom.vec_hom fs) \\<and>\n     gs.lin_indpt (set (map of_int_hom.vec_hom fs));\n     length (map of_int_hom.vec_hom fs) = m;\n     set fs \\<subseteq> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> gs1.gso i \\<in> Rn; length fs = m;\n     lattice_of fs = L\\<rbrakk>\n    \\<Longrightarrow> set (take (i - 1) (map of_int_hom.vec_hom fs)) =\n                      (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}", "apply(subst nth_image[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i - 1 \\<le> m;\n     set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n     distinct (map of_int_hom.vec_hom fs) \\<and>\n     gs.lin_indpt (set (map of_int_hom.vec_hom fs));\n     length (map of_int_hom.vec_hom fs) = m;\n     set fs \\<subseteq> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> gs1.gso i \\<in> Rn; length fs = m;\n     lattice_of fs = L\\<rbrakk>\n    \\<Longrightarrow> i - 1 \\<le> length (map of_int_hom.vec_hom fs)\n 2. \\<lbrakk>i - 1 \\<le> m;\n     set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n     distinct (map of_int_hom.vec_hom fs) \\<and>\n     gs.lin_indpt (set (map of_int_hom.vec_hom fs));\n     length (map of_int_hom.vec_hom fs) = m;\n     set fs \\<subseteq> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> gs1.gso i \\<in> Rn; length fs = m;\n     lattice_of fs = L\\<rbrakk>\n    \\<Longrightarrow> (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1} =\n                      (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1}", "by (insert i inv, auto)"], ["proof (state)\nthis:\n  gs.span (gs1.gso ` {0..<i - 1}) =\n  gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})\n\ngoal (1 subgoal):\n 1. u \\<in> gs.span U", "also"], ["proof (state)\nthis:\n  gs.span (gs1.gso ` {0..<i - 1}) =\n  gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})\n\ngoal (1 subgoal):\n 1. u \\<in> gs.span U", "have \"\\<dots> \\<subseteq> gs.span U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})\n    \\<subseteq> gs.span U", "unfolding U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})\n    \\<subseteq> gs.span\n                 ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1} \\<union>\n                  {map of_int_hom.vec_hom fs ! i})", "by (rule gs.span_is_monotone, auto)"], ["proof (state)\nthis:\n  gs.span ((!) (map of_int_hom.vec_hom fs) ` {0..<i - 1})\n  \\<subseteq> gs.span U\n\ngoal (1 subgoal):\n 1. u \\<in> gs.span U", "finally"], ["proof (chain)\npicking this:\n  u \\<in> gs.span U", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> gs.span U\n\ngoal (1 subgoal):\n 1. u \\<in> gs.span U", "."], ["proof (state)\nthis:\n  u \\<in> gs.span U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> gs.span U\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "from i"], ["proof (chain)\npicking this:\n  i < m\n  i \\<noteq> 0", "have im1: \"i - 1 < m\""], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i - 1 < m", "by auto"], ["proof (state)\nthis:\n  i - 1 < m\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have u: \"u \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> Rn", "using uU U"], ["proof (prove)\nusing this:\n  u \\<in> gs.span U\n  U \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. u \\<in> Rn", "by simp"], ["proof (state)\nthis:\n  u \\<in> Rn\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have id_u: \"u + (?g1 (i - 1) - ?g2 i) = u + ?g1 (i - 1) - ?g2 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u + (gs1.gso (i - 1) - gs2.gso i) = u + gs1.gso (i - 1) - gs2.gso i", "using u g2i inv(5)[OF im1]"], ["proof (prove)\nusing this:\n  u \\<in> Rn\n  gs2.gso i \\<in> Rn\n  gs1.gso (i - 1) \\<in> Rn\n\ngoal (1 subgoal):\n 1. u + (gs1.gso (i - 1) - gs2.gso i) = u + gs1.gso (i - 1) - gs2.gso i", "by auto"], ["proof (state)\nthis:\n  u + (gs1.gso (i - 1) - gs2.gso i) = u + gs1.gso (i - 1) - gs2.gso i\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have list_id: \"[0..<Suc (i - 1)] = [0..< i - 1] @ [i - 1]\" \n          \"map f [x] = [f x]\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (i - 1)] = [0..<i - 1] @ [i - 1] &&& map f [x] = [f x]", "by auto"], ["proof (state)\nthis:\n  [0..<Suc (i - 1)] = [0..<i - 1] @ [i - 1]\n  map ?f2 [?x2] = [?f2 ?x2]\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have \"gs.is_oc_projection (gs2.gso i) (gs.span (gs2.gso ` {0..<i})) ((RAT fs') ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.is_oc_projection (gs2.gso i) (gs.span (gs2.gso ` {0..<i}))\n     (map of_int_hom.vec_hom fs' ! i)", "using i inv'"], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs2.gso ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n\ngoal (1 subgoal):\n 1. gs.is_oc_projection (gs2.gso i) (gs.span (gs2.gso ` {0..<i}))\n     (map of_int_hom.vec_hom fs' ! i)", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs') \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs2.gso ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n\ngoal (1 subgoal):\n 1. gs.is_oc_projection (gs2.gso i) (gs.span (gs2.gso ` {0..<i}))\n     (map of_int_hom.vec_hom fs' ! i)", "by (intro gs2.gso_oc_projection_span(2)) auto"], ["proof (state)\nthis:\n  gs.is_oc_projection (gs2.gso i) (gs.span (gs2.gso ` {0..<i}))\n   (map of_int_hom.vec_hom fs' ! i)\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  gs.is_oc_projection (gs2.gso i) (gs.span (gs2.gso ` {0..<i}))\n   (map of_int_hom.vec_hom fs' ! i)", "have \"gs.is_oc_projection (?g2 i) (gs.span (gs2.gso ` {0 ..< i}))  (?f1 (i - 1))\""], ["proof (prove)\nusing this:\n  gs.is_oc_projection (gs2.gso i) (gs.span (gs2.gso ` {0..<i}))\n   (map of_int_hom.vec_hom fs' ! i)\n\ngoal (1 subgoal):\n 1. gs.is_oc_projection (gs2.gso i) (gs.span (gs2.gso ` {0..<i}))\n     (map of_int_hom.vec_hom fs ! (i - 1))", "unfolding fs'_def"], ["proof (prove)\nusing this:\n  gs.is_oc_projection\n   (gram_schmidt_fs.gso n\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) i)\n   (gs.span\n     (gram_schmidt_fs.gso n\n       (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) `\n      {0..<i}))\n   (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) ! i)\n\ngoal (1 subgoal):\n 1. gs.is_oc_projection\n     (gram_schmidt_fs.gso n\n       (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) i)\n     (gs.span\n       (gram_schmidt_fs.gso n\n         (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) `\n        {0..<i}))\n     (map of_int_hom.vec_hom fs ! (i - 1))", "using inv(6) i"], ["proof (prove)\nusing this:\n  gs.is_oc_projection\n   (gram_schmidt_fs.gso n\n     (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) i)\n   (gs.span\n     (gram_schmidt_fs.gso n\n       (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) `\n      {0..<i}))\n   (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) ! i)\n  length fs = m\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gs.is_oc_projection\n     (gram_schmidt_fs.gso n\n       (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) i)\n     (gs.span\n       (gram_schmidt_fs.gso n\n         (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) `\n        {0..<i}))\n     (map of_int_hom.vec_hom fs ! (i - 1))", "by auto"], ["proof (state)\nthis:\n  gs.is_oc_projection (gs2.gso i) (gs.span (gs2.gso ` {0..<i}))\n   (map of_int_hom.vec_hom fs ! (i - 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  gs.is_oc_projection (gs2.gso i) (gs.span (gs2.gso ` {0..<i}))\n   (map of_int_hom.vec_hom fs ! (i - 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have \"?f1 (i - 1) = u + ?g1 (i - 1) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. map of_int_hom.vec_hom fs ! (i - 1) = u + gs1.gso (i - 1)", "apply(subst gs1.fi_is_sum_of_mu_gso, insert im1 inv, unfold gs.lin_indpt_list_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i - 1 < m;\n     set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n     distinct (map of_int_hom.vec_hom fs) \\<and>\n     gs.lin_indpt (set (map of_int_hom.vec_hom fs));\n     length (map of_int_hom.vec_hom fs) = m;\n     set fs \\<subseteq> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> gs1.gso i \\<in> Rn; length fs = m;\n     lattice_of fs = L\\<rbrakk>\n    \\<Longrightarrow> i - 1 < length (map of_int_hom.vec_hom fs)\n 2. \\<lbrakk>i - 1 < m;\n     set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n     distinct (map of_int_hom.vec_hom fs) \\<and>\n     gs.lin_indpt (set (map of_int_hom.vec_hom fs));\n     length (map of_int_hom.vec_hom fs) = m;\n     set fs \\<subseteq> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> gs1.gso i \\<in> Rn; length fs = m;\n     lattice_of fs = L\\<rbrakk>\n    \\<Longrightarrow> gs.M.sumlist\n                       (map (\\<lambda>j.\n                                gs1.\\<mu> (i - 1) j \\<cdot>\\<^sub>v\n                                gs1.gso j)\n                         [0..<Suc (i - 1)]) =\n                      u + gs1.gso (i - 1)", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i - 1 < m;\n     set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n     distinct (map of_int_hom.vec_hom fs) \\<and>\n     gs.lin_indpt (set (map of_int_hom.vec_hom fs));\n     length (map of_int_hom.vec_hom fs) = m;\n     set fs \\<subseteq> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> gs1.gso i \\<in> Rn; length fs = m;\n     lattice_of fs = L\\<rbrakk>\n    \\<Longrightarrow> gs.M.sumlist\n                       (map (\\<lambda>j.\n                                gs1.\\<mu> (i - 1) j \\<cdot>\\<^sub>v\n                                gs1.gso j)\n                         [0..<Suc (i - 1)]) =\n                      u + gs1.gso (i - 1)", "unfolding list_id map_append u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i - 1 < m;\n     set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n     distinct (map of_int_hom.vec_hom fs) \\<and>\n     gs.lin_indpt (set (map of_int_hom.vec_hom fs));\n     length (map of_int_hom.vec_hom fs) = m;\n     set fs \\<subseteq> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> fs ! i \\<in> carrier_vec n;\n     \\<And>i. i < m \\<Longrightarrow> gs1.gso i \\<in> Rn; length fs = m;\n     lattice_of fs = L\\<rbrakk>\n    \\<Longrightarrow> gs.M.sumlist\n                       (map (\\<lambda>j.\n                                gs1.\\<mu> (i - 1) j \\<cdot>\\<^sub>v\n                                gs1.gso j)\n                         [0..<i - 1] @\n                        [gs1.\\<mu> (i - 1) (i - 1) \\<cdot>\\<^sub>v\n                         gs1.gso (i - 1)]) =\n                      gs.M.sumlist\n                       (map (\\<lambda>j.\n                                gs1.\\<mu> (i - 1) j \\<cdot>\\<^sub>v\n                                gs1.gso j)\n                         [0..<i - 1]) +\n                      gs1.gso (i - 1)", "by (subst gs.M.sumlist_snoc, insert i, auto simp: gs1.\\<mu>.simps intro!: inv(5))"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) = u + gs1.gso (i - 1)\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  map of_int_hom.vec_hom fs ! (i - 1) = u + gs1.gso (i - 1)\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have \"gs.span (gs2.gso ` {0 ..< i}) = gs.span (set (take i (RAT fs')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (gs2.gso ` {0..<i}) =\n    gs.span (set (take i (map of_int_hom.vec_hom fs')))", "using inv' \\<open>i < m\\<close>"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs2.gso ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n  i < m\n\ngoal (1 subgoal):\n 1. gs.span (gs2.gso ` {0..<i}) =\n    gs.span (set (take i (map of_int_hom.vec_hom fs')))", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs') \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs') \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs'))\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> gs2.gso ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n  i < m\n\ngoal (1 subgoal):\n 1. gs.span (gs2.gso ` {0..<i}) =\n    gs.span (set (take i (map of_int_hom.vec_hom fs')))", "by (subst gs2.partial_span) auto"], ["proof (state)\nthis:\n  gs.span (gs2.gso ` {0..<i}) =\n  gs.span (set (take i (map of_int_hom.vec_hom fs')))\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  gs.span (gs2.gso ` {0..<i}) =\n  gs.span (set (take i (map of_int_hom.vec_hom fs')))\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have \"set (take i (RAT fs')) = ?f2 ` {0 ..< i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take i (map of_int_hom.vec_hom fs')) =\n    (!) (map of_int_hom.vec_hom fs') ` {0..<i}", "using inv'(6) i"], ["proof (prove)\nusing this:\n  length fs' = m\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set (take i (map of_int_hom.vec_hom fs')) =\n    (!) (map of_int_hom.vec_hom fs') ` {0..<i}", "by (subst nth_image[symmetric], auto)"], ["proof (state)\nthis:\n  set (take i (map of_int_hom.vec_hom fs')) =\n  (!) (map of_int_hom.vec_hom fs') ` {0..<i}\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  set (take i (map of_int_hom.vec_hom fs')) =\n  (!) (map of_int_hom.vec_hom fs') ` {0..<i}\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have \"{0 ..< i} = {0 ..< i - 1} \\<union> {(i - 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<i} = {0..<i - 1} \\<union> {i - 1}", "using i"], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {0..<i} = {0..<i - 1} \\<union> {i - 1}", "by auto"], ["proof (state)\nthis:\n  {0..<i} = {0..<i - 1} \\<union> {i - 1}\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  {0..<i} = {0..<i - 1} \\<union> {i - 1}\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have \"?f2 ` \\<dots> = ?f2 ` {0 ..< i - 1} \\<union> {?f2 (i - 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom fs') ` ({0..<i - 1} \\<union> {i - 1}) =\n    (!) (map of_int_hom.vec_hom fs') ` {0..<i - 1} \\<union>\n    {map of_int_hom.vec_hom fs' ! (i - 1)}", "by auto"], ["proof (state)\nthis:\n  (!) (map of_int_hom.vec_hom fs') ` ({0..<i - 1} \\<union> {i - 1}) =\n  (!) (map of_int_hom.vec_hom fs') ` {0..<i - 1} \\<union>\n  {map of_int_hom.vec_hom fs' ! (i - 1)}\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  (!) (map of_int_hom.vec_hom fs') ` ({0..<i - 1} \\<union> {i - 1}) =\n  (!) (map of_int_hom.vec_hom fs') ` {0..<i - 1} \\<union>\n  {map of_int_hom.vec_hom fs' ! (i - 1)}\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "have \"\\<dots> = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom fs') ` {0..<i - 1} \\<union>\n    {map of_int_hom.vec_hom fs' ! (i - 1)} =\n    U", "unfolding U_def fs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) (map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i])) `\n    {0..<i - 1} \\<union>\n    {map of_int_hom.vec_hom (fs[i := fs ! (i - 1), i - 1 := fs ! i]) !\n     (i - 1)} =\n    (!) (map of_int_hom.vec_hom fs) ` {0..<i - 1} \\<union>\n    {map of_int_hom.vec_hom fs ! i}", "by (rule arg_cong2[of _ _ _ _ \"(\\<union>)\"], insert i inv(6), force+)"], ["proof (state)\nthis:\n  (!) (map of_int_hom.vec_hom fs') ` {0..<i - 1} \\<union>\n  {map of_int_hom.vec_hom fs' ! (i - 1)} =\n  U\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  gs.is_oc_projection (gs2.gso i) (gs.span U) (u + gs1.gso (i - 1))", "have \"gs.is_oc_projection (?g2 i) (gs.span U) (u + ?g1 (i - 1))\""], ["proof (prove)\nusing this:\n  gs.is_oc_projection (gs2.gso i) (gs.span U) (u + gs1.gso (i - 1))\n\ngoal (1 subgoal):\n 1. gs.is_oc_projection (gs2.gso i) (gs.span U) (u + gs1.gso (i - 1))", "."], ["proof (state)\nthis:\n  gs.is_oc_projection (gs2.gso i) (gs.span U) (u + gs1.gso (i - 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "hence proj: \"gs.is_oc_projection (?g2 i) (gs.span U) (?g1 (i - 1))\""], ["proof (prove)\nusing this:\n  gs.is_oc_projection (gs2.gso i) (gs.span U) (u + gs1.gso (i - 1))\n\ngoal (1 subgoal):\n 1. gs.is_oc_projection (gs2.gso i) (gs.span U) (gs1.gso (i - 1))", "unfolding gs.is_oc_projection_def"], ["proof (prove)\nusing this:\n  gs2.gso i \\<in> Rn \\<and>\n  u + gs1.gso (i - 1) - gs2.gso i \\<in> gs.span (gs.span U) \\<and>\n  (\\<forall>u.\n      u \\<in> gs.span U \\<longrightarrow> gs2.gso i \\<bullet> u = 0)\n\ngoal (1 subgoal):\n 1. gs2.gso i \\<in> Rn \\<and>\n    gs1.gso (i - 1) - gs2.gso i \\<in> gs.span (gs.span U) \\<and>\n    (\\<forall>u.\n        u \\<in> gs.span U \\<longrightarrow> gs2.gso i \\<bullet> u = 0)", "using gs.span_add[OF U uU, of \"?g1 (i - 1) - ?g2 i\"] \n          inv(5)[OF im1] g2i u id_u"], ["proof (prove)\nusing this:\n  gs2.gso i \\<in> Rn \\<and>\n  u + gs1.gso (i - 1) - gs2.gso i \\<in> gs.span (gs.span U) \\<and>\n  (\\<forall>u.\n      u \\<in> gs.span U \\<longrightarrow> gs2.gso i \\<bullet> u = 0)\n  gs1.gso (i - 1) - gs2.gso i \\<in> Rn \\<Longrightarrow>\n  (gs1.gso (i - 1) - gs2.gso i \\<in> gs.span U) =\n  (u + (gs1.gso (i - 1) - gs2.gso i) \\<in> gs.span U)\n  gs1.gso (i - 1) \\<in> Rn\n  gs2.gso i \\<in> Rn\n  u \\<in> Rn\n  u + (gs1.gso (i - 1) - gs2.gso i) = u + gs1.gso (i - 1) - gs2.gso i\n\ngoal (1 subgoal):\n 1. gs2.gso i \\<in> Rn \\<and>\n    gs1.gso (i - 1) - gs2.gso i \\<in> gs.span (gs.span U) \\<and>\n    (\\<forall>u.\n        u \\<in> gs.span U \\<longrightarrow> gs2.gso i \\<bullet> u = 0)", "by (auto simp: U)"], ["proof (state)\nthis:\n  gs.is_oc_projection (gs2.gso i) (gs.span U) (gs1.gso (i - 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "from gs.is_oc_projection_sq_norm[OF this gs.span_is_subset2[OF U]  inv(5)[OF im1]]"], ["proof (chain)\npicking this:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "show \"?n2 i \\<le> ?n1 (i - 1)\""], ["proof (prove)\nusing this:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2", "."], ["proof (state)\nthis:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "also"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso i\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "have \"\\<dots> \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 \\<le> B", "by fact"], ["proof (state)\nthis:\n  \\<parallel>gs1.gso (i - 1)\\<parallel>\\<^sup>2 \\<le> B\n\ngoal (1 subgoal):\n 1. k = i \\<Longrightarrow> \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n\ngoal (1 subgoal):\n 1. \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B", "."], ["proof (state)\nthis:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<parallel>gs2.gso k\\<parallel>\\<^sup>2 \\<le> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g_bnd B fs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_swap_bound: assumes \n  binv: \"LLL_bound_invariant True False i fs\" \n  and res: \"basis_reduction_swap i fs = (upw',i',fs')\" \n  and cond: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\" \n  and i: \"i < m\" \"i \\<noteq> 0\" \nshows \"LLL_bound_invariant True upw' i' fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw' i' fs'", "proof (rule bound_invI)"], ["proof (state)\ngoal (3 subgoals):\n 1. LLL_invariant upw' i' fs'\n 2. f_bound True i' fs'\n 3. g_bound fs'", "note Linv = bound_invD(1)[OF binv]"], ["proof (state)\nthis:\n  LLL_invariant False i fs\n\ngoal (3 subgoals):\n 1. LLL_invariant upw' i' fs'\n 2. f_bound True i' fs'\n 3. g_bound fs'", "from basis_reduction_swap[OF Linv res cond i]"], ["proof (chain)\npicking this:\n  LLL_invariant upw' i' fs'\n  LLL_measure i' fs' < LLL_measure i fs", "show Linv': \"LLL_invariant upw' i' fs'\""], ["proof (prove)\nusing this:\n  LLL_invariant upw' i' fs'\n  LLL_measure i' fs' < LLL_measure i fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw' i' fs'", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw' i' fs'\n\ngoal (2 subgoals):\n 1. f_bound True i' fs'\n 2. g_bound fs'", "from res[unfolded basis_reduction_swap_def]"], ["proof (chain)\npicking this:\n  (False, i - 1, fs[i := fs ! (i - 1), i - 1 := fs ! i]) = (upw', i', fs')", "have id: \"i' = i - 1\" \"fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]\""], ["proof (prove)\nusing this:\n  (False, i - 1, fs[i := fs ! (i - 1), i - 1 := fs ! i]) = (upw', i', fs')\n\ngoal (1 subgoal):\n 1. i' = i - 1 &&& fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]", "by auto"], ["proof (state)\nthis:\n  i' = i - 1\n  fs' = fs[i := fs ! (i - 1), i - 1 := fs ! i]\n\ngoal (2 subgoals):\n 1. f_bound True i' fs'\n 2. g_bound fs'", "from LLL_invD(6)[OF Linv] i"], ["proof (chain)\npicking this:\n  length fs = m\n  i < m\n  i \\<noteq> 0", "have choice: \"fs' ! k = fs ! k \\<or> fs' ! k = fs ! i \\<or> fs' ! k = fs ! (i - 1)\" for k"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fs' ! k = fs ! k \\<or> fs' ! k = fs ! i \\<or> fs' ! k = fs ! (i - 1)", "unfolding id"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fs[i := fs ! (i - 1), i - 1 := fs ! i] ! k = fs ! k \\<or>\n    fs[i := fs ! (i - 1), i - 1 := fs ! i] ! k = fs ! i \\<or>\n    fs[i := fs ! (i - 1), i - 1 := fs ! i] ! k = fs ! (i - 1)", "by (cases \"k = i\"; cases \"k = i - 1\", auto)"], ["proof (state)\nthis:\n  fs' ! ?k1 = fs ! ?k1 \\<or>\n  fs' ! ?k1 = fs ! i \\<or> fs' ! ?k1 = fs ! (i - 1)\n\ngoal (2 subgoals):\n 1. f_bound True i' fs'\n 2. g_bound fs'", "from bound_invD(2)[OF binv] i"], ["proof (chain)\npicking this:\n  f_bound True i fs\n  i < m\n  i \\<noteq> 0", "show \"f_bound True i' fs'\""], ["proof (prove)\nusing this:\n  f_bound True i fs\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f_bound True i' fs'", "unfolding id(1) f_bound_def"], ["proof (prove)\nusing this:\n  \\<forall>ia<m.\n     \\<parallel>fs ! ia\\<parallel>\\<^sup>2\n     \\<le> (if ia \\<noteq> i \\<or> True then int (N * m)\n            else int (4 ^ (m - 1) * N ^ m * m * m))\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>ia<m.\n       \\<parallel>fs' ! ia\\<parallel>\\<^sup>2\n       \\<le> (if ia \\<noteq> i - 1 \\<or> True then int (N * m)\n              else int (4 ^ (m - 1) * N ^ m * m * m))", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>\\<forall>ia<m.\n                   \\<parallel>fs ! ia\\<parallel>\\<^sup>2\n                   \\<le> (if ia \\<noteq> i \\<or> True then int (N * m)\n                          else int (4 ^ (m - 1) * N ^ m * m * m));\n        i < m; i \\<noteq> 0; ia < m\\<rbrakk>\n       \\<Longrightarrow> \\<parallel>fs' ! ia\\<parallel>\\<^sup>2\n                         \\<le> (if ia \\<noteq> i - 1 \\<or> True\n                                then int (N * m)\n                                else int (4 ^ (m - 1) * N ^ m * m * m))", "case (1 k)"], ["proof (state)\nthis:\n  \\<forall>ia<m.\n     \\<parallel>fs ! ia\\<parallel>\\<^sup>2\n     \\<le> (if ia \\<noteq> i \\<or> True then int (N * m)\n            else int (4 ^ (m - 1) * N ^ m * m * m))\n  i < m\n  i \\<noteq> 0\n  k < m\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>\\<forall>ia<m.\n                   \\<parallel>fs ! ia\\<parallel>\\<^sup>2\n                   \\<le> (if ia \\<noteq> i \\<or> True then int (N * m)\n                          else int (4 ^ (m - 1) * N ^ m * m * m));\n        i < m; i \\<noteq> 0; ia < m\\<rbrakk>\n       \\<Longrightarrow> \\<parallel>fs' ! ia\\<parallel>\\<^sup>2\n                         \\<le> (if ia \\<noteq> i - 1 \\<or> True\n                                then int (N * m)\n                                else int (4 ^ (m - 1) * N ^ m * m * m))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>ia<m.\n     \\<parallel>fs ! ia\\<parallel>\\<^sup>2\n     \\<le> (if ia \\<noteq> i \\<or> True then int (N * m)\n            else int (4 ^ (m - 1) * N ^ m * m * m))\n  i < m\n  i \\<noteq> 0\n  k < m\n\ngoal (1 subgoal):\n 1. \\<parallel>fs' ! k\\<parallel>\\<^sup>2\n    \\<le> (if k \\<noteq> i - 1 \\<or> True then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "using choice[of k]"], ["proof (prove)\nusing this:\n  \\<forall>ia<m.\n     \\<parallel>fs ! ia\\<parallel>\\<^sup>2\n     \\<le> (if ia \\<noteq> i \\<or> True then int (N * m)\n            else int (4 ^ (m - 1) * N ^ m * m * m))\n  i < m\n  i \\<noteq> 0\n  k < m\n  fs' ! k = fs ! k \\<or> fs' ! k = fs ! i \\<or> fs' ! k = fs ! (i - 1)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs' ! k\\<parallel>\\<^sup>2\n    \\<le> (if k \\<noteq> i - 1 \\<or> True then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs' ! k\\<parallel>\\<^sup>2\n  \\<le> (if k \\<noteq> i - 1 \\<or> True then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f_bound True i' fs'\n\ngoal (1 subgoal):\n 1. g_bound fs'", "from bound_invD(3)[OF binv, unfolded g_bound_def]"], ["proof (chain)\npicking this:\n  \\<forall>i<m.\n     \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                 i\\<parallel>\\<^sup>2\n     \\<le> rat_of_nat N", "have gbnd: \"g_bnd (of_nat N) fs\""], ["proof (prove)\nusing this:\n  \\<forall>i<m.\n     \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                 i\\<parallel>\\<^sup>2\n     \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. g_bnd (rat_of_nat N) fs", "unfolding g_bnd_def"], ["proof (prove)\nusing this:\n  \\<forall>i<m.\n     \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                 i\\<parallel>\\<^sup>2\n     \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. \\<forall>i<m.\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                   i\\<parallel>\\<^sup>2\n       \\<le> rat_of_nat N", "."], ["proof (state)\nthis:\n  g_bnd (rat_of_nat N) fs\n\ngoal (1 subgoal):\n 1. g_bound fs'", "from LLL_invD(11)[OF Linv, unfolded \\<mu>_small_def] i"], ["proof (chain)\npicking this:\n  False \\<or>\n  (\\<forall>j<i.\n      \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n      \\<le> 1 / 2)\n  i < m\n  i \\<noteq> 0", "have \"abs (\\<mu> fs i (i - 1)) \\<le> 1/2\""], ["proof (prove)\nusing this:\n  False \\<or>\n  (\\<forall>j<i.\n      \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n      \\<le> 1 / 2)\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n           (i - 1)\\<bar>\n    \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1)\\<bar>\n  \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. g_bound fs'", "from g_bnd_swap[OF i LLL_inv_imp_w[OF Linv] this cond id(2) gbnd]"], ["proof (chain)\npicking this:\n  g_bnd (rat_of_nat N) fs'", "have \"g_bnd (rat_of_nat N) fs'\""], ["proof (prove)\nusing this:\n  g_bnd (rat_of_nat N) fs'\n\ngoal (1 subgoal):\n 1. g_bnd (rat_of_nat N) fs'", "."], ["proof (state)\nthis:\n  g_bnd (rat_of_nat N) fs'\n\ngoal (1 subgoal):\n 1. g_bound fs'", "thus \"g_bound fs'\""], ["proof (prove)\nusing this:\n  g_bnd (rat_of_nat N) fs'\n\ngoal (1 subgoal):\n 1. g_bound fs'", "unfolding g_bnd_def g_bound_def"], ["proof (prove)\nusing this:\n  \\<forall>i<m.\n     \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                 i\\<parallel>\\<^sup>2\n     \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. \\<forall>i<m.\n       \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                   i\\<parallel>\\<^sup>2\n       \\<le> rat_of_nat N", "."], ["proof (state)\nthis:\n  g_bound fs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_step_bound: assumes \n  binv: \"LLL_bound_invariant True upw i fs\" \n  and res: \"basis_reduction_step upw i fs = (upw',i',fs')\" \n  and i: \"i < m\" \nshows \"LLL_bound_invariant True upw' i' fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw' i' fs'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw' i' fs'", "note def = basis_reduction_step_def"], ["proof (state)\nthis:\n  basis_reduction_step ?upw ?i ?fs =\n  (if ?i = 0 then (True, Suc ?i, ?fs)\n   else let fs' = basis_reduction_add_rows ?upw ?i ?fs\n        in if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                          (?i - 1)\\<parallel>\\<^sup>2\n              \\<le> \\<alpha> *\n                    \\<parallel>gram_schmidt_fs.gso n\n                                (map of_int_hom.vec_hom fs')\n                                ?i\\<parallel>\\<^sup>2\n           then (True, Suc ?i, fs') else basis_reduction_swap ?i fs')\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw' i' fs'", "obtain fs'' where fs'': \"basis_reduction_add_rows upw i fs = fs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs''.\n        basis_reduction_add_rows upw i fs = fs'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  basis_reduction_add_rows upw i fs = fs''\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw' i' fs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw' i' fs'", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'\n 2. i \\<noteq> 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'\n 2. i \\<noteq> 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'", "from increase_i_bound[OF binv i True] res True"], ["proof (chain)\npicking this:\n  (i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     i\\<parallel>\\<^sup>2) \\<Longrightarrow>\n  LLL_bound_invariant True True (Suc i) fs\n  basis_reduction_step upw i fs = (upw', i', fs')\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     i\\<parallel>\\<^sup>2) \\<Longrightarrow>\n  LLL_bound_invariant True True (Suc i) fs\n  basis_reduction_step upw i fs = (upw', i', fs')\n  i = 0\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw' i' fs'", "by (auto simp: def)"], ["proof (state)\nthis:\n  LLL_bound_invariant True upw' i' fs'\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'", "hence id: \"(i = 0) = False\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (i = 0) = False", "by auto"], ["proof (state)\nthis:\n  (i = 0) = False\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'", "note res = res[unfolded def id if_False fs'' Let_def]"], ["proof (state)\nthis:\n  (if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2\n      \\<le> \\<alpha> *\n            \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                        i\\<parallel>\\<^sup>2\n   then (True, Suc i, fs'') else basis_reduction_swap i fs'') =\n  (upw', i', fs')\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'", "let ?x = \"sq_norm (gso fs'' (i - 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'", "let ?y = \"\\<alpha> * sq_norm (gso fs'' i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'", "from basis_reduction_add_rows_bound[OF binv fs'' i]"], ["proof (chain)\npicking this:\n  LLL_bound_invariant True False i fs''", "have binv: \"LLL_bound_invariant True False i fs''\""], ["proof (prove)\nusing this:\n  LLL_bound_invariant True False i fs''\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True False i fs''", "by auto"], ["proof (state)\nthis:\n  LLL_bound_invariant True False i fs''\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> LLL_bound_invariant True upw' i' fs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw' i' fs'", "proof (cases \"?x \\<le> ?y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> *\n          \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                      i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_bound_invariant True upw' i' fs'\n 2. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_bound_invariant True upw' i' fs'", "case True"], ["proof (state)\nthis:\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                    i\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> *\n          \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                      i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_bound_invariant True upw' i' fs'\n 2. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_bound_invariant True upw' i' fs'", "from increase_i_bound[OF binv i _ True] True res"], ["proof (chain)\npicking this:\n  (False \\<Longrightarrow> i = 0) \\<Longrightarrow>\n  LLL_bound_invariant True True (Suc i) fs''\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                    i\\<parallel>\\<^sup>2\n  (if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2\n      \\<le> \\<alpha> *\n            \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                        i\\<parallel>\\<^sup>2\n   then (True, Suc i, fs'') else basis_reduction_swap i fs'') =\n  (upw', i', fs')", "show ?thesis"], ["proof (prove)\nusing this:\n  (False \\<Longrightarrow> i = 0) \\<Longrightarrow>\n  LLL_bound_invariant True True (Suc i) fs''\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n              (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                    i\\<parallel>\\<^sup>2\n  (if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2\n      \\<le> \\<alpha> *\n            \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                        i\\<parallel>\\<^sup>2\n   then (True, Suc i, fs'') else basis_reduction_swap i fs'') =\n  (upw', i', fs')\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw' i' fs'", "by auto"], ["proof (state)\nthis:\n  LLL_bound_invariant True upw' i' fs'\n\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_bound_invariant True upw' i' fs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_bound_invariant True upw' i' fs'", "case gt: False"], ["proof (state)\nthis:\n  \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     (i - 1)\\<parallel>\\<^sup>2\n         \\<le> \\<alpha> *\n               \\<parallel>gram_schmidt_fs.gso n\n                           (map of_int_hom.vec_hom fs'')\n                           i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_bound_invariant True upw' i' fs'", "hence \"?x > ?y\""], ["proof (prove)\nusing this:\n  \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     (i - 1)\\<parallel>\\<^sup>2\n         \\<le> \\<alpha> *\n               \\<parallel>gram_schmidt_fs.gso n\n                           (map of_int_hom.vec_hom fs'')\n                           i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<alpha> *\n    \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                i\\<parallel>\\<^sup>2\n    < \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<alpha> *\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n              i\\<parallel>\\<^sup>2\n  < \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                       (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>gram_schmidt_fs.gso n\n                             (map of_int_hom.vec_hom fs'')\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_bound_invariant True upw' i' fs'", "from basis_reduction_swap_bound[OF binv _ this i False] gt res"], ["proof (chain)\npicking this:\n  basis_reduction_swap i fs'' = (?upw', ?i', ?fs') \\<Longrightarrow>\n  LLL_bound_invariant True ?upw' ?i' ?fs'\n  \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     (i - 1)\\<parallel>\\<^sup>2\n         \\<le> \\<alpha> *\n               \\<parallel>gram_schmidt_fs.gso n\n                           (map of_int_hom.vec_hom fs'')\n                           i\\<parallel>\\<^sup>2\n  (if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2\n      \\<le> \\<alpha> *\n            \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                        i\\<parallel>\\<^sup>2\n   then (True, Suc i, fs'') else basis_reduction_swap i fs'') =\n  (upw', i', fs')", "show ?thesis"], ["proof (prove)\nusing this:\n  basis_reduction_swap i fs'' = (?upw', ?i', ?fs') \\<Longrightarrow>\n  LLL_bound_invariant True ?upw' ?i' ?fs'\n  \\<not> \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                     (i - 1)\\<parallel>\\<^sup>2\n         \\<le> \\<alpha> *\n               \\<parallel>gram_schmidt_fs.gso n\n                           (map of_int_hom.vec_hom fs'')\n                           i\\<parallel>\\<^sup>2\n  (if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                  (i - 1)\\<parallel>\\<^sup>2\n      \\<le> \\<alpha> *\n            \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                        i\\<parallel>\\<^sup>2\n   then (True, Suc i, fs'') else basis_reduction_swap i fs'') =\n  (upw', i', fs')\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw' i' fs'", "by auto"], ["proof (state)\nthis:\n  LLL_bound_invariant True upw' i' fs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_bound_invariant True upw' i' fs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_bound_invariant True upw' i' fs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_main_bound: assumes \"LLL_bound_invariant True upw i fs\" \n  and res: \"basis_reduction_main (upw,i,fs) = fs'\" \nshows \"LLL_bound_invariant True True m fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True m fs'", "using assms"], ["proof (prove)\nusing this:\n  LLL_bound_invariant True upw i fs\n  basis_reduction_main (upw, i, fs) = fs'\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True m fs'", "proof (induct \"LLL_measure i fs\" arbitrary: i fs upw rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_bound_invariant True upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True True m fs';\n        LLL_bound_invariant True upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True True m fs'", "case (less i fs upw)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_measure ?i1 ?fs1 < LLL_measure i fs;\n   LLL_bound_invariant True ?upw1 ?i1 ?fs1;\n   basis_reduction_main (?upw1, ?i1, ?fs1) = fs'\\<rbrakk>\n  \\<Longrightarrow> LLL_bound_invariant True True m fs'\n  LLL_bound_invariant True upw i fs\n  basis_reduction_main (upw, i, fs) = fs'\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_bound_invariant True upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True True m fs';\n        LLL_bound_invariant True upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True True m fs'", "have id: \"LLL_bound_invariant True upw i fs = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw i fs = True", "using less"], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_measure ?i1 ?fs1 < LLL_measure i fs;\n   LLL_bound_invariant True ?upw1 ?i1 ?fs1;\n   basis_reduction_main (?upw1, ?i1, ?fs1) = fs'\\<rbrakk>\n  \\<Longrightarrow> LLL_bound_invariant True True m fs'\n  LLL_bound_invariant True upw i fs\n  basis_reduction_main (upw, i, fs) = fs'\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw i fs = True", "by auto"], ["proof (state)\nthis:\n  LLL_bound_invariant True upw i fs = True\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_bound_invariant True upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True True m fs';\n        LLL_bound_invariant True upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True True m fs'", "note res = less(3)[unfolded basis_reduction_main.simps[of upw i fs] id]"], ["proof (state)\nthis:\n  (if i < m \\<and> LLL_invariant upw i fs\n   then basis_reduction_main (basis_reduction_step upw i fs) else fs) =\n  fs'\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_bound_invariant True upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True True m fs';\n        LLL_bound_invariant True upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True True m fs'", "note inv = less(2)"], ["proof (state)\nthis:\n  LLL_bound_invariant True upw i fs\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_bound_invariant True upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True True m fs';\n        LLL_bound_invariant True upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True True m fs'", "note IH = less(1)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_measure ?i1 ?fs1 < LLL_measure i fs;\n   LLL_bound_invariant True ?upw1 ?i1 ?fs1;\n   basis_reduction_main (?upw1, ?i1, ?fs1) = fs'\\<rbrakk>\n  \\<Longrightarrow> LLL_bound_invariant True True m fs'\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_bound_invariant True upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True True m fs';\n        LLL_bound_invariant True upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True True m fs'", "note Linv = bound_invD(1)[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant upw i fs\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw.\n       \\<lbrakk>\\<And>ia fsa upw.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_bound_invariant True upw ia fsa;\n                    basis_reduction_main (upw, ia, fsa) = fs'\\<rbrakk>\n                   \\<Longrightarrow> LLL_bound_invariant True True m fs';\n        LLL_bound_invariant True upw i fs;\n        basis_reduction_main (upw, i, fs) = fs'\\<rbrakk>\n       \\<Longrightarrow> LLL_bound_invariant True True m fs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True m fs'", "proof (cases \"i < m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'\n 2. \\<not> i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'", "case i: True"], ["proof (state)\nthis:\n  i < m\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'\n 2. \\<not> i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'", "obtain i' fs' upw' where step: \"basis_reduction_step upw i fs = (upw',i',fs')\" \n      (is \"?step = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>upw' i' fs'.\n        basis_reduction_step upw i fs = (upw', i', fs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?step, auto)"], ["proof (state)\nthis:\n  basis_reduction_step upw i fs = (upw', i', fs')\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'\n 2. \\<not> i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'", "note decrease = basis_reduction_step(2)[OF Linv step i]"], ["proof (state)\nthis:\n  LLL_measure i' fs' < LLL_measure i fs\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'\n 2. \\<not> i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'", "from IH[OF decrease basis_reduction_step_bound(1)[OF inv step i]] res[unfolded step] i Linv"], ["proof (chain)\npicking this:\n  basis_reduction_main (upw', i', fs') = fs' \\<Longrightarrow>\n  LLL_bound_invariant True True m fs'\n  (if i < m \\<and> LLL_invariant upw i fs\n   then basis_reduction_main (upw', i', fs') else fs) =\n  fs'\n  i < m\n  LLL_invariant upw i fs", "show ?thesis"], ["proof (prove)\nusing this:\n  basis_reduction_main (upw', i', fs') = fs' \\<Longrightarrow>\n  LLL_bound_invariant True True m fs'\n  (if i < m \\<and> LLL_invariant upw i fs\n   then basis_reduction_main (upw', i', fs') else fs) =\n  fs'\n  i < m\n  LLL_invariant upw i fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True m fs'", "by auto"], ["proof (state)\nthis:\n  LLL_bound_invariant True True m fs'\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'", "case False"], ["proof (state)\nthis:\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'", "with LLL_invD[OF Linv]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i\n  \\<not> i < m", "have i: \"i = m\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. i = m", "by auto"], ["proof (state)\nthis:\n  i = m\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'", "with False res inv"], ["proof (chain)\npicking this:\n  \\<not> i < m\n  (if i < m \\<and> LLL_invariant upw i fs\n   then basis_reduction_main (basis_reduction_step upw i fs) else fs) =\n  fs'\n  LLL_bound_invariant True upw i fs\n  i = m", "have \"LLL_bound_invariant True upw m fs'\""], ["proof (prove)\nusing this:\n  \\<not> i < m\n  (if i < m \\<and> LLL_invariant upw i fs\n   then basis_reduction_main (basis_reduction_step upw i fs) else fs) =\n  fs'\n  LLL_bound_invariant True upw i fs\n  i = m\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True upw m fs'", "by auto"], ["proof (state)\nthis:\n  LLL_bound_invariant True upw m fs'\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow> LLL_bound_invariant True True m fs'", "thus ?thesis"], ["proof (prove)\nusing this:\n  LLL_bound_invariant True upw m fs'\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True m fs'", "by (auto simp: LLL_invariant_def LLL_bound_invariant_def)"], ["proof (state)\nthis:\n  LLL_bound_invariant True True m fs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_bound_invariant True True m fs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_inv_initial_state_bound: \"LLL_bound_invariant True True 0 fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True 0 fs_init", "proof (intro bound_invI[OF LLL_inv_initial_state _ g_bound_fs_init])"], ["proof (state)\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "assume i: \"i < m\""], ["proof (state)\nthis:\n  i < m\n\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "let ?N = \"map (nat o sq_norm) fs_init\""], ["proof (state)\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "let ?r = rat_of_int"], ["proof (state)\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "from i"], ["proof (chain)\npicking this:\n  i < m", "have mem: \"nat (sq_norm (fs_init ! i)) \\<in> set ?N\""], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n    \\<in> set (map (nat \\<circ> sq_norm) fs_init)", "using fs_init len"], ["proof (prove)\nusing this:\n  i < m\n  set fs_init \\<subseteq> carrier_vec n\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n    \\<in> set (map (nat \\<circ> sq_norm) fs_init)", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  i < m\n  {fs_init ! i |i. i < length fs_init} \\<subseteq> carrier_vec n\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n    \\<in> {map (nat \\<circ> sq_norm) fs_init ! i |i.\n           i < length (map (nat \\<circ> sq_norm) fs_init)}", "by force"], ["proof (state)\nthis:\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n  \\<in> set (map (nat \\<circ> sq_norm) fs_init)\n\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "from mem_set_imp_le_max_list[OF _ mem]"], ["proof (chain)\npicking this:\n  (\\<And>a b.\n      \\<lbrakk>a \\<in> set (map (nat \\<circ> sq_norm) fs_init);\n       b \\<in> set (map (nat \\<circ> sq_norm) fs_init)\\<rbrakk>\n      \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a) \\<Longrightarrow>\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init)", "have FN: \"nat (sq_norm (fs_init ! i)) \\<le> N\""], ["proof (prove)\nusing this:\n  (\\<And>a b.\n      \\<lbrakk>a \\<in> set (map (nat \\<circ> sq_norm) fs_init);\n       b \\<in> set (map (nat \\<circ> sq_norm) fs_init)\\<rbrakk>\n      \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a) \\<Longrightarrow>\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init)\n\ngoal (1 subgoal):\n 1. nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> N", "unfolding N_def"], ["proof (prove)\nusing this:\n  (\\<And>a b.\n      \\<lbrakk>a \\<in> set (map (nat \\<circ> sq_norm) fs_init);\n       b \\<in> set (map (nat \\<circ> sq_norm) fs_init)\\<rbrakk>\n      \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a) \\<Longrightarrow>\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n  \\<le> Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init)\n\ngoal (1 subgoal):\n 1. nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n    \\<le> Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init)", "by force"], ["proof (state)\nthis:\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> N\n\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "hence \"\\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int N\""], ["proof (prove)\nusing this:\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> N\n\ngoal (1 subgoal):\n 1. \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int N", "using i"], ["proof (prove)\nusing this:\n  nat \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> N\n  i < m\n\ngoal (1 subgoal):\n 1. \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int N", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int N\n\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "also"], ["proof (state)\nthis:\n  \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int N\n\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "have \"\\<dots> \\<le> int (N * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int N \\<le> int (N * m)", "using i"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. int N \\<le> int (N * m)", "by fastforce"], ["proof (state)\nthis:\n  int N \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)", "have f_bnd:  \"\\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)\""], ["proof (prove)\nusing this:\n  \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)", "."], ["proof (state)\nthis:\n  \\<parallel>fs_init ! i\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "}"], ["proof (state)\nthis:\n  ?i3 < m \\<Longrightarrow>\n  \\<parallel>fs_init ! ?i3\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "thus \"f_bound True 0 fs_init\""], ["proof (prove)\nusing this:\n  ?i3 < m \\<Longrightarrow>\n  \\<parallel>fs_init ! ?i3\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. f_bound True 0 fs_init", "unfolding f_bound_def"], ["proof (prove)\nusing this:\n  ?i3 < m \\<Longrightarrow>\n  \\<parallel>fs_init ! ?i3\\<parallel>\\<^sup>2 \\<le> int (N * m)\n\ngoal (1 subgoal):\n 1. \\<forall>i<m.\n       \\<parallel>fs_init ! i\\<parallel>\\<^sup>2\n       \\<le> (if i \\<noteq> 0 \\<or> True then int (N * m)\n              else int (4 ^ (m - 1) * N ^ m * m * m))", "by auto"], ["proof (state)\nthis:\n  f_bound True 0 fs_init\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduce_basis_bound: assumes res: \"reduce_basis = fs\" \n  shows \"LLL_bound_invariant True True m fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True m fs", "using basis_reduction_main_bound[OF LLL_inv_initial_state_bound res[unfolded reduce_basis_def]]"], ["proof (prove)\nusing this:\n  LLL_bound_invariant True True m fs\n\ngoal (1 subgoal):\n 1. LLL_bound_invariant True True m fs", "."], ["", "subsubsection \\<open>Bound extracted from @{term LLL_bound_invariant}.\\<close>"], ["", "fun f_bnd :: \"bool \\<Rightarrow> nat\" where\n  \"f_bnd False = 2 ^ (m - 1) * N ^ m * m\" \n| \"f_bnd True = N * m\""], ["", "lemma f_bnd_mono: \"f_bnd outside \\<le> f_bnd False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_bnd outside \\<le> f_bnd False", "proof (cases outside)"], ["proof (state)\ngoal (2 subgoals):\n 1. outside \\<Longrightarrow> f_bnd outside \\<le> f_bnd False\n 2. \\<not> outside \\<Longrightarrow> f_bnd outside \\<le> f_bnd False", "case out: True"], ["proof (state)\nthis:\n  outside\n\ngoal (2 subgoals):\n 1. outside \\<Longrightarrow> f_bnd outside \\<le> f_bnd False\n 2. \\<not> outside \\<Longrightarrow> f_bnd outside \\<le> f_bnd False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f_bnd outside \\<le> f_bnd False", "proof (cases \"N = 0 \\<or> m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow> f_bnd outside \\<le> f_bnd False\n 2. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "case True"], ["proof (state)\nthis:\n  N = 0 \\<or> m = 0\n\ngoal (2 subgoals):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow> f_bnd outside \\<le> f_bnd False\n 2. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "thus ?thesis"], ["proof (prove)\nusing this:\n  N = 0 \\<or> m = 0\n\ngoal (1 subgoal):\n 1. f_bnd outside \\<le> f_bnd False", "using out"], ["proof (prove)\nusing this:\n  N = 0 \\<or> m = 0\n  outside\n\ngoal (1 subgoal):\n 1. f_bnd outside \\<le> f_bnd False", "by auto"], ["proof (state)\nthis:\n  f_bnd outside \\<le> f_bnd False\n\ngoal (1 subgoal):\n 1. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "case False"], ["proof (state)\nthis:\n  \\<not> (N = 0 \\<or> m = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "hence 0: \"N > 0\" \"m > 0\""], ["proof (prove)\nusing this:\n  \\<not> (N = 0 \\<or> m = 0)\n\ngoal (1 subgoal):\n 1. 0 < N &&& 0 < m", "by auto"], ["proof (state)\nthis:\n  0 < N\n  0 < m\n\ngoal (1 subgoal):\n 1. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "let ?num = \"(2 ^ (m - 1) * N ^ m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "have \"(N * m) * 1 \\<le> (N * m) * (2 ^ (m - 1) * N ^ (m - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N * m * 1 \\<le> N * m * (2 ^ (m - 1) * N ^ (m - 1))", "by (rule mult_left_mono, insert 0, auto)"], ["proof (state)\nthis:\n  N * m * 1 \\<le> N * m * (2 ^ (m - 1) * N ^ (m - 1))\n\ngoal (1 subgoal):\n 1. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "also"], ["proof (state)\nthis:\n  N * m * 1 \\<le> N * m * (2 ^ (m - 1) * N ^ (m - 1))\n\ngoal (1 subgoal):\n 1. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "have \"\\<dots> = 2 ^ (m - 1) * N ^ (Suc (m - 1)) * m \""], ["proof (prove)\ngoal (1 subgoal):\n 1. N * m * (2 ^ (m - 1) * N ^ (m - 1)) = 2 ^ (m - 1) * N ^ Suc (m - 1) * m", "by simp"], ["proof (state)\nthis:\n  N * m * (2 ^ (m - 1) * N ^ (m - 1)) = 2 ^ (m - 1) * N ^ Suc (m - 1) * m\n\ngoal (1 subgoal):\n 1. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "also"], ["proof (state)\nthis:\n  N * m * (2 ^ (m - 1) * N ^ (m - 1)) = 2 ^ (m - 1) * N ^ Suc (m - 1) * m\n\ngoal (1 subgoal):\n 1. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "have \"Suc (m - 1) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (m - 1) = m", "using 0"], ["proof (prove)\nusing this:\n  0 < N\n  0 < m\n\ngoal (1 subgoal):\n 1. Suc (m - 1) = m", "by simp"], ["proof (state)\nthis:\n  Suc (m - 1) = m\n\ngoal (1 subgoal):\n 1. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    f_bnd outside \\<le> f_bnd False", "finally"], ["proof (chain)\npicking this:\n  N * m * 1 \\<le> 2 ^ (m - 1) * N ^ m * m", "show ?thesis"], ["proof (prove)\nusing this:\n  N * m * 1 \\<le> 2 ^ (m - 1) * N ^ m * m\n\ngoal (1 subgoal):\n 1. f_bnd outside \\<le> f_bnd False", "using out"], ["proof (prove)\nusing this:\n  N * m * 1 \\<le> 2 ^ (m - 1) * N ^ m * m\n  outside\n\ngoal (1 subgoal):\n 1. f_bnd outside \\<le> f_bnd False", "by auto"], ["proof (state)\nthis:\n  f_bnd outside \\<le> f_bnd False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f_bnd outside \\<le> f_bnd False\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow> f_bnd outside \\<le> f_bnd False", "qed auto"], ["", "lemma aux_bnd_mono: \"N * m \\<le> (4 ^ (m - 1) * N ^ m * m * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "proof (cases \"N = 0 \\<or> m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m\n 2. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "case False"], ["proof (state)\nthis:\n  \\<not> (N = 0 \\<or> m = 0)\n\ngoal (2 subgoals):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m\n 2. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "hence 0: \"N > 0\" \"m > 0\""], ["proof (prove)\nusing this:\n  \\<not> (N = 0 \\<or> m = 0)\n\ngoal (1 subgoal):\n 1. 0 < N &&& 0 < m", "by auto"], ["proof (state)\nthis:\n  0 < N\n  0 < m\n\ngoal (2 subgoals):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m\n 2. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "let ?num = \"(4 ^ (m - 1) * N ^ m * m * m)\""], ["proof (state)\ngoal (2 subgoals):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m\n 2. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "have \"(N * m) * 1 \\<le> (N * m) * (4 ^ (m - 1) * N ^ (m - 1) * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N * m * 1 \\<le> N * m * (4 ^ (m - 1) * N ^ (m - 1) * m)", "by (rule mult_left_mono, insert 0, auto)"], ["proof (state)\nthis:\n  N * m * 1 \\<le> N * m * (4 ^ (m - 1) * N ^ (m - 1) * m)\n\ngoal (2 subgoals):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m\n 2. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "also"], ["proof (state)\nthis:\n  N * m * 1 \\<le> N * m * (4 ^ (m - 1) * N ^ (m - 1) * m)\n\ngoal (2 subgoals):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m\n 2. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "have \"\\<dots> = 4 ^ (m - 1) * N ^ (Suc (m - 1)) * m * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N * m * (4 ^ (m - 1) * N ^ (m - 1) * m) =\n    4 ^ (m - 1) * N ^ Suc (m - 1) * m * m", "by simp"], ["proof (state)\nthis:\n  N * m * (4 ^ (m - 1) * N ^ (m - 1) * m) =\n  4 ^ (m - 1) * N ^ Suc (m - 1) * m * m\n\ngoal (2 subgoals):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m\n 2. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "also"], ["proof (state)\nthis:\n  N * m * (4 ^ (m - 1) * N ^ (m - 1) * m) =\n  4 ^ (m - 1) * N ^ Suc (m - 1) * m * m\n\ngoal (2 subgoals):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m\n 2. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "have \"Suc (m - 1) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (m - 1) = m", "using 0"], ["proof (prove)\nusing this:\n  0 < N\n  0 < m\n\ngoal (1 subgoal):\n 1. Suc (m - 1) = m", "by simp"], ["proof (state)\nthis:\n  Suc (m - 1) = m\n\ngoal (2 subgoals):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m\n 2. \\<not> (N = 0 \\<or> m = 0) \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "finally"], ["proof (chain)\npicking this:\n  N * m * 1 \\<le> 4 ^ (m - 1) * N ^ m * m * m", "show \"N * m \\<le> ?num\""], ["proof (prove)\nusing this:\n  N * m * 1 \\<le> 4 ^ (m - 1) * N ^ m * m * m\n\ngoal (1 subgoal):\n 1. N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "by simp"], ["proof (state)\nthis:\n  N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m\n\ngoal (1 subgoal):\n 1. N = 0 \\<or> m = 0 \\<Longrightarrow>\n    N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m", "qed auto"], ["", "context fixes outside upw k fs\n  assumes binv: \"LLL_bound_invariant outside upw k fs\"\nbegin"], ["", "lemma LLL_f_bnd: \n  assumes i: \"i < m\" and j: \"j < n\" \nshows \"\\<bar>fs ! i $ j\\<bar> \\<le> f_bnd outside\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "from bound_invD[OF binv]"], ["proof (chain)\npicking this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs", "have inv: \"LLL_invariant upw k fs\" \n    and fbnd: \"f_bound outside k fs\" \n    and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw k fs &&& f_bound outside k fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "from LLL_inv_N_pos[OF invw gbnd] i"], ["proof (chain)\npicking this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  i < m", "have N0: \"N > 0\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  i < m\n\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "note inv = LLL_invD[OF inv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  k \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "from inv i"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  k \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n  i < m", "have fsi: \"fs ! i \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  k \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n  i < m\n\ngoal (1 subgoal):\n 1. fs ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  fs ! i \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "have one: \"\\<bar>fs ! i $ j\\<bar>^1 \\<le> \\<bar>fs ! i $ j\\<bar>^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> ^ 1 \\<le> \\<bar>fs ! i $ j\\<bar>\\<^sup>2", "by (cases \"fs ! i $ j \\<noteq> 0\", intro pow_mono_exp, auto)"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar> ^ 1 \\<le> \\<bar>fs ! i $ j\\<bar>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "let ?num = \"(4 ^ (m - 1) * N ^ m * m * m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "let ?sq_bnd = \"if i \\<noteq> k \\<or> outside then int (N * m) else int ?num\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "have \"\\<bar>fs ! i $ j\\<bar>^2 \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "using fsi j"], ["proof (prove)\nusing this:\n  fs ! i \\<in> carrier_vec n\n  j < n\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar>\\<^sup>2\n    \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2", "by (metis vec_le_sq_norm)"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar>\\<^sup>2 \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "also"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar>\\<^sup>2 \\<le> \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "have \"\\<dots> \\<le> ?sq_bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "using fbnd[unfolded f_bound_def, rule_format, OF i]"], ["proof (prove)\nusing this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "by auto"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>fs ! i $ j\\<bar>\\<^sup>2\n  \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))", "have two: \"(fs ! i $ j)^2 \\<le> ?sq_bnd\""], ["proof (prove)\nusing this:\n  \\<bar>fs ! i $ j\\<bar>\\<^sup>2\n  \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. (fs ! i $ j)\\<^sup>2\n    \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n           else int (4 ^ (m - 1) * N ^ m * m * m))", "by simp"], ["proof (state)\nthis:\n  (fs ! i $ j)\\<^sup>2\n  \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "proof (cases outside)"], ["proof (state)\ngoal (2 subgoals):\n 1. outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)\n 2. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "case True"], ["proof (state)\nthis:\n  outside\n\ngoal (2 subgoals):\n 1. outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)\n 2. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "with one two"], ["proof (chain)\npicking this:\n  \\<bar>fs ! i $ j\\<bar> ^ 1 \\<le> \\<bar>fs ! i $ j\\<bar>\\<^sup>2\n  (fs ! i $ j)\\<^sup>2\n  \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n  outside", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>fs ! i $ j\\<bar> ^ 1 \\<le> \\<bar>fs ! i $ j\\<bar>\\<^sup>2\n  (fs ! i $ j)\\<^sup>2\n  \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n  outside\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "by auto"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "case False"], ["proof (state)\nthis:\n  \\<not> outside\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "let ?num2 = \"(2 ^ (m - 1) * N ^ m * m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "have four: \"(4 :: nat) = 2^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 = 2\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  4 = 2\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "have \"(fs ! i $ j)^2 \\<le> int (max (N * m) ?num)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs ! i $ j)\\<^sup>2\n    \\<le> int (max (N * m) (4 ^ (m - 1) * N ^ m * m * m))", "by (rule order.trans[OF two], auto simp: of_nat_mult[symmetric] simp del: of_nat_mult)"], ["proof (state)\nthis:\n  (fs ! i $ j)\\<^sup>2 \\<le> int (max (N * m) (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "also"], ["proof (state)\nthis:\n  (fs ! i $ j)\\<^sup>2 \\<le> int (max (N * m) (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "have \"max (N * m) ?num = ?num\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (N * m) (4 ^ (m - 1) * N ^ m * m * m) = 4 ^ (m - 1) * N ^ m * m * m", "using aux_bnd_mono"], ["proof (prove)\nusing this:\n  N * m \\<le> 4 ^ (m - 1) * N ^ m * m * m\n\ngoal (1 subgoal):\n 1. max (N * m) (4 ^ (m - 1) * N ^ m * m * m) = 4 ^ (m - 1) * N ^ m * m * m", "by presburger"], ["proof (state)\nthis:\n  max (N * m) (4 ^ (m - 1) * N ^ m * m * m) = 4 ^ (m - 1) * N ^ m * m * m\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "also"], ["proof (state)\nthis:\n  max (N * m) (4 ^ (m - 1) * N ^ m * m * m) = 4 ^ (m - 1) * N ^ m * m * m\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "have \"int ?num = int ?num * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (4 ^ (m - 1) * N ^ m * m * m) =\n    int (4 ^ (m - 1) * N ^ m * m * m) * 1", "by simp"], ["proof (state)\nthis:\n  int (4 ^ (m - 1) * N ^ m * m * m) = int (4 ^ (m - 1) * N ^ m * m * m) * 1\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "also"], ["proof (state)\nthis:\n  int (4 ^ (m - 1) * N ^ m * m * m) = int (4 ^ (m - 1) * N ^ m * m * m) * 1\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "have \"\\<dots> \\<le> int ?num * N ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (4 ^ (m - 1) * N ^ m * m * m) * 1\n    \\<le> int (4 ^ (m - 1) * N ^ m * m * m) * int (N ^ m)", "by (rule mult_left_mono, insert N0, auto)"], ["proof (state)\nthis:\n  int (4 ^ (m - 1) * N ^ m * m * m) * 1\n  \\<le> int (4 ^ (m - 1) * N ^ m * m * m) * int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "also"], ["proof (state)\nthis:\n  int (4 ^ (m - 1) * N ^ m * m * m) * 1\n  \\<le> int (4 ^ (m - 1) * N ^ m * m * m) * int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "have \"\\<dots> = int (?num * N ^ m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (4 ^ (m - 1) * N ^ m * m * m) * int (N ^ m) =\n    int (4 ^ (m - 1) * N ^ m * m * m * N ^ m)", "by simp"], ["proof (state)\nthis:\n  int (4 ^ (m - 1) * N ^ m * m * m) * int (N ^ m) =\n  int (4 ^ (m - 1) * N ^ m * m * m * N ^ m)\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "also"], ["proof (state)\nthis:\n  int (4 ^ (m - 1) * N ^ m * m * m) * int (N ^ m) =\n  int (4 ^ (m - 1) * N ^ m * m * m * N ^ m)\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "have \"?num * N ^ m = ?num2^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 ^ (m - 1) * N ^ m * m * m * N ^ m = (2 ^ (m - 1) * N ^ m * m)\\<^sup>2", "unfolding power2_eq_square four power_mult_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (m - 1) * 2 ^ (m - 1) * N ^ m * m * m * N ^ m =\n    2 ^ (m - 1) * N ^ m * m * (2 ^ (m - 1) * N ^ m * m)", "by simp"], ["proof (state)\nthis:\n  4 ^ (m - 1) * N ^ m * m * m * N ^ m = (2 ^ (m - 1) * N ^ m * m)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "also"], ["proof (state)\nthis:\n  4 ^ (m - 1) * N ^ m * m * m * N ^ m = (2 ^ (m - 1) * N ^ m * m)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "have \"int \\<dots> = (int ?num2)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int ((2 ^ (m - 1) * N ^ m * m)\\<^sup>2) =\n    (int (2 ^ (m - 1) * N ^ m * m))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  int ((2 ^ (m - 1) * N ^ m * m)\\<^sup>2) =\n  (int (2 ^ (m - 1) * N ^ m * m))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "finally"], ["proof (chain)\npicking this:\n  (fs ! i $ j)\\<^sup>2 \\<le> (int (2 ^ (m - 1) * N ^ m * m))\\<^sup>2", "have \"(fs ! i $ j)\\<^sup>2 \\<le> (int (f_bnd outside))\\<^sup>2\""], ["proof (prove)\nusing this:\n  (fs ! i $ j)\\<^sup>2 \\<le> (int (2 ^ (m - 1) * N ^ m * m))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (fs ! i $ j)\\<^sup>2 \\<le> (int (f_bnd outside))\\<^sup>2", "using False"], ["proof (prove)\nusing this:\n  (fs ! i $ j)\\<^sup>2 \\<le> (int (2 ^ (m - 1) * N ^ m * m))\\<^sup>2\n  \\<not> outside\n\ngoal (1 subgoal):\n 1. (fs ! i $ j)\\<^sup>2 \\<le> (int (f_bnd outside))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (fs ! i $ j)\\<^sup>2 \\<le> (int (f_bnd outside))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> outside \\<Longrightarrow>\n    \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (fs ! i $ j)\\<^sup>2 \\<le> (int (f_bnd outside))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "unfolding abs_le_square_iff[symmetric]"], ["proof (prove)\nusing this:\n  \\<bar>fs ! i $ j\\<bar> \\<le> \\<bar>int (f_bnd outside)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "by simp"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_gso_bound:\n  assumes i: \"i < m\" and j: \"j < n\" \n  and quot: \"quotient_of (gso fs i $ j) = (num, denom)\" \nshows \"\\<bar>num\\<bar>   \\<le> N ^ m\" \n  and \"\\<bar>denom\\<bar> \\<le> N ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m) &&&\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from bound_invD[OF binv]"], ["proof (chain)\npicking this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs", "have inv: \"LLL_invariant upw k fs\" \n    and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw k fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw k fs\n  g_bound fs\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "note * = LLL_invD[OF inv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  k \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "interpret fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by standard (use invw in auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "note d_approx[OF invw gbnd i, unfolded d_def]"], ["proof (state)\nthis:\n  rat_of_int (gs.Gramian_determinant fs i) \\<le> rat_of_nat (N ^ i)\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have int: \"(gs.Gramian_determinant (RAT fs) i \\<cdot>\\<^sub>v (gso fs i)) $ j \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.d i \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fs.gs.d i \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>", "have \"of_int_hom.vec_hom (fs ! j) $ i \\<in> \\<int>\" if \"i < n\" \"j < m\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! j) $ i \\<in> \\<int>", "using that assms *"], ["proof (prove)\nusing this:\n  i < n\n  j < m\n  i < m\n  j < n\n  quotient_of (fs.gs.gso i $ j) = (num, denom)\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> k\n  k \\<le> m\n  fs.gs.reduced \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! j) $ i \\<in> \\<int>", "by (intro vec_hom_Ints) (auto)"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < m\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (fs.gs.d i \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < n; ?j2 < m\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < m\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (fs.gs.d i \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>", "using * gs.gso_connect snd_gram_schmidt_int assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < m\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> k\n  k \\<le> m\n  fs.gs.reduced \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n  snd (gs.main ?us) = gram_schmidt n ?us\n  snd (gram_schmidt_int ?n ?us) =\n  gram_schmidt ?n (map of_int_hom.vec_hom ?us)\n  i < m\n  j < n\n  quotient_of (fs.gs.gso i $ j) = (num, denom)\n\ngoal (1 subgoal):\n 1. (fs.gs.d i \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < m\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>\n  set (map of_int_hom.vec_hom fs) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs))\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> k\n  k \\<le> m\n  fs.gs.reduced \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n  snd (gs.main ?us) = gram_schmidt n ?us\n  snd (gram_schmidt_int ?n ?us) =\n  gram_schmidt ?n (map of_int_hom.vec_hom ?us)\n  i < m\n  j < n\n  quotient_of (fs.gs.gso i $ j) = (num, denom)\n\ngoal (1 subgoal):\n 1. (fs.gs.d i \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>", "by (intro fs.gs.d_gso_Ints) (auto)"], ["proof (state)\nthis:\n  (fs.gs.d i \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fs.gs.d i \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have gsi: \"gso fs i \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.gso i \\<in> Rn", "using *(5)[OF i]"], ["proof (prove)\nusing this:\n  fs.gs.gso i \\<in> Rn\n\ngoal (1 subgoal):\n 1. fs.gs.gso i \\<in> Rn", "."], ["proof (state)\nthis:\n  fs.gs.gso i \\<in> Rn\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have gs_sq: \"\\<bar>(gso fs i $ j)\\<bar>\\<^sup>2 \\<le> rat_of_nat N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.gso i $ j\\<bar>\\<^sup>2 \\<le> rat_of_nat N", "by(rule order_trans, rule vec_le_sq_norm[of _ n])\n      (use gsi assms gbnd * LLL.g_bound_def in auto)"], ["proof (state)\nthis:\n  \\<bar>fs.gs.gso i $ j\\<bar>\\<^sup>2 \\<le> rat_of_nat N\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from i"], ["proof (chain)\npicking this:\n  i < m", "have \"m * m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. m * m \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  m * m \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "then"], ["proof (chain)\npicking this:\n  m * m \\<noteq> 0", "have N0: \"N \\<noteq> 0\""], ["proof (prove)\nusing this:\n  m * m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0", "using less_le_trans[OF LLL_D_pos[OF invw] D_approx[OF invw gbnd]]"], ["proof (prove)\nusing this:\n  m * m \\<noteq> 0\n  0 < N ^ (m * m)\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  N \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<bar>(gso fs i $ j)\\<bar> \\<le> max 1 \\<bar>(gso fs i $ j)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.gso i $ j\\<bar> \\<le> max 1 \\<bar>fs.gs.gso i $ j\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>fs.gs.gso i $ j\\<bar> \\<le> max 1 \\<bar>fs.gs.gso i $ j\\<bar>\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  \\<bar>fs.gs.gso i $ j\\<bar> \\<le> max 1 \\<bar>fs.gs.gso i $ j\\<bar>\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> (max 1 \\<bar>gso fs i $ j\\<bar>)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max 1 \\<bar>fs.gs.gso i $ j\\<bar>\n    \\<le> (max 1 \\<bar>fs.gs.gso i $ j\\<bar>)\\<^sup>2", "by (rule self_le_power, auto)"], ["proof (state)\nthis:\n  max 1 \\<bar>fs.gs.gso i $ j\\<bar>\n  \\<le> (max 1 \\<bar>fs.gs.gso i $ j\\<bar>)\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  max 1 \\<bar>fs.gs.gso i $ j\\<bar>\n  \\<le> (max 1 \\<bar>fs.gs.gso i $ j\\<bar>)\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> of_nat N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (max 1 \\<bar>fs.gs.gso i $ j\\<bar>)\\<^sup>2 \\<le> rat_of_nat N", "using gs_sq N0"], ["proof (prove)\nusing this:\n  \\<bar>fs.gs.gso i $ j\\<bar>\\<^sup>2 \\<le> rat_of_nat N\n  N \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (max 1 \\<bar>fs.gs.gso i $ j\\<bar>)\\<^sup>2 \\<le> rat_of_nat N", "unfolding max_def"], ["proof (prove)\nusing this:\n  \\<bar>fs.gs.gso i $ j\\<bar>\\<^sup>2 \\<le> rat_of_nat N\n  N \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if 1 \\<le> \\<bar>fs.gs.gso i $ j\\<bar> then \\<bar>fs.gs.gso i $ j\\<bar>\n     else 1)\\<^sup>2\n    \\<le> rat_of_nat N", "by auto"], ["proof (state)\nthis:\n  (max 1 \\<bar>fs.gs.gso i $ j\\<bar>)\\<^sup>2 \\<le> rat_of_nat N\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>fs.gs.gso i $ j\\<bar> \\<le> rat_of_nat N", "have gs_bound: \"\\<bar>(gso fs i $ j)\\<bar> \\<le> of_nat N\""], ["proof (prove)\nusing this:\n  \\<bar>fs.gs.gso i $ j\\<bar> \\<le> rat_of_nat N\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.gso i $ j\\<bar> \\<le> rat_of_nat N", "."], ["proof (state)\nthis:\n  \\<bar>fs.gs.gso i $ j\\<bar> \\<le> rat_of_nat N\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"gs.Gramian_determinant (RAT fs) i = rat_of_int (gs.Gramian_determinant fs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.d i = rat_of_int (gs.Gramian_determinant fs i)", "using  assms *(4-6) carrier_vecD nth_mem"], ["proof (prove)\nusing this:\n  i < m\n  j < n\n  quotient_of (fs.gs.gso i $ j) = (num, denom)\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> dim_vec ?v = ?n\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. fs.gs.d i = rat_of_int (gs.Gramian_determinant fs i)", "by (intro fs.of_int_Gramian_determinant) (simp, blast)"], ["proof (state)\nthis:\n  fs.gs.d i = rat_of_int (gs.Gramian_determinant fs i)\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "with int"], ["proof (chain)\npicking this:\n  (fs.gs.d i \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>\n  fs.gs.d i = rat_of_int (gs.Gramian_determinant fs i)", "have \"(of_int (d fs i) \\<cdot>\\<^sub>v gso fs i) $ j \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  (fs.gs.d i \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>\n  fs.gs.d i = rat_of_int (gs.Gramian_determinant fs i)\n\ngoal (1 subgoal):\n 1. (rat_of_int (d fs i) \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>", "unfolding d_def"], ["proof (prove)\nusing this:\n  (fs.gs.d i \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>\n  fs.gs.d i = rat_of_int (gs.Gramian_determinant fs i)\n\ngoal (1 subgoal):\n 1. (rat_of_int (gs.Gramian_determinant fs i) \\<cdot>\\<^sub>v fs.gs.gso i) $\n    j\n    \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  (rat_of_int (d fs i) \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  (rat_of_int (d fs i) \\<cdot>\\<^sub>v fs.gs.gso i) $ j \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"(of_int (d fs i) \\<cdot>\\<^sub>v gso fs i) $ j = of_int (d fs i) * (gso fs i $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (d fs i) \\<cdot>\\<^sub>v fs.gs.gso i) $ j =\n    rat_of_int (d fs i) * fs.gs.gso i $ j", "using gsi i j"], ["proof (prove)\nusing this:\n  fs.gs.gso i \\<in> Rn\n  i < m\n  j < n\n\ngoal (1 subgoal):\n 1. (rat_of_int (d fs i) \\<cdot>\\<^sub>v fs.gs.gso i) $ j =\n    rat_of_int (d fs i) * fs.gs.gso i $ j", "by auto"], ["proof (state)\nthis:\n  (rat_of_int (d fs i) \\<cdot>\\<^sub>v fs.gs.gso i) $ j =\n  rat_of_int (d fs i) * fs.gs.gso i $ j\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (d fs i) * fs.gs.gso i $ j \\<in> \\<int>", "have l: \"of_int (d fs i) * gso fs i $ j \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs i) * fs.gs.gso i $ j \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs i) * fs.gs.gso i $ j \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  rat_of_int (d fs i) * fs.gs.gso i $ j \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have num: \"rat_of_int \\<bar>num\\<bar> \\<le> of_int (d fs i * int N)\" and denom: \"denom \\<le> d fs i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>num\\<bar> \\<le> rat_of_int (d fs i * int N) &&&\n    denom \\<le> d fs i", "using quotient_of_bounds[OF quot l LLL_d_pos[OF invw] gs_bound] i"], ["proof (prove)\nusing this:\n  i \\<le> m \\<Longrightarrow>\n  rat_of_int \\<bar>num\\<bar> \\<le> rat_of_int (d fs i) * rat_of_nat N\n  i \\<le> m \\<Longrightarrow> denom \\<le> d fs i\n  i < m\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>num\\<bar> \\<le> rat_of_int (d fs i * int N) &&&\n    denom \\<le> d fs i", "by auto"], ["proof (state)\nthis:\n  rat_of_int \\<bar>num\\<bar> \\<le> rat_of_int (d fs i * int N)\n  denom \\<le> d fs i\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from num"], ["proof (chain)\npicking this:\n  rat_of_int \\<bar>num\\<bar> \\<le> rat_of_int (d fs i * int N)", "have num: \"\\<bar>num\\<bar> \\<le> d fs i * int N\""], ["proof (prove)\nusing this:\n  rat_of_int \\<bar>num\\<bar> \\<le> rat_of_int (d fs i * int N)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> d fs i * int N", "by linarith"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> d fs i * int N\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from d_approx[OF invw gbnd i]"], ["proof (chain)\npicking this:\n  rat_of_int (d fs i) \\<le> rat_of_nat (N ^ i)", "have d: \"d fs i \\<le> int (N ^ i)\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs i) \\<le> rat_of_nat (N ^ i)\n\ngoal (1 subgoal):\n 1. d fs i \\<le> int (N ^ i)", "by linarith"], ["proof (state)\nthis:\n  d fs i \\<le> int (N ^ i)\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from denom d"], ["proof (chain)\npicking this:\n  denom \\<le> d fs i\n  d fs i \\<le> int (N ^ i)", "have denom: \"denom \\<le> int (N ^ i)\""], ["proof (prove)\nusing this:\n  denom \\<le> d fs i\n  d fs i \\<le> int (N ^ i)\n\ngoal (1 subgoal):\n 1. denom \\<le> int (N ^ i)", "by auto"], ["proof (state)\nthis:\n  denom \\<le> int (N ^ i)\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "note num"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> d fs i * int N\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> d fs i * int N\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"d fs i * int N \\<le> int (N ^ i) * int N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d fs i * int N \\<le> int (N ^ i) * int N", "by (rule mult_right_mono[OF d], auto)"], ["proof (state)\nthis:\n  d fs i * int N \\<le> int (N ^ i) * int N\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  d fs i * int N \\<le> int (N ^ i) * int N\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> = int (N ^ (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (N ^ i) * int N = int (N ^ Suc i)", "by simp"], ["proof (state)\nthis:\n  int (N ^ i) * int N = int (N ^ Suc i)\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>num\\<bar> \\<le> int (N ^ Suc i)", "have num: \"\\<bar>num\\<bar> \\<le> int (N ^ (i + 1))\""], ["proof (prove)\nusing this:\n  \\<bar>num\\<bar> \\<le> int (N ^ Suc i)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (i + 1))", "by auto"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> int (N ^ (i + 1))\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "{"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> int (N ^ (i + 1))\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "fix jj"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "assume \"jj \\<le> i + 1\""], ["proof (state)\nthis:\n  jj \\<le> i + 1\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "with i"], ["proof (chain)\npicking this:\n  i < m\n  jj \\<le> i + 1", "have \"jj \\<le> m\""], ["proof (prove)\nusing this:\n  i < m\n  jj \\<le> i + 1\n\ngoal (1 subgoal):\n 1. jj \\<le> m", "by auto"], ["proof (state)\nthis:\n  jj \\<le> m\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from pow_mono_exp[OF _ this, of N] N0"], ["proof (chain)\npicking this:\n  1 \\<le> N \\<Longrightarrow> N ^ jj \\<le> N ^ m\n  N \\<noteq> 0", "have \"N^jj \\<le> N^m\""], ["proof (prove)\nusing this:\n  1 \\<le> N \\<Longrightarrow> N ^ jj \\<le> N ^ m\n  N \\<noteq> 0\n\ngoal (1 subgoal):\n 1. N ^ jj \\<le> N ^ m", "by auto"], ["proof (state)\nthis:\n  N ^ jj \\<le> N ^ m\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "hence \"int (N^jj) \\<le> int (N^m)\""], ["proof (prove)\nusing this:\n  N ^ jj \\<le> N ^ m\n\ngoal (1 subgoal):\n 1. int (N ^ jj) \\<le> int (N ^ m)", "by linarith"], ["proof (state)\nthis:\n  int (N ^ jj) \\<le> int (N ^ m)\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "}"], ["proof (state)\nthis:\n  ?jj3 \\<le> i + 1 \\<Longrightarrow> int (N ^ ?jj3) \\<le> int (N ^ m)\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "note j_m = this"], ["proof (state)\nthis:\n  ?jj3 \\<le> i + 1 \\<Longrightarrow> int (N ^ ?jj3) \\<le> int (N ^ m)\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<bar>denom\\<bar> = denom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>denom\\<bar> = denom", "using quotient_of_denom_pos[OF quot]"], ["proof (prove)\nusing this:\n  0 < denom\n\ngoal (1 subgoal):\n 1. \\<bar>denom\\<bar> = denom", "by auto"], ["proof (state)\nthis:\n  \\<bar>denom\\<bar> = denom\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  \\<bar>denom\\<bar> = denom\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> int (N ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. denom \\<le> int (N ^ i)", "by fact"], ["proof (state)\nthis:\n  denom \\<le> int (N ^ i)\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  denom \\<le> int (N ^ i)\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> int (N ^ m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (N ^ i) \\<le> int (N ^ m)", "by (rule j_m, auto)"], ["proof (state)\nthis:\n  int (N ^ i) \\<le> int (N ^ m)\n\ngoal (2 subgoals):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)\n 2. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)", "show \"\\<bar>denom\\<bar> \\<le> int (N ^ m)\""], ["proof (prove)\nusing this:\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)", "show \"\\<bar>num\\<bar> \\<le> int (N ^ m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)", "using j_m[of \"i+1\"] num"], ["proof (prove)\nusing this:\n  i + 1 \\<le> i + 1 \\<Longrightarrow> int (N ^ (i + 1)) \\<le> int (N ^ m)\n  \\<bar>num\\<bar> \\<le> int (N ^ (i + 1))\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> int (N ^ m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_f_bound:\n  assumes i: \"i < m\" and j: \"j < n\" \nshows \"\\<bar>fs ! i $ j\\<bar> \\<le> N ^ m * 2 ^ (m - 1) * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "have \"\\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "using LLL_f_bnd[OF i j]"], ["proof (prove)\nusing this:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)", "by auto"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (f_bnd outside)\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "have \"\\<dots> \\<le> int (f_bnd False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (f_bnd outside) \\<le> int (f_bnd False)", "using f_bnd_mono[of outside]"], ["proof (prove)\nusing this:\n  f_bnd outside \\<le> f_bnd False\n\ngoal (1 subgoal):\n 1. int (f_bnd outside) \\<le> int (f_bnd False)", "by presburger"], ["proof (state)\nthis:\n  int (f_bnd outside) \\<le> int (f_bnd False)\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  int (f_bnd outside) \\<le> int (f_bnd False)\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "have \"\\<dots> = int (N ^ m * 2 ^ (m - 1) * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (f_bnd False) = int (N ^ m * 2 ^ (m - 1) * m)", "by simp"], ["proof (state)\nthis:\n  int (f_bnd False) = int (N ^ m * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "."], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_d_bound: \n  assumes i: \"i \\<le> m\"   \nshows \"abs (d fs i) \\<le> N ^ i \\<and> abs (d fs i) \\<le> N ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "proof (cases \"m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "case True"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "with i"], ["proof (chain)\npicking this:\n  i \\<le> m\n  m = 0", "have id: \"m = 0\" \"i = 0\""], ["proof (prove)\nusing this:\n  i \\<le> m\n  m = 0\n\ngoal (1 subgoal):\n 1. m = 0 &&& i = 0", "by auto"], ["proof (state)\nthis:\n  m = 0\n  i = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)\n 2. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "unfolding id(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>d fs 0\\<bar> \\<le> int (N ^ 0) \\<and>\n    \\<bar>d fs 0\\<bar> \\<le> int (N ^ m)", "using id"], ["proof (prove)\nusing this:\n  m = 0\n  i = 0\n\ngoal (1 subgoal):\n 1. \\<bar>d fs 0\\<bar> \\<le> int (N ^ 0) \\<and>\n    \\<bar>d fs 0\\<bar> \\<le> int (N ^ m)", "unfolding gs.Gramian_determinant_0 d_def"], ["proof (prove)\nusing this:\n  m = 0\n  i = 0\n\ngoal (1 subgoal):\n 1. \\<bar>1\\<bar> \\<le> int (N ^ 0) \\<and> \\<bar>1\\<bar> \\<le> int (N ^ m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n  \\<bar>d fs i\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "case m: False"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "from bound_invD[OF binv]"], ["proof (chain)\npicking this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs", "have inv: \"LLL_invariant upw k fs\"\n     and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw k fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "from LLL_inv_N_pos[OF invw gbnd] m"], ["proof (chain)\npicking this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  m \\<noteq> 0", "have N: \"N > 0\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "let ?r = rat_of_int"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "from d_approx_main[OF invw gbnd i m]"], ["proof (chain)\npicking this:\n  rat_of_int (d fs i) \\<le> rat_of_nat (N ^ i)", "have \"rat_of_int (d fs i) \\<le> of_nat (N ^ i)\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs i) \\<le> rat_of_nat (N ^ i)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs i) \\<le> rat_of_nat (N ^ i)", "by auto"], ["proof (state)\nthis:\n  rat_of_int (d fs i) \\<le> rat_of_nat (N ^ i)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "hence one: \"d fs i \\<le> N ^ i\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs i) \\<le> rat_of_nat (N ^ i)\n\ngoal (1 subgoal):\n 1. d fs i \\<le> int (N ^ i)", "by linarith"], ["proof (state)\nthis:\n  d fs i \\<le> int (N ^ i)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  d fs i \\<le> int (N ^ i)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> N ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (N ^ i) \\<le> int (N ^ m)", "unfolding of_nat_le_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. N ^ i \\<le> N ^ m", "by (rule pow_mono_exp, insert N i, auto)"], ["proof (state)\nthis:\n  int (N ^ i) \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "finally"], ["proof (chain)\npicking this:\n  d fs i \\<le> int (N ^ m)", "have \"d fs i \\<le> N ^ m\""], ["proof (prove)\nusing this:\n  d fs i \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. d fs i \\<le> int (N ^ m)", "by simp"], ["proof (state)\nthis:\n  d fs i \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "with LLL_d_pos[OF invw i] one"], ["proof (chain)\npicking this:\n  0 < d fs i\n  d fs i \\<le> int (N ^ i)\n  d fs i \\<le> int (N ^ m)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < d fs i\n  d fs i \\<le> int (N ^ i)\n  d fs i \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n    \\<bar>d fs i\\<bar> \\<le> int (N ^ m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>d fs i\\<bar> \\<le> int (N ^ i) \\<and>\n  \\<bar>d fs i\\<bar> \\<le> int (N ^ m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_mu_abs_bound: \n  assumes i: \"i < m\"\n  and j: \"j < i\" \nshows \"\\<bar>\\<mu> fs i j\\<bar> \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "from bound_invD[OF binv]"], ["proof (chain)\npicking this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs", "have inv: \"LLL_invariant upw k fs\"\n     and fbnd: \"f_bound outside k fs\"\n     and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw k fs &&& f_bound outside k fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "from LLL_inv_N_pos[OF invw gbnd] i"], ["proof (chain)\npicking this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  i < m", "have N: \"N > 0\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  i < m\n\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "note * = LLL_invD[OF inv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  k \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n\ngoal (1 subgoal):\n 1. \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "interpret fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by standard (use invw in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "let ?mu = \"\\<mu> fs i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "from j i"], ["proof (chain)\npicking this:\n  j < i\n  i < m", "have jm: \"j < m\""], ["proof (prove)\nusing this:\n  j < i\n  i < m\n\ngoal (1 subgoal):\n 1. j < m", "by auto"], ["proof (state)\nthis:\n  j < m\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "from d_approx[OF invw gbnd jm]"], ["proof (chain)\npicking this:\n  rat_of_int (d fs j) \\<le> rat_of_nat (N ^ j)", "have dj: \"d fs j \\<le> int (N ^ j)\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs j) \\<le> rat_of_nat (N ^ j)\n\ngoal (1 subgoal):\n 1. d fs j \\<le> int (N ^ j)", "by linarith"], ["proof (state)\nthis:\n  d fs j \\<le> int (N ^ j)\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "let ?num = \"4 ^ (m - 1) * N ^ m * m * m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "let ?bnd = \"N^(m - 1) * 2 ^ (m - 1) * m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "from fbnd[unfolded f_bound_def, rule_format, OF i]\n    aux_bnd_mono[folded of_nat_le_iff[where ?'a = int]]"], ["proof (chain)\npicking this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n  int (N * m) \\<le> int (4 ^ (m - 1) * N ^ m * m * m)", "have sq_f_bnd: \"sq_norm (fs ! i) \\<le> int ?num\""], ["proof (prove)\nusing this:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> (if i \\<noteq> k \\<or> outside then int (N * m)\n         else int (4 ^ (m - 1) * N ^ m * m * m))\n  int (N * m) \\<le> int (4 ^ (m - 1) * N ^ m * m * m)\n\ngoal (1 subgoal):\n 1. \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> int (4 ^ (m - 1) * N ^ m * m * m)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  \\<parallel>fs ! i\\<parallel>\\<^sup>2\n  \\<le> int (4 ^ (m - 1) * N ^ m * m * m)\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "have four: \"(4 :: nat) = 2^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 = 2\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  4 = 2\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "have \"?mu^2 \\<le> (gs.Gramian_determinant (RAT fs) j) * sq_norm (RAT fs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2\n    \\<le> fs.gs.d j *\n          \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2\n    \\<le> fs.gs.d j *\n          \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2", "have 1: \"of_int_hom.vec_hom (fs ! j) $ i \\<in> \\<int>\" if \"i < n\" \"j < length fs\" for j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! j) $ i \\<in> \\<int>", "using * that"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> k\n  k \\<le> m\n  fs.gs.reduced \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n  i < n\n  j < length fs\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs ! j) $ i \\<in> \\<int>", "by (metis vec_hom_Ints)"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < length fs\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2\n    \\<le> fs.gs.d j *\n          \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < n; ?j2 < length fs\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < length fs\\<rbrakk>\n  \\<Longrightarrow> of_int_hom.vec_hom (fs ! ?j2) $ ?i2 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2\n    \\<le> fs.gs.d j *\n          \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2", "by (intro fs.gs.mu_bound_Gramian_determinant[OF j], insert * j i, \n          auto simp: set_conv_nth gs.lin_indpt_list_def)"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2\n  \\<le> fs.gs.d j *\n        \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2\n  \\<le> fs.gs.d j *\n        \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2\n  \\<le> fs.gs.d j *\n        \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "have \"sq_norm (RAT fs ! i) = of_int (sq_norm (fs ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2 =\n    rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2", "unfolding sq_norm_of_int[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2 =\n    \\<parallel>of_int_hom.vec_hom (fs ! i)\\<parallel>\\<^sup>2", "using *(6) i"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n\ngoal (1 subgoal):\n 1. \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2 =\n    \\<parallel>of_int_hom.vec_hom (fs ! i)\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2 =\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  \\<parallel>map of_int_hom.vec_hom fs ! i\\<parallel>\\<^sup>2 =\n  rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "have \"(gs.Gramian_determinant (RAT fs) j) = of_int (d fs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.d j = rat_of_int (d fs j)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.d j = rat_of_int (gs.Gramian_determinant fs j)", "by (rule fs.of_int_Gramian_determinant, insert i j *(3,6), auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  fs.gs.d j = rat_of_int (d fs j)\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  fs.gs.d j = rat_of_int (d fs j)\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "have \"\\<dots> * of_int (sq_norm (fs ! i)) = of_int (d fs j * sq_norm (fs ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs j) * rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n    rat_of_int (d fs j * \\<parallel>fs ! i\\<parallel>\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs j) * rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  rat_of_int (d fs j * \\<parallel>fs ! i\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs j) * rat_of_int \\<parallel>fs ! i\\<parallel>\\<^sup>2 =\n  rat_of_int (d fs j * \\<parallel>fs ! i\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "have \"\\<dots> \\<le> of_int (int (N^j) * int ?num)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs j * \\<parallel>fs ! i\\<parallel>\\<^sup>2)\n    \\<le> rat_of_int (int (N ^ j) * int (4 ^ (m - 1) * N ^ m * m * m))", "unfolding of_int_le_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. d fs j * \\<parallel>fs ! i\\<parallel>\\<^sup>2\n    \\<le> int (N ^ j) * int (4 ^ (m - 1) * N ^ m * m * m)", "by (rule mult_mono[OF dj sq_f_bnd], auto)"], ["proof (state)\nthis:\n  rat_of_int (d fs j * \\<parallel>fs ! i\\<parallel>\\<^sup>2)\n  \\<le> rat_of_int (int (N ^ j) * int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs j * \\<parallel>fs ! i\\<parallel>\\<^sup>2)\n  \\<le> rat_of_int (int (N ^ j) * int (4 ^ (m - 1) * N ^ m * m * m))\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "have \"\\<dots> = of_nat (N^(j + m) * (4 ^ (m - 1) * m * m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (int (N ^ j) * int (4 ^ (m - 1) * N ^ m * m * m)) =\n    rat_of_nat (N ^ (j + m) * (4 ^ (m - 1) * m * m))", "by (simp add: power_add)"], ["proof (state)\nthis:\n  rat_of_int (int (N ^ j) * int (4 ^ (m - 1) * N ^ m * m * m)) =\n  rat_of_nat (N ^ (j + m) * (4 ^ (m - 1) * m * m))\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  rat_of_int (int (N ^ j) * int (4 ^ (m - 1) * N ^ m * m * m)) =\n  rat_of_nat (N ^ (j + m) * (4 ^ (m - 1) * m * m))\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "have \"\\<dots> \\<le> of_nat (N^( (m - 1) + (m-1)) * (4 ^ (m - 1) * m * m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (N ^ (j + m) * (4 ^ (m - 1) * m * m))\n    \\<le> rat_of_nat (N ^ (m - 1 + (m - 1)) * (4 ^ (m - 1) * m * m))", "unfolding of_nat_le_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. N ^ (j + m) * (4 ^ (m - 1) * m * m)\n    \\<le> N ^ (m - 1 + (m - 1)) * (4 ^ (m - 1) * m * m)", "by (rule mult_right_mono[OF pow_mono_exp], insert N j i jm, auto)"], ["proof (state)\nthis:\n  rat_of_nat (N ^ (j + m) * (4 ^ (m - 1) * m * m))\n  \\<le> rat_of_nat (N ^ (m - 1 + (m - 1)) * (4 ^ (m - 1) * m * m))\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  rat_of_nat (N ^ (j + m) * (4 ^ (m - 1) * m * m))\n  \\<le> rat_of_nat (N ^ (m - 1 + (m - 1)) * (4 ^ (m - 1) * m * m))\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "have \"\\<dots> = of_nat (?bnd^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (N ^ (m - 1 + (m - 1)) * (4 ^ (m - 1) * m * m)) =\n    rat_of_nat ((N ^ (m - 1) * 2 ^ (m - 1) * m)\\<^sup>2)", "unfolding four power_mult_distrib power2_eq_square of_nat_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (N ^ (m - 1 + (m - 1))) *\n    (rat_of_nat (2 ^ (m - 1)) * rat_of_nat (2 ^ (m - 1)) * rat_of_nat m *\n     rat_of_nat m) =\n    rat_of_nat (N ^ (m - 1)) * rat_of_nat (2 ^ (m - 1)) * rat_of_nat m *\n    (rat_of_nat (N ^ (m - 1)) * rat_of_nat (2 ^ (m - 1)) * rat_of_nat m)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  rat_of_nat (N ^ (m - 1 + (m - 1)) * (4 ^ (m - 1) * m * m)) =\n  rat_of_nat ((N ^ (m - 1) * 2 ^ (m - 1) * m)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "finally"], ["proof (chain)\npicking this:\n  (fs.gs.\\<mu> i j)\\<^sup>2\n  \\<le> rat_of_nat ((N ^ (m - 1) * 2 ^ (m - 1) * m)\\<^sup>2)", "have \"?mu^2 \\<le> (of_nat ?bnd)^2\""], ["proof (prove)\nusing this:\n  (fs.gs.\\<mu> i j)\\<^sup>2\n  \\<le> rat_of_nat ((N ^ (m - 1) * 2 ^ (m - 1) * m)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (fs.gs.\\<mu> i j)\\<^sup>2\n    \\<le> (rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m))\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  (fs.gs.\\<mu> i j)\\<^sup>2\n  \\<le> (rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "from this[folded abs_le_square_iff]"], ["proof (chain)\npicking this:\n  \\<bar>fs.gs.\\<mu> i j\\<bar>\n  \\<le> \\<bar>rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\\<bar>", "show \"abs ?mu \\<le> of_nat ?bnd\""], ["proof (prove)\nusing this:\n  \\<bar>fs.gs.\\<mu> i j\\<bar>\n  \\<le> \\<bar>rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>fs.gs.\\<mu> i j\\<bar>\n  \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_d\\<mu>_bound: \n  assumes i: \"i < m\" and j: \"j < i\"  \nshows \"abs (d\\<mu> fs i j) \\<le> N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "from bound_invD[OF binv]"], ["proof (chain)\npicking this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs", "have inv: \"LLL_invariant upw k fs\"\n     and fbnd: \"f_bound outside k fs\"\n     and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw k fs &&& f_bound outside k fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "interpret fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by standard (use invw in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "from LLL_inv_N_pos[OF invw gbnd] i"], ["proof (chain)\npicking this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  i < m", "have N: \"N > 0\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  i < m\n\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "from j i"], ["proof (chain)\npicking this:\n  j < i\n  i < m", "have jm: \"j < m - 1\" \"j < m\""], ["proof (prove)\nusing this:\n  j < i\n  i < m\n\ngoal (1 subgoal):\n 1. j < m - 1 &&& j < m", "by auto"], ["proof (state)\nthis:\n  j < m - 1\n  j < m\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "let ?r = rat_of_int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "from LLL_d_bound[of \"Suc j\"] jm"], ["proof (chain)\npicking this:\n  Suc j \\<le> m \\<Longrightarrow>\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ Suc j) \\<and>\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ m)\n  j < m - 1\n  j < m", "have \"abs (d fs (Suc j)) \\<le> N ^ Suc j\""], ["proof (prove)\nusing this:\n  Suc j \\<le> m \\<Longrightarrow>\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ Suc j) \\<and>\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ m)\n  j < m - 1\n  j < m\n\ngoal (1 subgoal):\n 1. \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ Suc j)", "by linarith"], ["proof (state)\nthis:\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ Suc j)\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ Suc j)\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "have \"\\<dots> \\<le> N ^ (m - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (N ^ Suc j) \\<le> int (N ^ (m - 1))", "unfolding of_nat_le_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. N ^ Suc j \\<le> N ^ (m - 1)", "by (rule pow_mono_exp, insert N jm, auto)"], ["proof (state)\nthis:\n  int (N ^ Suc j) \\<le> int (N ^ (m - 1))\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ (m - 1))", "have dsj: \"abs (d fs (Suc j)) \\<le> int N ^ (m - 1)\""], ["proof (prove)\nusing this:\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ (m - 1))\n\ngoal (1 subgoal):\n 1. \\<bar>d fs (Suc j)\\<bar> \\<le> int N ^ (m - 1)", "by auto"], ["proof (state)\nthis:\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int N ^ (m - 1)\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "from fs.d\\<mu>[of j i] j i LLL_invD[OF inv]"], ["proof (chain)\npicking this:\n  \\<lbrakk>j < length fs; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (fs.d\\<mu> i j) =\n                    rat_of_int (fs.d fs (Suc j)) * fs.gs.\\<mu> i j\n  j < i\n  i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> k\n  k \\<le> m\n  fs.gs.reduced \\<alpha> k\n  upw \\<or> \\<mu>_small fs k", "have \"?r (abs (d\\<mu> fs i j)) = abs (?r (d fs (Suc j)) * \\<mu> fs i j)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length fs; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (fs.d\\<mu> i j) =\n                    rat_of_int (fs.d fs (Suc j)) * fs.gs.\\<mu> i j\n  j < i\n  i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> k\n  k \\<le> m\n  fs.gs.reduced \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>d\\<mu> fs i j\\<bar> =\n    \\<bar>rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j\\<bar>", "unfolding d_def fs.d_def d\\<mu>_def fs.d\\<mu>_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length fs; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int\n                     (int_of_rat\n                       (rat_of_int (gs.Gramian_determinant fs (Suc j)) *\n                        fs.gs.\\<mu> i j)) =\n                    rat_of_int (gs.Gramian_determinant fs (Suc j)) *\n                    fs.gs.\\<mu> i j\n  j < i\n  i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> k\n  k \\<le> m\n  fs.gs.reduced \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n\ngoal (1 subgoal):\n 1. rat_of_int\n     \\<bar>int_of_rat\n            (rat_of_int (gs.Gramian_determinant fs (Suc j)) *\n             fs.gs.\\<mu> i j)\\<bar> =\n    \\<bar>rat_of_int (gs.Gramian_determinant fs (Suc j)) *\n          fs.gs.\\<mu> i j\\<bar>", "by auto"], ["proof (state)\nthis:\n  rat_of_int \\<bar>d\\<mu> fs i j\\<bar> =\n  \\<bar>rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  rat_of_int \\<bar>d\\<mu> fs i j\\<bar> =\n  \\<bar>rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "have \"\\<dots> = ?r (abs (d fs (Suc j))) * abs (\\<mu> fs i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j\\<bar> =\n    rat_of_int \\<bar>d fs (Suc j)\\<bar> * \\<bar>fs.gs.\\<mu> i j\\<bar>", "by (simp add: abs_mult)"], ["proof (state)\nthis:\n  \\<bar>rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j\\<bar> =\n  rat_of_int \\<bar>d fs (Suc j)\\<bar> * \\<bar>fs.gs.\\<mu> i j\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  \\<bar>rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j\\<bar> =\n  rat_of_int \\<bar>d fs (Suc j)\\<bar> * \\<bar>fs.gs.\\<mu> i j\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "have \"\\<dots> \\<le> ?r (int N ^ (m - 1)) * rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>d fs (Suc j)\\<bar> * \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_int (int N ^ (m - 1)) *\n          rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "by (rule mult_mono[OF _ LLL_mu_abs_bound[OF i j]], insert dsj, linarith, auto)"], ["proof (state)\nthis:\n  rat_of_int \\<bar>d fs (Suc j)\\<bar> * \\<bar>fs.gs.\\<mu> i j\\<bar>\n  \\<le> rat_of_int (int N ^ (m - 1)) *\n        rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  rat_of_int \\<bar>d fs (Suc j)\\<bar> * \\<bar>fs.gs.\\<mu> i j\\<bar>\n  \\<le> rat_of_int (int N ^ (m - 1)) *\n        rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "have \"\\<dots> = ?r (int (N ^ ((m - 1) + (m - 1)) * 2 ^ (m - 1) * m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (int N ^ (m - 1)) *\n    rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m) =\n    rat_of_int (int (N ^ (m - 1 + (m - 1)) * 2 ^ (m - 1) * m))", "by (simp add: power_add)"], ["proof (state)\nthis:\n  rat_of_int (int N ^ (m - 1)) *\n  rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m) =\n  rat_of_int (int (N ^ (m - 1 + (m - 1)) * 2 ^ (m - 1) * m))\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "also"], ["proof (state)\nthis:\n  rat_of_int (int N ^ (m - 1)) *\n  rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m) =\n  rat_of_int (int (N ^ (m - 1 + (m - 1)) * 2 ^ (m - 1) * m))\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "have \"(m - 1) + (m - 1) = 2 * (m - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m - 1 + (m - 1) = 2 * (m - 1)", "by simp"], ["proof (state)\nthis:\n  m - 1 + (m - 1) = 2 * (m - 1)\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int \\<bar>d\\<mu> fs i j\\<bar>\n  \\<le> rat_of_int (int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m))", "show \"abs (d\\<mu> fs i j) \\<le> N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m\""], ["proof (prove)\nusing this:\n  rat_of_int \\<bar>d\\<mu> fs i j\\<bar>\n  \\<le> rat_of_int (int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m))\n\ngoal (1 subgoal):\n 1. \\<bar>d\\<mu> fs i j\\<bar>\n    \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "by linarith"], ["proof (state)\nthis:\n  \\<bar>d\\<mu> fs i j\\<bar> \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_mu_num_denom_bound: \n  assumes i: \"i < m\"                 \n  and quot: \"quotient_of (\\<mu> fs i j) = (num, denom)\" \nshows \"\\<bar>num\\<bar>   \\<le> N ^ (2 * m) * 2 ^ m * m\" \n  and \"\\<bar>denom\\<bar> \\<le> N ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) &&&\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "proof (atomize(full))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from bound_invD[OF binv]"], ["proof (chain)\npicking this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs", "have inv: \"LLL_invariant upw k fs\"\n     and fbnd: \"f_bound outside k fs\"\n     and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw k fs &&& f_bound outside k fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from LLL_inv_N_pos[OF invw gbnd] i"], ["proof (chain)\npicking this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  i < m", "have N: \"N > 0\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  i < m\n\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "note * = LLL_invD[OF inv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  k \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> k\n  upw \\<or> \\<mu>_small fs k\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "interpret fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by standard (use invw in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "let ?mu = \"\\<mu> fs i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "let ?bnd = \"N^(m - 1) * 2 ^ (m - 1) * m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "show \"\\<bar>num\\<bar> \\<le> N ^ (2 * m) * 2 ^ m * m \\<and> \\<bar>denom\\<bar> \\<le> N ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "proof (cases \"j < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "case j: True"], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "with i"], ["proof (chain)\npicking this:\n  i < m\n  j < i", "have jm: \"j < m\""], ["proof (prove)\nusing this:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. j < m", "by auto"], ["proof (state)\nthis:\n  j < m\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from LLL_d_pos[OF invw, of \"Suc j\"] i j"], ["proof (chain)\npicking this:\n  Suc j \\<le> m \\<Longrightarrow> 0 < d fs (Suc j)\n  i < m\n  j < i", "have dsj: \"0 < d fs (Suc j)\""], ["proof (prove)\nusing this:\n  Suc j \\<le> m \\<Longrightarrow> 0 < d fs (Suc j)\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. 0 < d fs (Suc j)", "by auto"], ["proof (state)\nthis:\n  0 < d fs (Suc j)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from quotient_of_square[OF quot]"], ["proof (chain)\npicking this:\n  quotient_of (fs.gs.\\<mu> i j * fs.gs.\\<mu> i j) =\n  (num * num, denom * denom)", "have quot_sq: \"quotient_of (?mu^2) = (num * num, denom * denom)\""], ["proof (prove)\nusing this:\n  quotient_of (fs.gs.\\<mu> i j * fs.gs.\\<mu> i j) =\n  (num * num, denom * denom)\n\ngoal (1 subgoal):\n 1. quotient_of ((fs.gs.\\<mu> i j)\\<^sup>2) = (num * num, denom * denom)", "unfolding power2_eq_square"], ["proof (prove)\nusing this:\n  quotient_of (fs.gs.\\<mu> i j * fs.gs.\\<mu> i j) =\n  (num * num, denom * denom)\n\ngoal (1 subgoal):\n 1. quotient_of (fs.gs.\\<mu> i j * fs.gs.\\<mu> i j) =\n    (num * num, denom * denom)", "by auto"], ["proof (state)\nthis:\n  quotient_of ((fs.gs.\\<mu> i j)\\<^sup>2) = (num * num, denom * denom)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from LLL_mu_abs_bound[OF assms(1) j]"], ["proof (chain)\npicking this:\n  \\<bar>fs.gs.\\<mu> i j\\<bar>\n  \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "have mu_bound: \"abs ?mu \\<le> of_nat ?bnd\""], ["proof (prove)\nusing this:\n  \\<bar>fs.gs.\\<mu> i j\\<bar>\n  \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<bar>fs.gs.\\<mu> i j\\<bar>\n    \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>fs.gs.\\<mu> i j\\<bar>\n  \\<le> rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"gs.Gramian_determinant (RAT fs) (Suc j) * ?mu \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.d (Suc j) * fs.gs.\\<mu> i j \\<in> \\<int>", "by (rule fs.gs.d_mu_Ints,\n      insert j *(1,3-6) i, auto simp: set_conv_nth gs.lin_indpt_list_def vec_hom_Ints)"], ["proof (state)\nthis:\n  fs.gs.d (Suc j) * fs.gs.\\<mu> i j \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  fs.gs.d (Suc j) * fs.gs.\\<mu> i j \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"(gs.Gramian_determinant (RAT fs) (Suc j)) = of_int (d fs (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.d (Suc j) = rat_of_int (d fs (Suc j))", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.d (Suc j) = rat_of_int (gs.Gramian_determinant fs (Suc j))", "by (rule fs.of_int_Gramian_determinant, insert i j *(3,6), auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  fs.gs.d (Suc j) = rat_of_int (d fs (Suc j))\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j \\<in> \\<int>", "have ints: \"of_int (d fs (Suc j)) * ?mu \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j \\<in> \\<int>", "."], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from LLL_d_bound[of \"Suc j\"] jm"], ["proof (chain)\npicking this:\n  Suc j \\<le> m \\<Longrightarrow>\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ Suc j) \\<and>\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ m)\n  j < m", "have d_j: \"d fs (Suc j) \\<le> N ^ m\""], ["proof (prove)\nusing this:\n  Suc j \\<le> m \\<Longrightarrow>\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ Suc j) \\<and>\n  \\<bar>d fs (Suc j)\\<bar> \\<le> int (N ^ m)\n  j < m\n\ngoal (1 subgoal):\n 1. d fs (Suc j) \\<le> int (N ^ m)", "by auto"], ["proof (state)\nthis:\n  d fs (Suc j) \\<le> int (N ^ m)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "note quot_bounds = quotient_of_bounds[OF quot ints dsj mu_bound]"], ["proof (state)\nthis:\n  rat_of_int \\<bar>num\\<bar>\n  \\<le> rat_of_int (d fs (Suc j)) *\n        rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\n  denom \\<le> d fs (Suc j)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"abs denom \\<le> denom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>denom\\<bar> \\<le> denom", "using quotient_of_denom_pos[OF quot]"], ["proof (prove)\nusing this:\n  0 < denom\n\ngoal (1 subgoal):\n 1. \\<bar>denom\\<bar> \\<le> denom", "by auto"], ["proof (state)\nthis:\n  \\<bar>denom\\<bar> \\<le> denom\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  \\<bar>denom\\<bar> \\<le> denom\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> d fs (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. denom \\<le> d fs (Suc j)", "by fact"], ["proof (state)\nthis:\n  denom \\<le> d fs (Suc j)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  denom \\<le> d fs (Suc j)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> N ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d fs (Suc j) \\<le> int (N ^ m)", "by fact"], ["proof (state)\nthis:\n  d fs (Suc j) \\<le> int (N ^ m)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have denom: \"abs denom \\<le> N ^ m\""], ["proof (prove)\nusing this:\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from quot_bounds(1)"], ["proof (chain)\npicking this:\n  rat_of_int \\<bar>num\\<bar>\n  \\<le> rat_of_int (d fs (Suc j)) *\n        rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)", "have \"\\<bar>num\\<bar> \\<le> d fs (Suc j) * int ?bnd\""], ["proof (prove)\nusing this:\n  rat_of_int \\<bar>num\\<bar>\n  \\<le> rat_of_int (d fs (Suc j)) *\n        rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> d fs (Suc j) * int (N ^ (m - 1) * 2 ^ (m - 1) * m)", "unfolding of_int_le_iff[symmetric, where ?'a = rat]"], ["proof (prove)\nusing this:\n  rat_of_int \\<bar>num\\<bar>\n  \\<le> rat_of_int (d fs (Suc j)) *\n        rat_of_nat (N ^ (m - 1) * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. rat_of_int \\<bar>num\\<bar>\n    \\<le> rat_of_int (d fs (Suc j) * int (N ^ (m - 1) * 2 ^ (m - 1) * m))", "by simp"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> d fs (Suc j) * int (N ^ (m - 1) * 2 ^ (m - 1) * m)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> d fs (Suc j) * int (N ^ (m - 1) * 2 ^ (m - 1) * m)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> N ^ m * int ?bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d fs (Suc j) * int (N ^ (m - 1) * 2 ^ (m - 1) * m)\n    \\<le> int (N ^ m) * int (N ^ (m - 1) * 2 ^ (m - 1) * m)", "by (rule mult_right_mono[OF d_j], auto)"], ["proof (state)\nthis:\n  d fs (Suc j) * int (N ^ (m - 1) * 2 ^ (m - 1) * m)\n  \\<le> int (N ^ m) * int (N ^ (m - 1) * 2 ^ (m - 1) * m)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  d fs (Suc j) * int (N ^ (m - 1) * 2 ^ (m - 1) * m)\n  \\<le> int (N ^ m) * int (N ^ (m - 1) * 2 ^ (m - 1) * m)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> = (int N ^ (m + (m - 1))) * (2 ^ (m - 1)) * int m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (N ^ m) * int (N ^ (m - 1) * 2 ^ (m - 1) * m) =\n    int N ^ (m + (m - 1)) * 2 ^ (m - 1) * int m", "unfolding power_add of_nat_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (N ^ m) * (int (N ^ (m - 1)) * int (2 ^ (m - 1)) * int m) =\n    int N ^ m * int N ^ (m - 1) * 2 ^ (m - 1) * int m", "by simp"], ["proof (state)\nthis:\n  int (N ^ m) * int (N ^ (m - 1) * 2 ^ (m - 1) * m) =\n  int N ^ (m + (m - 1)) * 2 ^ (m - 1) * int m\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  int (N ^ m) * int (N ^ (m - 1) * 2 ^ (m - 1) * m) =\n  int N ^ (m + (m - 1)) * 2 ^ (m - 1) * int m\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> (int N ^ (2 * m)) * (2 ^ m) * int m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int N ^ (m + (m - 1)) * 2 ^ (m - 1) * int m\n    \\<le> int N ^ (2 * m) * 2 ^ m * int m", "unfolding of_nat_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. int N ^ (m + (m - 1)) * 2 ^ (m - 1) * int m\n    \\<le> int N ^ (2 * m) * 2 ^ m * int m", "by (intro mult_mono pow_mono_exp, insert N, auto)"], ["proof (state)\nthis:\n  int N ^ (m + (m - 1)) * 2 ^ (m - 1) * int m\n  \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  int N ^ (m + (m - 1)) * 2 ^ (m - 1) * int m\n  \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> = int (N ^ (2 * m) * 2 ^ m * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int N ^ (2 * m) * 2 ^ m * int m = int (N ^ (2 * m) * 2 ^ m * m)", "by simp"], ["proof (state)\nthis:\n  int N ^ (2 * m) * 2 ^ m * int m = int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "have num: \"\\<bar>num\\<bar> \\<le> N ^ (2 * m) * 2 ^ m * m\""], ["proof (prove)\nusing this:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "."], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from denom num"], ["proof (chain)\npicking this:\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "by blast"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "case False"], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "hence \"?mu = 0 \\<or> ?mu = 1\""], ["proof (prove)\nusing this:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. fs.gs.\\<mu> i j = 0 \\<or> fs.gs.\\<mu> i j = 1", "unfolding fs.gs.\\<mu>.simps"], ["proof (prove)\nusing this:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. (if j < i\n     then map of_int_hom.vec_hom fs ! i \\<bullet> fs.gs.gso j /\n          \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2\n     else if i = j then 1 else 0) =\n    0 \\<or>\n    (if j < i\n     then map of_int_hom.vec_hom fs ! i \\<bullet> fs.gs.gso j /\n          \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2\n     else if i = j then 1 else 0) =\n    1", "by auto"], ["proof (state)\nthis:\n  fs.gs.\\<mu> i j = 0 \\<or> fs.gs.\\<mu> i j = 1\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "hence \"quotient_of ?mu = (1,1) \\<or> quotient_of ?mu = (0,1)\""], ["proof (prove)\nusing this:\n  fs.gs.\\<mu> i j = 0 \\<or> fs.gs.\\<mu> i j = 1\n\ngoal (1 subgoal):\n 1. quotient_of (fs.gs.\\<mu> i j) = (1, 1) \\<or>\n    quotient_of (fs.gs.\\<mu> i j) = (0, 1)", "by auto"], ["proof (state)\nthis:\n  quotient_of (fs.gs.\\<mu> i j) = (1, 1) \\<or>\n  quotient_of (fs.gs.\\<mu> i j) = (0, 1)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from this[unfolded quot]"], ["proof (chain)\npicking this:\n  (num, denom) = (1, 1) \\<or> (num, denom) = (0, 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (num, denom) = (1, 1) \\<or> (num, denom) = (0, 1)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "using N i"], ["proof (prove)\nusing this:\n  (num, denom) = (1, 1) \\<or> (num, denom) = (0, 1)\n  0 < N\n  i < m\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "by (auto intro!: mult_ge_one)"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now we have bounds on each number $(f_i)_j$, $(g_i)_j$, and $\\mu_{i,j}$, i.e.,\n  for rational numbers bounds on the numerators and denominators.\\<close>"], ["", "lemma logN_le_2log_Mn: assumes m: \"m \\<noteq> 0\" \"n \\<noteq> 0\" and N: \"N > 0\" \n  shows \"log 2 N \\<le> 2 * log 2 (M * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "have \"N \\<le> nat M * nat M * n * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<le> nat M * nat M * n * 1", "using N_le_MMn m"], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow> N \\<le> nat M * nat M * n\n  m \\<noteq> 0\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. N \\<le> nat M * nat M * n * 1", "by auto"], ["proof (state)\nthis:\n  N \\<le> nat M * nat M * n * 1\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "also"], ["proof (state)\nthis:\n  N \\<le> nat M * nat M * n * 1\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "have \"\\<dots> \\<le> nat M * nat M * n * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat M * nat M * n * 1 \\<le> nat M * nat M * n * n", "by (intro mult_mono, insert m, auto)"], ["proof (state)\nthis:\n  nat M * nat M * n * 1 \\<le> nat M * nat M * n * n\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "finally"], ["proof (chain)\npicking this:\n  N \\<le> nat M * nat M * n * n", "have NM: \"N \\<le> nat M * nat M * n * n\""], ["proof (prove)\nusing this:\n  N \\<le> nat M * nat M * n * n\n\ngoal (1 subgoal):\n 1. N \\<le> nat M * nat M * n * n", "by simp"], ["proof (state)\nthis:\n  N \\<le> nat M * nat M * n * n\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "with N"], ["proof (chain)\npicking this:\n  0 < N\n  N \\<le> nat M * nat M * n * n", "have \"nat M \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < N\n  N \\<le> nat M * nat M * n * n\n\ngoal (1 subgoal):\n 1. nat M \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  nat M \\<noteq> 0\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "hence M: \"M > 0\""], ["proof (prove)\nusing this:\n  nat M \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < M", "by simp"], ["proof (state)\nthis:\n  0 < M\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "have \"log 2 N \\<le> log 2 (M * M * n * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> log 2 (real_of_int (M * M * int n * int n))", "proof (subst log_le_cancel_iff)"], ["proof (state)\ngoal (4 subgoals):\n 1. 1 < 2\n 2. 0 < real N\n 3. 0 < real_of_int (M * M * int n * int n)\n 4. real N \\<le> real_of_int (M * M * int n * int n)", "show \"real N \\<le> (M * M * int n * int n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real N \\<le> real_of_int (M * M * int n * int n)", "using NM[folded of_nat_le_iff[where ?'a = real]] M"], ["proof (prove)\nusing this:\n  real N \\<le> real (nat M * nat M * n * n)\n  0 < M\n\ngoal (1 subgoal):\n 1. real N \\<le> real_of_int (M * M * int n * int n)", "by simp"], ["proof (state)\nthis:\n  real N \\<le> real_of_int (M * M * int n * int n)\n\ngoal (3 subgoals):\n 1. 1 < 2\n 2. 0 < real N\n 3. 0 < real_of_int (M * M * int n * int n)", "qed (insert N M m, auto)"], ["proof (state)\nthis:\n  log 2 (real N) \\<le> log 2 (real_of_int (M * M * int n * int n))\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "also"], ["proof (state)\nthis:\n  log 2 (real N) \\<le> log 2 (real_of_int (M * M * int n * int n))\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "have \"\\<dots> = log 2 (of_int (M * n) * of_int (M * n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real_of_int (M * M * int n * int n)) =\n    log 2 (real_of_int (M * int n) * real_of_int (M * int n))", "unfolding of_int_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2\n     (real_of_int M * real_of_int M * real_of_int (int n) *\n      real_of_int (int n)) =\n    log 2\n     (real_of_int M * real_of_int (int n) *\n      (real_of_int M * real_of_int (int n)))", "by (simp  add: ac_simps)"], ["proof (state)\nthis:\n  log 2 (real_of_int (M * M * int n * int n)) =\n  log 2 (real_of_int (M * int n) * real_of_int (M * int n))\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "also"], ["proof (state)\nthis:\n  log 2 (real_of_int (M * M * int n * int n)) =\n  log 2 (real_of_int (M * int n) * real_of_int (M * int n))\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "have \"\\<dots> = 2 * log 2 (M * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real_of_int (M * int n) * real_of_int (M * int n)) =\n    2 * log 2 (real_of_int (M * int n))", "by (subst log_mult, insert m M, auto)"], ["proof (state)\nthis:\n  log 2 (real_of_int (M * int n) * real_of_int (M * int n)) =\n  2 * log 2 (real_of_int (M * int n))\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "finally"], ["proof (chain)\npicking this:\n  log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "show \"log 2 N \\<le> 2 * log 2 (M * n)\""], ["proof (prove)\nusing this:\n  log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))\n\ngoal (1 subgoal):\n 1. log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))", "by auto"], ["proof (state)\nthis:\n  log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We now prove a combined size-bound for all of these numbers. The bounds clearly indicate\n  that the size of the numbers grows at most polynomial, namely the sizes are roughly \n  bounded by ${\\cal O}(m \\cdot \\log(M \\cdot n))$ where $m$ is the number of vectors, $n$ is the dimension\n  of the vectors, and $M$ is the maximum absolute value that occurs in the input to the LLL algorithm.\\<close>"], ["", "lemma combined_size_bound: fixes number :: int \n  assumes i: \"i < m\" and j: \"j < n\"\n  and x: \"x \\<in> {of_int (fs ! i $ j), gso fs i $ j, \\<mu> fs i j}\" \n  and quot: \"quotient_of x = (num, denom)\" \n  and number: \"number \\<in> {num, denom}\" \n  and number0: \"number \\<noteq> 0\" \nshows \"log 2 \\<bar>number\\<bar> \\<le> 2 * m * log 2 N       + m + log 2 m\" \n      \"log 2 \\<bar>number\\<bar> \\<le> 4 * m * log 2 (M * n) + m + log 2 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m) &&&\n    log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "from bound_invD[OF binv]"], ["proof (chain)\npicking this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs", "have inv: \"LLL_invariant upw k fs\"\n     and fbnd: \"f_bound outside k fs\" \n     and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw k fs &&& f_bound outside k fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "from LLL_inv_N_pos[OF invw gbnd] i"], ["proof (chain)\npicking this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  i < m", "have N: \"N > 0\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow> 0 < N\n  i < m\n\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "let ?bnd = \"N ^ (2 * m) * 2 ^ m * m\""], ["proof (state)\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "have \"N ^ m * int 1 \\<le> N ^ (2 * m) * (2^m * int m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (N ^ m) * int 1 \\<le> int (N ^ (2 * m)) * (2 ^ m * int m)", "by (rule mult_mono, unfold of_nat_le_iff, rule pow_mono_exp, insert N i, auto)"], ["proof (state)\nthis:\n  int (N ^ m) * int 1 \\<le> int (N ^ (2 * m)) * (2 ^ m * int m)\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "hence le: \"int (N ^ m) \\<le> N ^ (2 * m) * 2^m * m\""], ["proof (prove)\nusing this:\n  int (N ^ m) * int 1 \\<le> int (N ^ (2 * m)) * (2 ^ m * int m)\n\ngoal (1 subgoal):\n 1. int (N ^ m) \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "by auto"], ["proof (state)\nthis:\n  int (N ^ m) \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "from x"], ["proof (chain)\npicking this:\n  x \\<in> {rat_of_int (fs ! i $ j),\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i $ j,\n           gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j}", "consider (xfs) \"x = of_int (fs ! i $ j)\" | (xgs) \"x = gso fs i $ j\" | (xmu) \"x = \\<mu> fs i j\""], ["proof (prove)\nusing this:\n  x \\<in> {rat_of_int (fs ! i $ j),\n           gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i $ j,\n           gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = rat_of_int (fs ! i $ j) \\<Longrightarrow> thesis;\n     x =\n     gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i $\n     j \\<Longrightarrow>\n     thesis;\n     x =\n     gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n      j \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x = rat_of_int (fs ! i $ j) \\<Longrightarrow> ?thesis1;\n   x =\n   gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i $ j \\<Longrightarrow>\n   ?thesis1;\n   x =\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j \\<Longrightarrow>\n   ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "hence num_denom_bound: \"\\<bar>num\\<bar> \\<le> ?bnd \\<and> \\<bar>denom\\<bar> \\<le> N ^ m\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x = rat_of_int (fs ! i $ j) \\<Longrightarrow> ?thesis1;\n   x =\n   gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i $ j \\<Longrightarrow>\n   ?thesis1;\n   x =\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j \\<Longrightarrow>\n   ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. x =\n    gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i $\n    j \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 3. x =\n    gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n     j \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "case xgs"], ["proof (state)\nthis:\n  x = gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i $ j\n\ngoal (3 subgoals):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. x =\n    gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i $\n    j \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 3. x =\n    gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n     j \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from LLL_gso_bound[OF i j quot[unfolded xgs]] le"], ["proof (chain)\npicking this:\n  \\<bar>num\\<bar> \\<le> int (N ^ m)\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n  int (N ^ m) \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>num\\<bar> \\<le> int (N ^ m)\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n  int (N ^ m) \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (2 subgoals):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. x =\n    gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n     j \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. x =\n    gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n     j \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "case xmu"], ["proof (state)\nthis:\n  x = gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i j\n\ngoal (2 subgoals):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)\n 2. x =\n    gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n     j \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "from LLL_mu_num_denom_bound[OF i, of j, OF quot[unfolded xmu]]"], ["proof (chain)\npicking this:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "case xfs"], ["proof (state)\nthis:\n  x = rat_of_int (fs ! i $ j)\n\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<bar>denom\\<bar> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>denom\\<bar> = 1", "using quot[unfolded xfs]"], ["proof (prove)\nusing this:\n  quotient_of (rat_of_int (fs ! i $ j)) = (num, denom)\n\ngoal (1 subgoal):\n 1. \\<bar>denom\\<bar> = 1", "by auto"], ["proof (state)\nthis:\n  \\<bar>denom\\<bar> = 1\n\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  \\<bar>denom\\<bar> = 1\n\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> N ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> int (N ^ m)", "using N"], ["proof (prove)\nusing this:\n  0 < N\n\ngoal (1 subgoal):\n 1. 1 \\<le> int (N ^ m)", "by auto"], ["proof (state)\nthis:\n  1 \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have denom: \"\\<bar>denom\\<bar> \\<le> N ^ m\""], ["proof (prove)\nusing this:\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<bar>denom\\<bar> \\<le> int (N ^ m)", "."], ["proof (state)\nthis:\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<bar>num\\<bar> = \\<bar>fs ! i $ j\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> = \\<bar>fs ! i $ j\\<bar>", "using quot[unfolded xfs]"], ["proof (prove)\nusing this:\n  quotient_of (rat_of_int (fs ! i $ j)) = (num, denom)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> = \\<bar>fs ! i $ j\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> = \\<bar>fs ! i $ j\\<bar>\n\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> = \\<bar>fs ! i $ j\\<bar>\n\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> int (N ^ m * 2 ^ (m - 1) * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "using LLL_f_bound[OF i j]"], ["proof (prove)\nusing this:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "also"], ["proof (state)\nthis:\n  \\<bar>fs ! i $ j\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "have \"\\<dots> \\<le> ?bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (N ^ m * 2 ^ (m - 1) * m) \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "unfolding of_nat_mult of_nat_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (N ^ m) * int (2 ^ (m - 1)) * int m\n    \\<le> int (N ^ (2 * m)) * int (2 ^ m) * int m", "using N"], ["proof (prove)\nusing this:\n  0 < N\n\ngoal (1 subgoal):\n 1. int (N ^ m) * int (2 ^ (m - 1)) * int m\n    \\<le> int (N ^ (2 * m)) * int (2 ^ m) * int m", "by (auto intro!: mult_mono pow_mono_exp)"], ["proof (state)\nthis:\n  int (N ^ m * 2 ^ (m - 1) * m) \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (1 subgoal):\n 1. x = rat_of_int (fs ! i $ j) \\<Longrightarrow>\n    \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "using denom"], ["proof (prove)\nusing this:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n    \\<bar>denom\\<bar> \\<le> int (N ^ m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "from number"], ["proof (chain)\npicking this:\n  number \\<in> {num, denom}", "consider (num) \"number = num\" | (denom) \"number = denom\""], ["proof (prove)\nusing this:\n  number \\<in> {num, denom}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>number = num \\<Longrightarrow> thesis;\n     number = denom \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>number = num \\<Longrightarrow> ?thesis1;\n   number = denom \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "hence number_bound: \"\\<bar>number\\<bar> \\<le> ?bnd\""], ["proof (prove)\nusing this:\n  \\<lbrakk>number = num \\<Longrightarrow> ?thesis1;\n   number = denom \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. number = num \\<Longrightarrow>\n    \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n 2. number = denom \\<Longrightarrow>\n    \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "case num"], ["proof (state)\nthis:\n  number = num\n\ngoal (2 subgoals):\n 1. number = num \\<Longrightarrow>\n    \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n 2. number = denom \\<Longrightarrow>\n    \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "with num_denom_bound"], ["proof (chain)\npicking this:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n  number = num", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n  number = num\n\ngoal (1 subgoal):\n 1. \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (1 subgoal):\n 1. number = denom \\<Longrightarrow>\n    \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. number = denom \\<Longrightarrow>\n    \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "case denom"], ["proof (state)\nthis:\n  number = denom\n\ngoal (1 subgoal):\n 1. number = denom \\<Longrightarrow>\n    \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "with num_denom_bound"], ["proof (chain)\npicking this:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n  number = denom", "have \"\\<bar>number\\<bar> \\<le> N ^ m\""], ["proof (prove)\nusing this:\n  \\<bar>num\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) \\<and>\n  \\<bar>denom\\<bar> \\<le> int (N ^ m)\n  number = denom\n\ngoal (1 subgoal):\n 1. \\<bar>number\\<bar> \\<le> int (N ^ m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>number\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. number = denom \\<Longrightarrow>\n    \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "with le"], ["proof (chain)\npicking this:\n  int (N ^ m) \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n  \\<bar>number\\<bar> \\<le> int (N ^ m)", "show ?thesis"], ["proof (prove)\nusing this:\n  int (N ^ m) \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n  \\<bar>number\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "by auto"], ["proof (state)\nthis:\n  \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "from number_bound"], ["proof (chain)\npicking this:\n  \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "have bnd: \"of_int \\<bar>number\\<bar> \\<le> real ?bnd\""], ["proof (prove)\nusing this:\n  \\<bar>number\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>number\\<bar> \\<le> real (N ^ (2 * m) * 2 ^ m * m)", "by linarith"], ["proof (state)\nthis:\n  real_of_int \\<bar>number\\<bar> \\<le> real (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "have \"log 2 \\<bar>number\\<bar> \\<le> log 2 ?bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> log 2 (real (N ^ (2 * m) * 2 ^ m * m))", "by (subst log_le_cancel_iff, insert number0 bnd, auto)"], ["proof (state)\nthis:\n  log 2 (real_of_int \\<bar>number\\<bar>)\n  \\<le> log 2 (real (N ^ (2 * m) * 2 ^ m * m))\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "also"], ["proof (state)\nthis:\n  log 2 (real_of_int \\<bar>number\\<bar>)\n  \\<le> log 2 (real (N ^ (2 * m) * 2 ^ m * m))\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "have \"\\<dots> = log 2 (N^(2 * m) * 2^m) + log 2 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (N ^ (2 * m) * 2 ^ m * m)) =\n    log 2 (real (N ^ (2 * m) * 2 ^ m)) + log 2 (real m)", "by (subst log_mult[symmetric], insert i N, auto)"], ["proof (state)\nthis:\n  log 2 (real (N ^ (2 * m) * 2 ^ m * m)) =\n  log 2 (real (N ^ (2 * m) * 2 ^ m)) + log 2 (real m)\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "also"], ["proof (state)\nthis:\n  log 2 (real (N ^ (2 * m) * 2 ^ m * m)) =\n  log 2 (real (N ^ (2 * m) * 2 ^ m)) + log 2 (real m)\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "have \"\\<dots> = log 2 (N^(2 * m)) + log 2 (2^m) + log 2 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (N ^ (2 * m) * 2 ^ m)) + log 2 (real m) =\n    log 2 (real (N ^ (2 * m))) + log 2 (2 ^ m) + log 2 (real m)", "by (subst log_mult[symmetric], insert i N, auto)"], ["proof (state)\nthis:\n  log 2 (real (N ^ (2 * m) * 2 ^ m)) + log 2 (real m) =\n  log 2 (real (N ^ (2 * m))) + log 2 (2 ^ m) + log 2 (real m)\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "also"], ["proof (state)\nthis:\n  log 2 (real (N ^ (2 * m) * 2 ^ m)) + log 2 (real m) =\n  log 2 (real (N ^ (2 * m))) + log 2 (2 ^ m) + log 2 (real m)\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "have \"log 2 (N^(2 * m)) = log 2 (N powr (2 * m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (N ^ (2 * m))) = log 2 (real N powr real (2 * m))", "by (rule arg_cong[of _ _ \"log 2\"], subst powr_realpow, insert N, auto)"], ["proof (state)\nthis:\n  log 2 (real (N ^ (2 * m))) = log 2 (real N powr real (2 * m))\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "also"], ["proof (state)\nthis:\n  log 2 (real (N ^ (2 * m))) = log 2 (real N powr real (2 * m))\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "have \"\\<dots> = (2 * m) * log 2 N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real N powr real (2 * m)) = real (2 * m) * log 2 (real N)", "by (subst log_powr, insert N, auto)"], ["proof (state)\nthis:\n  log 2 (real N powr real (2 * m)) = real (2 * m) * log 2 (real N)\n\ngoal (2 subgoals):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "finally"], ["proof (chain)\npicking this:\n  log 2 (real_of_int \\<bar>number\\<bar>)\n  \\<le> real (2 * m) * log 2 (real N) + log 2 (2 ^ m) + log 2 (real m)", "show boundN: \"log 2 \\<bar>number\\<bar> \\<le> 2 * m * log 2 N + m + log 2 m\""], ["proof (prove)\nusing this:\n  log 2 (real_of_int \\<bar>number\\<bar>)\n  \\<le> real (2 * m) * log 2 (real N) + log 2 (2 ^ m) + log 2 (real m)\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)", "by simp"], ["proof (state)\nthis:\n  log 2 (real_of_int \\<bar>number\\<bar>)\n  \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "also"], ["proof (state)\nthis:\n  log 2 (real_of_int \\<bar>number\\<bar>)\n  \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "have \"\\<dots> \\<le> 2 * m * (2 * log 2 (M * n)) + m + log 2 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n    \\<le> real (2 * m) * (2 * log 2 (real_of_int (M * int n))) + real m +\n          log 2 (real m)", "by (intro add_right_mono mult_mono logN_le_2log_Mn N, insert i j N, auto)"], ["proof (state)\nthis:\n  real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n  \\<le> real (2 * m) * (2 * log 2 (real_of_int (M * int n))) + real m +\n        log 2 (real m)\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "finally"], ["proof (chain)\npicking this:\n  log 2 (real_of_int \\<bar>number\\<bar>)\n  \\<le> real (2 * m) * (2 * log 2 (real_of_int (M * int n))) + real m +\n        log 2 (real m)", "show \"log 2 \\<bar>number\\<bar> \\<le> 4 * m * log 2 (M * n) + m + log 2 m\""], ["proof (prove)\nusing this:\n  log 2 (real_of_int \\<bar>number\\<bar>)\n  \\<le> real (2 * m) * (2 * log 2 (real_of_int (M * int n))) + real m +\n        log 2 (real m)\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int \\<bar>number\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "by simp"], ["proof (state)\nthis:\n  log 2 (real_of_int \\<bar>number\\<bar>)\n  \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n        log 2 (real m)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>And a combined size bound for an integer implementation which stores values \n  $f_i$, $d_{j+1}\\mu_{ij}$ and $d_i$.\\<close>"], ["", "interpretation fs: fs_int_indpt n fs_init"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int_indpt n fs_init", "by (standard) (use lin_dep in auto)"], ["", "lemma fs_gs_N_N': assumes \"m \\<noteq> 0\"\n  shows \"fs.gs.N = of_nat N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "have 0: \"Max (sq_norm ` set fs_init)  \\<in>  sq_norm ` set fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (sq_norm ` set fs_init) \\<in> sq_norm ` set fs_init", "using len assms"], ["proof (prove)\nusing this:\n  length fs_init = m\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Max (sq_norm ` set fs_init) \\<in> sq_norm ` set fs_init", "by auto"], ["proof (state)\nthis:\n  Max (sq_norm ` set fs_init) \\<in> sq_norm ` set fs_init\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "then"], ["proof (chain)\npicking this:\n  Max (sq_norm ` set fs_init) \\<in> sq_norm ` set fs_init", "have 1: \" nat (Max (sq_norm ` set fs_init)) \\<in> (nat \\<circ> sq_norm) ` set fs_init\""], ["proof (prove)\nusing this:\n  Max (sq_norm ` set fs_init) \\<in> sq_norm ` set fs_init\n\ngoal (1 subgoal):\n 1. nat (Max (sq_norm ` set fs_init))\n    \\<in> (nat \\<circ> sq_norm) ` set fs_init", "by (auto)"], ["proof (state)\nthis:\n  nat (Max (sq_norm ` set fs_init))\n  \\<in> (nat \\<circ> sq_norm) ` set fs_init\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "have [simp]: \"0 \\<le> Max (sq_norm ` set fs_init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Max (sq_norm ` set fs_init)", "using 0"], ["proof (prove)\nusing this:\n  Max (sq_norm ` set fs_init) \\<in> sq_norm ` set fs_init\n\ngoal (1 subgoal):\n 1. 0 \\<le> Max (sq_norm ` set fs_init)", "by force"], ["proof (state)\nthis:\n  0 \\<le> Max (sq_norm ` set fs_init)\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "have [simp]: \"sq_norm ` of_int_hom.vec_hom ` set fs_init = rat_of_int ` sq_norm ` set fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sq_norm ` of_int_hom.vec_hom ` set fs_init =\n    rat_of_int ` sq_norm ` set fs_init", "by (auto simp add: sq_norm_of_int image_iff)"], ["proof (state)\nthis:\n  sq_norm ` of_int_hom.vec_hom ` set fs_init =\n  rat_of_int ` sq_norm ` set fs_init\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "then"], ["proof (chain)\npicking this:\n  sq_norm ` of_int_hom.vec_hom ` set fs_init =\n  rat_of_int ` sq_norm ` set fs_init", "have [simp]: \"rat_of_int (Max (sq_norm ` set fs_init)) \\<in> rat_of_int ` sq_norm ` set fs_init\""], ["proof (prove)\nusing this:\n  sq_norm ` of_int_hom.vec_hom ` set fs_init =\n  rat_of_int ` sq_norm ` set fs_init\n\ngoal (1 subgoal):\n 1. rat_of_int (Max (sq_norm ` set fs_init))\n    \\<in> rat_of_int ` sq_norm ` set fs_init", "using 0"], ["proof (prove)\nusing this:\n  sq_norm ` of_int_hom.vec_hom ` set fs_init =\n  rat_of_int ` sq_norm ` set fs_init\n  Max (sq_norm ` set fs_init) \\<in> sq_norm ` set fs_init\n\ngoal (1 subgoal):\n 1. rat_of_int (Max (sq_norm ` set fs_init))\n    \\<in> rat_of_int ` sq_norm ` set fs_init", "by auto"], ["proof (state)\nthis:\n  rat_of_int (Max (sq_norm ` set fs_init))\n  \\<in> rat_of_int ` sq_norm ` set fs_init\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "have \"(Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init)) = Max ((nat \\<circ> sq_norm) ` set fs_init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init) =\n    Max ((nat \\<circ> sq_norm) ` set fs_init)", "using assms len"], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init) =\n    Max ((nat \\<circ> sq_norm) ` set fs_init)", "by (subst max_list_Max) (auto)"], ["proof (state)\nthis:\n  Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init) =\n  Max ((nat \\<circ> sq_norm) ` set fs_init)\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "also"], ["proof (state)\nthis:\n  Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init) =\n  Max ((nat \\<circ> sq_norm) ` set fs_init)\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "have \"\\<dots> = nat (Max (sq_norm_vec ` set fs_init))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max ((nat \\<circ> sq_norm) ` set fs_init) =\n    nat (Max (sq_norm ` set fs_init))", "using assms 1"], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n  nat (Max (sq_norm ` set fs_init))\n  \\<in> (nat \\<circ> sq_norm) ` set fs_init\n\ngoal (1 subgoal):\n 1. Max ((nat \\<circ> sq_norm) ` set fs_init) =\n    nat (Max (sq_norm ` set fs_init))", "by (auto intro!: nat_mono Max_eqI)"], ["proof (state)\nthis:\n  Max ((nat \\<circ> sq_norm) ` set fs_init) =\n  nat (Max (sq_norm ` set fs_init))\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "also"], ["proof (state)\nthis:\n  Max ((nat \\<circ> sq_norm) ` set fs_init) =\n  nat (Max (sq_norm ` set fs_init))\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "have \"int \\<dots> = Max (sq_norm_vec ` set fs_init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat (Max (sq_norm ` set fs_init))) = Max (sq_norm ` set fs_init)", "by (subst int_nat_eq) (auto)"], ["proof (state)\nthis:\n  int (nat (Max (sq_norm ` set fs_init))) = Max (sq_norm ` set fs_init)\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "also"], ["proof (state)\nthis:\n  int (nat (Max (sq_norm ` set fs_init))) = Max (sq_norm ` set fs_init)\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "have \"rat_of_int \\<dots> = Max (sq_norm ` set (map of_int_hom.vec_hom fs_init))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (Max (sq_norm ` set fs_init)) =\n    Max (sq_norm ` set (map of_int_hom.vec_hom fs_init))", "by (rule Max_eqI[symmetric]) (auto simp add: sq_norm_of_int)"], ["proof (state)\nthis:\n  rat_of_int (Max (sq_norm ` set fs_init)) =\n  Max (sq_norm ` set (map of_int_hom.vec_hom fs_init))\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "finally"], ["proof (chain)\npicking this:\n  rat_of_int\n   (int (Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init))) =\n  Max (sq_norm ` set (map of_int_hom.vec_hom fs_init))", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_of_int\n   (int (Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init))) =\n  Max (sq_norm ` set (map of_int_hom.vec_hom fs_init))\n\ngoal (1 subgoal):\n 1. fs.gs.N = rat_of_nat N", "unfolding N_def fs.gs.N_def"], ["proof (prove)\nusing this:\n  rat_of_int\n   (int (Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init))) =\n  Max (sq_norm ` set (map of_int_hom.vec_hom fs_init))\n\ngoal (1 subgoal):\n 1. Max (sq_norm ` set (map of_int_hom.vec_hom fs_init)) =\n    rat_of_nat (Missing_Lemmas.max_list (map (nat \\<circ> sq_norm) fs_init))", "by (auto)"], ["proof (state)\nthis:\n  fs.gs.N = rat_of_nat N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fs_gs_N_N: \"m \\<noteq> 0 \\<Longrightarrow> real_of_rat fs.gs.N = real N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> real_of_rat fs.gs.N = real N", "using fs_gs_N_N'"], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow> fs.gs.N = rat_of_nat N\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow> real_of_rat fs.gs.N = real N", "by simp"], ["", "lemma combined_size_bound_gso_integer:\n  assumes \"x \\<in> \n    {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union> \n    {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\"\n  and m: \"m \\<noteq> 0\" and \"x \\<noteq> 0\" \"n \\<noteq> 0\"\nshows \"log 2 \\<bar>real_of_int x\\<bar> \\<le> (6 + 6 * m) * log 2 (M * n) + log 2 m + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "from bound_invD[OF binv]"], ["proof (chain)\npicking this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs", "have inv: \"LLL_invariant upw k fs\"\n     and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw k fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "from LLL_inv_N_pos[OF invw gbnd m]"], ["proof (chain)\npicking this:\n  0 < N", "have N: \"N > 0\""], ["proof (prove)\nusing this:\n  0 < N\n\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "have \"log 2 \\<bar>real_of_int x\\<bar> \\<le> log 2 m + real (3 + 3 * m) * log 2 N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> log 2 (real m) + real (3 + 3 * m) * log 2 (real N)", "using assms len fs.combined_size_bound_integer_log"], ["proof (prove)\nusing this:\n  x \\<in> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n          {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\n  m \\<noteq> 0\n  x \\<noteq> 0\n  n \\<noteq> 0\n  length fs_init = m\n  \\<lbrakk>?x \\<in> {fs.\\<mu>' i j |i j.\n                     j \\<le> i \\<and> i < length fs_init} \\<union>\n                    {fs.\\<sigma>s l i j |i j l.\n                     i < length fs_init \\<and> j \\<le> i \\<and> l < j};\n   length fs_init \\<noteq> 0; ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> log 2 \\<bar>real_of_int ?x\\<bar>\n                    \\<le> log 2 (real (length fs_init)) +\n                          real (3 + 3 * length fs_init) *\n                          log 2 (real_of_rat fs.gs.N)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> log 2 (real m) + real (3 + 3 * m) * log 2 (real N)", "by (auto simp add: fs_gs_N_N)"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> log 2 (real m) + real (3 + 3 * m) * log 2 (real N)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "also"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> log 2 (real m) + real (3 + 3 * m) * log 2 (real N)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "have \"\\<dots> \\<le> log 2 m + (3 + 3 * m) * (2 * log 2 (M * n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real m) + real (3 + 3 * m) * log 2 (real N)\n    \\<le> log 2 (real m) +\n          real (3 + 3 * m) * (2 * log 2 (real_of_int (M * int n)))", "using logN_le_2log_Mn assms N"], ["proof (prove)\nusing this:\n  \\<lbrakk>m \\<noteq> 0; n \\<noteq> 0; 0 < N\\<rbrakk>\n  \\<Longrightarrow> log 2 (real N) \\<le> 2 * log 2 (real_of_int (M * int n))\n  x \\<in> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n          {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\n  m \\<noteq> 0\n  x \\<noteq> 0\n  n \\<noteq> 0\n  0 < N\n\ngoal (1 subgoal):\n 1. log 2 (real m) + real (3 + 3 * m) * log 2 (real N)\n    \\<le> log 2 (real m) +\n          real (3 + 3 * m) * (2 * log 2 (real_of_int (M * int n)))", "by (intro add_left_mono, intro mult_left_mono) (auto)"], ["proof (state)\nthis:\n  log 2 (real m) + real (3 + 3 * m) * log 2 (real N)\n  \\<le> log 2 (real m) +\n        real (3 + 3 * m) * (2 * log 2 (real_of_int (M * int n)))\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "also"], ["proof (state)\nthis:\n  log 2 (real m) + real (3 + 3 * m) * log 2 (real N)\n  \\<le> log 2 (real m) +\n        real (3 + 3 * m) * (2 * log 2 (real_of_int (M * int n)))\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "have \"\\<dots> = log 2 m + (6 + 6 * m) * log 2 (M * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real m) +\n    real (3 + 3 * m) * (2 * log 2 (real_of_int (M * int n))) =\n    log 2 (real m) + real (6 + 6 * m) * log 2 (real_of_int (M * int n))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  log 2 (real m) +\n  real (3 + 3 * m) * (2 * log 2 (real_of_int (M * int n))) =\n  log 2 (real m) + real (6 + 6 * m) * log 2 (real_of_int (M * int n))\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "finally"], ["proof (chain)\npicking this:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> log 2 (real m) + real (6 + 6 * m) * log 2 (real_of_int (M * int n))", "show ?thesis"], ["proof (prove)\nusing this:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> log 2 (real m) + real (6 + 6 * m) * log 2 (real_of_int (M * int n))\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "by auto"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n        log 2 (real m) +\n        real m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma combined_size_bound_integer':  \n  assumes x: \"x \\<in> {fs ! i $ j | i j. i < m \\<and> j < n} \n    \\<union> {d\\<mu> fs i j | i j. j < i \\<and> i < m} \n    \\<union> {d fs i | i. i \\<le> m}\" \n    (is \"x \\<in> ?fs \\<union> ?d\\<mu> \\<union> ?d\")\n  and m: \"m \\<noteq> 0\" and n: \"n \\<noteq> 0\" \nshows \"abs x \\<le> N ^ (2 * m) * 2 ^ m * m\"\n  \"x \\<noteq> 0 \\<Longrightarrow> log 2 \\<bar>x\\<bar> \\<le> 2 * m * log 2 N       + m + log 2 m\" (is \"_ \\<Longrightarrow> ?l1 \\<le> ?b1\")\n  \"x \\<noteq> 0 \\<Longrightarrow> log 2 \\<bar>x\\<bar> \\<le> 4 * m * log 2 (M * n) + m + log 2 m\" (is \"_ \\<Longrightarrow> _ \\<le> ?b2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m) &&&\n    (x \\<noteq> 0 \\<Longrightarrow>\n     log 2 \\<bar>real_of_int x\\<bar>\n     \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)) &&&\n    (x \\<noteq> 0 \\<Longrightarrow>\n     log 2 \\<bar>real_of_int x\\<bar>\n     \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n           log 2 (real m))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 3. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "let ?bnd = \"int N ^ (2 * m) * 2 ^ m * int m\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 3. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "from bound_invD[OF binv]"], ["proof (chain)\npicking this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs", "have inv: \"LLL_invariant upw k fs\"\n     and fbnd: \"f_bound outside k fs\" \n     and gbnd: \"g_bound fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (1 subgoal):\n 1. LLL_invariant upw k fs &&& f_bound outside k fs &&& g_bound fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw k fs\n  f_bound outside k fs\n  g_bound fs\n\ngoal (3 subgoals):\n 1. \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 3. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (3 subgoals):\n 1. \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 3. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "from LLL_inv_N_pos[OF invw gbnd m]"], ["proof (chain)\npicking this:\n  0 < N", "have N: \"N > 0\""], ["proof (prove)\nusing this:\n  0 < N\n\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (3 subgoals):\n 1. \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 3. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "let ?r = real_of_int"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 3. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "from x"], ["proof (chain)\npicking this:\n  x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<union>\n          {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<union>\n          {d fs i |i. i \\<le> m}", "consider (fs) \"x \\<in> ?fs\" | (d\\<mu>) \"x \\<in> ?d\\<mu>\" | (d) \"x \\<in> ?d\""], ["proof (prove)\nusing this:\n  x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<union>\n          {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<union>\n          {d fs i |i. i \\<le> m}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<Longrightarrow>\n             thesis;\n     x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n     thesis;\n     x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<Longrightarrow>\n           ?thesis1;\n   x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n   ?thesis1;\n   x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (3 subgoals):\n 1. \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 3. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "hence \"abs x \\<le> ?bnd\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<Longrightarrow>\n           ?thesis1;\n   x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n   ?thesis1;\n   x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 3. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "case fs"], ["proof (state)\nthis:\n  x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n}\n\ngoal (3 subgoals):\n 1. x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 3. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "then"], ["proof (chain)\npicking this:\n  x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n}", "obtain i j where i: \"i < m\" and j: \"j < n\" and x: \"x = fs ! i $ j\""], ["proof (prove)\nusing this:\n  x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n}\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < m; j < n; x = fs ! i $ j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < m\n  j < n\n  x = fs ! i $ j\n\ngoal (3 subgoals):\n 1. x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 3. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "from LLL_f_bound[OF i j, folded x]"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)", "have \"\\<bar>x\\<bar> \\<le> int N ^ m * 2 ^ (m - 1) * int m\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> int (N ^ m * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> int N ^ m * 2 ^ (m - 1) * int m", "by simp"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> int N ^ m * 2 ^ (m - 1) * int m\n\ngoal (3 subgoals):\n 1. x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 3. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "also"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> int N ^ m * 2 ^ (m - 1) * int m\n\ngoal (3 subgoals):\n 1. x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 3. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "have \"\\<dots> \\<le> ?bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int N ^ m * 2 ^ (m - 1) * int m \\<le> int N ^ (2 * m) * 2 ^ m * int m", "by (intro mult_mono pow_mono_exp, insert N, auto)"], ["proof (state)\nthis:\n  int N ^ m * 2 ^ (m - 1) * int m \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (3 subgoals):\n 1. x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 3. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "finally"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "."], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (2 subgoals):\n 1. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "case d\\<mu>"], ["proof (state)\nthis:\n  x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m}\n\ngoal (2 subgoals):\n 1. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "then"], ["proof (chain)\npicking this:\n  x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m}", "obtain i j where i: \"i < m\" and j: \"j < i\" and x: \"x = d\\<mu> fs i j\""], ["proof (prove)\nusing this:\n  x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m}\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < m; j < i; x = d\\<mu> fs i j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < m\n  j < i\n  x = d\\<mu> fs i j\n\ngoal (2 subgoals):\n 1. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "from LLL_d\\<mu>_bound[OF i j, folded x]"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)", "have \"\\<bar>x\\<bar> \\<le> int N ^ (2 * (m - 1)) * 2 ^ (m - 1) * int m\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> int (N ^ (2 * (m - 1)) * 2 ^ (m - 1) * m)\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> int N ^ (2 * (m - 1)) * 2 ^ (m - 1) * int m", "by simp"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * (m - 1)) * 2 ^ (m - 1) * int m\n\ngoal (2 subgoals):\n 1. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "also"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * (m - 1)) * 2 ^ (m - 1) * int m\n\ngoal (2 subgoals):\n 1. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "have \"\\<dots> \\<le> ?bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int N ^ (2 * (m - 1)) * 2 ^ (m - 1) * int m\n    \\<le> int N ^ (2 * m) * 2 ^ m * int m", "by (intro mult_mono pow_mono_exp, insert N, auto)"], ["proof (state)\nthis:\n  int N ^ (2 * (m - 1)) * 2 ^ (m - 1) * int m\n  \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (2 subgoals):\n 1. x \\<in> {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n 2. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "finally"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "."], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (1 subgoal):\n 1. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "case d"], ["proof (state)\nthis:\n  x \\<in> {d fs i |i. i \\<le> m}\n\ngoal (1 subgoal):\n 1. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "then"], ["proof (chain)\npicking this:\n  x \\<in> {d fs i |i. i \\<le> m}", "obtain i where i: \"i \\<le> m\" and x: \"x = d fs i\""], ["proof (prove)\nusing this:\n  x \\<in> {d fs i |i. i \\<le> m}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<le> m; x = d fs i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<le> m\n  x = d fs i\n\ngoal (1 subgoal):\n 1. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "from LLL_d_bound[OF i, folded x]"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> \\<le> int (N ^ i) \\<and> \\<bar>x\\<bar> \\<le> int (N ^ m)", "have \"\\<bar>x\\<bar> \\<le> int N ^ m * 2 ^ 0 * 1\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> int (N ^ i) \\<and> \\<bar>x\\<bar> \\<le> int (N ^ m)\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> int N ^ m * 2 ^ 0 * 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> int N ^ m * 2 ^ 0 * 1\n\ngoal (1 subgoal):\n 1. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "also"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> int N ^ m * 2 ^ 0 * 1\n\ngoal (1 subgoal):\n 1. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "have \"\\<dots> \\<le> ?bnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int N ^ m * 2 ^ 0 * 1 \\<le> int N ^ (2 * m) * 2 ^ m * int m", "by (intro mult_mono pow_mono_exp, insert N m, auto)"], ["proof (state)\nthis:\n  int N ^ m * 2 ^ 0 * 1 \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (1 subgoal):\n 1. x \\<in> {d fs i |i. i \\<le> m} \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "finally"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m", "."], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (3 subgoals):\n 1. \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 3. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "thus \"abs x \\<le> N ^ (2 * m) * 2 ^ m * m\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> int N ^ (2 * m) * 2 ^ m * int m\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)", "by simp"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (2 subgoals):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "hence abs: \"?r (abs x) \\<le> ?r (N ^ (2 * m) * 2 ^ m * m)\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> int (N ^ (2 * m) * 2 ^ m * m)\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>x\\<bar>\n    \\<le> real_of_int (int (N ^ (2 * m) * 2 ^ m * m))", "by linarith"], ["proof (state)\nthis:\n  real_of_int \\<bar>x\\<bar>\n  \\<le> real_of_int (int (N ^ (2 * m) * 2 ^ m * m))\n\ngoal (2 subgoals):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "assume \"x \\<noteq> 0\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "hence x: \"abs x > 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < \\<bar>x\\<bar>", "by auto"], ["proof (state)\nthis:\n  0 < \\<bar>x\\<bar>\n\ngoal (2 subgoals):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "from abs"], ["proof (chain)\npicking this:\n  real_of_int \\<bar>x\\<bar>\n  \\<le> real_of_int (int (N ^ (2 * m) * 2 ^ m * m))", "have \"log 2 (abs x) \\<le> log 2 (?r (N ^ (2 * m)) * 2 ^ m * ?r m)\""], ["proof (prove)\nusing this:\n  real_of_int \\<bar>x\\<bar>\n  \\<le> real_of_int (int (N ^ (2 * m) * 2 ^ m * m))\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int \\<bar>x\\<bar>)\n    \\<le> log 2\n           (real_of_int (int (N ^ (2 * m))) * 2 ^ m * real_of_int (int m))", "by (subst log_le_cancel_iff, insert x N m, auto)"], ["proof (state)\nthis:\n  log 2 (real_of_int \\<bar>x\\<bar>)\n  \\<le> log 2\n         (real_of_int (int (N ^ (2 * m))) * 2 ^ m * real_of_int (int m))\n\ngoal (2 subgoals):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "also"], ["proof (state)\nthis:\n  log 2 (real_of_int \\<bar>x\\<bar>)\n  \\<le> log 2\n         (real_of_int (int (N ^ (2 * m))) * 2 ^ m * real_of_int (int m))\n\ngoal (2 subgoals):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "have \"\\<dots> = log 2 (?r N ^ (2 * m)) + m + log 2 (?r m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real_of_int (int (N ^ (2 * m))) * 2 ^ m * real_of_int (int m)) =\n    log 2 (real_of_int (int N) ^ (2 * m)) + real m +\n    log 2 (real_of_int (int m))", "using N m"], ["proof (prove)\nusing this:\n  0 < N\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int (int (N ^ (2 * m))) * 2 ^ m * real_of_int (int m)) =\n    log 2 (real_of_int (int N) ^ (2 * m)) + real m +\n    log 2 (real_of_int (int m))", "by (auto simp: log_mult)"], ["proof (state)\nthis:\n  log 2 (real_of_int (int (N ^ (2 * m))) * 2 ^ m * real_of_int (int m)) =\n  log 2 (real_of_int (int N) ^ (2 * m)) + real m +\n  log 2 (real_of_int (int m))\n\ngoal (2 subgoals):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "also"], ["proof (state)\nthis:\n  log 2 (real_of_int (int (N ^ (2 * m))) * 2 ^ m * real_of_int (int m)) =\n  log 2 (real_of_int (int N) ^ (2 * m)) + real m +\n  log 2 (real_of_int (int m))\n\ngoal (2 subgoals):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "have \"log 2 (?r N ^ (2 * m)) = real (2 * m) * log 2 (?r N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real_of_int (int N) ^ (2 * m)) =\n    real (2 * m) * log 2 (real_of_int (int N))", "by (subst log_nat_power, insert N, auto)"], ["proof (state)\nthis:\n  log 2 (real_of_int (int N) ^ (2 * m)) =\n  real (2 * m) * log 2 (real_of_int (int N))\n\ngoal (2 subgoals):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "finally"], ["proof (chain)\npicking this:\n  log 2 (real_of_int \\<bar>x\\<bar>)\n  \\<le> real (2 * m) * log 2 (real_of_int (int N)) + real m +\n        log 2 (real_of_int (int m))", "show \"?l1 \\<le> ?b1\""], ["proof (prove)\nusing this:\n  log 2 (real_of_int \\<bar>x\\<bar>)\n  \\<le> real (2 * m) * log 2 (real_of_int (int N)) + real m +\n        log 2 (real_of_int (int m))\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)", "by simp"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "also"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "have \"\\<dots> \\<le> 2 * m * (2 * log 2 (M * n)) + m + log 2 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n    \\<le> real (2 * m) * (2 * log 2 (real_of_int (M * int n))) + real m +\n          log 2 (real m)", "by (intro add_right_mono mult_left_mono logN_le_2log_Mn, insert m n N, auto)"], ["proof (state)\nthis:\n  real (2 * m) * log 2 (real N) + real m + log 2 (real m)\n  \\<le> real (2 * m) * (2 * log 2 (real_of_int (M * int n))) + real m +\n        log 2 (real m)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "finally"], ["proof (chain)\npicking this:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> real (2 * m) * (2 * log 2 (real_of_int (M * int n))) + real m +\n        log 2 (real m)", "show \"?l1 \\<le> ?b2\""], ["proof (prove)\nusing this:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> real (2 * m) * (2 * log 2 (real_of_int (M * int n))) + real m +\n        log 2 (real m)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "by simp"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n        log 2 (real m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma combined_size_bound_integer:  \n  assumes x: \"x \\<in> \n      {fs ! i $ j | i j. i < m \\<and> j < n} \n    \\<union> {d\\<mu> fs i j | i j. j < i \\<and> i < m} \n    \\<union> {d fs i | i. i \\<le> m}\n    \\<union> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m}\n    \\<union> {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\"\n    (is \"?x \\<in> ?s1 \\<union> ?s2 \\<union> ?s3 \\<union> ?g1 \\<union> ?g2\")\n  and m: \"m \\<noteq> 0\" and n: \"n \\<noteq> 0\" and \"x \\<noteq> 0\" and \"0 < M\"\nshows \"log 2 \\<bar>x\\<bar> \\<le> (6 + 6 * m) * log 2 (M * n) + log 2 m + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "proof (cases \"?x \\<in> ?g1 \\<union> ?g2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n            {fs.\\<sigma>s l i j |i j l.\n             i < m \\<and> j \\<le> i \\<and> l < j} \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m\n 2. x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n               {fs.\\<sigma>s l i j |i j l.\n                i < m \\<and> j \\<le> i \\<and> l < j} \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "case True"], ["proof (state)\nthis:\n  x \\<in> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n          {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\n\ngoal (2 subgoals):\n 1. x \\<in> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n            {fs.\\<sigma>s l i j |i j l.\n             i < m \\<and> j \\<le> i \\<and> l < j} \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m\n 2. x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n               {fs.\\<sigma>s l i j |i j l.\n                i < m \\<and> j \\<le> i \\<and> l < j} \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "then"], ["proof (chain)\npicking this:\n  x \\<in> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n          {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n          {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "using combined_size_bound_gso_integer assms"], ["proof (prove)\nusing this:\n  x \\<in> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n          {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\n  \\<lbrakk>?x \\<in> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n                    {fs.\\<sigma>s l i j |i j l.\n                     i < m \\<and> j \\<le> i \\<and> l < j};\n   m \\<noteq> 0; ?x \\<noteq> 0; n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> log 2 \\<bar>real_of_int ?x\\<bar>\n                    \\<le> real (6 + 6 * m) *\n                          log 2 (real_of_int (M * int n)) +\n                          log 2 (real m) +\n                          real m\n  x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<union>\n          {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<union>\n          {d fs i |i. i \\<le> m} \\<union>\n          {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n          {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\n  m \\<noteq> 0\n  n \\<noteq> 0\n  x \\<noteq> 0\n  0 < M\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "by simp"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n        log 2 (real m) +\n        real m\n\ngoal (1 subgoal):\n 1. x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n               {fs.\\<sigma>s l i j |i j l.\n                i < m \\<and> j \\<le> i \\<and> l < j} \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n               {fs.\\<sigma>s l i j |i j l.\n                i < m \\<and> j \\<le> i \\<and> l < j} \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "case False"], ["proof (state)\nthis:\n  x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n             {fs.\\<sigma>s l i j |i j l.\n              i < m \\<and> j \\<le> i \\<and> l < j}\n\ngoal (1 subgoal):\n 1. x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n               {fs.\\<sigma>s l i j |i j l.\n                i < m \\<and> j \\<le> i \\<and> l < j} \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "then"], ["proof (chain)\npicking this:\n  x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n             {fs.\\<sigma>s l i j |i j l.\n              i < m \\<and> j \\<le> i \\<and> l < j}", "have x: \"x \\<in> ?s1 \\<union> ?s2 \\<union> ?s3\""], ["proof (prove)\nusing this:\n  x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n             {fs.\\<sigma>s l i j |i j l.\n              i < m \\<and> j \\<le> i \\<and> l < j}\n\ngoal (1 subgoal):\n 1. x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<union>\n            {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<union>\n            {d fs i |i. i \\<le> m}", "using x"], ["proof (prove)\nusing this:\n  x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n             {fs.\\<sigma>s l i j |i j l.\n              i < m \\<and> j \\<le> i \\<and> l < j}\n  x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<union>\n          {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<union>\n          {d fs i |i. i \\<le> m} \\<union>\n          {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n          {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\n\ngoal (1 subgoal):\n 1. x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<union>\n            {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<union>\n            {d fs i |i. i \\<le> m}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<union>\n          {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<union>\n          {d fs i |i. i \\<le> m}\n\ngoal (1 subgoal):\n 1. x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n               {fs.\\<sigma>s l i j |i j l.\n                i < m \\<and> j \\<le> i \\<and> l < j} \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "from combined_size_bound_integer'(3)[OF this m n \\<open>x \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n        log 2 (real m)", "have \"log 2 \\<bar>x\\<bar> \\<le> 4 * m * log 2 (M * n) + m + log 2 m\""], ["proof (prove)\nusing this:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n        log 2 (real m)\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int \\<bar>x\\<bar>)\n    \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "by simp"], ["proof (state)\nthis:\n  log 2 (real_of_int \\<bar>x\\<bar>)\n  \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n        log 2 (real m)\n\ngoal (1 subgoal):\n 1. x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n               {fs.\\<sigma>s l i j |i j l.\n                i < m \\<and> j \\<le> i \\<and> l < j} \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "also"], ["proof (state)\nthis:\n  log 2 (real_of_int \\<bar>x\\<bar>)\n  \\<le> real (4 * m) * log 2 (real_of_int (M * int n)) + real m +\n        log 2 (real m)\n\ngoal (1 subgoal):\n 1. x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n               {fs.\\<sigma>s l i j |i j l.\n                i < m \\<and> j \\<le> i \\<and> l < j} \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "have \"\\<dots> \\<le> (6 + 6 * m) * log 2 (M * n) + m + log 2 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (4 * m) * log 2 (real_of_int (M * int n)) + real m + log 2 (real m)\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> {fs ! i $ j |i j. i < m \\<and> j < n} \\<union>\n          {d\\<mu> fs i j |i j. j < i \\<and> i < m} \\<union>\n          {d fs i |i. i \\<le> m} \\<union>\n          {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n          {fs.\\<sigma>s l i j |i j l. i < m \\<and> j \\<le> i \\<and> l < j}\n  m \\<noteq> 0\n  n \\<noteq> 0\n  x \\<noteq> 0\n  0 < M\n\ngoal (1 subgoal):\n 1. real (4 * m) * log 2 (real_of_int (M * int n)) + real m + log 2 (real m)\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) + real m +\n          log 2 (real m)", "by (intro add_right_mono, intro mult_right_mono) auto"], ["proof (state)\nthis:\n  real (4 * m) * log 2 (real_of_int (M * int n)) + real m + log 2 (real m)\n  \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) + real m +\n        log 2 (real m)\n\ngoal (1 subgoal):\n 1. x \\<notin> {fs.\\<mu>' i j |i j. j \\<le> i \\<and> i < m} \\<union>\n               {fs.\\<sigma>s l i j |i j l.\n                i < m \\<and> j \\<le> i \\<and> l < j} \\<Longrightarrow>\n    log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "finally"], ["proof (chain)\npicking this:\n  log 2 (real_of_int \\<bar>x\\<bar>)\n  \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) + real m +\n        log 2 (real m)", "show ?thesis"], ["proof (prove)\nusing this:\n  log 2 (real_of_int \\<bar>x\\<bar>)\n  \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) + real m +\n        log 2 (real m)\n\ngoal (1 subgoal):\n 1. log 2 \\<bar>real_of_int x\\<bar>\n    \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n          log 2 (real m) +\n          real m", "by simp"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n        log 2 (real m) +\n        real m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  log 2 \\<bar>real_of_int x\\<bar>\n  \\<le> real (6 + 6 * m) * log 2 (real_of_int (M * int n)) +\n        log 2 (real m) +\n        real m\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* LLL_bound_invariant *)"], ["", "end"], ["", "(* LLL locale *)"], ["", "end"]]}