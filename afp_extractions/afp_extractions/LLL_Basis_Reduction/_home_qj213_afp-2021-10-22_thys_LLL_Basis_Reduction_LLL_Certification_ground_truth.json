{"file_name": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction/LLL_Certification.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction", "problem_names": ["lemma mat_mult_sub_lattice: assumes fs: \"set fs \\<subseteq> carrier_vec n\" \n  and gs: \"set gs \\<subseteq> carrier_vec n\" \n  and A: \"A \\<in> carrier_mat (length fs) (length gs)\" \n  and prod: \"mat_of_rows n fs = map_mat of_int A * mat_of_rows n gs\" \n  shows \"lattice_of fs \\<subseteq> lattice_of gs\"", "lemma mult_left_identity:\n  defines \"B \\<equiv> (map_mat rat_of_int (mat_of_rows n fs_init))\"\n  assumes P_carrier[simp]: \"P \\<in> carrier_mat m m\" \n  and PB: \"P * B = B\"  \nshows \"P = 1\\<^sub>m m\"", "lemma LLL_change_basis: assumes gs: \"set gs \\<subseteq> carrier_vec n\" \n  and len': \"length gs = m\" \n  and U1: \"U1 \\<in> carrier_mat m m\" \n  and U2: \"U2 \\<in> carrier_mat m m\" \n  and prod1: \"mat_of_rows n fs_init = U1 * mat_of_rows n gs\" \n  and prod2: \"mat_of_rows n gs = U2 * mat_of_rows n fs_init\" \nshows \"lattice_of gs = lattice_of fs_init\" \"LLL_with_assms n m gs \\<alpha>\"", "lemma gauss_jordan_integer_inverse: fixes fs gs :: \"int vec list\" \n  assumes gs: \"set gs \\<subseteq> carrier_vec n\"\n  and len_gs: \"length gs = n\" \n  and fs: \"set fs \\<subseteq> carrier_vec n\" \n  and len_fs: \"length fs = n\" \n  and gauss: \"gauss_jordan_integer_inverse n (map_mat rat_of_int (mat_of_cols n fs)) \n    (map_mat rat_of_int (mat_of_cols n gs)) (1\\<^sub>m n)\" (is \"gauss_jordan_integer_inverse _ ?fs ?gs _\")\nshows \"\\<exists> U. U \\<in> carrier_mat n n \\<and> mat_of_rows n gs = U * mat_of_rows n fs\"", "lemma LLL_change_basis_mat_inverse: assumes gs: \"set gs \\<subseteq> carrier_vec n\" \n  and len': \"length gs = n\" \n  and \"m = n\" \n  and eq: \"integer_equivalent n fs_init gs\" \nshows \"lattice_of gs = lattice_of fs_init\" \"LLL_with_assms n m gs \\<alpha>\"", "lemma reduce_basis_external: assumes res: \"reduce_basis_external \\<alpha> fs_init = fs\" \n  shows \"reduced fs m\" \"LLL_invariant True m fs\"", "lemma short_vector_external: assumes res: \"short_vector_external \\<alpha> fs_init = v\"\n  and m0: \"m \\<noteq> 0\"\nshows \"v \\<in> carrier_vec n\"\n  \"v \\<in> L - {0\\<^sub>v n}\"\n  \"h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow> rat_of_int (sq_norm v) \\<le> \\<alpha> ^ (m - 1) * rat_of_int (sq_norm h)\"\n  \"v \\<noteq> 0\\<^sub>v j\"", "lemma short_vector_hybrid: assumes res: \"short_vector_hybrid \\<alpha> fs_init = v\"\n  and m0: \"m \\<noteq> 0\"\nshows \"v \\<in> carrier_vec n\"\n  \"v \\<in> L - {0\\<^sub>v n}\"\n  \"h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow> rat_of_int (sq_norm v) \\<le> \\<alpha> ^ (m - 1) * rat_of_int (sq_norm h)\"\n  \"v \\<noteq> 0\\<^sub>v j\"", "lemma reduce_basis_hybrid: assumes res: \"reduce_basis_hybrid \\<alpha> fs_init = fs\" \n  shows \"reduced fs m\" \"LLL_invariant True m fs\"", "lemma lll_oracle_default_code[code]: \n  \"external_lll_solver x = Code.abort (STR ''no implementation of external_lll_solver specified'') (\\<lambda> _. external_lll_solver x)\""], "translations": [["", "lemma mat_mult_sub_lattice: assumes fs: \"set fs \\<subseteq> carrier_vec n\" \n  and gs: \"set gs \\<subseteq> carrier_vec n\" \n  and A: \"A \\<in> carrier_mat (length fs) (length gs)\" \n  and prod: \"mat_of_rows n fs = map_mat of_int A * mat_of_rows n gs\" \n  shows \"lattice_of fs \\<subseteq> lattice_of gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of fs \\<subseteq> lattice_of gs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "let ?m = \"length fs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "let ?m' = \"length gs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "let ?i = \"of_int :: int \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "let ?I = \"map_mat ?i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "let ?A = \"?I A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have gsC: \"mat_of_rows n gs \\<in> carrier_mat ?m' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n gs \\<in> carrier_mat (length gs) n", "by auto"], ["proof (state)\nthis:\n  mat_of_rows n gs \\<in> carrier_mat (length gs) n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat (length fs) (length gs)", "have A: \"?A \\<in> carrier_mat ?m ?m'\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat (length fs) (length gs)\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom A \\<in> carrier_mat (length fs) (length gs)", "by auto"], ["proof (state)\nthis:\n  of_int_hom.mat_hom A \\<in> carrier_mat (length fs) (length gs)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "from fs"], ["proof (chain)\npicking this:\n  set fs \\<subseteq> carrier_vec n", "have fsi[simp]: \"\\<And> i. i < ?m \\<Longrightarrow> fs ! i \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length fs \\<Longrightarrow> fs ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?i2 < length fs \\<Longrightarrow> fs ! ?i2 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "hence fsi'[simp]: \"\\<And> i. i < ?m \\<Longrightarrow> dim_vec (fs ! i) = n\""], ["proof (prove)\nusing this:\n  ?i2 < length fs \\<Longrightarrow> fs ! ?i2 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length fs \\<Longrightarrow> dim_vec (fs ! i) = n", "by simp"], ["proof (state)\nthis:\n  ?i2 < length fs \\<Longrightarrow> dim_vec (fs ! ?i2) = n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "from gs"], ["proof (chain)\npicking this:\n  set gs \\<subseteq> carrier_vec n", "have fsi[simp]: \"\\<And> i. i < ?m' \\<Longrightarrow> gs ! i \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length gs \\<Longrightarrow> gs ! i \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?i2 < length gs \\<Longrightarrow> gs ! ?i2 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "hence gsi'[simp]: \"\\<And> i. i < ?m' \\<Longrightarrow> dim_vec (gs ! i) = n\""], ["proof (prove)\nusing this:\n  ?i2 < length gs \\<Longrightarrow> gs ! ?i2 \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length gs \\<Longrightarrow> dim_vec (gs ! i) = n", "by simp"], ["proof (state)\nthis:\n  ?i2 < length gs \\<Longrightarrow> dim_vec (gs ! ?i2) = n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "assume \"v \\<in> lattice_of fs\""], ["proof (state)\nthis:\n  v \\<in> lattice_of fs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "from in_latticeE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>c.\n      v =\n      M.sumlist\n       (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n         [0..<length fs]) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain c where v: \"v = M.sumlist (map (\\<lambda>i. ?i (c i) \\<cdot>\\<^sub>v fs ! i) [0..<?m])\""], ["proof (prove)\nusing this:\n  (\\<And>c.\n      v =\n      M.sumlist\n       (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n         [0..<length fs]) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        v =\n        M.sumlist\n         (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n           [0..<length fs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "let ?c = \"vec ?m (\\<lambda> i. ?i (c i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "let ?d = \"A\\<^sup>T *\\<^sub>v vec ?m c\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "note v"], ["proof (state)\nthis:\n  v =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "also"], ["proof (state)\nthis:\n  v =\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs])\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have \"\\<dots> = mat_of_cols n fs *\\<^sub>v ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i)\n       [0..<length fs]) =\n    mat_of_cols n fs *\\<^sub>v vec (length fs) (\\<lambda>i. of_int (c i))", "by (rule eq_vecI, auto intro!: dim_sumlist sum.cong \n      simp: sumlist_nth scalar_prod_def mat_of_cols_def)"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs]) =\n  mat_of_cols n fs *\\<^sub>v vec (length fs) (\\<lambda>i. of_int (c i))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "also"], ["proof (state)\nthis:\n  M.sumlist\n   (map (\\<lambda>i. of_int (c i) \\<cdot>\\<^sub>v fs ! i) [0..<length fs]) =\n  mat_of_cols n fs *\\<^sub>v vec (length fs) (\\<lambda>i. of_int (c i))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have \"mat_of_cols n fs = (mat_of_rows n fs)\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n fs = (mat_of_rows n fs)\\<^sup>T", "by (simp add: transpose_mat_of_rows)"], ["proof (state)\nthis:\n  mat_of_cols n fs = (mat_of_rows n fs)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "also"], ["proof (state)\nthis:\n  mat_of_cols n fs = (mat_of_rows n fs)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have \"\\<dots> = (?A * mat_of_rows n gs)\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_of_rows n fs)\\<^sup>T =\n    (of_int_hom.mat_hom A * mat_of_rows n gs)\\<^sup>T", "unfolding prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_hom.mat_hom A * mat_of_rows n gs)\\<^sup>T =\n    (of_int_hom.mat_hom A * mat_of_rows n gs)\\<^sup>T", ".."], ["proof (state)\nthis:\n  (mat_of_rows n fs)\\<^sup>T =\n  (of_int_hom.mat_hom A * mat_of_rows n gs)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "also"], ["proof (state)\nthis:\n  (mat_of_rows n fs)\\<^sup>T =\n  (of_int_hom.mat_hom A * mat_of_rows n gs)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have \"\\<dots> = (mat_of_rows n gs)\\<^sup>T * ?A\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_hom.mat_hom A * mat_of_rows n gs)\\<^sup>T =\n    (mat_of_rows n gs)\\<^sup>T * (of_int_hom.mat_hom A)\\<^sup>T", "by (rule transpose_mult[OF A gsC])"], ["proof (state)\nthis:\n  (of_int_hom.mat_hom A * mat_of_rows n gs)\\<^sup>T =\n  (mat_of_rows n gs)\\<^sup>T * (of_int_hom.mat_hom A)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "also"], ["proof (state)\nthis:\n  (of_int_hom.mat_hom A * mat_of_rows n gs)\\<^sup>T =\n  (mat_of_rows n gs)\\<^sup>T * (of_int_hom.mat_hom A)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have \"(mat_of_rows n gs)\\<^sup>T = mat_of_cols n gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_of_rows n gs)\\<^sup>T = mat_of_cols n gs", "by (simp add: transpose_mat_of_rows)"], ["proof (state)\nthis:\n  (mat_of_rows n gs)\\<^sup>T = mat_of_cols n gs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "finally"], ["proof (chain)\npicking this:\n  v =\n  mat_of_cols n gs * (of_int_hom.mat_hom A)\\<^sup>T *\\<^sub>v\n  vec (length fs) (\\<lambda>i. of_int (c i))", "have \"v = (mat_of_cols n gs * ?A\\<^sup>T) *\\<^sub>v ?c\""], ["proof (prove)\nusing this:\n  v =\n  mat_of_cols n gs * (of_int_hom.mat_hom A)\\<^sup>T *\\<^sub>v\n  vec (length fs) (\\<lambda>i. of_int (c i))\n\ngoal (1 subgoal):\n 1. v =\n    mat_of_cols n gs * (of_int_hom.mat_hom A)\\<^sup>T *\\<^sub>v\n    vec (length fs) (\\<lambda>i. of_int (c i))", "."], ["proof (state)\nthis:\n  v =\n  mat_of_cols n gs * (of_int_hom.mat_hom A)\\<^sup>T *\\<^sub>v\n  vec (length fs) (\\<lambda>i. of_int (c i))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "also"], ["proof (state)\nthis:\n  v =\n  mat_of_cols n gs * (of_int_hom.mat_hom A)\\<^sup>T *\\<^sub>v\n  vec (length fs) (\\<lambda>i. of_int (c i))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have \"\\<dots> = mat_of_cols n gs *\\<^sub>v (?A\\<^sup>T *\\<^sub>v ?c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n gs * (of_int_hom.mat_hom A)\\<^sup>T *\\<^sub>v\n    vec (length fs) (\\<lambda>i. of_int (c i)) =\n    mat_of_cols n gs *\\<^sub>v\n    ((of_int_hom.mat_hom A)\\<^sup>T *\\<^sub>v\n     vec (length fs) (\\<lambda>i. of_int (c i)))", "by (rule assoc_mult_mat_vec, insert A, auto)"], ["proof (state)\nthis:\n  mat_of_cols n gs * (of_int_hom.mat_hom A)\\<^sup>T *\\<^sub>v\n  vec (length fs) (\\<lambda>i. of_int (c i)) =\n  mat_of_cols n gs *\\<^sub>v\n  ((of_int_hom.mat_hom A)\\<^sup>T *\\<^sub>v\n   vec (length fs) (\\<lambda>i. of_int (c i)))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "also"], ["proof (state)\nthis:\n  mat_of_cols n gs * (of_int_hom.mat_hom A)\\<^sup>T *\\<^sub>v\n  vec (length fs) (\\<lambda>i. of_int (c i)) =\n  mat_of_cols n gs *\\<^sub>v\n  ((of_int_hom.mat_hom A)\\<^sup>T *\\<^sub>v\n   vec (length fs) (\\<lambda>i. of_int (c i)))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have \"?A\\<^sup>T = ?I (A\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_hom.mat_hom A)\\<^sup>T = of_int_hom.mat_hom A\\<^sup>T", "by fastforce"], ["proof (state)\nthis:\n  (of_int_hom.mat_hom A)\\<^sup>T = of_int_hom.mat_hom A\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "also"], ["proof (state)\nthis:\n  (of_int_hom.mat_hom A)\\<^sup>T = of_int_hom.mat_hom A\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have \"?c = map_vec ?i (vec ?m c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (length fs) (\\<lambda>i. of_int (c i)) =\n    of_int_hom.vec_hom (vec (length fs) c)", "by auto"], ["proof (state)\nthis:\n  vec (length fs) (\\<lambda>i. of_int (c i)) =\n  of_int_hom.vec_hom (vec (length fs) c)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "also"], ["proof (state)\nthis:\n  vec (length fs) (\\<lambda>i. of_int (c i)) =\n  of_int_hom.vec_hom (vec (length fs) c)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have \"?I (A\\<^sup>T) *\\<^sub>v \\<dots> = map_vec ?i ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom A\\<^sup>T *\\<^sub>v\n    of_int_hom.vec_hom (vec (length fs) c) =\n    of_int_hom.vec_hom (A\\<^sup>T *\\<^sub>v vec (length fs) c)", "using A"], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom A \\<in> carrier_mat (length fs) (length gs)\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom A\\<^sup>T *\\<^sub>v\n    of_int_hom.vec_hom (vec (length fs) c) =\n    of_int_hom.vec_hom (A\\<^sup>T *\\<^sub>v vec (length fs) c)", "by (simp add: of_int_hom.mult_mat_vec_hom)"], ["proof (state)\nthis:\n  of_int_hom.mat_hom A\\<^sup>T *\\<^sub>v\n  of_int_hom.vec_hom (vec (length fs) c) =\n  of_int_hom.vec_hom (A\\<^sup>T *\\<^sub>v vec (length fs) c)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "finally"], ["proof (chain)\npicking this:\n  v =\n  mat_of_cols n gs *\\<^sub>v\n  of_int_hom.vec_hom (A\\<^sup>T *\\<^sub>v vec (length fs) c)", "have \"v = mat_of_cols n gs *\\<^sub>v map_vec ?i ?d\""], ["proof (prove)\nusing this:\n  v =\n  mat_of_cols n gs *\\<^sub>v\n  of_int_hom.vec_hom (A\\<^sup>T *\\<^sub>v vec (length fs) c)\n\ngoal (1 subgoal):\n 1. v =\n    mat_of_cols n gs *\\<^sub>v\n    of_int_hom.vec_hom (A\\<^sup>T *\\<^sub>v vec (length fs) c)", "."], ["proof (state)\nthis:\n  v =\n  mat_of_cols n gs *\\<^sub>v\n  of_int_hom.vec_hom (A\\<^sup>T *\\<^sub>v vec (length fs) c)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "define d where \"d = ?d\""], ["proof (state)\nthis:\n  d = A\\<^sup>T *\\<^sub>v vec (length fs) c\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have d: \"d \\<in> carrier_vec ?m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<in> carrier_vec (length gs)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>T *\\<^sub>v vec (length fs) c \\<in> carrier_vec (length gs)", "using A"], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom A \\<in> carrier_mat (length fs) (length gs)\n\ngoal (1 subgoal):\n 1. A\\<^sup>T *\\<^sub>v vec (length fs) c \\<in> carrier_vec (length gs)", "by auto"], ["proof (state)\nthis:\n  d \\<in> carrier_vec (length gs)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have \"v = mat_of_cols n gs *\\<^sub>v map_vec ?i d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = mat_of_cols n gs *\\<^sub>v of_int_hom.vec_hom d", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v =\n    mat_of_cols n gs *\\<^sub>v\n    of_int_hom.vec_hom (A\\<^sup>T *\\<^sub>v vec (length fs) c)", "by fact"], ["proof (state)\nthis:\n  v = mat_of_cols n gs *\\<^sub>v of_int_hom.vec_hom d\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "also"], ["proof (state)\nthis:\n  v = mat_of_cols n gs *\\<^sub>v of_int_hom.vec_hom d\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "have \"\\<dots> =  M.sumlist (map (\\<lambda>i. ?i (d $ i) \\<cdot>\\<^sub>v gs ! i) [0..<?m'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n gs *\\<^sub>v of_int_hom.vec_hom d =\n    M.sumlist\n     (map (\\<lambda>i. of_int (d $ i) \\<cdot>\\<^sub>v gs ! i)\n       [0..<length gs])", "by (rule sym, rule eq_vecI, insert d, auto intro!: dim_sumlist sum.cong \n      simp: sumlist_nth scalar_prod_def mat_of_cols_def)"], ["proof (state)\nthis:\n  mat_of_cols n gs *\\<^sub>v of_int_hom.vec_hom d =\n  M.sumlist\n   (map (\\<lambda>i. of_int (d $ i) \\<cdot>\\<^sub>v gs ! i) [0..<length gs])\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lattice_of fs \\<Longrightarrow> x \\<in> lattice_of gs", "finally"], ["proof (chain)\npicking this:\n  v =\n  M.sumlist\n   (map (\\<lambda>i. of_int (d $ i) \\<cdot>\\<^sub>v gs ! i) [0..<length gs])", "show \"v \\<in> lattice_of gs\""], ["proof (prove)\nusing this:\n  v =\n  M.sumlist\n   (map (\\<lambda>i. of_int (d $ i) \\<cdot>\\<^sub>v gs ! i) [0..<length gs])\n\ngoal (1 subgoal):\n 1. v \\<in> lattice_of gs", "by (intro in_latticeI, auto)"], ["proof (state)\nthis:\n  v \\<in> lattice_of gs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context LLL_with_assms\nbegin"], ["", "lemma mult_left_identity:\n  defines \"B \\<equiv> (map_mat rat_of_int (mat_of_rows n fs_init))\"\n  assumes P_carrier[simp]: \"P \\<in> carrier_mat m m\" \n  and PB: \"P * B = B\"  \nshows \"P = 1\\<^sub>m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = 1\\<^sub>m m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P = 1\\<^sub>m m", "let ?set_rows = \"set (rows B)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P = 1\\<^sub>m m", "let ?hom = \"of_int_hom.vec_hom :: int vec \\<Rightarrow> rat vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. P = 1\\<^sub>m m", "have set_rows_carrier: \"?set_rows \\<subseteq> (carrier_vec n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rows B) \\<subseteq> Rn", "by (auto simp add: rows_def B_def)"], ["proof (state)\nthis:\n  set (rows B) \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. P = 1\\<^sub>m m", "have set_rows_eq: \"?set_rows = set (map of_int_hom.vec_hom fs_init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rows B) = set (map of_int_hom.vec_hom fs_init)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (rows B) = set (map of_int_hom.vec_hom fs_init)", "have \"x \\<in> of_int_hom.vec_hom ` set fs_init\" if x: \"x \\<in> set (rows B)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> of_int_hom.vec_hom ` set fs_init", "using x"], ["proof (prove)\nusing this:\n  x \\<in> set (rows B)\n\ngoal (1 subgoal):\n 1. x \\<in> of_int_hom.vec_hom ` set fs_init", "unfolding B_def"], ["proof (prove)\nusing this:\n  x \\<in> set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n\ngoal (1 subgoal):\n 1. x \\<in> of_int_hom.vec_hom ` set fs_init", "by (metis cof_vec_space.lin_indpt_list_def fs_init image_set \n          lin_dep mat_of_rows_map rows_mat_of_rows)"], ["proof (state)\nthis:\n  ?x1 \\<in> set (rows B) \\<Longrightarrow>\n  ?x1 \\<in> of_int_hom.vec_hom ` set fs_init\n\ngoal (1 subgoal):\n 1. set (rows B) = set (map of_int_hom.vec_hom fs_init)", "moreover"], ["proof (state)\nthis:\n  ?x1 \\<in> set (rows B) \\<Longrightarrow>\n  ?x1 \\<in> of_int_hom.vec_hom ` set fs_init\n\ngoal (1 subgoal):\n 1. set (rows B) = set (map of_int_hom.vec_hom fs_init)", "have \"of_int_hom.vec_hom xa \\<in> set (rows B)\" if xa: \"xa \\<in> set fs_init\" for xa"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom xa \\<in> set (rows B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom xa \\<in> set (rows B)", "obtain i where xa: \"xa = fs_init ! i\" and i: \"i<m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xa = fs_init ! i; i < m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth len xa)"], ["proof (state)\nthis:\n  xa = fs_init ! i\n  i < m\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom xa \\<in> set (rows B)", "have \"?hom (fs_init ! i) = row B i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs_init ! i) = row B i", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs_init ! i) =\n    row (of_int_hom.mat_hom (mat_of_rows n fs_init)) i", "by (metis i cof_vec_space.lin_indpt_list_def fs_init index_map_mat(2) len lin_dep \n            mat_of_rows_carrier(2) mat_of_rows_map nth_map nth_rows rows_mat_of_rows)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs_init ! i) = row B i\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom xa \\<in> set (rows B)", "thus ?thesis"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (fs_init ! i) = row B i\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom xa \\<in> set (rows B)", "by (metis B_def xa i cof_vec_space.lin_indpt_list_def fs_init index_map_mat(2) len \n            length_rows lin_dep mat_of_rows_map nth_map nth_mem rows_mat_of_rows)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom xa \\<in> set (rows B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?xa1 \\<in> set fs_init \\<Longrightarrow>\n  of_int_hom.vec_hom ?xa1 \\<in> set (rows B)\n\ngoal (1 subgoal):\n 1. set (rows B) = set (map of_int_hom.vec_hom fs_init)", "ultimately"], ["proof (chain)\npicking this:\n  ?x1 \\<in> set (rows B) \\<Longrightarrow>\n  ?x1 \\<in> of_int_hom.vec_hom ` set fs_init\n  ?xa1 \\<in> set fs_init \\<Longrightarrow>\n  of_int_hom.vec_hom ?xa1 \\<in> set (rows B)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set (rows B) \\<Longrightarrow>\n  ?x1 \\<in> of_int_hom.vec_hom ` set fs_init\n  ?xa1 \\<in> set fs_init \\<Longrightarrow>\n  of_int_hom.vec_hom ?xa1 \\<in> set (rows B)\n\ngoal (1 subgoal):\n 1. set (rows B) = set (map of_int_hom.vec_hom fs_init)", "by auto"], ["proof (state)\nthis:\n  set (rows B) = set (map of_int_hom.vec_hom fs_init)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (rows B) = set (map of_int_hom.vec_hom fs_init)\n\ngoal (1 subgoal):\n 1. P = 1\\<^sub>m m", "have ind_set_rows: \"gs.lin_indpt ?set_rows\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (rows B))", "using lin_dep set_rows_eq"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)\n  set (rows B) = set (map of_int_hom.vec_hom fs_init)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (rows B))", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs_init) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n  set (rows B) = set (map of_int_hom.vec_hom fs_init)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (rows B))", "by auto"], ["proof (state)\nthis:\n  gs.lin_indpt (set (rows B))\n\ngoal (1 subgoal):\n 1. P = 1\\<^sub>m m", "have inj_on_rowB: \"inj_on (row B) {0..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (row B) {0..<m}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (row B) {0..<m}", "have \"x = y\" if x: \"x < m\" and y: \"y < m\" and row_xy: \"row B x = row B y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "assume xy: \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have 1: \"?hom (fs_init ! x) = row B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs_init ! x) = row B x", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs_init ! x) =\n    row (of_int_hom.mat_hom (mat_of_rows n fs_init)) x", "by (metis fs_init index_map_mat(2) len local.set_rows_carrier mat_of_rows_carrier(2) \n            mat_of_rows_map nth_map nth_rows rows_mat_of_rows set_rows_eq that(1))"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs_init ! x) = row B x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs_init ! x) = row B x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have 2: \"?hom (fs_init ! y) = row B y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs_init ! y) = row B y", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs_init ! y) =\n    row (of_int_hom.mat_hom (mat_of_rows n fs_init)) y", "by (metis fs_init index_map_mat(2) len local.set_rows_carrier mat_of_rows_carrier(2) \n            mat_of_rows_map nth_map nth_rows rows_mat_of_rows set_rows_eq that(2))"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs_init ! y) = row B y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  of_int_hom.vec_hom (fs_init ! x) = row B x\n  of_int_hom.vec_hom (fs_init ! y) = row B y", "have \"?hom (fs_init ! x) = ?hom (fs_init ! y)\""], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (fs_init ! x) = row B x\n  of_int_hom.vec_hom (fs_init ! y) = row B y\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs_init ! x) = of_int_hom.vec_hom (fs_init ! y)", "using row_xy"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (fs_init ! x) = row B x\n  of_int_hom.vec_hom (fs_init ! y) = row B y\n  row B x = row B y\n\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (fs_init ! x) = of_int_hom.vec_hom (fs_init ! y)", "by auto"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (fs_init ! x) = of_int_hom.vec_hom (fs_init ! y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (fs_init ! x) = of_int_hom.vec_hom (fs_init ! y)\n\ngoal (1 subgoal):\n 1. False", "using lin_dep x y row_xy"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (fs_init ! x) = of_int_hom.vec_hom (fs_init ! y)\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)\n  x < m\n  y < m\n  row B x = row B y\n\ngoal (1 subgoal):\n 1. False", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (fs_init ! x) = of_int_hom.vec_hom (fs_init ! y)\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs_init) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n  x < m\n  y < m\n  row B x = row B y\n\ngoal (1 subgoal):\n 1. False", "using xy x y len"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (fs_init ! x) = of_int_hom.vec_hom (fs_init ! y)\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs_init) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n  x < m\n  y < m\n  row B x = row B y\n  x \\<noteq> y\n  x < m\n  y < m\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. False", "unfolding distinct_conv_nth"], ["proof (prove)\nusing this:\n  of_int_hom.vec_hom (fs_init ! x) = of_int_hom.vec_hom (fs_init ! y)\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn \\<and>\n  (\\<forall>i<length (map of_int_hom.vec_hom fs_init).\n      \\<forall>j<length (map of_int_hom.vec_hom fs_init).\n         i \\<noteq> j \\<longrightarrow>\n         map of_int_hom.vec_hom fs_init ! i \\<noteq>\n         map of_int_hom.vec_hom fs_init ! j) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n  x < m\n  y < m\n  row B x = row B y\n  x \\<noteq> y\n  x < m\n  y < m\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 < m; ?y1 < m; row B ?x1 = row B ?y1\\<rbrakk>\n  \\<Longrightarrow> ?x1 = ?y1\n\ngoal (1 subgoal):\n 1. inj_on (row B) {0..<m}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1 < m; ?y1 < m; row B ?x1 = row B ?y1\\<rbrakk>\n  \\<Longrightarrow> ?x1 = ?y1\n\ngoal (1 subgoal):\n 1. inj_on (row B) {0..<m}", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1 < m; ?y1 < m; row B ?x1 = row B ?y1\\<rbrakk>\n  \\<Longrightarrow> ?x1 = ?y1\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..<m}.\n       \\<forall>y\\<in>{0..<m}. row B x = row B y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj_on (row B) {0..<m}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (row B) {0..<m}\n\ngoal (1 subgoal):\n 1. P = 1\\<^sub>m m", "have the_x: \"(THE k. k < m \\<and> row B x = row B k) = x\" if x: \"x < m\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE k. k < m \\<and> row B x = row B k) = x", "proof (rule theI2)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?a < m \\<and> row B x = row B ?a\n 2. \\<And>xa. xa < m \\<and> row B x = row B xa \\<Longrightarrow> xa = ?a\n 3. \\<And>xa. xa < m \\<and> row B x = row B xa \\<Longrightarrow> xa = x", "show \"x < m \\<and> row B x = row B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < m \\<and> row B x = row B x", "using x"], ["proof (prove)\nusing this:\n  x < m\n\ngoal (1 subgoal):\n 1. x < m \\<and> row B x = row B x", "by auto"], ["proof (state)\nthis:\n  x < m \\<and> row B x = row B x\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa < m \\<and> row B x = row B xa \\<Longrightarrow> xa = x\n 2. \\<And>xa. xa < m \\<and> row B x = row B xa \\<Longrightarrow> xa = x", "fix xa"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. xa < m \\<and> row B x = row B xa \\<Longrightarrow> xa = x\n 2. \\<And>xa. xa < m \\<and> row B x = row B xa \\<Longrightarrow> xa = x", "assume xa: \"xa < m \\<and> row B x = row B xa\""], ["proof (state)\nthis:\n  xa < m \\<and> row B x = row B xa\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa < m \\<and> row B x = row B xa \\<Longrightarrow> xa = x\n 2. \\<And>xa. xa < m \\<and> row B x = row B xa \\<Longrightarrow> xa = x", "show \"xa = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa = x", "using xa inj_on_rowB x"], ["proof (prove)\nusing this:\n  xa < m \\<and> row B x = row B xa\n  inj_on (row B) {0..<m}\n  x < m\n\ngoal (1 subgoal):\n 1. xa = x", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  xa < m \\<and> row B x = row B xa\n  \\<forall>x\\<in>{0..<m}.\n     \\<forall>y\\<in>{0..<m}. row B x = row B y \\<longrightarrow> x = y\n  x < m\n\ngoal (1 subgoal):\n 1. xa = x", "by auto"], ["proof (state)\nthis:\n  xa = x\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa < m \\<and> row B x = row B xa \\<Longrightarrow> xa = x", "thus \"xa = x\""], ["proof (prove)\nusing this:\n  xa = x\n\ngoal (1 subgoal):\n 1. xa = x", "."], ["proof (state)\nthis:\n  xa = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1 < m \\<Longrightarrow> (THE k. k < m \\<and> row B ?x1 = row B k) = ?x1\n\ngoal (1 subgoal):\n 1. P = 1\\<^sub>m m", "let ?h= \"row B\""], ["proof (state)\ngoal (1 subgoal):\n 1. P = 1\\<^sub>m m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = 1\\<^sub>m m", "proof (rule eq_matI, unfold one_mat_def, auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "fix j"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "assume j: \"j < m\""], ["proof (state)\nthis:\n  j < m\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "let ?f = \"(\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "let ?g = \"\\<lambda>v. if v = row B j then (?f v) - 1 else ?f v\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have finsum_closed[simp]: \n       \"finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n     {0..<m}\n    \\<in> Rn", "by (rule finsum_vec_closed, insert len B_def, auto)"], ["proof (state)\nthis:\n  finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n   {0..<m}\n  \\<in> Rn\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have B_carrier[simp]: \"B \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat m n", "using len fs_init B_def"], ["proof (prove)\nusing this:\n  length fs_init = m\n  set fs_init \\<subseteq> carrier_vec n\n  B \\<equiv> of_int_hom.mat_hom (mat_of_rows n fs_init)\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat m n\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "define v where \"v \\<equiv> row B j\""], ["proof (state)\nthis:\n  v \\<equiv> row B j\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have v_set_rows: \"v \\<in> set (rows B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (rows B)", "using nth_rows j"], ["proof (prove)\nusing this:\n  ?i < dim_row ?A \\<Longrightarrow> rows ?A ! ?i = row ?A ?i\n  j < m\n\ngoal (1 subgoal):\n 1. v \\<in> set (rows B)", "unfolding v_def"], ["proof (prove)\nusing this:\n  ?i < dim_row ?A \\<Longrightarrow> rows ?A ! ?i = row ?A ?i\n  j < m\n\ngoal (1 subgoal):\n 1. row B j \\<in> set (rows B)", "by (metis B_carrier carrier_matD(1) length_rows nth_mem)"], ["proof (state)\nthis:\n  v \\<in> set (rows B)\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have [simp]: \"mat_of_rows n fs_init \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows n fs_init \\<in> carrier_mat m n", "using len fs_init"], ["proof (prove)\nusing this:\n  length fs_init = m\n  set fs_init \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat_of_rows n fs_init \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  mat_of_rows n fs_init \\<in> carrier_mat m n\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have \"B = P*B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = P * B", "using PB"], ["proof (prove)\nusing this:\n  P * B = B\n\ngoal (1 subgoal):\n 1. B = P * B", "by auto"], ["proof (state)\nthis:\n  B = P * B\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "also"], ["proof (state)\nthis:\n  B = P * B\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have \"... = mat\\<^sub>r m n (\\<lambda>i. finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (i, k) \\<cdot>\\<^sub>v row B k) {0..<m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * B =\n    mat\\<^sub>r m n\n     (\\<lambda>i.\n         finsum_vec TYPE(rat) n\n          (\\<lambda>k. P $$ (i, k) \\<cdot>\\<^sub>v row B k) {0..<m})", "by (rule mat_mul_finsum_alt, auto)"], ["proof (state)\nthis:\n  P * B =\n  mat\\<^sub>r m n\n   (\\<lambda>i.\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (i, k) \\<cdot>\\<^sub>v row B k) {0..<m})\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "also"], ["proof (state)\nthis:\n  P * B =\n  mat\\<^sub>r m n\n   (\\<lambda>i.\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (i, k) \\<cdot>\\<^sub>v row B k) {0..<m})\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have \"row (...) j = finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat\\<^sub>r m n\n          (\\<lambda>i.\n              finsum_vec TYPE(rat) n\n               (\\<lambda>k. P $$ (i, k) \\<cdot>\\<^sub>v row B k) {0..<m}))\n     j =\n    finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n     {0..<m}", "by (rule row_mat_of_row_fun[OF j], simp)"], ["proof (state)\nthis:\n  row (mat\\<^sub>r m n\n        (\\<lambda>i.\n            finsum_vec TYPE(rat) n\n             (\\<lambda>k. P $$ (i, k) \\<cdot>\\<^sub>v row B k) {0..<m}))\n   j =\n  finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n   {0..<m}\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "also"], ["proof (state)\nthis:\n  row (mat\\<^sub>r m n\n        (\\<lambda>i.\n            finsum_vec TYPE(rat) n\n             (\\<lambda>k. P $$ (i, k) \\<cdot>\\<^sub>v row B k) {0..<m}))\n   j =\n  finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n   {0..<m}\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have \"... = finsum_vec TYPE(rat) n (\\<lambda>v.  ?f v \\<cdot>\\<^sub>v v) ?set_rows\"  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n     {0..<m} =\n    finsum_vec TYPE(rat) n\n     (\\<lambda>v.\n         P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n     (set (rows B))", "proof (rule eq_vecI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i\n 2. dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m}) =\n    dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>v.\n           P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n       (set (rows B)))", "have rhs_carrier: \"?rhs \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum_vec TYPE(rat) n\n     (\\<lambda>v.\n         P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n     (set (rows B))\n    \\<in> Rn", "by (rule finsum_vec_closed, insert set_rows_carrier, auto)"], ["proof (state)\nthis:\n  finsum_vec TYPE(rat) n\n   (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n   (set (rows B))\n  \\<in> Rn\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i\n 2. dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m}) =\n    dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>v.\n           P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n       (set (rows B)))", "have \"dim_vec ?lhs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m}) =\n    n", "using vec_space.finsum_dim"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; ?f \\<in> ?A \\<rightarrow> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> dim_vec (finsum (module_vec TYPE(?'a) ?n) ?f ?A) = ?n\n\ngoal (1 subgoal):\n 1. dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m}) =\n    n", "by simp"], ["proof (state)\nthis:\n  dim_vec\n   (finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n     {0..<m}) =\n  n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i\n 2. dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m}) =\n    dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>v.\n           P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n       (set (rows B)))", "also"], ["proof (state)\nthis:\n  dim_vec\n   (finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n     {0..<m}) =\n  n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i\n 2. dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m}) =\n    dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>v.\n           P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n       (set (rows B)))", "have dim_rhs: \"... = dim_vec ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n =\n    dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>v.\n           P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n       (set (rows B)))", "using rhs_carrier"], ["proof (prove)\nusing this:\n  finsum_vec TYPE(rat) n\n   (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n   (set (rows B))\n  \\<in> Rn\n\ngoal (1 subgoal):\n 1. n =\n    dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>v.\n           P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n       (set (rows B)))", "by auto"], ["proof (state)\nthis:\n  n =\n  dim_vec\n   (finsum_vec TYPE(rat) n\n     (\\<lambda>v.\n         P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n     (set (rows B)))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i\n 2. dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m}) =\n    dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>v.\n           P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n       (set (rows B)))", "finally"], ["proof (chain)\npicking this:\n  dim_vec\n   (finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n     {0..<m}) =\n  dim_vec\n   (finsum_vec TYPE(rat) n\n     (\\<lambda>v.\n         P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n     (set (rows B)))", "show \"dim_vec ?lhs = dim_vec ?rhs\""], ["proof (prove)\nusing this:\n  dim_vec\n   (finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n     {0..<m}) =\n  dim_vec\n   (finsum_vec TYPE(rat) n\n     (\\<lambda>v.\n         P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n     (set (rows B)))\n\ngoal (1 subgoal):\n 1. dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m}) =\n    dim_vec\n     (finsum_vec TYPE(rat) n\n       (\\<lambda>v.\n           P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n       (set (rows B)))", "."], ["proof (state)\nthis:\n  dim_vec\n   (finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n     {0..<m}) =\n  dim_vec\n   (finsum_vec TYPE(rat) n\n     (\\<lambda>v.\n         P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n     (set (rows B)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "assume i: \"i < dim_vec ?rhs\""], ["proof (state)\nthis:\n  i < dim_vec\n       (finsum_vec TYPE(rat) n\n         (\\<lambda>v.\n             P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n         (set (rows B)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "have i_n: \"i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n", "using i dim_rhs"], ["proof (prove)\nusing this:\n  i < dim_vec\n       (finsum_vec TYPE(rat) n\n         (\\<lambda>v.\n             P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n         (set (rows B)))\n  n =\n  dim_vec\n   (finsum_vec TYPE(rat) n\n     (\\<lambda>v.\n         P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n     (set (rows B)))\n\ngoal (1 subgoal):\n 1. i < n", "by auto"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "let ?g = \"\\<lambda>v. (?f v \\<cdot>\\<^sub>v v) $ i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "have image_h: \"?h `{0..<m} = ?set_rows\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row B ` {0..<m} = set (rows B)", "by (auto simp add: B_def len rows_def)"], ["proof (state)\nthis:\n  row B ` {0..<m} = set (rows B)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "have \"?lhs $ i = (\\<Sum>k\\<in>{0..<m}. (P $$ (j, k) \\<cdot>\\<^sub>v row B k) $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n     {0..<m} $\n    i =\n    (\\<Sum>k = 0..<m. (P $$ (j, k) \\<cdot>\\<^sub>v row B k) $ i)", "by (rule index_finsum_vec[OF _ i_n], auto)"], ["proof (state)\nthis:\n  finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n   {0..<m} $\n  i =\n  (\\<Sum>k = 0..<m. (P $$ (j, k) \\<cdot>\\<^sub>v row B k) $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "also"], ["proof (state)\nthis:\n  finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n   {0..<m} $\n  i =\n  (\\<Sum>k = 0..<m. (P $$ (j, k) \\<cdot>\\<^sub>v row B k) $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "have \"... = sum (?g \\<circ> ?h) {0..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<m. (P $$ (j, k) \\<cdot>\\<^sub>v row B k) $ i) =\n    sum ((\\<lambda>v.\n             (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $\n             i) \\<circ>\n         row B)\n     {0..<m}", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<m. (P $$ (j, k) \\<cdot>\\<^sub>v row B k) $ i) =\n    (\\<Sum>x = 0..<m.\n        (P $$ (j, THE k. k < m \\<and> row B x = row B k) \\<cdot>\\<^sub>v\n         row B x) $\n        i)", "by (rule sum.cong, insert the_x, auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<m. (P $$ (j, k) \\<cdot>\\<^sub>v row B k) $ i) =\n  sum ((\\<lambda>v.\n           (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $\n           i) \\<circ>\n       row B)\n   {0..<m}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<m. (P $$ (j, k) \\<cdot>\\<^sub>v row B k) $ i) =\n  sum ((\\<lambda>v.\n           (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $\n           i) \\<circ>\n       row B)\n   {0..<m}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "have \"... = sum (\\<lambda>v. (?f v \\<cdot>\\<^sub>v v) $ i) (?h `{0..<m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>v.\n             (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $\n             i) \\<circ>\n         row B)\n     {0..<m} =\n    (\\<Sum>v\\<in>row B ` {0..<m}.\n       (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i)", "by (rule sum.reindex[symmetric, OF inj_on_rowB])"], ["proof (state)\nthis:\n  sum ((\\<lambda>v.\n           (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $\n           i) \\<circ>\n       row B)\n   {0..<m} =\n  (\\<Sum>v\\<in>row B ` {0..<m}.\n     (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>v.\n           (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $\n           i) \\<circ>\n       row B)\n   {0..<m} =\n  (\\<Sum>v\\<in>row B ` {0..<m}.\n     (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "have \"... =  (\\<Sum>v\\<in>?set_rows. (?f v \\<cdot>\\<^sub>v v) $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>row B ` {0..<m}.\n       (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i) =\n    (\\<Sum>v\\<in>set (rows B).\n       (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i)", "using image_h"], ["proof (prove)\nusing this:\n  row B ` {0..<m} = set (rows B)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>row B ` {0..<m}.\n       (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i) =\n    (\\<Sum>v\\<in>set (rows B).\n       (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>row B ` {0..<m}.\n     (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i) =\n  (\\<Sum>v\\<in>set (rows B).\n     (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>row B ` {0..<m}.\n     (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i) =\n  (\\<Sum>v\\<in>set (rows B).\n     (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "have \"... = ?rhs $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>set (rows B).\n       (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i) =\n    finsum_vec TYPE(rat) n\n     (\\<lambda>v.\n         P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n     (set (rows B)) $\n    i", "by (rule index_finsum_vec[symmetric, OF _ i_n], insert set_rows_carrier, auto)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>set (rows B).\n     (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) $ i) =\n  finsum_vec TYPE(rat) n\n   (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n   (set (rows B)) $\n  i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (finsum_vec TYPE(rat) n\n              (\\<lambda>v.\n                  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v\n                  v)\n              (set (rows B))) \\<Longrightarrow>\n       finsum_vec TYPE(rat) n\n        (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k) {0..<m} $\n       i =\n       finsum_vec TYPE(rat) n\n        (\\<lambda>v.\n            P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n        (set (rows B)) $\n       i", "finally"], ["proof (chain)\npicking this:\n  finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n   {0..<m} $\n  i =\n  finsum_vec TYPE(rat) n\n   (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n   (set (rows B)) $\n  i", "show \"?lhs $ i = ?rhs $ i\""], ["proof (prove)\nusing this:\n  finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n   {0..<m} $\n  i =\n  finsum_vec TYPE(rat) n\n   (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n   (set (rows B)) $\n  i\n\ngoal (1 subgoal):\n 1. finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n     {0..<m} $\n    i =\n    finsum_vec TYPE(rat) n\n     (\\<lambda>v.\n         P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n     (set (rows B)) $\n    i", "by auto"], ["proof (state)\nthis:\n  finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n   {0..<m} $\n  i =\n  finsum_vec TYPE(rat) n\n   (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n   (set (rows B)) $\n  i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n   {0..<m} =\n  finsum_vec TYPE(rat) n\n   (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n   (set (rows B))\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "also"], ["proof (state)\nthis:\n  finsum_vec TYPE(rat) n (\\<lambda>k. P $$ (j, k) \\<cdot>\\<^sub>v row B k)\n   {0..<m} =\n  finsum_vec TYPE(rat) n\n   (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n   (set (rows B))\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have \"... = (\\<Oplus>\\<^bsub>gs.V\\<^esub>v\\<in>?set_rows. ?f v \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum_vec TYPE(rat) n\n     (\\<lambda>v.\n         P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n     (set (rows B)) =\n    (\\<Oplus>\\<^bsub>gs.V\\<^esub>v\\<in>set\n  (rows B). P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)", "unfolding vec_space.finsum_vec"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>gs.V\\<^esub>v\\<in>set\n  (rows B). P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>gs.V\\<^esub>v\\<in>set\n  (rows B). P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)", ".."], ["proof (state)\nthis:\n  finsum_vec TYPE(rat) n\n   (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n   (set (rows B)) =\n  (\\<Oplus>\\<^bsub>gs.V\\<^esub>v\\<in>set\n(rows B). P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "also"], ["proof (state)\nthis:\n  finsum_vec TYPE(rat) n\n   (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n   (set (rows B)) =\n  (\\<Oplus>\\<^bsub>gs.V\\<^esub>v\\<in>set\n(rows B). P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have \"... = gs.lincomb ?f ?set_rows\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>gs.V\\<^esub>v\\<in>set\n  (rows B). P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) =\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B))", "unfolding gs.lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>gs.V\\<^esub>v\\<in>set\n  (rows B). P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) =\n    (\\<Oplus>\\<^bsub>gs.V\\<^esub>v\\<in>set\n  (rows B). P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>gs.V\\<^esub>v\\<in>set\n(rows B). P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v) =\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B))\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "finally"], ["proof (chain)\npicking this:\n  row B j =\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B))", "have lincomb_rowBj: \"gs.lincomb ?f ?set_rows = row B j\""], ["proof (prove)\nusing this:\n  row B j =\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B))\n\ngoal (1 subgoal):\n 1. gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    row B j", ".."], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B)) =\n  row B j\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have lincomb_0: \"gs.lincomb ?g (?set_rows) = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have v_closed[simp]: \"v \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> Rn", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. row B j \\<in> Rn", "using j"], ["proof (prove)\nusing this:\n  j < m\n\ngoal (1 subgoal):\n 1. row B j \\<in> Rn", "by auto"], ["proof (state)\nthis:\n  v \\<in> Rn\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have lincomb_f_closed[simp]: \"gs.lincomb ?f (?set_rows-{v}) \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v})\n    \\<in> Rn", "by (rule gs.lincomb_closed, insert set_rows_carrier, auto)"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v})\n  \\<in> Rn\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have fv_v_closed[simp]: \"?f v \\<cdot>\\<^sub>v v \\<in> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v \\<in> Rn", "by auto"], ["proof (state)\nthis:\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v \\<in> Rn\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have lincomb_f: \"gs.lincomb ?f ?set_rows = ?f v \\<cdot>\\<^sub>v v + gs.lincomb ?f (?set_rows-{v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v})", "by (rule gs.lincomb_del2, insert set_rows_carrier v_set_rows, auto)"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B)) =\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v})\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have fvv_gvv: \"?f v \\<cdot>\\<^sub>v v - v = ?g v \\<cdot>\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v - v =\n    (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n    v", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P $$ (j, THE k. k < m \\<and> row B j = row B k) \\<cdot>\\<^sub>v\n    row B j -\n    row B j =\n    (if row B j = row B j\n     then P $$ (j, THE k. k < m \\<and> row B j = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> row B j = row B k)) \\<cdot>\\<^sub>v\n    row B j", "by (rule eq_vecI, auto, simp add: left_diff_distrib)"], ["proof (state)\nthis:\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v - v =\n  (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n  v\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have lincomb_fg: \"gs.lincomb ?f (?set_rows-{v}) = gs.lincomb ?g (?set_rows-{v})\" \n        (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) =\n    gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v})", "proof (rule eq_vecI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (gs.lincomb\n              (\\<lambda>v.\n                  if v = row B j\n                  then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n                  else P $$ (j, THE k. k < m \\<and> v = row B k))\n              (set (rows B) - {v})) \\<Longrightarrow>\n       gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i =\n       gs.lincomb\n        (\\<lambda>v.\n            if v = row B j\n            then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n            else P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i\n 2. dim_vec\n     (gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n       (set (rows B) - {v})) =\n    dim_vec\n     (gs.lincomb\n       (\\<lambda>v.\n           if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n           else P $$ (j, THE k. k < m \\<and> v = row B k))\n       (set (rows B) - {v}))", "show dim_vec_eq: \"dim_vec ?lhs = dim_vec ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n       (set (rows B) - {v})) =\n    dim_vec\n     (gs.lincomb\n       (\\<lambda>v.\n           if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n           else P $$ (j, THE k. k < m \\<and> v = row B k))\n       (set (rows B) - {v}))", "by (smt DiffE carrier_vecD gs.lincomb_closed local.set_rows_carrier subsetCE subsetI)"], ["proof (state)\nthis:\n  dim_vec\n   (gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v})) =\n  dim_vec\n   (gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (gs.lincomb\n              (\\<lambda>v.\n                  if v = row B j\n                  then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n                  else P $$ (j, THE k. k < m \\<and> v = row B k))\n              (set (rows B) - {v})) \\<Longrightarrow>\n       gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i =\n       gs.lincomb\n        (\\<lambda>v.\n            if v = row B j\n            then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n            else P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (gs.lincomb\n              (\\<lambda>v.\n                  if v = row B j\n                  then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n                  else P $$ (j, THE k. k < m \\<and> v = row B k))\n              (set (rows B) - {v})) \\<Longrightarrow>\n       gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i =\n       gs.lincomb\n        (\\<lambda>v.\n            if v = row B j\n            then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n            else P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i", "assume i: \"i<dim_vec ?rhs\""], ["proof (state)\nthis:\n  i < dim_vec\n       (gs.lincomb\n         (\\<lambda>v.\n             if v = row B j\n             then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n             else P $$ (j, THE k. k < m \\<and> v = row B k))\n         (set (rows B) - {v}))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (gs.lincomb\n              (\\<lambda>v.\n                  if v = row B j\n                  then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n                  else P $$ (j, THE k. k < m \\<and> v = row B k))\n              (set (rows B) - {v})) \\<Longrightarrow>\n       gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i =\n       gs.lincomb\n        (\\<lambda>v.\n            if v = row B j\n            then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n            else P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i", "hence i_n: \"i<n\""], ["proof (prove)\nusing this:\n  i < dim_vec\n       (gs.lincomb\n         (\\<lambda>v.\n             if v = row B j\n             then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n             else P $$ (j, THE k. k < m \\<and> v = row B k))\n         (set (rows B) - {v}))\n\ngoal (1 subgoal):\n 1. i < n", "using dim_vec_eq lincomb_f_closed"], ["proof (prove)\nusing this:\n  i < dim_vec\n       (gs.lincomb\n         (\\<lambda>v.\n             if v = row B j\n             then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n             else P $$ (j, THE k. k < m \\<and> v = row B k))\n         (set (rows B) - {v}))\n  dim_vec\n   (gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v})) =\n  dim_vec\n   (gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}))\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v})\n  \\<in> Rn\n\ngoal (1 subgoal):\n 1. i < n", "by auto"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (gs.lincomb\n              (\\<lambda>v.\n                  if v = row B j\n                  then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n                  else P $$ (j, THE k. k < m \\<and> v = row B k))\n              (set (rows B) - {v})) \\<Longrightarrow>\n       gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i =\n       gs.lincomb\n        (\\<lambda>v.\n            if v = row B j\n            then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n            else P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i", "have \"?lhs $ i =  (\\<Sum>x\\<in>(?set_rows-{v}). ?f x * x $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) $\n    i =\n    (\\<Sum>x\\<in>set (rows B) - {v}.\n       P $$ (j, THE k. k < m \\<and> x = row B k) * x $ i)", "by (rule gs.lincomb_index[OF i_n], insert set_rows_carrier, auto)"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) $\n  i =\n  (\\<Sum>x\\<in>set (rows B) - {v}.\n     P $$ (j, THE k. k < m \\<and> x = row B k) * x $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (gs.lincomb\n              (\\<lambda>v.\n                  if v = row B j\n                  then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n                  else P $$ (j, THE k. k < m \\<and> v = row B k))\n              (set (rows B) - {v})) \\<Longrightarrow>\n       gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i =\n       gs.lincomb\n        (\\<lambda>v.\n            if v = row B j\n            then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n            else P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i", "also"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) $\n  i =\n  (\\<Sum>x\\<in>set (rows B) - {v}.\n     P $$ (j, THE k. k < m \\<and> x = row B k) * x $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (gs.lincomb\n              (\\<lambda>v.\n                  if v = row B j\n                  then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n                  else P $$ (j, THE k. k < m \\<and> v = row B k))\n              (set (rows B) - {v})) \\<Longrightarrow>\n       gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i =\n       gs.lincomb\n        (\\<lambda>v.\n            if v = row B j\n            then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n            else P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i", "have \"... = (\\<Sum>x\\<in>(?set_rows-{v}). ?g x * x $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (rows B) - {v}.\n       P $$ (j, THE k. k < m \\<and> x = row B k) * x $ i) =\n    (\\<Sum>x\\<in>set (rows B) - {v}.\n       (if x = row B j then P $$ (j, THE k. k < m \\<and> x = row B k) - 1\n        else P $$ (j, THE k. k < m \\<and> x = row B k)) *\n       x $ i)", "by (rule sum.cong, auto simp add: v_def)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (rows B) - {v}.\n     P $$ (j, THE k. k < m \\<and> x = row B k) * x $ i) =\n  (\\<Sum>x\\<in>set (rows B) - {v}.\n     (if x = row B j then P $$ (j, THE k. k < m \\<and> x = row B k) - 1\n      else P $$ (j, THE k. k < m \\<and> x = row B k)) *\n     x $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (gs.lincomb\n              (\\<lambda>v.\n                  if v = row B j\n                  then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n                  else P $$ (j, THE k. k < m \\<and> v = row B k))\n              (set (rows B) - {v})) \\<Longrightarrow>\n       gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i =\n       gs.lincomb\n        (\\<lambda>v.\n            if v = row B j\n            then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n            else P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (rows B) - {v}.\n     P $$ (j, THE k. k < m \\<and> x = row B k) * x $ i) =\n  (\\<Sum>x\\<in>set (rows B) - {v}.\n     (if x = row B j then P $$ (j, THE k. k < m \\<and> x = row B k) - 1\n      else P $$ (j, THE k. k < m \\<and> x = row B k)) *\n     x $ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (gs.lincomb\n              (\\<lambda>v.\n                  if v = row B j\n                  then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n                  else P $$ (j, THE k. k < m \\<and> v = row B k))\n              (set (rows B) - {v})) \\<Longrightarrow>\n       gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i =\n       gs.lincomb\n        (\\<lambda>v.\n            if v = row B j\n            then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n            else P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i", "have \"... = ?rhs $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set (rows B) - {v}.\n       (if x = row B j then P $$ (j, THE k. k < m \\<and> x = row B k) - 1\n        else P $$ (j, THE k. k < m \\<and> x = row B k)) *\n       x $ i) =\n    gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) $\n    i", "by (rule gs.lincomb_index[symmetric, OF i_n], insert set_rows_carrier, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set (rows B) - {v}.\n     (if x = row B j then P $$ (j, THE k. k < m \\<and> x = row B k) - 1\n      else P $$ (j, THE k. k < m \\<and> x = row B k)) *\n     x $ i) =\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) $\n  i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (gs.lincomb\n              (\\<lambda>v.\n                  if v = row B j\n                  then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n                  else P $$ (j, THE k. k < m \\<and> v = row B k))\n              (set (rows B) - {v})) \\<Longrightarrow>\n       gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i =\n       gs.lincomb\n        (\\<lambda>v.\n            if v = row B j\n            then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n            else P $$ (j, THE k. k < m \\<and> v = row B k))\n        (set (rows B) - {v}) $\n       i", "finally"], ["proof (chain)\npicking this:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) $\n  i =\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) $\n  i", "show \"?lhs $ i = ?rhs $ i\""], ["proof (prove)\nusing this:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) $\n  i =\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) $\n  i\n\ngoal (1 subgoal):\n 1. gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) $\n    i =\n    gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) $\n    i", "."], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) $\n  i =\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) $\n  i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) =\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v})\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have \"0\\<^sub>v n = gs.lincomb ?f ?set_rows - v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n =\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) -\n    v", "using lincomb_rowBj"], ["proof (prove)\nusing this:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B)) =\n  row B j\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n =\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) -\n    v", "unfolding v_def B_def"], ["proof (prove)\nusing this:\n  gs.lincomb\n   (\\<lambda>v.\n       P $$\n       (j, THE k.\n              k < m \\<and>\n              v = row (of_int_hom.mat_hom (mat_of_rows n fs_init)) k))\n   (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n  row (of_int_hom.mat_hom (mat_of_rows n fs_init)) j\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n =\n    gs.lincomb\n     (\\<lambda>v.\n         P $$\n         (j, THE k.\n                k < m \\<and>\n                v = row (of_int_hom.mat_hom (mat_of_rows n fs_init)) k))\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) -\n    row (of_int_hom.mat_hom (mat_of_rows n fs_init)) j", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v n =\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B)) -\n  v\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  0\\<^sub>v n =\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B)) -\n  v\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have \"... = ?f v \\<cdot>\\<^sub>v v + gs.lincomb ?f (?set_rows-{v}) - v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) -\n    v =\n    P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) -\n    v", "using lincomb_f"], ["proof (prove)\nusing this:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B)) =\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v})\n\ngoal (1 subgoal):\n 1. gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) -\n    v =\n    P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) -\n    v", "by auto"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B)) -\n  v =\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) -\n  v\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B)) -\n  v =\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) -\n  v\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have \"... = (gs.lincomb ?f (?set_rows-{v}) + ?f v \\<cdot>\\<^sub>v v) + - v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) -\n    v =\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) +\n    P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n    - v", "unfolding gs.M.a_comm[OF lincomb_f_closed fv_v_closed]"], ["proof (prove)\ngoal (1 subgoal):\n 1. P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) -\n    v =\n    P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) +\n    - v", "by auto"], ["proof (state)\nthis:\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) -\n  v =\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n  - v\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) -\n  v =\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n  - v\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have \"... = gs.lincomb ?f (?set_rows-{v}) + (?f v \\<cdot>\\<^sub>v v + - v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) +\n    P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n    - v =\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) +\n    (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v + - v)", "by (rule gs.M.a_assoc, auto)"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n  - v =\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v + - v)\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v +\n  - v =\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v + - v)\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have \"... = gs.lincomb ?f (?set_rows-{v}) + (?f v \\<cdot>\\<^sub>v v - v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) +\n    (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v + - v) =\n    gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) +\n    (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v - v)", "by auto"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v + - v) =\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v - v)\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v + - v) =\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v - v)\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have \"... = gs.lincomb ?g (?set_rows-{v}) + (?g v \\<cdot>\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) +\n    (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v - v) =\n    gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) +\n    (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n    v", "unfolding lincomb_fg fvv_gvv"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) +\n    (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n    v =\n    gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) +\n    (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n    v", "by auto"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v - v) =\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n  v\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  gs.lincomb (\\<lambda>v. P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (P $$ (j, THE k. k < m \\<and> v = row B k) \\<cdot>\\<^sub>v v - v) =\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n  v\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have \"... = (?g v \\<cdot>\\<^sub>v v) + gs.lincomb ?g (?set_rows-{v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) +\n    (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n    v =\n    (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n    v +\n    gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v})", "by (rule gs.M.a_comm, auto, rule gs.lincomb_closed, insert set_rows_carrier, auto)"], ["proof (state)\nthis:\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n  v =\n  (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n  v +\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v})\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "also"], ["proof (state)\nthis:\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) +\n  (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n  v =\n  (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n  v +\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v})\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "have \"... = gs.lincomb ?g (?set_rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n    v +\n    gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B) - {v}) =\n    gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B))", "by (rule gs.lincomb_del2[symmetric], insert v_set_rows set_rows_carrier, auto)"], ["proof (state)\nthis:\n  (if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> v = row B k)) \\<cdot>\\<^sub>v\n  v +\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B) - {v}) =\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B))\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", "finally"], ["proof (chain)\npicking this:\n  0\\<^sub>v n =\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B))", "show ?thesis"], ["proof (prove)\nusing this:\n  0\\<^sub>v n =\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B))\n\ngoal (1 subgoal):\n 1. gs.lincomb\n     (\\<lambda>v.\n         if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n         else P $$ (j, THE k. k < m \\<and> v = row B k))\n     (set (rows B)) =\n    0\\<^sub>v n", ".."], ["proof (state)\nthis:\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B)) =\n  0\\<^sub>v n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs.lincomb\n   (\\<lambda>v.\n       if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n       else P $$ (j, THE k. k < m \\<and> v = row B k))\n   (set (rows B)) =\n  0\\<^sub>v n\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "have g0: \"?g \\<in> ?set_rows \\<rightarrow> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n        else P $$ (j, THE k. k < m \\<and> v = row B k))\n    \\<in> set (rows B) \\<rightarrow> {0}", "by (rule gs.not_lindepD[of ?set_rows, OF ind_set_rows _ _ _ lincomb_0], auto)"], ["proof (state)\nthis:\n  (\\<lambda>v.\n      if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n      else P $$ (j, THE k. k < m \\<and> v = row B k))\n  \\<in> set (rows B) \\<rightarrow> {0}\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "hence \"?g (row B j) = 0\""], ["proof (prove)\nusing this:\n  (\\<lambda>v.\n      if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n      else P $$ (j, THE k. k < m \\<and> v = row B k))\n  \\<in> set (rows B) \\<rightarrow> {0}\n\ngoal (1 subgoal):\n 1. (if row B j = row B j\n     then P $$ (j, THE k. k < m \\<and> row B j = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> row B j = row B k)) =\n    0", "using v_set_rows"], ["proof (prove)\nusing this:\n  (\\<lambda>v.\n      if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n      else P $$ (j, THE k. k < m \\<and> v = row B k))\n  \\<in> set (rows B) \\<rightarrow> {0}\n  v \\<in> set (rows B)\n\ngoal (1 subgoal):\n 1. (if row B j = row B j\n     then P $$ (j, THE k. k < m \\<and> row B j = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> row B j = row B k)) =\n    0", "unfolding v_def Pi_def"], ["proof (prove)\nusing this:\n  (\\<lambda>v.\n      if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n      else P $$ (j, THE k. k < m \\<and> v = row B k))\n  \\<in> {f. \\<forall>x.\n               x \\<in> set (rows B) \\<longrightarrow> f x \\<in> {0}}\n  row B j \\<in> set (rows B)\n\ngoal (1 subgoal):\n 1. (if row B j = row B j\n     then P $$ (j, THE k. k < m \\<and> row B j = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> row B j = row B k)) =\n    0", "by blast"], ["proof (state)\nthis:\n  (if row B j = row B j\n   then P $$ (j, THE k. k < m \\<and> row B j = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> row B j = row B k)) =\n  0\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "hence \"?f (row B j) - 1 = 0\""], ["proof (prove)\nusing this:\n  (if row B j = row B j\n   then P $$ (j, THE k. k < m \\<and> row B j = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> row B j = row B k)) =\n  0\n\ngoal (1 subgoal):\n 1. P $$ (j, THE k. k < m \\<and> row B j = row B k) - 1 = 0", "by auto"], ["proof (state)\nthis:\n  P $$ (j, THE k. k < m \\<and> row B j = row B k) - 1 = 0\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "hence \"P $$ (j,j) - 1 = 0\""], ["proof (prove)\nusing this:\n  P $$ (j, THE k. k < m \\<and> row B j = row B k) - 1 = 0\n\ngoal (1 subgoal):\n 1. P $$ (j, j) - 1 = 0", "using the_x j"], ["proof (prove)\nusing this:\n  P $$ (j, THE k. k < m \\<and> row B j = row B k) - 1 = 0\n  ?x1 < m \\<Longrightarrow> (THE k. k < m \\<and> row B ?x1 = row B k) = ?x1\n  j < m\n\ngoal (1 subgoal):\n 1. P $$ (j, j) - 1 = 0", "by auto"], ["proof (state)\nthis:\n  P $$ (j, j) - 1 = 0\n\ngoal (4 subgoals):\n 1. \\<And>j. j < m \\<Longrightarrow> P $$ (j, j) = 1\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 3. dim_row P = m\n 4. dim_col P = m", "thus \"P$$(j,j) = 1\""], ["proof (prove)\nusing this:\n  P $$ (j, j) - 1 = 0\n\ngoal (1 subgoal):\n 1. P $$ (j, j) = 1", "by auto"], ["proof (state)\nthis:\n  P $$ (j, j) = 1\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 2. dim_row P = m\n 3. dim_col P = m", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 2. dim_row P = m\n 3. dim_col P = m", "assume i: \"i < m\" and ji: \"j \\<noteq> i\""], ["proof (state)\nthis:\n  i < m\n  j \\<noteq> i\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 2. dim_row P = m\n 3. dim_col P = m", "have row_ij: \"row B i \\<noteq> row B j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row B i \\<noteq> row B j", "using inj_on_rowB ji i j"], ["proof (prove)\nusing this:\n  inj_on (row B) {0..<m}\n  j \\<noteq> i\n  i < m\n  j < m\n\ngoal (1 subgoal):\n 1. row B i \\<noteq> row B j", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..<m}.\n     \\<forall>y\\<in>{0..<m}. row B x = row B y \\<longrightarrow> x = y\n  j \\<noteq> i\n  i < m\n  j < m\n\ngoal (1 subgoal):\n 1. row B i \\<noteq> row B j", "by fastforce"], ["proof (state)\nthis:\n  row B i \\<noteq> row B j\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 2. dim_row P = m\n 3. dim_col P = m", "have \"row B i \\<in> ?set_rows\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row B i \\<in> set (rows B)", "using nth_rows i"], ["proof (prove)\nusing this:\n  ?i < dim_row ?A \\<Longrightarrow> rows ?A ! ?i = row ?A ?i\n  i < m\n\ngoal (1 subgoal):\n 1. row B i \\<in> set (rows B)", "by (metis B_carrier carrier_matD(1) length_rows nth_mem)"], ["proof (state)\nthis:\n  row B i \\<in> set (rows B)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 2. dim_row P = m\n 3. dim_col P = m", "hence \"?g (row B i) = 0\""], ["proof (prove)\nusing this:\n  row B i \\<in> set (rows B)\n\ngoal (1 subgoal):\n 1. (if row B i = row B j\n     then P $$ (j, THE k. k < m \\<and> row B i = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> row B i = row B k)) =\n    0", "using g0"], ["proof (prove)\nusing this:\n  row B i \\<in> set (rows B)\n  (\\<lambda>v.\n      if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n      else P $$ (j, THE k. k < m \\<and> v = row B k))\n  \\<in> set (rows B) \\<rightarrow> {0}\n\ngoal (1 subgoal):\n 1. (if row B i = row B j\n     then P $$ (j, THE k. k < m \\<and> row B i = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> row B i = row B k)) =\n    0", "unfolding Pi_def"], ["proof (prove)\nusing this:\n  row B i \\<in> set (rows B)\n  (\\<lambda>v.\n      if v = row B j then P $$ (j, THE k. k < m \\<and> v = row B k) - 1\n      else P $$ (j, THE k. k < m \\<and> v = row B k))\n  \\<in> {f. \\<forall>x.\n               x \\<in> set (rows B) \\<longrightarrow> f x \\<in> {0}}\n\ngoal (1 subgoal):\n 1. (if row B i = row B j\n     then P $$ (j, THE k. k < m \\<and> row B i = row B k) - 1\n     else P $$ (j, THE k. k < m \\<and> row B i = row B k)) =\n    0", "by blast"], ["proof (state)\nthis:\n  (if row B i = row B j\n   then P $$ (j, THE k. k < m \\<and> row B i = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> row B i = row B k)) =\n  0\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 2. dim_row P = m\n 3. dim_col P = m", "hence \"?f (row B i) = 0\""], ["proof (prove)\nusing this:\n  (if row B i = row B j\n   then P $$ (j, THE k. k < m \\<and> row B i = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> row B i = row B k)) =\n  0\n\ngoal (1 subgoal):\n 1. P $$ (j, THE k. k < m \\<and> row B i = row B k) = 0", "using row_ij"], ["proof (prove)\nusing this:\n  (if row B i = row B j\n   then P $$ (j, THE k. k < m \\<and> row B i = row B k) - 1\n   else P $$ (j, THE k. k < m \\<and> row B i = row B k)) =\n  0\n  row B i \\<noteq> row B j\n\ngoal (1 subgoal):\n 1. P $$ (j, THE k. k < m \\<and> row B i = row B k) = 0", "by auto"], ["proof (state)\nthis:\n  P $$ (j, THE k. k < m \\<and> row B i = row B k) = 0\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < m; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> P $$ (i, j) = 0\n 2. dim_row P = m\n 3. dim_col P = m", "thus \"P $$ (j, i) = 0\""], ["proof (prove)\nusing this:\n  P $$ (j, THE k. k < m \\<and> row B i = row B k) = 0\n\ngoal (1 subgoal):\n 1. P $$ (j, i) = 0", "using the_x i"], ["proof (prove)\nusing this:\n  P $$ (j, THE k. k < m \\<and> row B i = row B k) = 0\n  ?x1 < m \\<Longrightarrow> (THE k. k < m \\<and> row B ?x1 = row B k) = ?x1\n  i < m\n\ngoal (1 subgoal):\n 1. P $$ (j, i) = 0", "by auto"], ["proof (state)\nthis:\n  P $$ (j, i) = 0\n\ngoal (2 subgoals):\n 1. dim_row P = m\n 2. dim_col P = m", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_row P = m\n 2. dim_col P = m", "show \"dim_row P = m\" and \"dim_col P = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row P = m &&& dim_col P = m", "using P_carrier"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. dim_row P = m &&& dim_col P = m", "unfolding carrier_mat_def"], ["proof (prove)\nusing this:\n  P \\<in> {ma. dim_row ma = m \\<and> dim_col ma = m}\n\ngoal (1 subgoal):\n 1. dim_row P = m &&& dim_col P = m", "by auto"], ["proof (state)\nthis:\n  dim_row P = m\n  dim_col P = m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P = 1\\<^sub>m m\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This is the key lemma. It permits to change from the initial basis\n@{term fs_init} to an arbitrary @{term gs} that has been computed by some\nexternal tool. Here, two change-of-basis matrices U1 and U2 are required \nto certify the change via the conditions prod1 and prod2.\\<close>"], ["", "lemma LLL_change_basis: assumes gs: \"set gs \\<subseteq> carrier_vec n\" \n  and len': \"length gs = m\" \n  and U1: \"U1 \\<in> carrier_mat m m\" \n  and U2: \"U2 \\<in> carrier_mat m m\" \n  and prod1: \"mat_of_rows n fs_init = U1 * mat_of_rows n gs\" \n  and prod2: \"mat_of_rows n gs = U2 * mat_of_rows n fs_init\" \nshows \"lattice_of gs = lattice_of fs_init\" \"LLL_with_assms n m gs \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs_init &&& LLL_with_assms n m gs \\<alpha>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "let ?i = \"of_int :: int \\<Rightarrow> int\""], ["proof (state)\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "have \"U1 = map_mat ?i U1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U1 = of_int_hom.mat_hom U1", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  U1 = of_int_hom.mat_hom U1\n\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "with prod1"], ["proof (chain)\npicking this:\n  mat_of_rows n fs_init = U1 * mat_of_rows n gs\n  U1 = of_int_hom.mat_hom U1", "have prod1: \"mat_of_rows n fs_init = map_mat ?i U1 * mat_of_rows n gs\""], ["proof (prove)\nusing this:\n  mat_of_rows n fs_init = U1 * mat_of_rows n gs\n  U1 = of_int_hom.mat_hom U1\n\ngoal (1 subgoal):\n 1. mat_of_rows n fs_init = of_int_hom.mat_hom U1 * mat_of_rows n gs", "by simp"], ["proof (state)\nthis:\n  mat_of_rows n fs_init = of_int_hom.mat_hom U1 * mat_of_rows n gs\n\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "have \"U2 = map_mat ?i U2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U2 = of_int_hom.mat_hom U2", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  U2 = of_int_hom.mat_hom U2\n\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "with prod2"], ["proof (chain)\npicking this:\n  mat_of_rows n gs = U2 * mat_of_rows n fs_init\n  U2 = of_int_hom.mat_hom U2", "have prod2: \"mat_of_rows n gs = map_mat ?i U2 * mat_of_rows n fs_init\""], ["proof (prove)\nusing this:\n  mat_of_rows n gs = U2 * mat_of_rows n fs_init\n  U2 = of_int_hom.mat_hom U2\n\ngoal (1 subgoal):\n 1. mat_of_rows n gs = of_int_hom.mat_hom U2 * mat_of_rows n fs_init", "by simp"], ["proof (state)\nthis:\n  mat_of_rows n gs = of_int_hom.mat_hom U2 * mat_of_rows n fs_init\n\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "have \"lattice_of gs \\<subseteq> lattice_of fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of gs \\<subseteq> lattice_of fs_init", "by (rule mat_mult_sub_lattice[OF gs fs_init _ prod2], auto simp: U2 len len')"], ["proof (state)\nthis:\n  lattice_of gs \\<subseteq> lattice_of fs_init\n\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "moreover"], ["proof (state)\nthis:\n  lattice_of gs \\<subseteq> lattice_of fs_init\n\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "have \"lattice_of gs \\<supseteq> lattice_of fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of fs_init \\<subseteq> lattice_of gs", "by (rule mat_mult_sub_lattice[OF fs_init gs _ prod1], auto simp: U1 len len')"], ["proof (state)\nthis:\n  lattice_of fs_init \\<subseteq> lattice_of gs\n\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "ultimately"], ["proof (chain)\npicking this:\n  lattice_of gs \\<subseteq> lattice_of fs_init\n  lattice_of fs_init \\<subseteq> lattice_of gs", "show \"lattice_of gs = lattice_of fs_init\""], ["proof (prove)\nusing this:\n  lattice_of gs \\<subseteq> lattice_of fs_init\n  lattice_of fs_init \\<subseteq> lattice_of gs\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs_init", "by blast"], ["proof (state)\nthis:\n  lattice_of gs = lattice_of fs_init\n\ngoal (1 subgoal):\n 1. LLL_with_assms n m gs \\<alpha>", "show \"LLL_with_assms n m gs \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_with_assms n m gs \\<alpha>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. 4 / 3 \\<le> \\<alpha>\n 2. gs.lin_indpt_list (map of_int_hom.vec_hom gs)\n 3. length gs = m", "show \"4/3 \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 / 3 \\<le> \\<alpha>", "by (rule \\<alpha>)"], ["proof (state)\nthis:\n  4 / 3 \\<le> \\<alpha>\n\ngoal (2 subgoals):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)\n 2. length gs = m", "show \"length gs = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length gs = m", "by fact"], ["proof (state)\nthis:\n  length gs = m\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "show \"lin_indep gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "let ?fs = \"map_mat rat_of_int (mat_of_rows n fs_init)\""], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "let ?gs = \"map_mat rat_of_int (mat_of_rows n gs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "let ?U1 = \"map_mat rat_of_int U1\""], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "let ?U2 = \"map_mat rat_of_int U2\""], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "let ?P = \"?U1 * ?U2\""], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have rows_gs_eq: \"rows ?gs = map of_int_hom.vec_hom gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rows (of_int_hom.mat_hom (mat_of_rows n gs)) = map of_int_hom.vec_hom gs", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (rows (of_int_hom.mat_hom (mat_of_rows n gs))) =\n    length (map of_int_hom.vec_hom gs)\n 2. \\<And>i.\n       i < length\n            (rows (of_int_hom.mat_hom (mat_of_rows n gs))) \\<Longrightarrow>\n       rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n       map of_int_hom.vec_hom gs ! i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length (rows (of_int_hom.mat_hom (mat_of_rows n gs))) =\n    length (map of_int_hom.vec_hom gs)\n 2. \\<And>i.\n       i < length\n            (rows (of_int_hom.mat_hom (mat_of_rows n gs))) \\<Longrightarrow>\n       rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n       map of_int_hom.vec_hom gs ! i", "assume i: \"i < length (rows ?gs)\""], ["proof (state)\nthis:\n  i < length (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n\ngoal (2 subgoals):\n 1. length (rows (of_int_hom.mat_hom (mat_of_rows n gs))) =\n    length (map of_int_hom.vec_hom gs)\n 2. \\<And>i.\n       i < length\n            (rows (of_int_hom.mat_hom (mat_of_rows n gs))) \\<Longrightarrow>\n       rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n       map of_int_hom.vec_hom gs ! i", "have \"rows ?gs ! i = row ?gs i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n    row (of_int_hom.mat_hom (mat_of_rows n gs)) i", "by (rule nth_rows, insert i, auto)"], ["proof (state)\nthis:\n  rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n  row (of_int_hom.mat_hom (mat_of_rows n gs)) i\n\ngoal (2 subgoals):\n 1. length (rows (of_int_hom.mat_hom (mat_of_rows n gs))) =\n    length (map of_int_hom.vec_hom gs)\n 2. \\<And>i.\n       i < length\n            (rows (of_int_hom.mat_hom (mat_of_rows n gs))) \\<Longrightarrow>\n       rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n       map of_int_hom.vec_hom gs ! i", "also"], ["proof (state)\nthis:\n  rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n  row (of_int_hom.mat_hom (mat_of_rows n gs)) i\n\ngoal (2 subgoals):\n 1. length (rows (of_int_hom.mat_hom (mat_of_rows n gs))) =\n    length (map of_int_hom.vec_hom gs)\n 2. \\<And>i.\n       i < length\n            (rows (of_int_hom.mat_hom (mat_of_rows n gs))) \\<Longrightarrow>\n       rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n       map of_int_hom.vec_hom gs ! i", "have \"... = of_int_hom.vec_hom (gs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (of_int_hom.mat_hom (mat_of_rows n gs)) i =\n    of_int_hom.vec_hom (gs ! i)", "by (metis (mono_tags, lifting) gs i index_map_mat(2) length_map length_rows map_carrier_vec \n              mat_of_rows_map mat_of_rows_row nth_map nth_mem rows_mat_of_rows subset_code(1))"], ["proof (state)\nthis:\n  row (of_int_hom.mat_hom (mat_of_rows n gs)) i =\n  of_int_hom.vec_hom (gs ! i)\n\ngoal (2 subgoals):\n 1. length (rows (of_int_hom.mat_hom (mat_of_rows n gs))) =\n    length (map of_int_hom.vec_hom gs)\n 2. \\<And>i.\n       i < length\n            (rows (of_int_hom.mat_hom (mat_of_rows n gs))) \\<Longrightarrow>\n       rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n       map of_int_hom.vec_hom gs ! i", "also"], ["proof (state)\nthis:\n  row (of_int_hom.mat_hom (mat_of_rows n gs)) i =\n  of_int_hom.vec_hom (gs ! i)\n\ngoal (2 subgoals):\n 1. length (rows (of_int_hom.mat_hom (mat_of_rows n gs))) =\n    length (map of_int_hom.vec_hom gs)\n 2. \\<And>i.\n       i < length\n            (rows (of_int_hom.mat_hom (mat_of_rows n gs))) \\<Longrightarrow>\n       rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n       map of_int_hom.vec_hom gs ! i", "have \"... = map of_int_hom.vec_hom gs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.vec_hom (gs ! i) = map of_int_hom.vec_hom gs ! i", "by (rule nth_map[symmetric], insert i, auto)"], ["proof (state)\nthis:\n  of_int_hom.vec_hom (gs ! i) = map of_int_hom.vec_hom gs ! i\n\ngoal (2 subgoals):\n 1. length (rows (of_int_hom.mat_hom (mat_of_rows n gs))) =\n    length (map of_int_hom.vec_hom gs)\n 2. \\<And>i.\n       i < length\n            (rows (of_int_hom.mat_hom (mat_of_rows n gs))) \\<Longrightarrow>\n       rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n       map of_int_hom.vec_hom gs ! i", "finally"], ["proof (chain)\npicking this:\n  rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n  map of_int_hom.vec_hom gs ! i", "show \"rows ?gs ! i = map of_int_hom.vec_hom gs ! i\""], ["proof (prove)\nusing this:\n  rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n  map of_int_hom.vec_hom gs ! i\n\ngoal (1 subgoal):\n 1. rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n    map of_int_hom.vec_hom gs ! i", "."], ["proof (state)\nthis:\n  rows (of_int_hom.mat_hom (mat_of_rows n gs)) ! i =\n  map of_int_hom.vec_hom gs ! i\n\ngoal (1 subgoal):\n 1. length (rows (of_int_hom.mat_hom (mat_of_rows n gs))) =\n    length (map of_int_hom.vec_hom gs)", "qed (simp)"], ["proof (state)\nthis:\n  rows (of_int_hom.mat_hom (mat_of_rows n gs)) = map of_int_hom.vec_hom gs\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have fs_hom: \"?fs \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n fs_init) \\<in> carrier_mat m n", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n fs_init)\n    \\<in> {ma. dim_row ma = m \\<and> dim_col ma = n}", "using len"], ["proof (prove)\nusing this:\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n fs_init)\n    \\<in> {ma. dim_row ma = m \\<and> dim_col ma = n}", "by auto"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_rows n fs_init) \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have gs_hom: \"?gs \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n gs) \\<in> carrier_mat m n", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n gs)\n    \\<in> {ma. dim_row ma = m \\<and> dim_col ma = n}", "using len'"], ["proof (prove)\nusing this:\n  length gs = m\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n gs)\n    \\<in> {ma. dim_row ma = m \\<and> dim_col ma = n}", "by auto"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_rows n gs) \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have U1U2: \"U1 * U2 \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U1 * U2 \\<in> carrier_mat m m", "by (meson assms(3) assms(4) mult_carrier_mat)"], ["proof (state)\nthis:\n  U1 * U2 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have U1_hom: \"?U1 \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom U1 \\<in> carrier_mat m m", "by (simp add: U1)"], ["proof (state)\nthis:\n  of_int_hom.mat_hom U1 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have U2_hom: \"?U2 \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom U2 \\<in> carrier_mat m m", "by (simp add: U2)"], ["proof (state)\nthis:\n  of_int_hom.mat_hom U2 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have U1U2_hom: \"?U1 * ?U2 \\<in> carrier_mat m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom U1 * of_int_hom.mat_hom U2 \\<in> carrier_mat m m", "using U1 U2"], ["proof (prove)\nusing this:\n  U1 \\<in> carrier_mat m m\n  U2 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom U1 * of_int_hom.mat_hom U2 \\<in> carrier_mat m m", "by auto"], ["proof (state)\nthis:\n  of_int_hom.mat_hom U1 * of_int_hom.mat_hom U2 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have Gs_U2Fs: \"?gs = ?U2 * ?fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n gs) =\n    of_int_hom.mat_hom U2 * of_int_hom.mat_hom (mat_of_rows n fs_init)", "using prod2"], ["proof (prove)\nusing this:\n  mat_of_rows n gs = of_int_hom.mat_hom U2 * mat_of_rows n fs_init\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n gs) =\n    of_int_hom.mat_hom U2 * of_int_hom.mat_hom (mat_of_rows n fs_init)", "by (metis U2 assms(6) len mat_of_rows_carrier(1) of_int_hom.mat_hom_mult)"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_rows n gs) =\n  of_int_hom.mat_hom U2 * of_int_hom.mat_hom (mat_of_rows n fs_init)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have fs_hom_eq: \"?fs = ?P * ?fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_rows n fs_init) =\n    of_int_hom.mat_hom U1 * of_int_hom.mat_hom U2 *\n    of_int_hom.mat_hom (mat_of_rows n fs_init)", "by (smt U1 U1U2 U2 assms(5) assms(6) assoc_mult_mat fs_hom \n            map_carrier_mat of_int_hom.mat_hom_mult)"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_rows n fs_init) =\n  of_int_hom.mat_hom U1 * of_int_hom.mat_hom U2 *\n  of_int_hom.mat_hom (mat_of_rows n fs_init)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have P_id: \"?P = 1\\<^sub>m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom U1 * of_int_hom.mat_hom U2 = 1\\<^sub>m m", "by (rule mult_left_identity[OF U1U2_hom fs_hom_eq[symmetric]])"], ["proof (state)\nthis:\n  of_int_hom.mat_hom U1 * of_int_hom.mat_hom U2 = 1\\<^sub>m m\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "hence \"det (?U1) * det (?U2) = 1\""], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom U1 * of_int_hom.mat_hom U2 = 1\\<^sub>m m\n\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom U1) * det (of_int_hom.mat_hom U2) = 1", "by (smt U1_hom U2_hom det_mult det_one of_int_hom.hom_det)"], ["proof (state)\nthis:\n  det (of_int_hom.mat_hom U1) * det (of_int_hom.mat_hom U2) = 1\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "hence det_U2: \"det ?U2 \\<noteq> 0\" and det_U1: \"det ?U1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  det (of_int_hom.mat_hom U1) * det (of_int_hom.mat_hom U2) = 1\n\ngoal (1 subgoal):\n 1. det (of_int_hom.mat_hom U2) \\<noteq> 0 &&&\n    det (of_int_hom.mat_hom U1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  det (of_int_hom.mat_hom U2) \\<noteq> 0\n  det (of_int_hom.mat_hom U1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "from det_non_zero_imp_unit[OF U2_hom det_U2, unfolded Units_def, of \"()\"]"], ["proof (chain)\npicking this:\n  of_int_hom.mat_hom U2\n  \\<in> {y \\<in> carrier (ring_mat TYPE(rat) m ()).\n         \\<exists>x\\<in>carrier (ring_mat TYPE(rat) m ()).\n            x \\<otimes>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> y =\n            \\<one>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> \\<and>\n            y \\<otimes>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> x =\n            \\<one>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub>}", "have inv_U2: \"invertible_mat ?U2\""], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom U2\n  \\<in> {y \\<in> carrier (ring_mat TYPE(rat) m ()).\n         \\<exists>x\\<in>carrier (ring_mat TYPE(rat) m ()).\n            x \\<otimes>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> y =\n            \\<one>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> \\<and>\n            y \\<otimes>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> x =\n            \\<one>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub>}\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom U2)", "using U1_hom U2_hom"], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom U2\n  \\<in> {y \\<in> carrier (ring_mat TYPE(rat) m ()).\n         \\<exists>x\\<in>carrier (ring_mat TYPE(rat) m ()).\n            x \\<otimes>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> y =\n            \\<one>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> \\<and>\n            y \\<otimes>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> x =\n            \\<one>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub>}\n  of_int_hom.mat_hom U1 \\<in> carrier_mat m m\n  of_int_hom.mat_hom U2 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. invertible_mat (of_int_hom.mat_hom U2)", "unfolding invertible_mat_def inverts_mat_def"], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom U2\n  \\<in> {y \\<in> carrier (ring_mat TYPE(rat) m ()).\n         \\<exists>x\\<in>carrier (ring_mat TYPE(rat) m ()).\n            x \\<otimes>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> y =\n            \\<one>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> \\<and>\n            y \\<otimes>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub> x =\n            \\<one>\\<^bsub>ring_mat TYPE(rat) m ()\\<^esub>}\n  of_int_hom.mat_hom U1 \\<in> carrier_mat m m\n  of_int_hom.mat_hom U2 \\<in> carrier_mat m m\n\ngoal (1 subgoal):\n 1. square_mat (of_int_hom.mat_hom U2) \\<and>\n    (\\<exists>B.\n        of_int_hom.mat_hom U2 * B =\n        1\\<^sub>m (dim_row (of_int_hom.mat_hom U2)) \\<and>\n        B * of_int_hom.mat_hom U2 = 1\\<^sub>m (dim_row B))", "by (auto simp: ring_mat_def)"], ["proof (state)\nthis:\n  invertible_mat (of_int_hom.mat_hom U2)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "interpret Rs: vectorspace class_ring \"(gs.vs (gs.row_space ?gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring\n     (gs.vs (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))", "by (rule gs.vector_space_row_space[OF gs_hom])"], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "interpret RS_fs: vectorspace class_ring \"(gs.vs (gs.row_space (?fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring\n     (gs.vs (gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "by (rule gs.vector_space_row_space[OF fs_hom])"], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have submoduleGS: \"submodule class_ring (gs.row_space ?gs) gs.V\"\n        and submoduleFS: \"submodule class_ring (gs.row_space ?fs) gs.V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LinearCombinations.submodule class_ring\n     (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))) gs.V &&&\n    LinearCombinations.submodule class_ring\n     (gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init))) gs.V", "by (metis gs.row_space_def gs.span_is_submodule index_map_mat(3) \n            mat_of_rows_carrier(3) rows_carrier)+"], ["proof (state)\nthis:\n  LinearCombinations.submodule class_ring\n   (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))) gs.V\n  LinearCombinations.submodule class_ring\n   (gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init))) gs.V\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have set_rows_fs_in: \"set (rows ?fs) \\<subseteq> gs.row_space ?fs\" \n        and rows_gs_row_space: \"set (rows ?gs) \\<subseteq> gs.row_space ?gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n    \\<subseteq> gs.row_space\n                 (of_int_hom.mat_hom (mat_of_rows n fs_init)) &&&\n    set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n    \\<subseteq> gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))", "unfolding gs.row_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n    \\<subseteq> gs.span\n                 (set (rows\n                        (of_int_hom.mat_hom (mat_of_rows n fs_init)))) &&&\n    set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n    \\<subseteq> gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "by (metis gs.in_own_span index_map_mat(3) mat_of_rows_carrier(3) rows_carrier)+"], ["proof (state)\nthis:\n  set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n  \\<subseteq> gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init))\n  set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n  \\<subseteq> gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have Rs_fs_dim: \"RS_fs.dim = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RS_fs.dim = m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. RS_fs.dim = m", "have \"RS_fs.dim = card (set (rows ?fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RS_fs.dim =\n    card (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "proof (rule RS_fs.dim_basis)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. RS_fs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "have \"RS_fs.span (set (rows ?fs)) = gs.span (set (rows ?fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RS_fs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n    gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "by (rule gs.span_li_not_depend[OF _ submoduleFS], simp add: set_rows_fs_in)"], ["proof (state)\nthis:\n  RS_fs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n  gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (2 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. RS_fs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "also"], ["proof (state)\nthis:\n  RS_fs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n  gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (2 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. RS_fs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "have \"... = carrier (gs.vs (gs.row_space ?fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n    carrier\n     (gs.vs (gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "unfolding gs.row_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n    carrier\n     (gs.vs\n       (gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))))", "unfolding gs.carrier_vs_is_self"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n    gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "by auto"], ["proof (state)\nthis:\n  gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n  carrier\n   (gs.vs (gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (2 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. RS_fs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "finally"], ["proof (chain)\npicking this:\n  RS_fs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "have \"RS_fs.gen_set (set (rows ?fs))\""], ["proof (prove)\nusing this:\n  RS_fs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (1 subgoal):\n 1. RS_fs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "by auto"], ["proof (state)\nthis:\n  RS_fs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (2 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. RS_fs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "moreover"], ["proof (state)\nthis:\n  RS_fs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (2 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. RS_fs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "have \"RS_fs.lin_indpt (set (rows ?fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RS_fs.lin_indpt\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. RS_fs.lin_indpt\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "have \"module.lin_dep class_ring (gs.vs (gs.row_space ?fs)) (set (rows ?fs)) \n              = gs.lin_dep (set (rows ?fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RS_fs.lin_dep\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n    gs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "by (rule gs.span_li_not_depend[OF _ submoduleFS], simp add: set_rows_fs_in)"], ["proof (state)\nthis:\n  RS_fs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n  gs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (1 subgoal):\n 1. RS_fs.lin_indpt\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  RS_fs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n  gs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (1 subgoal):\n 1. RS_fs.lin_indpt\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "using lin_dep"], ["proof (prove)\nusing this:\n  RS_fs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n  gs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs_init)\n\ngoal (1 subgoal):\n 1. RS_fs.lin_indpt\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "unfolding gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  RS_fs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) =\n  gs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn \\<and>\n  distinct (map of_int_hom.vec_hom fs_init) \\<and>\n  gs.lin_indpt (set (map of_int_hom.vec_hom fs_init))\n\ngoal (1 subgoal):\n 1. RS_fs.lin_indpt\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "by (metis fs_init mat_of_rows_map rows_mat_of_rows)"], ["proof (state)\nthis:\n  RS_fs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  RS_fs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (2 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. RS_fs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "moreover"], ["proof (state)\nthis:\n  RS_fs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (2 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. RS_fs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "have \"set (rows ?fs) \\<subseteq> carrier (gs.vs (gs.row_space ?fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n    \\<subseteq> carrier\n                 (gs.vs\n                   (gs.row_space\n                     (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "by (simp add: set_rows_fs_in)"], ["proof (state)\nthis:\n  set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n  \\<subseteq> carrier\n               (gs.vs\n                 (gs.row_space\n                   (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (2 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n 2. RS_fs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "ultimately"], ["proof (chain)\npicking this:\n  RS_fs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n  RS_fs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n  set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n  \\<subseteq> carrier\n               (gs.vs\n                 (gs.row_space\n                   (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "show \"RS_fs.basis (set (rows ?fs))\""], ["proof (prove)\nusing this:\n  RS_fs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n  RS_fs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n  set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n  \\<subseteq> carrier\n               (gs.vs\n                 (gs.row_space\n                   (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (1 subgoal):\n 1. RS_fs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "unfolding RS_fs.basis_def"], ["proof (prove)\nusing this:\n  RS_fs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n  RS_fs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n  set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n  \\<subseteq> carrier\n               (gs.vs\n                 (gs.row_space\n                   (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (1 subgoal):\n 1. RS_fs.lin_indpt\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) \\<and>\n    RS_fs.gen_set\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) \\<and>\n    set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))\n    \\<subseteq> carrier\n                 (gs.vs\n                   (gs.row_space\n                     (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "by simp"], ["proof (state)\nthis:\n  RS_fs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (1 subgoal):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))", "qed (simp)"], ["proof (state)\nthis:\n  RS_fs.dim = card (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (1 subgoal):\n 1. RS_fs.dim = m", "also"], ["proof (state)\nthis:\n  RS_fs.dim = card (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init))))\n\ngoal (1 subgoal):\n 1. RS_fs.dim = m", "have \"... = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) = m", "by (metis cof_vec_space.lin_indpt_list_def distinct_card fs_init len \n              length_map lin_dep mat_of_rows_map rows_mat_of_rows)"], ["proof (state)\nthis:\n  card (set (rows (of_int_hom.mat_hom (mat_of_rows n fs_init)))) = m\n\ngoal (1 subgoal):\n 1. RS_fs.dim = m", "finally"], ["proof (chain)\npicking this:\n  RS_fs.dim = m", "show ?thesis"], ["proof (prove)\nusing this:\n  RS_fs.dim = m\n\ngoal (1 subgoal):\n 1. RS_fs.dim = m", "."], ["proof (state)\nthis:\n  RS_fs.dim = m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  RS_fs.dim = m\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have \"gs.row_space ?fs = gs.row_space (?U2*?fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n    gs.row_space\n     (of_int_hom.mat_hom U2 * of_int_hom.mat_hom (mat_of_rows n fs_init))", "by (rule gs.row_space_is_preserved[symmetric, OF inv_U2 U2_hom fs_hom])"], ["proof (state)\nthis:\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  gs.row_space\n   (of_int_hom.mat_hom U2 * of_int_hom.mat_hom (mat_of_rows n fs_init))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "also"], ["proof (state)\nthis:\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  gs.row_space\n   (of_int_hom.mat_hom U2 * of_int_hom.mat_hom (mat_of_rows n fs_init))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have \"... = gs.row_space ?gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.row_space\n     (of_int_hom.mat_hom U2 * of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n    gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))", "using Gs_U2Fs"], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom (mat_of_rows n gs) =\n  of_int_hom.mat_hom U2 * of_int_hom.mat_hom (mat_of_rows n fs_init)\n\ngoal (1 subgoal):\n 1. gs.row_space\n     (of_int_hom.mat_hom U2 * of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n    gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))", "by auto"], ["proof (state)\nthis:\n  gs.row_space\n   (of_int_hom.mat_hom U2 * of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "finally"], ["proof (chain)\npicking this:\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))", "have \"gs.row_space ?fs = gs.row_space ?gs\""], ["proof (prove)\nusing this:\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n    gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))", "by auto"], ["proof (state)\nthis:\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "hence \"vectorspace.dim class_ring (gs.vs (gs.row_space ?gs)) = m\""], ["proof (prove)\nusing this:\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. Rs.dim = m", "using Rs_fs_dim fs_hom_eq"], ["proof (prove)\nusing this:\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n fs_init)) =\n  gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))\n  RS_fs.dim = m\n  of_int_hom.mat_hom (mat_of_rows n fs_init) =\n  of_int_hom.mat_hom U1 * of_int_hom.mat_hom U2 *\n  of_int_hom.mat_hom (mat_of_rows n fs_init)\n\ngoal (1 subgoal):\n 1. Rs.dim = m", "by auto"], ["proof (state)\nthis:\n  Rs.dim = m\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "hence Rs_dim_is_m: \"Rs.dim = m\""], ["proof (prove)\nusing this:\n  Rs.dim = m\n\ngoal (1 subgoal):\n 1. Rs.dim = m", "by blast"], ["proof (state)\nthis:\n  Rs.dim = m\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have card_set_rows: \"card (set (rows ?gs)) \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<le> m", "by (metis assms(2) card_length length_map rows_gs_eq)"], ["proof (state)\nthis:\n  card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<le> m\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have Rs_basis: \"Rs.basis (set (rows ?gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "proof (rule Rs.dim_gen_is_basis)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n 2. set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n    \\<subseteq> carrier\n                 (gs.vs\n                   (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))\n 3. Rs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n 4. card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<le> Rs.dim", "show \"card (set (rows ?gs)) \\<le> Rs.dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<le> Rs.dim", "using card_set_rows Rs_dim_is_m"], ["proof (prove)\nusing this:\n  card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<le> m\n  Rs.dim = m\n\ngoal (1 subgoal):\n 1. card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<le> Rs.dim", "by auto"], ["proof (state)\nthis:\n  card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<le> Rs.dim\n\ngoal (3 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n 2. set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n    \\<subseteq> carrier\n                 (gs.vs\n                   (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))\n 3. Rs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "have \"Rs.span (set (rows ?gs)) = gs.span (set (rows ?gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) =\n    gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "by (rule gs.span_li_not_depend[OF rows_gs_row_space submoduleGS])"], ["proof (state)\nthis:\n  Rs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) =\n  gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (3 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n 2. set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n    \\<subseteq> carrier\n                 (gs.vs\n                   (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))\n 3. Rs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "also"], ["proof (state)\nthis:\n  Rs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) =\n  gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (3 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n 2. set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n    \\<subseteq> carrier\n                 (gs.vs\n                   (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))\n 3. Rs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "have \"... = carrier (gs.vs (gs.row_space ?gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) =\n    carrier (gs.vs (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))", "unfolding gs.row_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) =\n    carrier\n     (gs.vs (gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))))", "unfolding gs.carrier_vs_is_self"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) =\n    gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "by auto"], ["proof (state)\nthis:\n  gs.span (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) =\n  carrier (gs.vs (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (3 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n 2. set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n    \\<subseteq> carrier\n                 (gs.vs\n                   (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))\n 3. Rs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "finally"], ["proof (chain)\npicking this:\n  Rs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "show \"Rs.gen_set (set (rows ?gs))\""], ["proof (prove)\nusing this:\n  Rs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. Rs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "by auto"], ["proof (state)\nthis:\n  Rs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (2 subgoals):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n 2. set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n    \\<subseteq> carrier\n                 (gs.vs\n                   (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))", "show \"set (rows ?gs) \\<subseteq> carrier (gs.vs (gs.row_space ?gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n    \\<subseteq> carrier\n                 (gs.vs\n                   (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))", "using rows_gs_row_space"], ["proof (prove)\nusing this:\n  set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n  \\<subseteq> gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n    \\<subseteq> carrier\n                 (gs.vs\n                   (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))", "by auto"], ["proof (state)\nthis:\n  set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n  \\<subseteq> carrier\n               (gs.vs\n                 (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. finite (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "qed (simp)"], ["proof (state)\nthis:\n  Rs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "hence indpt_Rs: \"Rs.lin_indpt (set (rows ?gs))\""], ["proof (prove)\nusing this:\n  Rs.basis (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. Rs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "unfolding Rs.basis_def"], ["proof (prove)\nusing this:\n  Rs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<and>\n  Rs.gen_set (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<and>\n  set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n  \\<subseteq> carrier\n               (gs.vs\n                 (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. Rs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "by auto"], ["proof (state)\nthis:\n  Rs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have gs_lin_indpt_rows: \"gs.lin_indpt (set (rows ?gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "(*Is there any automatic way to prove this?*) \n        (*TODO: via gs.span_li_not_depend*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. gs.lin_dep\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<Longrightarrow>\n    False", "define N where \"N \\<equiv> (gs.row_space ?gs)\""], ["proof (state)\nthis:\n  N \\<equiv> gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. gs.lin_dep\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<Longrightarrow>\n    False", "assume \"gs.lin_dep (set (rows ?gs))\""], ["proof (state)\nthis:\n  gs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. gs.lin_dep\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  gs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "obtain A f v where A1: \"finite A\" and A2: \"A \\<subseteq> set (rows ?gs)\"\n          and lc_gs: \"gs.lincomb f A = 0\\<^sub>v n\" and v: \"v \\<in> A\" and fv: \"f v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  gs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. (\\<And>A f v.\n        \\<lbrakk>finite A;\n         A \\<subseteq> set (rows (of_int_hom.mat_hom (mat_of_rows n gs)));\n         gs.lincomb f A = 0\\<^sub>v n; v \\<in> A; f v \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding gs.lin_dep_def"], ["proof (prove)\nusing this:\n  \\<exists>A a v.\n     finite A \\<and>\n     A \\<subseteq> set (rows (of_int_hom.mat_hom (mat_of_rows n gs))) \\<and>\n     True \\<and>\n     gs.lincomb a A = 0\\<^sub>v n \\<and> v \\<in> A \\<and> a v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>A f v.\n        \\<lbrakk>finite A;\n         A \\<subseteq> set (rows (of_int_hom.mat_hom (mat_of_rows n gs)));\n         gs.lincomb f A = 0\\<^sub>v n; v \\<in> A; f v \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite A\n  A \\<subseteq> set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n  gs.lincomb f A = 0\\<^sub>v n\n  v \\<in> A\n  f v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gs.lin_dep\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<Longrightarrow>\n    False", "have \"gs.lincomb f A = module.lincomb (gs.vs N) f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs.lincomb f A = module.lincomb (gs.vs N) f A", "by (rule gs.lincomb_not_depend, insert submoduleGS A1 A2 gs.row_space_def \n              rows_gs_row_space, auto simp add: N_def gs.row_space_def)"], ["proof (state)\nthis:\n  gs.lincomb f A = module.lincomb (gs.vs N) f A\n\ngoal (1 subgoal):\n 1. gs.lin_dep\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  gs.lincomb f A = module.lincomb (gs.vs N) f A\n\ngoal (1 subgoal):\n 1. gs.lin_dep\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<Longrightarrow>\n    False", "have \"... = Rs.lincomb f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module.lincomb (gs.vs N) f A = Rs.lincomb f A", "using N_def"], ["proof (prove)\nusing this:\n  N \\<equiv> gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs))\n\ngoal (1 subgoal):\n 1. module.lincomb (gs.vs N) f A = Rs.lincomb f A", "by blast"], ["proof (state)\nthis:\n  module.lincomb (gs.vs N) f A = Rs.lincomb f A\n\ngoal (1 subgoal):\n 1. gs.lin_dep\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  gs.lincomb f A = Rs.lincomb f A", "have \"Rs.lin_dep (set (rows ?gs))\""], ["proof (prove)\nusing this:\n  gs.lincomb f A = Rs.lincomb f A\n\ngoal (1 subgoal):\n 1. Rs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "unfolding Rs.lin_dep_def"], ["proof (prove)\nusing this:\n  gs.lincomb f A = Rs.lincomb f A\n\ngoal (1 subgoal):\n 1. \\<exists>A a v.\n       finite A \\<and>\n       A \\<subseteq> set (rows\n                           (of_int_hom.mat_hom (mat_of_rows n gs))) \\<and>\n       a \\<in> A \\<rightarrow> carrier class_ring \\<and>\n       Rs.lincomb a A =\n       \\<zero>\\<^bsub>gs.vs (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs)))\\<^esub> \\<and>\n       v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>class_ring\\<^esub>", "using A1 A2 v fv lc_gs"], ["proof (prove)\nusing this:\n  gs.lincomb f A = Rs.lincomb f A\n  finite A\n  A \\<subseteq> set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))\n  v \\<in> A\n  f v \\<noteq> 0\n  gs.lincomb f A = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<exists>A a v.\n       finite A \\<and>\n       A \\<subseteq> set (rows\n                           (of_int_hom.mat_hom (mat_of_rows n gs))) \\<and>\n       a \\<in> A \\<rightarrow> carrier class_ring \\<and>\n       Rs.lincomb a A =\n       \\<zero>\\<^bsub>gs.vs (gs.row_space (of_int_hom.mat_hom (mat_of_rows n gs)))\\<^esub> \\<and>\n       v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>class_ring\\<^esub>", "by auto"], ["proof (state)\nthis:\n  Rs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. gs.lin_dep\n     (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  Rs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. False", "using indpt_Rs"], ["proof (prove)\nusing this:\n  Rs.lin_dep (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n  Rs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have \"card (set (rows ?gs)) \\<ge> Rs.dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs.dim \\<le> card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))", "by (rule Rs.gen_ge_dim, insert rows_gs_row_space Rs_basis, auto simp add: Rs.basis_def)"], ["proof (state)\nthis:\n  Rs.dim \\<le> card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "hence card_m: \"card (set (rows ?gs)) = m\""], ["proof (prove)\nusing this:\n  Rs.dim \\<le> card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) = m", "using card_set_rows Rs_dim_is_m"], ["proof (prove)\nusing this:\n  Rs.dim \\<le> card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n  card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) \\<le> m\n  Rs.dim = m\n\ngoal (1 subgoal):\n 1. card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) = m", "by auto"], ["proof (state)\nthis:\n  card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) = m\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have \"distinct (map (of_int_hom.vec_hom::int vec \\<Rightarrow> rat vec) gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map of_int_hom.vec_hom gs)", "using rows_gs_eq assms(2) card_m card_distinct"], ["proof (prove)\nusing this:\n  rows (of_int_hom.mat_hom (mat_of_rows n gs)) = map of_int_hom.vec_hom gs\n  length gs = m\n  card (set (rows (of_int_hom.mat_hom (mat_of_rows n gs)))) = m\n  card (set ?xs) = length ?xs \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. distinct (map of_int_hom.vec_hom gs)", "by force"], ["proof (state)\nthis:\n  distinct (map of_int_hom.vec_hom gs)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "moreover"], ["proof (state)\nthis:\n  distinct (map of_int_hom.vec_hom gs)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "have \"set (map of_int_hom.vec_hom gs) \\<subseteq> Rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map of_int_hom.vec_hom gs) \\<subseteq> Rn", "using gs"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (map of_int_hom.vec_hom gs) \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  set (map of_int_hom.vec_hom gs) \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (map of_int_hom.vec_hom gs)\n  set (map of_int_hom.vec_hom gs) \\<subseteq> Rn", "show \"gs.lin_indpt_list (map of_int_hom.vec_hom gs)\""], ["proof (prove)\nusing this:\n  distinct (map of_int_hom.vec_hom gs)\n  set (map of_int_hom.vec_hom gs) \\<subseteq> Rn\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "using gs_lin_indpt_rows"], ["proof (prove)\nusing this:\n  distinct (map of_int_hom.vec_hom gs)\n  set (map of_int_hom.vec_hom gs) \\<subseteq> Rn\n  gs.lin_indpt (set (rows (of_int_hom.mat_hom (mat_of_rows n gs))))\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom gs)", "unfolding rows_gs_eq gs.lin_indpt_list_def"], ["proof (prove)\nusing this:\n  distinct (map of_int_hom.vec_hom gs)\n  set (map of_int_hom.vec_hom gs) \\<subseteq> Rn\n  gs.lin_indpt (set (map of_int_hom.vec_hom gs))\n\ngoal (1 subgoal):\n 1. set (map of_int_hom.vec_hom gs) \\<subseteq> Rn \\<and>\n    distinct (map of_int_hom.vec_hom gs) \\<and>\n    gs.lin_indpt (set (map of_int_hom.vec_hom gs))", "by auto"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom gs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom gs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_with_assms n m gs \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_jordan_integer_inverse: fixes fs gs :: \"int vec list\" \n  assumes gs: \"set gs \\<subseteq> carrier_vec n\"\n  and len_gs: \"length gs = n\" \n  and fs: \"set fs \\<subseteq> carrier_vec n\" \n  and len_fs: \"length fs = n\" \n  and gauss: \"gauss_jordan_integer_inverse n (map_mat rat_of_int (mat_of_cols n fs)) \n    (map_mat rat_of_int (mat_of_cols n gs)) (1\\<^sub>m n)\" (is \"gauss_jordan_integer_inverse _ ?fs ?gs _\")\nshows \"\\<exists> U. U \\<in> carrier_mat n n \\<and> mat_of_rows n gs = U * mat_of_rows n fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "have fs': \"?fs \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_cols n fs) \\<in> carrier_mat n n", "using fs len_fs"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  length fs = n\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_cols n fs) \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_cols n fs) \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "have gs': \"?gs \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_cols n gs) \\<in> carrier_mat n n", "using gs len_gs"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier_vec n\n  length gs = n\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_cols n gs) \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_cols n gs) \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "note gauss = gauss[unfolded gauss_jordan_integer_inverse_def]"], ["proof (state)\nthis:\n  case gauss_jordan (of_int_hom.mat_hom (mat_of_cols n fs))\n        (of_int_hom.mat_hom (mat_of_cols n gs)) of\n  (C, D) \\<Rightarrow>\n    C = 1\\<^sub>m n \\<and> list_all is_int_rat (concat (mat_to_list D))\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "from gauss"], ["proof (chain)\npicking this:\n  case gauss_jordan (of_int_hom.mat_hom (mat_of_cols n fs))\n        (of_int_hom.mat_hom (mat_of_cols n gs)) of\n  (C, D) \\<Rightarrow>\n    C = 1\\<^sub>m n \\<and> list_all is_int_rat (concat (mat_to_list D))", "obtain A where gauss: \"gauss_jordan ?fs ?gs = (1\\<^sub>m n, A)\"\n   and int: \"list_all is_int_rat (concat (mat_to_list A))\""], ["proof (prove)\nusing this:\n  case gauss_jordan (of_int_hom.mat_hom (mat_of_cols n fs))\n        (of_int_hom.mat_hom (mat_of_cols n gs)) of\n  (C, D) \\<Rightarrow>\n    C = 1\\<^sub>m n \\<and> list_all is_int_rat (concat (mat_to_list D))\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>gauss_jordan (of_int_hom.mat_hom (mat_of_cols n fs))\n                  (of_int_hom.mat_hom (mat_of_cols n gs)) =\n                 (1\\<^sub>m n, A);\n         list_all is_int_rat (concat (mat_to_list A))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gauss_jordan (of_int_hom.mat_hom (mat_of_cols n fs))\n   (of_int_hom.mat_hom (mat_of_cols n gs)) =\n  (1\\<^sub>m n, A)\n  list_all is_int_rat (concat (mat_to_list A))\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "note gauss = gauss_jordan[OF fs' gs' gauss]"], ["proof (state)\nthis:\n  ?x \\<in> Rn \\<Longrightarrow>\n  (of_int_hom.mat_hom (mat_of_cols n fs) *\\<^sub>v ?x = 0\\<^sub>v n) =\n  (1\\<^sub>m n *\\<^sub>v ?x = 0\\<^sub>v n)\n  ?X \\<in> carrier_mat n n \\<Longrightarrow>\n  (of_int_hom.mat_hom (mat_of_cols n fs) * ?X =\n   of_int_hom.mat_hom (mat_of_cols n gs)) =\n  (1\\<^sub>m n * ?X = A)\n  1\\<^sub>m n \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "note A = gauss(4)"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "let ?A = \"map_mat int_of_rat A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "from gauss(2)[OF A] A"], ["proof (chain)\npicking this:\n  (of_int_hom.mat_hom (mat_of_cols n fs) * A =\n   of_int_hom.mat_hom (mat_of_cols n gs)) =\n  (1\\<^sub>m n * A = A)\n  A \\<in> carrier_mat n n", "have id: \"?fs * A = ?gs\""], ["proof (prove)\nusing this:\n  (of_int_hom.mat_hom (mat_of_cols n fs) * A =\n   of_int_hom.mat_hom (mat_of_cols n gs)) =\n  (1\\<^sub>m n * A = A)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_cols n fs) * A =\n    of_int_hom.mat_hom (mat_of_cols n gs)", "by auto"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_cols n fs) * A =\n  of_int_hom.mat_hom (mat_of_cols n gs)\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "let ?U = \"(map_mat int_of_rat A)\\<^sup>T\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have U: \"?U \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (map_mat int_of_rat A)\\<^sup>T \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  (map_mat int_of_rat A)\\<^sup>T \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "have \"A = map_mat of_int ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = of_int_hom.mat_hom (map_mat int_of_rat A)", "using int[unfolded list_all_iff] A"], ["proof (prove)\nusing this:\n  Ball (set (concat (mat_to_list A))) is_int_rat\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = of_int_hom.mat_hom (map_mat int_of_rat A)", "by (intro eq_matI, auto simp: mat_to_list_def)"], ["proof (state)\nthis:\n  A = of_int_hom.mat_hom (map_mat int_of_rat A)\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "with id"], ["proof (chain)\npicking this:\n  of_int_hom.mat_hom (mat_of_cols n fs) * A =\n  of_int_hom.mat_hom (mat_of_cols n gs)\n  A = of_int_hom.mat_hom (map_mat int_of_rat A)", "have \"?gs = ?fs * map_mat of_int ?A\""], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom (mat_of_cols n fs) * A =\n  of_int_hom.mat_hom (mat_of_cols n gs)\n  A = of_int_hom.mat_hom (map_mat int_of_rat A)\n\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_cols n gs) =\n    of_int_hom.mat_hom (mat_of_cols n fs) *\n    of_int_hom.mat_hom (map_mat int_of_rat A)", "by auto"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_cols n gs) =\n  of_int_hom.mat_hom (mat_of_cols n fs) *\n  of_int_hom.mat_hom (map_mat int_of_rat A)\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "also"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_cols n gs) =\n  of_int_hom.mat_hom (mat_of_cols n fs) *\n  of_int_hom.mat_hom (map_mat int_of_rat A)\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "have \"\\<dots> = map_mat of_int (mat_of_cols n fs * ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_hom.mat_hom (mat_of_cols n fs) *\n    of_int_hom.mat_hom (map_mat int_of_rat A) =\n    of_int_hom.mat_hom (mat_of_cols n fs * map_mat int_of_rat A)", "by (rule of_int_hom.mat_hom_mult[symmetric], insert fs' A, auto)"], ["proof (state)\nthis:\n  of_int_hom.mat_hom (mat_of_cols n fs) *\n  of_int_hom.mat_hom (map_mat int_of_rat A) =\n  of_int_hom.mat_hom (mat_of_cols n fs * map_mat int_of_rat A)\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "finally"], ["proof (chain)\npicking this:\n  of_int_hom.mat_hom (mat_of_cols n gs) =\n  of_int_hom.mat_hom (mat_of_cols n fs * map_mat int_of_rat A)", "have \"mat_of_cols n fs * ?A = mat_of_cols n gs\""], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom (mat_of_cols n gs) =\n  of_int_hom.mat_hom (mat_of_cols n fs * map_mat int_of_rat A)\n\ngoal (1 subgoal):\n 1. mat_of_cols n fs * map_mat int_of_rat A = mat_of_cols n gs", "using of_int_hom.mat_hom_inj"], ["proof (prove)\nusing this:\n  of_int_hom.mat_hom (mat_of_cols n gs) =\n  of_int_hom.mat_hom (mat_of_cols n fs * map_mat int_of_rat A)\n  of_int_hom.mat_hom ?A = of_int_hom.mat_hom ?B \\<Longrightarrow> ?A = ?B\n\ngoal (1 subgoal):\n 1. mat_of_cols n fs * map_mat int_of_rat A = mat_of_cols n gs", "by fastforce"], ["proof (state)\nthis:\n  mat_of_cols n fs * map_mat int_of_rat A = mat_of_cols n gs\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "hence \"(mat_of_cols n gs)\\<^sup>T = (mat_of_cols n fs * ?A)\\<^sup>T\""], ["proof (prove)\nusing this:\n  mat_of_cols n fs * map_mat int_of_rat A = mat_of_cols n gs\n\ngoal (1 subgoal):\n 1. (mat_of_cols n gs)\\<^sup>T =\n    (mat_of_cols n fs * map_mat int_of_rat A)\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  (mat_of_cols n gs)\\<^sup>T =\n  (mat_of_cols n fs * map_mat int_of_rat A)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "also"], ["proof (state)\nthis:\n  (mat_of_cols n gs)\\<^sup>T =\n  (mat_of_cols n fs * map_mat int_of_rat A)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "have \"\\<dots> = ?U * (mat_of_cols n fs)\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_of_cols n fs * map_mat int_of_rat A)\\<^sup>T =\n    (map_mat int_of_rat A)\\<^sup>T * (mat_of_cols n fs)\\<^sup>T", "by (rule transpose_mult, insert fs' A, auto)"], ["proof (state)\nthis:\n  (mat_of_cols n fs * map_mat int_of_rat A)\\<^sup>T =\n  (map_mat int_of_rat A)\\<^sup>T * (mat_of_cols n fs)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "also"], ["proof (state)\nthis:\n  (mat_of_cols n fs * map_mat int_of_rat A)\\<^sup>T =\n  (map_mat int_of_rat A)\\<^sup>T * (mat_of_cols n fs)\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "have \"(mat_of_cols n fs)\\<^sup>T = mat_of_rows n fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_of_cols n fs)\\<^sup>T = mat_of_rows n fs", "using fs len_fs"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  length fs = n\n\ngoal (1 subgoal):\n 1. (mat_of_cols n fs)\\<^sup>T = mat_of_rows n fs", "unfolding mat_of_rows_def mat_of_cols_def"], ["proof (prove)\nusing this:\n  set fs \\<subseteq> carrier_vec n\n  length fs = n\n\ngoal (1 subgoal):\n 1. (mat n (length fs) (\\<lambda>(i, j). fs ! j $ i))\\<^sup>T =\n    mat (length fs) n (\\<lambda>(i, y). fs ! i $ y)", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  (mat_of_cols n fs)\\<^sup>T = mat_of_rows n fs\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "also"], ["proof (state)\nthis:\n  (mat_of_cols n fs)\\<^sup>T = mat_of_rows n fs\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "have \"(mat_of_cols n gs)\\<^sup>T = mat_of_rows n gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_of_cols n gs)\\<^sup>T = mat_of_rows n gs", "using gs len_gs"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier_vec n\n  length gs = n\n\ngoal (1 subgoal):\n 1. (mat_of_cols n gs)\\<^sup>T = mat_of_rows n gs", "unfolding mat_of_rows_def mat_of_cols_def"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier_vec n\n  length gs = n\n\ngoal (1 subgoal):\n 1. (mat n (length gs) (\\<lambda>(i, j). gs ! j $ i))\\<^sup>T =\n    mat (length gs) n (\\<lambda>(i, y). gs ! i $ y)", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  (mat_of_cols n gs)\\<^sup>T = mat_of_rows n gs\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "finally"], ["proof (chain)\npicking this:\n  mat_of_rows n gs = (map_mat int_of_rat A)\\<^sup>T * mat_of_rows n fs", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_of_rows n gs = (map_mat int_of_rat A)\\<^sup>T * mat_of_rows n fs\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "using U"], ["proof (prove)\nusing this:\n  mat_of_rows n gs = (map_mat int_of_rat A)\\<^sup>T * mat_of_rows n fs\n  (map_mat int_of_rat A)\\<^sup>T \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> carrier_mat n n \\<and>\n       mat_of_rows n gs = U * mat_of_rows n fs", "by blast"], ["proof (state)\nthis:\n  \\<exists>U.\n     U \\<in> carrier_mat n n \\<and> mat_of_rows n gs = U * mat_of_rows n fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LLL_change_basis_mat_inverse: assumes gs: \"set gs \\<subseteq> carrier_vec n\" \n  and len': \"length gs = n\" \n  and \"m = n\" \n  and eq: \"integer_equivalent n fs_init gs\" \nshows \"lattice_of gs = lattice_of fs_init\" \"LLL_with_assms n m gs \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs_init &&& LLL_with_assms n m gs \\<alpha>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "from eq[unfolded integer_equivalent_def Let_def]"], ["proof (chain)\npicking this:\n  gauss_jordan_integer_inverse n\n   (of_int_hom.mat_hom (mat_of_cols n fs_init))\n   (of_int_hom.mat_hom (mat_of_cols n gs)) (1\\<^sub>m n) \\<and>\n  gauss_jordan_integer_inverse n (of_int_hom.mat_hom (mat_of_cols n gs))\n   (of_int_hom.mat_hom (mat_of_cols n fs_init)) (1\\<^sub>m n)", "have 1: \"gauss_jordan_integer_inverse n (of_int_hom.mat_hom (mat_of_cols n fs_init))\n   (of_int_hom.mat_hom (mat_of_cols n gs)) (1\\<^sub>m n)\" \n    and 2: \"gauss_jordan_integer_inverse n (of_int_hom.mat_hom (mat_of_cols n gs))\n     (of_int_hom.mat_hom (mat_of_cols n fs_init)) (1\\<^sub>m n)\""], ["proof (prove)\nusing this:\n  gauss_jordan_integer_inverse n\n   (of_int_hom.mat_hom (mat_of_cols n fs_init))\n   (of_int_hom.mat_hom (mat_of_cols n gs)) (1\\<^sub>m n) \\<and>\n  gauss_jordan_integer_inverse n (of_int_hom.mat_hom (mat_of_cols n gs))\n   (of_int_hom.mat_hom (mat_of_cols n fs_init)) (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. gauss_jordan_integer_inverse n\n     (of_int_hom.mat_hom (mat_of_cols n fs_init))\n     (of_int_hom.mat_hom (mat_of_cols n gs)) (1\\<^sub>m n) &&&\n    gauss_jordan_integer_inverse n (of_int_hom.mat_hom (mat_of_cols n gs))\n     (of_int_hom.mat_hom (mat_of_cols n fs_init)) (1\\<^sub>m n)", "by auto"], ["proof (state)\nthis:\n  gauss_jordan_integer_inverse n\n   (of_int_hom.mat_hom (mat_of_cols n fs_init))\n   (of_int_hom.mat_hom (mat_of_cols n gs)) (1\\<^sub>m n)\n  gauss_jordan_integer_inverse n (of_int_hom.mat_hom (mat_of_cols n gs))\n   (of_int_hom.mat_hom (mat_of_cols n fs_init)) (1\\<^sub>m n)\n\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "note len = len[unfolded \\<open>m = n\\<close>]"], ["proof (state)\nthis:\n  length fs_init = n\n\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "from gauss_jordan_integer_inverse[OF gs len' fs_init len 1] \\<open>m = n\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>U.\n     U \\<in> carrier_mat n n \\<and>\n     mat_of_rows n gs = U * mat_of_rows n fs_init\n  m = n", "obtain U where U: \"U \\<in> carrier_mat m m\" \"mat_of_rows n gs = U * mat_of_rows n fs_init\""], ["proof (prove)\nusing this:\n  \\<exists>U.\n     U \\<in> carrier_mat n n \\<and>\n     mat_of_rows n gs = U * mat_of_rows n fs_init\n  m = n\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        \\<lbrakk>U \\<in> carrier_mat m m;\n         mat_of_rows n gs = U * mat_of_rows n fs_init\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  U \\<in> carrier_mat m m\n  mat_of_rows n gs = U * mat_of_rows n fs_init\n\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "from gauss_jordan_integer_inverse[OF fs_init len gs len' 2] \\<open>m = n\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>U.\n     U \\<in> carrier_mat n n \\<and>\n     mat_of_rows n fs_init = U * mat_of_rows n gs\n  m = n", "obtain V where V: \"V \\<in> carrier_mat m m\" \"mat_of_rows n fs_init = V * mat_of_rows n gs\""], ["proof (prove)\nusing this:\n  \\<exists>U.\n     U \\<in> carrier_mat n n \\<and>\n     mat_of_rows n fs_init = U * mat_of_rows n gs\n  m = n\n\ngoal (1 subgoal):\n 1. (\\<And>V.\n        \\<lbrakk>V \\<in> carrier_mat m m;\n         mat_of_rows n fs_init = V * mat_of_rows n gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  V \\<in> carrier_mat m m\n  mat_of_rows n fs_init = V * mat_of_rows n gs\n\ngoal (2 subgoals):\n 1. lattice_of gs = lattice_of fs_init\n 2. LLL_with_assms n m gs \\<alpha>", "from LLL_change_basis[OF gs len'[folded \\<open>m = n\\<close>] V(1) U(1) V(2) U(2)]"], ["proof (chain)\npicking this:\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>", "show \"lattice_of gs = lattice_of fs_init\" \"LLL_with_assms n m gs \\<alpha>\""], ["proof (prove)\nusing this:\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs_init &&& LLL_with_assms n m gs \\<alpha>", "by blast+"], ["proof (state)\nthis:\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>External solvers must deliver a reduced basis and optionally two\n  matrices to convert between the input and the reduced basis. These two\n  matrices are mandatory if the input matrix is not a square matrix.\\<close>"], ["", "consts external_lll_solver :: \"integer \\<times> integer \\<Rightarrow> integer list list \\<Rightarrow> \n  integer list list \\<times> (integer list list \\<times> integer list list)option\""], ["", "definition reduce_basis_external :: \"rat \\<Rightarrow> int vec list \\<Rightarrow> int vec list\" where\n  \"reduce_basis_external \\<alpha> fs = (case fs of Nil \\<Rightarrow> [] | Cons f _ \\<Rightarrow> (let \n    rb = reduce_basis \\<alpha>;\n    fsi = map (map integer_of_int o list_of_vec) fs;\n    n = dim_vec f;\n    m = length fs in \n  case external_lll_solver (map_prod integer_of_int integer_of_int (quotient_of \\<alpha>)) fsi of \n    (gsi, co) \\<Rightarrow>\n    let gs = (map (vec_of_list o map int_of_integer) gsi) in\n    if \\<not> (length gs = m \\<and> (\\<forall> gi \\<in> set gs. dim_vec gi = n)) then\n      Code.abort (STR ''error in external LLL invocation: dimensions of reduced basis do not fit\\<newline>input to external solver: ''\n        + String.implode (show fs) + STR ''\\<newline>\\<newline>'') (\\<lambda> _. rb fs)\n     else \n       case co of Some (u1i, u2i) \\<Rightarrow> (let \n         u1 = mat_of_rows_list m (map (map int_of_integer) u1i);\n         u2 = mat_of_rows_list m (map (map int_of_integer) u2i);\n         gs = (map (vec_of_list o map int_of_integer) gsi);\n         Fs = mat_of_rows n fs;\n         Gs = mat_of_rows n gs in \n         if (dim_row u1 = m \\<and> dim_col u1 = m \\<and> dim_row u2 = m \\<and> dim_col u2 = m \n             \\<and> Fs = u1 * Gs \\<and> Gs = u2 * Fs)\n          then rb gs\n          else Code.abort (STR ''error in external lll invocation\\<newline>f,g,u1,u2 are as follows\\<newline>''\n            + String.implode (show Fs) + STR ''\\<newline>\\<newline>''\n            + String.implode (show Gs) + STR ''\\<newline>\\<newline>''\n            + String.implode (show u1) + STR ''\\<newline>\\<newline>''\n            + String.implode (show u2) + STR ''\\<newline>\\<newline>''\n            ) (\\<lambda> _. rb fs))\n   | None \\<Rightarrow> (if (n = m \\<and> integer_equivalent n fs gs) then\n       rb gs\n      else Code.abort (STR ''error in external LLL invocation:\\<newline>'' +\n        (if n = m then STR ''reduced matrix does not span same lattice'' else \n          STR ''no certificate only allowed for square matrices'')) (\\<lambda> _. rb fs))\n    ))\""], ["", "definition short_vector_external :: \"rat \\<Rightarrow> int vec list \\<Rightarrow> int vec\" where\n  \"short_vector_external \\<alpha> fs = (hd (reduce_basis_external \\<alpha> fs))\""], ["", "instance bool :: prime_card"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, prime_card_class)", "by (standard, auto)"], ["", "context LLL_with_assms\nbegin"], ["", "lemma reduce_basis_external: assumes res: \"reduce_basis_external \\<alpha> fs_init = fs\" \n  shows \"reduced fs m\" \"LLL_invariant True m fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m &&&\n    LLL_invariant True m fs", "(* \"lattice_of fs = lattice_of fs_init\" is part of LLL_invariant *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m &&&\n    LLL_invariant True m fs", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "proof (cases \"LLL_Impl.reduce_basis \\<alpha> fs_init = fs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init = fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "case True"], ["proof (state)\nthis:\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs\n\ngoal (2 subgoals):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init = fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "from reduce_basis[OF this]"], ["proof (chain)\npicking this:\n  lattice_of fs = L\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = m\n  LLL_invariant True m fs", "show ?thesis"], ["proof (prove)\nusing this:\n  lattice_of fs = L\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = m\n  LLL_invariant True m fs\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "by simp"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "case False"], ["proof (state)\nthis:\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "proof (cases fs_init)"], ["proof (state)\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "case Nil"], ["proof (state)\nthis:\n  fs_init = []\n\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "with res"], ["proof (chain)\npicking this:\n  reduce_basis_external \\<alpha> fs_init = fs\n  fs_init = []", "have \"fs = []\""], ["proof (prove)\nusing this:\n  reduce_basis_external \\<alpha> fs_init = fs\n  fs_init = []\n\ngoal (1 subgoal):\n 1. fs = []", "unfolding reduce_basis_external_def"], ["proof (prove)\nusing this:\n  (case fs_init of [] \\<Rightarrow> []\n   | f # x \\<Rightarrow>\n       let rb = LLL_Impl.reduce_basis \\<alpha>;\n           fsi = map (map integer_of_int \\<circ> list_of_vec) fs_init;\n           n = dim_vec f; m = length fs_init\n       in case external_lll_solver\n                (map_prod integer_of_int integer_of_int\n                  (quotient_of \\<alpha>))\n                fsi of\n          (gsi, co) \\<Rightarrow>\n            let gs = map (vec_of_list \\<circ> map int_of_integer) gsi\n            in if \\<not> (length gs = m \\<and>\n                          (\\<forall>gi\\<in>set gs. dim_vec gi = n))\n               then Code.abort\n                     (STR ''error in external LLL invocation: dimensions of reduced basis do not fit\\<newline>input to external solver: '' +\n                      String.implode (show fs_init) +\n                      STR ''\\<newline>\\<newline>'')\n                     (\\<lambda>_. rb fs_init)\n               else case co of\n                    None \\<Rightarrow>\n                      if n = m \\<and> integer_equivalent n fs_init gs\n                      then rb gs\n                      else Code.abort\n                            (STR ''error in external LLL invocation:\\<newline>'' +\n                             (if n = m\n                              then STR ''reduced matrix does not span same lattice''\n                              else STR ''no certificate only allowed for square matrices''))\n                            (\\<lambda>_. rb fs_init)\n                    | Some (u1i, u2i) \\<Rightarrow>\n                        let u1 = mat_of_rows_list m\n                                  (map (map int_of_integer) u1i);\n                            u2 = mat_of_rows_list m\n                                  (map (map int_of_integer) u2i);\n                            gs = map (vec_of_list \\<circ>\nmap int_of_integer)\n                                  gsi;\n                            Fs = mat_of_rows n fs_init;\n                            Gs = mat_of_rows n gs\n                        in if dim_row u1 = m \\<and>\n                              dim_col u1 = m \\<and>\n                              dim_row u2 = m \\<and>\n                              dim_col u2 = m \\<and>\n                              Fs = u1 * Gs \\<and> Gs = u2 * Fs\n                           then rb gs\n                           else Code.abort\n                                 (STR ''error in external lll invocation\\<newline>f,g,u1,u2 are as follows\\<newline>'' +\n                                  String.implode (show Fs) +\n                                  STR ''\\<newline>\\<newline>'' +\n                                  String.implode (show Gs) +\n                                  STR ''\\<newline>\\<newline>'' +\n                                  String.implode (show u1) +\n                                  STR ''\\<newline>\\<newline>'' +\n                                  String.implode (show u2) +\n                                  STR ''\\<newline>\\<newline>'')\n                                 (\\<lambda>_. rb fs_init)) =\n  fs\n  fs_init = []\n\ngoal (1 subgoal):\n 1. fs = []", "by auto"], ["proof (state)\nthis:\n  fs = []\n\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "with False Nil"], ["proof (chain)\npicking this:\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n  fs_init = []\n  fs = []", "have False"], ["proof (prove)\nusing this:\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n  fs_init = []\n  fs = []\n\ngoal (1 subgoal):\n 1. False", "by (simp add: LLL_Impl.reduce_basis_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", ".."], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "case (Cons f rest)"], ["proof (state)\nthis:\n  fs_init = f # rest\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "from Cons fs_init len"], ["proof (chain)\npicking this:\n  fs_init = f # rest\n  set fs_init \\<subseteq> carrier_vec n\n  length fs_init = m", "have dim_fs_n: \"dim_vec f = n\""], ["proof (prove)\nusing this:\n  fs_init = f # rest\n  set fs_init \\<subseteq> carrier_vec n\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. dim_vec f = n", "by auto"], ["proof (state)\nthis:\n  dim_vec f = n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "let ?ext = \"external_lll_solver (map_prod integer_of_int integer_of_int (quotient_of \\<alpha>)) \n        (map (map integer_of_int \\<circ> list_of_vec) fs_init)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "note res = res[unfolded reduce_basis_external_def Cons Let_def list.case Code.abort_def dim_fs_n,\n          folded Cons]"], ["proof (state)\nthis:\n  (case external_lll_solver\n         (map_prod integer_of_int integer_of_int (quotient_of \\<alpha>))\n         (map (map integer_of_int \\<circ> list_of_vec) fs_init) of\n   (gsi, co) \\<Rightarrow>\n     if \\<not> (length (map (vec_of_list \\<circ> map int_of_integer) gsi) =\n                length fs_init \\<and>\n                (\\<forall>gi\\<in>set (map\n (vec_of_list \\<circ> map int_of_integer) gsi).\n                    dim_vec gi = n))\n     then LLL_Impl.reduce_basis \\<alpha> fs_init\n     else case co of\n          None \\<Rightarrow>\n            if n = length fs_init \\<and>\n               integer_equivalent n fs_init\n                (map (vec_of_list \\<circ> map int_of_integer) gsi)\n            then LLL_Impl.reduce_basis \\<alpha>\n                  (map (vec_of_list \\<circ> map int_of_integer) gsi)\n            else LLL_Impl.reduce_basis \\<alpha> fs_init\n          | Some (u1i, u2i) \\<Rightarrow>\n              if dim_row\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u1i)) =\n                 length fs_init \\<and>\n                 dim_col\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u1i)) =\n                 length fs_init \\<and>\n                 dim_row\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u2i)) =\n                 length fs_init \\<and>\n                 dim_col\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u2i)) =\n                 length fs_init \\<and>\n                 mat_of_rows n fs_init =\n                 mat_of_rows_list (length fs_init)\n                  (map (map int_of_integer) u1i) *\n                 mat_of_rows n\n                  (map (vec_of_list \\<circ> map int_of_integer) gsi) \\<and>\n                 mat_of_rows n\n                  (map (vec_of_list \\<circ> map int_of_integer) gsi) =\n                 mat_of_rows_list (length fs_init)\n                  (map (map int_of_integer) u2i) *\n                 mat_of_rows n fs_init\n              then LLL_Impl.reduce_basis \\<alpha>\n                    (map (vec_of_list \\<circ> map int_of_integer) gsi)\n              else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "from res False"], ["proof (chain)\npicking this:\n  (case external_lll_solver\n         (map_prod integer_of_int integer_of_int (quotient_of \\<alpha>))\n         (map (map integer_of_int \\<circ> list_of_vec) fs_init) of\n   (gsi, co) \\<Rightarrow>\n     if \\<not> (length (map (vec_of_list \\<circ> map int_of_integer) gsi) =\n                length fs_init \\<and>\n                (\\<forall>gi\\<in>set (map\n (vec_of_list \\<circ> map int_of_integer) gsi).\n                    dim_vec gi = n))\n     then LLL_Impl.reduce_basis \\<alpha> fs_init\n     else case co of\n          None \\<Rightarrow>\n            if n = length fs_init \\<and>\n               integer_equivalent n fs_init\n                (map (vec_of_list \\<circ> map int_of_integer) gsi)\n            then LLL_Impl.reduce_basis \\<alpha>\n                  (map (vec_of_list \\<circ> map int_of_integer) gsi)\n            else LLL_Impl.reduce_basis \\<alpha> fs_init\n          | Some (u1i, u2i) \\<Rightarrow>\n              if dim_row\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u1i)) =\n                 length fs_init \\<and>\n                 dim_col\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u1i)) =\n                 length fs_init \\<and>\n                 dim_row\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u2i)) =\n                 length fs_init \\<and>\n                 dim_col\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u2i)) =\n                 length fs_init \\<and>\n                 mat_of_rows n fs_init =\n                 mat_of_rows_list (length fs_init)\n                  (map (map int_of_integer) u1i) *\n                 mat_of_rows n\n                  (map (vec_of_list \\<circ> map int_of_integer) gsi) \\<and>\n                 mat_of_rows n\n                  (map (vec_of_list \\<circ> map int_of_integer) gsi) =\n                 mat_of_rows_list (length fs_init)\n                  (map (map int_of_integer) u2i) *\n                 mat_of_rows n fs_init\n              then LLL_Impl.reduce_basis \\<alpha>\n                    (map (vec_of_list \\<circ> map int_of_integer) gsi)\n              else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs", "obtain gsi co where ext: \"?ext = (gsi, co)\""], ["proof (prove)\nusing this:\n  (case external_lll_solver\n         (map_prod integer_of_int integer_of_int (quotient_of \\<alpha>))\n         (map (map integer_of_int \\<circ> list_of_vec) fs_init) of\n   (gsi, co) \\<Rightarrow>\n     if \\<not> (length (map (vec_of_list \\<circ> map int_of_integer) gsi) =\n                length fs_init \\<and>\n                (\\<forall>gi\\<in>set (map\n (vec_of_list \\<circ> map int_of_integer) gsi).\n                    dim_vec gi = n))\n     then LLL_Impl.reduce_basis \\<alpha> fs_init\n     else case co of\n          None \\<Rightarrow>\n            if n = length fs_init \\<and>\n               integer_equivalent n fs_init\n                (map (vec_of_list \\<circ> map int_of_integer) gsi)\n            then LLL_Impl.reduce_basis \\<alpha>\n                  (map (vec_of_list \\<circ> map int_of_integer) gsi)\n            else LLL_Impl.reduce_basis \\<alpha> fs_init\n          | Some (u1i, u2i) \\<Rightarrow>\n              if dim_row\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u1i)) =\n                 length fs_init \\<and>\n                 dim_col\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u1i)) =\n                 length fs_init \\<and>\n                 dim_row\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u2i)) =\n                 length fs_init \\<and>\n                 dim_col\n                  (mat_of_rows_list (length fs_init)\n                    (map (map int_of_integer) u2i)) =\n                 length fs_init \\<and>\n                 mat_of_rows n fs_init =\n                 mat_of_rows_list (length fs_init)\n                  (map (map int_of_integer) u1i) *\n                 mat_of_rows n\n                  (map (vec_of_list \\<circ> map int_of_integer) gsi) \\<and>\n                 mat_of_rows n\n                  (map (vec_of_list \\<circ> map int_of_integer) gsi) =\n                 mat_of_rows_list (length fs_init)\n                  (map (map int_of_integer) u2i) *\n                 mat_of_rows n fs_init\n              then LLL_Impl.reduce_basis \\<alpha>\n                    (map (vec_of_list \\<circ> map int_of_integer) gsi)\n              else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n\ngoal (1 subgoal):\n 1. (\\<And>gsi co.\n        external_lll_solver\n         (map_prod integer_of_int integer_of_int (quotient_of \\<alpha>))\n         (map (map integer_of_int \\<circ> list_of_vec) fs_init) =\n        (gsi, co) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?ext, auto)"], ["proof (state)\nthis:\n  external_lll_solver\n   (map_prod integer_of_int integer_of_int (quotient_of \\<alpha>))\n   (map (map integer_of_int \\<circ> list_of_vec) fs_init) =\n  (gsi, co)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "define gs where \"gs = map (vec_of_list o map int_of_integer) gsi\""], ["proof (state)\nthis:\n  gs = map (vec_of_list \\<circ> map int_of_integer) gsi\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "note res = res[unfolded ext option.simps split len dim_fs_n, folded gs_def]"], ["proof (state)\nthis:\n  (if \\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))\n   then LLL_Impl.reduce_basis \\<alpha> fs_init\n   else case co of\n        None \\<Rightarrow>\n          if n = m \\<and> integer_equivalent n fs_init gs\n          then LLL_Impl.reduce_basis \\<alpha> gs\n          else LLL_Impl.reduce_basis \\<alpha> fs_init\n        | Some (u1i, u2i) \\<Rightarrow>\n            if dim_row (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n               m \\<and>\n               dim_col (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n               m \\<and>\n               dim_row (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n               m \\<and>\n               dim_col (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n               m \\<and>\n               mat_of_rows n fs_init =\n               mat_of_rows_list m (map (map int_of_integer) u1i) *\n               mat_of_rows n gs \\<and>\n               mat_of_rows n gs =\n               mat_of_rows_list m (map (map int_of_integer) u2i) *\n               mat_of_rows n fs_init\n            then LLL_Impl.reduce_basis \\<alpha> gs\n            else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "from res False"], ["proof (chain)\npicking this:\n  (if \\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))\n   then LLL_Impl.reduce_basis \\<alpha> fs_init\n   else case co of\n        None \\<Rightarrow>\n          if n = m \\<and> integer_equivalent n fs_init gs\n          then LLL_Impl.reduce_basis \\<alpha> gs\n          else LLL_Impl.reduce_basis \\<alpha> fs_init\n        | Some (u1i, u2i) \\<Rightarrow>\n            if dim_row (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n               m \\<and>\n               dim_col (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n               m \\<and>\n               dim_row (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n               m \\<and>\n               dim_col (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n               m \\<and>\n               mat_of_rows n fs_init =\n               mat_of_rows_list m (map (map int_of_integer) u1i) *\n               mat_of_rows n gs \\<and>\n               mat_of_rows n gs =\n               mat_of_rows_list m (map (map int_of_integer) u2i) *\n               mat_of_rows n fs_init\n            then LLL_Impl.reduce_basis \\<alpha> gs\n            else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs", "have not: \"(\\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))) = False\""], ["proof (prove)\nusing this:\n  (if \\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))\n   then LLL_Impl.reduce_basis \\<alpha> fs_init\n   else case co of\n        None \\<Rightarrow>\n          if n = m \\<and> integer_equivalent n fs_init gs\n          then LLL_Impl.reduce_basis \\<alpha> gs\n          else LLL_Impl.reduce_basis \\<alpha> fs_init\n        | Some (u1i, u2i) \\<Rightarrow>\n            if dim_row (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n               m \\<and>\n               dim_col (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n               m \\<and>\n               dim_row (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n               m \\<and>\n               dim_col (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n               m \\<and>\n               mat_of_rows n fs_init =\n               mat_of_rows_list m (map (map int_of_integer) u1i) *\n               mat_of_rows n gs \\<and>\n               mat_of_rows n gs =\n               mat_of_rows_list m (map (map int_of_integer) u2i) *\n               mat_of_rows n fs_init\n            then LLL_Impl.reduce_basis \\<alpha> gs\n            else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n\ngoal (1 subgoal):\n 1. (\\<not> (length gs = m \\<and>\n             (\\<forall>gi\\<in>set gs. dim_vec gi = n))) =\n    False", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  (\\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))) =\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "note res = res[unfolded this if_False]"], ["proof (state)\nthis:\n  (case co of\n   None \\<Rightarrow>\n     if n = m \\<and> integer_equivalent n fs_init gs\n     then LLL_Impl.reduce_basis \\<alpha> gs\n     else LLL_Impl.reduce_basis \\<alpha> fs_init\n   | Some (u1i, u2i) \\<Rightarrow>\n       if dim_row (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n          m \\<and>\n          dim_col (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n          m \\<and>\n          dim_row (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n          m \\<and>\n          dim_col (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n          m \\<and>\n          mat_of_rows n fs_init =\n          mat_of_rows_list m (map (map int_of_integer) u1i) *\n          mat_of_rows n gs \\<and>\n          mat_of_rows n gs =\n          mat_of_rows_list m (map (map int_of_integer) u2i) *\n          mat_of_rows n fs_init\n       then LLL_Impl.reduce_basis \\<alpha> gs\n       else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "from not"], ["proof (chain)\npicking this:\n  (\\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))) =\n  False", "have gs: \"set gs \\<subseteq> carrier_vec n\" \n         and len_gs: \"length gs = m\""], ["proof (prove)\nusing this:\n  (\\<not> (length gs = m \\<and> (\\<forall>gi\\<in>set gs. dim_vec gi = n))) =\n  False\n\ngoal (1 subgoal):\n 1. set gs \\<subseteq> carrier_vec n &&& length gs = m", "by auto"], ["proof (state)\nthis:\n  set gs \\<subseteq> carrier_vec n\n  length gs = m\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "have \"lattice_of gs = lattice_of fs_init \\<and> LLL_with_assms n m gs \\<alpha> \\<and> LLL_Impl.reduce_basis \\<alpha> gs = fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs", "proof (cases co)"], ["proof (state)\ngoal (2 subgoals):\n 1. co = None \\<Longrightarrow>\n    lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs\n 2. \\<And>a.\n       co = Some a \\<Longrightarrow>\n       lattice_of gs = lattice_of fs_init \\<and>\n       LLL_with_assms n m gs \\<alpha> \\<and>\n       LLL_Impl.reduce_basis \\<alpha> gs = fs", "case (Some pair)"], ["proof (state)\nthis:\n  co = Some pair\n\ngoal (2 subgoals):\n 1. co = None \\<Longrightarrow>\n    lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs\n 2. \\<And>a.\n       co = Some a \\<Longrightarrow>\n       lattice_of gs = lattice_of fs_init \\<and>\n       LLL_with_assms n m gs \\<alpha> \\<and>\n       LLL_Impl.reduce_basis \\<alpha> gs = fs", "from res Some"], ["proof (chain)\npicking this:\n  (case co of\n   None \\<Rightarrow>\n     if n = m \\<and> integer_equivalent n fs_init gs\n     then LLL_Impl.reduce_basis \\<alpha> gs\n     else LLL_Impl.reduce_basis \\<alpha> fs_init\n   | Some (u1i, u2i) \\<Rightarrow>\n       if dim_row (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n          m \\<and>\n          dim_col (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n          m \\<and>\n          dim_row (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n          m \\<and>\n          dim_col (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n          m \\<and>\n          mat_of_rows n fs_init =\n          mat_of_rows_list m (map (map int_of_integer) u1i) *\n          mat_of_rows n gs \\<and>\n          mat_of_rows n gs =\n          mat_of_rows_list m (map (map int_of_integer) u2i) *\n          mat_of_rows n fs_init\n       then LLL_Impl.reduce_basis \\<alpha> gs\n       else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  co = Some pair", "obtain u1i u2i where co: \"co = Some (u1i, u2i)\""], ["proof (prove)\nusing this:\n  (case co of\n   None \\<Rightarrow>\n     if n = m \\<and> integer_equivalent n fs_init gs\n     then LLL_Impl.reduce_basis \\<alpha> gs\n     else LLL_Impl.reduce_basis \\<alpha> fs_init\n   | Some (u1i, u2i) \\<Rightarrow>\n       if dim_row (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n          m \\<and>\n          dim_col (mat_of_rows_list m (map (map int_of_integer) u1i)) =\n          m \\<and>\n          dim_row (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n          m \\<and>\n          dim_col (mat_of_rows_list m (map (map int_of_integer) u2i)) =\n          m \\<and>\n          mat_of_rows n fs_init =\n          mat_of_rows_list m (map (map int_of_integer) u1i) *\n          mat_of_rows n gs \\<and>\n          mat_of_rows n gs =\n          mat_of_rows_list m (map (map int_of_integer) u2i) *\n          mat_of_rows n fs_init\n       then LLL_Impl.reduce_basis \\<alpha> gs\n       else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  co = Some pair\n\ngoal (1 subgoal):\n 1. (\\<And>u1i u2i.\n        co = Some (u1i, u2i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases co, auto)"], ["proof (state)\nthis:\n  co = Some (u1i, u2i)\n\ngoal (2 subgoals):\n 1. co = None \\<Longrightarrow>\n    lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs\n 2. \\<And>a.\n       co = Some a \\<Longrightarrow>\n       lattice_of gs = lattice_of fs_init \\<and>\n       LLL_with_assms n m gs \\<alpha> \\<and>\n       LLL_Impl.reduce_basis \\<alpha> gs = fs", "define u1 where \"u1 = mat_of_rows_list m (map (map int_of_integer) u1i)\""], ["proof (state)\nthis:\n  u1 = mat_of_rows_list m (map (map int_of_integer) u1i)\n\ngoal (2 subgoals):\n 1. co = None \\<Longrightarrow>\n    lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs\n 2. \\<And>a.\n       co = Some a \\<Longrightarrow>\n       lattice_of gs = lattice_of fs_init \\<and>\n       LLL_with_assms n m gs \\<alpha> \\<and>\n       LLL_Impl.reduce_basis \\<alpha> gs = fs", "define u2 where \"u2 = mat_of_rows_list m (map (map int_of_integer) u2i)\""], ["proof (state)\nthis:\n  u2 = mat_of_rows_list m (map (map int_of_integer) u2i)\n\ngoal (2 subgoals):\n 1. co = None \\<Longrightarrow>\n    lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs\n 2. \\<And>a.\n       co = Some a \\<Longrightarrow>\n       lattice_of gs = lattice_of fs_init \\<and>\n       LLL_with_assms n m gs \\<alpha> \\<and>\n       LLL_Impl.reduce_basis \\<alpha> gs = fs", "note res = res[unfolded co option.simps split len dim_fs_n, folded u1_def u2_def gs_def]"], ["proof (state)\nthis:\n  (if dim_row u1 = m \\<and>\n      dim_col u1 = m \\<and>\n      dim_row u2 = m \\<and>\n      dim_col u2 = m \\<and>\n      mat_of_rows n fs_init = u1 * mat_of_rows n gs \\<and>\n      mat_of_rows n gs = u2 * mat_of_rows n fs_init\n   then LLL_Impl.reduce_basis \\<alpha> gs\n   else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n\ngoal (2 subgoals):\n 1. co = None \\<Longrightarrow>\n    lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs\n 2. \\<And>a.\n       co = Some a \\<Longrightarrow>\n       lattice_of gs = lattice_of fs_init \\<and>\n       LLL_with_assms n m gs \\<alpha> \\<and>\n       LLL_Impl.reduce_basis \\<alpha> gs = fs", "from res False"], ["proof (chain)\npicking this:\n  (if dim_row u1 = m \\<and>\n      dim_col u1 = m \\<and>\n      dim_row u2 = m \\<and>\n      dim_col u2 = m \\<and>\n      mat_of_rows n fs_init = u1 * mat_of_rows n gs \\<and>\n      mat_of_rows n gs = u2 * mat_of_rows n fs_init\n   then LLL_Impl.reduce_basis \\<alpha> gs\n   else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs", "have u1: \"u1 \\<in> carrier_mat m m\" \n          and u2: \"u2 \\<in> carrier_mat m m\" \n          and prod1: \"mat_of_rows n fs_init = u1 * mat_of_rows n gs\" \n          and prod2: \"mat_of_rows n gs = u2 * mat_of_rows n fs_init\" \n          and gs_v: \"LLL_Impl.reduce_basis \\<alpha> gs = fs\""], ["proof (prove)\nusing this:\n  (if dim_row u1 = m \\<and>\n      dim_col u1 = m \\<and>\n      dim_row u2 = m \\<and>\n      dim_col u2 = m \\<and>\n      mat_of_rows n fs_init = u1 * mat_of_rows n gs \\<and>\n      mat_of_rows n gs = u2 * mat_of_rows n fs_init\n   then LLL_Impl.reduce_basis \\<alpha> gs\n   else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n\ngoal (1 subgoal):\n 1. (u1 \\<in> carrier_mat m m &&& u2 \\<in> carrier_mat m m) &&&\n    mat_of_rows n fs_init = u1 * mat_of_rows n gs &&&\n    mat_of_rows n gs = u2 * mat_of_rows n fs_init &&&\n    LLL_Impl.reduce_basis \\<alpha> gs = fs", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  u1 \\<in> carrier_mat m m\n  u2 \\<in> carrier_mat m m\n  mat_of_rows n fs_init = u1 * mat_of_rows n gs\n  mat_of_rows n gs = u2 * mat_of_rows n fs_init\n  LLL_Impl.reduce_basis \\<alpha> gs = fs\n\ngoal (2 subgoals):\n 1. co = None \\<Longrightarrow>\n    lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs\n 2. \\<And>a.\n       co = Some a \\<Longrightarrow>\n       lattice_of gs = lattice_of fs_init \\<and>\n       LLL_with_assms n m gs \\<alpha> \\<and>\n       LLL_Impl.reduce_basis \\<alpha> gs = fs", "from LLL_change_basis[OF gs len_gs u1 u2 prod1 prod2] gs_v"], ["proof (chain)\npicking this:\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n  LLL_Impl.reduce_basis \\<alpha> gs = fs", "show ?thesis"], ["proof (prove)\nusing this:\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n  LLL_Impl.reduce_basis \\<alpha> gs = fs\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs", "by auto"], ["proof (state)\nthis:\n  lattice_of gs = lattice_of fs_init \\<and>\n  LLL_with_assms n m gs \\<alpha> \\<and>\n  LLL_Impl.reduce_basis \\<alpha> gs = fs\n\ngoal (1 subgoal):\n 1. co = None \\<Longrightarrow>\n    lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. co = None \\<Longrightarrow>\n    lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs", "case None"], ["proof (state)\nthis:\n  co = None\n\ngoal (1 subgoal):\n 1. co = None \\<Longrightarrow>\n    lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs", "from res[unfolded None option.simps] False"], ["proof (chain)\npicking this:\n  (if n = m \\<and> integer_equivalent n fs_init gs\n   then LLL_Impl.reduce_basis \\<alpha> gs\n   else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs", "have id: \"fs = LLL_Impl.reduce_basis \\<alpha> gs\" and nm: \"n = m\" \n          and equiv: \"integer_equivalent n fs_init gs\""], ["proof (prove)\nusing this:\n  (if n = m \\<and> integer_equivalent n fs_init gs\n   then LLL_Impl.reduce_basis \\<alpha> gs\n   else LLL_Impl.reduce_basis \\<alpha> fs_init) =\n  fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init \\<noteq> fs\n\ngoal (1 subgoal):\n 1. fs = LLL_Impl.reduce_basis \\<alpha> gs &&&\n    n = m &&& integer_equivalent n fs_init gs", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  fs = LLL_Impl.reduce_basis \\<alpha> gs\n  n = m\n  integer_equivalent n fs_init gs\n\ngoal (1 subgoal):\n 1. co = None \\<Longrightarrow>\n    lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs", "from LLL_change_basis_mat_inverse[OF gs len_gs[folded nm] nm[symmetric] equiv] id"], ["proof (chain)\npicking this:\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n  fs = LLL_Impl.reduce_basis \\<alpha> gs", "show ?thesis"], ["proof (prove)\nusing this:\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n  fs = LLL_Impl.reduce_basis \\<alpha> gs\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs_init \\<and>\n    LLL_with_assms n m gs \\<alpha> \\<and>\n    LLL_Impl.reduce_basis \\<alpha> gs = fs", "by auto"], ["proof (state)\nthis:\n  lattice_of gs = lattice_of fs_init \\<and>\n  LLL_with_assms n m gs \\<alpha> \\<and>\n  LLL_Impl.reduce_basis \\<alpha> gs = fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lattice_of gs = lattice_of fs_init \\<and>\n  LLL_with_assms n m gs \\<alpha> \\<and>\n  LLL_Impl.reduce_basis \\<alpha> gs = fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "hence id: \"lattice_of gs = lattice_of fs_init\" \n         and assms: \"LLL_with_assms n m gs \\<alpha>\"\n         and gs_fs: \"LLL_Impl.reduce_basis \\<alpha> gs = fs\""], ["proof (prove)\nusing this:\n  lattice_of gs = lattice_of fs_init \\<and>\n  LLL_with_assms n m gs \\<alpha> \\<and>\n  LLL_Impl.reduce_basis \\<alpha> gs = fs\n\ngoal (1 subgoal):\n 1. lattice_of gs = lattice_of fs_init &&&\n    LLL_with_assms n m gs \\<alpha> &&&\n    LLL_Impl.reduce_basis \\<alpha> gs = fs", "by auto"], ["proof (state)\nthis:\n  lattice_of gs = lattice_of fs_init\n  LLL_with_assms n m gs \\<alpha>\n  LLL_Impl.reduce_basis \\<alpha> gs = fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "from LLL_with_assms.reduce_basis[OF assms gs_fs]"], ["proof (chain)\npicking this:\n  lattice_of fs = LLL.L n gs\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = m\n  LLL.LLL_invariant n m gs \\<alpha> True m fs", "have red: \"reduced fs m\" and inv: \"LLL.LLL_invariant n m gs \\<alpha> True m fs\""], ["proof (prove)\nusing this:\n  lattice_of fs = LLL.L n gs\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length fs = m\n  LLL.LLL_invariant n m gs \\<alpha> True m fs\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m &&&\n    LLL.LLL_invariant n m gs \\<alpha> True m fs", "by auto"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  LLL.LLL_invariant n m gs \\<alpha> True m fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "from inv[unfolded LLL.LLL_invariant_def LLL.L_def id]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n  lattice_of fs = lattice_of fs_init \\<and>\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  m \\<le> m \\<and> length fs = m \\<and> (True \\<or> \\<mu>_small fs m)", "have lattice: \"lattice_of fs = lattice_of fs_init\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n  lattice_of fs = lattice_of fs_init \\<and>\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  m \\<le> m \\<and> length fs = m \\<and> (True \\<or> \\<mu>_small fs m)\n\ngoal (1 subgoal):\n 1. lattice_of fs = lattice_of fs_init", "by auto"], ["proof (state)\nthis:\n  lattice_of fs = lattice_of fs_init\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow>\n       gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha>\n        m \\<and>\n       LLL_invariant True m fs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    LLL_invariant True m fs", "proof (intro conjI red lattice)"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_invariant True m fs", "show \"LLL_invariant True m fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True m fs", "using inv"], ["proof (prove)\nusing this:\n  LLL.LLL_invariant n m gs \\<alpha> True m fs\n\ngoal (1 subgoal):\n 1. LLL_invariant True m fs", "unfolding LLL.LLL_invariant_def LLL.L_def id"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n  lattice_of fs = lattice_of fs_init \\<and>\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  m \\<le> m \\<and> length fs = m \\<and> (True \\<or> \\<mu>_small fs m)\n\ngoal (1 subgoal):\n 1. gs.lin_indpt_list (map of_int_hom.vec_hom fs) \\<and>\n    lattice_of fs = lattice_of fs_init \\<and>\n    gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n    m \\<le> m \\<and> length fs = m \\<and> (True \\<or> \\<mu>_small fs m)", "."], ["proof (state)\nthis:\n  LLL_invariant True m fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m \\<and>\n  LLL_invariant True m fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma short_vector_external: assumes res: \"short_vector_external \\<alpha> fs_init = v\"\n  and m0: \"m \\<noteq> 0\"\nshows \"v \\<in> carrier_vec n\"\n  \"v \\<in> L - {0\\<^sub>v n}\"\n  \"h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow> rat_of_int (sq_norm v) \\<le> \\<alpha> ^ (m - 1) * rat_of_int (sq_norm h)\"\n  \"v \\<noteq> 0\\<^sub>v j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n &&& v \\<in> L - {0\\<^sub>v n}) &&&\n    (h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) &&&\n    v \\<noteq> 0\\<^sub>v j", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n \\<and> v \\<in> L - {0\\<^sub>v n}) \\<and>\n    (h \\<in> L - {0\\<^sub>v n} \\<longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) \\<and>\n    v \\<noteq> 0\\<^sub>v j", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n \\<and> v \\<in> L - {0\\<^sub>v n}) \\<and>\n    (h \\<in> L - {0\\<^sub>v n} \\<longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) \\<and>\n    v \\<noteq> 0\\<^sub>v j", "obtain fs where red: \"reduce_basis_external \\<alpha> fs_init = fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs.\n        reduce_basis_external \\<alpha> fs_init = fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  reduce_basis_external \\<alpha> fs_init = fs\n\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n \\<and> v \\<in> L - {0\\<^sub>v n}) \\<and>\n    (h \\<in> L - {0\\<^sub>v n} \\<longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) \\<and>\n    v \\<noteq> 0\\<^sub>v j", "from res[unfolded short_vector_external_def red]"], ["proof (chain)\npicking this:\n  hd fs = v", "have v: \"v = hd fs\""], ["proof (prove)\nusing this:\n  hd fs = v\n\ngoal (1 subgoal):\n 1. v = hd fs", "by auto"], ["proof (state)\nthis:\n  v = hd fs\n\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n \\<and> v \\<in> L - {0\\<^sub>v n}) \\<and>\n    (h \\<in> L - {0\\<^sub>v n} \\<longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) \\<and>\n    v \\<noteq> 0\\<^sub>v j", "from reduce_basis_external[OF red]"], ["proof (chain)\npicking this:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  LLL_invariant True m fs", "have red: \"reduced fs m\" and inv: \"LLL_invariant True m fs\""], ["proof (prove)\nusing this:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  LLL_invariant True m fs\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m &&&\n    LLL_invariant True m fs", "by blast+"], ["proof (state)\nthis:\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  LLL_invariant True m fs\n\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n \\<and> v \\<in> L - {0\\<^sub>v n}) \\<and>\n    (h \\<in> L - {0\\<^sub>v n} \\<longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) \\<and>\n    v \\<noteq> 0\\<^sub>v j", "from basis_reduction_short_vector[OF inv v m0]"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  v \\<in> L - {0\\<^sub>v n}\n  ?h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n  rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>?h\\<parallel>\\<^sup>2\n  v \\<noteq> 0\\<^sub>v ?j", "show ?case"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<in> L - {0\\<^sub>v n}\n  ?h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n  rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>?h\\<parallel>\\<^sup>2\n  v \\<noteq> 0\\<^sub>v ?j\n\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n \\<and> v \\<in> L - {0\\<^sub>v n}) \\<and>\n    (h \\<in> L - {0\\<^sub>v n} \\<longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) \\<and>\n    v \\<noteq> 0\\<^sub>v j", "by blast"], ["proof (state)\nthis:\n  (v \\<in> carrier_vec n \\<and> v \\<in> L - {0\\<^sub>v n}) \\<and>\n  (h \\<in> L - {0\\<^sub>v n} \\<longrightarrow>\n   rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> ^ (m - 1) *\n         rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) \\<and>\n  v \\<noteq> 0\\<^sub>v j\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>Unspecified constant to easily enable/disable external lll solver in generated code\\<close>"], ["", "consts enable_external_lll_solver :: bool"], ["", "definition short_vector_hybrid :: \"rat \\<Rightarrow> int vec list \\<Rightarrow> int vec\" where\n  \"short_vector_hybrid = (if enable_external_lll_solver then short_vector_external else short_vector)\""], ["", "definition reduce_basis_hybrid :: \"rat \\<Rightarrow> int vec list \\<Rightarrow> int vec list\" where\n  \"reduce_basis_hybrid = (if enable_external_lll_solver then reduce_basis_external else reduce_basis)\""], ["", "context LLL_with_assms\nbegin"], ["", "lemma short_vector_hybrid: assumes res: \"short_vector_hybrid \\<alpha> fs_init = v\"\n  and m0: \"m \\<noteq> 0\"\nshows \"v \\<in> carrier_vec n\"\n  \"v \\<in> L - {0\\<^sub>v n}\"\n  \"h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow> rat_of_int (sq_norm v) \\<le> \\<alpha> ^ (m - 1) * rat_of_int (sq_norm h)\"\n  \"v \\<noteq> 0\\<^sub>v j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n &&& v \\<in> L - {0\\<^sub>v n}) &&&\n    (h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) &&&\n    v \\<noteq> 0\\<^sub>v j", "using short_vector[of v, OF _ m0] short_vector_external[of v, OF _ m0]\n    res[unfolded short_vector_hybrid_def]"], ["proof (prove)\nusing this:\n  LLL_Impl.short_vector \\<alpha> fs_init = v \\<Longrightarrow>\n  v \\<in> carrier_vec n\n  LLL_Impl.short_vector \\<alpha> fs_init = v \\<Longrightarrow>\n  v \\<in> L - {0\\<^sub>v n}\n  \\<lbrakk>LLL_Impl.short_vector \\<alpha> fs_init = v;\n   ?h \\<in> L - {0\\<^sub>v n}\\<rbrakk>\n  \\<Longrightarrow> rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n                    \\<le> \\<alpha> ^ (m - 1) *\n                          rat_of_int \\<parallel>?h\\<parallel>\\<^sup>2\n  LLL_Impl.short_vector \\<alpha> fs_init = v \\<Longrightarrow>\n  v \\<noteq> 0\\<^sub>v ?j\n  short_vector_external \\<alpha> fs_init = v \\<Longrightarrow>\n  v \\<in> carrier_vec n\n  short_vector_external \\<alpha> fs_init = v \\<Longrightarrow>\n  v \\<in> L - {0\\<^sub>v n}\n  \\<lbrakk>short_vector_external \\<alpha> fs_init = v;\n   ?h \\<in> L - {0\\<^sub>v n}\\<rbrakk>\n  \\<Longrightarrow> rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n                    \\<le> \\<alpha> ^ (m - 1) *\n                          rat_of_int \\<parallel>?h\\<parallel>\\<^sup>2\n  short_vector_external \\<alpha> fs_init = v \\<Longrightarrow>\n  v \\<noteq> 0\\<^sub>v ?j\n  (if enable_external_lll_solver then short_vector_external\n   else LLL_Impl.short_vector)\n   \\<alpha> fs_init =\n  v\n\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n &&& v \\<in> L - {0\\<^sub>v n}) &&&\n    (h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) &&&\n    v \\<noteq> 0\\<^sub>v j", "by (auto split: if_splits)"], ["", "lemma reduce_basis_hybrid: assumes res: \"reduce_basis_hybrid \\<alpha> fs_init = fs\" \n  shows \"reduced fs m\" \"LLL_invariant True m fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m &&&\n    LLL_invariant True m fs", "using reduce_basis_external[of fs] reduce_basis[of fs] res[unfolded reduce_basis_hybrid_def]"], ["proof (prove)\nusing this:\n  reduce_basis_external \\<alpha> fs_init = fs \\<Longrightarrow>\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  reduce_basis_external \\<alpha> fs_init = fs \\<Longrightarrow>\n  LLL_invariant True m fs\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs \\<Longrightarrow>\n  lattice_of fs = L\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs \\<Longrightarrow>\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs \\<Longrightarrow>\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs \\<Longrightarrow>\n  length fs = m\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs \\<Longrightarrow>\n  LLL_invariant True m fs\n  (if enable_external_lll_solver then reduce_basis_external\n   else LLL_Impl.reduce_basis)\n   \\<alpha> fs_init =\n  fs\n\ngoal (1 subgoal):\n 1. gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m &&&\n    LLL_invariant True m fs", "by (auto split: if_splits)"], ["", "end"], ["", "lemma lll_oracle_default_code[code]: \n  \"external_lll_solver x = Code.abort (STR ''no implementation of external_lll_solver specified'') (\\<lambda> _. external_lll_solver x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. external_lll_solver x =\n    Code.abort STR ''no implementation of external_lll_solver specified''\n     (\\<lambda>_. external_lll_solver x)", "by simp"], ["", "text \\<open>By default, external solvers are disabled.\n  For enabling an external solver, load it via a separate theory like \\<^file>\\<open>FPLLL_Solver.thy\\<close>\\<close>"], ["", "overloading enable_external_lll_solver \\<equiv> enable_external_lll_solver\nbegin"], ["", "definition enable_external_lll_solver where \"enable_external_lll_solver = False\""], ["", "end"], ["", "definition \"short_vector_test_hybrid xs = \n  (let ys = map (vec_of_list o map int_of_integer) xs\n   in integer_of_int (sq_norm (short_vector_hybrid (3/2) ys)))\""], ["", "(* export_code short_vector_test_hybrid in Haskell module_name LLL *)"], ["", "end"]]}