{"file_name": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction/Missing_Lemmas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction", "problem_names": ["lemma (in zero_less_one) zero_le_one [simp]: \"0 \\<le> 1\"", "lemma of_nat_ge_zero[intro!]: \"of_nat n \\<ge> 0\"", "lemma zero_le_power [simp]: \"0 \\<le> a \\<Longrightarrow> 0 \\<le> a ^ n\"", "lemma power_mono: \"a \\<le> b \\<Longrightarrow> 0 \\<le> a \\<Longrightarrow> a ^ n \\<le> b ^ n\"", "lemma one_le_power [simp]: \"1 \\<le> a \\<Longrightarrow> 1 \\<le> a ^ n\"", "lemma power_le_one: \"0 \\<le> a \\<Longrightarrow> a \\<le> 1 \\<Longrightarrow> a ^ n \\<le> 1\"", "lemma power_gt1_lemma:\n  assumes gt1: \"1 < a\"\n  shows \"1 < a * a ^ n\"", "lemma power_gt1: \"1 < a \\<Longrightarrow> 1 < a ^ Suc n\"", "lemma one_less_power [simp]: \"1 < a \\<Longrightarrow> 0 < n \\<Longrightarrow> 1 < a ^ n\"", "lemma power_decreasing: \"n \\<le> N \\<Longrightarrow> 0 \\<le> a \\<Longrightarrow> a \\<le> 1 \\<Longrightarrow> a ^ N \\<le> a ^ n\"", "lemma power_increasing: \"n \\<le> N \\<Longrightarrow> 1 \\<le> a \\<Longrightarrow> a ^ n \\<le> a ^ N\"", "lemma power_Suc_le_self: \"0 \\<le> a \\<Longrightarrow> a \\<le> 1 \\<Longrightarrow> a ^ Suc n \\<le> a\"", "lemma prod_list_nonneg: \"(\\<And> x. (x :: 'a :: ordered_semiring_1) \\<in> set xs \\<Longrightarrow> x \\<ge> 0) \\<Longrightarrow> prod_list xs \\<ge> 0\"", "lemma log_prod: assumes \"0 < a\" \"a \\<noteq> 1\" \"\\<And> x. x \\<in> X \\<Longrightarrow> 0 < f x\" \n  shows \"log a (prod f X) = sum (log a o f) X\"", "lemma less_1_mult': \n  fixes a::\"'a::linordered_semidom\"\n  shows \"1 < a \\<Longrightarrow> 1 \\<le> b \\<Longrightarrow> 1 < a * b\"", "lemma upt_minus_eq_append: \"i\\<le>j \\<Longrightarrow> i\\<le>j-k \\<Longrightarrow> [i..<j] = [i..<j-k] @ [j-k..<j]\"", "lemma list_trisect: \"x < length lst \\<Longrightarrow> [0..<length lst] = [0..<x]@x#[Suc x..<length lst]\"", "lemma id_imp_bij_betw:\n  assumes f: \"f : A \\<rightarrow> A\"\n      and ff: \"\\<And>a. a \\<in> A \\<Longrightarrow> f (f a) = a\"\n  shows \"bij_betw f A A\"", "lemma range_subsetI:\n  assumes \"\\<And>x. f x = g (h x)\" shows \"range f \\<subseteq> range g\"", "lemma Gcd_uminus: \n  fixes A::\"int set\"\n  assumes \"finite A\"\n  shows \"Gcd A = Gcd (uminus ` A)\"", "lemma aux_abs_int: fixes c :: int\n  assumes \"c \\<noteq> 0\" \n  shows \"\\<bar>x\\<bar> \\<le> \\<bar>x * c\\<bar>\"", "lemma mod_0_abs_less_imp_0:\n  fixes a::int\n  assumes a1: \"[a = 0] (mod m)\"\n  and a2: \"abs(a)<m\"\n  shows \"a = 0\"", "lemma sum_list_zero:\n  assumes \"set xs \\<subseteq> {0}\" shows \"sum_list xs = 0\"", "lemma max_idem [simp]: shows \"max a a = a\"", "lemma hom_max:\n  assumes \"a \\<le> b \\<longleftrightarrow> f a \\<le> f b\"\n  shows \"f (max a b) = max (f a) (f b)\"", "lemma le_max_self:\n  fixes a b :: \"'a :: preorder\"\n  assumes \"a \\<le> b \\<or> b \\<le> a\" shows \"a \\<le> max a b\" and \"b \\<le> max a b\"", "lemma le_max:\n  fixes a b :: \"'a :: preorder\"\n  assumes \"c \\<le> a \\<or> c \\<le> b\" and \"a \\<le> b \\<or> b \\<le> a\" shows \"c \\<le> max a b\"", "lemma max_list_Cons: \"max_list (x#xs) = (if xs = [] then x else max x (max_list xs))\"", "lemma max_list_mem: \"xs \\<noteq> [] \\<Longrightarrow> max_list xs \\<in> set xs\"", "lemma mem_set_imp_le_max_list:\n  fixes xs :: \"'a :: preorder list\"\n  assumes \"\\<And>a b. a \\<in> set xs \\<Longrightarrow> b \\<in> set xs \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a\"\n      and \"a \\<in> set xs\"\n  shows \"a \\<le> max_list xs\"", "lemma le_max_list:\n  fixes xs :: \"'a :: preorder list\"\n  assumes ord: \"\\<And>a b. a \\<in> set xs \\<Longrightarrow> b \\<in> set xs \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a\"\n      and ab: \"a \\<le> b\"\n      and b: \"b \\<in> set xs\"\n  shows \"a \\<le> max_list xs\"", "lemma max_list_le:\n  fixes xs :: \"'a :: preorder list\"\n  assumes a: \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<le> a\"\n      and xs: \"xs \\<noteq> []\"\n  shows \"max_list xs \\<le> a\"", "lemma max_list_as_Greatest:\n  assumes \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set xs \\<Longrightarrow> x \\<le> y \\<or> y \\<le> x\"\n  shows \"max_list xs = (GREATEST a. a \\<in> set xs)\"", "lemma hom_max_list_commute:\n  assumes \"xs \\<noteq> []\"\n      and \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set xs \\<Longrightarrow> h (max x y) = max (h x) (h y)\"\n  shows \"h (max_list xs) = max_list (map h xs)\"", "lemma rev_upt_rec: \"[i>..j] = (if i>j then [i>..Suc j] @ [j] else [])\"", "lemma upt_aux_rec [code]:\n  \"rev_upt_aux i j js = (if j\\<ge>i then js else rev_upt_aux i (Suc j) (j#js))\"", "lemma rev_upt_code[code]: \"[i>..j] = rev_upt_aux i j []\"", "lemma upt_rev_upt:\n  \"rev [j>..i] = [i..<j]\"", "lemma rev_upt_upt:\n  \"rev [i..<j] = [j>..i]\"", "lemma length_rev_upt [simp]: \"length [i>..j] = i - j\"", "lemma nth_rev_upt [simp]: \"j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k\"", "lemma nth_map_rev_upt: \n  assumes i: \"i < m-n\"\n  shows \"(map f [m>..n]) ! i = f (m - 1 - i)\"", "lemma coeff_mult_monom:\n \"coeff (p * monom a d) i = (if d \\<le> i then a * coeff p (i - d) else 0)\"", "lemma vec_of_poly_0 [simp]: \"vec_of_poly 0 = 0\\<^sub>v 1\"", "lemma vec_index_vec_of_poly [simp]: \"i \\<le> degree p \\<Longrightarrow> vec_of_poly p $ i = coeff p (degree p - i)\"", "lemma poly_of_vec_vec: \"poly_of_vec (vec n f) = Poly (rev (map f [0..<n]))\"", "lemma sum_list_map_dropWhile0:\n  assumes f0: \"f 0 = 0\"\n  shows \"sum_list (map f (dropWhile ((=) 0) xs)) = sum_list (map f xs)\"", "lemma coeffs_poly_of_vec:\n  \"coeffs (poly_of_vec v) = rev (dropWhile ((=) 0) (list_of_vec v))\"", "lemma poly_of_vec_vCons:\n \"poly_of_vec (vCons a v) = monom a (dim_vec v) + poly_of_vec v\" (is \"?l = ?r\")", "lemma poly_of_vec_as_Poly: \"poly_of_vec v = Poly (rev (list_of_vec v))\"", "lemma poly_of_vec_add:\n  assumes \"dim_vec a = dim_vec b\"\n  shows \"poly_of_vec (a + b) = poly_of_vec a + poly_of_vec b\"", "lemma degree_poly_of_vec_less:\n  assumes \"0 < dim_vec v\" and \"dim_vec v \\<le> n\" shows \"degree (poly_of_vec v) < n\"", "lemma (in vec_module) poly_of_vec_finsum:\n  assumes \"f \\<in> X \\<rightarrow> carrier_vec n\"\n  shows \"poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))\"", "lemma vec_of_poly_as: \"vec_of_poly_n p (Suc (degree p)) = vec_of_poly p\"", "lemma vec_of_poly_n_0 [simp]: \"vec_of_poly_n p 0 = vNil\"", "lemma vec_dim_vec_of_poly_n [simp]:\n  \"dim_vec (vec_of_poly_n p n) = n\"\n  \"vec_of_poly_n p n \\<in> carrier_vec n\"", "lemma dim_vec_of_poly [simp]: \"dim_vec (vec_of_poly f) = degree f + 1\"", "lemma vec_index_of_poly_n:\n  assumes \"i < n\"\n  shows \"vec_of_poly_n p n $ i =\n    (if i < n - Suc (degree p) then 0 else coeff p (n - i - 1))\"", "lemma vec_of_poly_n_pCons[simp]:\n  shows \"vec_of_poly_n (pCons a p) (Suc n) = vec_of_poly_n p n @\\<^sub>v vec_of_list [a]\" (is \"?l = ?r\")", "lemma vec_of_poly_pCons:\n  shows \"vec_of_poly (pCons a p) =\n   (if p = 0 then vec_of_list [a] else vec_of_poly p @\\<^sub>v vec_of_list [a])\"", "lemma list_of_vec_of_poly [simp]:\n  \"list_of_vec (vec_of_poly p) = (if p = 0 then [0] else rev (coeffs p))\"", "lemma poly_of_vec_of_poly_n:\n  assumes p: \"degree p<n\"\n  shows \"poly_of_vec (vec_of_poly_n p n) = p\"", "lemma vec_of_poly_n0[simp]: \"vec_of_poly_n 0 n = 0\\<^sub>v n\"", "lemma vec_of_poly_n_add: \"vec_of_poly_n (a + b) n = vec_of_poly_n a n + vec_of_poly_n b n\"", "lemma vec_of_poly_n_poly_of_vec:\n  assumes n: \"dim_vec g = n\"\n  shows \"vec_of_poly_n (poly_of_vec g) n = g\"", "lemma poly_of_vec_scalar_mult:\n  assumes \"degree b<n\"\n  shows \"poly_of_vec (a \\<cdot>\\<^sub>v (vec_of_poly_n b n)) = smult a b\"", "lemma vec_of_poly_rev_shifted_dim[simp]: \"dim_vec (vec_of_poly_rev_shifted p n s j) = n\"", "lemma col_sylvester_sub: (* TODO: from this directly derive col_sylvester *)\n  assumes j: \"j < m + n\"\n  shows \"col (sylvester_mat_sub m n p q) j =\n    vec_of_poly_rev_shifted p n m j @\\<^sub>v vec_of_poly_rev_shifted q m n j\" (is \"?l = ?r\")", "lemma vec_of_poly_rev_shifted_scalar_prod:\n  fixes p v\n  defines \"q \\<equiv> poly_of_vec v\"\n  assumes m: \"degree p \\<le> m\" and n: \"dim_vec v = n\"\n  assumes j: \"j < m+n\"\n  shows \"vec_of_poly_rev_shifted p n m (n+m-Suc j) \\<bullet> v = coeff (p * q) j\" (is \"?l = ?r\")", "lemma sylvester_sub_poly:\n  fixes p q :: \"'a :: comm_semiring_0 poly\"\n  assumes m: \"degree p \\<le> m\"\n  assumes n: \"degree q \\<le> n\"\n  assumes v: \"v \\<in> carrier_vec (m+n)\"\n  shows \"poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) =\n    poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q\" (is \"?l = ?r\")", "lemma normalize_field [simp]: \"normalize (a :: 'a :: {field, semiring_gcd}) = (if a = 0 then 0 else 1)\"", "lemma content_field [simp]: \"content (p :: 'a :: {field,semiring_gcd} poly) = (if p = 0 then 0 else 1)\"", "lemma primitive_part_field [simp]: \"primitive_part (p :: 'a :: {field,semiring_gcd} poly) = p\"", "lemma primitive_part_dvd: \"primitive_part a dvd a\"", "lemma degree_abs [simp]:\n  \"degree \\<bar>p\\<bar> = degree p\"", "lemma degree_gcd1:\n  assumes a_not0: \"a \\<noteq> 0\" \n  shows \"degree (gcd a b) \\<le> degree a\"", "lemma primitive_part_neg [simp]:\n  fixes a::\"'a :: {factorial_ring_gcd,factorial_semiring_multiplicative} poly\"\n  shows \"primitive_part (-a) = - primitive_part a\"", "lemma content_uminus[simp]: \n  fixes f::\"int poly\"\n  shows \"content (-f) = content f\"", "lemma pseudo_mod_monic:\n  fixes f g :: \"'a::{comm_ring_1,semiring_1_no_zero_divisors} poly\"\n  defines \"r \\<equiv> pseudo_mod f g\"\n  assumes monic_g: \"monic g\"\n  shows \"\\<exists>q.  f = g * q + r\" \"r = 0 \\<or> degree r < degree g\"", "lemma monic_imp_div_mod_int_poly_degree: \n  fixes p :: \"'a::{comm_ring_1,semiring_1_no_zero_divisors} poly\"\n  assumes m: \"monic u\"\n  shows \"\\<exists>q r. p = q*u + r \\<and> (r = 0 \\<or> degree r < degree u)\"", "lemma (in zero_hom) hom_upper_triangular:\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> upper_triangular A \\<Longrightarrow> upper_triangular (map_mat hom A)\""], "translations": [["", "lemma (in zero_less_one) zero_le_one [simp]: \"0 \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (1::'a)", "by (rule less_imp_le, simp)"], ["", "subclass (in zero_less_one) zero_neq_one"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.zero_neq_one (1::'a) (0::'a)", "by (unfold_locales, simp add: less_imp_neq)"], ["", "class ordered_semiring_1 = Rings.ordered_semiring_0 + monoid_mult + zero_less_one\nbegin"], ["", "subclass semiring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_1 (1::'a) (*) (+) (0::'a)", ".."], ["", "lemma of_nat_ge_zero[intro!]: \"of_nat n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> of_nat n", "using add_right_mono[of _ _ 1]"], ["proof (prove)\nusing this:\n  ?a \\<le> ?b \\<Longrightarrow> ?a + (1::'a) \\<le> ?b + (1::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> of_nat n", "by (induct n, auto)"], ["", "(* Following lemmas are moved from @{class ordered_idom}. *)"], ["", "lemma zero_le_power [simp]: \"0 \\<le> a \\<Longrightarrow> 0 \\<le> a ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> a \\<Longrightarrow> (0::'a) \\<le> a ^ n", "by (induct n) simp_all"], ["", "lemma power_mono: \"a \\<le> b \\<Longrightarrow> 0 \\<le> a \\<Longrightarrow> a ^ n \\<le> b ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; (0::'a) \\<le> a\\<rbrakk>\n    \\<Longrightarrow> a ^ n \\<le> b ^ n", "by (induct n) (auto intro: mult_mono order_trans [of 0 a b])"], ["", "lemma one_le_power [simp]: \"1 \\<le> a \\<Longrightarrow> 1 \\<le> a ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> a \\<Longrightarrow> (1::'a) \\<le> a ^ n", "using power_mono [of 1 a n]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(1::'a) \\<le> a; (0::'a) \\<le> (1::'a)\\<rbrakk>\n  \\<Longrightarrow> (1::'a) ^ n \\<le> a ^ n\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> a \\<Longrightarrow> (1::'a) \\<le> a ^ n", "by simp"], ["", "lemma power_le_one: \"0 \\<le> a \\<Longrightarrow> a \\<le> 1 \\<Longrightarrow> a ^ n \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> a ^ n \\<le> (1::'a)", "using power_mono [of a 1 n]"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<le> (1::'a); (0::'a) \\<le> a\\<rbrakk>\n  \\<Longrightarrow> a ^ n \\<le> (1::'a) ^ n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> a ^ n \\<le> (1::'a)", "by simp"], ["", "lemma power_gt1_lemma:\n  assumes gt1: \"1 < a\"\n  shows \"1 < a * a ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) < a * a ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (1::'a) < a * a ^ n", "from gt1"], ["proof (chain)\npicking this:\n  (1::'a) < a", "have \"0 \\<le> a\""], ["proof (prove)\nusing this:\n  (1::'a) < a\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> a", "by (fact order_trans [OF zero_le_one less_imp_le])"], ["proof (state)\nthis:\n  (0::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. (1::'a) < a * a ^ n", "from gt1"], ["proof (chain)\npicking this:\n  (1::'a) < a", "have \"1 * 1 < a * 1\""], ["proof (prove)\nusing this:\n  (1::'a) < a\n\ngoal (1 subgoal):\n 1. (1::'a) * (1::'a) < a * (1::'a)", "by simp"], ["proof (state)\nthis:\n  (1::'a) * (1::'a) < a * (1::'a)\n\ngoal (1 subgoal):\n 1. (1::'a) < a * a ^ n", "also"], ["proof (state)\nthis:\n  (1::'a) * (1::'a) < a * (1::'a)\n\ngoal (1 subgoal):\n 1. (1::'a) < a * a ^ n", "from gt1"], ["proof (chain)\npicking this:\n  (1::'a) < a", "have \"\\<dots> \\<le> a * a ^ n\""], ["proof (prove)\nusing this:\n  (1::'a) < a\n\ngoal (1 subgoal):\n 1. a * (1::'a) \\<le> a * a ^ n", "by (simp only: mult_mono \\<open>0 \\<le> a\\<close> one_le_power order_less_imp_le zero_le_one order_refl)"], ["proof (state)\nthis:\n  a * (1::'a) \\<le> a * a ^ n\n\ngoal (1 subgoal):\n 1. (1::'a) < a * a ^ n", "finally"], ["proof (chain)\npicking this:\n  (1::'a) * (1::'a) < a * a ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  (1::'a) * (1::'a) < a * a ^ n\n\ngoal (1 subgoal):\n 1. (1::'a) < a * a ^ n", "by simp"], ["proof (state)\nthis:\n  (1::'a) < a * a ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma power_gt1: \"1 < a \\<Longrightarrow> 1 < a ^ Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) < a \\<Longrightarrow> (1::'a) < a ^ Suc n", "by (simp add: power_gt1_lemma)"], ["", "lemma one_less_power [simp]: \"1 < a \\<Longrightarrow> 0 < n \\<Longrightarrow> 1 < a ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(1::'a) < a; 0 < n\\<rbrakk> \\<Longrightarrow> (1::'a) < a ^ n", "by (cases n) (simp_all add: power_gt1_lemma)"], ["", "lemma power_decreasing: \"n \\<le> N \\<Longrightarrow> 0 \\<le> a \\<Longrightarrow> a \\<le> 1 \\<Longrightarrow> a ^ N \\<le> a ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> N; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> a ^ N \\<le> a ^ n", "proof (induction N)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> 0; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> a ^ 0 \\<le> a ^ n\n 2. \\<And>N.\n       \\<lbrakk>\\<lbrakk>n \\<le> N; (0::'a) \\<le> a;\n                 a \\<le> (1::'a)\\<rbrakk>\n                \\<Longrightarrow> a ^ N \\<le> a ^ n;\n        n \\<le> Suc N; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n       \\<Longrightarrow> a ^ Suc N \\<le> a ^ n", "case (Suc N)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> N; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n  \\<Longrightarrow> a ^ N \\<le> a ^ n\n  n \\<le> Suc N\n  (0::'a) \\<le> a\n  a \\<le> (1::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> 0; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> a ^ 0 \\<le> a ^ n\n 2. \\<And>N.\n       \\<lbrakk>\\<lbrakk>n \\<le> N; (0::'a) \\<le> a;\n                 a \\<le> (1::'a)\\<rbrakk>\n                \\<Longrightarrow> a ^ N \\<le> a ^ n;\n        n \\<le> Suc N; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n       \\<Longrightarrow> a ^ Suc N \\<le> a ^ n", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<le> N; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n  \\<Longrightarrow> a ^ N \\<le> a ^ n\n  n \\<le> Suc N\n  (0::'a) \\<le> a\n  a \\<le> (1::'a)", "have \"a * a^N \\<le> 1 * a^n\" if \"n \\<le> N\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> N; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n  \\<Longrightarrow> a ^ N \\<le> a ^ n\n  n \\<le> Suc N\n  (0::'a) \\<le> a\n  a \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. a * a ^ N \\<le> (1::'a) * a ^ n", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> N; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n  \\<Longrightarrow> a ^ N \\<le> a ^ n\n  n \\<le> Suc N\n  (0::'a) \\<le> a\n  a \\<le> (1::'a)\n  n \\<le> N\n\ngoal (1 subgoal):\n 1. a * a ^ N \\<le> (1::'a) * a ^ n", "by (intro mult_mono) auto"], ["proof (state)\nthis:\n  n \\<le> N \\<Longrightarrow> a * a ^ N \\<le> (1::'a) * a ^ n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> 0; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> a ^ 0 \\<le> a ^ n\n 2. \\<And>N.\n       \\<lbrakk>\\<lbrakk>n \\<le> N; (0::'a) \\<le> a;\n                 a \\<le> (1::'a)\\<rbrakk>\n                \\<Longrightarrow> a ^ N \\<le> a ^ n;\n        n \\<le> Suc N; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n       \\<Longrightarrow> a ^ Suc N \\<le> a ^ n", "then"], ["proof (chain)\npicking this:\n  n \\<le> N \\<Longrightarrow> a * a ^ N \\<le> (1::'a) * a ^ n", "show ?case"], ["proof (prove)\nusing this:\n  n \\<le> N \\<Longrightarrow> a * a ^ N \\<le> (1::'a) * a ^ n\n\ngoal (1 subgoal):\n 1. a ^ Suc N \\<le> a ^ n", "using Suc"], ["proof (prove)\nusing this:\n  n \\<le> N \\<Longrightarrow> a * a ^ N \\<le> (1::'a) * a ^ n\n  \\<lbrakk>n \\<le> N; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n  \\<Longrightarrow> a ^ N \\<le> a ^ n\n  n \\<le> Suc N\n  (0::'a) \\<le> a\n  a \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. a ^ Suc N \\<le> a ^ n", "by (auto simp add: le_Suc_eq)"], ["proof (state)\nthis:\n  a ^ Suc N \\<le> a ^ n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> 0; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> a ^ 0 \\<le> a ^ n", "qed (auto)"], ["", "lemma power_increasing: \"n \\<le> N \\<Longrightarrow> 1 \\<le> a \\<Longrightarrow> a ^ n \\<le> a ^ N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> N; (1::'a) \\<le> a\\<rbrakk>\n    \\<Longrightarrow> a ^ n \\<le> a ^ N", "proof (induction N)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> 0; (1::'a) \\<le> a\\<rbrakk>\n    \\<Longrightarrow> a ^ n \\<le> a ^ 0\n 2. \\<And>N.\n       \\<lbrakk>\\<lbrakk>n \\<le> N; (1::'a) \\<le> a\\<rbrakk>\n                \\<Longrightarrow> a ^ n \\<le> a ^ N;\n        n \\<le> Suc N; (1::'a) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a ^ n \\<le> a ^ Suc N", "case (Suc N)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> N; (1::'a) \\<le> a\\<rbrakk>\n  \\<Longrightarrow> a ^ n \\<le> a ^ N\n  n \\<le> Suc N\n  (1::'a) \\<le> a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> 0; (1::'a) \\<le> a\\<rbrakk>\n    \\<Longrightarrow> a ^ n \\<le> a ^ 0\n 2. \\<And>N.\n       \\<lbrakk>\\<lbrakk>n \\<le> N; (1::'a) \\<le> a\\<rbrakk>\n                \\<Longrightarrow> a ^ n \\<le> a ^ N;\n        n \\<le> Suc N; (1::'a) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a ^ n \\<le> a ^ Suc N", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<le> N; (1::'a) \\<le> a\\<rbrakk>\n  \\<Longrightarrow> a ^ n \\<le> a ^ N\n  n \\<le> Suc N\n  (1::'a) \\<le> a", "have \"1 * a^n \\<le> a * a^N\" if \"n \\<le> N\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> N; (1::'a) \\<le> a\\<rbrakk>\n  \\<Longrightarrow> a ^ n \\<le> a ^ N\n  n \\<le> Suc N\n  (1::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. (1::'a) * a ^ n \\<le> a * a ^ N", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> N; (1::'a) \\<le> a\\<rbrakk>\n  \\<Longrightarrow> a ^ n \\<le> a ^ N\n  n \\<le> Suc N\n  (1::'a) \\<le> a\n  n \\<le> N\n\ngoal (1 subgoal):\n 1. (1::'a) * a ^ n \\<le> a * a ^ N", "by (intro mult_mono) (auto simp add: order_trans[OF zero_le_one])"], ["proof (state)\nthis:\n  n \\<le> N \\<Longrightarrow> (1::'a) * a ^ n \\<le> a * a ^ N\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<le> 0; (1::'a) \\<le> a\\<rbrakk>\n    \\<Longrightarrow> a ^ n \\<le> a ^ 0\n 2. \\<And>N.\n       \\<lbrakk>\\<lbrakk>n \\<le> N; (1::'a) \\<le> a\\<rbrakk>\n                \\<Longrightarrow> a ^ n \\<le> a ^ N;\n        n \\<le> Suc N; (1::'a) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a ^ n \\<le> a ^ Suc N", "then"], ["proof (chain)\npicking this:\n  n \\<le> N \\<Longrightarrow> (1::'a) * a ^ n \\<le> a * a ^ N", "show ?case"], ["proof (prove)\nusing this:\n  n \\<le> N \\<Longrightarrow> (1::'a) * a ^ n \\<le> a * a ^ N\n\ngoal (1 subgoal):\n 1. a ^ n \\<le> a ^ Suc N", "using Suc"], ["proof (prove)\nusing this:\n  n \\<le> N \\<Longrightarrow> (1::'a) * a ^ n \\<le> a * a ^ N\n  \\<lbrakk>n \\<le> N; (1::'a) \\<le> a\\<rbrakk>\n  \\<Longrightarrow> a ^ n \\<le> a ^ N\n  n \\<le> Suc N\n  (1::'a) \\<le> a\n\ngoal (1 subgoal):\n 1. a ^ n \\<le> a ^ Suc N", "by (auto simp add: le_Suc_eq)"], ["proof (state)\nthis:\n  a ^ n \\<le> a ^ Suc N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> 0; (1::'a) \\<le> a\\<rbrakk>\n    \\<Longrightarrow> a ^ n \\<le> a ^ 0", "qed (auto)"], ["", "lemma power_Suc_le_self: \"0 \\<le> a \\<Longrightarrow> a \\<le> 1 \\<Longrightarrow> a ^ Suc n \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> a ^ Suc n \\<le> a", "using power_decreasing [of 1 \"Suc n\" a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<le> Suc n; (0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n  \\<Longrightarrow> a ^ Suc n \\<le> a ^ 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'a) \\<le> a; a \\<le> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> a ^ Suc n \\<le> a", "by simp"], ["", "end"], ["", "lemma prod_list_nonneg: \"(\\<And> x. (x :: 'a :: ordered_semiring_1) \\<in> set xs \\<Longrightarrow> x \\<ge> 0) \\<Longrightarrow> prod_list xs \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> (0::'a) \\<le> x) \\<Longrightarrow>\n    (0::'a) \\<le> prod_list xs", "by (induct xs, auto)"], ["", "subclass (in ordered_idom) ordered_semiring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ordered_semiring_1 (1::'a) (*) (+) (0::'a) (\\<le>) (<)", "by unfold_locales auto"], ["", "(**** End of lemmas that could be moved to HOL/Rings.thy ****)\n\n(* missing lemma on logarithms *)"], ["", "lemma log_prod: assumes \"0 < a\" \"a \\<noteq> 1\" \"\\<And> x. x \\<in> X \\<Longrightarrow> 0 < f x\" \n  shows \"log a (prod f X) = sum (log a o f) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log a (prod f X) = sum (log a \\<circ> f) X", "using assms(3)"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> 0 < f ?x\n\ngoal (1 subgoal):\n 1. log a (prod f X) = sum (log a \\<circ> f) X", "proof (induct X rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> 0 < f x\\<rbrakk>\n       \\<Longrightarrow> log a (prod f A) = sum (log a \\<circ> f) A\n 2. (\\<And>x. x \\<in> {} \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n    log a (prod f {}) = sum (log a \\<circ> f) {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x. x \\<in> F \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n        log a (prod f F) = sum (log a \\<circ> f) F;\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> 0 < f xa\\<rbrakk>\n       \\<Longrightarrow> log a (prod f (insert x F)) =\n                         sum (log a \\<circ> f) (insert x F)", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  (\\<And>x. x \\<in> F \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n  log a (prod f F) = sum (log a \\<circ> f) F\n  ?x \\<in> insert x F \\<Longrightarrow> 0 < f ?x\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> 0 < f x\\<rbrakk>\n       \\<Longrightarrow> log a (prod f A) = sum (log a \\<circ> f) A\n 2. (\\<And>x. x \\<in> {} \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n    log a (prod f {}) = sum (log a \\<circ> f) {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x. x \\<in> F \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n        log a (prod f F) = sum (log a \\<circ> f) F;\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> 0 < f xa\\<rbrakk>\n       \\<Longrightarrow> log a (prod f (insert x F)) =\n                         sum (log a \\<circ> f) (insert x F)", "have \"log a (prod f (insert x F)) = log a (f x * prod f F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log a (prod f (insert x F)) = log a (f x * prod f F)", "using insert"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  (\\<And>x. x \\<in> F \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n  log a (prod f F) = sum (log a \\<circ> f) F\n  ?x \\<in> insert x F \\<Longrightarrow> 0 < f ?x\n\ngoal (1 subgoal):\n 1. log a (prod f (insert x F)) = log a (f x * prod f F)", "by simp"], ["proof (state)\nthis:\n  log a (prod f (insert x F)) = log a (f x * prod f F)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> 0 < f x\\<rbrakk>\n       \\<Longrightarrow> log a (prod f A) = sum (log a \\<circ> f) A\n 2. (\\<And>x. x \\<in> {} \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n    log a (prod f {}) = sum (log a \\<circ> f) {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x. x \\<in> F \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n        log a (prod f F) = sum (log a \\<circ> f) F;\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> 0 < f xa\\<rbrakk>\n       \\<Longrightarrow> log a (prod f (insert x F)) =\n                         sum (log a \\<circ> f) (insert x F)", "also"], ["proof (state)\nthis:\n  log a (prod f (insert x F)) = log a (f x * prod f F)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> 0 < f x\\<rbrakk>\n       \\<Longrightarrow> log a (prod f A) = sum (log a \\<circ> f) A\n 2. (\\<And>x. x \\<in> {} \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n    log a (prod f {}) = sum (log a \\<circ> f) {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x. x \\<in> F \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n        log a (prod f F) = sum (log a \\<circ> f) F;\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> 0 < f xa\\<rbrakk>\n       \\<Longrightarrow> log a (prod f (insert x F)) =\n                         sum (log a \\<circ> f) (insert x F)", "have \"\\<dots> = log a (f x) + log a (prod f F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log a (f x * prod f F) = log a (f x) + log a (prod f F)", "by (rule log_mult[OF assms(1-2) insert(4) prod_pos], insert insert, auto)"], ["proof (state)\nthis:\n  log a (f x * prod f F) = log a (f x) + log a (prod f F)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> 0 < f x\\<rbrakk>\n       \\<Longrightarrow> log a (prod f A) = sum (log a \\<circ> f) A\n 2. (\\<And>x. x \\<in> {} \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n    log a (prod f {}) = sum (log a \\<circ> f) {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>x. x \\<in> F \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n        log a (prod f F) = sum (log a \\<circ> f) F;\n        \\<And>xa. xa \\<in> insert x F \\<Longrightarrow> 0 < f xa\\<rbrakk>\n       \\<Longrightarrow> log a (prod f (insert x F)) =\n                         sum (log a \\<circ> f) (insert x F)", "finally"], ["proof (chain)\npicking this:\n  log a (prod f (insert x F)) = log a (f x) + log a (prod f F)", "show ?case"], ["proof (prove)\nusing this:\n  log a (prod f (insert x F)) = log a (f x) + log a (prod f F)\n\ngoal (1 subgoal):\n 1. log a (prod f (insert x F)) = sum (log a \\<circ> f) (insert x F)", "using insert"], ["proof (prove)\nusing this:\n  log a (prod f (insert x F)) = log a (f x) + log a (prod f F)\n  finite F\n  x \\<notin> F\n  (\\<And>x. x \\<in> F \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n  log a (prod f F) = sum (log a \\<circ> f) F\n  ?x \\<in> insert x F \\<Longrightarrow> 0 < f ?x\n\ngoal (1 subgoal):\n 1. log a (prod f (insert x F)) = sum (log a \\<circ> f) (insert x F)", "by auto"], ["proof (state)\nthis:\n  log a (prod f (insert x F)) = sum (log a \\<circ> f) (insert x F)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> 0 < f x\\<rbrakk>\n       \\<Longrightarrow> log a (prod f A) = sum (log a \\<circ> f) A\n 2. (\\<And>x. x \\<in> {} \\<Longrightarrow> 0 < f x) \\<Longrightarrow>\n    log a (prod f {}) = sum (log a \\<circ> f) {}", "qed auto"], ["", "(* TODO: Jordan_Normal_Form/Missing_Ring.ordered_idom should be redefined *)"], ["", "subclass (in ordered_idom) zero_less_one"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.zero_less_one (1::'a) (0::'a) (\\<le>) (<)", "by (unfold_locales, auto)"], ["", "hide_fact Missing_Ring.zero_less_one"], ["", "(**** The following lemmas could be part of the standard library ****)"], ["", "instance real :: ordered_semiring_strict"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real, ordered_semiring_strict_class)", "by (intro_classes, auto)"], ["", "instance real :: linordered_idom"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real, linordered_idom_class)", ".."], ["", "(*This is a generalisation of thm less_1_mult*)"], ["", "lemma less_1_mult': \n  fixes a::\"'a::linordered_semidom\"\n  shows \"1 < a \\<Longrightarrow> 1 \\<le> b \\<Longrightarrow> 1 < a * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(1::'a) < a; (1::'a) \\<le> b\\<rbrakk>\n    \\<Longrightarrow> (1::'a) < a * b", "by (metis le_less less_1_mult mult.right_neutral)"], ["", "lemma upt_minus_eq_append: \"i\\<le>j \\<Longrightarrow> i\\<le>j-k \\<Longrightarrow> [i..<j] = [i..<j-k] @ [j-k..<j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; i \\<le> j - k\\<rbrakk>\n    \\<Longrightarrow> [i..<j] = [i..<j - k] @ [j - k..<j]", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<le> j; i \\<le> j - 0\\<rbrakk>\n    \\<Longrightarrow> [i..<j] = [i..<j - 0] @ [j - 0..<j]\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>i \\<le> j; i \\<le> j - k\\<rbrakk>\n                \\<Longrightarrow> [i..<j] = [i..<j - k] @ [j - k..<j];\n        i \\<le> j; i \\<le> j - Suc k\\<rbrakk>\n       \\<Longrightarrow> [i..<j] = [i..<j - Suc k] @ [j - Suc k..<j]", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> j; i \\<le> j - k\\<rbrakk>\n  \\<Longrightarrow> [i..<j] = [i..<j - k] @ [j - k..<j]\n  i \\<le> j\n  i \\<le> j - Suc k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<le> j; i \\<le> j - 0\\<rbrakk>\n    \\<Longrightarrow> [i..<j] = [i..<j - 0] @ [j - 0..<j]\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>i \\<le> j; i \\<le> j - k\\<rbrakk>\n                \\<Longrightarrow> [i..<j] = [i..<j - k] @ [j - k..<j];\n        i \\<le> j; i \\<le> j - Suc k\\<rbrakk>\n       \\<Longrightarrow> [i..<j] = [i..<j - Suc k] @ [j - Suc k..<j]", "have hyp: \"[i..<j] = [i..<j - k] @ [j - k..<j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i..<j] = [i..<j - k] @ [j - k..<j]", "using Suc.hyps Suc.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> j; i \\<le> j - k\\<rbrakk>\n  \\<Longrightarrow> [i..<j] = [i..<j - k] @ [j - k..<j]\n  i \\<le> j\n  i \\<le> j - Suc k\n\ngoal (1 subgoal):\n 1. [i..<j] = [i..<j - k] @ [j - k..<j]", "by auto"], ["proof (state)\nthis:\n  [i..<j] = [i..<j - k] @ [j - k..<j]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<le> j; i \\<le> j - 0\\<rbrakk>\n    \\<Longrightarrow> [i..<j] = [i..<j - 0] @ [j - 0..<j]\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>i \\<le> j; i \\<le> j - k\\<rbrakk>\n                \\<Longrightarrow> [i..<j] = [i..<j - k] @ [j - k..<j];\n        i \\<le> j; i \\<le> j - Suc k\\<rbrakk>\n       \\<Longrightarrow> [i..<j] = [i..<j - Suc k] @ [j - Suc k..<j]", "then"], ["proof (chain)\npicking this:\n  [i..<j] = [i..<j - k] @ [j - k..<j]", "show ?case"], ["proof (prove)\nusing this:\n  [i..<j] = [i..<j - k] @ [j - k..<j]\n\ngoal (1 subgoal):\n 1. [i..<j] = [i..<j - Suc k] @ [j - Suc k..<j]", "by (metis Suc.prems(2) append.simps(1) diff_Suc_less nat_less_le neq0_conv upt_append upt_rec zero_diff)"], ["proof (state)\nthis:\n  [i..<j] = [i..<j - Suc k] @ [j - Suc k..<j]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; i \\<le> j - 0\\<rbrakk>\n    \\<Longrightarrow> [i..<j] = [i..<j - 0] @ [j - 0..<j]", "qed auto"], ["", "lemma list_trisect: \"x < length lst \\<Longrightarrow> [0..<length lst] = [0..<x]@x#[Suc x..<length lst]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < length lst \\<Longrightarrow>\n    [0..<length lst] = [0..<x] @ x # [Suc x..<length lst]", "by (induct lst, force, rename_tac a lst, case_tac \"x = length lst\", auto)"], ["", "lemma id_imp_bij_betw:\n  assumes f: \"f : A \\<rightarrow> A\"\n      and ff: \"\\<And>a. a \\<in> A \\<Longrightarrow> f (f a) = a\"\n  shows \"bij_betw f A A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw f A A", "by (intro bij_betwI[OF f f], simp_all add: ff)"], ["", "lemma range_subsetI:\n  assumes \"\\<And>x. f x = g (h x)\" shows \"range f \\<subseteq> range g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range f \\<subseteq> range g", "using assms"], ["proof (prove)\nusing this:\n  f ?x = g (h ?x)\n\ngoal (1 subgoal):\n 1. range f \\<subseteq> range g", "by auto"], ["", "lemma Gcd_uminus: \n  fixes A::\"int set\"\n  assumes \"finite A\"\n  shows \"Gcd A = Gcd (uminus ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gcd A = Gcd (uminus ` A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. Gcd A = Gcd (uminus ` A)", "by (induct A, auto)"], ["", "lemma aux_abs_int: fixes c :: int\n  assumes \"c \\<noteq> 0\" \n  shows \"\\<bar>x\\<bar> \\<le> \\<bar>x * c\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x * c\\<bar>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x * c\\<bar>", "have \"abs x = abs x * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> = \\<bar>x\\<bar> * 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> = \\<bar>x\\<bar> * 1\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x * c\\<bar>", "also"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> = \\<bar>x\\<bar> * 1\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x * c\\<bar>", "have \"\\<dots> \\<le> abs x * abs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> * 1 \\<le> \\<bar>x\\<bar> * \\<bar>c\\<bar>", "by (rule mult_left_mono, insert assms, auto)"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> * 1 \\<le> \\<bar>x\\<bar> * \\<bar>c\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x * c\\<bar>", "finally"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> \\<le> \\<bar>x\\<bar> * \\<bar>c\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> \\<bar>x\\<bar> * \\<bar>c\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x * c\\<bar>", "unfolding abs_mult"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> \\<bar>x\\<bar> * \\<bar>c\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x\\<bar> * \\<bar>c\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> \\<bar>x * c\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_0_abs_less_imp_0:\n  fixes a::int\n  assumes a1: \"[a = 0] (mod m)\"\n  and a2: \"abs(a)<m\"\n  shows \"a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = 0", "have \"m\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> m", "using assms"], ["proof (prove)\nusing this:\n  [a = 0] (mod m)\n  \\<bar>a\\<bar> < m\n\ngoal (1 subgoal):\n 1. 0 \\<le> m", "by auto"], ["proof (state)\nthis:\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. a = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. a = 0", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> m\n  [a = 0] (mod m)\n  \\<bar>a\\<bar> < m\n\ngoal (1 subgoal):\n 1. a = 0", "unfolding cong_def"], ["proof (prove)\nusing this:\n  0 \\<le> m\n  a mod m = 0 mod m\n  \\<bar>a\\<bar> < m\n\ngoal (1 subgoal):\n 1. a = 0", "using int_mod_pos_eq large_mod_0 zless_imp_add1_zle"], ["proof (prove)\nusing this:\n  0 \\<le> m\n  a mod m = 0 mod m\n  \\<bar>a\\<bar> < m\n  \\<lbrakk>?a = ?b * ?q + ?r; 0 \\<le> ?r; ?r < ?b\\<rbrakk>\n  \\<Longrightarrow> ?a mod ?b = ?r\n  \\<lbrakk>1 < ?n; \\<bar>?k\\<bar> < ?n; ?k mod ?n = 0\\<rbrakk>\n  \\<Longrightarrow> ?k = 0\n  ?w < ?z \\<Longrightarrow> ?w + 1 \\<le> ?z\n\ngoal (1 subgoal):\n 1. a = 0", "by (metis abs_of_nonneg le_less not_less zabs_less_one_iff zmod_trivial_iff)"], ["proof (state)\nthis:\n  a = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "(* an intro version of sum_list_0 *)"], ["", "lemma sum_list_zero:\n  assumes \"set xs \\<subseteq> {0}\" shows \"sum_list xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> {0::'a}\n\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)", "by (induct xs, auto)"], ["", "(* About @{const max} *)"], ["", "lemma max_idem [simp]: shows \"max a a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max a a = a", "by (simp add: max_def)"], ["", "lemma hom_max:\n  assumes \"a \\<le> b \\<longleftrightarrow> f a \\<le> f b\"\n  shows \"f (max a b) = max (f a) (f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (max a b) = max (f a) (f b)", "using assms"], ["proof (prove)\nusing this:\n  (a \\<le> b) = (f a \\<le> f b)\n\ngoal (1 subgoal):\n 1. f (max a b) = max (f a) (f b)", "by (auto simp: max_def)"], ["", "lemma le_max_self:\n  fixes a b :: \"'a :: preorder\"\n  assumes \"a \\<le> b \\<or> b \\<le> a\" shows \"a \\<le> max a b\" and \"b \\<le> max a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> max a b &&& b \\<le> max a b", "using assms"], ["proof (prove)\nusing this:\n  a \\<le> b \\<or> b \\<le> a\n\ngoal (1 subgoal):\n 1. a \\<le> max a b &&& b \\<le> max a b", "by (auto simp: max_def)"], ["", "lemma le_max:\n  fixes a b :: \"'a :: preorder\"\n  assumes \"c \\<le> a \\<or> c \\<le> b\" and \"a \\<le> b \\<or> b \\<le> a\" shows \"c \\<le> max a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> max a b", "using assms(1) le_max_self[OF assms(2)]"], ["proof (prove)\nusing this:\n  c \\<le> a \\<or> c \\<le> b\n  a \\<le> max a b\n  b \\<le> max a b\n\ngoal (1 subgoal):\n 1. c \\<le> max a b", "by (auto dest: order_trans)"], ["", "fun max_list where\n  \"max_list [] = (THE x. False)\" (* more convenient than \"undefined\" *)\n| \"max_list [x] = x\"\n| \"max_list (x # y # xs) = max x (max_list (y # xs))\""], ["", "declare max_list.simps(1) [simp del]"], ["", "declare max_list.simps(2-3)[code]"], ["", "lemma max_list_Cons: \"max_list (x#xs) = (if xs = [] then x else max x (max_list xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list (x # xs) =\n    (if xs = [] then x else max x (Missing_Lemmas.max_list xs))", "by (cases xs, auto)"], ["", "lemma max_list_mem: \"xs \\<noteq> [] \\<Longrightarrow> max_list xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> Missing_Lemmas.max_list xs \\<in> set xs", "by (induct xs, auto simp: max_list_Cons max_def)"], ["", "lemma mem_set_imp_le_max_list:\n  fixes xs :: \"'a :: preorder list\"\n  assumes \"\\<And>a b. a \\<in> set xs \\<Longrightarrow> b \\<in> set xs \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a\"\n      and \"a \\<in> set xs\"\n  shows \"a \\<le> max_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list xs", "proof (insert assms, induct xs arbitrary:a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>a \\<in> set []; b \\<in> set []\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        a \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list []\n 2. \\<And>a xs aa.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<And>a b.\n                               \\<lbrakk>a \\<in> set xs;\n                                b \\<in> set xs\\<rbrakk>\n                               \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n                    a \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list xs;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs); b \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> aa \\<le> b \\<or> b \\<le> aa;\n        aa \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> aa \\<le> Missing_Lemmas.max_list (a # xs)", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> set []; ?b \\<in> set []\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<or> ?b \\<le> ?a\n  a \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>a \\<in> set []; b \\<in> set []\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n        a \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list []\n 2. \\<And>a xs aa.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<And>a b.\n                               \\<lbrakk>a \\<in> set xs;\n                                b \\<in> set xs\\<rbrakk>\n                               \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n                    a \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list xs;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs); b \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> aa \\<le> b \\<or> b \\<le> aa;\n        aa \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> aa \\<le> Missing_Lemmas.max_list (a # xs)", "with assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> set xs; ?b \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<or> ?b \\<le> ?a\n  a \\<in> set xs\n  \\<lbrakk>?a \\<in> set []; ?b \\<in> set []\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<or> ?b \\<le> ?a\n  a \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> set xs; ?b \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<or> ?b \\<le> ?a\n  a \\<in> set xs\n  \\<lbrakk>?a \\<in> set []; ?b \\<in> set []\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<or> ?b \\<le> ?a\n  a \\<in> set []\n\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list []", "by auto"], ["proof (state)\nthis:\n  a \\<le> Missing_Lemmas.max_list []\n\ngoal (1 subgoal):\n 1. \\<And>a xs aa.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<And>a b.\n                               \\<lbrakk>a \\<in> set xs;\n                                b \\<in> set xs\\<rbrakk>\n                               \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n                    a \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list xs;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs); b \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> aa \\<le> b \\<or> b \\<le> aa;\n        aa \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> aa \\<le> Missing_Lemmas.max_list (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs aa.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<And>a b.\n                               \\<lbrakk>a \\<in> set xs;\n                                b \\<in> set xs\\<rbrakk>\n                               \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n                    a \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list xs;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs); b \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> aa \\<le> b \\<or> b \\<le> aa;\n        aa \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> aa \\<le> Missing_Lemmas.max_list (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>a b.\n              \\<lbrakk>a \\<in> set xs; b \\<in> set xs\\<rbrakk>\n              \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n   ?a \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> Missing_Lemmas.max_list xs\n  \\<lbrakk>?a \\<in> set (x # xs); ?b \\<in> set (x # xs)\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<or> ?b \\<le> ?a\n  a \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs aa.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<And>a b.\n                               \\<lbrakk>a \\<in> set xs;\n                                b \\<in> set xs\\<rbrakk>\n                               \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n                    a \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list xs;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs); b \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> aa \\<le> b \\<or> b \\<le> aa;\n        aa \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> aa \\<le> Missing_Lemmas.max_list (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list (x # xs)", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list (x # xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list (x # xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "have \"x \\<le> max_list xs \\<or> max_list xs \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> Missing_Lemmas.max_list xs \\<or>\n    Missing_Lemmas.max_list xs \\<le> x", "apply (rule Cons(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> set (x # xs)\n 2. Missing_Lemmas.max_list xs \\<in> set (x # xs)", "using max_list_mem[of xs] False"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow> Missing_Lemmas.max_list xs \\<in> set xs\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. x \\<in> set (x # xs)\n 2. Missing_Lemmas.max_list xs \\<in> set (x # xs)", "by auto"], ["proof (state)\nthis:\n  x \\<le> Missing_Lemmas.max_list xs \\<or>\n  Missing_Lemmas.max_list xs \\<le> x\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list (x # xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "note 1 = le_max_self[OF this]"], ["proof (state)\nthis:\n  x \\<le> max x (Missing_Lemmas.max_list xs)\n  Missing_Lemmas.max_list xs \\<le> max x (Missing_Lemmas.max_list xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list (x # xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>a b.\n              \\<lbrakk>a \\<in> set xs; b \\<in> set xs\\<rbrakk>\n              \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n   ?a \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> Missing_Lemmas.max_list xs\n  \\<lbrakk>?a \\<in> set (x # xs); ?b \\<in> set (x # xs)\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<or> ?b \\<le> ?a\n  a \\<in> set (x # xs)", "have \"a = x \\<or> a \\<in> set xs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>a b.\n              \\<lbrakk>a \\<in> set xs; b \\<in> set xs\\<rbrakk>\n              \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a;\n   ?a \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> Missing_Lemmas.max_list xs\n  \\<lbrakk>?a \\<in> set (x # xs); ?b \\<in> set (x # xs)\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?b \\<or> ?b \\<le> ?a\n  a \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. a = x \\<or> a \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  a = x \\<or> a \\<in> set xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list (x # xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "then"], ["proof (chain)\npicking this:\n  a = x \\<or> a \\<in> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  a = x \\<or> a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list (x # xs)", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list (x # xs)\n 2. a \\<in> set xs \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "assume a: \"a = x\""], ["proof (state)\nthis:\n  a = x\n\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list (x # xs)\n 2. a \\<in> set xs \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list (x # xs)", "by (unfold a max_list_Cons, auto simp: False intro!: 1)"], ["proof (state)\nthis:\n  a \\<le> Missing_Lemmas.max_list (x # xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "assume \"a \\<in> set xs\""], ["proof (state)\nthis:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "then"], ["proof (chain)\npicking this:\n  a \\<in> set xs", "have \"a \\<le> max_list xs\""], ["proof (prove)\nusing this:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list xs", "by (intro Cons, auto)"], ["proof (state)\nthis:\n  a \\<le> Missing_Lemmas.max_list xs\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "with 1"], ["proof (chain)\npicking this:\n  x \\<le> max x (Missing_Lemmas.max_list xs)\n  Missing_Lemmas.max_list xs \\<le> max x (Missing_Lemmas.max_list xs)\n  a \\<le> Missing_Lemmas.max_list xs", "have \"a \\<le> max x (max_list xs)\""], ["proof (prove)\nusing this:\n  x \\<le> max x (Missing_Lemmas.max_list xs)\n  Missing_Lemmas.max_list xs \\<le> max x (Missing_Lemmas.max_list xs)\n  a \\<le> Missing_Lemmas.max_list xs\n\ngoal (1 subgoal):\n 1. a \\<le> max x (Missing_Lemmas.max_list xs)", "by (auto dest: order_trans)"], ["proof (state)\nthis:\n  a \\<le> max x (Missing_Lemmas.max_list xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow>\n    a \\<le> Missing_Lemmas.max_list (x # xs)", "then"], ["proof (chain)\npicking this:\n  a \\<le> max x (Missing_Lemmas.max_list xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> max x (Missing_Lemmas.max_list xs)\n\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list (x # xs)", "by (unfold max_list_Cons, auto simp: False)"], ["proof (state)\nthis:\n  a \\<le> Missing_Lemmas.max_list (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<le> Missing_Lemmas.max_list (x # xs)\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> a \\<le> Missing_Lemmas.max_list (x # xs)", "qed (insert Cons, auto)"], ["proof (state)\nthis:\n  a \\<le> Missing_Lemmas.max_list (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_max_list:\n  fixes xs :: \"'a :: preorder list\"\n  assumes ord: \"\\<And>a b. a \\<in> set xs \\<Longrightarrow> b \\<in> set xs \\<Longrightarrow> a \\<le> b \\<or> b \\<le> a\"\n      and ab: \"a \\<le> b\"\n      and b: \"b \\<in> set xs\"\n  shows \"a \\<le> max_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list xs", "note ab"], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list xs", "also"], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list xs", "have \"b \\<le> max_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> Missing_Lemmas.max_list xs", "by (rule mem_set_imp_le_max_list, fact ord, fact b)"], ["proof (state)\nthis:\n  b \\<le> Missing_Lemmas.max_list xs\n\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list xs", "finally"], ["proof (chain)\npicking this:\n  a \\<le> Missing_Lemmas.max_list xs", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> Missing_Lemmas.max_list xs\n\ngoal (1 subgoal):\n 1. a \\<le> Missing_Lemmas.max_list xs", "."], ["proof (state)\nthis:\n  a \\<le> Missing_Lemmas.max_list xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_list_le:\n  fixes xs :: \"'a :: preorder list\"\n  assumes a: \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<le> a\"\n      and xs: \"xs \\<noteq> []\"\n  shows \"max_list xs \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list xs \\<le> a", "using max_list_mem[OF xs] a"], ["proof (prove)\nusing this:\n  Missing_Lemmas.max_list xs \\<in> set xs\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<le> a\n\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list xs \\<le> a", "by auto"], ["", "lemma max_list_as_Greatest:\n  assumes \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set xs \\<Longrightarrow> x \\<le> y \\<or> y \\<le> x\"\n  shows \"max_list xs = (GREATEST a. a \\<in> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "then"], ["proof (chain)\npicking this:\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "by (unfold Greatest_def, auto simp: max_list.simps(1))"], ["proof (state)\nthis:\n  Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set xs; ?y \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y \\<or> ?y \\<le> ?x", "have 1: \"x \\<in> set xs \\<Longrightarrow> x \\<le> max_list xs\" for x"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; ?y \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y \\<or> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> x \\<le> Missing_Lemmas.max_list xs", "by (auto intro: le_max_list)"], ["proof (state)\nthis:\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<le> Missing_Lemmas.max_list xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "have 2: \"max_list xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list xs \\<in> set xs", "by (fact max_list_mem[OF False])"], ["proof (state)\nthis:\n  Missing_Lemmas.max_list xs \\<in> set xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "have \"\\<exists>!x. x \\<in> set xs \\<and> (\\<forall>y. y \\<in> set xs \\<longrightarrow> y \\<le> x)\" (is \"\\<exists>!x. ?P x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y. y \\<in> set xs \\<longrightarrow> y \\<le> x)", "proof (intro ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a \\<in> set xs \\<and>\n    (\\<forall>y. y \\<in> set xs \\<longrightarrow> y \\<le> ?a)\n 2. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y.\n           y \\<in> set xs \\<longrightarrow> y \\<le> x) \\<Longrightarrow>\n       x = ?a", "from 1 2"], ["proof (chain)\npicking this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<le> Missing_Lemmas.max_list xs\n  Missing_Lemmas.max_list xs \\<in> set xs", "show \"?P (max_list xs)\""], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<le> Missing_Lemmas.max_list xs\n  Missing_Lemmas.max_list xs \\<in> set xs\n\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list xs \\<in> set xs \\<and>\n    (\\<forall>y.\n        y \\<in> set xs \\<longrightarrow> y \\<le> Missing_Lemmas.max_list xs)", "by auto"], ["proof (state)\nthis:\n  Missing_Lemmas.max_list xs \\<in> set xs \\<and>\n  (\\<forall>y.\n      y \\<in> set xs \\<longrightarrow> y \\<le> Missing_Lemmas.max_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y.\n           y \\<in> set xs \\<longrightarrow> y \\<le> x) \\<Longrightarrow>\n       x = Missing_Lemmas.max_list xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y.\n           y \\<in> set xs \\<longrightarrow> y \\<le> x) \\<Longrightarrow>\n       x = Missing_Lemmas.max_list xs", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y.\n           y \\<in> set xs \\<longrightarrow> y \\<le> x) \\<Longrightarrow>\n       x = Missing_Lemmas.max_list xs", "assume 3: \"?P x\""], ["proof (state)\nthis:\n  x \\<in> set xs \\<and>\n  (\\<forall>y. y \\<in> set xs \\<longrightarrow> y \\<le> x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y.\n           y \\<in> set xs \\<longrightarrow> y \\<le> x) \\<Longrightarrow>\n       x = Missing_Lemmas.max_list xs", "with 1"], ["proof (chain)\npicking this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<le> Missing_Lemmas.max_list xs\n  x \\<in> set xs \\<and>\n  (\\<forall>y. y \\<in> set xs \\<longrightarrow> y \\<le> x)", "have \"x \\<le> max_list xs\""], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<le> Missing_Lemmas.max_list xs\n  x \\<in> set xs \\<and>\n  (\\<forall>y. y \\<in> set xs \\<longrightarrow> y \\<le> x)\n\ngoal (1 subgoal):\n 1. x \\<le> Missing_Lemmas.max_list xs", "by auto"], ["proof (state)\nthis:\n  x \\<le> Missing_Lemmas.max_list xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y.\n           y \\<in> set xs \\<longrightarrow> y \\<le> x) \\<Longrightarrow>\n       x = Missing_Lemmas.max_list xs", "moreover"], ["proof (state)\nthis:\n  x \\<le> Missing_Lemmas.max_list xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y.\n           y \\<in> set xs \\<longrightarrow> y \\<le> x) \\<Longrightarrow>\n       x = Missing_Lemmas.max_list xs", "from 2 3"], ["proof (chain)\npicking this:\n  Missing_Lemmas.max_list xs \\<in> set xs\n  x \\<in> set xs \\<and>\n  (\\<forall>y. y \\<in> set xs \\<longrightarrow> y \\<le> x)", "have \"max_list xs \\<le> x\""], ["proof (prove)\nusing this:\n  Missing_Lemmas.max_list xs \\<in> set xs\n  x \\<in> set xs \\<and>\n  (\\<forall>y. y \\<in> set xs \\<longrightarrow> y \\<le> x)\n\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list xs \\<le> x", "by auto"], ["proof (state)\nthis:\n  Missing_Lemmas.max_list xs \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y.\n           y \\<in> set xs \\<longrightarrow> y \\<le> x) \\<Longrightarrow>\n       x = Missing_Lemmas.max_list xs", "ultimately"], ["proof (chain)\npicking this:\n  x \\<le> Missing_Lemmas.max_list xs\n  Missing_Lemmas.max_list xs \\<le> x", "show \"x = max_list xs\""], ["proof (prove)\nusing this:\n  x \\<le> Missing_Lemmas.max_list xs\n  Missing_Lemmas.max_list xs \\<le> x\n\ngoal (1 subgoal):\n 1. x = Missing_Lemmas.max_list xs", "by auto"], ["proof (state)\nthis:\n  x = Missing_Lemmas.max_list xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!x.\n     x \\<in> set xs \\<and>\n     (\\<forall>y. y \\<in> set xs \\<longrightarrow> y \\<le> x)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "note 3 = theI_unique[OF this,symmetric]"], ["proof (state)\nthis:\n  (?x =\n   (THE x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y. y \\<in> set xs \\<longrightarrow> y \\<le> x))) =\n  (?x \\<in> set xs \\<and>\n   (\\<forall>y. y \\<in> set xs \\<longrightarrow> y \\<le> ?x))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "from 1 2"], ["proof (chain)\npicking this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<le> Missing_Lemmas.max_list xs\n  Missing_Lemmas.max_list xs \\<in> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<le> Missing_Lemmas.max_list xs\n  Missing_Lemmas.max_list xs \\<in> set xs\n\ngoal (1 subgoal):\n 1. Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)", "by (unfold Greatest_def Cons 3, auto)"], ["proof (state)\nthis:\n  Missing_Lemmas.max_list xs = (GREATEST a. a \\<in> set xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_max_list_commute:\n  assumes \"xs \\<noteq> []\"\n      and \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set xs \\<Longrightarrow> h (max x y) = max (h x) (h y)\"\n  shows \"h (max_list xs) = max_list (map h xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (Missing_Lemmas.max_list xs) = Missing_Lemmas.max_list (map h xs)", "by (insert assms, induct xs, auto simp: max_list_Cons max_list_mem)"], ["", "(*Efficient rev [i..<j]*)"], ["", "primrec rev_upt :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat list\" (\"(1[_>.._])\") where\nrev_upt_0: \"[0>..j] = []\" |\nrev_upt_Suc: \"[(Suc i)>..j] = (if i \\<ge> j then i # [i>..j] else [])\""], ["", "lemma rev_upt_rec: \"[i>..j] = (if i>j then [i>..Suc j] @ [j] else [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i>..j] = (if j < i then [i>..Suc j] @ [j] else [])", "by (induct i, auto)"], ["", "definition rev_upt_aux :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat list \\<Rightarrow> nat list\" where\n  \"rev_upt_aux i j js = [i>..j] @ js\""], ["", "lemma upt_aux_rec [code]:\n  \"rev_upt_aux i j js = (if j\\<ge>i then js else rev_upt_aux i (Suc j) (j#js))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev_upt_aux i j js =\n    (if i \\<le> j then js else rev_upt_aux i (Suc j) (j # js))", "by (induct j, auto simp add: rev_upt_aux_def rev_upt_rec)"], ["", "lemma rev_upt_code[code]: \"[i>..j] = rev_upt_aux i j []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i>..j] = rev_upt_aux i j []", "by(simp add: rev_upt_aux_def)"], ["", "lemma upt_rev_upt:\n  \"rev [j>..i] = [i..<j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev [j>..i] = [i..<j]", "by (induct j, auto)"], ["", "lemma rev_upt_upt:\n  \"rev [i..<j] = [j>..i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev [i..<j] = [j>..i]", "by (induct j, auto)"], ["", "lemma length_rev_upt [simp]: \"length [i>..j] = i - j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [i>..j] = i - j", "by (induct i) (auto simp add: Suc_diff_le)"], ["", "lemma nth_rev_upt [simp]: \"j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k", "assume jk_i: \"j + k < i\""], ["proof (state)\nthis:\n  j + k < i\n\ngoal (1 subgoal):\n 1. j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k", "have \"[i>..j] = rev [j..<i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i>..j] = rev [j..<i]", "using rev_upt_upt"], ["proof (prove)\nusing this:\n  rev [?i..<?j] = [?j>..?i]\n\ngoal (1 subgoal):\n 1. [i>..j] = rev [j..<i]", "by simp"], ["proof (state)\nthis:\n  [i>..j] = rev [j..<i]\n\ngoal (1 subgoal):\n 1. j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k", "also"], ["proof (state)\nthis:\n  [i>..j] = rev [j..<i]\n\ngoal (1 subgoal):\n 1. j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k", "have \"... ! k = [j..<i] ! (length [j..<i] - 1 - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev [j..<i] ! k = [j..<i] ! (length [j..<i] - 1 - k)", "using jk_i"], ["proof (prove)\nusing this:\n  j + k < i\n\ngoal (1 subgoal):\n 1. rev [j..<i] ! k = [j..<i] ! (length [j..<i] - 1 - k)", "by (simp add: rev_nth)"], ["proof (state)\nthis:\n  rev [j..<i] ! k = [j..<i] ! (length [j..<i] - 1 - k)\n\ngoal (1 subgoal):\n 1. j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k", "also"], ["proof (state)\nthis:\n  rev [j..<i] ! k = [j..<i] ! (length [j..<i] - 1 - k)\n\ngoal (1 subgoal):\n 1. j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k", "have \"... = [j..<i] ! (i - j - 1 - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [j..<i] ! (length [j..<i] - 1 - k) = [j..<i] ! (i - j - 1 - k)", "by auto"], ["proof (state)\nthis:\n  [j..<i] ! (length [j..<i] - 1 - k) = [j..<i] ! (i - j - 1 - k)\n\ngoal (1 subgoal):\n 1. j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k", "also"], ["proof (state)\nthis:\n  [j..<i] ! (length [j..<i] - 1 - k) = [j..<i] ! (i - j - 1 - k)\n\ngoal (1 subgoal):\n 1. j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k", "have \"... = j + (i - j - 1 - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [j..<i] ! (i - j - 1 - k) = j + (i - j - 1 - k)", "by (rule nth_upt, insert jk_i, auto)"], ["proof (state)\nthis:\n  [j..<i] ! (i - j - 1 - k) = j + (i - j - 1 - k)\n\ngoal (1 subgoal):\n 1. j + k < i \\<Longrightarrow> [i>..j] ! k = i - 1 - k", "finally"], ["proof (chain)\npicking this:\n  [i>..j] ! k = j + (i - j - 1 - k)", "show ?thesis"], ["proof (prove)\nusing this:\n  [i>..j] ! k = j + (i - j - 1 - k)\n\ngoal (1 subgoal):\n 1. [i>..j] ! k = i - 1 - k", "using jk_i"], ["proof (prove)\nusing this:\n  [i>..j] ! k = j + (i - j - 1 - k)\n  j + k < i\n\ngoal (1 subgoal):\n 1. [i>..j] ! k = i - 1 - k", "by auto"], ["proof (state)\nthis:\n  [i>..j] ! k = i - 1 - k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_map_rev_upt: \n  assumes i: \"i < m-n\"\n  shows \"(map f [m>..n]) ! i = f (m - 1 - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [m>..n] ! i = f (m - 1 - i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map f [m>..n] ! i = f (m - 1 - i)", "have \"(map f [m>..n]) ! i = f ([m>..n] ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [m>..n] ! i = f ([m>..n] ! i)", "by (rule nth_map, auto simp add: i)"], ["proof (state)\nthis:\n  map f [m>..n] ! i = f ([m>..n] ! i)\n\ngoal (1 subgoal):\n 1. map f [m>..n] ! i = f (m - 1 - i)", "also"], ["proof (state)\nthis:\n  map f [m>..n] ! i = f ([m>..n] ! i)\n\ngoal (1 subgoal):\n 1. map f [m>..n] ! i = f (m - 1 - i)", "have \"... = f (m - 1 - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ([m>..n] ! i) = f (m - 1 - i)", "proof (rule arg_cong[of _ _ f], rule nth_rev_upt)"], ["proof (state)\ngoal (1 subgoal):\n 1. n + i < m", "show \"n + i < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + i < m", "using i"], ["proof (prove)\nusing this:\n  i < m - n\n\ngoal (1 subgoal):\n 1. n + i < m", "by linarith"], ["proof (state)\nthis:\n  n + i < m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ([m>..n] ! i) = f (m - 1 - i)\n\ngoal (1 subgoal):\n 1. map f [m>..n] ! i = f (m - 1 - i)", "finally"], ["proof (chain)\npicking this:\n  map f [m>..n] ! i = f (m - 1 - i)", "show ?thesis"], ["proof (prove)\nusing this:\n  map f [m>..n] ! i = f (m - 1 - i)\n\ngoal (1 subgoal):\n 1. map f [m>..n] ! i = f (m - 1 - i)", "."], ["proof (state)\nthis:\n  map f [m>..n] ! i = f (m - 1 - i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_mult_monom:\n \"coeff (p * monom a d) i = (if d \\<le> i then a * coeff p (i - d) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * monom a d) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "using coeff_monom_mult[of a d p]"], ["proof (prove)\nusing this:\n  coeff (monom a d * p) ?i =\n  (if d \\<le> ?i then a * coeff p (?i - d) else (0::'a))\n\ngoal (1 subgoal):\n 1. coeff (p * monom a d) i =\n    (if d \\<le> i then a * coeff p (i - d) else (0::'a))", "by (simp add: ac_simps)"], ["", "(**** End of the lemmas which may be part of the standard library ****)\n\n(**** The following lemmas could be moved to Algebraic_Numbers/Resultant.thy ****)"], ["", "lemma vec_of_poly_0 [simp]: \"vec_of_poly 0 = 0\\<^sub>v 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly 0 = 0\\<^sub>v 1", "by (auto simp: vec_of_poly_def)"], ["", "lemma vec_index_vec_of_poly [simp]: \"i \\<le> degree p \\<Longrightarrow> vec_of_poly p $ i = coeff p (degree p - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> degree p \\<Longrightarrow>\n    vec_of_poly p $ i = coeff p (degree p - i)", "by (simp add: vec_of_poly_def Let_def)"], ["", "lemma poly_of_vec_vec: \"poly_of_vec (vec n f) = Poly (rev (map f [0..<n]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (vec n f) = Poly (rev (map f [0..<n]))", "proof (induct n arbitrary:f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f. poly_of_vec (vec 0 f) = Poly (rev (map f [0..<0]))\n 2. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>f. poly_of_vec (vec 0 f) = Poly (rev (map f [0..<0]))\n 2. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (vec 0 f) = Poly (rev (map f [0..<0]))", "by auto"], ["proof (state)\nthis:\n  poly_of_vec (vec 0 f) = Poly (rev (map f [0..<0]))\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "case (Suc n)"], ["proof (state)\nthis:\n  poly_of_vec (vec n ?f) = Poly (rev (map ?f [0..<n]))\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "have \"map f [0..<Suc n] = f 0 # map (f \\<circ> Suc) [0..<n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [0..<Suc n] = f 0 # map (f \\<circ> Suc) [0..<n]", "by (simp add: map_upt_Suc del: upt_Suc)"], ["proof (state)\nthis:\n  map f [0..<Suc n] = f 0 # map (f \\<circ> Suc) [0..<n]\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "also"], ["proof (state)\nthis:\n  map f [0..<Suc n] = f 0 # map (f \\<circ> Suc) [0..<n]\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "have \"Poly (rev \\<dots>) = Poly (rev (map (f \\<circ> Suc) [0..<n])) + monom (f 0) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (rev (f 0 # map (f \\<circ> Suc) [0..<n])) =\n    Poly (rev (map (f \\<circ> Suc) [0..<n])) + monom (f 0) n", "by (simp add: Poly_snoc smult_monom)"], ["proof (state)\nthis:\n  Poly (rev (f 0 # map (f \\<circ> Suc) [0..<n])) =\n  Poly (rev (map (f \\<circ> Suc) [0..<n])) + monom (f 0) n\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "also"], ["proof (state)\nthis:\n  Poly (rev (f 0 # map (f \\<circ> Suc) [0..<n])) =\n  Poly (rev (map (f \\<circ> Suc) [0..<n])) + monom (f 0) n\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "have \"\\<dots> = poly_of_vec (vec n (f \\<circ> Suc)) + monom (f 0) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (rev (map (f \\<circ> Suc) [0..<n])) + monom (f 0) n =\n    poly_of_vec (vec n (f \\<circ> Suc)) + monom (f 0) n", "by (fold Suc, simp)"], ["proof (state)\nthis:\n  Poly (rev (map (f \\<circ> Suc) [0..<n])) + monom (f 0) n =\n  poly_of_vec (vec n (f \\<circ> Suc)) + monom (f 0) n\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "also"], ["proof (state)\nthis:\n  Poly (rev (map (f \\<circ> Suc) [0..<n])) + monom (f 0) n =\n  poly_of_vec (vec n (f \\<circ> Suc)) + monom (f 0) n\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "have \"\\<dots> = poly_of_vec (vec (Suc n) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (vec n (f \\<circ> Suc)) + monom (f 0) n =\n    poly_of_vec (vec (Suc n) f)", "apply (unfold poly_of_vec_def Let_def dim_vec sum.lessThan_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. monom (vec n (f \\<circ> Suc) $ (n - Suc i)) i) +\n    monom (f 0) n =\n    (\\<Sum>i<n. monom (vec (Suc n) f $ (Suc n - Suc i)) i) +\n    monom (vec (Suc n) f $ (Suc n - Suc n)) n", "by (auto simp add: Suc_diff_Suc)"], ["proof (state)\nthis:\n  poly_of_vec (vec n (f \\<circ> Suc)) + monom (f 0) n =\n  poly_of_vec (vec (Suc n) f)\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f.\n           poly_of_vec (vec n f) =\n           Poly (rev (map f [0..<n]))) \\<Longrightarrow>\n       poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", "finally"], ["proof (chain)\npicking this:\n  Poly (rev (map f [0..<Suc n])) = poly_of_vec (vec (Suc n) f)", "show ?case"], ["proof (prove)\nusing this:\n  Poly (rev (map f [0..<Suc n])) = poly_of_vec (vec (Suc n) f)\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))", ".."], ["proof (state)\nthis:\n  poly_of_vec (vec (Suc n) f) = Poly (rev (map f [0..<Suc n]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_map_dropWhile0:\n  assumes f0: \"f 0 = 0\"\n  shows \"sum_list (map f (dropWhile ((=) 0) xs)) = sum_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (dropWhile ((=) (0::'b)) xs)) = sum_list (map f xs)", "by (induct xs, auto simp add: f0)"], ["", "lemma coeffs_poly_of_vec:\n  \"coeffs (poly_of_vec v) = rev (dropWhile ((=) 0) (list_of_vec v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (poly_of_vec v) = rev (dropWhile ((=) (0::'a)) (list_of_vec v))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. coeffs (poly_of_vec v) = rev (dropWhile ((=) (0::'a)) (list_of_vec v))", "obtain n f where v: \"v = vec n f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n f. v = vec n f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer auto"], ["proof (state)\nthis:\n  v = vec n f\n\ngoal (1 subgoal):\n 1. coeffs (poly_of_vec v) = rev (dropWhile ((=) (0::'a)) (list_of_vec v))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (poly_of_vec v) = rev (dropWhile ((=) (0::'a)) (list_of_vec v))", "by (simp add: v poly_of_vec_vec)"], ["proof (state)\nthis:\n  coeffs (poly_of_vec v) = rev (dropWhile ((=) (0::'a)) (list_of_vec v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_of_vec_vCons:\n \"poly_of_vec (vCons a v) = monom a (dim_vec v) + poly_of_vec v\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (vCons a v) = monom a (dim_vec v) + poly_of_vec v", "by (auto intro: poly_eqI simp: coeff_poly_of_vec vec_index_vCons)"], ["", "lemma poly_of_vec_as_Poly: \"poly_of_vec v = Poly (rev (list_of_vec v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec v = Poly (rev (list_of_vec v))", "by (induct v, auto simp:poly_of_vec_vCons Poly_snoc ac_simps)"], ["", "lemma poly_of_vec_add:\n  assumes \"dim_vec a = dim_vec b\"\n  shows \"poly_of_vec (a + b) = poly_of_vec a + poly_of_vec b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (a + b) = poly_of_vec a + poly_of_vec b", "using assms"], ["proof (prove)\nusing this:\n  dim_vec a = dim_vec b\n\ngoal (1 subgoal):\n 1. poly_of_vec (a + b) = poly_of_vec a + poly_of_vec b", "by (auto simp add: poly_eq_iff coeff_poly_of_vec)"], ["", "(*TODO: replace the one in Resultant.thy*)"], ["", "lemma degree_poly_of_vec_less:\n  assumes \"0 < dim_vec v\" and \"dim_vec v \\<le> n\" shows \"degree (poly_of_vec v) < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_of_vec v) < n", "using degree_poly_of_vec_less assms"], ["proof (prove)\nusing this:\n  0 < dim_vec ?v \\<Longrightarrow> degree (poly_of_vec ?v) < dim_vec ?v\n  0 < dim_vec v\n  dim_vec v \\<le> n\n\ngoal (1 subgoal):\n 1. degree (poly_of_vec v) < n", "by (auto dest: less_le_trans)"], ["", "lemma (in vec_module) poly_of_vec_finsum:\n  assumes \"f \\<in> X \\<rightarrow> carrier_vec n\"\n  shows \"poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))", "proof (cases \"finite X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))\n 2. infinite X \\<Longrightarrow>\n    poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))", "case False"], ["proof (state)\nthis:\n  infinite X\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))\n 2. infinite X \\<Longrightarrow>\n    poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))", "then"], ["proof (chain)\npicking this:\n  infinite X", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite X\n\ngoal (1 subgoal):\n 1. poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))", "by auto"], ["proof (state)\nthis:\n  poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow>\n    poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow>\n    poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))", "case True"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow>\n    poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))", "proof (insert True assms, induct X rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    poly_of_vec (finsum V f {}) = (\\<Sum>i\\<in>{}. poly_of_vec (f i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        poly_of_vec (finsum V f F) = (\\<Sum>i\\<in>F. poly_of_vec (f i));\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> poly_of_vec (finsum V f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. poly_of_vec (f i))", "case IH: (insert a X)"], ["proof (state)\nthis:\n  finite X\n  a \\<notin> X\n  f \\<in> X \\<rightarrow> carrier_vec n \\<Longrightarrow>\n  poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))\n  f \\<in> insert a X \\<rightarrow> carrier_vec n\n\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    poly_of_vec (finsum V f {}) = (\\<Sum>i\\<in>{}. poly_of_vec (f i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        poly_of_vec (finsum V f F) = (\\<Sum>i\\<in>F. poly_of_vec (f i));\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> poly_of_vec (finsum V f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. poly_of_vec (f i))", "have [simp]: \"f x \\<in> carrier_vec n\" if x: \"x \\<in> X\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<in> carrier_vec n", "using x IH.prems"], ["proof (prove)\nusing this:\n  x \\<in> X\n  f \\<in> insert a X \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. f x \\<in> carrier_vec n", "unfolding Pi_def"], ["proof (prove)\nusing this:\n  x \\<in> X\n  f \\<in> {f. \\<forall>x.\n                 x \\<in> insert a X \\<longrightarrow>\n                 f x \\<in> carrier_vec n}\n\ngoal (1 subgoal):\n 1. f x \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> X \\<Longrightarrow> f ?x1 \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    poly_of_vec (finsum V f {}) = (\\<Sum>i\\<in>{}. poly_of_vec (f i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        poly_of_vec (finsum V f F) = (\\<Sum>i\\<in>F. poly_of_vec (f i));\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> poly_of_vec (finsum V f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. poly_of_vec (f i))", "have [simp]: \"f a \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<in> carrier_vec n", "using IH.prems"], ["proof (prove)\nusing this:\n  f \\<in> insert a X \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. f a \\<in> carrier_vec n", "unfolding Pi_def"], ["proof (prove)\nusing this:\n  f \\<in> {f. \\<forall>x.\n                 x \\<in> insert a X \\<longrightarrow>\n                 f x \\<in> carrier_vec n}\n\ngoal (1 subgoal):\n 1. f a \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  f a \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    poly_of_vec (finsum V f {}) = (\\<Sum>i\\<in>{}. poly_of_vec (f i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        poly_of_vec (finsum V f F) = (\\<Sum>i\\<in>F. poly_of_vec (f i));\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> poly_of_vec (finsum V f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. poly_of_vec (f i))", "have [simp]: \"dim_vec (finsum V f X) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (finsum V f X) = n", "by simp"], ["proof (state)\nthis:\n  dim_vec (finsum V f X) = n\n\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    poly_of_vec (finsum V f {}) = (\\<Sum>i\\<in>{}. poly_of_vec (f i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        poly_of_vec (finsum V f F) = (\\<Sum>i\\<in>F. poly_of_vec (f i));\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> poly_of_vec (finsum V f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. poly_of_vec (f i))", "have [simp]: \"dim_vec (f a) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (f a) = n", "by simp"], ["proof (state)\nthis:\n  dim_vec (f a) = n\n\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    poly_of_vec (finsum V f {}) = (\\<Sum>i\\<in>{}. poly_of_vec (f i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        poly_of_vec (finsum V f F) = (\\<Sum>i\\<in>F. poly_of_vec (f i));\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> poly_of_vec (finsum V f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. poly_of_vec (f i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "proof (cases \"a \\<in> X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))\n 2. a \\<notin> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "case True"], ["proof (state)\nthis:\n  a \\<in> X\n\ngoal (2 subgoals):\n 1. a \\<in> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))\n 2. a \\<notin> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "then"], ["proof (chain)\npicking this:\n  a \\<in> X", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> X\n\ngoal (1 subgoal):\n 1. poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "by (auto simp: insert_absorb IH)"], ["proof (state)\nthis:\n  poly_of_vec (finsum V f (insert a X)) =\n  (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))\n\ngoal (1 subgoal):\n 1. a \\<notin> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "case False"], ["proof (state)\nthis:\n  a \\<notin> X\n\ngoal (1 subgoal):\n 1. a \\<notin> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "then"], ["proof (chain)\npicking this:\n  a \\<notin> X", "have \"(finsum V f (insert a X)) = f a + (finsum V f X)\""], ["proof (prove)\nusing this:\n  a \\<notin> X\n\ngoal (1 subgoal):\n 1. finsum V f (insert a X) = f a + finsum V f X", "by (auto intro: finsum_insert IH)"], ["proof (state)\nthis:\n  finsum V f (insert a X) = f a + finsum V f X\n\ngoal (1 subgoal):\n 1. a \\<notin> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "also"], ["proof (state)\nthis:\n  finsum V f (insert a X) = f a + finsum V f X\n\ngoal (1 subgoal):\n 1. a \\<notin> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "have \"poly_of_vec ... = poly_of_vec (f a) + poly_of_vec (finsum V f X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (f a + finsum V f X) =\n    poly_of_vec (f a) + poly_of_vec (finsum V f X)", "by (rule poly_of_vec_add, simp)"], ["proof (state)\nthis:\n  poly_of_vec (f a + finsum V f X) =\n  poly_of_vec (f a) + poly_of_vec (finsum V f X)\n\ngoal (1 subgoal):\n 1. a \\<notin> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "also"], ["proof (state)\nthis:\n  poly_of_vec (f a + finsum V f X) =\n  poly_of_vec (f a) + poly_of_vec (finsum V f X)\n\ngoal (1 subgoal):\n 1. a \\<notin> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "have \"... = (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (f a) + poly_of_vec (finsum V f X) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "using IH False"], ["proof (prove)\nusing this:\n  finite X\n  a \\<notin> X\n  f \\<in> X \\<rightarrow> carrier_vec n \\<Longrightarrow>\n  poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))\n  f \\<in> insert a X \\<rightarrow> carrier_vec n\n  a \\<notin> X\n\ngoal (1 subgoal):\n 1. poly_of_vec (f a) + poly_of_vec (finsum V f X) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "by (subst sum.insert, auto)"], ["proof (state)\nthis:\n  poly_of_vec (f a) + poly_of_vec (finsum V f X) =\n  (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))\n\ngoal (1 subgoal):\n 1. a \\<notin> X \\<Longrightarrow>\n    poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "finally"], ["proof (chain)\npicking this:\n  poly_of_vec (finsum V f (insert a X)) =\n  (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_of_vec (finsum V f (insert a X)) =\n  (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))\n\ngoal (1 subgoal):\n 1. poly_of_vec (finsum V f (insert a X)) =\n    (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))", "."], ["proof (state)\nthis:\n  poly_of_vec (finsum V f (insert a X)) =\n  (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_of_vec (finsum V f (insert a X)) =\n  (\\<Sum>i\\<in>insert a X. poly_of_vec (f i))\n\ngoal (1 subgoal):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    poly_of_vec (finsum V f {}) = (\\<Sum>i\\<in>{}. poly_of_vec (f i))", "qed auto"], ["proof (state)\nthis:\n  poly_of_vec (finsum V f X) = (\\<Sum>i\\<in>X. poly_of_vec (f i))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*This function transforms a polynomial to a vector of dimension n*)"], ["", "definition \"vec_of_poly_n p n =\n  vec n (\\<lambda>i. if i < n - degree p - 1 then 0 else coeff p (n - i - 1))\""], ["", "(* TODO: make it abbreviation? *)"], ["", "lemma vec_of_poly_as: \"vec_of_poly_n p (Suc (degree p)) = vec_of_poly p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n p (Suc (degree p)) = vec_of_poly p", "by (induct p, auto simp: vec_of_poly_def vec_of_poly_n_def)"], ["", "lemma vec_of_poly_n_0 [simp]: \"vec_of_poly_n p 0 = vNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n p 0 = vNil", "by (auto simp: vec_of_poly_n_def)"], ["", "lemma vec_dim_vec_of_poly_n [simp]:\n  \"dim_vec (vec_of_poly_n p n) = n\"\n  \"vec_of_poly_n p n \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_of_poly_n p n) = n &&&\n    vec_of_poly_n p n \\<in> carrier_vec n", "unfolding vec_of_poly_n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec n\n       (\\<lambda>i.\n           if i < n - degree p - 1 then 0::'a else coeff p (n - i - 1))) =\n    n &&&\n    vec n\n     (\\<lambda>i.\n         if i < n - degree p - 1 then 0::'a else coeff p (n - i - 1))\n    \\<in> carrier_vec n", "by auto"], ["", "lemma dim_vec_of_poly [simp]: \"dim_vec (vec_of_poly f) = degree f + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_of_poly f) = degree f + 1", "by (simp add: vec_of_poly_as[symmetric])"], ["", "lemma vec_index_of_poly_n:\n  assumes \"i < n\"\n  shows \"vec_of_poly_n p n $ i =\n    (if i < n - Suc (degree p) then 0 else coeff p (n - i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n p n $ i =\n    (if i < n - Suc (degree p) then 0::'a else coeff p (n - i - 1))", "using assms"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n p n $ i =\n    (if i < n - Suc (degree p) then 0::'a else coeff p (n - i - 1))", "by (auto simp: vec_of_poly_n_def Let_def)"], ["", "lemma vec_of_poly_n_pCons[simp]:\n  shows \"vec_of_poly_n (pCons a p) (Suc n) = vec_of_poly_n p n @\\<^sub>v vec_of_list [a]\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n (pCons a p) (Suc n) =\n    vec_of_poly_n p n @\\<^sub>v vec_of_list [a]", "proof (unfold vec_eq_iff, intro conjI allI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_vec (vec_of_poly_n (pCons a p) (Suc n)) =\n    dim_vec (vec_of_poly_n p n @\\<^sub>v vec_of_list [a])\n 2. \\<And>i.\n       i < dim_vec\n            (vec_of_poly_n p n @\\<^sub>v vec_of_list [a]) \\<Longrightarrow>\n       vec_of_poly_n (pCons a p) (Suc n) $ i =\n       (vec_of_poly_n p n @\\<^sub>v vec_of_list [a]) $ i", "show \"dim_vec ?l = dim_vec ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_of_poly_n (pCons a p) (Suc n)) =\n    dim_vec (vec_of_poly_n p n @\\<^sub>v vec_of_list [a])", "by auto"], ["proof (state)\nthis:\n  dim_vec (vec_of_poly_n (pCons a p) (Suc n)) =\n  dim_vec (vec_of_poly_n p n @\\<^sub>v vec_of_list [a])\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (vec_of_poly_n p n @\\<^sub>v vec_of_list [a]) \\<Longrightarrow>\n       vec_of_poly_n (pCons a p) (Suc n) $ i =\n       (vec_of_poly_n p n @\\<^sub>v vec_of_list [a]) $ i", "show \"i < dim_vec ?r \\<Longrightarrow> ?l $ i = ?r $ i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_vec\n         (vec_of_poly_n p n @\\<^sub>v vec_of_list [a]) \\<Longrightarrow>\n    vec_of_poly_n (pCons a p) (Suc n) $ i =\n    (vec_of_poly_n p n @\\<^sub>v vec_of_list [a]) $ i", "by (cases \"n - i\", auto simp: coeff_pCons less_Suc_eq_le vec_index_of_poly_n)"], ["proof (state)\nthis:\n  ?i < dim_vec\n        (vec_of_poly_n p n @\\<^sub>v vec_of_list [a]) \\<Longrightarrow>\n  vec_of_poly_n (pCons a p) (Suc n) $ ?i =\n  (vec_of_poly_n p n @\\<^sub>v vec_of_list [a]) $ ?i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_poly_pCons:\n  shows \"vec_of_poly (pCons a p) =\n   (if p = 0 then vec_of_list [a] else vec_of_poly p @\\<^sub>v vec_of_list [a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly (pCons a p) =\n    (if p = 0 then vec_of_list [a]\n     else vec_of_poly p @\\<^sub>v vec_of_list [a])", "by (cases \"degree p\", auto simp: vec_of_poly_as[symmetric])"], ["", "lemma list_of_vec_of_poly [simp]:\n  \"list_of_vec (vec_of_poly p) = (if p = 0 then [0] else rev (coeffs p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec (vec_of_poly p) =\n    (if p = 0 then [0::'a] else rev (coeffs p))", "by (induct p, auto simp: vec_of_poly_pCons)"], ["", "lemma poly_of_vec_of_poly_n:\n  assumes p: \"degree p<n\"\n  shows \"poly_of_vec (vec_of_poly_n p n) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (vec_of_poly_n p n) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_of_vec (vec_of_poly_n p n) = p", "have \"vec_of_poly_n p n $ (n - Suc i) = coeff p i\" if i: \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n p n $ (n - Suc i) = coeff p i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_poly_n p n $ (n - Suc i) = coeff p i", "have n: \"n - Suc i < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - Suc i < n", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. n - Suc i < n", "by auto"], ["proof (state)\nthis:\n  n - Suc i < n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n p n $ (n - Suc i) = coeff p i", "have \"vec_of_poly_n p n $ (n - Suc i) = \n      (if n - Suc i < n - Suc (degree p) then 0 else coeff p (n - (n - Suc i) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n p n $ (n - Suc i) =\n    (if n - Suc i < n - Suc (degree p) then 0::'a\n     else coeff p (n - (n - Suc i) - 1))", "using vec_index_of_poly_n[OF n, of p]"], ["proof (prove)\nusing this:\n  vec_of_poly_n p n $ (n - Suc i) =\n  (if n - Suc i < n - Suc (degree p) then 0::'a\n   else coeff p (n - (n - Suc i) - 1))\n\ngoal (1 subgoal):\n 1. vec_of_poly_n p n $ (n - Suc i) =\n    (if n - Suc i < n - Suc (degree p) then 0::'a\n     else coeff p (n - (n - Suc i) - 1))", "."], ["proof (state)\nthis:\n  vec_of_poly_n p n $ (n - Suc i) =\n  (if n - Suc i < n - Suc (degree p) then 0::'a\n   else coeff p (n - (n - Suc i) - 1))\n\ngoal (1 subgoal):\n 1. vec_of_poly_n p n $ (n - Suc i) = coeff p i", "also"], ["proof (state)\nthis:\n  vec_of_poly_n p n $ (n - Suc i) =\n  (if n - Suc i < n - Suc (degree p) then 0::'a\n   else coeff p (n - (n - Suc i) - 1))\n\ngoal (1 subgoal):\n 1. vec_of_poly_n p n $ (n - Suc i) = coeff p i", "have \"... = coeff p i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n - Suc i < n - Suc (degree p) then 0::'a\n     else coeff p (n - (n - Suc i) - 1)) =\n    coeff p i", "using i n le_degree"], ["proof (prove)\nusing this:\n  i < n\n  n - Suc i < n\n  coeff ?p ?n \\<noteq> (0::?'a) \\<Longrightarrow> ?n \\<le> degree ?p\n\ngoal (1 subgoal):\n 1. (if n - Suc i < n - Suc (degree p) then 0::'a\n     else coeff p (n - (n - Suc i) - 1)) =\n    coeff p i", "by fastforce"], ["proof (state)\nthis:\n  (if n - Suc i < n - Suc (degree p) then 0::'a\n   else coeff p (n - (n - Suc i) - 1)) =\n  coeff p i\n\ngoal (1 subgoal):\n 1. vec_of_poly_n p n $ (n - Suc i) = coeff p i", "finally"], ["proof (chain)\npicking this:\n  vec_of_poly_n p n $ (n - Suc i) = coeff p i", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_of_poly_n p n $ (n - Suc i) = coeff p i\n\ngoal (1 subgoal):\n 1. vec_of_poly_n p n $ (n - Suc i) = coeff p i", "."], ["proof (state)\nthis:\n  vec_of_poly_n p n $ (n - Suc i) = coeff p i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> vec_of_poly_n p n $ (n - Suc ?i) = coeff p ?i\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_of_poly_n p n) = p", "moreover"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> vec_of_poly_n p n $ (n - Suc ?i) = coeff p ?i\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_of_poly_n p n) = p", "have \"coeff p i = 0\" if i2: \"i \\<ge> n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p i = (0::'a)", "by (rule coeff_eq_0, insert i2 p, simp)"], ["proof (state)\nthis:\n  n \\<le> ?i \\<Longrightarrow> coeff p ?i = (0::'a)\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_of_poly_n p n) = p", "ultimately"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow> vec_of_poly_n p n $ (n - Suc ?i) = coeff p ?i\n  n \\<le> ?i \\<Longrightarrow> coeff p ?i = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> vec_of_poly_n p n $ (n - Suc ?i) = coeff p ?i\n  n \\<le> ?i \\<Longrightarrow> coeff p ?i = (0::'a)\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_of_poly_n p n) = p", "using assms"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> vec_of_poly_n p n $ (n - Suc ?i) = coeff p ?i\n  n \\<le> ?i \\<Longrightarrow> coeff p ?i = (0::'a)\n  degree p < n\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_of_poly_n p n) = p", "unfolding poly_eq_iff"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> vec_of_poly_n p n $ (n - Suc ?i) = coeff p ?i\n  n \\<le> ?i \\<Longrightarrow> coeff p ?i = (0::'a)\n  degree p < n\n\ngoal (1 subgoal):\n 1. \\<forall>na. coeff (poly_of_vec (vec_of_poly_n p n)) na = coeff p na", "unfolding coeff_poly_of_vec"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> vec_of_poly_n p n $ (n - Suc ?i) = coeff p ?i\n  n \\<le> ?i \\<Longrightarrow> coeff p ?i = (0::'a)\n  degree p < n\n\ngoal (1 subgoal):\n 1. \\<forall>na.\n       (if na < dim_vec (vec_of_poly_n p n)\n        then vec_of_poly_n p n $ (dim_vec (vec_of_poly_n p n) - Suc na)\n        else (0::'a)) =\n       coeff p na", "by auto"], ["proof (state)\nthis:\n  poly_of_vec (vec_of_poly_n p n) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_poly_n0[simp]: \"vec_of_poly_n 0 n = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n 0 n = 0\\<^sub>v n", "unfolding vec_of_poly_n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>i.\n         if i < n - degree 0 - 1 then 0::'a else coeff 0 (n - i - 1)) =\n    0\\<^sub>v n", "by auto"], ["", "lemma vec_of_poly_n_add: \"vec_of_poly_n (a + b) n = vec_of_poly_n a n + vec_of_poly_n b n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n (a + b) n = vec_of_poly_n a n + vec_of_poly_n b n", "proof (induct n arbitrary: a b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       vec_of_poly_n (a + b) 0 = vec_of_poly_n a 0 + vec_of_poly_n b 0\n 2. \\<And>n a b.\n       (\\<And>a b.\n           vec_of_poly_n (a + b) n =\n           vec_of_poly_n a n + vec_of_poly_n b n) \\<Longrightarrow>\n       vec_of_poly_n (a + b) (Suc n) =\n       vec_of_poly_n a (Suc n) + vec_of_poly_n b (Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       vec_of_poly_n (a + b) 0 = vec_of_poly_n a 0 + vec_of_poly_n b 0\n 2. \\<And>n a b.\n       (\\<And>a b.\n           vec_of_poly_n (a + b) n =\n           vec_of_poly_n a n + vec_of_poly_n b n) \\<Longrightarrow>\n       vec_of_poly_n (a + b) (Suc n) =\n       vec_of_poly_n a (Suc n) + vec_of_poly_n b (Suc n)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n (a + b) 0 = vec_of_poly_n a 0 + vec_of_poly_n b 0", "by auto"], ["proof (state)\nthis:\n  vec_of_poly_n (a + b) 0 = vec_of_poly_n a 0 + vec_of_poly_n b 0\n\ngoal (1 subgoal):\n 1. \\<And>n a b.\n       (\\<And>a b.\n           vec_of_poly_n (a + b) n =\n           vec_of_poly_n a n + vec_of_poly_n b n) \\<Longrightarrow>\n       vec_of_poly_n (a + b) (Suc n) =\n       vec_of_poly_n a (Suc n) + vec_of_poly_n b (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n a b.\n       (\\<And>a b.\n           vec_of_poly_n (a + b) n =\n           vec_of_poly_n a n + vec_of_poly_n b n) \\<Longrightarrow>\n       vec_of_poly_n (a + b) (Suc n) =\n       vec_of_poly_n a (Suc n) + vec_of_poly_n b (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  vec_of_poly_n (?a + ?b) n = vec_of_poly_n ?a n + vec_of_poly_n ?b n\n\ngoal (1 subgoal):\n 1. \\<And>n a b.\n       (\\<And>a b.\n           vec_of_poly_n (a + b) n =\n           vec_of_poly_n a n + vec_of_poly_n b n) \\<Longrightarrow>\n       vec_of_poly_n (a + b) (Suc n) =\n       vec_of_poly_n a (Suc n) + vec_of_poly_n b (Suc n)", "then"], ["proof (chain)\npicking this:\n  vec_of_poly_n (?a + ?b) n = vec_of_poly_n ?a n + vec_of_poly_n ?b n", "show ?case"], ["proof (prove)\nusing this:\n  vec_of_poly_n (?a + ?b) n = vec_of_poly_n ?a n + vec_of_poly_n ?b n\n\ngoal (1 subgoal):\n 1. vec_of_poly_n (a + b) (Suc n) =\n    vec_of_poly_n a (Suc n) + vec_of_poly_n b (Suc n)", "by (cases a, cases b, auto)"], ["proof (state)\nthis:\n  vec_of_poly_n (a + b) (Suc n) =\n  vec_of_poly_n a (Suc n) + vec_of_poly_n b (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_poly_n_poly_of_vec:\n  assumes n: \"dim_vec g = n\"\n  shows \"vec_of_poly_n (poly_of_vec g) n = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_n (poly_of_vec g) n = g", "proof (auto simp add: poly_of_vec_def vec_of_poly_n_def assms vec_eq_iff Let_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < n - Suc (degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> g $ i = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>\\<not> i < n -\n                           Suc (degree\n                                 (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i)\n                          (n - Suc i) =\n                         g $ i", "have d: \"degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i) = degree (poly_of_vec g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i) = degree (poly_of_vec g)", "unfolding poly_of_vec_def Let_def n"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i) =\n    degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i)", "by auto"], ["proof (state)\nthis:\n  degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i) = degree (poly_of_vec g)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < n - Suc (degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> g $ i = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>\\<not> i < n -\n                           Suc (degree\n                                 (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i)\n                          (n - Suc i) =\n                         g $ i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < n - Suc (degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> g $ i = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>\\<not> i < n -\n                           Suc (degree\n                                 (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i)\n                          (n - Suc i) =\n                         g $ i", "assume i1: \"i < n - Suc (degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i))\" \n    and i2: \"i < n\""], ["proof (state)\nthis:\n  i < n - Suc (degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i))\n  i < n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < n - Suc (degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> g $ i = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>\\<not> i < n -\n                           Suc (degree\n                                 (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i)\n                          (n - Suc i) =\n                         g $ i", "have i3: \"i < n - Suc (degree (poly_of_vec g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n - Suc (degree (poly_of_vec g))", "using i1"], ["proof (prove)\nusing this:\n  i < n - Suc (degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i))\n\ngoal (1 subgoal):\n 1. i < n - Suc (degree (poly_of_vec g))", "unfolding d"], ["proof (prove)\nusing this:\n  i < n - Suc (degree (poly_of_vec g))\n\ngoal (1 subgoal):\n 1. i < n - Suc (degree (poly_of_vec g))", "by auto"], ["proof (state)\nthis:\n  i < n - Suc (degree (poly_of_vec g))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < n - Suc (degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> g $ i = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>\\<not> i < n -\n                           Suc (degree\n                                 (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i)\n                          (n - Suc i) =\n                         g $ i", "hence \"dim_vec g - Suc i > degree (poly_of_vec g)\""], ["proof (prove)\nusing this:\n  i < n - Suc (degree (poly_of_vec g))\n\ngoal (1 subgoal):\n 1. degree (poly_of_vec g) < dim_vec g - Suc i", "using n"], ["proof (prove)\nusing this:\n  i < n - Suc (degree (poly_of_vec g))\n  dim_vec g = n\n\ngoal (1 subgoal):\n 1. degree (poly_of_vec g) < dim_vec g - Suc i", "by linarith"], ["proof (state)\nthis:\n  degree (poly_of_vec g) < dim_vec g - Suc i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < n - Suc (degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> g $ i = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>\\<not> i < n -\n                           Suc (degree\n                                 (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i)\n                          (n - Suc i) =\n                         g $ i", "then"], ["proof (chain)\npicking this:\n  degree (poly_of_vec g) < dim_vec g - Suc i", "show \"g $ i = 0\""], ["proof (prove)\nusing this:\n  degree (poly_of_vec g) < dim_vec g - Suc i\n\ngoal (1 subgoal):\n 1. g $ i = (0::'a)", "using i1 i2 i3"], ["proof (prove)\nusing this:\n  degree (poly_of_vec g) < dim_vec g - Suc i\n  i < n - Suc (degree (\\<Sum>i<n. monom (g $ (n - Suc i)) i))\n  i < n\n  i < n - Suc (degree (poly_of_vec g))\n\ngoal (1 subgoal):\n 1. g $ i = (0::'a)", "by (metis (no_types, lifting) Suc_diff_Suc coeff_poly_of_vec diff_Suc_less \n        diff_diff_cancel leD le_degree less_imp_le_nat n neq0_conv)"], ["proof (state)\nthis:\n  g $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> i < n -\n                           Suc (degree\n                                 (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i)\n                          (n - Suc i) =\n                         g $ i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> i < n -\n                           Suc (degree\n                                 (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i)\n                          (n - Suc i) =\n                         g $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> i < n -\n                           Suc (degree\n                                 (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i)\n                          (n - Suc i) =\n                         g $ i", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> i < n -\n                           Suc (degree\n                                 (\\<Sum>i<n. monom (g $ (n - Suc i)) i));\n        i < n\\<rbrakk>\n       \\<Longrightarrow> coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i)\n                          (n - Suc i) =\n                         g $ i", "thus \"coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i) (n - Suc i) = g $ i\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i) (n - Suc i) = g $ i", "by (metis (no_types) Suc_diff_Suc coeff_poly_of_vec diff_diff_cancel \n        diff_less_Suc less_imp_le_nat n not_less_eq poly_of_vec_def)"], ["proof (state)\nthis:\n  coeff (\\<Sum>i<n. monom (g $ (n - Suc i)) i) (n - Suc i) = g $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_of_vec_scalar_mult:\n  assumes \"degree b<n\"\n  shows \"poly_of_vec (a \\<cdot>\\<^sub>v (vec_of_poly_n b n)) = smult a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (a \\<cdot>\\<^sub>v vec_of_poly_n b n) = smult a b", "using assms"], ["proof (prove)\nusing this:\n  degree b < n\n\ngoal (1 subgoal):\n 1. poly_of_vec (a \\<cdot>\\<^sub>v vec_of_poly_n b n) = smult a b", "by (auto simp add: poly_eq_iff coeff_poly_of_vec vec_of_poly_n_def coeff_eq_0)"], ["", "(*TODO: replace the one in Resultant.thy*)"], ["", "definition vec_of_poly_rev_shifted where\n  \"vec_of_poly_rev_shifted p n s j \\<equiv>\n   vec n (\\<lambda>i. if i \\<le> j \\<and> j \\<le> s + i then coeff p (s + i - j) else 0)\""], ["", "lemma vec_of_poly_rev_shifted_dim[simp]: \"dim_vec (vec_of_poly_rev_shifted p n s j) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (Missing_Lemmas.vec_of_poly_rev_shifted p n s j) = n", "unfolding vec_of_poly_rev_shifted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec n\n       (\\<lambda>i.\n           if i \\<le> j \\<and> j \\<le> s + i then coeff p (s + i - j)\n           else (0::'a))) =\n    n", "by auto"], ["", "lemma col_sylvester_sub: (* TODO: from this directly derive col_sylvester *)\n  assumes j: \"j < m + n\"\n  shows \"col (sylvester_mat_sub m n p q) j =\n    vec_of_poly_rev_shifted p n m j @\\<^sub>v vec_of_poly_rev_shifted q m n j\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (sylvester_mat_sub m n p q) j =\n    Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n    Missing_Lemmas.vec_of_poly_rev_shifted q m n j", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n             Missing_Lemmas.vec_of_poly_rev_shifted q m n\n              j) \\<Longrightarrow>\n       col (sylvester_mat_sub m n p q) j $ i =\n       (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n        Missing_Lemmas.vec_of_poly_rev_shifted q m n j) $\n       i\n 2. dim_vec (col (sylvester_mat_sub m n p q) j) =\n    dim_vec\n     (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n      Missing_Lemmas.vec_of_poly_rev_shifted q m n j)", "show \"dim_vec ?l = dim_vec ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (col (sylvester_mat_sub m n p q) j) =\n    dim_vec\n     (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n      Missing_Lemmas.vec_of_poly_rev_shifted q m n j)", "by simp"], ["proof (state)\nthis:\n  dim_vec (col (sylvester_mat_sub m n p q) j) =\n  dim_vec\n   (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n    Missing_Lemmas.vec_of_poly_rev_shifted q m n j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n             Missing_Lemmas.vec_of_poly_rev_shifted q m n\n              j) \\<Longrightarrow>\n       col (sylvester_mat_sub m n p q) j $ i =\n       (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n        Missing_Lemmas.vec_of_poly_rev_shifted q m n j) $\n       i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n             Missing_Lemmas.vec_of_poly_rev_shifted q m n\n              j) \\<Longrightarrow>\n       col (sylvester_mat_sub m n p q) j $ i =\n       (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n        Missing_Lemmas.vec_of_poly_rev_shifted q m n j) $\n       i", "assume \"i < dim_vec ?r\""], ["proof (state)\nthis:\n  i < dim_vec\n       (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n        Missing_Lemmas.vec_of_poly_rev_shifted q m n j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n             Missing_Lemmas.vec_of_poly_rev_shifted q m n\n              j) \\<Longrightarrow>\n       col (sylvester_mat_sub m n p q) j $ i =\n       (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n        Missing_Lemmas.vec_of_poly_rev_shifted q m n j) $\n       i", "then"], ["proof (chain)\npicking this:\n  i < dim_vec\n       (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n        Missing_Lemmas.vec_of_poly_rev_shifted q m n j)", "have i: \"i < m+n\""], ["proof (prove)\nusing this:\n  i < dim_vec\n       (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n        Missing_Lemmas.vec_of_poly_rev_shifted q m n j)\n\ngoal (1 subgoal):\n 1. i < m + n", "by auto"], ["proof (state)\nthis:\n  i < m + n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n             Missing_Lemmas.vec_of_poly_rev_shifted q m n\n              j) \\<Longrightarrow>\n       col (sylvester_mat_sub m n p q) j $ i =\n       (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n        Missing_Lemmas.vec_of_poly_rev_shifted q m n j) $\n       i", "show \"?l $ i = ?r $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (sylvester_mat_sub m n p q) j $ i =\n    (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n     Missing_Lemmas.vec_of_poly_rev_shifted q m n j) $\n    i", "unfolding vec_of_poly_rev_shifted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (sylvester_mat_sub m n p q) j $ i =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "apply (subst index_col)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < dim_row (sylvester_mat_sub m n p q)\n 2. j < dim_col (sylvester_mat_sub m n p q)\n 3. sylvester_mat_sub m n p q $$ (i, j) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "using i"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (3 subgoals):\n 1. i < dim_row (sylvester_mat_sub m n p q)\n 2. j < dim_col (sylvester_mat_sub m n p q)\n 3. sylvester_mat_sub m n p q $$ (i, j) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. j < dim_col (sylvester_mat_sub m n p q)\n 2. sylvester_mat_sub m n p q $$ (i, j) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "using j"], ["proof (prove)\nusing this:\n  j < m + n\n\ngoal (2 subgoals):\n 1. j < dim_col (sylvester_mat_sub m n p q)\n 2. sylvester_mat_sub m n p q $$ (i, j) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sylvester_mat_sub m n p q $$ (i, j) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "apply (subst sylvester_mat_sub_index)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < m + n\n 2. j < m + n\n 3. (if i < n\n     then if i \\<le> j \\<and> j - i \\<le> m then coeff p (m + i - j)\n          else (0::'a)\n     else if i - n \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "using i"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (3 subgoals):\n 1. i < m + n\n 2. j < m + n\n 3. (if i < n\n     then if i \\<le> j \\<and> j - i \\<le> m then coeff p (m + i - j)\n          else (0::'a)\n     else if i - n \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. j < m + n\n 2. (if i < n\n     then if i \\<le> j \\<and> j - i \\<le> m then coeff p (m + i - j)\n          else (0::'a)\n     else if i - n \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "using j"], ["proof (prove)\nusing this:\n  j < m + n\n\ngoal (2 subgoals):\n 1. j < m + n\n 2. (if i < n\n     then if i \\<le> j \\<and> j - i \\<le> m then coeff p (m + i - j)\n          else (0::'a)\n     else if i - n \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < n\n     then if i \\<le> j \\<and> j - i \\<le> m then coeff p (m + i - j)\n          else (0::'a)\n     else if i - n \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "apply (cases \"i < n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    (if i < n\n     then if i \\<le> j \\<and> j - i \\<le> m then coeff p (m + i - j)\n          else (0::'a)\n     else if i - n \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i\n 2. \\<not> i < n \\<Longrightarrow>\n    (if i < n\n     then if i \\<le> j \\<and> j - i \\<le> m then coeff p (m + i - j)\n          else (0::'a)\n     else if i - n \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "using i"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    (if i < n\n     then if i \\<le> j \\<and> j - i \\<le> m then coeff p (m + i - j)\n          else (0::'a)\n     else if i - n \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i\n 2. \\<not> i < n \\<Longrightarrow>\n    (if i < n\n     then if i \\<le> j \\<and> j - i \\<le> m then coeff p (m + i - j)\n          else (0::'a)\n     else if i - n \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    (if i < n\n     then if i \\<le> j \\<and> j - i \\<le> m then coeff p (m + i - j)\n          else (0::'a)\n     else if i - n \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "using i"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    (if i < n\n     then if i \\<le> j \\<and> j - i \\<le> m then coeff p (m + i - j)\n          else (0::'a)\n     else if i - n \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> m + i then coeff p (m + i - j)\n          else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> n + i then coeff q (n + i - j)\n          else (0::'a))) $\n    i", "apply (auto simp: not_less not_le intro!: coeff_eq_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  col (sylvester_mat_sub m n p q) j $ i =\n  (Missing_Lemmas.vec_of_poly_rev_shifted p n m j @\\<^sub>v\n   Missing_Lemmas.vec_of_poly_rev_shifted q m n j) $\n  i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_poly_rev_shifted_scalar_prod:\n  fixes p v\n  defines \"q \\<equiv> poly_of_vec v\"\n  assumes m: \"degree p \\<le> m\" and n: \"dim_vec v = n\"\n  assumes j: \"j < m+n\"\n  shows \"vec_of_poly_rev_shifted p n m (n+m-Suc j) \\<bullet> v = coeff (p * q) j\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n    v =\n    coeff (p * q) j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n    v =\n    coeff (p * q) j", "have id1: \"\\<And> i. m + i - (n + m - Suc j) = i + Suc j - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. m + i - (n + m - Suc j) = i + Suc j - n", "using j"], ["proof (prove)\nusing this:\n  j < m + n\n\ngoal (1 subgoal):\n 1. \\<And>i. m + i - (n + m - Suc j) = i + Suc j - n", "by auto"], ["proof (state)\nthis:\n  m + ?i - (n + m - Suc j) = ?i + Suc j - n\n\ngoal (1 subgoal):\n 1. Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n    v =\n    coeff (p * q) j", "let ?g = \"\\<lambda> i. if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i then coeff p (i + Suc j - n) *  v $ i else 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n    v =\n    coeff (p * q) j", "have \"?thesis = ((\\<Sum>i = 0..<n. ?g i) =          \n        (\\<Sum>i\\<le>j. coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else 0)))\" (is \"_ = (?l = ?r)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n     v =\n     coeff (p * q) j) =\n    ((\\<Sum>i = 0..<n.\n         if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n         then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n     (\\<Sum>i\\<le>j.\n         coeff p i *\n         (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))", "unfolding vec_of_poly_rev_shifted_def coeff_mult m scalar_prod_def n q_def\n      coeff_poly_of_vec"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n.\n         vec n\n          (\\<lambda>i.\n              if i \\<le> n + m - Suc j \\<and> n + m - Suc j \\<le> m + i\n              then coeff p (m + i - (n + m - Suc j)) else (0::'a)) $\n         i *\n         v $ i) =\n     (\\<Sum>i\\<le>j.\n         coeff p i *\n         (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))) =\n    ((\\<Sum>i = 0..<n.\n         if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n         then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n     (\\<Sum>i\\<le>j.\n         coeff p i *\n         (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))", "by (subst sum.cong, insert id1, auto)"], ["proof (state)\nthis:\n  (Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n   v =\n   coeff (p * q) j) =\n  ((\\<Sum>i = 0..<n.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n   (\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))\n\ngoal (1 subgoal):\n 1. Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n    v =\n    coeff (p * q) j", "also"], ["proof (state)\nthis:\n  (Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n   v =\n   coeff (p * q) j) =\n  ((\\<Sum>i = 0..<n.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n   (\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))\n\ngoal (1 subgoal):\n 1. Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n    v =\n    coeff (p * q) j", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"?r = (\\<Sum>i\\<le>j. (if j - i < n then coeff p i * v $ (n - Suc (j - i)) else 0))\" (is \"_ = sum ?f _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>j.\n        coeff p i *\n        (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n    (\\<Sum>i\\<le>j.\n        if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n  (\\<Sum>i\\<le>j.\n      if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n  (\\<Sum>i\\<le>j.\n      if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?f {..j} = sum ?f ({i. i \\<le> j \\<and> j - i < n} \\<union> {i. i \\<le> j \\<and> \\<not> j - i < n})\" \n      (is \"_ = sum _ (?R1 \\<union> ?R2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>j.\n        if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n                 {i. i \\<le> j \\<and> \\<not> j - i < n}.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>j.\n      if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n               {i. i \\<le> j \\<and> \\<not> j - i < n}.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>j.\n      if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n               {i. i \\<le> j \\<and> \\<not> j - i < n}.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?f ?R1 + sum ?f ?R2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n                 {i. i \\<le> j \\<and> \\<not> j - i < n}.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n    (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n    (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))", "by (subst sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n               {i. i \\<le> j \\<and> \\<not> j - i < n}.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n  (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n               {i. i \\<le> j \\<and> \\<not> j - i < n}.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n  (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?f ?R2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n    (0::'a)", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?f ?R1 + 0 = sum (\\<lambda> i. coeff p i * v $ (i + n - Suc j)) ?R1\"\n      (is \"_ = sum ?F _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n    (0::'a) =\n    (\\<Sum>i | i \\<le> j \\<and> j - i < n. coeff p i * v $ (i + n - Suc j))", "by (subst sum.cong, auto simp: ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n  (0::'a) =\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n. coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n  (0::'a) =\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n. coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?F ((?R1 \\<inter> {..m}) \\<union> (?R1 - {..m}))\"\n      (is \"_ = sum _ (?R \\<union> ?R')\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n       coeff p i * v $ (i + n - Suc j)) =\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n                 ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n       coeff p i * v $ (i + n - Suc j))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n. coeff p i * v $ (i + n - Suc j)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n               ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n     coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n. coeff p i * v $ (i + n - Suc j)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n               ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n     coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?F ?R + sum ?F ?R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n                 ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n       coeff p i * v $ (i + n - Suc j)) =\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n       coeff p i * v $ (i + n - Suc j)) +\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j))", "by (subst sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n               ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n     coeff p i * v $ (i + n - Suc j)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n     coeff p i * v $ (i + n - Suc j)) +\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n     coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n               ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n     coeff p i * v $ (i + n - Suc j)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n     coeff p i * v $ (i + n - Suc j)) +\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n     coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?F ?R' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "assume \"x > m\""], ["proof (state)\nthis:\n  m < x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "with m"], ["proof (chain)\npicking this:\n  degree p \\<le> m\n  m < x", "have \"?F x = 0\""], ["proof (prove)\nusing this:\n  degree p \\<le> m\n  m < x\n\ngoal (1 subgoal):\n 1. coeff p x * v $ (x + n - Suc j) = (0::'a)", "by (subst coeff_eq_0, auto)"], ["proof (state)\nthis:\n  coeff p x * v $ (x + n - Suc j) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "}"], ["proof (state)\nthis:\n  m < ?x2 \\<Longrightarrow> coeff p ?x2 * v $ (?x2 + n - Suc j) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  m < ?x2 \\<Longrightarrow> coeff p ?x2 * v $ (?x2 + n - Suc j) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "by (subst sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n     coeff p i * v $ (i + n - Suc j)) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n     coeff p i * v $ (i + n - Suc j)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n     coeff p i * v $ (i + n - Suc j)) +\n  (0::'a)", "have r: \"?r = sum ?F ?R\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n     coeff p i * v $ (i + n - Suc j)) +\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>j.\n        coeff p i *\n        (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n       coeff p i * v $ (i + n - Suc j))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n     coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"?l = sum ?g ({i. i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \n      \\<union> {i. i < n \\<and> \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i)})\" \n      (is \"_ = sum _ (?L1 \\<union> ?L2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<union>\n                 {i. i < n \\<and>\n                     \\<not> (i \\<le> n + m - Suc j \\<and>\n                             n - Suc j \\<le> i)}.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<union>\n               {i. i < n \\<and>\n                   \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i)}.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<union>\n               {i. i < n \\<and>\n                   \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i)}.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?g ?L1 + sum ?g ?L2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<union>\n                 {i. i < n \\<and>\n                     \\<not> (i \\<le> n + m - Suc j \\<and>\n                             n - Suc j \\<le> i)}.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n    (\\<Sum>i | i < n \\<and>\n               \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a))", "by (subst sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<union>\n               {i. i < n \\<and>\n                   \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i)}.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n  (\\<Sum>i | i < n \\<and>\n             \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<union>\n               {i. i < n \\<and>\n                   \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i)}.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n  (\\<Sum>i | i < n \\<and>\n             \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?g ?L2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < n \\<and>\n               \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (0::'a)", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and>\n             \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and>\n             \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?g ?L1 + 0 = sum (\\<lambda> i. coeff p (i + Suc j - n) * v $ i) ?L1\"\n      (is \"_ = sum ?G _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n    (0::'a) =\n    (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n       coeff p (i + Suc j - n) * v $ i)", "by (subst sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n  (0::'a) =\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n  (0::'a) =\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?G (?L1 \\<inter> {i. i + Suc j - n \\<le> m} \\<union> (?L1 - {i. i + Suc j - n \\<le> m}))\"\n      (is \"_ = sum _ (?L \\<union> ?L')\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n       coeff p (i + Suc j - n) * v $ i) =\n    (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<inter>\n                 {i. i + Suc j - n \\<le> m} \\<union>\n                 ({i. i < n \\<and>\n                      i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                  {i. i + Suc j - n \\<le> m}).\n       coeff p (i + Suc j - n) * v $ i)", "by (subst sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     coeff p (i + Suc j - n) * v $ i) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m} \\<union>\n               ({i. i < n \\<and>\n                    i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                {i. i + Suc j - n \\<le> m}).\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     coeff p (i + Suc j - n) * v $ i) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m} \\<union>\n               ({i. i < n \\<and>\n                    i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                {i. i + Suc j - n \\<le> m}).\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?G ?L + sum ?G ?L'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<inter>\n                 {i. i + Suc j - n \\<le> m} \\<union>\n                 ({i. i < n \\<and>\n                      i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                  {i. i + Suc j - n \\<le> m}).\n       coeff p (i + Suc j - n) * v $ i) =\n    (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<inter>\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) +\n    (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i)", "by (subst sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m} \\<union>\n               ({i. i < n \\<and>\n                    i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                {i. i + Suc j - n \\<le> m}).\n     coeff p (i + Suc j - n) * v $ i) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) +\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m} \\<union>\n               ({i. i < n \\<and>\n                    i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                {i. i + Suc j - n \\<le> m}).\n     coeff p (i + Suc j - n) * v $ i) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) +\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?G ?L' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "assume \"x + Suc j - n > m\""], ["proof (state)\nthis:\n  m < x + Suc j - n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "with m"], ["proof (chain)\npicking this:\n  degree p \\<le> m\n  m < x + Suc j - n", "have \"?G x = 0\""], ["proof (prove)\nusing this:\n  degree p \\<le> m\n  m < x + Suc j - n\n\ngoal (1 subgoal):\n 1. coeff p (x + Suc j - n) * v $ x = (0::'a)", "by (subst coeff_eq_0, auto)"], ["proof (state)\nthis:\n  coeff p (x + Suc j - n) * v $ x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "}"], ["proof (state)\nthis:\n  m < ?x2 + Suc j - n \\<Longrightarrow>\n  coeff p (?x2 + Suc j - n) * v $ ?x2 = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  m < ?x2 + Suc j - n \\<Longrightarrow>\n  coeff p (?x2 + Suc j - n) * v $ ?x2 = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "by (subst sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) +\n  (0::'a)", "have l: \"?l = sum ?G ?L\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) +\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<inter>\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "let ?bij = \"\\<lambda> i. i + n - Suc j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "assume x: \"j < m + n\" \"Suc (x + j) - n \\<le> m\" \"x < n\" \"n - Suc j \\<le> x\""], ["proof (state)\nthis:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "define y where \"y = x + Suc j - n\""], ["proof (state)\nthis:\n  y = x + Suc j - n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "from x"], ["proof (chain)\npicking this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x", "have \"x + Suc j \\<ge> n\""], ["proof (prove)\nusing this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n\ngoal (1 subgoal):\n 1. n \\<le> x + Suc j", "by auto"], ["proof (state)\nthis:\n  n \\<le> x + Suc j\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "with x"], ["proof (chain)\npicking this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n  n \\<le> x + Suc j", "have xy: \"x = ?bij y\""], ["proof (prove)\nusing this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n  n \\<le> x + Suc j\n\ngoal (1 subgoal):\n 1. x = y + n - Suc j", "unfolding y_def"], ["proof (prove)\nusing this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n  n \\<le> x + Suc j\n\ngoal (1 subgoal):\n 1. x = x + Suc j - n + n - Suc j", "by auto"], ["proof (state)\nthis:\n  x = y + n - Suc j\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "from x"], ["proof (chain)\npicking this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x", "have y: \"y \\<in> ?R\""], ["proof (prove)\nusing this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n\ngoal (1 subgoal):\n 1. y \\<in> {i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}", "unfolding y_def"], ["proof (prove)\nusing this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n\ngoal (1 subgoal):\n 1. x + Suc j - n \\<in> {i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}", "by auto"], ["proof (state)\nthis:\n  y \\<in> {i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"x \\<in> ?bij ` ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>i. i + n - Suc j) `\n            ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})", "unfolding xy"], ["proof (prove)\ngoal (1 subgoal):\n 1. y + n - Suc j\n    \\<in> (\\<lambda>i. i + n - Suc j) `\n          ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})", "using y"], ["proof (prove)\nusing this:\n  y \\<in> {i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}\n\ngoal (1 subgoal):\n 1. y + n - Suc j\n    \\<in> (\\<lambda>i. i + n - Suc j) `\n          ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>i. i + n - Suc j) `\n          ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>j < m + n; Suc (?x2 + j) - n \\<le> m; ?x2 < n;\n   n - Suc j \\<le> ?x2\\<rbrakk>\n  \\<Longrightarrow> ?x2\n                    \\<in> (\\<lambda>i. i + n - Suc j) `\n                          ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "note tedious = this"], ["proof (state)\nthis:\n  \\<lbrakk>j < m + n; Suc (?x2 + j) - n \\<le> m; ?x2 < n;\n   n - Suc j \\<le> ?x2\\<rbrakk>\n  \\<Longrightarrow> ?x2\n                    \\<in> (\\<lambda>i. i + n - Suc j) `\n                          ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "unfolding l r"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<inter>\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n       coeff p i * v $ (i + n - Suc j))", "by (rule sum.reindex_cong[of ?bij], insert j, auto simp: inj_on_def tedious)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))\n\ngoal (1 subgoal):\n 1. Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n    v =\n    coeff (p * q) j", "finally"], ["proof (chain)\npicking this:\n  (Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n   v =\n   coeff (p * q) j) =\n  ((\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n   (\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))", "show ?thesis"], ["proof (prove)\nusing this:\n  (Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n   v =\n   coeff (p * q) j) =\n  ((\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n   (\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))\n\ngoal (1 subgoal):\n 1. Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet>\n    v =\n    coeff (p * q) j", "by simp"], ["proof (state)\nthis:\n  Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc j) \\<bullet> v =\n  coeff (p * q) j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sylvester_sub_poly:\n  fixes p q :: \"'a :: comm_semiring_0 poly\"\n  assumes m: \"degree p \\<le> m\"\n  assumes n: \"degree q \\<le> n\"\n  assumes v: \"v \\<in> carrier_vec (m+n)\"\n  shows \"poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) =\n    poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) =\n    poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q", "proof (rule poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n        na =\n       coeff\n        (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n        na", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n        na =\n       coeff\n        (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n        na", "let ?Tv = \"(sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n        na =\n       coeff\n        (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n        na", "have dim: \"dim_vec (vec_first v n) = n\" \"dim_vec (vec_last v m) = m\" \"dim_vec ?Tv = n + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_first v n) = n &&&\n    dim_vec (vec_last v m) = m &&&\n    dim_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) = n + m", "using v"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (m + n)\n\ngoal (1 subgoal):\n 1. dim_vec (vec_first v n) = n &&&\n    dim_vec (vec_last v m) = m &&&\n    dim_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) = n + m", "by auto"], ["proof (state)\nthis:\n  dim_vec (vec_first v n) = n\n  dim_vec (vec_last v m) = m\n  dim_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) = n + m\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n        na =\n       coeff\n        (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n        na", "have if_distrib: \"\\<And> x y z. (if x then y else (0 :: 'a)) * z = (if x then y * z else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (if x then y else (0::'a)) * z = (if x then y * z else (0::'a))", "by auto"], ["proof (state)\nthis:\n  (if ?x then ?y else (0::'a)) * ?z = (if ?x then ?y * ?z else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n        na =\n       coeff\n        (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n        na", "show \"coeff ?l i = coeff ?r i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "proof (cases \"i < m+n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "case False"], ["proof (state)\nthis:\n  \\<not> i < m + n\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence i_mn: \"i \\<ge> m+n\"\n        and i_n: \"\\<And>x. x \\<le> i \\<and> x < n \\<longleftrightarrow> x < n\"\n        and i_m: \"\\<And>x. x \\<le> i \\<and> x < m \\<longleftrightarrow> x < m\""], ["proof (prove)\nusing this:\n  \\<not> i < m + n\n\ngoal (1 subgoal):\n 1. m + n \\<le> i &&&\n    (\\<And>x. (x \\<le> i \\<and> x < n) = (x < n)) &&&\n    (\\<And>x. (x \\<le> i \\<and> x < m) = (x < m))", "by auto"], ["proof (state)\nthis:\n  m + n \\<le> i\n  (?x \\<le> i \\<and> ?x < n) = (?x < n)\n  (?x \\<le> i \\<and> ?x < m) = (?x < m)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"coeff ?r i =\n            (\\<Sum> x < n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n            (\\<Sum> x < m. vec_last v m $ (m - Suc x) * coeff q (i - x))\"\n        (is \"_ = sum ?f _ + sum ?g _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding coeff_add coeff_mult Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<le>i.\n        coeff (poly_of_vec (vec_first v n)) ia * coeff p (i - ia)) +\n    (\\<Sum>ia\\<le>i.\n        coeff (poly_of_vec (vec_last v m)) ia * coeff q (i - ia)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding coeff_poly_of_vec dim if_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<le>i.\n        if ia < n then vec_first v n $ (n - Suc ia) * coeff p (i - ia)\n        else (0::'a)) +\n    (\\<Sum>ia\\<le>i.\n        if ia < m then vec_last v m $ (m - Suc ia) * coeff q (i - ia)\n        else (0::'a)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding atMost_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x. x \\<le> i}.\n       if ia < n then vec_first v n $ (n - Suc ia) * coeff p (i - ia)\n       else (0::'a)) +\n    (\\<Sum>ia\\<in>{x. x \\<le> i}.\n       if ia < m then vec_last v m $ (m - Suc ia) * coeff q (i - ia)\n       else (0::'a)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "apply(subst sum.inter_filter[symmetric],simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x \\<in> {x. x \\<le> i}. x < n}.\n       vec_first v n $ (n - Suc ia) * coeff p (i - ia)) +\n    (\\<Sum>ia\\<in>{x. x \\<le> i}.\n       if ia < m then vec_last v m $ (m - Suc ia) * coeff q (i - ia)\n       else (0::'a)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "apply(subst sum.inter_filter[symmetric],simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x \\<in> {x. x \\<le> i}. x < n}.\n       vec_first v n $ (n - Suc ia) * coeff p (i - ia)) +\n    (\\<Sum>ia\\<in>{x \\<in> {x. x \\<le> i}. x < m}.\n       vec_last v m $ (m - Suc ia) * coeff q (i - ia)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x. x \\<le> i \\<and> x < n}.\n       vec_first v n $ (n - Suc ia) * coeff p (i - ia)) +\n    (\\<Sum>ia\\<in>{x. x \\<le> i \\<and> x < m}.\n       vec_last v m $ (m - Suc ia) * coeff q (i - ia)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding i_n i_m"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x. x < n}.\n       vec_first v n $ (n - Suc ia) * coeff p (i - ia)) +\n    (\\<Sum>ia\\<in>{x. x < m}.\n       vec_last v m $ (m - Suc ia) * coeff q (i - ia)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding lessThan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x. x < n}.\n       vec_first v n $ (n - Suc ia) * coeff p (i - ia)) +\n    (\\<Sum>ia\\<in>{x. x < m}.\n       vec_last v m $ (m - Suc ia) * coeff q (i - ia)) =\n    (\\<Sum>x | x < n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x | x < m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "by simp"], ["proof (state)\nthis:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n  (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n  (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "{"], ["proof (state)\nthis:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n  (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "assume x: \"x < n\""], ["proof (state)\nthis:\n  x < n\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"coeff p (i-x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p (i - x) = (0::'a)", "apply(rule coeff_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p < i - x", "using i_mn x m"], ["proof (prove)\nusing this:\n  m + n \\<le> i\n  x < n\n  degree p \\<le> m\n\ngoal (1 subgoal):\n 1. degree p < i - x", "by auto"], ["proof (state)\nthis:\n  coeff p (i - x) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence \"?f x = 0\""], ["proof (prove)\nusing this:\n  coeff p (i - x) = (0::'a)\n\ngoal (1 subgoal):\n 1. vec_first v n $ (n - Suc x) * coeff p (i - x) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  vec_first v n $ (n - Suc x) * coeff p (i - x) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "}"], ["proof (state)\nthis:\n  ?x2 < n \\<Longrightarrow>\n  vec_first v n $ (n - Suc ?x2) * coeff p (i - ?x2) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence \"sum ?f {..<n} = 0\""], ["proof (prove)\nusing this:\n  ?x2 < n \\<Longrightarrow>\n  vec_first v n $ (n - Suc ?x2) * coeff p (i - ?x2) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "{"], ["proof (state)\nthis:\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "assume x: \"x < m\""], ["proof (state)\nthis:\n  x < m\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"coeff q (i-x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff q (i - x) = (0::'a)", "apply(rule coeff_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q < i - x", "using i_mn x n"], ["proof (prove)\nusing this:\n  m + n \\<le> i\n  x < m\n  degree q \\<le> n\n\ngoal (1 subgoal):\n 1. degree q < i - x", "by auto"], ["proof (state)\nthis:\n  coeff q (i - x) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence \"?g x = 0\""], ["proof (prove)\nusing this:\n  coeff q (i - x) = (0::'a)\n\ngoal (1 subgoal):\n 1. vec_last v m $ (m - Suc x) * coeff q (i - x) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  vec_last v m $ (m - Suc x) * coeff q (i - x) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "}"], ["proof (state)\nthis:\n  ?x2 < m \\<Longrightarrow>\n  vec_last v m $ (m - Suc ?x2) * coeff q (i - ?x2) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence \"sum ?g {..<m} = 0\""], ["proof (prove)\nusing this:\n  ?x2 < m \\<Longrightarrow>\n  vec_last v m $ (m - Suc ?x2) * coeff q (i - ?x2) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x)) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x)) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "finally"], ["proof (chain)\npicking this:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (0::'a) + (0::'a)", "have \"coeff ?r i = 0\""], ["proof (prove)\nusing this:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (0::'a) + (0::'a)\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "from False"], ["proof (chain)\npicking this:\n  \\<not> i < m + n", "have \"0 = coeff ?l i\""], ["proof (prove)\nusing this:\n  \\<not> i < m + n\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v)) i", "unfolding coeff_poly_of_vec dim sum.distrib[symmetric]"], ["proof (prove)\nusing this:\n  \\<not> i < m + n\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    (if i < n + m\n     then ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) $\n          (n + m - Suc i)\n     else (0::'a))", "by auto"], ["proof (state)\nthis:\n  (0::'a) =\n  coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v)) i\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "finally"], ["proof (chain)\npicking this:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v)) i", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v)) i\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "by auto"], ["proof (state)\nthis:\n  coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v)) i =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "case True"], ["proof (state)\nthis:\n  i < m + n\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence \"coeff ?l i = ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i)\""], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i)", "unfolding coeff_poly_of_vec dim sum.distrib[symmetric]"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (1 subgoal):\n 1. (if i < n + m\n     then ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) $\n          (n + m - Suc i)\n     else (0::'a)) =\n    ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i)", "by auto"], ["proof (state)\nthis:\n  coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v)) i =\n  ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i)\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v)) i =\n  ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i)\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"... = coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i) =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(subst index_mult_mat_vec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n + m - Suc i < dim_row (sylvester_mat_sub m n p q)\\<^sup>T\n 2. row (sylvester_mat_sub m n p q)\\<^sup>T (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using True"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (2 subgoals):\n 1. n + m - Suc i < dim_row (sylvester_mat_sub m n p q)\\<^sup>T\n 2. row (sylvester_mat_sub m n p q)\\<^sup>T (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (sylvester_mat_sub m n p q)\\<^sup>T (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(subst row_transpose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n + m - Suc i < dim_col (sylvester_mat_sub m n p q)\n 2. col (sylvester_mat_sub m n p q) (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using True"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (2 subgoals):\n 1. n + m - Suc i < dim_col (sylvester_mat_sub m n p q)\n 2. col (sylvester_mat_sub m n p q) (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (sylvester_mat_sub m n p q) (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(subst col_sylvester_sub)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n + m - Suc i < m + n\n 2. (Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc i) @\\<^sub>v\n     Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i)) \\<bullet>\n    v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using True"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (2 subgoals):\n 1. n + m - Suc i < m + n\n 2. (Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc i) @\\<^sub>v\n     Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i)) \\<bullet>\n    v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc i) @\\<^sub>v\n     Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i)) \\<bullet>\n    v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(subst vec_first_last_append[of v n m,symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> carrier_vec (n + m)\n 2. (Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc i) @\\<^sub>v\n     Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i)) \\<bullet>\n    (vec_first v n @\\<^sub>v vec_last v m) =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using v"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (m + n)\n\ngoal (2 subgoals):\n 1. v \\<in> carrier_vec (n + m)\n 2. (Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc i) @\\<^sub>v\n     Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i)) \\<bullet>\n    (vec_first v n @\\<^sub>v vec_last v m) =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(simp add: add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc i) @\\<^sub>v\n     Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i)) \\<bullet>\n    (vec_first v n @\\<^sub>v vec_last v m) =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(subst scalar_prod_append)"], ["proof (prove)\ngoal (5 subgoals):\n 1. Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc i)\n    \\<in> carrier_vec ?n1.55\n 2. Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i)\n    \\<in> carrier_vec ?n2.55\n 3. vec_first v n \\<in> carrier_vec ?n1.55\n 4. vec_last v m \\<in> carrier_vec ?n2.55\n 5. Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc i) \\<bullet>\n    vec_first v n +\n    Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i) \\<bullet>\n    vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply (rule carrier_vecI,simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. Missing_Lemmas.vec_of_poly_rev_shifted p n m (n + m - Suc i) \\<bullet>\n    vec_first v n +\n    Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i) \\<bullet>\n    vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply (subst vec_of_poly_rev_shifted_scalar_prod[OF m],simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < m + n\n 2. coeff (p * poly_of_vec (vec_first v n)) i +\n    Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i) \\<bullet>\n    vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using True"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (2 subgoals):\n 1. i < m + n\n 2. coeff (p * poly_of_vec (vec_first v n)) i +\n    Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i) \\<bullet>\n    vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n)) i +\n    Missing_Lemmas.vec_of_poly_rev_shifted q m n (n + m - Suc i) \\<bullet>\n    vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply (subst add.commute[of n m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n)) i +\n    Missing_Lemmas.vec_of_poly_rev_shifted q m n (m + n - Suc i) \\<bullet>\n    vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply (subst vec_of_poly_rev_shifted_scalar_prod[OF n])"], ["proof (prove)\ngoal (3 subgoals):\n 1. dim_vec (vec_last v m) = m\n 2. i < n + m\n 3. coeff (p * poly_of_vec (vec_first v n)) i +\n    coeff (q * poly_of_vec (vec_last v m)) i =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < n + m\n 2. coeff (p * poly_of_vec (vec_first v n)) i +\n    coeff (q * poly_of_vec (vec_last v m)) i =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using True"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (2 subgoals):\n 1. i < n + m\n 2. coeff (p * poly_of_vec (vec_first v n)) i +\n    coeff (q * poly_of_vec (vec_last v m)) i =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n)) i +\n    coeff (q * poly_of_vec (vec_last v m)) i =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "by simp"], ["proof (state)\nthis:\n  ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i) =\n  coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m)) i\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i) =\n  coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m)) i\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"... =\n        (\\<Sum>x\\<le>i. (if x < n then vec_first v n $ (n - Suc x) else 0) * coeff p (i - x)) +\n        (\\<Sum>x\\<le>i. (if x < m then vec_last v m $ (m - Suc x) else 0) * coeff q (i - x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i =\n    (\\<Sum>x\\<le>i.\n        (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n        coeff p (i - x)) +\n    (\\<Sum>x\\<le>i.\n        (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n        coeff q (i - x))", "unfolding coeff_poly_of_vec[of \"vec_first v n\",unfolded dim_vec_first,symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i =\n    (\\<Sum>x\\<le>i.\n        coeff (poly_of_vec (vec_first v n)) x * coeff p (i - x)) +\n    (\\<Sum>x\\<le>i.\n        (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n        coeff q (i - x))", "unfolding coeff_poly_of_vec[of \"vec_last v m\",unfolded dim_vec_last,symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i =\n    (\\<Sum>x\\<le>i.\n        coeff (poly_of_vec (vec_first v n)) x * coeff p (i - x)) +\n    (\\<Sum>x\\<le>i. coeff (poly_of_vec (vec_last v m)) x * coeff q (i - x))", "unfolding coeff_mult[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p) i +\n    coeff (poly_of_vec (vec_last v m) * q) i", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n   i =\n  (\\<Sum>x\\<le>i.\n      (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n      coeff p (i - x)) +\n  (\\<Sum>x\\<le>i.\n      (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n      coeff q (i - x))\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n   i =\n  (\\<Sum>x\\<le>i.\n      (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n      coeff p (i - x)) +\n  (\\<Sum>x\\<le>i.\n      (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n      coeff q (i - x))\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"... = coeff ?r i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n        coeff p (i - x)) +\n    (\\<Sum>x\\<le>i.\n        (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n        coeff q (i - x)) =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "unfolding coeff_add coeff_mult Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n        coeff p (i - x)) +\n    (\\<Sum>x\\<le>i.\n        (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n        coeff q (i - x)) =\n    (\\<Sum>ia\\<le>i.\n        coeff (poly_of_vec (vec_first v n)) ia * coeff p (i - ia)) +\n    (\\<Sum>ia\\<le>i.\n        coeff (poly_of_vec (vec_last v m)) ia * coeff q (i - ia))", "unfolding coeff_poly_of_vec dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n        coeff p (i - x)) +\n    (\\<Sum>x\\<le>i.\n        (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n        coeff q (i - x)) =\n    (\\<Sum>ia\\<le>i.\n        (if ia < n then vec_first v n $ (n - Suc ia) else (0::'a)) *\n        coeff p (i - ia)) +\n    (\\<Sum>ia\\<le>i.\n        (if ia < m then vec_last v m $ (m - Suc ia) else (0::'a)) *\n        coeff q (i - ia))", ".."], ["proof (state)\nthis:\n  (\\<Sum>x\\<le>i.\n      (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n      coeff p (i - x)) +\n  (\\<Sum>x\\<le>i.\n      (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n      coeff q (i - x)) =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "finally"], ["proof (chain)\npicking this:\n  coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v)) i =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v)) i =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "."], ["proof (state)\nthis:\n  coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v)) i =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff (poly_of_vec ((sylvester_mat_sub m n p q)\\<^sup>T *\\<^sub>v v)) i =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i\n\ngoal:\nNo subgoals!", "qed"], ["", "(**** End of the lemmas which could be moved to Algebraic_Numbers/Resultant.thy ****)\n\n(**** The following lemmas could be moved to Computational_Algebra/Polynomial.thy ****)"], ["", "lemma normalize_field [simp]: \"normalize (a :: 'a :: {field, semiring_gcd}) = (if a = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize a = (if a = (0::'a) then 0::'a else (1::'a))", "using unit_factor_normalize"], ["proof (prove)\nusing this:\n  ?a \\<noteq> (0::?'a) \\<Longrightarrow>\n  unit_factor (normalize ?a) = (1::?'a)\n\ngoal (1 subgoal):\n 1. normalize a = (if a = (0::'a) then 0::'a else (1::'a))", "by fastforce"], ["", "lemma content_field [simp]: \"content (p :: 'a :: {field,semiring_gcd} poly) = (if p = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content p = (if p = 0 then 0::'a else (1::'a))", "by (induct p, auto simp: content_def)"], ["", "lemma primitive_part_field [simp]: \"primitive_part (p :: 'a :: {field,semiring_gcd} poly) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_part p = p", "by (cases \"p = 0\", auto intro!: primitive_part_prim)"], ["", "lemma primitive_part_dvd: \"primitive_part a dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_part a dvd a", "by (metis content_times_primitive_part dvd_def dvd_refl mult_smult_right)"], ["", "lemma degree_abs [simp]:\n  \"degree \\<bar>p\\<bar> = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree \\<bar>p\\<bar> = degree p", "by (auto simp: abs_poly_def)"], ["", "lemma degree_gcd1:\n  assumes a_not0: \"a \\<noteq> 0\" \n  shows \"degree (gcd a b) \\<le> degree a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree a", "let ?g = \"gcd a b\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree a", "have gcd_dvd_b: \"?g dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd a b dvd a", "by simp"], ["proof (state)\nthis:\n  gcd a b dvd a\n\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree a", "from this"], ["proof (chain)\npicking this:\n  gcd a b dvd a", "obtain c where a_gc: \"a = ?g * c\""], ["proof (prove)\nusing this:\n  gcd a b dvd a\n\ngoal (1 subgoal):\n 1. (\\<And>c. a = gcd a b * c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. a = gcd a b * k\n\ngoal (1 subgoal):\n 1. (\\<And>c. a = gcd a b * c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = gcd a b * c\n\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree a", "have g_not0: \"?g \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd a b \\<noteq> 0", "using a_not0 a_gc"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  a = gcd a b * c\n\ngoal (1 subgoal):\n 1. gcd a b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  gcd a b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree a", "have c0: \"c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "using a_not0 a_gc"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  a = gcd a b * c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree a", "have \"degree ?g \\<le> degree (?g * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree (gcd a b * c)", "by (rule degree_mult_right_le[OF c0])"], ["proof (state)\nthis:\n  degree (gcd a b) \\<le> degree (gcd a b * c)\n\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree a", "also"], ["proof (state)\nthis:\n  degree (gcd a b) \\<le> degree (gcd a b * c)\n\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree a", "have \"... = degree a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (gcd a b * c) = degree a", "using a_gc"], ["proof (prove)\nusing this:\n  a = gcd a b * c\n\ngoal (1 subgoal):\n 1. degree (gcd a b * c) = degree a", "by auto"], ["proof (state)\nthis:\n  degree (gcd a b * c) = degree a\n\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree a", "finally"], ["proof (chain)\npicking this:\n  degree (gcd a b) \\<le> degree a", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (gcd a b) \\<le> degree a\n\ngoal (1 subgoal):\n 1. degree (gcd a b) \\<le> degree a", "."], ["proof (state)\nthis:\n  degree (gcd a b) \\<le> degree a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma primitive_part_neg [simp]:\n  fixes a::\"'a :: {factorial_ring_gcd,factorial_semiring_multiplicative} poly\"\n  shows \"primitive_part (-a) = - primitive_part a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_part (- a) = - primitive_part a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. primitive_part (- a) = - primitive_part a", "have \"primitive_part (-a) = primitive_part (smult (-1) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_part (- a) = primitive_part (smult (- (1::'a)) a)", "by auto"], ["proof (state)\nthis:\n  primitive_part (- a) = primitive_part (smult (- (1::'a)) a)\n\ngoal (1 subgoal):\n 1. primitive_part (- a) = - primitive_part a", "then"], ["proof (chain)\npicking this:\n  primitive_part (- a) = primitive_part (smult (- (1::'a)) a)", "show ?thesis"], ["proof (prove)\nusing this:\n  primitive_part (- a) = primitive_part (smult (- (1::'a)) a)\n\ngoal (1 subgoal):\n 1. primitive_part (- a) = - primitive_part a", "unfolding primitive_part_smult"], ["proof (prove)\nusing this:\n  primitive_part (- a) = smult (unit_factor (- (1::'a))) (primitive_part a)\n\ngoal (1 subgoal):\n 1. primitive_part (- a) = - primitive_part a", "by (simp add: is_unit_unit_factor)"], ["proof (state)\nthis:\n  primitive_part (- a) = - primitive_part a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma content_uminus[simp]: \n  fixes f::\"int poly\"\n  shows \"content (-f) = content f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (- f) = content f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. content (- f) = content f", "have \"-f = - (smult 1 f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - f = - smult 1 f", "by auto"], ["proof (state)\nthis:\n  - f = - smult 1 f\n\ngoal (1 subgoal):\n 1. content (- f) = content f", "also"], ["proof (state)\nthis:\n  - f = - smult 1 f\n\ngoal (1 subgoal):\n 1. content (- f) = content f", "have \"... = smult (-1) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - smult 1 f = smult (- 1) f", "using smult_minus_left"], ["proof (prove)\nusing this:\n  smult (- ?a) ?p = - smult ?a ?p\n\ngoal (1 subgoal):\n 1. - smult 1 f = smult (- 1) f", "by auto"], ["proof (state)\nthis:\n  - smult 1 f = smult (- 1) f\n\ngoal (1 subgoal):\n 1. content (- f) = content f", "finally"], ["proof (chain)\npicking this:\n  - f = smult (- 1) f", "have \"content (-f) = content (smult (-1) f)\""], ["proof (prove)\nusing this:\n  - f = smult (- 1) f\n\ngoal (1 subgoal):\n 1. content (- f) = content (smult (- 1) f)", "by auto"], ["proof (state)\nthis:\n  content (- f) = content (smult (- 1) f)\n\ngoal (1 subgoal):\n 1. content (- f) = content f", "also"], ["proof (state)\nthis:\n  content (- f) = content (smult (- 1) f)\n\ngoal (1 subgoal):\n 1. content (- f) = content f", "have \"... = normalize (- 1) * content f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (smult (- 1) f) = normalize (- 1) * content f", "unfolding content_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (- 1) * content f = normalize (- 1) * content f", ".."], ["proof (state)\nthis:\n  content (smult (- 1) f) = normalize (- 1) * content f\n\ngoal (1 subgoal):\n 1. content (- f) = content f", "finally"], ["proof (chain)\npicking this:\n  content (- f) = normalize (- 1) * content f", "show ?thesis"], ["proof (prove)\nusing this:\n  content (- f) = normalize (- 1) * content f\n\ngoal (1 subgoal):\n 1. content (- f) = content f", "by auto"], ["proof (state)\nthis:\n  content (- f) = content f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pseudo_mod_monic:\n  fixes f g :: \"'a::{comm_ring_1,semiring_1_no_zero_divisors} poly\"\n  defines \"r \\<equiv> pseudo_mod f g\"\n  assumes monic_g: \"monic g\"\n  shows \"\\<exists>q.  f = g * q + r\" \"r = 0 \\<or> degree r < degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. f = g * q + r &&& r = 0 \\<or> degree r < degree g", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>q. f = g * q + r\n 2. r = 0 \\<or> degree r < degree g", "let ?cg = \"coeff g (degree g)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>q. f = g * q + r\n 2. r = 0 \\<or> degree r < degree g", "let ?cge = \"?cg ^ (Suc (degree f) - degree g)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>q. f = g * q + r\n 2. r = 0 \\<or> degree r < degree g", "define a where \"a = ?cge\""], ["proof (state)\nthis:\n  a = lead_coeff g ^ (Suc (degree f) - degree g)\n\ngoal (2 subgoals):\n 1. \\<exists>q. f = g * q + r\n 2. r = 0 \\<or> degree r < degree g", "from r_def[unfolded pseudo_mod_def]"], ["proof (chain)\npicking this:\n  r \\<equiv> snd (pseudo_divmod f g)", "obtain q where pdm: \"pseudo_divmod f g = (q, r)\""], ["proof (prove)\nusing this:\n  r \\<equiv> snd (pseudo_divmod f g)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        pseudo_divmod f g = (q, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"pseudo_divmod f g\") auto"], ["proof (state)\nthis:\n  pseudo_divmod f g = (q, r)\n\ngoal (2 subgoals):\n 1. \\<exists>q. f = g * q + r\n 2. r = 0 \\<or> degree r < degree g", "have g: \"g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "using monic_g"], ["proof (prove)\nusing this:\n  monic g\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<exists>q. f = g * q + r\n 2. r = 0 \\<or> degree r < degree g", "from pseudo_divmod[OF g pdm]"], ["proof (chain)\npicking this:\n  smult (lead_coeff g ^ (Suc (degree f) - degree g)) f = g * q + r\n  r = 0 \\<or> degree r < degree g", "have id: \"smult a f = g * q + r\" and \"r = 0 \\<or> degree r < degree g\""], ["proof (prove)\nusing this:\n  smult (lead_coeff g ^ (Suc (degree f) - degree g)) f = g * q + r\n  r = 0 \\<or> degree r < degree g\n\ngoal (1 subgoal):\n 1. smult a f = g * q + r &&& r = 0 \\<or> degree r < degree g", "by (auto simp: a_def)"], ["proof (state)\nthis:\n  smult a f = g * q + r\n  r = 0 \\<or> degree r < degree g\n\ngoal (2 subgoals):\n 1. \\<exists>q. f = g * q + r\n 2. r = 0 \\<or> degree r < degree g", "have a1: \"a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = (1::'a)", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff g ^ (Suc (degree f) - degree g) = (1::'a)", "using monic_g"], ["proof (prove)\nusing this:\n  monic g\n\ngoal (1 subgoal):\n 1. lead_coeff g ^ (Suc (degree f) - degree g) = (1::'a)", "by auto"], ["proof (state)\nthis:\n  a = (1::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>q. f = g * q + r\n 2. r = 0 \\<or> degree r < degree g", "hence id2: \"f = g * q + r\""], ["proof (prove)\nusing this:\n  a = (1::'a)\n\ngoal (1 subgoal):\n 1. f = g * q + r", "using id"], ["proof (prove)\nusing this:\n  a = (1::'a)\n  smult a f = g * q + r\n\ngoal (1 subgoal):\n 1. f = g * q + r", "by auto"], ["proof (state)\nthis:\n  f = g * q + r\n\ngoal (2 subgoals):\n 1. \\<exists>q. f = g * q + r\n 2. r = 0 \\<or> degree r < degree g", "show \"r = 0 \\<or> degree r < degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = 0 \\<or> degree r < degree g", "by fact"], ["proof (state)\nthis:\n  r = 0 \\<or> degree r < degree g\n\ngoal (1 subgoal):\n 1. \\<exists>q. f = g * q + r", "from g"], ["proof (chain)\npicking this:\n  g \\<noteq> 0", "have \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a)", "by (auto simp: a_def)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>q. f = g * q + r", "with id2"], ["proof (chain)\npicking this:\n  f = g * q + r\n  a \\<noteq> (0::'a)", "show \"\\<exists>q. f = g * q + r\""], ["proof (prove)\nusing this:\n  f = g * q + r\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>q. f = g * q + r", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. f = g * q + r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_imp_div_mod_int_poly_degree: \n  fixes p :: \"'a::{comm_ring_1,semiring_1_no_zero_divisors} poly\"\n  assumes m: \"monic u\"\n  shows \"\\<exists>q r. p = q*u + r \\<and> (r = 0 \\<or> degree r < degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q * u + r \\<and> (r = 0 \\<or> degree r < degree u)", "using pseudo_mod_monic[OF m]"], ["proof (prove)\nusing this:\n  \\<exists>q. ?f = u * q + pseudo_mod ?f u\n  pseudo_mod ?f u = 0 \\<or> degree (pseudo_mod ?f u) < degree u\n\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q * u + r \\<and> (r = 0 \\<or> degree r < degree u)", "using mult.commute"], ["proof (prove)\nusing this:\n  \\<exists>q. ?f = u * q + pseudo_mod ?f u\n  pseudo_mod ?f u = 0 \\<or> degree (pseudo_mod ?f u) < degree u\n  ?a * ?b = ?b * ?a\n\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q * u + r \\<and> (r = 0 \\<or> degree r < degree u)", "by metis"], ["", "corollary monic_imp_div_mod_int_poly_degree2: \n  fixes p :: \"'a::{comm_ring_1,semiring_1_no_zero_divisors} poly\"\n  assumes m: \"monic u\" and deg_u: \"degree u > 0\"\n  shows \"\\<exists>q r. p = q*u + r \\<and> (degree r < degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q * u + r \\<and> degree r < degree u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q * u + r \\<and> degree r < degree u", "obtain q r where \"p = q * u + r\" and r: \"(r = 0 \\<or> degree r < degree u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q * u + r; r = 0 \\<or> degree r < degree u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using monic_imp_div_mod_int_poly_degree[OF m, of p]"], ["proof (prove)\nusing this:\n  \\<exists>q r. p = q * u + r \\<and> (r = 0 \\<or> degree r < degree u)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q * u + r; r = 0 \\<or> degree r < degree u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = q * u + r\n  r = 0 \\<or> degree r < degree u\n\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q * u + r \\<and> degree r < degree u", "moreover"], ["proof (state)\nthis:\n  p = q * u + r\n  r = 0 \\<or> degree r < degree u\n\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q * u + r \\<and> degree r < degree u", "have \"degree r < degree u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree r < degree u", "using deg_u r"], ["proof (prove)\nusing this:\n  0 < degree u\n  r = 0 \\<or> degree r < degree u\n\ngoal (1 subgoal):\n 1. degree r < degree u", "by auto"], ["proof (state)\nthis:\n  degree r < degree u\n\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q * u + r \\<and> degree r < degree u", "ultimately"], ["proof (chain)\npicking this:\n  p = q * u + r\n  r = 0 \\<or> degree r < degree u\n  degree r < degree u", "show ?thesis"], ["proof (prove)\nusing this:\n  p = q * u + r\n  r = 0 \\<or> degree r < degree u\n  degree r < degree u\n\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q * u + r \\<and> degree r < degree u", "by auto"], ["proof (state)\nthis:\n  \\<exists>q r. p = q * u + r \\<and> degree r < degree u\n\ngoal:\nNo subgoals!", "qed"], ["", "(**** End of the lemmas that could be moved to Computational_Algebra/Polynomial.thy ****)\n\n\n(* To be categorized *)"], ["", "lemma (in zero_hom) hom_upper_triangular:\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> upper_triangular A \\<Longrightarrow> upper_triangular (map_mat hom A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n n; upper_triangular A\\<rbrakk>\n    \\<Longrightarrow> upper_triangular (map_mat hom A)", "by (auto simp: upper_triangular_def)"], ["", "end"]]}