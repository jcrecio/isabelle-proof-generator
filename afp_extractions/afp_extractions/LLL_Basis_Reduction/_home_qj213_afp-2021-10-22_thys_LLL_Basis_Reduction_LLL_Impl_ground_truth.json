{"file_name": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction/LLL_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LLL_Basis_Reduction", "problem_names": ["lemma round_num_denom: \"round_num_denom num denom = \n  round (of_int num / rat_of_int denom)\"", "lemma round_num_denom_d\\<mu>_d:\n  assumes j: \"j \\<le> i\" and i: \"i < m\"  \nshows \"round_num_denom (d\\<mu> i j) (d fs (Suc j)) = round (gs.\\<mu> i j)\"", "lemma d_sq_norm_comparison:\n  assumes quot: \"quotient_of \\<alpha> = (num,denom)\" \n  and i: \"i < m\" \n  and i0: \"i \\<noteq> 0\" \n  shows \"(d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i))\n   = (sq_norm (gs.gso (i - 1)) \\<le> \\<alpha> * sq_norm (gs.gso i))\"", "lemma d_d\\<mu>_add_row: assumes Linv: \"LLL_invariant_weak fs\"\n  and i: \"i < m\"  and j: \"j < i\" \n  and fs': \"fs' = fs[ i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]\" \nshows  \n  (* d-updates: none *)\n  \"\\<And> ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii\" \n  (* d\\<mu>-updates: *)\n  \"\\<And> i' j'. i' < m \\<Longrightarrow> j' < i' \\<Longrightarrow>       \n     d\\<mu> fs' i' j' = (\n       if i' = i \\<and> j' < j \n         then d\\<mu> fs i' j' - c * d\\<mu> fs j j' \n       else if i' = i \\<and> j' = j \n         then d\\<mu> fs i' j' - c * d fs (Suc j) \n       else d\\<mu> fs i' j')\"\n    (is \"\\<And> i' j'. _ \\<Longrightarrow> _ \\<Longrightarrow> _ = ?new_mu i' j'\")", "lemma d_d\\<mu>_swap: assumes invw: \"LLL_invariant_weak fs\"\n  and small: \"LLL_invariant False k fs \\<or> abs (\\<mu> fs k (k - 1)) \\<le> 1/2\" \n  and k: \"k < m\"\n  and k0: \"k \\<noteq> 0\" \n  and norm_ineq: \"sq_norm (gso fs (k - 1)) > \\<alpha> * sq_norm (gso fs k)\" \n  and fs'_def: \"fs' = fs[k := fs ! (k - 1), k - 1 := fs ! k]\" \nshows (* d-updates *)\n  \"\\<And> i. i \\<le> m \\<Longrightarrow>\n      d fs' i = (\n        if i = k then \n          (d fs (Suc k) * d fs (k - 1) + d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div d fs k \n        else d fs i)\"\nand (* d\\<mu>-updates *)\n  \"\\<And> i j. i < m \\<Longrightarrow> j < i \\<Longrightarrow> \n      d\\<mu> fs' i j = (\n        if i = k - 1 then \n           d\\<mu> fs k j\n        else if i = k \\<and> j \\<noteq> k - 1 then \n             d\\<mu> fs (k - 1) j\n        else if i > k \\<and> j = k then\n           (d fs (Suc k) * d\\<mu> fs i (k - 1) - d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div d fs k\n        else if i > k \\<and> j = k - 1 then \n           (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) div d fs k\n        else d\\<mu> fs i j)\" \n    (is \"\\<And> i j. _ \\<Longrightarrow> _ \\<Longrightarrow> _ = ?new_mu i j\")", "lemma basis_reduction_add_rows_loop_code:\n  \"basis_reduction_add_rows_loop n state i sj (fj # fjs) = (\n     case state of ((f1,f2),mus,ds) \\<Rightarrow>\n     let fi = hd f2;\n         j = sj - 1;\n         dsj = ds !! sj;\n         mui = mus !! i;\n         c = round_num_denom (mui !! j) dsj\n      in (if c = 0 then\n          basis_reduction_add_rows_loop n state i j fjs\n         else\n             let muj = mus !! j in\n           basis_reduction_add_rows_loop n\n                ((f1,  vec n (\\<lambda> i. fi $ i - c * fj $ i) # tl f2), iarray_update mus i\n             (IArray.of_fun (\\<lambda> jj. let mu = mui !! jj in\n                  if jj < j then mu - c * muj !! jj else\n                  if jj = j then mu - dsj * c else mu) i),\n                  ds) i j fjs))\"", "lemmas basis_reduction_add_rows_loop_code_equations =\n  basis_reduction_add_rows_loop.simps(1) basis_reduction_add_rows_loop_code", "lemma basis_reduction_swap_code[code]:\n  \"basis_reduction_swap i ((f1,f2), dmus, ds) = (let\n       di = ds !! i;\n       dsi = ds !! (Suc i);\n       im1 = i - 1;\n       dim1 = ds !! im1;\n       fi = hd f2;\n       fim1 = hd f1;\n       dmu_i_im1 = dmus !! i !! im1;\n       fi' = fim1;\n       fim1' = fi\n     in (False, im1,\n           ((tl f1,fim1' # fi' # tl f2),\n            swap_mu dmus i dmu_i_im1 dim1 di dsi,\n            iarray_update ds i ((dsi * dim1 + dmu_i_im1 * dmu_i_im1) div di))))\"", "lemma map_rev_Suc: \"map f (rev [0..<Suc j]) = f j # map f (rev [0..< j])\"", "lemma to_list_repr: \"list_repr i f (map ((!) fs) [0..<m])\"", "lemma to_mu_repr: \"mu_repr mu fs\"", "lemma to_d_repr: \"d_repr ds fs\"", "lemma dmu_ij_state: assumes j: \"j < ii\"\n  and ii: \"ii < m\"\nshows \"dmu_ij_state state ii j = d\\<mu> fs ii j\"", "lemma fi_state: \"i < m \\<Longrightarrow> fi_state state = fs ! i\"", "lemma fim1_state: \"i < m \\<Longrightarrow> i \\<noteq> 0 \\<Longrightarrow> fim1_state state = fs ! (i - 1)\"", "lemma d_state: \"ii \\<le> m \\<Longrightarrow> d_state state ii = d fs ii\"", "lemma fs_state: \"length fs = m \\<Longrightarrow> fs_state state = fs\"", "lemma LLL_state_inc_state: assumes i: \"i < m\"\nshows \"LLL_impl_inv (inc_state state) (Suc i) fs\"\n  \"fs_state (inc_state state) = fs_state state\"", "lemma basis_reduction_add_rows_loop_impl: assumes\n    impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant True i fs\"\n  and mu_small: \"\\<mu>_small_row i fs j\"\n  and res: \"LLL_Impl.basis_reduction_add_rows_loop n state i j\n    (map ((!) fs) (rev [0 ..< j])) = state'\"\n    (is \"LLL_Impl.basis_reduction_add_rows_loop n state i j (?mapf fs j) = _\")\n  and j: \"j \\<le> i\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i fs'\"\n  \"basis_reduction_add_rows_loop i fs j = fs'\"", "lemma basis_reduction_add_rows_loop: assumes\n    impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant True i fs\"\n  and mu_small: \"\\<mu>_small_row i fs j\"\n  and res: \"LLL_Impl.basis_reduction_add_rows_loop n state i j\n    (map ((!) fs) (rev [0 ..< j])) = state'\"\n    (is \"LLL_Impl.basis_reduction_add_rows_loop n state i j (?mapf fs j) = _\")\n  and j: \"j \\<le> i\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i fs'\"\n  \"LLL_invariant False i fs'\"\n  \"LLL_measure i fs' = LLL_measure i fs\"\n  \"basis_reduction_add_rows_loop i fs j = fs'\"", "lemma basis_reduction_add_rows_impl: assumes\n     impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_add_rows n upw i state = state'\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i fs'\"\n  \"basis_reduction_add_rows upw i fs = fs'\"", "lemma basis_reduction_add_rows: assumes\n     impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_add_rows n upw i state = state'\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i fs'\"\n  \"LLL_invariant False i fs'\"\n  \"LLL_measure i fs' = LLL_measure i fs\"\n  \"basis_reduction_add_rows upw i fs = fs'\"", "lemma basis_reduction_swap_impl: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant False i fs\"\n  and res: \"LLL_Impl.basis_reduction_swap m i state = (upw',i',state')\"\n  and cond: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\"\n  and i: \"i < m\" and i0: \"i \\<noteq> 0\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i' fs'\" (is ?g1)\n  \"basis_reduction_swap i fs = (upw',i',fs')\" (is ?g2)", "lemma basis_reduction_swap: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant False i fs\"\n  and res: \"LLL_Impl.basis_reduction_swap m i state = (upw',i',state')\"\n  and cond: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\"\n  and i: \"i < m\" and i0: \"i \\<noteq> 0\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i' fs'\" \n  \"LLL_invariant upw' i' fs'\" \n  \"LLL_measure i' fs' < LLL_measure i fs\"\n  \"basis_reduction_swap i fs = (upw',i',fs')\"", "lemma basis_reduction_step_impl: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_step \\<alpha> n m upw i state = (upw',i',state')\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i' fs'\"\n  \"basis_reduction_step upw i fs = (upw',i',fs')\"", "lemma basis_reduction_step: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_step \\<alpha> n m upw i state = (upw',i',state')\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i' fs'\"\n  \"LLL_invariant upw' i' fs'\"\n  \"LLL_measure i' fs' < LLL_measure i fs\"\n  \"basis_reduction_step upw i fs = (upw',i',fs')\"", "lemma basis_reduction_main_impl: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_main \\<alpha> n m upw i state = state'\"\n  and fs': \"fs' = fs_state state'\"\nshows \"LLL_impl_inv state' m fs'\"\n  \"basis_reduction_main (upw,i,fs) = fs'\"", "lemma basis_reduction_main: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_main \\<alpha> n m upw i state = state'\"\n  and fs': \"fs' = fs_state state'\"\nshows \n  \"LLL_invariant True m fs'\"\n  \"LLL_impl_inv state' m fs'\"\n  \"basis_reduction_main (upw,i,fs) = fs'\"", "lemma initial_state: \"LLL_impl_inv (initial_state m fs_init) 0 fs_init\" (is ?g1)\n  \"fs_state (initial_state m fs_init) = fs_init\" (is ?g2)", "lemma basis_reduction: assumes res: \"basis_reduction \\<alpha> n fs_init = state\"\n  and fs: \"fs = fs_state state\"\nshows \"LLL_invariant True m fs\"\n  \"LLL_impl_inv state m fs\"\n  \"basis_reduction_main (True, 0, fs_init) = fs\"", "lemma reduce_basis_impl: \"LLL_Impl.reduce_basis \\<alpha> fs_init = reduce_basis\"", "lemma reduce_basis: assumes \"LLL_Impl.reduce_basis \\<alpha> fs_init = fs\"\n  shows \"lattice_of fs = L\" \n  \"reduced fs m\" \n  \"lin_indep fs\" \n  \"length fs = m\" \n  \"LLL_invariant True m fs\"", "lemma short_vector_impl: \"LLL_Impl.short_vector \\<alpha> fs_init = short_vector\"", "lemma short_vector: assumes res: \"LLL_Impl.short_vector \\<alpha> fs_init = v\"\n  and m0: \"m \\<noteq> 0\"\nshows \n  \"v \\<in> carrier_vec n\"\n  \"v \\<in> L - {0\\<^sub>v n}\"\n  \"h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow> rat_of_int (sq_norm v) \\<le> \\<alpha> ^ (m - 1) * rat_of_int (sq_norm h)\"\n  \"v \\<noteq> 0\\<^sub>v j\""], "translations": [["", "lemma round_num_denom: \"round_num_denom num denom = \n  round (of_int num / rat_of_int denom)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_num_denom num denom = round (rat_of_int num / rat_of_int denom)", "proof (cases \"denom = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. denom = 0 \\<Longrightarrow>\n    round_num_denom num denom = round (rat_of_int num / rat_of_int denom)\n 2. denom \\<noteq> 0 \\<Longrightarrow>\n    round_num_denom num denom = round (rat_of_int num / rat_of_int denom)", "case False"], ["proof (state)\nthis:\n  denom \\<noteq> 0\n\ngoal (2 subgoals):\n 1. denom = 0 \\<Longrightarrow>\n    round_num_denom num denom = round (rat_of_int num / rat_of_int denom)\n 2. denom \\<noteq> 0 \\<Longrightarrow>\n    round_num_denom num denom = round (rat_of_int num / rat_of_int denom)", "have \"denom \\<noteq> 0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. denom \\<noteq> 0 \\<Longrightarrow>\n    round_num_denom num denom = round (rat_of_int num / rat_of_int denom)", "unfolding round_def round_num_denom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. denom \\<noteq> 0 \\<Longrightarrow>\n    (2 * num + denom) div (2 * denom) =\n    \\<lfloor>rat_of_int num / rat_of_int denom + 1 / 2\\<rfloor>", "unfolding floor_divide_of_int_eq[where ?'a = rat, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. denom \\<noteq> 0 \\<Longrightarrow>\n    \\<lfloor>rat_of_int (2 * num + denom) /\n             rat_of_int (2 * denom)\\<rfloor> =\n    \\<lfloor>rat_of_int num / rat_of_int denom + 1 / 2\\<rfloor>", "by (rule arg_cong[of _ _ floor], simp add: add_divide_distrib)"], ["proof (state)\nthis:\n  denom \\<noteq> 0 \\<Longrightarrow>\n  round_num_denom num denom = round (rat_of_int num / rat_of_int denom)\n\ngoal (2 subgoals):\n 1. denom = 0 \\<Longrightarrow>\n    round_num_denom num denom = round (rat_of_int num / rat_of_int denom)\n 2. denom \\<noteq> 0 \\<Longrightarrow>\n    round_num_denom num denom = round (rat_of_int num / rat_of_int denom)", "with False"], ["proof (chain)\npicking this:\n  denom \\<noteq> 0\n  denom \\<noteq> 0 \\<Longrightarrow>\n  round_num_denom num denom = round (rat_of_int num / rat_of_int denom)", "show ?thesis"], ["proof (prove)\nusing this:\n  denom \\<noteq> 0\n  denom \\<noteq> 0 \\<Longrightarrow>\n  round_num_denom num denom = round (rat_of_int num / rat_of_int denom)\n\ngoal (1 subgoal):\n 1. round_num_denom num denom = round (rat_of_int num / rat_of_int denom)", "by auto"], ["proof (state)\nthis:\n  round_num_denom num denom = round (rat_of_int num / rat_of_int denom)\n\ngoal (1 subgoal):\n 1. denom = 0 \\<Longrightarrow>\n    round_num_denom num denom = round (rat_of_int num / rat_of_int denom)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. denom = 0 \\<Longrightarrow>\n    round_num_denom num denom = round (rat_of_int num / rat_of_int denom)", "case True"], ["proof (state)\nthis:\n  denom = 0\n\ngoal (1 subgoal):\n 1. denom = 0 \\<Longrightarrow>\n    round_num_denom num denom = round (rat_of_int num / rat_of_int denom)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. round_num_denom num denom = round (rat_of_int num / rat_of_int denom)", "unfolding True round_num_denom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * num + 0) div (2 * 0) = round (rat_of_int num / rat_of_int 0)", "by auto"], ["proof (state)\nthis:\n  round_num_denom num denom = round (rat_of_int num / rat_of_int denom)\n\ngoal:\nNo subgoals!", "qed"], ["", "context fs_int_indpt\nbegin"], ["", "lemma round_num_denom_d\\<mu>_d:\n  assumes j: \"j \\<le> i\" and i: \"i < m\"  \nshows \"round_num_denom (d\\<mu> i j) (d fs (Suc j)) = round (gs.\\<mu> i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_num_denom (d\\<mu> i j) (d fs (Suc j)) = round (gs.\\<mu> i j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. round_num_denom (d\\<mu> i j) (d fs (Suc j)) = round (gs.\\<mu> i j)", "from j i"], ["proof (chain)\npicking this:\n  j \\<le> i\n  i < length fs", "have sj: \"Suc j \\<le> m\""], ["proof (prove)\nusing this:\n  j \\<le> i\n  i < length fs\n\ngoal (1 subgoal):\n 1. Suc j \\<le> length fs", "by auto"], ["proof (state)\nthis:\n  Suc j \\<le> length fs\n\ngoal (1 subgoal):\n 1. round_num_denom (d\\<mu> i j) (d fs (Suc j)) = round (gs.\\<mu> i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. round_num_denom (d\\<mu> i j) (d fs (Suc j)) = round (gs.\\<mu> i j)", "unfolding round_num_denom"], ["proof (prove)\ngoal (1 subgoal):\n 1. round (rat_of_int (d\\<mu> i j) / rat_of_int (d fs (Suc j))) =\n    round (gs.\\<mu> i j)", "by (rule arg_cong[of _ _ round], subst d\\<mu>[OF _ i], insert j i fs_int_d_pos[OF sj], auto)"], ["proof (state)\nthis:\n  round_num_denom (d\\<mu> i j) (d fs (Suc j)) = round (gs.\\<mu> i j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_sq_norm_comparison:\n  assumes quot: \"quotient_of \\<alpha> = (num,denom)\" \n  and i: \"i < m\" \n  and i0: \"i \\<noteq> 0\" \n  shows \"(d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i))\n   = (sq_norm (gs.gso (i - 1)) \\<le> \\<alpha> * sq_norm (gs.gso i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "let ?x = \"sq_norm (gs.gso (i - 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "let ?y = \"\\<alpha> * sq_norm (gs.gso i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "from i"], ["proof (chain)\npicking this:\n  i < length fs", "have le: \"i - 1 \\<le> m\" \" i \\<le> m\" \"Suc i \\<le> m\""], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. i - 1 \\<le> length fs &&& i \\<le> length fs &&& Suc i \\<le> length fs", "by auto"], ["proof (state)\nthis:\n  i - 1 \\<le> length fs\n  i \\<le> length fs\n  Suc i \\<le> length fs\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "note pos = fs_int_d_pos[OF le(1)] fs_int_d_pos[OF le(2)] quotient_of_denom_pos[OF quot]"], ["proof (state)\nthis:\n  0 < d fs (i - 1)\n  0 < d fs i\n  0 < denom\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "have \"(d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i))\n    = (?r (d fs i * d fs i * denom) \\<le> ?r (num * d fs (i - 1) * d fs (Suc i)))\" (is \"?cond = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (rat_of_int (d fs i * d fs i * denom)\n     \\<le> rat_of_int (num * d fs (i - 1) * d fs (Suc i)))", "by presburger"], ["proof (state)\nthis:\n  (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n  (rat_of_int (d fs i * d fs i * denom)\n   \\<le> rat_of_int (num * d fs (i - 1) * d fs (Suc i)))\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "also"], ["proof (state)\nthis:\n  (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n  (rat_of_int (d fs i * d fs i * denom)\n   \\<le> rat_of_int (num * d fs (i - 1) * d fs (Suc i)))\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "have \"\\<dots> = (?r (d fs i) * ?r (d fs i) * ?r denom \\<le> ?r num * ?r (d fs (i - 1)) * ?r (d fs (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (d fs i * d fs i * denom)\n     \\<le> rat_of_int (num * d fs (i - 1) * d fs (Suc i))) =\n    (rat_of_int (d fs i) * rat_of_int (d fs i) * rat_of_int denom\n     \\<le> rat_of_int num * rat_of_int (d fs (i - 1)) *\n           rat_of_int (d fs (Suc i)))", "by simp"], ["proof (state)\nthis:\n  (rat_of_int (d fs i * d fs i * denom)\n   \\<le> rat_of_int (num * d fs (i - 1) * d fs (Suc i))) =\n  (rat_of_int (d fs i) * rat_of_int (d fs i) * rat_of_int denom\n   \\<le> rat_of_int num * rat_of_int (d fs (i - 1)) *\n         rat_of_int (d fs (Suc i)))\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "also"], ["proof (state)\nthis:\n  (rat_of_int (d fs i * d fs i * denom)\n   \\<le> rat_of_int (num * d fs (i - 1) * d fs (Suc i))) =\n  (rat_of_int (d fs i) * rat_of_int (d fs i) * rat_of_int denom\n   \\<le> rat_of_int num * rat_of_int (d fs (i - 1)) *\n         rat_of_int (d fs (Suc i)))\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "have \"\\<dots> = (?r (d fs i) * ?r (d fs i) \\<le> \\<alpha> * ?r (d fs (i - 1)) * ?r (d fs (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (d fs i) * rat_of_int (d fs i) * rat_of_int denom\n     \\<le> rat_of_int num * rat_of_int (d fs (i - 1)) *\n           rat_of_int (d fs (Suc i))) =\n    (rat_of_int (d fs i) * rat_of_int (d fs i)\n     \\<le> \\<alpha> * rat_of_int (d fs (i - 1)) * rat_of_int (d fs (Suc i)))", "using pos"], ["proof (prove)\nusing this:\n  0 < d fs (i - 1)\n  0 < d fs i\n  0 < denom\n\ngoal (1 subgoal):\n 1. (rat_of_int (d fs i) * rat_of_int (d fs i) * rat_of_int denom\n     \\<le> rat_of_int num * rat_of_int (d fs (i - 1)) *\n           rat_of_int (d fs (Suc i))) =\n    (rat_of_int (d fs i) * rat_of_int (d fs i)\n     \\<le> \\<alpha> * rat_of_int (d fs (i - 1)) * rat_of_int (d fs (Suc i)))", "unfolding quotient_of_div[OF quot]"], ["proof (prove)\nusing this:\n  0 < d fs (i - 1)\n  0 < d fs i\n  0 < denom\n\ngoal (1 subgoal):\n 1. (rat_of_int (d fs i) * rat_of_int (d fs i) * rat_of_int denom\n     \\<le> rat_of_int num * rat_of_int (d fs (i - 1)) *\n           rat_of_int (d fs (Suc i))) =\n    (rat_of_int (d fs i) * rat_of_int (d fs i)\n     \\<le> rat_of_int num / rat_of_int denom * rat_of_int (d fs (i - 1)) *\n           rat_of_int (d fs (Suc i)))", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (rat_of_int (d fs i) * rat_of_int (d fs i) * rat_of_int denom\n   \\<le> rat_of_int num * rat_of_int (d fs (i - 1)) *\n         rat_of_int (d fs (Suc i))) =\n  (rat_of_int (d fs i) * rat_of_int (d fs i)\n   \\<le> \\<alpha> * rat_of_int (d fs (i - 1)) * rat_of_int (d fs (Suc i)))\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "also"], ["proof (state)\nthis:\n  (rat_of_int (d fs i) * rat_of_int (d fs i) * rat_of_int denom\n   \\<le> rat_of_int num * rat_of_int (d fs (i - 1)) *\n         rat_of_int (d fs (Suc i))) =\n  (rat_of_int (d fs i) * rat_of_int (d fs i)\n   \\<le> \\<alpha> * rat_of_int (d fs (i - 1)) * rat_of_int (d fs (Suc i)))\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "have \"\\<dots> = (?r (d fs i) / ?r (d fs (i - 1)) \\<le> \\<alpha> * (?r (d fs (Suc i)) / ?r (d fs i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (d fs i) * rat_of_int (d fs i)\n     \\<le> \\<alpha> * rat_of_int (d fs (i - 1)) *\n           rat_of_int (d fs (Suc i))) =\n    (rat_of_int (d fs i) / rat_of_int (d fs (i - 1))\n     \\<le> \\<alpha> * (rat_of_int (d fs (Suc i)) / rat_of_int (d fs i)))", "using pos"], ["proof (prove)\nusing this:\n  0 < d fs (i - 1)\n  0 < d fs i\n  0 < denom\n\ngoal (1 subgoal):\n 1. (rat_of_int (d fs i) * rat_of_int (d fs i)\n     \\<le> \\<alpha> * rat_of_int (d fs (i - 1)) *\n           rat_of_int (d fs (Suc i))) =\n    (rat_of_int (d fs i) / rat_of_int (d fs (i - 1))\n     \\<le> \\<alpha> * (rat_of_int (d fs (Suc i)) / rat_of_int (d fs i)))", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (rat_of_int (d fs i) * rat_of_int (d fs i)\n   \\<le> \\<alpha> * rat_of_int (d fs (i - 1)) * rat_of_int (d fs (Suc i))) =\n  (rat_of_int (d fs i) / rat_of_int (d fs (i - 1))\n   \\<le> \\<alpha> * (rat_of_int (d fs (Suc i)) / rat_of_int (d fs i)))\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "also"], ["proof (state)\nthis:\n  (rat_of_int (d fs i) * rat_of_int (d fs i)\n   \\<le> \\<alpha> * rat_of_int (d fs (i - 1)) * rat_of_int (d fs (Suc i))) =\n  (rat_of_int (d fs i) / rat_of_int (d fs (i - 1))\n   \\<le> \\<alpha> * (rat_of_int (d fs (Suc i)) / rat_of_int (d fs i)))\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "have \"?r (d fs i) / ?r (d fs (i - 1)) = ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs i) / rat_of_int (d fs (i - 1)) =\n    \\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2", "using fs_int_d_Suc[of \"i - 1\"] pos i i0"], ["proof (prove)\nusing this:\n  i - 1 < length fs \\<Longrightarrow>\n  rat_of_int (d fs (Suc (i - 1))) =\n  \\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2 * rat_of_int (d fs (i - 1))\n  0 < d fs (i - 1)\n  0 < d fs i\n  0 < denom\n  i < length fs\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs i) / rat_of_int (d fs (i - 1)) =\n    \\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  rat_of_int (d fs i) / rat_of_int (d fs (i - 1)) =\n  \\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs i) / rat_of_int (d fs (i - 1)) =\n  \\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "have \"\\<alpha> * (?r (d fs (Suc i)) / ?r (d fs i)) = ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> * (rat_of_int (d fs (Suc i)) / rat_of_int (d fs i)) =\n    \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2", "using fs_int_d_Suc[OF i] pos i i0"], ["proof (prove)\nusing this:\n  rat_of_int (d fs (Suc i)) =\n  \\<parallel>gs.gso i\\<parallel>\\<^sup>2 * rat_of_int (d fs i)\n  0 < d fs (i - 1)\n  0 < d fs i\n  0 < denom\n  i < length fs\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<alpha> * (rat_of_int (d fs (Suc i)) / rat_of_int (d fs i)) =\n    \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  \\<alpha> * (rat_of_int (d fs (Suc i)) / rat_of_int (d fs i)) =\n  \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "finally"], ["proof (chain)\npicking this:\n  (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n  (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "show \"?cond = (?x \\<le> ?y)\""], ["proof (prove)\nusing this:\n  (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n  (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n    (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)", "."], ["proof (state)\nthis:\n  (d fs i * d fs i * denom \\<le> num * d fs (i - 1) * d fs (Suc i)) =\n  (\\<parallel>gs.gso (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> * \\<parallel>gs.gso i\\<parallel>\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context LLL\nbegin"], ["", "lemma d_d\\<mu>_add_row: assumes Linv: \"LLL_invariant_weak fs\"\n  and i: \"i < m\"  and j: \"j < i\" \n  and fs': \"fs' = fs[ i := fs ! i - c \\<cdot>\\<^sub>v fs ! j]\" \nshows  \n  (* d-updates: none *)\n  \"\\<And> ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii\" \n  (* d\\<mu>-updates: *)\n  \"\\<And> i' j'. i' < m \\<Longrightarrow> j' < i' \\<Longrightarrow>       \n     d\\<mu> fs' i' j' = (\n       if i' = i \\<and> j' < j \n         then d\\<mu> fs i' j' - c * d\\<mu> fs j j' \n       else if i' = i \\<and> j' = j \n         then d\\<mu> fs i' j' - c * d fs (Suc j) \n       else d\\<mu> fs i' j')\"\n    (is \"\\<And> i' j'. _ \\<Longrightarrow> _ \\<Longrightarrow> _ = ?new_mu i' j'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii) &&&\n    (\\<And>i' j'.\n        \\<lbrakk>i' < m; j' < i'\\<rbrakk>\n        \\<Longrightarrow> d\\<mu> fs' i' j' =\n                          (if i' = i \\<and> j' < j\n                           then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n                           else if i' = i \\<and> j' = j\n                                then d\\<mu> fs i' j' - c * d fs (Suc j)\n                                else d\\<mu> fs i' j'))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii\n 2. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < i'\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if i' = i \\<and> j' < j\n                          then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n                          else if i' = i \\<and> j' = j\n                               then d\\<mu> fs i' j' - c * d fs (Suc j)\n                               else d\\<mu> fs i' j')", "interpret fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by standard (use Linv in auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii\n 2. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < i'\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if i' = i \\<and> j' < j\n                          then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n                          else if i' = i \\<and> j' = j\n                               then d\\<mu> fs i' j' - c * d fs (Suc j)\n                               else d\\<mu> fs i' j')", "note add = basis_reduction_add_row_main[OF Linv i j fs']"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n  LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs'\n  \\<lbrakk>c = round (fs.gs.\\<mu> i j);\n   \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i fs' j\n  c = round (fs.gs.\\<mu> i j) \\<Longrightarrow>\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') i j\\<bar>\n  \\<le> 1 / 2\n  LLL_measure i fs' = LLL_measure i fs\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?i = fs.gs.gso ?i\n  \\<lbrakk>?i' < m; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') ?i'\n                     ?j' =\n                    (if ?i' = i \\<and> ?j' \\<le> j\n                     then fs.gs.\\<mu> i ?j' -\n                          rat_of_int c * fs.gs.\\<mu> j ?j'\n                     else fs.gs.\\<mu> ?i' ?j')\n  ?ii \\<le> m \\<Longrightarrow> d fs' ?ii = d fs ?ii\n\ngoal (2 subgoals):\n 1. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii\n 2. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < i'\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if i' = i \\<and> j' < j\n                          then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n                          else if i' = i \\<and> j' = j\n                               then d\\<mu> fs i' j' - c * d fs (Suc j)\n                               else d\\<mu> fs i' j')", "interpret fs': fs_int' n m fs_init fs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs'", "by standard (use add in auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii\n 2. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < i'\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if i' = i \\<and> j' < j\n                          then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n                          else if i' = i \\<and> j' = j\n                               then d\\<mu> fs i' j' - c * d fs (Suc j)\n                               else d\\<mu> fs i' j')", "show d: \"\\<And> ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ii. ii \\<le> m \\<Longrightarrow> d fs' ii = d fs ii", "by fact"], ["proof (state)\nthis:\n  ?ii1 \\<le> m \\<Longrightarrow> d fs' ?ii1 = d fs ?ii1\n\ngoal (1 subgoal):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < i'\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if i' = i \\<and> j' < j\n                          then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n                          else if i' = i \\<and> j' = j\n                               then d\\<mu> fs i' j' - c * d fs (Suc j)\n                               else d\\<mu> fs i' j')", "fix i' j'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < i'\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if i' = i \\<and> j' < j\n                          then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n                          else if i' = i \\<and> j' = j\n                               then d\\<mu> fs i' j' - c * d fs (Suc j)\n                               else d\\<mu> fs i' j')", "assume i': \"i' < m\" and j': \"j' < i'\""], ["proof (state)\nthis:\n  i' < m\n  j' < i'\n\ngoal (1 subgoal):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < i'\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if i' = i \\<and> j' < j\n                          then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n                          else if i' = i \\<and> j' = j\n                               then d\\<mu> fs i' j' - c * d fs (Suc j)\n                               else d\\<mu> fs i' j')", "hence j'm: \"j' < m\" and j'': \"j' \\<le> i'\""], ["proof (prove)\nusing this:\n  i' < m\n  j' < i'\n\ngoal (1 subgoal):\n 1. j' < m &&& j' \\<le> i'", "by auto"], ["proof (state)\nthis:\n  j' < m\n  j' \\<le> i'\n\ngoal (1 subgoal):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < i'\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if i' = i \\<and> j' < j\n                          then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n                          else if i' = i \\<and> j' = j\n                               then d\\<mu> fs i' j' - c * d fs (Suc j)\n                               else d\\<mu> fs i' j')", "note updates = add(7)[OF i' j'm]"], ["proof (state)\nthis:\n  fs'.gs.\\<mu> i' j' =\n  (if i' = i \\<and> j' \\<le> j\n   then fs.gs.\\<mu> i j' - rat_of_int c * fs.gs.\\<mu> j j'\n   else fs.gs.\\<mu> i' j')\n\ngoal (1 subgoal):\n 1. \\<And>i' j'.\n       \\<lbrakk>i' < m; j' < i'\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i' j' =\n                         (if i' = i \\<and> j' < j\n                          then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n                          else if i' = i \\<and> j' = j\n                               then d\\<mu> fs i' j' - c * d fs (Suc j)\n                               else d\\<mu> fs i' j')", "show \"d\\<mu> fs' i' j' = ?new_mu i' j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "proof (cases \"i' = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')\n 2. i' \\<noteq> i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "case False"], ["proof (state)\nthis:\n  i' \\<noteq> i\n\ngoal (2 subgoals):\n 1. i' = i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')\n 2. i' \\<noteq> i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "thus ?thesis"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "using d i' j'"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n  ?ii1 \\<le> m \\<Longrightarrow> d fs' ?ii1 = d fs ?ii1\n  i' < m\n  j' < i'\n\ngoal (1 subgoal):\n 1. d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "unfolding d\\<mu>_def updates"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n  ?ii1 \\<le> m \\<Longrightarrow> d fs' ?ii1 = d fs ?ii1\n  i' < m\n  j' < i'\n\ngoal (1 subgoal):\n 1. int_of_rat\n     (rat_of_int (d fs' (Suc j')) *\n      (if i' = i \\<and> j' \\<le> j\n       then fs.gs.\\<mu> i j' - rat_of_int c * fs.gs.\\<mu> j j'\n       else fs.gs.\\<mu> i' j')) =\n    (if i' = i \\<and> j' < j\n     then int_of_rat (rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> i' j') -\n          c * int_of_rat (rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> j j')\n     else if i' = i \\<and> j' = j\n          then int_of_rat (rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> i' j') -\n               c * d fs (Suc j)\n          else int_of_rat (rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> i' j'))", "by auto"], ["proof (state)\nthis:\n  d\\<mu> fs' i' j' =\n  (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n   else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n        else d\\<mu> fs i' j')\n\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "case True"], ["proof (state)\nthis:\n  i' = i\n\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "have id': \"d fs' (Suc j') = d fs (Suc j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d fs' (Suc j') = d fs (Suc j')", "by (rule d, insert i' j', auto)"], ["proof (state)\nthis:\n  d fs' (Suc j') = d fs (Suc j')\n\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "note fs'.d\\<mu>[]"], ["proof (state)\nthis:\n  \\<lbrakk>?j < length fs'; ?ii < length fs'\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (fs'.d\\<mu> ?ii ?j) =\n                    rat_of_int (fs'.d fs' (Suc ?j)) * fs'.gs.\\<mu> ?ii ?j\n\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "have *: \"rat_of_int (d\\<mu> fs' i' j') = rat_of_int (d fs' (Suc j')) * fs'.gs.\\<mu> i' j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d\\<mu> fs' i' j') =\n    rat_of_int (d fs' (Suc j')) * fs'.gs.\\<mu> i' j'", "unfolding d\\<mu>_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int\n     (int_of_rat\n       (rat_of_int (gs.Gramian_determinant fs' (Suc j')) *\n        fs'.gs.\\<mu> i' j')) =\n    rat_of_int (gs.Gramian_determinant fs' (Suc j')) * fs'.gs.\\<mu> i' j'", "apply(rule fs'.d\\<mu>[unfolded fs'.d\\<mu>_def fs'.d_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. j' < length fs'\n 2. i' < length fs'", "using j' i'  LLL_inv_wD[OF add(1)]"], ["proof (prove)\nusing this:\n  j' < i'\n  i' < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs'.gs.gso ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n\ngoal (2 subgoals):\n 1. j' < length fs'\n 2. i' < length fs'", "by (auto)"], ["proof (state)\nthis:\n  rat_of_int (d\\<mu> fs' i' j') =\n  rat_of_int (d fs' (Suc j')) * fs'.gs.\\<mu> i' j'\n\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "have **: \"rat_of_int (d\\<mu> fs i' j') = rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> i' j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d\\<mu> fs i' j') =\n    rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> i' j'", "unfolding d\\<mu>_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int\n     (int_of_rat\n       (rat_of_int (gs.Gramian_determinant fs (Suc j')) *\n        fs.gs.\\<mu> i' j')) =\n    rat_of_int (gs.Gramian_determinant fs (Suc j')) * fs.gs.\\<mu> i' j'", "apply(rule fs.d\\<mu>[unfolded fs.d\\<mu>_def fs.d_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. j' < length fs\n 2. i' < length fs", "using j' i' LLL_inv_wD[OF Linv]"], ["proof (prove)\nusing this:\n  j' < i'\n  i' < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (2 subgoals):\n 1. j' < length fs\n 2. i' < length fs", "by (auto)"], ["proof (state)\nthis:\n  rat_of_int (d\\<mu> fs i' j') =\n  rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> i' j'\n\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "have ***: \"rat_of_int (d\\<mu> fs j j') = rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> j j'\" if \"j' < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d\\<mu> fs j j') =\n    rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> j j'", "unfolding d\\<mu>_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int\n     (int_of_rat\n       (rat_of_int (gs.Gramian_determinant fs (Suc j')) *\n        fs.gs.\\<mu> j j')) =\n    rat_of_int (gs.Gramian_determinant fs (Suc j')) * fs.gs.\\<mu> j j'", "apply(rule fs.d\\<mu>[unfolded fs.d\\<mu>_def fs.d_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. j' < length fs\n 2. j < length fs", "using that j i LLL_inv_wD[OF Linv]"], ["proof (prove)\nusing this:\n  j' < j\n  j < i\n  i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (2 subgoals):\n 1. j' < length fs\n 2. j < length fs", "by (auto)"], ["proof (state)\nthis:\n  j' < j \\<Longrightarrow>\n  rat_of_int (d\\<mu> fs j j') =\n  rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> j j'\n\ngoal (1 subgoal):\n 1. i' = i \\<Longrightarrow>\n    d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs' i' j' =\n    (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n     else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n          else d\\<mu> fs i' j')", "apply(intro int_via_rat_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d\\<mu> fs' i' j') =\n    rat_of_int\n     (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n      else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n           else d\\<mu> fs i' j')", "apply(unfold if_distrib[of rat_of_int] of_int_diff of_int_mult ** * updates id' ring_distribs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc j')) *\n    (if i' = i \\<and> j' \\<le> j\n     then fs.gs.\\<mu> i j' - rat_of_int c * fs.gs.\\<mu> j j'\n     else fs.gs.\\<mu> i' j') =\n    (if i' = i \\<and> j' < j\n     then rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> i' j' -\n          rat_of_int c * rat_of_int (d\\<mu> fs j j')\n     else if i' = i \\<and> j' = j\n          then rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> i' j' -\n               rat_of_int c * rat_of_int (d fs (Suc j))\n          else rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> i' j')", "apply(insert True i' j' i j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i' = i; i' < m; j' < i'; i < m; j < i\\<rbrakk>\n    \\<Longrightarrow> rat_of_int (d fs (Suc j')) *\n                      (if i' = i \\<and> j' \\<le> j\n                       then fs.gs.\\<mu> i j' -\n                            rat_of_int c * fs.gs.\\<mu> j j'\n                       else fs.gs.\\<mu> i' j') =\n                      (if i' = i \\<and> j' < j\n                       then rat_of_int (d fs (Suc j')) * fs.gs.\\<mu> i' j' -\n                            rat_of_int c * rat_of_int (d\\<mu> fs j j')\n                       else if i' = i \\<and> j' = j\n                            then rat_of_int (d fs (Suc j')) *\n                                 fs.gs.\\<mu> i' j' -\n                                 rat_of_int c * rat_of_int (d fs (Suc j))\n                            else rat_of_int (d fs (Suc j')) *\n                                 fs.gs.\\<mu> i' j')", "by(auto simp: fs.gs.\\<mu>.simps algebra_simps ***)"], ["proof (state)\nthis:\n  d\\<mu> fs' i' j' =\n  (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n   else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n        else d\\<mu> fs i' j')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d\\<mu> fs' i' j' =\n  (if i' = i \\<and> j' < j then d\\<mu> fs i' j' - c * d\\<mu> fs j j'\n   else if i' = i \\<and> j' = j then d\\<mu> fs i' j' - c * d fs (Suc j)\n        else d\\<mu> fs i' j')\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context LLL_with_assms\nbegin"], ["", "lemma d_d\\<mu>_swap: assumes invw: \"LLL_invariant_weak fs\"\n  and small: \"LLL_invariant False k fs \\<or> abs (\\<mu> fs k (k - 1)) \\<le> 1/2\" \n  and k: \"k < m\"\n  and k0: \"k \\<noteq> 0\" \n  and norm_ineq: \"sq_norm (gso fs (k - 1)) > \\<alpha> * sq_norm (gso fs k)\" \n  and fs'_def: \"fs' = fs[k := fs ! (k - 1), k - 1 := fs ! k]\" \nshows (* d-updates *)\n  \"\\<And> i. i \\<le> m \\<Longrightarrow>\n      d fs' i = (\n        if i = k then \n          (d fs (Suc k) * d fs (k - 1) + d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div d fs k \n        else d fs i)\"\nand (* d\\<mu>-updates *)\n  \"\\<And> i j. i < m \\<Longrightarrow> j < i \\<Longrightarrow> \n      d\\<mu> fs' i j = (\n        if i = k - 1 then \n           d\\<mu> fs k j\n        else if i = k \\<and> j \\<noteq> k - 1 then \n             d\\<mu> fs (k - 1) j\n        else if i > k \\<and> j = k then\n           (d fs (Suc k) * d\\<mu> fs i (k - 1) - d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div d fs k\n        else if i > k \\<and> j = k - 1 then \n           (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) div d fs k\n        else d\\<mu> fs i j)\" \n    (is \"\\<And> i j. _ \\<Longrightarrow> _ \\<Longrightarrow> _ = ?new_mu i j\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<le> m \\<Longrightarrow>\n        d fs' i =\n        (if i = k\n         then (d fs (Suc k) * d fs (k - 1) +\n               d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n              d fs k\n         else d fs i)) &&&\n    (\\<And>i j.\n        \\<lbrakk>i < m; j < i\\<rbrakk>\n        \\<Longrightarrow> d\\<mu> fs' i j =\n                          (if i = k - 1 then d\\<mu> fs k j\n                           else if i = k \\<and> j \\<noteq> k - 1\n                                then d\\<mu> fs (k - 1) j\n                                else if k < i \\<and> j = k\n                                     then (d fs (Suc k) *\n     d\\<mu> fs i (k - 1) -\n     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n    d fs k\n                                     else if k < i \\<and> j = k - 1\n    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n          d\\<mu> fs i k * d fs (k - 1)) div\n         d fs k\n    else d\\<mu> fs i j))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note swap = basis_reduction_swap_main[OF invw small k k0 norm_ineq fs'_def]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n  LLL_invariant False k fs \\<Longrightarrow> LLL_invariant False (k - 1) fs'\n  LLL_measure (k - 1) fs' < LLL_measure k fs\n  ?k < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?k =\n  (if ?k = k - 1\n   then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) k\n         (k - 1) \\<cdot>\\<^sub>v\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (k - 1)\n   else if ?k = k\n        then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (k - 1) -\n             map of_int_hom.vec_hom fs ! (k - 1) \\<bullet>\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (k - 1) /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (k - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (k - 1)\n        else gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?k)\n  ?k < m \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n              ?k\\<parallel>\\<^sup>2 =\n  (if ?k = k - 1\n   then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    k\\<parallel>\\<^sup>2 +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) k (k - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) k (k - 1) *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    (k - 1)\\<parallel>\\<^sup>2\n   else if ?k = k\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         k\\<parallel>\\<^sup>2 *\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         (k - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (k - 1)\\<parallel>\\<^sup>2\n        else \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         ?k\\<parallel>\\<^sup>2)\n  \\<lbrakk>?ii < m; ?j < ?ii\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') ?ii\n                     ?j =\n                    (if ?ii = k - 1\n                     then gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) k ?j\n                     else if ?ii = k\n                          then if ?j = k - 1\n                               then gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) k (k - 1) *\n                                    \\<parallel>gram_schmidt_fs.gso n\n          (map of_int_hom.vec_hom fs) (k - 1)\\<parallel>\\<^sup>2 /\n                                    \\<parallel>gram_schmidt_fs.gso n\n          (map of_int_hom.vec_hom fs') (k - 1)\\<parallel>\\<^sup>2\n                               else gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) (k - 1) ?j\n                          else if k < ?ii \\<and> ?j = k\n                               then gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) ?ii\n                                     (k - 1) -\n                                    gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) k (k - 1) *\n                                    gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) ?ii k\n                               else if k < ?ii \\<and> ?j = k - 1\n                                    then gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ?ii (k - 1) *\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') k (k - 1) +\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ?ii k *\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               k\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (k - 1)\\<parallel>\\<^sup>2\n                                    else gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ?ii ?j)\n  ?ii \\<le> m \\<Longrightarrow>\n  rat_of_int (d fs' ?ii) =\n  (if ?ii = k\n   then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (k - 1)\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    (k - 1)\\<parallel>\\<^sup>2 *\n        rat_of_int (d fs k)\n   else rat_of_int (d fs ?ii))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note invw2 = swap(1)"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note swap = swap(1,3-)"], ["proof (state)\nthis:\n  LLL_invariant_weak fs'\n  LLL_measure (k - 1) fs' < LLL_measure k fs\n  ?k < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') ?k =\n  (if ?k = k - 1\n   then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) k +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) k\n         (k - 1) \\<cdot>\\<^sub>v\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (k - 1)\n   else if ?k = k\n        then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (k - 1) -\n             map of_int_hom.vec_hom fs ! (k - 1) \\<bullet>\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (k - 1) /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (k - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs') (k - 1)\n        else gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?k)\n  ?k < m \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n              ?k\\<parallel>\\<^sup>2 =\n  (if ?k = k - 1\n   then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    k\\<parallel>\\<^sup>2 +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) k (k - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) k (k - 1) *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    (k - 1)\\<parallel>\\<^sup>2\n   else if ?k = k\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         k\\<parallel>\\<^sup>2 *\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         (k - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                         (k - 1)\\<parallel>\\<^sup>2\n        else \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         ?k\\<parallel>\\<^sup>2)\n  \\<lbrakk>?ii < m; ?j < ?ii\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') ?ii\n                     ?j =\n                    (if ?ii = k - 1\n                     then gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) k ?j\n                     else if ?ii = k\n                          then if ?j = k - 1\n                               then gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) k (k - 1) *\n                                    \\<parallel>gram_schmidt_fs.gso n\n          (map of_int_hom.vec_hom fs) (k - 1)\\<parallel>\\<^sup>2 /\n                                    \\<parallel>gram_schmidt_fs.gso n\n          (map of_int_hom.vec_hom fs') (k - 1)\\<parallel>\\<^sup>2\n                               else gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) (k - 1) ?j\n                          else if k < ?ii \\<and> ?j = k\n                               then gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) ?ii\n                                     (k - 1) -\n                                    gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) k (k - 1) *\n                                    gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) ?ii k\n                               else if k < ?ii \\<and> ?j = k - 1\n                                    then gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ?ii (k - 1) *\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs') k (k - 1) +\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ?ii k *\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               k\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n               (k - 1)\\<parallel>\\<^sup>2\n                                    else gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ?ii ?j)\n  ?ii \\<le> m \\<Longrightarrow>\n  rat_of_int (d fs' ?ii) =\n  (if ?ii = k\n   then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                    (k - 1)\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    (k - 1)\\<parallel>\\<^sup>2 *\n        rat_of_int (d fs k)\n   else rat_of_int (d fs ?ii))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "from k k0"], ["proof (chain)\npicking this:\n  k < m\n  k \\<noteq> 0", "have kk: \"k - 1 < k\" and le_m: \"k - 1 \\<le> m\" \"k \\<le> m\" \"Suc k \\<le> m\""], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k - 1 < k &&& k - 1 \\<le> m &&& k \\<le> m &&& Suc k \\<le> m", "by auto"], ["proof (state)\nthis:\n  k - 1 < k\n  k - 1 \\<le> m\n  k \\<le> m\n  Suc k \\<le> m\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "from LLL_inv_wD[OF invw]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L", "have len: \"length fs = m\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. length fs = m", "by auto"], ["proof (state)\nthis:\n  length fs = m\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "interpret fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by standard (use invw in auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "interpret fs': fs_int' n m fs_init fs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs'", "by standard (use invw2 in auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "let ?r = rat_of_int"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "let ?n = \"\\<lambda> i. sq_norm (gso fs i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "let ?n' = \"\\<lambda> i. sq_norm (gso fs' i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "let ?dn = \"\\<lambda> i. ?r (d fs i * d fs i) * ?n i\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "let ?dn' = \"\\<lambda> i. ?r (d fs' i * d fs' i) * ?n' i\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "let ?dmu = \"\\<lambda> i j. ?r (d fs (Suc j)) * \\<mu> fs i j\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "let ?dmu' = \"\\<lambda> i j. ?r (d fs' (Suc j)) * \\<mu> fs' i j\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note dmu = fs.d\\<mu>"], ["proof (state)\nthis:\n  \\<lbrakk>?j < length fs; ?ii < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (fs.d\\<mu> ?ii ?j) =\n                    rat_of_int (fs'.d fs (Suc ?j)) * fs.gs.\\<mu> ?ii ?j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note dmu' = fs'.d\\<mu>"], ["proof (state)\nthis:\n  \\<lbrakk>?j < length fs'; ?ii < length fs'\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (fs'.d\\<mu> ?ii ?j) =\n                    rat_of_int (fs'.d fs' (Suc ?j)) * fs'.gs.\\<mu> ?ii ?j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note inv' = LLL_inv_wD[OF invw]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have nim1: \"?n k + square_rat (\\<mu> fs k (k - 1)) * ?n (k - 1) = \n    ?n' (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 +\n    square_rat (fs.gs.\\<mu> k (k - 1)) *\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2", "by (subst swap(4), insert k, auto)"], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 +\n  square_rat (fs.gs.\\<mu> k (k - 1)) *\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have ni: \"?n k * (?n (k - 1) / ?n' (k - 1)) = ?n' k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 *\n    (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n     \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n    \\<parallel>fs'.gs.gso k\\<parallel>\\<^sup>2", "by (subst swap(4)[of k], insert k k0, auto)"], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 *\n  (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n  \\<parallel>fs'.gs.gso k\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have mu': \"\\<mu> fs k (k - 1) * (?n (k - 1) / ?n' (k - 1)) = \\<mu> fs' k (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs.gs.\\<mu> k (k - 1) *\n    (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n     \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n    fs'.gs.\\<mu> k (k - 1)", "by (subst swap(5), insert k k0, auto)"], ["proof (state)\nthis:\n  fs.gs.\\<mu> k (k - 1) *\n  (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n  fs'.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have fi: \"fs ! (k - 1) = fs' ! k\" \"fs ! k = fs' ! (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! (k - 1) = fs' ! k &&& fs ! k = fs' ! (k - 1)", "unfolding fs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! (k - 1) = fs[k := fs ! (k - 1), k - 1 := fs ! k] ! k &&&\n    fs ! k = fs[k := fs ! (k - 1), k - 1 := fs ! k] ! (k - 1)", "using inv'(6) k k0"], ["proof (prove)\nusing this:\n  length fs = m\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fs ! (k - 1) = fs[k := fs ! (k - 1), k - 1 := fs ! k] ! k &&&\n    fs ! k = fs[k := fs ! (k - 1), k - 1 := fs ! k] ! (k - 1)", "by auto"], ["proof (state)\nthis:\n  fs ! (k - 1) = fs' ! k\n  fs ! k = fs' ! (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "let ?d'i = \"(d fs (Suc k) * d fs (k - 1) + d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div (d fs k)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have rat': \"i < m \\<Longrightarrow> j < i \\<Longrightarrow> ?r (d\\<mu> fs' i j) = ?dmu' i j\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < m; j < i\\<rbrakk>\n    \\<Longrightarrow> rat_of_int (d\\<mu> fs' i j) =\n                      rat_of_int (d fs' (Suc j)) * fs'.gs.\\<mu> i j", "using dmu'[of j i] LLL_inv_wD[OF invw2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length fs'; i < length fs'\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (fs'.d\\<mu> i j) =\n                    rat_of_int (fs'.d fs' (Suc j)) * fs'.gs.\\<mu> i j\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs'.gs.gso ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < m; j < i\\<rbrakk>\n    \\<Longrightarrow> rat_of_int (d\\<mu> fs' i j) =\n                      rat_of_int (d fs' (Suc j)) * fs'.gs.\\<mu> i j", "unfolding d\\<mu>_def fs'.d\\<mu>_def d_def fs'.d_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length fs'; i < length fs'\\<rbrakk>\n  \\<Longrightarrow> rat_of_int\n                     (int_of_rat\n                       (rat_of_int (gs.Gramian_determinant fs' (Suc j)) *\n                        fs'.gs.\\<mu> i j)) =\n                    rat_of_int (gs.Gramian_determinant fs' (Suc j)) *\n                    fs'.gs.\\<mu> i j\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs')\n  length (map of_int_hom.vec_hom fs') = m\n  set fs' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs'.gs.gso ?i \\<in> Rn\n  length fs' = m\n  lattice_of fs' = L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < m; j < i\\<rbrakk>\n    \\<Longrightarrow> rat_of_int\n                       (int_of_rat\n                         (rat_of_int (gs.Gramian_determinant fs' (Suc j)) *\n                          fs'.gs.\\<mu> i j)) =\n                      rat_of_int (gs.Gramian_determinant fs' (Suc j)) *\n                      fs'.gs.\\<mu> i j", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < m; ?j1 < ?i1\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (d\\<mu> fs' ?i1 ?j1) =\n                    rat_of_int (d fs' (Suc ?j1)) * fs'.gs.\\<mu> ?i1 ?j1\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have rat: \"i < m \\<Longrightarrow> j < i \\<Longrightarrow> ?r (d\\<mu> fs i j) = ?dmu i j\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < m; j < i\\<rbrakk>\n    \\<Longrightarrow> rat_of_int (d\\<mu> fs i j) =\n                      rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j", "using dmu[of j i] LLL_inv_wD[OF invw]"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length fs; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (fs.d\\<mu> i j) =\n                    rat_of_int (fs'.d fs (Suc j)) * fs.gs.\\<mu> i j\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < m; j < i\\<rbrakk>\n    \\<Longrightarrow> rat_of_int (d\\<mu> fs i j) =\n                      rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j", "unfolding d\\<mu>_def fs.d\\<mu>_def d_def fs.d_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length fs; i < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int\n                     (int_of_rat\n                       (rat_of_int (gs.Gramian_determinant fs (Suc j)) *\n                        fs.gs.\\<mu> i j)) =\n                    rat_of_int (gs.Gramian_determinant fs (Suc j)) *\n                    fs.gs.\\<mu> i j\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < m; j < i\\<rbrakk>\n    \\<Longrightarrow> rat_of_int\n                       (int_of_rat\n                         (rat_of_int (gs.Gramian_determinant fs (Suc j)) *\n                          fs.gs.\\<mu> i j)) =\n                      rat_of_int (gs.Gramian_determinant fs (Suc j)) *\n                      fs.gs.\\<mu> i j", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < m; ?j1 < ?i1\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (d\\<mu> fs ?i1 ?j1) =\n                    rat_of_int (d fs (Suc ?j1)) * fs.gs.\\<mu> ?i1 ?j1\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "from k k0"], ["proof (chain)\npicking this:\n  k < m\n  k \\<noteq> 0", "have sim1: \"Suc (k - 1) = k\" and km1: \"k - 1 < m\""], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Suc (k - 1) = k &&& k - 1 < m", "by auto"], ["proof (state)\nthis:\n  Suc (k - 1) = k\n  k - 1 < m\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "from LLL_d_Suc[OF invw km1, unfolded sim1]"], ["proof (chain)\npicking this:\n  rat_of_int (d fs k) =\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs (k - 1))", "have dn_km1: \"?dn (k - 1) = ?r (d fs k) * ?r (d fs (k - 1))\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs k) =\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs (k - 1))\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n    rat_of_int (d fs k) * rat_of_int (d fs (k - 1))", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n  rat_of_int (d fs k) * rat_of_int (d fs (k - 1))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note pos = Gramian_determinant[OF invw le_refl]"], ["proof (state)\nthis:\n  rat_of_int (gs.Gramian_determinant fs m) =\n  (\\<Prod>j<m. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2)\n  0 < gs.Gramian_determinant fs m\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "from pos(2)"], ["proof (chain)\npicking this:\n  0 < gs.Gramian_determinant fs m", "have \"?r (gs.Gramian_determinant fs m) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < gs.Gramian_determinant fs m\n\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs m) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  rat_of_int (gs.Gramian_determinant fs m) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "from this[unfolded pos(1)]"], ["proof (chain)\npicking this:\n  (\\<Prod>j<m. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) \\<noteq> 0", "have nzero: \"i < m \\<Longrightarrow> ?n i \\<noteq> 0\" for i"], ["proof (prove)\nusing this:\n  (\\<Prod>j<m. \\<parallel>fs.gs.gso j\\<parallel>\\<^sup>2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    \\<parallel>fs.gs.gso i\\<parallel>\\<^sup>2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ?i1 < m \\<Longrightarrow>\n  \\<parallel>fs.gs.gso ?i1\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note pos = Gramian_determinant[OF invw2 le_refl]"], ["proof (state)\nthis:\n  rat_of_int (gs.Gramian_determinant fs' m) =\n  (\\<Prod>j<m. \\<parallel>fs'.gs.gso j\\<parallel>\\<^sup>2)\n  0 < gs.Gramian_determinant fs' m\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "from pos(2)"], ["proof (chain)\npicking this:\n  0 < gs.Gramian_determinant fs' m", "have \"?r (gs.Gramian_determinant fs' m) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < gs.Gramian_determinant fs' m\n\ngoal (1 subgoal):\n 1. rat_of_int (gs.Gramian_determinant fs' m) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  rat_of_int (gs.Gramian_determinant fs' m) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "from this[unfolded pos(1)]"], ["proof (chain)\npicking this:\n  (\\<Prod>j<m. \\<parallel>fs'.gs.gso j\\<parallel>\\<^sup>2) \\<noteq> 0", "have nzero': \"i < m \\<Longrightarrow> ?n' i \\<noteq> 0\" for i"], ["proof (prove)\nusing this:\n  (\\<Prod>j<m. \\<parallel>fs'.gs.gso j\\<parallel>\\<^sup>2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow>\n    \\<parallel>fs'.gs.gso i\\<parallel>\\<^sup>2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ?i1 < m \\<Longrightarrow>\n  \\<parallel>fs'.gs.gso ?i1\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have dzero: \"i \\<le> m \\<Longrightarrow> d fs i \\<noteq> 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> m \\<Longrightarrow> d fs i \\<noteq> 0", "using LLL_d_pos[OF invw, of i]"], ["proof (prove)\nusing this:\n  i \\<le> m \\<Longrightarrow> 0 < d fs i\n\ngoal (1 subgoal):\n 1. i \\<le> m \\<Longrightarrow> d fs i \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ?i1 \\<le> m \\<Longrightarrow> d fs ?i1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have dzero': \"i \\<le> m \\<Longrightarrow> d fs' i \\<noteq> 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> m \\<Longrightarrow> d fs' i \\<noteq> 0", "using LLL_d_pos[OF invw2, of i]"], ["proof (prove)\nusing this:\n  i \\<le> m \\<Longrightarrow> 0 < d fs' i\n\ngoal (1 subgoal):\n 1. i \\<le> m \\<Longrightarrow> d fs' i \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ?i1 \\<le> m \\<Longrightarrow> d fs' ?i1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "{"], ["proof (state)\nthis:\n  ?i1 \\<le> m \\<Longrightarrow> d fs' ?i1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "define start where \"start = ?dmu' k (k - 1)\""], ["proof (state)\nthis:\n  start = rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"start = (?n' (k - 1) / ?n (k - 1) * ?r (d fs k)) * \\<mu> fs' k (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start =\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs k) *\n    fs'.gs.\\<mu> k (k - 1)", "using start_def swap(6)[of k] k k0"], ["proof (prove)\nusing this:\n  start = rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1)\n  k \\<le> m \\<Longrightarrow>\n  rat_of_int (d fs' k) =\n  (if k = k\n   then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n        \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n        rat_of_int (d fs k)\n   else rat_of_int (d fs k))\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. start =\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs k) *\n    fs'.gs.\\<mu> k (k - 1)", "by simp"], ["proof (state)\nthis:\n  start =\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs k) *\n  fs'.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  start =\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs k) *\n  fs'.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"\\<mu> fs' k (k - 1) = \\<mu> fs k (k - 1) * (?n (k - 1) / ?n' (k - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs'.gs.\\<mu> k (k - 1) =\n    fs.gs.\\<mu> k (k - 1) *\n    (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n     \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2)", "using mu'"], ["proof (prove)\nusing this:\n  fs.gs.\\<mu> k (k - 1) *\n  (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n  fs'.gs.\\<mu> k (k - 1)\n\ngoal (1 subgoal):\n 1. fs'.gs.\\<mu> k (k - 1) =\n    fs.gs.\\<mu> k (k - 1) *\n    (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n     \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  fs'.gs.\\<mu> k (k - 1) =\n  fs.gs.\\<mu> k (k - 1) *\n  (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  fs'.gs.\\<mu> k (k - 1) =\n  fs.gs.\\<mu> k (k - 1) *\n  (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n   \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"(?n' (k - 1) / ?n (k - 1) * ?r (d fs k)) * \\<dots> = ?r (d fs k) * \\<mu> fs k (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs k) *\n    (fs.gs.\\<mu> k (k - 1) *\n     (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n      \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2)) =\n    rat_of_int (d fs k) * fs.gs.\\<mu> k (k - 1)", "using nzero[OF km1] nzero'[OF km1]"], ["proof (prove)\nusing this:\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs k) *\n    (fs.gs.\\<mu> k (k - 1) *\n     (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n      \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2)) =\n    rat_of_int (d fs k) * fs.gs.\\<mu> k (k - 1)", "by simp"], ["proof (state)\nthis:\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs k) *\n  (fs.gs.\\<mu> k (k - 1) *\n   (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2)) =\n  rat_of_int (d fs k) * fs.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs k) *\n  (fs.gs.\\<mu> k (k - 1) *\n   (\\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2)) =\n  rat_of_int (d fs k) * fs.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"\\<dots> = ?dmu k (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs k) * fs.gs.\\<mu> k (k - 1) =\n    rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)", "using k0"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs k) * fs.gs.\\<mu> k (k - 1) =\n    rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs k) * fs.gs.\\<mu> k (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "finally"], ["proof (chain)\npicking this:\n  start = rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)", "have \"?dmu' k (k - 1) = ?dmu k (k - 1)\""], ["proof (prove)\nusing this:\n  start = rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n    rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)", "unfolding start_def"], ["proof (prove)\nusing this:\n  rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n    rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)", "."], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "}"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note dmu_i_im1 = this"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "{"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "(* d updates *)"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "assume j: \"j \\<le> m\""], ["proof (state)\nthis:\n  j \\<le> m\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "define start where \"start = d fs' j\""], ["proof (state)\nthis:\n  start = d fs' j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "{"], ["proof (state)\nthis:\n  start = d fs' j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "assume jj: \"j \\<noteq> k\""], ["proof (state)\nthis:\n  j \\<noteq> k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"?r start = ?r (d fs' j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int start = rat_of_int (d fs' j)", "unfolding start_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' j) = rat_of_int (d fs' j)", ".."], ["proof (state)\nthis:\n  rat_of_int start = rat_of_int (d fs' j)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int start = rat_of_int (d fs' j)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"?r (d fs' j) = ?r (d fs j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' j) = rat_of_int (d fs j)", "by (subst swap(6), insert j jj, auto)"], ["proof (state)\nthis:\n  rat_of_int (d fs' j) = rat_of_int (d fs j)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int start = rat_of_int (d fs j)", "have \"start = d fs j\""], ["proof (prove)\nusing this:\n  rat_of_int start = rat_of_int (d fs j)\n\ngoal (1 subgoal):\n 1. start = d fs j", "by simp"], ["proof (state)\nthis:\n  start = d fs j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "}"], ["proof (state)\nthis:\n  j \\<noteq> k \\<Longrightarrow> start = d fs j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note d_j = this"], ["proof (state)\nthis:\n  j \\<noteq> k \\<Longrightarrow> start = d fs j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "{"], ["proof (state)\nthis:\n  j \\<noteq> k \\<Longrightarrow> start = d fs j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "assume jj: \"j = k\""], ["proof (state)\nthis:\n  j = k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"?r start = ?r (d fs' k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int start = rat_of_int (d fs' k)", "unfolding start_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' j) = rat_of_int (d fs' k)", "unfolding jj"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' k) = rat_of_int (d fs' k)", "by simp"], ["proof (state)\nthis:\n  rat_of_int start = rat_of_int (d fs' k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int start = rat_of_int (d fs' k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"\\<dots> = ?n' (k - 1) / ?n (k - 1) * ?r (d fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' k) =\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs k)", "by (subst swap(6), insert k, auto)"], ["proof (state)\nthis:\n  rat_of_int (d fs' k) =\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs' k) =\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"?n' (k - 1) = (?r (d fs k) / ?r (d fs k)) * (?r (d fs k) / ?r (d fs k)) \n          * (?n k  + \\<mu> fs k (k - 1) * \\<mu> fs k (k - 1) * ?n (k - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n    rat_of_int (d fs k) / rat_of_int (d fs k) *\n    (rat_of_int (d fs k) / rat_of_int (d fs k)) *\n    (\\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 +\n     fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> k (k - 1) *\n     \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)", "by (subst swap(4)[OF km1], insert dzero[of k], insert k, simp)"], ["proof (state)\nthis:\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n  rat_of_int (d fs k) / rat_of_int (d fs k) *\n  (rat_of_int (d fs k) / rat_of_int (d fs k)) *\n  (\\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 +\n   fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> k (k - 1) *\n   \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n  rat_of_int (d fs k) / rat_of_int (d fs k) *\n  (rat_of_int (d fs k) / rat_of_int (d fs k)) *\n  (\\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 +\n   fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> k (k - 1) *\n   \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"?n (k - 1) = ?r (d fs k) / ?r (d fs (k - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n    rat_of_int (d fs k) / rat_of_int (d fs (k - 1))", "unfolding LLL_d_Suc[OF invw km1, unfolded sim1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs (k - 1)) /\n    rat_of_int (d fs (k - 1))", "using dzero[of \"k - 1\"] k k0"], ["proof (prove)\nusing this:\n  k - 1 \\<le> m \\<Longrightarrow> d fs (k - 1) \\<noteq> 0\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    rat_of_int (d fs (k - 1)) /\n    rat_of_int (d fs (k - 1))", "by simp"], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n  rat_of_int (d fs k) / rat_of_int (d fs (k - 1))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int start =\n  rat_of_int (d fs k) / rat_of_int (d fs k) *\n  (rat_of_int (d fs k) / rat_of_int (d fs k)) *\n  (\\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 +\n   fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs k) / rat_of_int (d fs (k - 1)))) /\n  (rat_of_int (d fs k) / rat_of_int (d fs (k - 1))) *\n  rat_of_int (d fs k)", "have \"?r start = \n          ((?r (d fs k) * ?n k) * ?r (d fs (k - 1)) + ?dmu k (k - 1) * ?dmu k (k - 1)) \n          / (?r (d fs k))\""], ["proof (prove)\nusing this:\n  rat_of_int start =\n  rat_of_int (d fs k) / rat_of_int (d fs k) *\n  (rat_of_int (d fs k) / rat_of_int (d fs k)) *\n  (\\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 +\n   fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs k) / rat_of_int (d fs (k - 1)))) /\n  (rat_of_int (d fs k) / rat_of_int (d fs (k - 1))) *\n  rat_of_int (d fs k)\n\ngoal (1 subgoal):\n 1. rat_of_int start =\n    (rat_of_int (d fs k) * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 *\n     rat_of_int (d fs (k - 1)) +\n     rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n     (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1))) /\n    rat_of_int (d fs k)", "using k k0 dzero[of k] dzero[of \"k - 1\"]"], ["proof (prove)\nusing this:\n  rat_of_int start =\n  rat_of_int (d fs k) / rat_of_int (d fs k) *\n  (rat_of_int (d fs k) / rat_of_int (d fs k)) *\n  (\\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 +\n   fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs k) / rat_of_int (d fs (k - 1)))) /\n  (rat_of_int (d fs k) / rat_of_int (d fs (k - 1))) *\n  rat_of_int (d fs k)\n  k < m\n  k \\<noteq> 0\n  k \\<le> m \\<Longrightarrow> d fs k \\<noteq> 0\n  k - 1 \\<le> m \\<Longrightarrow> d fs (k - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int start =\n    (rat_of_int (d fs k) * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 *\n     rat_of_int (d fs (k - 1)) +\n     rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n     (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1))) /\n    rat_of_int (d fs k)", "by (simp add: ring_distribs)"], ["proof (state)\nthis:\n  rat_of_int start =\n  (rat_of_int (d fs k) * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 *\n   rat_of_int (d fs (k - 1)) +\n   rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1))) /\n  rat_of_int (d fs k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int start =\n  (rat_of_int (d fs k) * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 *\n   rat_of_int (d fs (k - 1)) +\n   rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1))) /\n  rat_of_int (d fs k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"?r (d fs k) * ?n k = ?r (d fs (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs k) * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 =\n    rat_of_int (d fs (Suc k))", "unfolding LLL_d_Suc[OF invw k]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs k) * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 =\n    \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k)", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs k) * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 =\n  rat_of_int (d fs (Suc k))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs k) * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 =\n  rat_of_int (d fs (Suc k))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"?dmu k (k - 1) = ?r (d\\<mu> fs k (k - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) =\n    rat_of_int (d\\<mu> fs k (k - 1))", "by (subst rat, insert k k0, auto)"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) =\n  rat_of_int (d\\<mu> fs k (k - 1))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int start =\n  (rat_of_int (d fs (Suc k)) * rat_of_int (d fs (k - 1)) +\n   rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs k (k - 1))) /\n  rat_of_int (d fs k)", "have \"?r start = (?r (d fs (Suc k) * d fs (k - 1) + d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)))\n          / (?r (d fs k))\""], ["proof (prove)\nusing this:\n  rat_of_int start =\n  (rat_of_int (d fs (Suc k)) * rat_of_int (d fs (k - 1)) +\n   rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs k (k - 1))) /\n  rat_of_int (d fs k)\n\ngoal (1 subgoal):\n 1. rat_of_int start =\n    rat_of_int\n     (d fs (Suc k) * d fs (k - 1) +\n      d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) /\n    rat_of_int (d fs k)", "by simp"], ["proof (state)\nthis:\n  rat_of_int start =\n  rat_of_int\n   (d fs (Suc k) * d fs (k - 1) +\n    d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) /\n  rat_of_int (d fs k)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "from division_to_div[OF this]"], ["proof (chain)\npicking this:\n  start =\n  (d fs (Suc k) * d fs (k - 1) +\n   d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n  d fs k", "have \"start = ?d'i\""], ["proof (prove)\nusing this:\n  start =\n  (d fs (Suc k) * d fs (k - 1) +\n   d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n  d fs k\n\ngoal (1 subgoal):\n 1. start =\n    (d fs (Suc k) * d fs (k - 1) +\n     d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n    d fs k", "."], ["proof (state)\nthis:\n  start =\n  (d fs (Suc k) * d fs (k - 1) +\n   d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n  d fs k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "}"], ["proof (state)\nthis:\n  j = k \\<Longrightarrow>\n  start =\n  (d fs (Suc k) * d fs (k - 1) +\n   d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n  d fs k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note d_i = this"], ["proof (state)\nthis:\n  j = k \\<Longrightarrow>\n  start =\n  (d fs (Suc k) * d fs (k - 1) +\n   d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n  d fs k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> m \\<Longrightarrow>\n       d fs' i =\n       (if i = k\n        then (d fs (Suc k) * d fs (k - 1) +\n              d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n             d fs k\n        else d fs i)\n 2. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "from d_j d_i"], ["proof (chain)\npicking this:\n  j \\<noteq> k \\<Longrightarrow> start = d fs j\n  j = k \\<Longrightarrow>\n  start =\n  (d fs (Suc k) * d fs (k - 1) +\n   d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n  d fs k", "show \"d fs' j = (if j = k then ?d'i else d fs j)\""], ["proof (prove)\nusing this:\n  j \\<noteq> k \\<Longrightarrow> start = d fs j\n  j = k \\<Longrightarrow>\n  start =\n  (d fs (Suc k) * d fs (k - 1) +\n   d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n  d fs k\n\ngoal (1 subgoal):\n 1. d fs' j =\n    (if j = k\n     then (d fs (Suc k) * d fs (k - 1) +\n           d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n          d fs k\n     else d fs j)", "unfolding start_def"], ["proof (prove)\nusing this:\n  j \\<noteq> k \\<Longrightarrow> d fs' j = d fs j\n  j = k \\<Longrightarrow>\n  d fs' j =\n  (d fs (Suc k) * d fs (k - 1) +\n   d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n  d fs k\n\ngoal (1 subgoal):\n 1. d fs' j =\n    (if j = k\n     then (d fs (Suc k) * d fs (k - 1) +\n           d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n          d fs k\n     else d fs j)", "by auto"], ["proof (state)\nthis:\n  d fs' j =\n  (if j = k\n   then (d fs (Suc k) * d fs (k - 1) +\n         d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n        d fs k\n   else d fs j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "}"], ["proof (state)\nthis:\n  ?j3 \\<le> m \\<Longrightarrow>\n  d fs' ?j3 =\n  (if ?j3 = k\n   then (d fs (Suc k) * d fs (k - 1) +\n         d\\<mu> fs k (k - 1) * d\\<mu> fs k (k - 1)) div\n        d fs k\n   else d fs ?j3)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "have \"length fs' = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length fs' = m", "using fs'_def inv'(6)"], ["proof (prove)\nusing this:\n  fs' = fs[k := fs ! (k - 1), k - 1 := fs ! k]\n  length fs = m\n\ngoal (1 subgoal):\n 1. length fs' = m", "by auto"], ["proof (state)\nthis:\n  length fs' = m\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "{"], ["proof (state)\nthis:\n  length fs' = m\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "assume i: \"i < m\" and j: \"j < i\""], ["proof (state)\nthis:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "from j i"], ["proof (chain)\npicking this:\n  j < i\n  i < m", "have sj: \"Suc j \\<le> m\""], ["proof (prove)\nusing this:\n  j < i\n  i < m\n\ngoal (1 subgoal):\n 1. Suc j \\<le> m", "by auto"], ["proof (state)\nthis:\n  Suc j \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "note swaps = swap(5)[OF i j] swap(6)[OF sj]"], ["proof (state)\nthis:\n  fs'.gs.\\<mu> i j =\n  (if i = k - 1 then fs.gs.\\<mu> k j\n   else if i = k\n        then if j = k - 1\n             then fs.gs.\\<mu> k (k - 1) *\n                  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n             else fs.gs.\\<mu> (k - 1) j\n        else if k < i \\<and> j = k\n             then fs.gs.\\<mu> i (k - 1) -\n                  fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n             else if k < i \\<and> j = k - 1\n                  then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                       fs.gs.\\<mu> i k *\n                       \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                       \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                  else fs.gs.\\<mu> i j)\n  rat_of_int (d fs' (Suc j)) =\n  (if Suc j = k\n   then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n        \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n        rat_of_int (d fs k)\n   else rat_of_int (d fs (Suc j)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < i\\<rbrakk>\n       \\<Longrightarrow> d\\<mu> fs' i j =\n                         (if i = k - 1 then d\\<mu> fs k j\n                          else if i = k \\<and> j \\<noteq> k - 1\n                               then d\\<mu> fs (k - 1) j\n                               else if k < i \\<and> j = k\n                                    then (d fs (Suc k) *\n    d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n   d fs k\n                                    else if k < i \\<and> j = k - 1\n   then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n         d\\<mu> fs i k * d fs (k - 1)) div\n        d fs k\n   else d\\<mu> fs i j)", "show \"d\\<mu> fs' i j = ?new_mu i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "proof (cases \"i < k - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "case small: True"], ["proof (state)\nthis:\n  i < k - 1\n\ngoal (2 subgoals):\n 1. i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "hence id: \"?new_mu i j = d\\<mu> fs i j\""], ["proof (prove)\nusing this:\n  i < k - 1\n\ngoal (1 subgoal):\n 1. (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j) =\n    d\\<mu> fs i j", "by auto"], ["proof (state)\nthis:\n  (if i = k - 1 then d\\<mu> fs k j\n   else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n        else if k < i \\<and> j = k\n             then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                  d fs k\n             else if k < i \\<and> j = k - 1\n                  then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                        d\\<mu> fs i k * d fs (k - 1)) div\n                       d fs k\n                  else d\\<mu> fs i j) =\n  d\\<mu> fs i j\n\ngoal (2 subgoals):\n 1. i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "using swaps small i j k k0"], ["proof (prove)\nusing this:\n  fs'.gs.\\<mu> i j =\n  (if i = k - 1 then fs.gs.\\<mu> k j\n   else if i = k\n        then if j = k - 1\n             then fs.gs.\\<mu> k (k - 1) *\n                  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n             else fs.gs.\\<mu> (k - 1) j\n        else if k < i \\<and> j = k\n             then fs.gs.\\<mu> i (k - 1) -\n                  fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n             else if k < i \\<and> j = k - 1\n                  then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                       fs.gs.\\<mu> i k *\n                       \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                       \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                  else fs.gs.\\<mu> i j)\n  rat_of_int (d fs' (Suc j)) =\n  (if Suc j = k\n   then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n        \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n        rat_of_int (d fs k)\n   else rat_of_int (d fs (Suc j)))\n  i < k - 1\n  i < m\n  j < i\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "by (auto simp: d\\<mu>_def)"], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (if i = k - 1 then d\\<mu> fs k j\n   else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n        else if k < i \\<and> j = k\n             then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                  d fs k\n             else if k < i \\<and> j = k - 1\n                  then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                        d\\<mu> fs i k * d fs (k - 1)) div\n                       d fs k\n                  else d\\<mu> fs i j)\n\ngoal (1 subgoal):\n 1. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "case False"], ["proof (state)\nthis:\n  \\<not> i < k - 1\n\ngoal (1 subgoal):\n 1. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "from j i"], ["proof (chain)\npicking this:\n  j < i\n  i < m", "have sj: \"Suc j \\<le> m\""], ["proof (prove)\nusing this:\n  j < i\n  i < m\n\ngoal (1 subgoal):\n 1. Suc j \\<le> m", "by auto"], ["proof (state)\nthis:\n  Suc j \\<le> m\n\ngoal (1 subgoal):\n 1. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "let ?start = \"d\\<mu> fs' i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "define start where \"start = ?start\""], ["proof (state)\nthis:\n  start = d\\<mu> fs' i j\n\ngoal (1 subgoal):\n 1. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "note rat'[OF i j]"], ["proof (state)\nthis:\n  rat_of_int (d\\<mu> fs' i j) =\n  rat_of_int (d fs' (Suc j)) * fs'.gs.\\<mu> i j\n\ngoal (1 subgoal):\n 1. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "note rat_i_j = rat[OF i j]"], ["proof (state)\nthis:\n  rat_of_int (d\\<mu> fs i j) = rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j\n\ngoal (1 subgoal):\n 1. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "from False"], ["proof (chain)\npicking this:\n  \\<not> i < k - 1", "consider (i_k) \"i = k\" \"j = k - 1\" | (i_small) \"i = k\" \"j \\<noteq> k - 1\" | \n          (i_km1) \"i = k - 1\" | (i_large) \"i > k\""], ["proof (prove)\nusing this:\n  \\<not> i < k - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>i = k; j = k - 1\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>i = k; j \\<noteq> k - 1\\<rbrakk> \\<Longrightarrow> thesis;\n     i = k - 1 \\<Longrightarrow> thesis;\n     k < i \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>i = k; j = k - 1\\<rbrakk> \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>i = k; j \\<noteq> k - 1\\<rbrakk> \\<Longrightarrow> ?thesis1;\n   i = k - 1 \\<Longrightarrow> ?thesis1;\n   k < i \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<not> i < k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>i = k; j = k - 1\\<rbrakk> \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>i = k; j \\<noteq> k - 1\\<rbrakk> \\<Longrightarrow> ?thesis1;\n   i = k - 1 \\<Longrightarrow> ?thesis1;\n   k < i \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>i = k; j = k - 1\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i j =\n                      (if i = k - 1 then d\\<mu> fs k j\n                       else if i = k \\<and> j \\<noteq> k - 1\n                            then d\\<mu> fs (k - 1) j\n                            else if k < i \\<and> j = k\n                                 then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\nd fs k\n                                 else if k < i \\<and> j = k - 1\nthen (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n      d\\<mu> fs i k * d fs (k - 1)) div\n     d fs k\nelse d\\<mu> fs i j)\n 2. \\<lbrakk>i = k; j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i j =\n                      (if i = k - 1 then d\\<mu> fs k j\n                       else if i = k \\<and> j \\<noteq> k - 1\n                            then d\\<mu> fs (k - 1) j\n                            else if k < i \\<and> j = k\n                                 then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\nd fs k\n                                 else if k < i \\<and> j = k - 1\nthen (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n      d\\<mu> fs i k * d fs (k - 1)) div\n     d fs k\nelse d\\<mu> fs i j)\n 3. i = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 4. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "case *: i_small"], ["proof (state)\nthis:\n  i = k\n  j \\<noteq> k - 1\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i = k; j = k - 1\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i j =\n                      (if i = k - 1 then d\\<mu> fs k j\n                       else if i = k \\<and> j \\<noteq> k - 1\n                            then d\\<mu> fs (k - 1) j\n                            else if k < i \\<and> j = k\n                                 then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\nd fs k\n                                 else if k < i \\<and> j = k - 1\nthen (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n      d\\<mu> fs i k * d fs (k - 1)) div\n     d fs k\nelse d\\<mu> fs i j)\n 2. \\<lbrakk>i = k; j \\<noteq> k - 1\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i j =\n                      (if i = k - 1 then d\\<mu> fs k j\n                       else if i = k \\<and> j \\<noteq> k - 1\n                            then d\\<mu> fs (k - 1) j\n                            else if k < i \\<and> j = k\n                                 then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\nd fs k\n                                 else if k < i \\<and> j = k - 1\nthen (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n      d\\<mu> fs i k * d fs (k - 1)) div\n     d fs k\nelse d\\<mu> fs i j)\n 3. i = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 4. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "unfolding swaps d\\<mu>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_rat\n     ((if Suc j = k\n       then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n            \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n            rat_of_int (d fs k)\n       else rat_of_int (d fs (Suc j))) *\n      (if i = k - 1 then fs.gs.\\<mu> k j\n       else if i = k\n            then if j = k - 1\n                 then fs.gs.\\<mu> k (k - 1) *\n                      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                      \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                 else fs.gs.\\<mu> (k - 1) j\n            else if k < i \\<and> j = k\n                 then fs.gs.\\<mu> i (k - 1) -\n                      fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n                 else if k < i \\<and> j = k - 1\n                      then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                           fs.gs.\\<mu> i k *\n                           \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                           \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                      else fs.gs.\\<mu> i j)) =\n    (if i = k - 1\n     then int_of_rat (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> k j)\n     else if i = k \\<and> j \\<noteq> k - 1\n          then int_of_rat\n                (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> (k - 1) j)\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> i (k - 1)) -\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> k (k - 1)) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j)) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (int_of_rat\n                           (rat_of_int (d fs (Suc (k - 1))) *\n                            fs.gs.\\<mu> k (k - 1)) *\n                          int_of_rat\n                           (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) +\n                          int_of_rat\n                           (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k) *\n                          d fs (k - 1)) div\n                         d fs k\n                    else int_of_rat\n                          (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j))", "using * i k k0"], ["proof (prove)\nusing this:\n  i = k\n  j \\<noteq> k - 1\n  i < m\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int_of_rat\n     ((if Suc j = k\n       then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n            \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n            rat_of_int (d fs k)\n       else rat_of_int (d fs (Suc j))) *\n      (if i = k - 1 then fs.gs.\\<mu> k j\n       else if i = k\n            then if j = k - 1\n                 then fs.gs.\\<mu> k (k - 1) *\n                      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                      \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                 else fs.gs.\\<mu> (k - 1) j\n            else if k < i \\<and> j = k\n                 then fs.gs.\\<mu> i (k - 1) -\n                      fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n                 else if k < i \\<and> j = k - 1\n                      then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                           fs.gs.\\<mu> i k *\n                           \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                           \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                      else fs.gs.\\<mu> i j)) =\n    (if i = k - 1\n     then int_of_rat (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> k j)\n     else if i = k \\<and> j \\<noteq> k - 1\n          then int_of_rat\n                (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> (k - 1) j)\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> i (k - 1)) -\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> k (k - 1)) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j)) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (int_of_rat\n                           (rat_of_int (d fs (Suc (k - 1))) *\n                            fs.gs.\\<mu> k (k - 1)) *\n                          int_of_rat\n                           (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) +\n                          int_of_rat\n                           (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k) *\n                          d fs (k - 1)) div\n                         d fs k\n                    else int_of_rat\n                          (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j))", "by auto"], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (if i = k - 1 then d\\<mu> fs k j\n   else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n        else if k < i \\<and> j = k\n             then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                  d fs k\n             else if k < i \\<and> j = k - 1\n                  then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                        d\\<mu> fs i k * d fs (k - 1)) div\n                       d fs k\n                  else d\\<mu> fs i j)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = k; j = k - 1\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i j =\n                      (if i = k - 1 then d\\<mu> fs k j\n                       else if i = k \\<and> j \\<noteq> k - 1\n                            then d\\<mu> fs (k - 1) j\n                            else if k < i \\<and> j = k\n                                 then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\nd fs k\n                                 else if k < i \\<and> j = k - 1\nthen (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n      d\\<mu> fs i k * d fs (k - 1)) div\n     d fs k\nelse d\\<mu> fs i j)\n 2. i = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 3. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>i = k; j = k - 1\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i j =\n                      (if i = k - 1 then d\\<mu> fs k j\n                       else if i = k \\<and> j \\<noteq> k - 1\n                            then d\\<mu> fs (k - 1) j\n                            else if k < i \\<and> j = k\n                                 then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\nd fs k\n                                 else if k < i \\<and> j = k - 1\nthen (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n      d\\<mu> fs i k * d fs (k - 1)) div\n     d fs k\nelse d\\<mu> fs i j)\n 2. i = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 3. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "case *: i_k"], ["proof (state)\nthis:\n  i = k\n  j = k - 1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = k; j = k - 1\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i j =\n                      (if i = k - 1 then d\\<mu> fs k j\n                       else if i = k \\<and> j \\<noteq> k - 1\n                            then d\\<mu> fs (k - 1) j\n                            else if k < i \\<and> j = k\n                                 then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\nd fs k\n                                 else if k < i \\<and> j = k - 1\nthen (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n      d\\<mu> fs i k * d fs (k - 1)) div\n     d fs k\nelse d\\<mu> fs i j)\n 2. i = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 3. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "using dmu_i_im1 rat_i_j * k0"], ["proof (prove)\nusing this:\n  rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)\n  rat_of_int (d\\<mu> fs i j) = rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j\n  i = k\n  j = k - 1\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "by (auto simp: d\\<mu>_def)"], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (if i = k - 1 then d\\<mu> fs k j\n   else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n        else if k < i \\<and> j = k\n             then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                  d fs k\n             else if k < i \\<and> j = k - 1\n                  then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                        d\\<mu> fs i k * d fs (k - 1)) div\n                       d fs k\n                  else d\\<mu> fs i j)\n\ngoal (2 subgoals):\n 1. i = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "case *: i_km1"], ["proof (state)\nthis:\n  i = k - 1\n\ngoal (2 subgoals):\n 1. i = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "unfolding swaps d\\<mu>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_rat\n     ((if Suc j = k\n       then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n            \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n            rat_of_int (d fs k)\n       else rat_of_int (d fs (Suc j))) *\n      (if i = k - 1 then fs.gs.\\<mu> k j\n       else if i = k\n            then if j = k - 1\n                 then fs.gs.\\<mu> k (k - 1) *\n                      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                      \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                 else fs.gs.\\<mu> (k - 1) j\n            else if k < i \\<and> j = k\n                 then fs.gs.\\<mu> i (k - 1) -\n                      fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n                 else if k < i \\<and> j = k - 1\n                      then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                           fs.gs.\\<mu> i k *\n                           \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                           \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                      else fs.gs.\\<mu> i j)) =\n    (if i = k - 1\n     then int_of_rat (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> k j)\n     else if i = k \\<and> j \\<noteq> k - 1\n          then int_of_rat\n                (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> (k - 1) j)\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> i (k - 1)) -\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> k (k - 1)) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j)) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (int_of_rat\n                           (rat_of_int (d fs (Suc (k - 1))) *\n                            fs.gs.\\<mu> k (k - 1)) *\n                          int_of_rat\n                           (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) +\n                          int_of_rat\n                           (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k) *\n                          d fs (k - 1)) div\n                         d fs k\n                    else int_of_rat\n                          (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j))", "using * i j k k0"], ["proof (prove)\nusing this:\n  i = k - 1\n  i < m\n  j < i\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int_of_rat\n     ((if Suc j = k\n       then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n            \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n            rat_of_int (d fs k)\n       else rat_of_int (d fs (Suc j))) *\n      (if i = k - 1 then fs.gs.\\<mu> k j\n       else if i = k\n            then if j = k - 1\n                 then fs.gs.\\<mu> k (k - 1) *\n                      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                      \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                 else fs.gs.\\<mu> (k - 1) j\n            else if k < i \\<and> j = k\n                 then fs.gs.\\<mu> i (k - 1) -\n                      fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n                 else if k < i \\<and> j = k - 1\n                      then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                           fs.gs.\\<mu> i k *\n                           \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                           \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                      else fs.gs.\\<mu> i j)) =\n    (if i = k - 1\n     then int_of_rat (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> k j)\n     else if i = k \\<and> j \\<noteq> k - 1\n          then int_of_rat\n                (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> (k - 1) j)\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> i (k - 1)) -\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> k (k - 1)) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j)) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (int_of_rat\n                           (rat_of_int (d fs (Suc (k - 1))) *\n                            fs.gs.\\<mu> k (k - 1)) *\n                          int_of_rat\n                           (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) +\n                          int_of_rat\n                           (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k) *\n                          d fs (k - 1)) div\n                         d fs k\n                    else int_of_rat\n                          (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j))", "by auto"], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (if i = k - 1 then d\\<mu> fs k j\n   else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n        else if k < i \\<and> j = k\n             then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                  d fs k\n             else if k < i \\<and> j = k - 1\n                  then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                        d\\<mu> fs i k * d fs (k - 1)) div\n                       d fs k\n                  else d\\<mu> fs i j)\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "case *: i_large"], ["proof (state)\nthis:\n  k < i\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "consider (jj) \"j \\<noteq> k - 1\" \"j \\<noteq> k\" | (ji) \"j = k\" | (jim1) \"j = k - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>j \\<noteq> k - 1; j \\<noteq> k\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     j = k \\<Longrightarrow> thesis;\n     j = k - 1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>j \\<noteq> k - 1; j \\<noteq> k\\<rbrakk>\n           \\<Longrightarrow> ?thesis1;\n   j = k \\<Longrightarrow> ?thesis1;\n   j = k - 1 \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. k < i \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>j \\<noteq> k - 1; j \\<noteq> k\\<rbrakk>\n           \\<Longrightarrow> ?thesis1;\n   j = k \\<Longrightarrow> ?thesis1;\n   j = k - 1 \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>j \\<noteq> k - 1; j \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i j =\n                      (if i = k - 1 then d\\<mu> fs k j\n                       else if i = k \\<and> j \\<noteq> k - 1\n                            then d\\<mu> fs (k - 1) j\n                            else if k < i \\<and> j = k\n                                 then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\nd fs k\n                                 else if k < i \\<and> j = k - 1\nthen (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n      d\\<mu> fs i k * d fs (k - 1)) div\n     d fs k\nelse d\\<mu> fs i j)\n 2. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 3. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "case jj"], ["proof (state)\nthis:\n  j \\<noteq> k - 1\n  j \\<noteq> k\n\ngoal (3 subgoals):\n 1. \\<lbrakk>j \\<noteq> k - 1; j \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> d\\<mu> fs' i j =\n                      (if i = k - 1 then d\\<mu> fs k j\n                       else if i = k \\<and> j \\<noteq> k - 1\n                            then d\\<mu> fs (k - 1) j\n                            else if k < i \\<and> j = k\n                                 then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\nd fs k\n                                 else if k < i \\<and> j = k - 1\nthen (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n      d\\<mu> fs i k * d fs (k - 1)) div\n     d fs k\nelse d\\<mu> fs i j)\n 2. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 3. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "unfolding swaps d\\<mu>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_rat\n     ((if Suc j = k\n       then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n            \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n            rat_of_int (d fs k)\n       else rat_of_int (d fs (Suc j))) *\n      (if i = k - 1 then fs.gs.\\<mu> k j\n       else if i = k\n            then if j = k - 1\n                 then fs.gs.\\<mu> k (k - 1) *\n                      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                      \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                 else fs.gs.\\<mu> (k - 1) j\n            else if k < i \\<and> j = k\n                 then fs.gs.\\<mu> i (k - 1) -\n                      fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n                 else if k < i \\<and> j = k - 1\n                      then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                           fs.gs.\\<mu> i k *\n                           \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                           \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                      else fs.gs.\\<mu> i j)) =\n    (if i = k - 1\n     then int_of_rat (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> k j)\n     else if i = k \\<and> j \\<noteq> k - 1\n          then int_of_rat\n                (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> (k - 1) j)\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> i (k - 1)) -\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> k (k - 1)) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j)) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (int_of_rat\n                           (rat_of_int (d fs (Suc (k - 1))) *\n                            fs.gs.\\<mu> k (k - 1)) *\n                          int_of_rat\n                           (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) +\n                          int_of_rat\n                           (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k) *\n                          d fs (k - 1)) div\n                         d fs k\n                    else int_of_rat\n                          (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j))", "using * i j jj k k0"], ["proof (prove)\nusing this:\n  k < i\n  i < m\n  j < i\n  j \\<noteq> k - 1\n  j \\<noteq> k\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int_of_rat\n     ((if Suc j = k\n       then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n            \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n            rat_of_int (d fs k)\n       else rat_of_int (d fs (Suc j))) *\n      (if i = k - 1 then fs.gs.\\<mu> k j\n       else if i = k\n            then if j = k - 1\n                 then fs.gs.\\<mu> k (k - 1) *\n                      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                      \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                 else fs.gs.\\<mu> (k - 1) j\n            else if k < i \\<and> j = k\n                 then fs.gs.\\<mu> i (k - 1) -\n                      fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n                 else if k < i \\<and> j = k - 1\n                      then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                           fs.gs.\\<mu> i k *\n                           \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                           \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                      else fs.gs.\\<mu> i j)) =\n    (if i = k - 1\n     then int_of_rat (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> k j)\n     else if i = k \\<and> j \\<noteq> k - 1\n          then int_of_rat\n                (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> (k - 1) j)\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> i (k - 1)) -\n                     int_of_rat\n                      (rat_of_int (d fs (Suc (k - 1))) *\n                       fs.gs.\\<mu> k (k - 1)) *\n                     int_of_rat\n                      (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j)) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (int_of_rat\n                           (rat_of_int (d fs (Suc (k - 1))) *\n                            fs.gs.\\<mu> k (k - 1)) *\n                          int_of_rat\n                           (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) +\n                          int_of_rat\n                           (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k) *\n                          d fs (k - 1)) div\n                         d fs k\n                    else int_of_rat\n                          (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j))", "by auto"], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (if i = k - 1 then d\\<mu> fs k j\n   else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n        else if k < i \\<and> j = k\n             then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                  d fs k\n             else if k < i \\<and> j = k - 1\n                  then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                        d\\<mu> fs i k * d fs (k - 1)) div\n                       d fs k\n                  else d\\<mu> fs i j)\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "case ji"], ["proof (state)\nthis:\n  j = k\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"?r start = ?dmu' i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int start = rat_of_int (d fs' (Suc j)) * fs'.gs.\\<mu> i j", "unfolding start_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d\\<mu> fs' i j) =\n    rat_of_int (d fs' (Suc j)) * fs'.gs.\\<mu> i j", "by fact"], ["proof (state)\nthis:\n  rat_of_int start = rat_of_int (d fs' (Suc j)) * fs'.gs.\\<mu> i j\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int start = rat_of_int (d fs' (Suc j)) * fs'.gs.\\<mu> i j\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"?r (d fs' (Suc j)) = ?r (d fs (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc j)) = rat_of_int (d fs (Suc k))", "unfolding swaps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc j = k\n     then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n          \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n          rat_of_int (d fs k)\n     else rat_of_int (d fs (Suc j))) =\n    rat_of_int (d fs (Suc k))", "unfolding ji"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc k = k\n     then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n          \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n          rat_of_int (d fs k)\n     else rat_of_int (d fs (Suc k))) =\n    rat_of_int (d fs (Suc k))", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc j)) = rat_of_int (d fs (Suc k))\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc j)) = rat_of_int (d fs (Suc k))\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"\\<mu> fs' i j = \\<mu> fs i (k - 1) - \\<mu> fs k (k - 1) * \\<mu> fs i k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs'.gs.\\<mu> i j =\n    fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k", "unfolding swaps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = k - 1 then fs.gs.\\<mu> k j\n     else if i = k\n          then if j = k - 1\n               then fs.gs.\\<mu> k (k - 1) *\n                    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n               else fs.gs.\\<mu> (k - 1) j\n          else if k < i \\<and> j = k\n               then fs.gs.\\<mu> i (k - 1) -\n                    fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n               else if k < i \\<and> j = k - 1\n                    then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                         fs.gs.\\<mu> i k *\n                         \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                         \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                    else fs.gs.\\<mu> i j) =\n    fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k", "unfolding ji"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = k - 1 then fs.gs.\\<mu> k k\n     else if i = k\n          then if k = k - 1\n               then fs.gs.\\<mu> k (k - 1) *\n                    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n               else fs.gs.\\<mu> (k - 1) k\n          else if k < i \\<and> k = k\n               then fs.gs.\\<mu> i (k - 1) -\n                    fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n               else if k < i \\<and> k = k - 1\n                    then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                         fs.gs.\\<mu> i k *\n                         \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                         \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                    else fs.gs.\\<mu> i k) =\n    fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k", "using k0 *"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k < i\n\ngoal (1 subgoal):\n 1. (if i = k - 1 then fs.gs.\\<mu> k k\n     else if i = k\n          then if k = k - 1\n               then fs.gs.\\<mu> k (k - 1) *\n                    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n               else fs.gs.\\<mu> (k - 1) k\n          else if k < i \\<and> k = k\n               then fs.gs.\\<mu> i (k - 1) -\n                    fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n               else if k < i \\<and> k = k - 1\n                    then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                         fs.gs.\\<mu> i k *\n                         \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                         \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                    else fs.gs.\\<mu> i k) =\n    fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k", "by auto"], ["proof (state)\nthis:\n  fs'.gs.\\<mu> i j =\n  fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  fs'.gs.\\<mu> i j =\n  fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"?r (d fs (Suc k)) * \\<dots> = ?r (d fs (Suc k)) * ?r (d fs k) / ?r (d fs k) * \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) *\n    (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k) =\n    rat_of_int (d fs (Suc k)) * rat_of_int (d fs k) / rat_of_int (d fs k) *\n    (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k)", "using dzero[of k] k"], ["proof (prove)\nusing this:\n  k \\<le> m \\<Longrightarrow> d fs k \\<noteq> 0\n  k < m\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) *\n    (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k) =\n    rat_of_int (d fs (Suc k)) * rat_of_int (d fs k) / rat_of_int (d fs k) *\n    (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k)", "by auto"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc k)) *\n  (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k) =\n  rat_of_int (d fs (Suc k)) * rat_of_int (d fs k) / rat_of_int (d fs k) *\n  (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k)\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc k)) *\n  (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k) =\n  rat_of_int (d fs (Suc k)) * rat_of_int (d fs k) / rat_of_int (d fs k) *\n  (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k)\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"\\<dots> =  \n            (?r (d fs (Suc k)) * ?dmu i (k - 1) - ?dmu k (k - 1) * ?dmu i k) / ?r (d fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) * rat_of_int (d fs k) / rat_of_int (d fs k) *\n    (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k) =\n    (rat_of_int (d fs (Suc k)) *\n     (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) -\n     rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n     (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k)) /\n    rat_of_int (d fs k)", "using k0"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) * rat_of_int (d fs k) / rat_of_int (d fs k) *\n    (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k) =\n    (rat_of_int (d fs (Suc k)) *\n     (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) -\n     rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n     (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k)) /\n    rat_of_int (d fs k)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc k)) * rat_of_int (d fs k) / rat_of_int (d fs k) *\n  (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k) =\n  (rat_of_int (d fs (Suc k)) *\n   (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) -\n   rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k)) /\n  rat_of_int (d fs k)\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc k)) * rat_of_int (d fs k) / rat_of_int (d fs k) *\n  (fs.gs.\\<mu> i (k - 1) - fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k) =\n  (rat_of_int (d fs (Suc k)) *\n   (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) -\n   rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k)) /\n  rat_of_int (d fs k)\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"\\<dots> = \n            (?r (d fs (Suc k)) * ?r (d\\<mu> fs i (k - 1)) - ?r (d\\<mu> fs k (k - 1)) * ?r (d\\<mu> fs i k)) / ?r (d fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (d fs (Suc k)) *\n     (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) -\n     rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n     (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k)) /\n    rat_of_int (d fs k) =\n    (rat_of_int (d fs (Suc k)) * rat_of_int (d\\<mu> fs i (k - 1)) -\n     rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i k)) /\n    rat_of_int (d fs k)", "by (subst (1 2 3) rat, insert k k0 i *, auto)"], ["proof (state)\nthis:\n  (rat_of_int (d fs (Suc k)) *\n   (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) -\n   rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k)) /\n  rat_of_int (d fs k) =\n  (rat_of_int (d fs (Suc k)) * rat_of_int (d\\<mu> fs i (k - 1)) -\n   rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i k)) /\n  rat_of_int (d fs k)\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  (rat_of_int (d fs (Suc k)) *\n   (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) -\n   rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k)) /\n  rat_of_int (d fs k) =\n  (rat_of_int (d fs (Suc k)) * rat_of_int (d\\<mu> fs i (k - 1)) -\n   rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i k)) /\n  rat_of_int (d fs k)\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"\\<dots> = ?r (d fs (Suc k) * d\\<mu> fs i (k - 1) - d\\<mu> fs k (k - 1) * d\\<mu> fs i k) / ?r (d fs k)\" \n            (is \"_ = of_int ?x / _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (d fs (Suc k)) * rat_of_int (d\\<mu> fs i (k - 1)) -\n     rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i k)) /\n    rat_of_int (d fs k) =\n    rat_of_int\n     (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n      d\\<mu> fs k (k - 1) * d\\<mu> fs i k) /\n    rat_of_int (d fs k)", "by simp"], ["proof (state)\nthis:\n  (rat_of_int (d fs (Suc k)) * rat_of_int (d\\<mu> fs i (k - 1)) -\n   rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i k)) /\n  rat_of_int (d fs k) =\n  rat_of_int\n   (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i k) /\n  rat_of_int (d fs k)\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int start =\n  rat_of_int\n   (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i k) /\n  rat_of_int (d fs k)", "have \"?r start = ?r ?x / ?r (d fs k)\""], ["proof (prove)\nusing this:\n  rat_of_int start =\n  rat_of_int\n   (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i k) /\n  rat_of_int (d fs k)\n\ngoal (1 subgoal):\n 1. rat_of_int start =\n    rat_of_int\n     (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n      d\\<mu> fs k (k - 1) * d\\<mu> fs i k) /\n    rat_of_int (d fs k)", "."], ["proof (state)\nthis:\n  rat_of_int start =\n  rat_of_int\n   (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n    d\\<mu> fs k (k - 1) * d\\<mu> fs i k) /\n  rat_of_int (d fs k)\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "from division_to_div[OF this]"], ["proof (chain)\npicking this:\n  start =\n  (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n   d\\<mu> fs k (k - 1) * d\\<mu> fs i k) div\n  d fs k", "have id: \"?start = (d fs (Suc k) * d\\<mu> fs i (k - 1) - d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div d fs k\""], ["proof (prove)\nusing this:\n  start =\n  (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n   d\\<mu> fs k (k - 1) * d\\<mu> fs i k) div\n  d fs k\n\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n    d fs k", "unfolding start_def ji"], ["proof (prove)\nusing this:\n  d\\<mu> fs' i k =\n  (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n   d\\<mu> fs k (k - 1) * d\\<mu> fs i k) div\n  d fs k\n\ngoal (1 subgoal):\n 1. d\\<mu> fs' i k =\n    (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n     d\\<mu> fs k (k - 1) * d\\<mu> fs i k) div\n    d fs k", "."], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n  d fs k\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)\n 2. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n    d fs k =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "using * ji"], ["proof (prove)\nusing this:\n  k < i\n  j = k\n\ngoal (1 subgoal):\n 1. (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n    d fs k =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "by simp"], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (if i = k - 1 then d\\<mu> fs k j\n   else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n        else if k < i \\<and> j = k\n             then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                  d fs k\n             else if k < i \\<and> j = k - 1\n                  then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                        d\\<mu> fs i k * d fs (k - 1)) div\n                       d fs k\n                  else d\\<mu> fs i j)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "case jim1"], ["proof (state)\nthis:\n  j = k - 1\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "hence id'': \"(j = k - 1) = True\" \"(j = k) = False\""], ["proof (prove)\nusing this:\n  j = k - 1\n\ngoal (1 subgoal):\n 1. (j = k - 1) = True &&& (j = k) = False", "using k0"], ["proof (prove)\nusing this:\n  j = k - 1\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (j = k - 1) = True &&& (j = k) = False", "by auto"], ["proof (state)\nthis:\n  (j = k - 1) = True\n  (j = k) = False\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"?r (start) = ?dmu' i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int start = rat_of_int (d fs' (Suc j)) * fs'.gs.\\<mu> i j", "unfolding start_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d\\<mu> fs' i j) =\n    rat_of_int (d fs' (Suc j)) * fs'.gs.\\<mu> i j", "by fact"], ["proof (state)\nthis:\n  rat_of_int start = rat_of_int (d fs' (Suc j)) * fs'.gs.\\<mu> i j\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int start = rat_of_int (d fs' (Suc j)) * fs'.gs.\\<mu> i j\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"\\<mu> fs' i j = \\<mu> fs i (k - 1) * \\<mu> fs' k (k - 1) +\n                             \\<mu> fs i k * ?n k / ?n' (k - 1)\" (is \"_ = ?x1 + ?x2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs'.gs.\\<mu> i j =\n    fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n    fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2", "unfolding swaps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = k - 1 then fs.gs.\\<mu> k j\n     else if i = k\n          then if j = k - 1\n               then fs.gs.\\<mu> k (k - 1) *\n                    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n               else fs.gs.\\<mu> (k - 1) j\n          else if k < i \\<and> j = k\n               then fs.gs.\\<mu> i (k - 1) -\n                    fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n               else if k < i \\<and> j = k - 1\n                    then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                         fs.gs.\\<mu> i k *\n                         \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                         \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                    else fs.gs.\\<mu> i j) =\n    fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n    fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2", "unfolding jim1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = k - 1 then fs.gs.\\<mu> k (k - 1)\n     else if i = k\n          then if k - 1 = k - 1\n               then fs.gs.\\<mu> k (k - 1) *\n                    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n               else fs.gs.\\<mu> (k - 1) (k - 1)\n          else if k < i \\<and> k - 1 = k\n               then fs.gs.\\<mu> i (k - 1) -\n                    fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n               else if k < i \\<and> k - 1 = k - 1\n                    then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                         fs.gs.\\<mu> i k *\n                         \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                         \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                    else fs.gs.\\<mu> i (k - 1)) =\n    fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n    fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2", "using k0 *"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k < i\n\ngoal (1 subgoal):\n 1. (if i = k - 1 then fs.gs.\\<mu> k (k - 1)\n     else if i = k\n          then if k - 1 = k - 1\n               then fs.gs.\\<mu> k (k - 1) *\n                    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n                    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n               else fs.gs.\\<mu> (k - 1) (k - 1)\n          else if k < i \\<and> k - 1 = k\n               then fs.gs.\\<mu> i (k - 1) -\n                    fs.gs.\\<mu> k (k - 1) * fs.gs.\\<mu> i k\n               else if k < i \\<and> k - 1 = k - 1\n                    then fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n                         fs.gs.\\<mu> i k *\n                         \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n                         \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n                    else fs.gs.\\<mu> i (k - 1)) =\n    fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n    fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  fs'.gs.\\<mu> i j =\n  fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n  fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  fs'.gs.\\<mu> i j =\n  fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n  fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"?r (d fs' (Suc j)) * (?x1 + ?x2)\n              = ?r (d fs' (Suc j)) * ?x1 + ?r (d fs' (Suc j)) * ?x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc j)) *\n    (fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n     fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n     \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n    rat_of_int (d fs' (Suc j)) *\n    (fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1)) +\n    rat_of_int (d fs' (Suc j)) *\n    (fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n     \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2)", "by (simp add: ring_distribs)"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc j)) *\n  (fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n   fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n   \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n  rat_of_int (d fs' (Suc j)) *\n  (fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1)) +\n  rat_of_int (d fs' (Suc j)) *\n  (fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n   \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc j)) *\n  (fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1) +\n   fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n   \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n  rat_of_int (d fs' (Suc j)) *\n  (fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1)) +\n  rat_of_int (d fs' (Suc j)) *\n  (fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n   \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"?r (d fs' (Suc j)) * ?x1 = ?dmu' k (k - 1) * (?r (d fs k) * \\<mu> fs i (k - 1))\n            / ?r (d fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc j)) *\n    (fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1)) =\n    rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) *\n    (rat_of_int (d fs k) * fs.gs.\\<mu> i (k - 1)) /\n    rat_of_int (d fs k)", "unfolding jim1"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc (k - 1))) *\n    (fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1)) =\n    rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) *\n    (rat_of_int (d fs k) * fs.gs.\\<mu> i (k - 1)) /\n    rat_of_int (d fs k)", "using k0 dzero[of k] k"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k \\<le> m \\<Longrightarrow> d fs k \\<noteq> 0\n  k < m\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc (k - 1))) *\n    (fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1)) =\n    rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) *\n    (rat_of_int (d fs k) * fs.gs.\\<mu> i (k - 1)) /\n    rat_of_int (d fs k)", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc j)) *\n  (fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1)) =\n  rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) *\n  (rat_of_int (d fs k) * fs.gs.\\<mu> i (k - 1)) /\n  rat_of_int (d fs k)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc j)) *\n  (fs.gs.\\<mu> i (k - 1) * fs'.gs.\\<mu> k (k - 1)) =\n  rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) *\n  (rat_of_int (d fs k) * fs.gs.\\<mu> i (k - 1)) /\n  rat_of_int (d fs k)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"?dmu' k (k - 1) = ?dmu k (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n    rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)", "by fact"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc (k - 1))) * fs'.gs.\\<mu> k (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"?r (d fs k) * \\<mu> fs i (k - 1) = ?dmu i (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs k) * fs.gs.\\<mu> i (k - 1) =\n    rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)", "using k0"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs k) * fs.gs.\\<mu> i (k - 1) =\n    rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs k) * fs.gs.\\<mu> i (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs k) * fs.gs.\\<mu> i (k - 1) =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"?r (d fs' (Suc j)) = ?n' (k - 1) * ?r (d fs k) / ?n (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs' (Suc j)) =\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2", "unfolding swaps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc j = k\n     then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n          \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n          rat_of_int (d fs k)\n     else rat_of_int (d fs (Suc j))) =\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2", "unfolding jim1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc (k - 1) = k\n     then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n          \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n          rat_of_int (d fs k)\n     else rat_of_int (d fs (Suc (k - 1)))) =\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2", "using k k0"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if Suc (k - 1) = k\n     then \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 /\n          \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n          rat_of_int (d fs k)\n     else rat_of_int (d fs (Suc (k - 1)))) =\n    \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc j)) =\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs' (Suc j)) =\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"\\<dots> * ?x2 = (?n k * ?r (d fs k)) / ?n (k - 1) * \\<mu> fs i k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    (fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n     \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n    \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    fs.gs.\\<mu> i k", "using k k0 nzero'[of \"k - 1\"]"], ["proof (prove)\nusing this:\n  k < m\n  k \\<noteq> 0\n  k - 1 < m \\<Longrightarrow>\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    (fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n     \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n    \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    fs.gs.\\<mu> i k", "by simp"], ["proof (state)\nthis:\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  (fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n   \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n  \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  fs.gs.\\<mu> i k\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  (fs.gs.\\<mu> i k * \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 /\n   \\<parallel>fs'.gs.gso (k - 1)\\<parallel>\\<^sup>2) =\n  \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k) /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  fs.gs.\\<mu> i k\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"?n k * ?r (d fs k) = ?r (d fs (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k) =\n    rat_of_int (d fs (Suc k))", "unfolding LLL_d_Suc[OF invw k]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k) =\n    \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k)", ".."], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k) =\n  rat_of_int (d fs (Suc k))\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  \\<parallel>fs.gs.gso k\\<parallel>\\<^sup>2 * rat_of_int (d fs k) =\n  rat_of_int (d fs (Suc k))\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"?r (d fs (Suc k)) / ?n (k - 1) * \\<mu> fs i k = ?dmu i k / ?n (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n    fs.gs.\\<mu> i k =\n    rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc k)) /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  fs.gs.\\<mu> i k =\n  rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc k)) /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 *\n  fs.gs.\\<mu> i k =\n  rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"\\<dots> = ?dmu i k * ?r (d fs (k - 1) * d fs (k - 1)) / ?dn (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n    rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n    rat_of_int (d fs (k - 1) * d fs (k - 1)) /\n    (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n     \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)", "using dzero[of \"k - 1\"] k"], ["proof (prove)\nusing this:\n  k - 1 \\<le> m \\<Longrightarrow> d fs (k - 1) \\<noteq> 0\n  k < m\n\ngoal (1 subgoal):\n 1. rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k /\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n    rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n    rat_of_int (d fs (k - 1) * d fs (k - 1)) /\n    (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n     \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k /\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 =\n  rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n  rat_of_int (d fs (k - 1) * d fs (k - 1)) /\n  (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n   \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int start =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n  (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) /\n  rat_of_int (d fs k) +\n  rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n  rat_of_int (d fs (k - 1) * d fs (k - 1)) /\n  (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n   \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)", "have \"?r start = (?dmu k (k - 1) * ?dmu i j * ?dn (k - 1) + \n             ?dmu i k * (?r (d fs (k - 1) * d fs (k - 1) * d fs k))) / (?r (d fs k) * ?dn (k - 1))\""], ["proof (prove)\nusing this:\n  rat_of_int start =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n  (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) /\n  rat_of_int (d fs k) +\n  rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n  rat_of_int (d fs (k - 1) * d fs (k - 1)) /\n  (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n   \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. rat_of_int start =\n    (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n     (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) *\n     (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2) +\n     rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n     rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2))", "unfolding add_divide_distrib of_int_mult jim1"], ["proof (prove)\nusing this:\n  rat_of_int start =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n  (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) /\n  rat_of_int (d fs k) +\n  rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n  (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1))) /\n  (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n   \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. rat_of_int start =\n    rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n    (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) *\n    (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n     \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)) +\n    rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n    (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n     rat_of_int (d fs k)) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2))", "using dzero[of \"k - 1\"] nzero[of \"k - 1\"] k dzero[of k]"], ["proof (prove)\nusing this:\n  rat_of_int start =\n  rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n  (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) /\n  rat_of_int (d fs k) +\n  rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n  (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1))) /\n  (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n   \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)\n  k - 1 \\<le> m \\<Longrightarrow> d fs (k - 1) \\<noteq> 0\n  k - 1 < m \\<Longrightarrow>\n  \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2 \\<noteq> 0\n  k < m\n  k \\<le> m \\<Longrightarrow> d fs k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int start =\n    rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n    (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> i (k - 1)) *\n    (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n     \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)) +\n    rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n    (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n     rat_of_int (d fs k)) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2))", "by auto"], ["proof (state)\nthis:\n  rat_of_int start =\n  (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) *\n   (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2) +\n   rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n   rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n  (rat_of_int (d fs k) *\n   (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2))\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  rat_of_int start =\n  (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) *\n   (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2) +\n   rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n   rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n  (rat_of_int (d fs k) *\n   (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2))\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"\\<dots> = (?r (d\\<mu> fs k (k - 1)) * ?r (d\\<mu> fs i j) * (?r (d fs k) * ?r (d fs (k - 1))) + \n             ?r (d\\<mu> fs i k) * (?r (d fs (k - 1) * d fs (k - 1) * d fs k))) / (?r (d fs k) * (?r (d fs k) * ?r (d fs (k - 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n     (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) *\n     (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2) +\n     rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n     rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n      \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)) =\n    (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))) +\n     rat_of_int (d\\<mu> fs i k) *\n     rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))))", "unfolding dn_km1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n     (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))) +\n     rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n     rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1)))) =\n    (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))) +\n     rat_of_int (d\\<mu> fs i k) *\n     rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))))", "by (subst (1 2 3) rat, insert k k0 i * j, auto)"], ["proof (state)\nthis:\n  (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) *\n   (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2) +\n   rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n   rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n  (rat_of_int (d fs k) *\n   (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)) =\n  (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) *\n   (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))) +\n   rat_of_int (d\\<mu> fs i k) *\n   rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n  (rat_of_int (d fs k) * (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))))\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  (rat_of_int (d fs (Suc (k - 1))) * fs.gs.\\<mu> k (k - 1) *\n   (rat_of_int (d fs (Suc j)) * fs.gs.\\<mu> i j) *\n   (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2) +\n   rat_of_int (d fs (Suc k)) * fs.gs.\\<mu> i k *\n   rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n  (rat_of_int (d fs k) *\n   (rat_of_int (d fs (k - 1) * d fs (k - 1)) *\n    \\<parallel>fs.gs.gso (k - 1)\\<parallel>\\<^sup>2)) =\n  (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) *\n   (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))) +\n   rat_of_int (d\\<mu> fs i k) *\n   rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n  (rat_of_int (d fs k) * (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))))\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"\\<dots> = (?r (d\\<mu> fs k (k - 1)) * ?r (d\\<mu> fs i j) + ?r (d\\<mu> fs i k) * ?r (d fs (k - 1))) \n              / ?r (d fs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))) +\n     rat_of_int (d\\<mu> fs i k) *\n     rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1)))) =\n    (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) +\n     rat_of_int (d\\<mu> fs i k) * rat_of_int (d fs (k - 1))) /\n    rat_of_int (d fs k)", "unfolding of_int_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))) +\n     rat_of_int (d\\<mu> fs i k) *\n     (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n      rat_of_int (d fs k))) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1)))) =\n    (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) +\n     rat_of_int (d\\<mu> fs i k) * rat_of_int (d fs (k - 1))) /\n    rat_of_int (d fs k)", "using dzero[of k] dzero[of \"k - 1\"] k k0"], ["proof (prove)\nusing this:\n  k \\<le> m \\<Longrightarrow> d fs k \\<noteq> 0\n  k - 1 \\<le> m \\<Longrightarrow> d fs (k - 1) \\<noteq> 0\n  k < m\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))) +\n     rat_of_int (d\\<mu> fs i k) *\n     (rat_of_int (d fs (k - 1)) * rat_of_int (d fs (k - 1)) *\n      rat_of_int (d fs k))) /\n    (rat_of_int (d fs k) *\n     (rat_of_int (d fs k) * rat_of_int (d fs (k - 1)))) =\n    (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) +\n     rat_of_int (d\\<mu> fs i k) * rat_of_int (d fs (k - 1))) /\n    rat_of_int (d fs k)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) *\n   (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))) +\n   rat_of_int (d\\<mu> fs i k) *\n   rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n  (rat_of_int (d fs k) *\n   (rat_of_int (d fs k) * rat_of_int (d fs (k - 1)))) =\n  (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) +\n   rat_of_int (d\\<mu> fs i k) * rat_of_int (d fs (k - 1))) /\n  rat_of_int (d fs k)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "also"], ["proof (state)\nthis:\n  (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) *\n   (rat_of_int (d fs k) * rat_of_int (d fs (k - 1))) +\n   rat_of_int (d\\<mu> fs i k) *\n   rat_of_int (d fs (k - 1) * d fs (k - 1) * d fs k)) /\n  (rat_of_int (d fs k) *\n   (rat_of_int (d fs k) * rat_of_int (d fs (k - 1)))) =\n  (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) +\n   rat_of_int (d\\<mu> fs i k) * rat_of_int (d fs (k - 1))) /\n  rat_of_int (d fs k)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "have \"\\<dots> = ?r (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) / ?r (d fs k)\" \n            (is \"_ = of_int ?x / _\" )"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) +\n     rat_of_int (d\\<mu> fs i k) * rat_of_int (d fs (k - 1))) /\n    rat_of_int (d fs k) =\n    rat_of_int\n     (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) /\n    rat_of_int (d fs k)", "by simp"], ["proof (state)\nthis:\n  (rat_of_int (d\\<mu> fs k (k - 1)) * rat_of_int (d\\<mu> fs i j) +\n   rat_of_int (d\\<mu> fs i k) * rat_of_int (d fs (k - 1))) /\n  rat_of_int (d fs k) =\n  rat_of_int\n   (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) /\n  rat_of_int (d fs k)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "finally"], ["proof (chain)\npicking this:\n  rat_of_int start =\n  rat_of_int\n   (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) /\n  rat_of_int (d fs k)", "have \"?r start = ?r ?x / ?r (d fs k)\""], ["proof (prove)\nusing this:\n  rat_of_int start =\n  rat_of_int\n   (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) /\n  rat_of_int (d fs k)\n\ngoal (1 subgoal):\n 1. rat_of_int start =\n    rat_of_int\n     (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) /\n    rat_of_int (d fs k)", "."], ["proof (state)\nthis:\n  rat_of_int start =\n  rat_of_int\n   (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) /\n  rat_of_int (d fs k)\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "from division_to_div[OF this]"], ["proof (chain)\npicking this:\n  start =\n  (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) div\n  d fs k", "have id: \"?start = (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) div (d fs k)\""], ["proof (prove)\nusing this:\n  start =\n  (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) div\n  d fs k\n\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) div\n    d fs k", "unfolding start_def"], ["proof (prove)\nusing this:\n  d\\<mu> fs' i j =\n  (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) div\n  d fs k\n\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) div\n    d fs k", "."], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) div\n  d fs k\n\ngoal (1 subgoal):\n 1. j = k - 1 \\<Longrightarrow>\n    d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs' i j =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) div\n    d fs k =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "using * jim1 k0"], ["proof (prove)\nusing this:\n  k < i\n  j = k - 1\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (d\\<mu> fs k (k - 1) * d\\<mu> fs i j + d\\<mu> fs i k * d fs (k - 1)) div\n    d fs k =\n    (if i = k - 1 then d\\<mu> fs k j\n     else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n          else if k < i \\<and> j = k\n               then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                     d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                    d fs k\n               else if k < i \\<and> j = k - 1\n                    then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                          d\\<mu> fs i k * d fs (k - 1)) div\n                         d fs k\n                    else d\\<mu> fs i j)", "by auto"], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (if i = k - 1 then d\\<mu> fs k j\n   else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n        else if k < i \\<and> j = k\n             then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                  d fs k\n             else if k < i \\<and> j = k - 1\n                  then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                        d\\<mu> fs i k * d fs (k - 1)) div\n                       d fs k\n                  else d\\<mu> fs i j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (if i = k - 1 then d\\<mu> fs k j\n   else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n        else if k < i \\<and> j = k\n             then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                  d fs k\n             else if k < i \\<and> j = k - 1\n                  then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                        d\\<mu> fs i k * d fs (k - 1)) div\n                       d fs k\n                  else d\\<mu> fs i j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (if i = k - 1 then d\\<mu> fs k j\n   else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n        else if k < i \\<and> j = k\n             then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                  d fs k\n             else if k < i \\<and> j = k - 1\n                  then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                        d\\<mu> fs i k * d fs (k - 1)) div\n                       d fs k\n                  else d\\<mu> fs i j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d\\<mu> fs' i j =\n  (if i = k - 1 then d\\<mu> fs k j\n   else if i = k \\<and> j \\<noteq> k - 1 then d\\<mu> fs (k - 1) j\n        else if k < i \\<and> j = k\n             then (d fs (Suc k) * d\\<mu> fs i (k - 1) -\n                   d\\<mu> fs k (k - 1) * d\\<mu> fs i j) div\n                  d fs k\n             else if k < i \\<and> j = k - 1\n                  then (d\\<mu> fs k (k - 1) * d\\<mu> fs i j +\n                        d\\<mu> fs i k * d fs (k - 1)) div\n                       d fs k\n                  else d\\<mu> fs i j)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 < m; ?j3 < ?i3\\<rbrakk>\n  \\<Longrightarrow> d\\<mu> fs' ?i3 ?j3 =\n                    (if ?i3 = k - 1 then d\\<mu> fs k ?j3\n                     else if ?i3 = k \\<and> ?j3 \\<noteq> k - 1\n                          then d\\<mu> fs (k - 1) ?j3\n                          else if k < ?i3 \\<and> ?j3 = k\n                               then (d fs (Suc k) * d\\<mu> fs ?i3 (k - 1) -\n                                     d\\<mu> fs k (k - 1) *\n                                     d\\<mu> fs ?i3 ?j3) div\n                                    d fs k\n                               else if k < ?i3 \\<and> ?j3 = k - 1\n                                    then (d\\<mu> fs k (k - 1) *\n    d\\<mu> fs ?i3 ?j3 +\n    d\\<mu> fs ?i3 k * d fs (k - 1)) div\n   d fs k\n                                    else d\\<mu> fs ?i3 ?j3)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Implementation of LLL via Integer Operations and Arrays\\<close>"], ["", "hide_fact (open) Word.inc_i"], ["", "type_synonym LLL_dmu_d_state = \"int vec list_repr \\<times> int iarray iarray \\<times> int iarray\""], ["", "fun fi_state :: \"LLL_dmu_d_state \\<Rightarrow> int vec\" where\n  \"fi_state (f,mu,d) = get_nth_i f\""], ["", "fun fim1_state :: \"LLL_dmu_d_state \\<Rightarrow> int vec\" where\n  \"fim1_state (f,mu,d) = get_nth_im1 f\""], ["", "fun d_state :: \"LLL_dmu_d_state \\<Rightarrow> nat \\<Rightarrow> int\" where\n  \"d_state (f,mu,d) i = d !! i\""], ["", "fun fs_state :: \"LLL_dmu_d_state \\<Rightarrow> int vec list\" where\n  \"fs_state (f,mu,d) = of_list_repr f\""], ["", "fun upd_fi_mu_state :: \"LLL_dmu_d_state \\<Rightarrow> nat \\<Rightarrow> int vec \\<Rightarrow> int iarray \\<Rightarrow> LLL_dmu_d_state\" where\n  \"upd_fi_mu_state (f,mu,d) i fi mu_i = (update_i f fi, iarray_update mu i mu_i,d)\""], ["", "fun small_fs_state :: \"LLL_dmu_d_state \\<Rightarrow> int vec list\" where\n  \"small_fs_state (f,_) = fst f\""], ["", "fun dmu_ij_state :: \"LLL_dmu_d_state \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> int\" where\n  \"dmu_ij_state (f,mu,_) i j = mu !! i !! j\""], ["", "fun inc_state :: \"LLL_dmu_d_state \\<Rightarrow> LLL_dmu_d_state\" where\n  \"inc_state (f,mu,d) = (inc_i f, mu, d)\""], ["", "fun basis_reduction_add_rows_loop where\n  \"basis_reduction_add_rows_loop n state i j [] = state\"\n| \"basis_reduction_add_rows_loop n state i sj (fj # fjs) = (\n     let fi = fi_state state;\n         dsj = d_state state sj;\n         j = sj - 1;\n         c = round_num_denom (dmu_ij_state state i j) dsj;\n         state' = (if c = 0 then state else upd_fi_mu_state state i (vec n (\\<lambda> i. fi $ i - c * fj $ i))\n             (IArray.of_fun (\\<lambda> jj. let mu = dmu_ij_state state i jj in\n                  if jj < j then mu - c * dmu_ij_state state j jj else\n                  if jj = j then mu - dsj * c else mu) i))\n      in basis_reduction_add_rows_loop n state' i j fjs)\""], ["", "text \\<open>More efficient code which breaks abstraction of state.\\<close>"], ["", "lemma basis_reduction_add_rows_loop_code:\n  \"basis_reduction_add_rows_loop n state i sj (fj # fjs) = (\n     case state of ((f1,f2),mus,ds) \\<Rightarrow>\n     let fi = hd f2;\n         j = sj - 1;\n         dsj = ds !! sj;\n         mui = mus !! i;\n         c = round_num_denom (mui !! j) dsj\n      in (if c = 0 then\n          basis_reduction_add_rows_loop n state i j fjs\n         else\n             let muj = mus !! j in\n           basis_reduction_add_rows_loop n\n                ((f1,  vec n (\\<lambda> i. fi $ i - c * fj $ i) # tl f2), iarray_update mus i\n             (IArray.of_fun (\\<lambda> jj. let mu = mui !! jj in\n                  if jj < j then mu - c * muj !! jj else\n                  if jj = j then mu - dsj * c else mu) i),\n                  ds) i j fjs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_reduction_add_rows_loop n state i sj (fj # fjs) =\n    (case state of\n     ((f1, f2), mus, ds) \\<Rightarrow>\n       let fi = hd f2; j = sj - 1; dsj = ds !! sj; mui = mus !! i;\n           c = round_num_denom (mui !! j) dsj\n       in if c = 0 then basis_reduction_add_rows_loop n state i j fjs\n          else let muj = mus !! j\n               in basis_reduction_add_rows_loop n\n                   ((f1, vec n (\\<lambda>i. fi $ i - c * fj $ i) # tl f2),\n                    iarray_update mus i\n                     (IArray.of_fun\n                       (\\<lambda>jj.\n                           let mu = mui !! jj\n                           in if jj < j then mu - c * muj !! jj\n                              else if jj = j then mu - dsj * c else mu)\n                       i),\n                    ds)\n                   i j fjs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. basis_reduction_add_rows_loop n state i sj (fj # fjs) =\n    (case state of\n     ((f1, f2), mus, ds) \\<Rightarrow>\n       let fi = hd f2; j = sj - 1; dsj = ds !! sj; mui = mus !! i;\n           c = round_num_denom (mui !! j) dsj\n       in if c = 0 then basis_reduction_add_rows_loop n state i j fjs\n          else let muj = mus !! j\n               in basis_reduction_add_rows_loop n\n                   ((f1, vec n (\\<lambda>i. fi $ i - c * fj $ i) # tl f2),\n                    iarray_update mus i\n                     (IArray.of_fun\n                       (\\<lambda>jj.\n                           let mu = mui !! jj\n                           in if jj < j then mu - c * muj !! jj\n                              else if jj = j then mu - dsj * c else mu)\n                       i),\n                    ds)\n                   i j fjs)", "obtain f1 f2 mus ds where state: \"state = ((f1,f2),mus, ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f1 f2 mus ds.\n        state = ((f1, f2), mus, ds) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases state, auto)"], ["proof (state)\nthis:\n  state = ((f1, f2), mus, ds)\n\ngoal (1 subgoal):\n 1. basis_reduction_add_rows_loop n state i sj (fj # fjs) =\n    (case state of\n     ((f1, f2), mus, ds) \\<Rightarrow>\n       let fi = hd f2; j = sj - 1; dsj = ds !! sj; mui = mus !! i;\n           c = round_num_denom (mui !! j) dsj\n       in if c = 0 then basis_reduction_add_rows_loop n state i j fjs\n          else let muj = mus !! j\n               in basis_reduction_add_rows_loop n\n                   ((f1, vec n (\\<lambda>i. fi $ i - c * fj $ i) # tl f2),\n                    iarray_update mus i\n                     (IArray.of_fun\n                       (\\<lambda>jj.\n                           let mu = mui !! jj\n                           in if jj < j then mu - c * muj !! jj\n                              else if jj = j then mu - dsj * c else mu)\n                       i),\n                    ds)\n                   i j fjs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_reduction_add_rows_loop n state i sj (fj # fjs) =\n    (case state of\n     ((f1, f2), mus, ds) \\<Rightarrow>\n       let fi = hd f2; j = sj - 1; dsj = ds !! sj; mui = mus !! i;\n           c = round_num_denom (mui !! j) dsj\n       in if c = 0 then basis_reduction_add_rows_loop n state i j fjs\n          else let muj = mus !! j\n               in basis_reduction_add_rows_loop n\n                   ((f1, vec n (\\<lambda>i. fi $ i - c * fj $ i) # tl f2),\n                    iarray_update mus i\n                     (IArray.of_fun\n                       (\\<lambda>jj.\n                           let mu = mui !! jj\n                           in if jj < j then mu - c * muj !! jj\n                              else if jj = j then mu - dsj * c else mu)\n                       i),\n                    ds)\n                   i j fjs)", "unfolding basis_reduction_add_rows_loop.simps Let_def\n     state split dmu_ij_state.simps fi_state.simps get_nth_i_def update_i_def upd_fi_mu_state.simps\n     d_state.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_reduction_add_rows_loop n\n     (if round_num_denom (mus !! i !! (sj - 1)) (ds !! sj) = 0\n      then ((f1, f2), mus, ds)\n      else ((fst (f1, f2),\n             vec n\n              (\\<lambda>ia.\n                  hd (snd (f1, f2)) $ ia -\n                  round_num_denom (mus !! i !! (sj - 1)) (ds !! sj) *\n                  fj $ ia) #\n             tl (snd (f1, f2))),\n            iarray_update mus i\n             (IArray.of_fun\n               (\\<lambda>jj.\n                   if jj < sj - 1\n                   then mus !! i !! jj -\n                        round_num_denom (mus !! i !! (sj - 1)) (ds !! sj) *\n                        mus !! (sj - 1) !! jj\n                   else if jj = sj - 1\n                        then mus !! i !! jj -\n                             ds !! sj *\n                             round_num_denom (mus !! i !! (sj - 1))\n                              (ds !! sj)\n                        else mus !! i !! jj)\n               i),\n            ds))\n     i (sj - 1) fjs =\n    (if round_num_denom (mus !! i !! (sj - 1)) (ds !! sj) = 0\n     then basis_reduction_add_rows_loop n ((f1, f2), mus, ds) i (sj - 1) fjs\n     else basis_reduction_add_rows_loop n\n           ((f1,\n             vec n\n              (\\<lambda>ia.\n                  hd f2 $ ia -\n                  round_num_denom (mus !! i !! (sj - 1)) (ds !! sj) *\n                  fj $ ia) #\n             tl f2),\n            iarray_update mus i\n             (IArray.of_fun\n               (\\<lambda>jj.\n                   if jj < sj - 1\n                   then mus !! i !! jj -\n                        round_num_denom (mus !! i !! (sj - 1)) (ds !! sj) *\n                        mus !! (sj - 1) !! jj\n                   else if jj = sj - 1\n                        then mus !! i !! jj -\n                             ds !! sj *\n                             round_num_denom (mus !! i !! (sj - 1))\n                              (ds !! sj)\n                        else mus !! i !! jj)\n               i),\n            ds)\n           i (sj - 1) fjs)", "by simp"], ["proof (state)\nthis:\n  basis_reduction_add_rows_loop n state i sj (fj # fjs) =\n  (case state of\n   ((f1, f2), mus, ds) \\<Rightarrow>\n     let fi = hd f2; j = sj - 1; dsj = ds !! sj; mui = mus !! i;\n         c = round_num_denom (mui !! j) dsj\n     in if c = 0 then basis_reduction_add_rows_loop n state i j fjs\n        else let muj = mus !! j\n             in basis_reduction_add_rows_loop n\n                 ((f1, vec n (\\<lambda>i. fi $ i - c * fj $ i) # tl f2),\n                  iarray_update mus i\n                   (IArray.of_fun\n                     (\\<lambda>jj.\n                         let mu = mui !! jj\n                         in if jj < j then mu - c * muj !! jj\n                            else if jj = j then mu - dsj * c else mu)\n                     i),\n                  ds)\n                 i j fjs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas basis_reduction_add_rows_loop_code_equations =\n  basis_reduction_add_rows_loop.simps(1) basis_reduction_add_rows_loop_code"], ["", "declare basis_reduction_add_rows_loop_code_equations[code]"], ["", "definition basis_reduction_add_rows where\n  \"basis_reduction_add_rows n upw i state =\n     (if upw\n        then basis_reduction_add_rows_loop n state i i (small_fs_state state)\n        else state)\""], ["", "context\n  fixes \\<alpha> :: rat and n m :: nat and fs_init :: \"int vec list\"\nbegin"], ["", "definition swap_mu :: \"int iarray iarray \\<Rightarrow> nat \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int iarray iarray\" where\n  \"swap_mu dmu i dmu_i_im1 dim1 di dsi = (let im1 = i - 1 in\n       IArray.of_fun (\\<lambda> ii. if ii < im1 then dmu !! ii else\n       if ii > i then let dmu_ii = dmu !! ii in\n           IArray.of_fun (\\<lambda> j. let dmu_ii_j = dmu_ii !! j in\n               if j = i then (dsi * dmu_ii !! im1 - dmu_i_im1 * dmu_ii_j) div di\n               else if j = im1 then (dmu_i_im1 * dmu_ii_j + dmu_ii !! i * dim1) div di\n               else dmu_ii_j) ii else\n       if ii = i then let mu_im1 = dmu !! im1 in\n           IArray.of_fun (\\<lambda> j. if j = im1 then dmu_i_im1 else mu_im1 !! j) ii\n         else IArray.of_fun (\\<lambda> j. dmu !! i !! j) ii) \\<comment> \\<open>ii = i - 1\\<close>\n       m)\""], ["", "definition basis_reduction_swap where\n  \"basis_reduction_swap i state = (let\n       di = d_state state i;\n       dsi = d_state state (Suc i);\n       dim1 = d_state state (i - 1);\n       fi = fi_state state;\n       fim1 = fim1_state state;\n       dmu_i_im1 = dmu_ij_state state i (i - 1);\n       fi' = fim1;\n       fim1' = fi\n     in (case state of (f,dmus,djs) \\<Rightarrow>\n         (False, i - 1,\n           (dec_i (update_im1 (update_i f fi') fim1'),\n            swap_mu dmus i dmu_i_im1 dim1 di dsi,\n            iarray_update djs i ((dsi * dim1 + dmu_i_im1 * dmu_i_im1) div di)))))\""], ["", "text \\<open>More efficient code which breaks abstraction of state.\\<close>"], ["", "lemma basis_reduction_swap_code[code]:\n  \"basis_reduction_swap i ((f1,f2), dmus, ds) = (let\n       di = ds !! i;\n       dsi = ds !! (Suc i);\n       im1 = i - 1;\n       dim1 = ds !! im1;\n       fi = hd f2;\n       fim1 = hd f1;\n       dmu_i_im1 = dmus !! i !! im1;\n       fi' = fim1;\n       fim1' = fi\n     in (False, im1,\n           ((tl f1,fim1' # fi' # tl f2),\n            swap_mu dmus i dmu_i_im1 dim1 di dsi,\n            iarray_update ds i ((dsi * dim1 + dmu_i_im1 * dmu_i_im1) div di))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.basis_reduction_swap i ((f1, f2), dmus, ds) =\n    (let di = ds !! i; dsi = ds !! Suc i; im1 = i - 1; dim1 = ds !! im1;\n         fi = hd f2; fim1 = hd f1; dmu_i_im1 = dmus !! i !! im1; fi' = fim1;\n         fim1' = fi\n     in (False, im1, (tl f1, fim1' # fi' # tl f2),\n         local.swap_mu dmus i dmu_i_im1 dim1 di dsi,\n         iarray_update ds i ((dsi * dim1 + dmu_i_im1 * dmu_i_im1) div di)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.basis_reduction_swap i ((f1, f2), dmus, ds) =\n    (let di = ds !! i; dsi = ds !! Suc i; im1 = i - 1; dim1 = ds !! im1;\n         fi = hd f2; fim1 = hd f1; dmu_i_im1 = dmus !! i !! im1; fi' = fim1;\n         fim1' = fi\n     in (False, im1, (tl f1, fim1' # fi' # tl f2),\n         local.swap_mu dmus i dmu_i_im1 dim1 di dsi,\n         iarray_update ds i ((dsi * dim1 + dmu_i_im1 * dmu_i_im1) div di)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.basis_reduction_swap i ((f1, f2), dmus, ds) =\n    (let di = ds !! i; dsi = ds !! Suc i; im1 = i - 1; dim1 = ds !! im1;\n         fi = hd f2; fim1 = hd f1; dmu_i_im1 = dmus !! i !! im1; fi' = fim1;\n         fim1' = fi\n     in (False, im1, (tl f1, fim1' # fi' # tl f2),\n         local.swap_mu dmus i dmu_i_im1 dim1 di dsi,\n         iarray_update ds i ((dsi * dim1 + dmu_i_im1 * dmu_i_im1) div di)))", "unfolding basis_reduction_swap_def split Let_def fi_state.simps fim1_state.simps\n    d_state.simps get_nth_im1_def get_nth_i_def update_i_def update_im1_def dec_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (False, i - 1,\n     (tl (hd (snd (f1, f2)) #\n          tl (fst (fst (f1, f2), hd (fst (f1, f2)) # tl (snd (f1, f2))))),\n      hd (hd (snd (f1, f2)) #\n          tl (fst (fst (f1, f2), hd (fst (f1, f2)) # tl (snd (f1, f2))))) #\n      snd (fst (f1, f2), hd (fst (f1, f2)) # tl (snd (f1, f2)))),\n     local.swap_mu dmus i (dmu_ij_state ((f1, f2), dmus, ds) i (i - 1))\n      (ds !! (i - 1)) (ds !! i) (ds !! Suc i),\n     iarray_update ds i\n      ((ds !! Suc i * ds !! (i - 1) +\n        dmu_ij_state ((f1, f2), dmus, ds) i (i - 1) *\n        dmu_ij_state ((f1, f2), dmus, ds) i (i - 1)) div\n       ds !! i)) =\n    (False, i - 1, (tl f1, hd f2 # hd f1 # tl f2),\n     local.swap_mu dmus i (dmus !! i !! (i - 1)) (ds !! (i - 1)) (ds !! i)\n      (ds !! Suc i),\n     iarray_update ds i\n      ((ds !! Suc i * ds !! (i - 1) +\n        dmus !! i !! (i - 1) * dmus !! i !! (i - 1)) div\n       ds !! i))", "by simp"], ["proof (state)\nthis:\n  local.basis_reduction_swap i ((f1, f2), dmus, ds) =\n  (let di = ds !! i; dsi = ds !! Suc i; im1 = i - 1; dim1 = ds !! im1;\n       fi = hd f2; fim1 = hd f1; dmu_i_im1 = dmus !! i !! im1; fi' = fim1;\n       fim1' = fi\n   in (False, im1, (tl f1, fim1' # fi' # tl f2),\n       local.swap_mu dmus i dmu_i_im1 dim1 di dsi,\n       iarray_update ds i ((dsi * dim1 + dmu_i_im1 * dmu_i_im1) div di)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition basis_reduction_step where\n  \"basis_reduction_step upw i state = (if i = 0 then (True, Suc i, inc_state state)\n     else let\n       state' = basis_reduction_add_rows n upw i state;\n       di = d_state state' i;\n       dsi = d_state state' (Suc i);\n       dim1 = d_state state' (i - 1);\n       (num,denom) = quotient_of \\<alpha>\n    in if di * di * denom \\<le> num * dim1 * dsi then\n          (True, Suc i, inc_state state')\n        else basis_reduction_swap i state')\""], ["", "partial_function (tailrec) basis_reduction_main where\n  [code]: \"basis_reduction_main upw i state = (if i < m\n     then case basis_reduction_step upw i state of (upw',i',state') \\<Rightarrow>\n       basis_reduction_main upw' i' state' else\n       state)\""], ["", "definition \"initial_state = (let\n  dmus = d\\<mu>_impl fs_init;\n  ds = IArray.of_fun (\\<lambda> i. if i = 0 then 1 else let i1 = i - 1 in dmus !! i1 !! i1) (Suc m);\n  dmus' = IArray.of_fun (\\<lambda> i. let row_i = dmus !! i in\n       IArray.of_fun (\\<lambda> j. row_i !! j) i) m\n  in (([], fs_init), dmus', ds) :: LLL_dmu_d_state)\""], ["", "end"], ["", "definition \"basis_reduction \\<alpha> n fs = (let m = length fs in\n  basis_reduction_main \\<alpha> n m True 0 (initial_state m fs))\""], ["", "definition \"reduce_basis \\<alpha> fs = (case fs of Nil \\<Rightarrow> fs | Cons f _ \\<Rightarrow> fs_state (basis_reduction \\<alpha> (dim_vec f) fs))\""], ["", "definition \"short_vector \\<alpha> fs = hd (reduce_basis \\<alpha> fs)\""], ["", "lemma map_rev_Suc: \"map f (rev [0..<Suc j]) = f j # map f (rev [0..< j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (rev [0..<Suc j]) = f j # map f (rev [0..<j])", "by simp"], ["", "context LLL\nbegin"], ["", "definition mu_repr :: \"int iarray iarray \\<Rightarrow> int vec list \\<Rightarrow> bool\" where\n  \"mu_repr mu fs = (mu = IArray.of_fun (\\<lambda> i. IArray.of_fun (d\\<mu> fs i) i) m)\""], ["", "definition d_repr :: \"int iarray \\<Rightarrow> int vec list \\<Rightarrow> bool\" where\n  \"d_repr ds fs = (ds = IArray.of_fun (d fs) (Suc m))\""], ["", "fun LLL_impl_inv :: \"LLL_dmu_d_state \\<Rightarrow> nat \\<Rightarrow> int vec list \\<Rightarrow> bool\" where\n  \"LLL_impl_inv (f,mu,ds) i fs = (list_repr i f (map (\\<lambda> j. fs ! j) [0..<m])\n    \\<and> d_repr ds fs\n    \\<and> mu_repr mu fs)\""], ["", "context fixes state i fs upw f mu ds\n  assumes impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and state: \"state = (f,mu,ds)\"\nbegin"], ["", "lemma to_list_repr: \"list_repr i f (map ((!) fs) [0..<m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_repr i f (map ((!) fs) [0..<m])", "using impl[unfolded state]"], ["proof (prove)\nusing this:\n  LLL_impl_inv (f, mu, ds) i fs\n\ngoal (1 subgoal):\n 1. list_repr i f (map ((!) fs) [0..<m])", "by auto"], ["", "lemma to_mu_repr: \"mu_repr mu fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mu_repr mu fs", "using impl[unfolded state]"], ["proof (prove)\nusing this:\n  LLL_impl_inv (f, mu, ds) i fs\n\ngoal (1 subgoal):\n 1. mu_repr mu fs", "by auto"], ["", "lemma to_d_repr: \"d_repr ds fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_repr ds fs", "using impl[unfolded state]"], ["proof (prove)\nusing this:\n  LLL_impl_inv (f, mu, ds) i fs\n\ngoal (1 subgoal):\n 1. d_repr ds fs", "by auto"], ["", "lemma dmu_ij_state: assumes j: \"j < ii\"\n  and ii: \"ii < m\"\nshows \"dmu_ij_state state ii j = d\\<mu> fs ii j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_ij_state state ii j = d\\<mu> fs ii j", "unfolding to_mu_repr[unfolded mu_repr_def] state"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_ij_state\n     (f, IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m, ds) ii\n     j =\n    d\\<mu> fs ii j", "using ii j"], ["proof (prove)\nusing this:\n  ii < m\n  j < ii\n\ngoal (1 subgoal):\n 1. dmu_ij_state\n     (f, IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m, ds) ii\n     j =\n    d\\<mu> fs ii j", "by auto"], ["", "lemma fi_state: \"i < m \\<Longrightarrow> fi_state state = fs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow> fi_state state = fs ! i", "using get_nth_i[OF to_list_repr(1)]"], ["proof (prove)\nusing this:\n  i < length (map ((!) fs) [0..<m]) \\<Longrightarrow>\n  get_nth_i f = map ((!) fs) [0..<m] ! i\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow> fi_state state = fs ! i", "unfolding state"], ["proof (prove)\nusing this:\n  i < length (map ((!) fs) [0..<m]) \\<Longrightarrow>\n  get_nth_i f = map ((!) fs) [0..<m] ! i\n\ngoal (1 subgoal):\n 1. i < m \\<Longrightarrow> fi_state (f, mu, ds) = fs ! i", "by auto"], ["", "lemma fim1_state: \"i < m \\<Longrightarrow> i \\<noteq> 0 \\<Longrightarrow> fim1_state state = fs ! (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < m; i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fim1_state state = fs ! (i - 1)", "using get_nth_im1[OF to_list_repr(1)]"], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<Longrightarrow>\n  get_nth_im1 f = map ((!) fs) [0..<m] ! (i - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < m; i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fim1_state state = fs ! (i - 1)", "unfolding state"], ["proof (prove)\nusing this:\n  i \\<noteq> 0 \\<Longrightarrow>\n  get_nth_im1 f = map ((!) fs) [0..<m] ! (i - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < m; i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fim1_state (f, mu, ds) = fs ! (i - 1)", "by auto"], ["", "lemma d_state: \"ii \\<le> m \\<Longrightarrow> d_state state ii = d fs ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ii \\<le> m \\<Longrightarrow> d_state state ii = d fs ii", "using to_d_repr[unfolded d_repr_def] state"], ["proof (prove)\nusing this:\n  ds = IArray.of_fun (d fs) (Suc m)\n  state = (f, mu, ds)\n\ngoal (1 subgoal):\n 1. ii \\<le> m \\<Longrightarrow> d_state state ii = d fs ii", "unfolding state"], ["proof (prove)\nusing this:\n  ds = IArray.of_fun (d fs) (Suc m)\n  (f, mu, ds) = (f, mu, ds)\n\ngoal (1 subgoal):\n 1. ii \\<le> m \\<Longrightarrow> d_state (f, mu, ds) ii = d fs ii", "by (auto simp: nth_append)"], ["", "lemma fs_state: \"length fs = m \\<Longrightarrow> fs_state state = fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length fs = m \\<Longrightarrow> fs_state state = fs", "using of_list_repr[OF to_list_repr(1)]"], ["proof (prove)\nusing this:\n  of_list_repr f = map ((!) fs) [0..<m]\n\ngoal (1 subgoal):\n 1. length fs = m \\<Longrightarrow> fs_state state = fs", "unfolding state"], ["proof (prove)\nusing this:\n  of_list_repr f = map ((!) fs) [0..<m]\n\ngoal (1 subgoal):\n 1. length fs = m \\<Longrightarrow> fs_state (f, mu, ds) = fs", "by (auto simp: o_def intro!: nth_equalityI)"], ["", "lemma LLL_state_inc_state: assumes i: \"i < m\"\nshows \"LLL_impl_inv (inc_state state) (Suc i) fs\"\n  \"fs_state (inc_state state) = fs_state state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv (inc_state state) (Suc i) fs &&&\n    fs_state (inc_state state) = fs_state state", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv (inc_state state) (Suc i) fs\n 2. fs_state (inc_state state) = fs_state state", "from LLL_invD[OF inv]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i", "have len: \"length fs = m\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. length fs = m", "by auto"], ["proof (state)\nthis:\n  length fs = m\n\ngoal (2 subgoals):\n 1. LLL_impl_inv (inc_state state) (Suc i) fs\n 2. fs_state (inc_state state) = fs_state state", "note inc = inc_i[OF to_list_repr(1)]"], ["proof (state)\nthis:\n  i < length (map ((!) fs) [0..<m]) \\<Longrightarrow>\n  list_repr (Suc i) (inc_i f) (map ((!) fs) [0..<m])\n\ngoal (2 subgoals):\n 1. LLL_impl_inv (inc_state state) (Suc i) fs\n 2. fs_state (inc_state state) = fs_state state", "from inc i impl"], ["proof (chain)\npicking this:\n  i < length (map ((!) fs) [0..<m]) \\<Longrightarrow>\n  list_repr (Suc i) (inc_i f) (map ((!) fs) [0..<m])\n  i < m\n  LLL_impl_inv state i fs", "show \"LLL_impl_inv (inc_state state) (Suc i) fs\""], ["proof (prove)\nusing this:\n  i < length (map ((!) fs) [0..<m]) \\<Longrightarrow>\n  list_repr (Suc i) (inc_i f) (map ((!) fs) [0..<m])\n  i < m\n  LLL_impl_inv state i fs\n\ngoal (1 subgoal):\n 1. LLL_impl_inv (inc_state state) (Suc i) fs", "unfolding state"], ["proof (prove)\nusing this:\n  i < length (map ((!) fs) [0..<m]) \\<Longrightarrow>\n  list_repr (Suc i) (inc_i f) (map ((!) fs) [0..<m])\n  i < m\n  LLL_impl_inv (f, mu, ds) i fs\n\ngoal (1 subgoal):\n 1. LLL_impl_inv (inc_state (f, mu, ds)) (Suc i) fs", "by auto"], ["proof (state)\nthis:\n  LLL_impl_inv (inc_state state) (Suc i) fs\n\ngoal (1 subgoal):\n 1. fs_state (inc_state state) = fs_state state", "from of_list_repr[OF inc(1)] of_list_repr[OF to_list_repr(1)] i"], ["proof (chain)\npicking this:\n  i < length (map ((!) fs) [0..<m]) \\<Longrightarrow>\n  of_list_repr (inc_i f) = map ((!) fs) [0..<m]\n  of_list_repr f = map ((!) fs) [0..<m]\n  i < m", "show \"fs_state (inc_state state) = fs_state state\""], ["proof (prove)\nusing this:\n  i < length (map ((!) fs) [0..<m]) \\<Longrightarrow>\n  of_list_repr (inc_i f) = map ((!) fs) [0..<m]\n  of_list_repr f = map ((!) fs) [0..<m]\n  i < m\n\ngoal (1 subgoal):\n 1. fs_state (inc_state state) = fs_state state", "unfolding state"], ["proof (prove)\nusing this:\n  i < length (map ((!) fs) [0..<m]) \\<Longrightarrow>\n  of_list_repr (inc_i f) = map ((!) fs) [0..<m]\n  of_list_repr f = map ((!) fs) [0..<m]\n  i < m\n\ngoal (1 subgoal):\n 1. fs_state (inc_state (f, mu, ds)) = fs_state (f, mu, ds)", "by auto"], ["proof (state)\nthis:\n  fs_state (inc_state state) = fs_state state\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "context LLL_with_assms\nbegin"], ["", "lemma basis_reduction_add_rows_loop_impl: assumes\n    impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant True i fs\"\n  and mu_small: \"\\<mu>_small_row i fs j\"\n  and res: \"LLL_Impl.basis_reduction_add_rows_loop n state i j\n    (map ((!) fs) (rev [0 ..< j])) = state'\"\n    (is \"LLL_Impl.basis_reduction_add_rows_loop n state i j (?mapf fs j) = _\")\n  and j: \"j \\<le> i\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i fs'\"\n  \"basis_reduction_add_rows_loop i fs j = fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' &&&\n    local.basis_reduction_add_rows_loop i fs j = fs'", "proof (atomize(full), insert assms(1-6), induct j arbitrary: fs state)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fs state.\n       \\<lbrakk>LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs 0;\n        LLL_Impl.basis_reduction_add_rows_loop n state i 0\n         (map ((!) fs) (rev [0..<0])) =\n        state';\n        0 \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs 0 = fs'\n 2. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "case (0 fs state)"], ["proof (state)\nthis:\n  LLL_impl_inv state i fs\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs 0\n  LLL_Impl.basis_reduction_add_rows_loop n state i 0\n   (map ((!) fs) (rev [0..<0])) =\n  state'\n  0 \\<le> i\n  i < m\n\ngoal (2 subgoals):\n 1. \\<And>fs state.\n       \\<lbrakk>LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs 0;\n        LLL_Impl.basis_reduction_add_rows_loop n state i 0\n         (map ((!) fs) (rev [0..<0])) =\n        state';\n        0 \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs 0 = fs'\n 2. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "from LLL_invD[OF 0(2)]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  True \\<or> \\<mu>_small fs i", "have len: \"length fs = m\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. length fs = m", "by auto"], ["proof (state)\nthis:\n  length fs = m\n\ngoal (2 subgoals):\n 1. \\<And>fs state.\n       \\<lbrakk>LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs 0;\n        LLL_Impl.basis_reduction_add_rows_loop n state i 0\n         (map ((!) fs) (rev [0..<0])) =\n        state';\n        0 \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs 0 = fs'\n 2. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "from fs_state[OF 0(1-2) _ len]"], ["proof (chain)\npicking this:\n  state = (?f, ?mu, ?ds) \\<Longrightarrow> fs_state state = fs", "have \"fs_state state = fs\""], ["proof (prove)\nusing this:\n  state = (?f, ?mu, ?ds) \\<Longrightarrow> fs_state state = fs\n\ngoal (1 subgoal):\n 1. fs_state state = fs", "by (cases state, auto)"], ["proof (state)\nthis:\n  fs_state state = fs\n\ngoal (2 subgoals):\n 1. \\<And>fs state.\n       \\<lbrakk>LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs 0;\n        LLL_Impl.basis_reduction_add_rows_loop n state i 0\n         (map ((!) fs) (rev [0..<0])) =\n        state';\n        0 \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs 0 = fs'\n 2. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "thus ?case"], ["proof (prove)\nusing this:\n  fs_state state = fs\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs 0 = fs'", "using 0 i fs'"], ["proof (prove)\nusing this:\n  fs_state state = fs\n  LLL_impl_inv state i fs\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs 0\n  LLL_Impl.basis_reduction_add_rows_loop n state i 0\n   (map ((!) fs) (rev [0..<0])) =\n  state'\n  0 \\<le> i\n  i < m\n  i < m\n  fs' = fs_state state'\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs 0 = fs'", "by auto"], ["proof (state)\nthis:\n  LLL_impl_inv state' i fs' \\<and>\n  local.basis_reduction_add_rows_loop i fs 0 = fs'\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "case (Suc j fs state)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_impl_inv ?state1 i ?fs1; LLL_invariant True i ?fs1;\n   \\<mu>_small_row i ?fs1 j;\n   LLL_Impl.basis_reduction_add_rows_loop n ?state1 i j\n    (map ((!) ?fs1) (rev [0..<j])) =\n   state';\n   j \\<le> i; i < m\\<rbrakk>\n  \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                    local.basis_reduction_add_rows_loop i ?fs1 j = fs'\n  LLL_impl_inv state i fs\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs (Suc j)\n  LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n   (map ((!) fs) (rev [0..<Suc j])) =\n  state'\n  Suc j \\<le> i\n  i < m\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "hence j: \"j < i\" and jj: \"j \\<le> i\" and id: \"(j < i) = True\""], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_impl_inv ?state1 i ?fs1; LLL_invariant True i ?fs1;\n   \\<mu>_small_row i ?fs1 j;\n   LLL_Impl.basis_reduction_add_rows_loop n ?state1 i j\n    (map ((!) ?fs1) (rev [0..<j])) =\n   state';\n   j \\<le> i; i < m\\<rbrakk>\n  \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                    local.basis_reduction_add_rows_loop i ?fs1 j = fs'\n  LLL_impl_inv state i fs\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs (Suc j)\n  LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n   (map ((!) fs) (rev [0..<Suc j])) =\n  state'\n  Suc j \\<le> i\n  i < m\n\ngoal (1 subgoal):\n 1. j < i &&& j \\<le> i &&& (j < i) = True", "by auto"], ["proof (state)\nthis:\n  j < i\n  j \\<le> i\n  (j < i) = True\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "obtain f mu ds where state: \"state = (f,mu,ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f mu ds.\n        state = (f, mu, ds) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases state, auto)"], ["proof (state)\nthis:\n  state = (f, mu, ds)\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "note Linv = Suc(3)"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "note inv = LLL_invD[OF Linv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "note impl = Suc(2)"], ["proof (state)\nthis:\n  LLL_impl_inv state i fs\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "from fi_state[OF impl Linv state i]"], ["proof (chain)\npicking this:\n  fi_state state = fs ! i", "have fi: \"fi_state state = fs ! i\""], ["proof (prove)\nusing this:\n  fi_state state = fs ! i\n\ngoal (1 subgoal):\n 1. fi_state state = fs ! i", "by auto"], ["proof (state)\nthis:\n  fi_state state = fs ! i\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "have id: \"Suc j - 1 = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc j - 1 = j", "by simp"], ["proof (state)\nthis:\n  Suc j - 1 = j\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "note mu = dmu_ij_state[OF impl Linv state j i]"], ["proof (state)\nthis:\n  dmu_ij_state state i j = d\\<mu> fs i j\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "let ?c = \"round (\\<mu> fs i j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "note Linvw = LLL_inv_imp_w[OF Linv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "interpret fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by standard (use Linvw in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "have floor: \"round_num_denom (d\\<mu> fs i j) (d fs (Suc j)) = round (fs.gs.\\<mu> i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. round_num_denom (d\\<mu> fs i j) (d fs (Suc j)) = round (fs.gs.\\<mu> i j)", "using jj i inv"], ["proof (prove)\nusing this:\n  j \\<le> i\n  i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs.gs.reduced \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. round_num_denom (d\\<mu> fs i j) (d fs (Suc j)) = round (fs.gs.\\<mu> i j)", "unfolding d\\<mu>_def d_def"], ["proof (prove)\nusing this:\n  j \\<le> i\n  i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs.gs.reduced \\<alpha> i\n  True \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. round_num_denom\n     (int_of_rat\n       (rat_of_int (gs.Gramian_determinant fs (Suc j)) * fs.gs.\\<mu> i j))\n     (gs.Gramian_determinant fs (Suc j)) =\n    round (fs.gs.\\<mu> i j)", "by (intro fs.round_num_denom_d\\<mu>_d[unfolded fs.d\\<mu>_def fs.d_def]) auto"], ["proof (state)\nthis:\n  round_num_denom (d\\<mu> fs i j) (d fs (Suc j)) = round (fs.gs.\\<mu> i j)\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "from LLL_d_pos[OF Linvw] j i"], ["proof (chain)\npicking this:\n  ?k \\<le> m \\<Longrightarrow> 0 < d fs ?k\n  j < i\n  i < m", "have dj: \"d fs (Suc j) > 0\""], ["proof (prove)\nusing this:\n  ?k \\<le> m \\<Longrightarrow> 0 < d fs ?k\n  j < i\n  i < m\n\ngoal (1 subgoal):\n 1. 0 < d fs (Suc j)", "by auto"], ["proof (state)\nthis:\n  0 < d fs (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "note updates = d_d\\<mu>_add_row[OF Linvw i j refl]"], ["proof (state)\nthis:\n  ?ii \\<le> m \\<Longrightarrow>\n  d (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) ?ii = d fs ?ii\n  \\<lbrakk>?i' < m; ?j' < ?i'\\<rbrakk>\n  \\<Longrightarrow> d\\<mu> (fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j]) ?i'\n                     ?j' =\n                    (if ?i' = i \\<and> ?j' < j\n                     then d\\<mu> fs ?i' ?j' - ?c * d\\<mu> fs j ?j'\n                     else if ?i' = i \\<and> ?j' = j\n                          then d\\<mu> fs ?i' ?j' - ?c * d fs (Suc j)\n                          else d\\<mu> fs ?i' ?j')\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "note d_state = d_state[OF impl Linv state]"], ["proof (state)\nthis:\n  ?ii \\<le> m \\<Longrightarrow> d_state state ?ii = d fs ?ii\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "from d_state[of \"Suc j\"] j i"], ["proof (chain)\npicking this:\n  Suc j \\<le> m \\<Longrightarrow> d_state state (Suc j) = d fs (Suc j)\n  j < i\n  i < m", "have djs: \"d_state state (Suc j) = d fs (Suc j)\""], ["proof (prove)\nusing this:\n  Suc j \\<le> m \\<Longrightarrow> d_state state (Suc j) = d fs (Suc j)\n  j < i\n  i < m\n\ngoal (1 subgoal):\n 1. d_state state (Suc j) = d fs (Suc j)", "by auto"], ["proof (state)\nthis:\n  d_state state (Suc j) = d fs (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "note res = Suc(5)[unfolded floor map_rev_Suc djs append.simps LLL_Impl.basis_reduction_add_rows_loop.simps\n      fi Let_def mu id int_times_rat_def]"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_add_rows_loop n\n   (if round (fs.gs.\\<mu> i j) = 0 then state\n    else upd_fi_mu_state state i\n          (vec n\n            (\\<lambda>ia.\n                fs ! i $ ia - round (fs.gs.\\<mu> i j) * fs ! j $ ia))\n          (IArray.of_fun\n            (\\<lambda>jj.\n                if jj < j\n                then dmu_ij_state state i jj -\n                     round (fs.gs.\\<mu> i j) * dmu_ij_state state j jj\n                else if jj = j\n                     then dmu_ij_state state i jj -\n                          d fs (Suc j) * round (fs.gs.\\<mu> i j)\n                     else dmu_ij_state state i jj)\n            i))\n   i j (map ((!) fs) (rev [0..<j])) =\n  state'\n\ngoal (1 subgoal):\n 1. \\<And>j fs state.\n       \\<lbrakk>\\<And>fs state.\n                   \\<lbrakk>LLL_impl_inv state i fs;\n                    LLL_invariant True i fs; \\<mu>_small_row i fs j;\n                    LLL_Impl.basis_reduction_add_rows_loop n state i j\n                     (map ((!) fs) (rev [0..<j])) =\n                    state';\n                    j \\<le> i; i < m\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                                     local.basis_reduction_add_rows_loop i\nfs j =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant True i fs;\n        \\<mu>_small_row i fs (Suc j);\n        LLL_Impl.basis_reduction_add_rows_loop n state i (Suc j)\n         (map ((!) fs) (rev [0..<Suc j])) =\n        state';\n        Suc j \\<le> i; i < m\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' i fs' \\<and>\n                         local.basis_reduction_add_rows_loop i fs (Suc j) =\n                         fs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "proof (cases \"?c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. round (fs.gs.\\<mu> i j) = 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'\n 2. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "case True"], ["proof (state)\nthis:\n  round (fs.gs.\\<mu> i j) = 0\n\ngoal (2 subgoals):\n 1. round (fs.gs.\\<mu> i j) = 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'\n 2. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "from res[unfolded True]"], ["proof (chain)\npicking this:\n  LLL_Impl.basis_reduction_add_rows_loop n\n   (if 0 = 0 then state\n    else upd_fi_mu_state state i\n          (vec n (\\<lambda>ia. fs ! i $ ia - 0 * fs ! j $ ia))\n          (IArray.of_fun\n            (\\<lambda>jj.\n                if jj < j\n                then dmu_ij_state state i jj - 0 * dmu_ij_state state j jj\n                else if jj = j\n                     then dmu_ij_state state i jj - d fs (Suc j) * 0\n                     else dmu_ij_state state i jj)\n            i))\n   i j (map ((!) fs) (rev [0..<j])) =\n  state'", "have res: \"LLL_Impl.basis_reduction_add_rows_loop n state i j (?mapf fs j) = state'\""], ["proof (prove)\nusing this:\n  LLL_Impl.basis_reduction_add_rows_loop n\n   (if 0 = 0 then state\n    else upd_fi_mu_state state i\n          (vec n (\\<lambda>ia. fs ! i $ ia - 0 * fs ! j $ ia))\n          (IArray.of_fun\n            (\\<lambda>jj.\n                if jj < j\n                then dmu_ij_state state i jj - 0 * dmu_ij_state state j jj\n                else if jj = j\n                     then dmu_ij_state state i jj - d fs (Suc j) * 0\n                     else dmu_ij_state state i jj)\n            i))\n   i j (map ((!) fs) (rev [0..<j])) =\n  state'\n\ngoal (1 subgoal):\n 1. LLL_Impl.basis_reduction_add_rows_loop n state i j\n     (map ((!) fs) (rev [0..<j])) =\n    state'", "by simp"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_add_rows_loop n state i j\n   (map ((!) fs) (rev [0..<j])) =\n  state'\n\ngoal (2 subgoals):\n 1. round (fs.gs.\\<mu> i j) = 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'\n 2. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "note step = Linv basis_reduction_add_row_main_0[OF Linvw i j True Suc(4)]"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs j\n\ngoal (2 subgoals):\n 1. round (fs.gs.\\<mu> i j) = 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'\n 2. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "using Suc(1)[OF impl step(1-2) res _ i] j True"], ["proof (prove)\nusing this:\n  j \\<le> i \\<Longrightarrow>\n  LLL_impl_inv state' i fs' \\<and>\n  local.basis_reduction_add_rows_loop i fs j = fs'\n  j < i\n  round (fs.gs.\\<mu> i j) = 0\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "by auto"], ["proof (state)\nthis:\n  LLL_impl_inv state' i fs' \\<and>\n  local.basis_reduction_add_rows_loop i fs (Suc j) = fs'\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "case False"], ["proof (state)\nthis:\n  round (fs.gs.\\<mu> i j) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "hence id: \"(?c = 0) = False\""], ["proof (prove)\nusing this:\n  round (fs.gs.\\<mu> i j) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (round (fs.gs.\\<mu> i j) = 0) = False", "by auto"], ["proof (state)\nthis:\n  (round (fs.gs.\\<mu> i j) = 0) = False\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "from i j"], ["proof (chain)\npicking this:\n  i < m\n  j < i", "have jm: \"j < m\""], ["proof (prove)\nusing this:\n  i < m\n  j < i\n\ngoal (1 subgoal):\n 1. j < m", "by auto"], ["proof (state)\nthis:\n  j < m\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "have idd: \"vec n (\\<lambda>ia. fs ! i $ ia - ?c * fs ! j $ ia) =\n      fs ! i - ?c \\<cdot>\\<^sub>v fs ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n\n     (\\<lambda>ia. fs ! i $ ia - round (fs.gs.\\<mu> i j) * fs ! j $ ia) =\n    fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j", "by (intro eq_vecI, insert inv(4)[OF i] inv(4)[OF jm], auto)"], ["proof (state)\nthis:\n  vec n (\\<lambda>ia. fs ! i $ ia - round (fs.gs.\\<mu> i j) * fs ! j $ ia) =\n  fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "define fi' where \"fi' = fs ! i - ?c \\<cdot>\\<^sub>v fs ! j\""], ["proof (state)\nthis:\n  fi' = fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "obtain fs'' where fs'': \"fs[i := fs ! i - ?c \\<cdot>\\<^sub>v fs ! j] = fs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs''.\n        fs[i := fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j] =\n        fs'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fs[i := fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j] = fs''\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "note step = basis_reduction_add_row_main[OF Linvw i j fs''[symmetric]]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs''\n  LLL_invariant True i fs \\<Longrightarrow> LLL_invariant True i fs''\n  \\<lbrakk>round (fs.gs.\\<mu> i j) = round (fs.gs.\\<mu> i j);\n   \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i fs'' j\n  round (fs.gs.\\<mu> i j) = round (fs.gs.\\<mu> i j) \\<Longrightarrow>\n  \\<bar>gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs'') i j\\<bar>\n  \\<le> 1 / 2\n  LLL_measure i fs'' = LLL_measure i fs\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'') ?i = fs.gs.gso ?i\n  \\<lbrakk>?i' < m; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs'')\n                     ?i' ?j' =\n                    (if ?i' = i \\<and> ?j' \\<le> j\n                     then fs.gs.\\<mu> i ?j' -\n                          rat_of_int (round (fs.gs.\\<mu> i j)) *\n                          fs.gs.\\<mu> j ?j'\n                     else fs.gs.\\<mu> ?i' ?j')\n  ?ii \\<le> m \\<Longrightarrow> d fs'' ?ii = d fs ?ii\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "note Linvw2 = step(1)"], ["proof (state)\nthis:\n  LLL_invariant_weak fs''\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "note step = step(2)[OF Linv] step(3,5-)"], ["proof (state)\nthis:\n  LLL_invariant True i fs''\n  \\<lbrakk>round (fs.gs.\\<mu> i j) = round (fs.gs.\\<mu> i j);\n   \\<mu>_small_row i fs (Suc j)\\<rbrakk>\n  \\<Longrightarrow> \\<mu>_small_row i fs'' j\n  LLL_measure i fs'' = LLL_measure i fs\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'') ?i = fs.gs.gso ?i\n  \\<lbrakk>?i' < m; ?j' < m\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs'')\n                     ?i' ?j' =\n                    (if ?i' = i \\<and> ?j' \\<le> j\n                     then fs.gs.\\<mu> i ?j' -\n                          rat_of_int (round (fs.gs.\\<mu> i j)) *\n                          fs.gs.\\<mu> j ?j'\n                     else fs.gs.\\<mu> ?i' ?j')\n  ?ii \\<le> m \\<Longrightarrow> d fs'' ?ii = d fs ?ii\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "note updates = updates[where c = ?c, unfolded fs'']"], ["proof (state)\nthis:\n  ?ii \\<le> m \\<Longrightarrow> d fs'' ?ii = d fs ?ii\n  \\<lbrakk>?i' < m; ?j' < ?i'\\<rbrakk>\n  \\<Longrightarrow> d\\<mu> fs'' ?i' ?j' =\n                    (if ?i' = i \\<and> ?j' < j\n                     then d\\<mu> fs ?i' ?j' -\n                          round (fs.gs.\\<mu> i j) * d\\<mu> fs j ?j'\n                     else if ?i' = i \\<and> ?j' = j\n                          then d\\<mu> fs ?i' ?j' -\n                               round (fs.gs.\\<mu> i j) * d fs (Suc j)\n                          else d\\<mu> fs ?i' ?j')\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "have map_id_f: \"?mapf fs j = ?mapf fs'' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) fs) (rev [0..<j]) = map ((!) fs'') (rev [0..<j])", "by (rule nth_equalityI, insert j i, auto simp: rev_nth fs''[symmetric])"], ["proof (state)\nthis:\n  map ((!) fs) (rev [0..<j]) = map ((!) fs'') (rev [0..<j])\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "have nth_id: \"[0..<m] ! i = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<m] ! i = i", "using i"], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. [0..<m] ! i = i", "by auto"], ["proof (state)\nthis:\n  [0..<m] ! i = i\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "note res = res[unfolded False map_id_f id if_False idd]"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_add_rows_loop n\n   (upd_fi_mu_state state i\n     (fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j)\n     (IArray.of_fun\n       (\\<lambda>jj.\n           if jj < j\n           then dmu_ij_state state i jj -\n                round (fs.gs.\\<mu> i j) * dmu_ij_state state j jj\n           else if jj = j\n                then dmu_ij_state state i jj -\n                     d fs (Suc j) * round (fs.gs.\\<mu> i j)\n                else dmu_ij_state state i jj)\n       i))\n   i j (map ((!) fs'') (rev [0..<j])) =\n  state'\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "have fi: \"fi' = fs'' ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fi' = fs'' ! i", "unfolding fs''[symmetric] fi'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j =\n    fs[i := fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j] ! i", "using inv(6) i"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n\ngoal (1 subgoal):\n 1. fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j =\n    fs[i := fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j] ! i", "by auto"], ["proof (state)\nthis:\n  fi' = fs'' ! i\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "let ?fn = \"\\<lambda> fs i. (fs ! i, sq_norm (gso fs i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "let ?d = \"\\<lambda> fs i. d fs (Suc i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "let ?mu' = \"IArray.of_fun\n       (\\<lambda>jj. if jj < j then dmu_ij_state state i jj - ?c * dmu_ij_state state j jj\n             else if jj = j then dmu_ij_state state i jj - ?d fs j * ?c else dmu_ij_state state i jj) i\""], ["proof (state)\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "have mu': \"?mu' = IArray.of_fun (d\\<mu> fs'' i) i\" (is \"_ = ?mu'i\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>jj.\n         if jj < j\n         then dmu_ij_state state i jj -\n              round (fs.gs.\\<mu> i j) * dmu_ij_state state j jj\n         else if jj = j\n              then dmu_ij_state state i jj -\n                   d fs (Suc j) * round (fs.gs.\\<mu> i j)\n              else dmu_ij_state state i jj)\n     i =\n    IArray.of_fun (d\\<mu> fs'' i) i", "proof (rule iarray_cong', goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < i \\<Longrightarrow>\n       (if ia < j\n        then dmu_ij_state state i ia -\n             round (fs.gs.\\<mu> i j) * dmu_ij_state state j ia\n        else if ia = j\n             then dmu_ij_state state i ia -\n                  d fs (Suc j) * round (fs.gs.\\<mu> i j)\n             else dmu_ij_state state i ia) =\n       d\\<mu> fs'' i ia", "case (1 jj)"], ["proof (state)\nthis:\n  jj < i\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < i \\<Longrightarrow>\n       (if ia < j\n        then dmu_ij_state state i ia -\n             round (fs.gs.\\<mu> i j) * dmu_ij_state state j ia\n        else if ia = j\n             then dmu_ij_state state i ia -\n                  d fs (Suc j) * round (fs.gs.\\<mu> i j)\n             else dmu_ij_state state i ia) =\n       d\\<mu> fs'' i ia", "from 1 j i"], ["proof (chain)\npicking this:\n  jj < i\n  j < i\n  i < m", "have jm: \"j < m\""], ["proof (prove)\nusing this:\n  jj < i\n  j < i\n  i < m\n\ngoal (1 subgoal):\n 1. j < m", "by auto"], ["proof (state)\nthis:\n  j < m\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < i \\<Longrightarrow>\n       (if ia < j\n        then dmu_ij_state state i ia -\n             round (fs.gs.\\<mu> i j) * dmu_ij_state state j ia\n        else if ia = j\n             then dmu_ij_state state i ia -\n                  d fs (Suc j) * round (fs.gs.\\<mu> i j)\n             else dmu_ij_state state i ia) =\n       d\\<mu> fs'' i ia", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if jj < j\n     then dmu_ij_state state i jj -\n          round (fs.gs.\\<mu> i j) * dmu_ij_state state j jj\n     else if jj = j\n          then dmu_ij_state state i jj -\n               d fs (Suc j) * round (fs.gs.\\<mu> i j)\n          else dmu_ij_state state i jj) =\n    d\\<mu> fs'' i jj", "unfolding dmu_ij_state[OF impl Linv state 1 i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if jj < j\n     then d\\<mu> fs i jj - round (fs.gs.\\<mu> i j) * dmu_ij_state state j jj\n     else if jj = j\n          then d\\<mu> fs i jj - d fs (Suc j) * round (fs.gs.\\<mu> i j)\n          else d\\<mu> fs i jj) =\n    d\\<mu> fs'' i jj", "using dmu_ij_state[OF impl Linv state _ jm]"], ["proof (prove)\nusing this:\n  ?j < j \\<Longrightarrow> dmu_ij_state state j ?j = d\\<mu> fs j ?j\n\ngoal (1 subgoal):\n 1. (if jj < j\n     then d\\<mu> fs i jj - round (fs.gs.\\<mu> i j) * dmu_ij_state state j jj\n     else if jj = j\n          then d\\<mu> fs i jj - d fs (Suc j) * round (fs.gs.\\<mu> i j)\n          else d\\<mu> fs i jj) =\n    d\\<mu> fs'' i jj", "by (subst updates(2)[OF i 1], auto)"], ["proof (state)\nthis:\n  (if jj < j\n   then dmu_ij_state state i jj -\n        round (fs.gs.\\<mu> i j) * dmu_ij_state state j jj\n   else if jj = j\n        then dmu_ij_state state i jj -\n             d fs (Suc j) * round (fs.gs.\\<mu> i j)\n        else dmu_ij_state state i jj) =\n  d\\<mu> fs'' i jj\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>jj.\n       if jj < j\n       then dmu_ij_state state i jj -\n            round (fs.gs.\\<mu> i j) * dmu_ij_state state j jj\n       else if jj = j\n            then dmu_ij_state state i jj -\n                 d fs (Suc j) * round (fs.gs.\\<mu> i j)\n            else dmu_ij_state state i jj)\n   i =\n  IArray.of_fun (d\\<mu> fs'' i) i\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "{"], ["proof (state)\nthis:\n  IArray.of_fun\n   (\\<lambda>jj.\n       if jj < j\n       then dmu_ij_state state i jj -\n            round (fs.gs.\\<mu> i j) * dmu_ij_state state j jj\n       else if jj = j\n            then dmu_ij_state state i jj -\n                 d fs (Suc j) * round (fs.gs.\\<mu> i j)\n            else dmu_ij_state state i jj)\n   i =\n  IArray.of_fun (d\\<mu> fs'' i) i\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "fix ii"], ["proof (state)\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "assume ii: \"ii < m\" \"ii \\<noteq> i\""], ["proof (state)\nthis:\n  ii < m\n  ii \\<noteq> i\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "hence \"(IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m) !! ii\n        = IArray.of_fun (d\\<mu> fs ii) ii\""], ["proof (prove)\nusing this:\n  ii < m\n  ii \\<noteq> i\n\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m !! ii =\n    IArray.of_fun (d\\<mu> fs ii) ii", "by auto"], ["proof (state)\nthis:\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m !! ii =\n  IArray.of_fun (d\\<mu> fs ii) ii\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "also"], ["proof (state)\nthis:\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m !! ii =\n  IArray.of_fun (d\\<mu> fs ii) ii\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "have \"\\<dots> = IArray.of_fun (d\\<mu> fs'' ii) ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (d\\<mu> fs ii) ii = IArray.of_fun (d\\<mu> fs'' ii) ii", "proof (rule iarray_cong', goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < ii \\<Longrightarrow> d\\<mu> fs ii i = d\\<mu> fs'' ii i", "case (1 j)"], ["proof (state)\nthis:\n  j < ii\n\ngoal (1 subgoal):\n 1. \\<And>i. i < ii \\<Longrightarrow> d\\<mu> fs ii i = d\\<mu> fs'' ii i", "with ii"], ["proof (chain)\npicking this:\n  ii < m\n  ii \\<noteq> i\n  j < ii", "have j: \"Suc j \\<le> m\""], ["proof (prove)\nusing this:\n  ii < m\n  ii \\<noteq> i\n  j < ii\n\ngoal (1 subgoal):\n 1. Suc j \\<le> m", "by auto"], ["proof (state)\nthis:\n  Suc j \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>i. i < ii \\<Longrightarrow> d\\<mu> fs ii i = d\\<mu> fs'' ii i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs ii j = d\\<mu> fs'' ii j", "unfolding updates(2)[OF ii(1) 1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. d\\<mu> fs ii j =\n    (if ii = i \\<and> j < ja__\n     then d\\<mu> fs ii j - round (fs.gs.\\<mu> i ja__) * d\\<mu> fs ja__ j\n     else if ii = i \\<and> j = ja__\n          then d\\<mu> fs ii j - round (fs.gs.\\<mu> i ja__) * d fs (Suc ja__)\n          else d\\<mu> fs ii j)", "using ii"], ["proof (prove)\nusing this:\n  ii < m\n  ii \\<noteq> i\n\ngoal (1 subgoal):\n 1. d\\<mu> fs ii j =\n    (if ii = i \\<and> j < ja__\n     then d\\<mu> fs ii j - round (fs.gs.\\<mu> i ja__) * d\\<mu> fs ja__ j\n     else if ii = i \\<and> j = ja__\n          then d\\<mu> fs ii j - round (fs.gs.\\<mu> i ja__) * d fs (Suc ja__)\n          else d\\<mu> fs ii j)", "by auto"], ["proof (state)\nthis:\n  d\\<mu> fs ii j = d\\<mu> fs'' ii j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IArray.of_fun (d\\<mu> fs ii) ii = IArray.of_fun (d\\<mu> fs'' ii) ii\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "finally"], ["proof (chain)\npicking this:\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m !! ii =\n  IArray.of_fun (d\\<mu> fs'' ii) ii", "have \"(IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m) !! ii\n         = IArray.of_fun (d\\<mu> fs'' ii) ii\""], ["proof (prove)\nusing this:\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m !! ii =\n  IArray.of_fun (d\\<mu> fs'' ii) ii\n\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m !! ii =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "by auto"], ["proof (state)\nthis:\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m !! ii =\n  IArray.of_fun (d\\<mu> fs'' ii) ii\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ii3 < m; ?ii3 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> IArray.of_fun\n                     (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m !!\n                    ?ii3 =\n                    IArray.of_fun (d\\<mu> fs'' ?ii3) ?ii3\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "note ii = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ii3 < m; ?ii3 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> IArray.of_fun\n                     (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m !!\n                    ?ii3 =\n                    IArray.of_fun (d\\<mu> fs'' ?ii3) ?ii3\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "let ?mu'' = \"iarray_update mu i (IArray.of_fun (d\\<mu> fs'' i) i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "have new_array: \"?mu'' = IArray.of_fun (\\<lambda> i. IArray.of_fun (d\\<mu> fs'' i) i) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iarray_update mu i (IArray.of_fun (d\\<mu> fs'' i) i) =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs'' i) i) m", "unfolding iarray_update_of_fun to_mu_repr[OF impl Linv state, unfolded mu_repr_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     ((\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i)\n      (i := IArray.of_fun (d\\<mu> fs'' i) i))\n     m =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs'' i) i) m", "by (rule iarray_cong', insert ii, auto)"], ["proof (state)\nthis:\n  iarray_update mu i (IArray.of_fun (d\\<mu> fs'' i) i) =\n  IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs'' i) i) m\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "have d': \"(map (?d fs) (rev [0..<j])) = (map (?d fs'') (rev [0..<j]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. d fs (Suc i)) (rev [0..<j]) =\n    map (\\<lambda>i. d fs'' (Suc i)) (rev [0..<j])", "by (rule nth_equalityI, force, simp, subst updates(1), insert j i, auto\n        simp: rev_nth)"], ["proof (state)\nthis:\n  map (\\<lambda>i. d fs (Suc i)) (rev [0..<j]) =\n  map (\\<lambda>i. d fs'' (Suc i)) (rev [0..<j])\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "have repr_id:\n      \"(map ((!) fs) [0..<m])[i := (fs'' ! i)] = map ((!) fs'') [0..<m]\" (is \"?xs = ?ys\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map ((!) fs) [0..<m])[i := fs'' ! i] = map ((!) fs'') [0..<m]", "proof (rule nth_equalityI, force)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length ((map ((!) fs) [0..<m])[i := fs'' ! i]) \\<Longrightarrow>\n       (map ((!) fs) [0..<m])[i := fs'' ! i] ! ia =\n       map ((!) fs'') [0..<m] ! ia", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length ((map ((!) fs) [0..<m])[i := fs'' ! i]) \\<Longrightarrow>\n       (map ((!) fs) [0..<m])[i := fs'' ! i] ! ia =\n       map ((!) fs'') [0..<m] ! ia", "assume \"j < length ?xs\""], ["proof (state)\nthis:\n  j < length ((map ((!) fs) [0..<m])[i := fs'' ! i])\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length ((map ((!) fs) [0..<m])[i := fs'' ! i]) \\<Longrightarrow>\n       (map ((!) fs) [0..<m])[i := fs'' ! i] ! ia =\n       map ((!) fs'') [0..<m] ! ia", "thus \"?xs ! j = ?ys ! j\""], ["proof (prove)\nusing this:\n  j < length ((map ((!) fs) [0..<m])[i := fs'' ! i])\n\ngoal (1 subgoal):\n 1. (map ((!) fs) [0..<m])[i := fs'' ! i] ! j = map ((!) fs'') [0..<m] ! j", "unfolding fs''[symmetric] i"], ["proof (prove)\nusing this:\n  j < length\n       ((map ((!) fs) [0..<m])\n        [i := fs[i := fs ! i -\n                      round (fs.gs.\\<mu> i ja__) \\<cdot>\\<^sub>v\n                      fs ! ja__] !\n              i])\n\ngoal (1 subgoal):\n 1. (map ((!) fs) [0..<m])\n    [i := fs[i := fs ! i -\n                  round (fs.gs.\\<mu> i ja__) \\<cdot>\\<^sub>v fs ! ja__] !\n          i] !\n    j =\n    map ((!) (fs[i := fs ! i -\n                      round (fs.gs.\\<mu> i ja__) \\<cdot>\\<^sub>v\n                      fs ! ja__]))\n     [0..<m] !\n    j", "by (cases \"j = i\", auto)"], ["proof (state)\nthis:\n  (map ((!) fs) [0..<m])[i := fs'' ! i] ! j = map ((!) fs'') [0..<m] ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map ((!) fs) [0..<m])[i := fs'' ! i] = map ((!) fs'') [0..<m]\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "have repr_id_d:\n      \"map (d fs) [0..<Suc m] = map (d fs'') [0..<Suc m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (d fs) [0..<Suc m] = map (d fs'') [0..<Suc m]", "by (rule nth_equalityI, force, insert step(4,6), auto simp: nth_append)"], ["proof (state)\nthis:\n  map (d fs) [0..<Suc m] = map (d fs'') [0..<Suc m]\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "have mu: \"fs ! i - ?c \\<cdot>\\<^sub>v fs ! j = fs'' ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j = fs'' ! i", "unfolding fs''[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j =\n    fs[i := fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j] ! i", "using inv(6) i"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n\ngoal (1 subgoal):\n 1. fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j =\n    fs[i := fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j] ! i", "by auto"], ["proof (state)\nthis:\n  fs ! i - round (fs.gs.\\<mu> i j) \\<cdot>\\<^sub>v fs ! j = fs'' ! i\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "note res = res[unfolded mu' mu d']"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_add_rows_loop n\n   (upd_fi_mu_state state i (fs'' ! i) (IArray.of_fun (d\\<mu> fs'' i) i)) i\n   j (map ((!) fs'') (rev [0..<j])) =\n  state'\n\ngoal (1 subgoal):\n 1. round (fs.gs.\\<mu> i j) \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs (Suc j) = fs'", "unfolding basis_reduction_add_rows_loop.simps Let_def id if_False fs''"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows_loop i fs'' j = fs'", "proof (rule Suc(1)[OF _ step(1,2) res _ i])"], ["proof (state)\ngoal (4 subgoals):\n 1. LLL_impl_inv\n     (upd_fi_mu_state state i (fs'' ! i) (IArray.of_fun (d\\<mu> fs'' i) i))\n     i fs''\n 2. round (fs.gs.\\<mu> i j) = round (fs.gs.\\<mu> i j)\n 3. \\<mu>_small_row i fs (Suc j)\n 4. j \\<le> i", "note list_repr = to_list_repr[OF impl Linv state]"], ["proof (state)\nthis:\n  list_repr i f (map ((!) fs) [0..<m])\n\ngoal (4 subgoals):\n 1. LLL_impl_inv\n     (upd_fi_mu_state state i (fs'' ! i) (IArray.of_fun (d\\<mu> fs'' i) i))\n     i fs''\n 2. round (fs.gs.\\<mu> i j) = round (fs.gs.\\<mu> i j)\n 3. \\<mu>_small_row i fs (Suc j)\n 4. j \\<le> i", "from i"], ["proof (chain)\npicking this:\n  i < m", "have ii: \"i < length [0..<m]\""], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. i < length [0..<m]", "by auto"], ["proof (state)\nthis:\n  i < length [0..<m]\n\ngoal (4 subgoals):\n 1. LLL_impl_inv\n     (upd_fi_mu_state state i (fs'' ! i) (IArray.of_fun (d\\<mu> fs'' i) i))\n     i fs''\n 2. round (fs.gs.\\<mu> i j) = round (fs.gs.\\<mu> i j)\n 3. \\<mu>_small_row i fs (Suc j)\n 4. j \\<le> i", "show \"LLL_impl_inv (upd_fi_mu_state state i (fs'' ! i) ?mu'i) i fs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv\n     (upd_fi_mu_state state i (fs'' ! i) (IArray.of_fun (d\\<mu> fs'' i) i))\n     i fs''", "unfolding upd_fi_mu_state.simps state LLL_impl_inv.simps new_array"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_repr i (update_i f (fs'' ! i)) (map ((!) fs'') [0..<m]) \\<and>\n    d_repr ds fs'' \\<and>\n    mu_repr (IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs'' i) i) m)\n     fs''", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. list_repr i (update_i f (fs'' ! i)) (map ((!) fs'') [0..<m])\n 2. d_repr ds fs''\n 3. mu_repr (IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs'' i) i) m)\n     fs''", "show \"list_repr i (update_i f (fs'' ! i)) (map ((!) fs'') [0..<m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_repr i (update_i f (fs'' ! i)) (map ((!) fs'') [0..<m])", "using update_i[OF list_repr(1), unfolded length_map, OF ii]"], ["proof (prove)\nusing this:\n  list_repr i (update_i f ?x) ((map ((!) fs) [0..<m])[i := ?x])\n\ngoal (1 subgoal):\n 1. list_repr i (update_i f (fs'' ! i)) (map ((!) fs'') [0..<m])", "unfolding repr_id[symmetric]"], ["proof (prove)\nusing this:\n  list_repr i (update_i f ?x) ((map ((!) fs) [0..<m])[i := ?x])\n\ngoal (1 subgoal):\n 1. list_repr i (update_i f (fs'' ! i))\n     ((map ((!) fs) [0..<m])[i := fs'' ! i])", "."], ["proof (state)\nthis:\n  list_repr i (update_i f (fs'' ! i)) (map ((!) fs'') [0..<m])\n\ngoal (2 subgoals):\n 1. d_repr ds fs''\n 2. mu_repr (IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs'' i) i) m)\n     fs''", "show \"d_repr ds fs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_repr ds fs''", "unfolding to_d_repr[OF impl Linv state, unfolded d_repr_def] d_repr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (d fs) (Suc m) = IArray.of_fun (d fs'') (Suc m)", "by (rule iarray_cong', subst step(6), auto)"], ["proof (state)\nthis:\n  d_repr ds fs''\n\ngoal (1 subgoal):\n 1. mu_repr (IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs'' i) i) m)\n     fs''", "qed (auto simp: mu_repr_def)"], ["proof (state)\nthis:\n  LLL_impl_inv\n   (upd_fi_mu_state state i (fs'' ! i) (IArray.of_fun (d\\<mu> fs'' i) i)) i\n   fs''\n\ngoal (3 subgoals):\n 1. round (fs.gs.\\<mu> i j) = round (fs.gs.\\<mu> i j)\n 2. \\<mu>_small_row i fs (Suc j)\n 3. j \\<le> i", "qed (insert i j, auto simp: Suc(4))"], ["proof (state)\nthis:\n  LLL_impl_inv state' i fs' \\<and>\n  local.basis_reduction_add_rows_loop i fs (Suc j) = fs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_impl_inv state' i fs' \\<and>\n  local.basis_reduction_add_rows_loop i fs (Suc j) = fs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_add_rows_loop: assumes\n    impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant True i fs\"\n  and mu_small: \"\\<mu>_small_row i fs j\"\n  and res: \"LLL_Impl.basis_reduction_add_rows_loop n state i j\n    (map ((!) fs) (rev [0 ..< j])) = state'\"\n    (is \"LLL_Impl.basis_reduction_add_rows_loop n state i j (?mapf fs j) = _\")\n  and j: \"j \\<le> i\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i fs'\"\n  \"LLL_invariant False i fs'\"\n  \"LLL_measure i fs' = LLL_measure i fs\"\n  \"basis_reduction_add_rows_loop i fs j = fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LLL_impl_inv state' i fs' &&& LLL_invariant False i fs') &&&\n    LLL_measure i fs' = LLL_measure i fs &&&\n    local.basis_reduction_add_rows_loop i fs j = fs'", "using basis_reduction_add_rows_loop_impl[OF assms]\n    basis_reduction_add_rows_loop[OF inv mu_small _ i j]"], ["proof (prove)\nusing this:\n  LLL_impl_inv state' i fs'\n  local.basis_reduction_add_rows_loop i fs j = fs'\n  local.basis_reduction_add_rows_loop i fs j = ?fs' \\<Longrightarrow>\n  LLL_invariant False i ?fs'\n  local.basis_reduction_add_rows_loop i fs j = ?fs' \\<Longrightarrow>\n  LLL_measure i ?fs' = LLL_measure i fs\n\ngoal (1 subgoal):\n 1. (LLL_impl_inv state' i fs' &&& LLL_invariant False i fs') &&&\n    LLL_measure i fs' = LLL_measure i fs &&&\n    local.basis_reduction_add_rows_loop i fs j = fs'", "by blast+"], ["", "lemma basis_reduction_add_rows_impl: assumes\n     impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_add_rows n upw i state = state'\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i fs'\"\n  \"basis_reduction_add_rows upw i fs = fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' &&&\n    local.basis_reduction_add_rows upw i fs = fs'", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "obtain f mu ds where state: \"state = (f,mu,ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f mu ds.\n        state = (f, mu, ds) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases state, auto)"], ["proof (state)\nthis:\n  state = (f, mu, ds)\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "note def = LLL_Impl.basis_reduction_add_rows_def basis_reduction_add_rows_def"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_add_rows ?n ?upw ?i ?state =\n  (if ?upw\n   then LLL_Impl.basis_reduction_add_rows_loop ?n ?state ?i ?i\n         (small_fs_state ?state)\n   else ?state)\n  local.basis_reduction_add_rows ?upw ?i ?fs =\n  (if ?upw then local.basis_reduction_add_rows_loop ?i ?fs ?i else ?fs)\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "proof (cases upw)"], ["proof (state)\ngoal (2 subgoals):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'\n 2. \\<not> upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "case False"], ["proof (state)\nthis:\n  \\<not> upw\n\ngoal (2 subgoals):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'\n 2. \\<not> upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "from LLL_invD[OF inv]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i", "have len: \"length fs = m\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. length fs = m", "by auto"], ["proof (state)\nthis:\n  length fs = m\n\ngoal (2 subgoals):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'\n 2. \\<not> upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "from fs_state[OF impl inv state len]"], ["proof (chain)\npicking this:\n  fs_state state = fs", "have \"fs_state state = fs\""], ["proof (prove)\nusing this:\n  fs_state state = fs\n\ngoal (1 subgoal):\n 1. fs_state state = fs", "by auto"], ["proof (state)\nthis:\n  fs_state state = fs\n\ngoal (2 subgoals):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'\n 2. \\<not> upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "with assms False"], ["proof (chain)\npicking this:\n  LLL_impl_inv state i fs\n  LLL_invariant upw i fs\n  LLL_Impl.basis_reduction_add_rows n upw i state = state'\n  i < m\n  fs' = fs_state state'\n  \\<not> upw\n  fs_state state = fs", "show ?thesis"], ["proof (prove)\nusing this:\n  LLL_impl_inv state i fs\n  LLL_invariant upw i fs\n  LLL_Impl.basis_reduction_add_rows n upw i state = state'\n  i < m\n  fs' = fs_state state'\n  \\<not> upw\n  fs_state state = fs\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "by (auto simp: def)"], ["proof (state)\nthis:\n  LLL_impl_inv state' i fs' \\<and>\n  local.basis_reduction_add_rows upw i fs = fs'\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "case True"], ["proof (state)\nthis:\n  upw\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "with inv"], ["proof (chain)\npicking this:\n  LLL_invariant upw i fs\n  upw", "have \"LLL_invariant True i fs\""], ["proof (prove)\nusing this:\n  LLL_invariant upw i fs\n  upw\n\ngoal (1 subgoal):\n 1. LLL_invariant True i fs", "by auto"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "note start = this \\<mu>_small_row_refl[of i fs]"], ["proof (state)\nthis:\n  LLL_invariant True i fs\n  \\<mu>_small_row i fs i\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "have id: \"small_fs_state state = map (\\<lambda> i. fs ! i) (rev [0..<i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small_fs_state state = map ((!) fs) (rev [0..<i])", "unfolding state"], ["proof (prove)\ngoal (1 subgoal):\n 1. small_fs_state (f, mu, ds) = map ((!) fs) (rev [0..<i])", "using to_list_repr[OF impl inv state] i"], ["proof (prove)\nusing this:\n  list_repr i f (map ((!) fs) [0..<m])\n  i < m\n\ngoal (1 subgoal):\n 1. small_fs_state (f, mu, ds) = map ((!) fs) (rev [0..<i])", "unfolding list_repr_def"], ["proof (prove)\nusing this:\n  i \\<le> length (map ((!) fs) [0..<m]) \\<and>\n  fst f = rev (take i (map ((!) fs) [0..<m])) \\<and>\n  snd f = drop i (map ((!) fs) [0..<m])\n  i < m\n\ngoal (1 subgoal):\n 1. small_fs_state (f, mu, ds) = map ((!) fs) (rev [0..<i])", "by (auto intro!: nth_equalityI simp: rev_nth min_def)"], ["proof (state)\nthis:\n  small_fs_state state = map ((!) fs) (rev [0..<i])\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "from i"], ["proof (chain)\npicking this:\n  i < m", "have mm: \"[0..<m] = [0 ..< i] @ [i] @ [Suc i ..< m]\""], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. [0..<m] = [0..<i] @ [i] @ [Suc i..<m]", "by (intro nth_equalityI, auto simp: nth_append nth_Cons split: nat.splits)"], ["proof (state)\nthis:\n  [0..<m] = [0..<i] @ [i] @ [Suc i..<m]\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "from res[unfolded def] True"], ["proof (chain)\npicking this:\n  (if upw\n   then LLL_Impl.basis_reduction_add_rows_loop n state i i\n         (small_fs_state state)\n   else state) =\n  state'\n  upw", "have \"LLL_Impl.basis_reduction_add_rows_loop n state i i (small_fs_state state) = state'\""], ["proof (prove)\nusing this:\n  (if upw\n   then LLL_Impl.basis_reduction_add_rows_loop n state i i\n         (small_fs_state state)\n   else state) =\n  state'\n  upw\n\ngoal (1 subgoal):\n 1. LLL_Impl.basis_reduction_add_rows_loop n state i i\n     (small_fs_state state) =\n    state'", "by auto"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_add_rows_loop n state i i\n   (small_fs_state state) =\n  state'\n\ngoal (1 subgoal):\n 1. upw \\<Longrightarrow>\n    LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "from basis_reduction_add_rows_loop_impl[OF impl start(1-2) this[unfolded id] le_refl i fs']"], ["proof (chain)\npicking this:\n  LLL_impl_inv state' i fs'\n  local.basis_reduction_add_rows_loop i fs i = fs'", "show ?thesis"], ["proof (prove)\nusing this:\n  LLL_impl_inv state' i fs'\n  local.basis_reduction_add_rows_loop i fs i = fs'\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    local.basis_reduction_add_rows upw i fs = fs'", "unfolding def"], ["proof (prove)\nusing this:\n  LLL_impl_inv state' i fs'\n  local.basis_reduction_add_rows_loop i fs i = fs'\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    (if upw then local.basis_reduction_add_rows_loop i fs i else fs) = fs'", "using True"], ["proof (prove)\nusing this:\n  LLL_impl_inv state' i fs'\n  local.basis_reduction_add_rows_loop i fs i = fs'\n  upw\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i fs' \\<and>\n    (if upw then local.basis_reduction_add_rows_loop i fs i else fs) = fs'", "by auto"], ["proof (state)\nthis:\n  LLL_impl_inv state' i fs' \\<and>\n  local.basis_reduction_add_rows upw i fs = fs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_impl_inv state' i fs' \\<and>\n  local.basis_reduction_add_rows upw i fs = fs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_add_rows: assumes\n     impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_add_rows n upw i state = state'\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i fs'\"\n  \"LLL_invariant False i fs'\"\n  \"LLL_measure i fs' = LLL_measure i fs\"\n  \"basis_reduction_add_rows upw i fs = fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LLL_impl_inv state' i fs' &&& LLL_invariant False i fs') &&&\n    LLL_measure i fs' = LLL_measure i fs &&&\n    local.basis_reduction_add_rows upw i fs = fs'", "using basis_reduction_add_rows_impl[OF impl inv res i fs']\n    basis_reduction_add_rows[OF inv _ i]"], ["proof (prove)\nusing this:\n  LLL_impl_inv state' i fs'\n  local.basis_reduction_add_rows upw i fs = fs'\n  local.basis_reduction_add_rows upw i fs = ?fs' \\<Longrightarrow>\n  LLL_invariant False i ?fs'\n  local.basis_reduction_add_rows upw i fs = ?fs' \\<Longrightarrow>\n  LLL_measure i ?fs' = LLL_measure i fs\n\ngoal (1 subgoal):\n 1. (LLL_impl_inv state' i fs' &&& LLL_invariant False i fs') &&&\n    LLL_measure i fs' = LLL_measure i fs &&&\n    local.basis_reduction_add_rows upw i fs = fs'", "by blast+"], ["", "lemma basis_reduction_swap_impl: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant False i fs\"\n  and res: \"LLL_Impl.basis_reduction_swap m i state = (upw',i',state')\"\n  and cond: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\"\n  and i: \"i < m\" and i0: \"i \\<noteq> 0\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i' fs'\" (is ?g1)\n  \"basis_reduction_swap i fs = (upw',i',fs')\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' &&&\n    local.basis_reduction_swap i fs = (upw', i', fs')", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "from i i0"], ["proof (chain)\npicking this:\n  i < m\n  i \\<noteq> 0", "have ii: \"i - 1 < i\" and le_m: \"i - 1 \\<le> m\" \"i \\<le> m\" \"Suc i \\<le> m\""], ["proof (prove)\nusing this:\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i - 1 < i &&& i - 1 \\<le> m &&& i \\<le> m &&& Suc i \\<le> m", "by auto"], ["proof (state)\nthis:\n  i - 1 < i\n  i - 1 \\<le> m\n  i \\<le> m\n  Suc i \\<le> m\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "obtain f mu ds where state: \"state = (f,mu,ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f mu ds.\n        state = (f, mu, ds) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases state, auto)"], ["proof (state)\nthis:\n  state = (f, mu, ds)\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note dmu_ij_state = dmu_ij_state[OF impl inv state]"], ["proof (state)\nthis:\n  \\<lbrakk>?j < ?ii; ?ii < m\\<rbrakk>\n  \\<Longrightarrow> dmu_ij_state state ?ii ?j = d\\<mu> fs ?ii ?j\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note d_state = d_state[OF impl inv state]"], ["proof (state)\nthis:\n  ?ii \\<le> m \\<Longrightarrow> d_state state ?ii = d fs ?ii\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note res = res[unfolded LLL_Impl.basis_reduction_swap_def Let_def split state, folded state,\n    unfolded fi_state[OF impl inv state i] fim1_state[OF impl inv state i i0]]"], ["proof (state)\nthis:\n  (False, i - 1, dec_i (update_im1 (update_i f (fs ! (i - 1))) (fs ! i)),\n   swap_mu m mu i (dmu_ij_state state i (i - 1)) (d_state state (i - 1))\n    (d_state state i) (d_state state (Suc i)),\n   iarray_update ds i\n    ((d_state state (Suc i) * d_state state (i - 1) +\n      dmu_ij_state state i (i - 1) * dmu_ij_state state i (i - 1)) div\n     d_state state i)) =\n  (upw', i', state')\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note state_id = dmu_ij_state[OF ii i]"], ["proof (state)\nthis:\n  dmu_ij_state state i (i - 1) = d\\<mu> fs i (i - 1)\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note d_state_i = d_state[OF le_m(1)] d_state[OF le_m(2)] d_state[OF le_m(3)]"], ["proof (state)\nthis:\n  d_state state (i - 1) = d fs (i - 1)\n  d_state state i = d fs i\n  d_state state (Suc i) = d fs (Suc i)\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "from LLL_invD[OF inv]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  False \\<or> \\<mu>_small fs i", "have len: \"length fs = m\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  False \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. length fs = m", "by auto"], ["proof (state)\nthis:\n  length fs = m\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "from fs_state[OF impl inv state len]"], ["proof (chain)\npicking this:\n  fs_state state = fs", "have fs: \"fs_state state = fs\""], ["proof (prove)\nusing this:\n  fs_state state = fs\n\ngoal (1 subgoal):\n 1. fs_state state = fs", "by auto"], ["proof (state)\nthis:\n  fs_state state = fs\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "obtain fs'' where fs'': \"fs[i := fs ! (i - 1), i - 1 := fs ! i] = fs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs''.\n        fs[i := fs ! (i - 1), i - 1 := fs ! i] = fs'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fs[i := fs ! (i - 1), i - 1 := fs ! i] = fs''\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "let ?r = rat_of_int"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "let ?d = \"d fs\""], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "let ?d' = \"d fs''\""], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "let ?dmus = \"dmu_ij_state state\""], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "let ?ds = \"d_state state\""], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note swap = basis_reduction_swap_main[OF invw disjI1[OF inv] i i0 cond refl, unfolded fs'']"], ["proof (state)\nthis:\n  LLL_invariant_weak fs''\n  LLL_invariant False i fs \\<Longrightarrow>\n  LLL_invariant False (i - 1) fs''\n  LLL_measure (i - 1) fs'' < LLL_measure i fs\n  ?k < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'') ?k =\n  (if ?k = i - 1\n   then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n         (i - 1) \\<cdot>\\<^sub>v\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (i - 1)\n   else if ?k = i\n        then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (i - 1) -\n             map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'') (i - 1) /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                         (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'') (i - 1)\n        else gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?k)\n  ?k < m \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n              ?k\\<parallel>\\<^sup>2 =\n  (if ?k = i - 1\n   then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    i\\<parallel>\\<^sup>2 +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    (i - 1)\\<parallel>\\<^sup>2\n   else if ?k = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         i\\<parallel>\\<^sup>2 *\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                         (i - 1)\\<parallel>\\<^sup>2\n        else \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         ?k\\<parallel>\\<^sup>2)\n  \\<lbrakk>?ii < m; ?j < ?ii\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs'')\n                     ?ii ?j =\n                    (if ?ii = i - 1\n                     then gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) i ?j\n                     else if ?ii = i\n                          then if ?j = i - 1\n                               then gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) i (i - 1) *\n                                    \\<parallel>gram_schmidt_fs.gso n\n          (map of_int_hom.vec_hom fs) (i - 1)\\<parallel>\\<^sup>2 /\n                                    \\<parallel>gram_schmidt_fs.gso n\n          (map of_int_hom.vec_hom fs'') (i - 1)\\<parallel>\\<^sup>2\n                               else gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) (i - 1) ?j\n                          else if i < ?ii \\<and> ?j = i\n                               then gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) ?ii\n                                     (i - 1) -\n                                    gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) i (i - 1) *\n                                    gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) ?ii i\n                               else if i < ?ii \\<and> ?j = i - 1\n                                    then gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ?ii (i - 1) *\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs'') i (i - 1) +\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ?ii i *\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               i\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ?ii ?j)\n  ?ii \\<le> m \\<Longrightarrow>\n  rat_of_int (d fs'' ?ii) =\n  (if ?ii = i\n   then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                    (i - 1)\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    (i - 1)\\<parallel>\\<^sup>2 *\n        rat_of_int (d fs i)\n   else rat_of_int (d fs ?ii))\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note invw2 = swap(1)"], ["proof (state)\nthis:\n  LLL_invariant_weak fs''\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note swap = swap(2)[OF inv] swap(3-)"], ["proof (state)\nthis:\n  LLL_invariant False (i - 1) fs''\n  LLL_measure (i - 1) fs'' < LLL_measure i fs\n  ?k < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'') ?k =\n  (if ?k = i - 1\n   then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) i +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i\n         (i - 1) \\<cdot>\\<^sub>v\n        gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (i - 1)\n   else if ?k = i\n        then gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) (i - 1) -\n             map of_int_hom.vec_hom fs ! (i - 1) \\<bullet>\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'') (i - 1) /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                         (i - 1)\\<parallel>\\<^sup>2 \\<cdot>\\<^sub>v\n             gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'') (i - 1)\n        else gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?k)\n  ?k < m \\<Longrightarrow>\n  \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n              ?k\\<parallel>\\<^sup>2 =\n  (if ?k = i - 1\n   then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    i\\<parallel>\\<^sup>2 +\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n        gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) i (i - 1) *\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    (i - 1)\\<parallel>\\<^sup>2\n   else if ?k = i\n        then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         i\\<parallel>\\<^sup>2 *\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         (i - 1)\\<parallel>\\<^sup>2 /\n             \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                         (i - 1)\\<parallel>\\<^sup>2\n        else \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                         ?k\\<parallel>\\<^sup>2)\n  \\<lbrakk>?ii < m; ?j < ?ii\\<rbrakk>\n  \\<Longrightarrow> gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs'')\n                     ?ii ?j =\n                    (if ?ii = i - 1\n                     then gram_schmidt_fs.\\<mu> n\n                           (map of_int_hom.vec_hom fs) i ?j\n                     else if ?ii = i\n                          then if ?j = i - 1\n                               then gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) i (i - 1) *\n                                    \\<parallel>gram_schmidt_fs.gso n\n          (map of_int_hom.vec_hom fs) (i - 1)\\<parallel>\\<^sup>2 /\n                                    \\<parallel>gram_schmidt_fs.gso n\n          (map of_int_hom.vec_hom fs'') (i - 1)\\<parallel>\\<^sup>2\n                               else gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) (i - 1) ?j\n                          else if i < ?ii \\<and> ?j = i\n                               then gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) ?ii\n                                     (i - 1) -\n                                    gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) i (i - 1) *\n                                    gram_schmidt_fs.\\<mu> n\n                                     (map of_int_hom.vec_hom fs) ?ii i\n                               else if i < ?ii \\<and> ?j = i - 1\n                                    then gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ?ii (i - 1) *\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs'') i (i - 1) +\n   gram_schmidt_fs.\\<mu> n (map of_int_hom.vec_hom fs) ?ii i *\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               i\\<parallel>\\<^sup>2 /\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n               (i - 1)\\<parallel>\\<^sup>2\n                                    else gram_schmidt_fs.\\<mu> n\n    (map of_int_hom.vec_hom fs) ?ii ?j)\n  ?ii \\<le> m \\<Longrightarrow>\n  rat_of_int (d fs'' ?ii) =\n  (if ?ii = i\n   then \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs'')\n                    (i - 1)\\<parallel>\\<^sup>2 /\n        \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                    (i - 1)\\<parallel>\\<^sup>2 *\n        rat_of_int (d fs i)\n   else rat_of_int (d fs ?ii))\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "interpret fs: fs_int' n m fs_init fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs", "by standard (use invw in auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "interpret fs'': fs_int' n m fs_init fs''"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs''", "by standard (use invw2 in auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note dmu = fs.d\\<mu>"], ["proof (state)\nthis:\n  \\<lbrakk>?j < length fs; ?ii < length fs\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (fs.d\\<mu> ?ii ?j) =\n                    rat_of_int (fs''.d fs (Suc ?j)) * fs.gs.\\<mu> ?ii ?j\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note dmu' = fs''.d\\<mu>"], ["proof (state)\nthis:\n  \\<lbrakk>?j < length fs''; ?ii < length fs''\\<rbrakk>\n  \\<Longrightarrow> rat_of_int (fs''.d\\<mu> ?ii ?j) =\n                    rat_of_int (fs''.d fs'' (Suc ?j)) * fs''.gs.\\<mu> ?ii ?j\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note inv' = LLL_invD[OF inv]"], ["proof (state)\nthis:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs.gs.gso ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  fs.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs.gs.reduced \\<alpha> i\n  False \\<or> \\<mu>_small fs i\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "have fi: \"fs ! (i - 1) = fs'' ! i\" \"fs ! i = fs'' ! (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! (i - 1) = fs'' ! i &&& fs ! i = fs'' ! (i - 1)", "unfolding fs''[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs ! (i - 1) = fs[i := fs ! (i - 1), i - 1 := fs ! i] ! i &&&\n    fs ! i = fs[i := fs ! (i - 1), i - 1 := fs ! i] ! (i - 1)", "using inv'(6) i i0"], ["proof (prove)\nusing this:\n  length fs = m\n  i < m\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fs ! (i - 1) = fs[i := fs ! (i - 1), i - 1 := fs ! i] ! i &&&\n    fs ! i = fs[i := fs ! (i - 1), i - 1 := fs ! i] ! (i - 1)", "by auto"], ["proof (state)\nthis:\n  fs ! (i - 1) = fs'' ! i\n  fs ! i = fs'' ! (i - 1)\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "from res"], ["proof (chain)\npicking this:\n  (False, i - 1, dec_i (update_im1 (update_i f (fs ! (i - 1))) (fs ! i)),\n   swap_mu m mu i (dmu_ij_state state i (i - 1)) (d_state state (i - 1))\n    (d_state state i) (d_state state (Suc i)),\n   iarray_update ds i\n    ((d_state state (Suc i) * d_state state (i - 1) +\n      dmu_ij_state state i (i - 1) * dmu_ij_state state i (i - 1)) div\n     d_state state i)) =\n  (upw', i', state')", "have upw': \"upw' = False\" \"i' = i - 1\""], ["proof (prove)\nusing this:\n  (False, i - 1, dec_i (update_im1 (update_i f (fs ! (i - 1))) (fs ! i)),\n   swap_mu m mu i (dmu_ij_state state i (i - 1)) (d_state state (i - 1))\n    (d_state state i) (d_state state (Suc i)),\n   iarray_update ds i\n    ((d_state state (Suc i) * d_state state (i - 1) +\n      dmu_ij_state state i (i - 1) * dmu_ij_state state i (i - 1)) div\n     d_state state i)) =\n  (upw', i', state')\n\ngoal (1 subgoal):\n 1. upw' = False &&& i' = i - 1", "by auto"], ["proof (state)\nthis:\n  upw' = False\n  i' = i - 1\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "let ?dmu_repr' = \"swap_mu m mu i (?dmus i (i - 1)) (?d (i - 1)) (?d i) (?d (Suc i))\""], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "let ?d'i = \"(?d (Suc i) * ?d (i - 1) + ?dmus i (i - 1) * ?dmus i (i - 1)) div (?d i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "from res[unfolded fi d_state_i]"], ["proof (chain)\npicking this:\n  (False, i - 1,\n   dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))),\n   swap_mu m mu i (dmu_ij_state state i (i - 1)) (d fs (i - 1)) (d fs i)\n    (d fs (Suc i)),\n   iarray_update ds i\n    ((d fs (Suc i) * d fs (i - 1) +\n      dmu_ij_state state i (i - 1) * dmu_ij_state state i (i - 1)) div\n     d fs i)) =\n  (upw', i', state')", "have res: \"upw' = False\" \"i' = i - 1\"\n    \"state' = (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))),\n       ?dmu_repr', iarray_update ds i ?d'i)\""], ["proof (prove)\nusing this:\n  (False, i - 1,\n   dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))),\n   swap_mu m mu i (dmu_ij_state state i (i - 1)) (d fs (i - 1)) (d fs i)\n    (d fs (Suc i)),\n   iarray_update ds i\n    ((d fs (Suc i) * d fs (i - 1) +\n      dmu_ij_state state i (i - 1) * dmu_ij_state state i (i - 1)) div\n     d fs i)) =\n  (upw', i', state')\n\ngoal (1 subgoal):\n 1. upw' = False &&&\n    i' = i - 1 &&&\n    state' =\n    (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))),\n     swap_mu m mu i (dmu_ij_state state i (i - 1)) (d fs (i - 1)) (d fs i)\n      (d fs (Suc i)),\n     iarray_update ds i\n      ((d fs (Suc i) * d fs (i - 1) +\n        dmu_ij_state state i (i - 1) * dmu_ij_state state i (i - 1)) div\n       d fs i))", "by auto"], ["proof (state)\nthis:\n  upw' = False\n  i' = i - 1\n  state' =\n  (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))),\n   swap_mu m mu i (dmu_ij_state state i (i - 1)) (d fs (i - 1)) (d fs i)\n    (d fs (Suc i)),\n   iarray_update ds i\n    ((d fs (Suc i) * d fs (i - 1) +\n      dmu_ij_state state i (i - 1) * dmu_ij_state state i (i - 1)) div\n     d fs i))\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "from i"], ["proof (chain)\npicking this:\n  i < m", "have ii: \"i < length [0..<m]\" and im1: \"i - 1 < m\""], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. i < length [0..<m] &&& i - 1 < m", "by auto"], ["proof (state)\nthis:\n  i < length [0..<m]\n  i - 1 < m\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note list_repr = to_list_repr[OF impl inv state]"], ["proof (state)\nthis:\n  list_repr i f (map ((!) fs) [0..<m])\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "from dec_i[OF update_im1[OF update_i[OF list_repr(1)]], unfolded length_map, OF ii i0 i0]"], ["proof (chain)\npicking this:\n  list_repr (i - 1) (dec_i (update_im1 (update_i f ?x2) ?x1))\n   ((map ((!) fs) [0..<m])[i := ?x2, i - 1 := ?x1])", "have\n    \"list_repr (i - 1) (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1)))) ((map ((!) fs) [0..<m])[i := (fs'' ! i),\n       i - 1 := (fs'' ! (i - 1))])\" (is \"list_repr _ ?fr ?xs\")"], ["proof (prove)\nusing this:\n  list_repr (i - 1) (dec_i (update_im1 (update_i f ?x2) ?x1))\n   ((map ((!) fs) [0..<m])[i := ?x2, i - 1 := ?x1])\n\ngoal (1 subgoal):\n 1. list_repr (i - 1)\n     (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))))\n     ((map ((!) fs) [0..<m])[i := fs'' ! i, i - 1 := fs'' ! (i - 1)])", "."], ["proof (state)\nthis:\n  list_repr (i - 1)\n   (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))))\n   ((map ((!) fs) [0..<m])[i := fs'' ! i, i - 1 := fs'' ! (i - 1)])\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "also"], ["proof (state)\nthis:\n  list_repr (i - 1)\n   (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))))\n   ((map ((!) fs) [0..<m])[i := fs'' ! i, i - 1 := fs'' ! (i - 1)])\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "have \"?xs = map ((!) fs'') [0..<m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map ((!) fs) [0..<m])[i := fs'' ! i, i - 1 := fs'' ! (i - 1)] =\n    map ((!) fs'') [0..<m]", "unfolding fs''[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map ((!) fs) [0..<m])\n    [i := fs[i := fs ! (i - 1), i - 1 := fs ! i] ! i,\n     i - 1 := fs[i := fs ! (i - 1), i - 1 := fs ! i] ! (i - 1)] =\n    map ((!) (fs[i := fs ! (i - 1), i - 1 := fs ! i])) [0..<m]", "by (intro nth_equalityI, insert i i0 len, auto simp: nth_append, rename_tac ii, case_tac \"ii \\<in> {i-1,i}\", auto)"], ["proof (state)\nthis:\n  (map ((!) fs) [0..<m])[i := fs'' ! i, i - 1 := fs'' ! (i - 1)] =\n  map ((!) fs'') [0..<m]\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "finally"], ["proof (chain)\npicking this:\n  list_repr (i - 1)\n   (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))))\n   (map ((!) fs'') [0..<m])", "have f_repr: \"list_repr (i - 1) ?fr (map ((!) fs'') [0..<m])\""], ["proof (prove)\nusing this:\n  list_repr (i - 1)\n   (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))))\n   (map ((!) fs'') [0..<m])\n\ngoal (1 subgoal):\n 1. list_repr (i - 1)\n     (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))))\n     (map ((!) fs'') [0..<m])", "."], ["proof (state)\nthis:\n  list_repr (i - 1)\n   (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))))\n   (map ((!) fs'') [0..<m])\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "from i0"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "have sim1: \"Suc (i - 1) = i\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Suc (i - 1) = i", "by simp"], ["proof (state)\nthis:\n  Suc (i - 1) = i\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "from LLL_d_Suc[OF invw im1, unfolded sim1]"], ["proof (chain)\npicking this:\n  rat_of_int (d fs i) =\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs (i - 1))", "have \"length fs'' = m\""], ["proof (prove)\nusing this:\n  rat_of_int (d fs i) =\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs (i - 1))\n\ngoal (1 subgoal):\n 1. length fs'' = m", "using fs'' inv'(6)"], ["proof (prove)\nusing this:\n  rat_of_int (d fs i) =\n  \\<parallel>fs.gs.gso (i - 1)\\<parallel>\\<^sup>2 *\n  rat_of_int (d fs (i - 1))\n  fs[i := fs ! (i - 1), i - 1 := fs ! i] = fs''\n  length fs = m\n\ngoal (1 subgoal):\n 1. length fs'' = m", "by auto"], ["proof (state)\nthis:\n  length fs'' = m\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "hence fs_id: \"fs' = fs''\""], ["proof (prove)\nusing this:\n  length fs'' = m\n\ngoal (1 subgoal):\n 1. fs' = fs''", "unfolding fs' res fs_state.simps"], ["proof (prove)\nusing this:\n  length fs'' = m\n\ngoal (1 subgoal):\n 1. of_list_repr\n     (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1)))) =\n    fs''", "using of_list_repr[OF f_repr]"], ["proof (prove)\nusing this:\n  length fs'' = m\n  of_list_repr\n   (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1)))) =\n  map ((!) fs'') [0..<m]\n\ngoal (1 subgoal):\n 1. of_list_repr\n     (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1)))) =\n    fs''", "by (intro nth_equalityI, auto simp: o_def)"], ["proof (state)\nthis:\n  fs' = fs''\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "from to_mu_repr[OF impl inv state]"], ["proof (chain)\npicking this:\n  mu_repr mu fs", "have mu: \"mu_repr mu fs\""], ["proof (prove)\nusing this:\n  mu_repr mu fs\n\ngoal (1 subgoal):\n 1. mu_repr mu fs", "by auto"], ["proof (state)\nthis:\n  mu_repr mu fs\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "from to_d_repr[OF impl inv state]"], ["proof (chain)\npicking this:\n  d_repr ds fs", "have d_repr: \"d_repr ds fs\""], ["proof (prove)\nusing this:\n  d_repr ds fs\n\ngoal (1 subgoal):\n 1. d_repr ds fs", "by auto"], ["proof (state)\nthis:\n  d_repr ds fs\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note mu_def = mu[unfolded mu_repr_def]"], ["proof (state)\nthis:\n  mu = IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note updates = d_d\\<mu>_swap[OF invw disjI1[OF inv] i i0 cond fs''[symmetric]]"], ["proof (state)\nthis:\n  ?i \\<le> m \\<Longrightarrow>\n  d fs'' ?i =\n  (if ?i = i\n   then (d fs (Suc i) * d fs (i - 1) +\n         d\\<mu> fs i (i - 1) * d\\<mu> fs i (i - 1)) div\n        d fs i\n   else d fs ?i)\n  \\<lbrakk>?i < m; ?j < ?i\\<rbrakk>\n  \\<Longrightarrow> d\\<mu> fs'' ?i ?j =\n                    (if ?i = i - 1 then d\\<mu> fs i ?j\n                     else if ?i = i \\<and> ?j \\<noteq> i - 1\n                          then d\\<mu> fs (i - 1) ?j\n                          else if i < ?i \\<and> ?j = i\n                               then (d fs (Suc i) * d\\<mu> fs ?i (i - 1) -\n                                     d\\<mu> fs i (i - 1) *\n                                     d\\<mu> fs ?i ?j) div\n                                    d fs i\n                               else if i < ?i \\<and> ?j = i - 1\n                                    then (d\\<mu> fs i (i - 1) *\n    d\\<mu> fs ?i ?j +\n    d\\<mu> fs ?i i * d fs (i - 1)) div\n   d fs i\n                                    else d\\<mu> fs ?i ?j)\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "note dmu_ii = dmu_ij_state[OF \\<open>i - 1 < i\\<close> i]"], ["proof (state)\nthis:\n  dmu_ij_state state i (i - 1) = d\\<mu> fs i (i - 1)\n\ngoal (2 subgoals):\n 1. LLL_impl_inv state' i' fs'\n 2. local.basis_reduction_swap i fs = (upw', i', fs')", "show ?g1"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs'", "unfolding fs_id LLL_impl_inv.simps res"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_repr (i - 1)\n     (dec_i (update_im1 (update_i f (fs'' ! i)) (fs'' ! (i - 1))))\n     (map ((!) fs'') [0..<m]) \\<and>\n    d_repr\n     (iarray_update ds i\n       ((d fs (Suc i) * d fs (i - 1) +\n         dmu_ij_state state i (i - 1) * dmu_ij_state state i (i - 1)) div\n        d fs i))\n     fs'' \\<and>\n    mu_repr\n     (swap_mu m mu i (dmu_ij_state state i (i - 1)) (d fs (i - 1)) (d fs i)\n       (d fs (Suc i)))\n     fs''", "proof (intro conjI f_repr)"], ["proof (state)\ngoal (2 subgoals):\n 1. d_repr\n     (iarray_update ds i\n       ((d fs (Suc i) * d fs (i - 1) +\n         dmu_ij_state state i (i - 1) * dmu_ij_state state i (i - 1)) div\n        d fs i))\n     fs''\n 2. mu_repr\n     (swap_mu m mu i (dmu_ij_state state i (i - 1)) (d fs (i - 1)) (d fs i)\n       (d fs (Suc i)))\n     fs''", "show \"d_repr (iarray_update ds i ?d'i) fs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_repr\n     (iarray_update ds i\n       ((d fs (Suc i) * d fs (i - 1) +\n         dmu_ij_state state i (i - 1) * dmu_ij_state state i (i - 1)) div\n        d fs i))\n     fs''", "unfolding d_repr[unfolded d_repr_def] d_repr_def iarray_update_of_fun dmu_ii"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     ((d fs)\n      (i := (d fs (Suc i) * d fs (i - 1) +\n             d\\<mu> fs i (i - 1) * d\\<mu> fs i (i - 1)) div\n            d fs i))\n     (Suc m) =\n    IArray.of_fun (d fs'') (Suc m)", "by (rule iarray_cong', subst updates(1), auto simp: nth_append intro: arg_cong)"], ["proof (state)\nthis:\n  d_repr\n   (iarray_update ds i\n     ((d fs (Suc i) * d fs (i - 1) +\n       dmu_ij_state state i (i - 1) * dmu_ij_state state i (i - 1)) div\n      d fs i))\n   fs''\n\ngoal (1 subgoal):\n 1. mu_repr\n     (swap_mu m mu i (dmu_ij_state state i (i - 1)) (d fs (i - 1)) (d fs i)\n       (d fs (Suc i)))\n     fs''", "show \"mu_repr ?dmu_repr' fs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mu_repr\n     (swap_mu m mu i (dmu_ij_state state i (i - 1)) (d fs (i - 1)) (d fs i)\n       (d fs (Suc i)))\n     fs''", "unfolding mu_repr_def swap_mu_def Let_def dmu_ii"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>ii.\n         if ii < i - 1 then mu !! ii\n         else if i < ii\n              then IArray.of_fun\n                    (\\<lambda>j.\n                        if j = i\n                        then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                              d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                             d fs i\n                        else if j = i - 1\n                             then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                                   mu !! ii !! i * d fs (i - 1)) div\n                                  d fs i\n                             else mu !! ii !! j)\n                    ii\n              else if ii = i\n                   then IArray.of_fun\n                         (\\<lambda>j.\n                             if j = i - 1 then d\\<mu> fs i (i - 1)\n                             else mu !! (i - 1) !! j)\n                         ii\n                   else IArray.of_fun ((!!) (mu !! i)) ii)\n     m =\n    IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs'' i) i) m", "proof (rule iarray_cong', goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < m \\<Longrightarrow>\n       (if ia < i - 1 then mu !! ia\n        else if i < ia\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = i\n                       then (d fs (Suc i) * mu !! ia !! (i - 1) -\n                             d\\<mu> fs i (i - 1) * mu !! ia !! j) div\n                            d fs i\n                       else if j = i - 1\n                            then (d\\<mu> fs i (i - 1) * mu !! ia !! j +\n                                  mu !! ia !! i * d fs (i - 1)) div\n                                 d fs i\n                            else mu !! ia !! j)\n                   ia\n             else if ia = i\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = i - 1 then d\\<mu> fs i (i - 1)\n                            else mu !! (i - 1) !! j)\n                        ia\n                  else IArray.of_fun ((!!) (mu !! i)) ia) =\n       IArray.of_fun (d\\<mu> fs'' ia) ia", "case ii: (1 ii)"], ["proof (state)\nthis:\n  ii < m\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < m \\<Longrightarrow>\n       (if ia < i - 1 then mu !! ia\n        else if i < ia\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = i\n                       then (d fs (Suc i) * mu !! ia !! (i - 1) -\n                             d\\<mu> fs i (i - 1) * mu !! ia !! j) div\n                            d fs i\n                       else if j = i - 1\n                            then (d\\<mu> fs i (i - 1) * mu !! ia !! j +\n                                  mu !! ia !! i * d fs (i - 1)) div\n                                 d fs i\n                            else mu !! ia !! j)\n                   ia\n             else if ia = i\n                  then IArray.of_fun\n                        (\\<lambda>j.\n                            if j = i - 1 then d\\<mu> fs i (i - 1)\n                            else mu !! (i - 1) !! j)\n                        ia\n                  else IArray.of_fun ((!!) (mu !! i)) ia) =\n       IArray.of_fun (d\\<mu> fs'' ia) ia", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "proof (cases \"ii < i - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii\n 2. \\<not> ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "case small: True"], ["proof (state)\nthis:\n  ii < i - 1\n\ngoal (2 subgoals):\n 1. ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii\n 2. \\<not> ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "hence id: \"(ii = i) = False\" \"(ii = i - 1) = False\" \"(i < ii) = False\" \"(ii < i - 1) = True\""], ["proof (prove)\nusing this:\n  ii < i - 1\n\ngoal (1 subgoal):\n 1. ((ii = i) = False &&& (ii = i - 1) = False) &&&\n    (i < ii) = False &&& (ii < i - 1) = True", "by auto"], ["proof (state)\nthis:\n  (ii = i) = False\n  (ii = i - 1) = False\n  (i < ii) = False\n  (ii < i - 1) = True\n\ngoal (2 subgoals):\n 1. ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii\n 2. \\<not> ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "have mu: \"mu !! ii = IArray.of_fun (d\\<mu> fs ii) ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mu !! ii = IArray.of_fun (d\\<mu> fs ii) ii", "using ii"], ["proof (prove)\nusing this:\n  ii < m\n\ngoal (1 subgoal):\n 1. mu !! ii = IArray.of_fun (d\\<mu> fs ii) ii", "unfolding mu_def"], ["proof (prove)\nusing this:\n  ii < m\n\ngoal (1 subgoal):\n 1. IArray.of_fun (\\<lambda>i. IArray.of_fun (d\\<mu> fs i) i) m !! ii =\n    IArray.of_fun (d\\<mu> fs ii) ii", "by auto"], ["proof (state)\nthis:\n  mu !! ii = IArray.of_fun (d\\<mu> fs ii) ii\n\ngoal (2 subgoals):\n 1. ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii\n 2. \\<not> ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "unfolding id if_True if_False mu"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun (d\\<mu> fs ii) ii = IArray.of_fun (d\\<mu> fs'' ii) ii", "by (rule iarray_cong', insert small ii i i0, subst updates(2), simp_all, linarith)"], ["proof (state)\nthis:\n  (if ii < i - 1 then mu !! ii\n   else if i < ii\n        then IArray.of_fun\n              (\\<lambda>j.\n                  if j = i\n                  then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                        d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                       d fs i\n                  else if j = i - 1\n                       then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                             mu !! ii !! i * d fs (i - 1)) div\n                            d fs i\n                       else mu !! ii !! j)\n              ii\n        else if ii = i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = i - 1 then d\\<mu> fs i (i - 1)\n                       else mu !! (i - 1) !! j)\n                   ii\n             else IArray.of_fun ((!!) (mu !! i)) ii) =\n  IArray.of_fun (d\\<mu> fs'' ii) ii\n\ngoal (1 subgoal):\n 1. \\<not> ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "case False"], ["proof (state)\nthis:\n  \\<not> ii < i - 1\n\ngoal (1 subgoal):\n 1. \\<not> ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "hence iFalse: \"(ii < i - 1) = False\""], ["proof (prove)\nusing this:\n  \\<not> ii < i - 1\n\ngoal (1 subgoal):\n 1. (ii < i - 1) = False", "by auto"], ["proof (state)\nthis:\n  (ii < i - 1) = False\n\ngoal (1 subgoal):\n 1. \\<not> ii < i - 1 \\<Longrightarrow>\n    (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ii < i - 1 then mu !! ii\n     else if i < ii\n          then IArray.of_fun\n                (\\<lambda>j.\n                    if j = i\n                    then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                          d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                         d fs i\n                    else if j = i - 1\n                         then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                               mu !! ii !! i * d fs (i - 1)) div\n                              d fs i\n                         else mu !! ii !! j)\n                ii\n          else if ii = i\n               then IArray.of_fun\n                     (\\<lambda>j.\n                         if j = i - 1 then d\\<mu> fs i (i - 1)\n                         else mu !! (i - 1) !! j)\n                     ii\n               else IArray.of_fun ((!!) (mu !! i)) ii) =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "unfolding iFalse if_False if_distrib[of \"\\<lambda> f. IArray.of_fun f ii\", symmetric]\n          dmu_ij_state.simps[of f mu ds, folded state, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (if i < ii\n      then \\<lambda>j.\n              if j = i\n              then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                    d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                   d fs i\n              else if j = i - 1\n                   then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                         dmu_ij_state state ii i * d fs (i - 1)) div\n                        d fs i\n                   else dmu_ij_state state ii j\n      else if ii = i\n           then \\<lambda>j.\n                   if j = i - 1 then d\\<mu> fs i (i - 1)\n                   else dmu_ij_state state (i - 1) j\n           else dmu_ij_state state i)\n     ii =\n    IArray.of_fun (d\\<mu> fs'' ii) ii", "proof (rule iarray_cong', goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < ii \\<Longrightarrow>\n       (if i < ii\n        then \\<lambda>j.\n                if j = i\n                then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                      d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                     d fs i\n                else if j = i - 1\n                     then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                           dmu_ij_state state ii i * d fs (i - 1)) div\n                          d fs i\n                     else dmu_ij_state state ii j\n        else if ii = i\n             then \\<lambda>j.\n                     if j = i - 1 then d\\<mu> fs i (i - 1)\n                     else dmu_ij_state state (i - 1) j\n             else dmu_ij_state state i)\n        ia =\n       d\\<mu> fs'' ii ia", "case j: (1 j)"], ["proof (state)\nthis:\n  j < ii\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < ii \\<Longrightarrow>\n       (if i < ii\n        then \\<lambda>j.\n                if j = i\n                then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                      d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                     d fs i\n                else if j = i - 1\n                     then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                           dmu_ij_state state ii i * d fs (i - 1)) div\n                          d fs i\n                     else dmu_ij_state state ii j\n        else if ii = i\n             then \\<lambda>j.\n                     if j = i - 1 then d\\<mu> fs i (i - 1)\n                     else dmu_ij_state state (i - 1) j\n             else dmu_ij_state state i)\n        ia =\n       d\\<mu> fs'' ii ia", "note upd = updates(2)[OF ii j] dmu_ii dmu_ij_state[OF j ii] if_distrib[of \"\\<lambda> x. x j\"]"], ["proof (state)\nthis:\n  d\\<mu> fs'' ii j =\n  (if ii = i - 1 then d\\<mu> fs i j\n   else if ii = i \\<and> j \\<noteq> i - 1 then d\\<mu> fs (i - 1) j\n        else if i < ii \\<and> j = i\n             then (d fs (Suc i) * d\\<mu> fs ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n                  d fs i\n             else if i < ii \\<and> j = i - 1\n                  then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                        d\\<mu> fs ii i * d fs (i - 1)) div\n                       d fs i\n                  else d\\<mu> fs ii j)\n  dmu_ij_state state i (i - 1) = d\\<mu> fs i (i - 1)\n  dmu_ij_state state ii j = d\\<mu> fs ii j\n  (if ?c then ?x else ?y) j = (if ?c then ?x j else ?y j)\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < ii \\<Longrightarrow>\n       (if i < ii\n        then \\<lambda>j.\n                if j = i\n                then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                      d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                     d fs i\n                else if j = i - 1\n                     then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                           dmu_ij_state state ii i * d fs (i - 1)) div\n                          d fs i\n                     else dmu_ij_state state ii j\n        else if ii = i\n             then \\<lambda>j.\n                     if j = i - 1 then d\\<mu> fs i (i - 1)\n                     else dmu_ij_state state (i - 1) j\n             else dmu_ij_state state i)\n        ia =\n       d\\<mu> fs'' ii ia", "note simps = dmu_ij_state[OF _ ii] dmu_ij_state[OF _ im1] dmu_ij_state[OF _ i]"], ["proof (state)\nthis:\n  ?j < ii \\<Longrightarrow> dmu_ij_state state ii ?j = d\\<mu> fs ii ?j\n  ?j < i - 1 \\<Longrightarrow>\n  dmu_ij_state state (i - 1) ?j = d\\<mu> fs (i - 1) ?j\n  ?j < i \\<Longrightarrow> dmu_ij_state state i ?j = d\\<mu> fs i ?j\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < ii \\<Longrightarrow>\n       (if i < ii\n        then \\<lambda>j.\n                if j = i\n                then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                      d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                     d fs i\n                else if j = i - 1\n                     then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                           dmu_ij_state state ii i * d fs (i - 1)) div\n                          d fs i\n                     else dmu_ij_state state ii j\n        else if ii = i\n             then \\<lambda>j.\n                     if j = i - 1 then d\\<mu> fs i (i - 1)\n                     else dmu_ij_state state (i - 1) j\n             else dmu_ij_state state i)\n        ia =\n       d\\<mu> fs'' ii ia", "from False"], ["proof (chain)\npicking this:\n  \\<not> ii < i - 1", "consider (I) \"ii = i\" \"j = i - 1\" | (Is) \"ii = i\" \"j \\<noteq> i - 1\" |\n            (Im1) \"ii = i - 1\" | (large) \"ii > i\""], ["proof (prove)\nusing this:\n  \\<not> ii < i - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ii = i; j = i - 1\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>ii = i; j \\<noteq> i - 1\\<rbrakk> \\<Longrightarrow> thesis;\n     ii = i - 1 \\<Longrightarrow> thesis;\n     i < ii \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>ii = i; j = i - 1\\<rbrakk> \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>ii = i; j \\<noteq> i - 1\\<rbrakk> \\<Longrightarrow> ?thesis1;\n   ii = i - 1 \\<Longrightarrow> ?thesis1;\n   i < ii \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < ii \\<Longrightarrow>\n       (if i < ii\n        then \\<lambda>j.\n                if j = i\n                then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                      d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                     d fs i\n                else if j = i - 1\n                     then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                           dmu_ij_state state ii i * d fs (i - 1)) div\n                          d fs i\n                     else dmu_ij_state state ii j\n        else if ii = i\n             then \\<lambda>j.\n                     if j = i - 1 then d\\<mu> fs i (i - 1)\n                     else dmu_ij_state state (i - 1) j\n             else dmu_ij_state state i)\n        ia =\n       d\\<mu> fs'' ii ia", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>ii = i; j = i - 1\\<rbrakk> \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>ii = i; j \\<noteq> i - 1\\<rbrakk> \\<Longrightarrow> ?thesis1;\n   ii = i - 1 \\<Longrightarrow> ?thesis1;\n   i < ii \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "proof (cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>ii = i; j = i - 1\\<rbrakk>\n    \\<Longrightarrow> (if i < ii\n                       then \\<lambda>j.\n                               if j = i\n                               then (d fs (Suc i) *\n                                     dmu_ij_state state ii (i - 1) -\n                                     d\\<mu> fs i (i - 1) *\n                                     dmu_ij_state state ii j) div\n                                    d fs i\n                               else if j = i - 1\n                                    then (d\\<mu> fs i (i - 1) *\n    dmu_ij_state state ii j +\n    dmu_ij_state state ii i * d fs (i - 1)) div\n   d fs i\n                                    else dmu_ij_state state ii j\n                       else if ii = i\n                            then \\<lambda>j.\n                                    if j = i - 1 then d\\<mu> fs i (i - 1)\n                                    else dmu_ij_state state (i - 1) j\n                            else dmu_ij_state state i)\n                       j =\n                      d\\<mu> fs'' ii j\n 2. \\<lbrakk>ii = i; j \\<noteq> i - 1\\<rbrakk>\n    \\<Longrightarrow> (if i < ii\n                       then \\<lambda>j.\n                               if j = i\n                               then (d fs (Suc i) *\n                                     dmu_ij_state state ii (i - 1) -\n                                     d\\<mu> fs i (i - 1) *\n                                     dmu_ij_state state ii j) div\n                                    d fs i\n                               else if j = i - 1\n                                    then (d\\<mu> fs i (i - 1) *\n    dmu_ij_state state ii j +\n    dmu_ij_state state ii i * d fs (i - 1)) div\n   d fs i\n                                    else dmu_ij_state state ii j\n                       else if ii = i\n                            then \\<lambda>j.\n                                    if j = i - 1 then d\\<mu> fs i (i - 1)\n                                    else dmu_ij_state state (i - 1) j\n                            else dmu_ij_state state i)\n                       j =\n                      d\\<mu> fs'' ii j\n 3. ii = i - 1 \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j\n 4. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "case (I)"], ["proof (state)\nthis:\n  ii = i\n  j = i - 1\n\ngoal (4 subgoals):\n 1. \\<lbrakk>ii = i; j = i - 1\\<rbrakk>\n    \\<Longrightarrow> (if i < ii\n                       then \\<lambda>j.\n                               if j = i\n                               then (d fs (Suc i) *\n                                     dmu_ij_state state ii (i - 1) -\n                                     d\\<mu> fs i (i - 1) *\n                                     dmu_ij_state state ii j) div\n                                    d fs i\n                               else if j = i - 1\n                                    then (d\\<mu> fs i (i - 1) *\n    dmu_ij_state state ii j +\n    dmu_ij_state state ii i * d fs (i - 1)) div\n   d fs i\n                                    else dmu_ij_state state ii j\n                       else if ii = i\n                            then \\<lambda>j.\n                                    if j = i - 1 then d\\<mu> fs i (i - 1)\n                                    else dmu_ij_state state (i - 1) j\n                            else dmu_ij_state state i)\n                       j =\n                      d\\<mu> fs'' ii j\n 2. \\<lbrakk>ii = i; j \\<noteq> i - 1\\<rbrakk>\n    \\<Longrightarrow> (if i < ii\n                       then \\<lambda>j.\n                               if j = i\n                               then (d fs (Suc i) *\n                                     dmu_ij_state state ii (i - 1) -\n                                     d\\<mu> fs i (i - 1) *\n                                     dmu_ij_state state ii j) div\n                                    d fs i\n                               else if j = i - 1\n                                    then (d\\<mu> fs i (i - 1) *\n    dmu_ij_state state ii j +\n    dmu_ij_state state ii i * d fs (i - 1)) div\n   d fs i\n                                    else dmu_ij_state state ii j\n                       else if ii = i\n                            then \\<lambda>j.\n                                    if j = i - 1 then d\\<mu> fs i (i - 1)\n                                    else dmu_ij_state state (i - 1) j\n                            else dmu_ij_state state i)\n                       j =\n                      d\\<mu> fs'' ii j\n 3. ii = i - 1 \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j\n 4. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "unfolding upd"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < ii\n     then if j = i\n          then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n               d fs i\n          else if j = i - 1\n               then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                     dmu_ij_state state ii i * d fs (i - 1)) div\n                    d fs i\n               else d\\<mu> fs ii j\n     else if ii = i\n          then if j = i - 1 then d\\<mu> fs i (i - 1)\n               else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i j) =\n    (if ii = i - 1 then d\\<mu> fs i j\n     else if ii = i \\<and> j \\<noteq> i - 1 then d\\<mu> fs (i - 1) j\n          else if i < ii \\<and> j = i\n               then (d fs (Suc i) * d\\<mu> fs ii (i - 1) -\n                     d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n                    d fs i\n               else if i < ii \\<and> j = i - 1\n                    then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                          d\\<mu> fs ii i * d fs (i - 1)) div\n                         d fs i\n                    else d\\<mu> fs ii j)", "using I"], ["proof (prove)\nusing this:\n  ii = i\n  j = i - 1\n\ngoal (1 subgoal):\n 1. (if i < ii\n     then if j = i\n          then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n               d fs i\n          else if j = i - 1\n               then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                     dmu_ij_state state ii i * d fs (i - 1)) div\n                    d fs i\n               else d\\<mu> fs ii j\n     else if ii = i\n          then if j = i - 1 then d\\<mu> fs i (i - 1)\n               else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i j) =\n    (if ii = i - 1 then d\\<mu> fs i j\n     else if ii = i \\<and> j \\<noteq> i - 1 then d\\<mu> fs (i - 1) j\n          else if i < ii \\<and> j = i\n               then (d fs (Suc i) * d\\<mu> fs ii (i - 1) -\n                     d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n                    d fs i\n               else if i < ii \\<and> j = i - 1\n                    then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                          d\\<mu> fs ii i * d fs (i - 1)) div\n                         d fs i\n                    else d\\<mu> fs ii j)", "by auto"], ["proof (state)\nthis:\n  (if i < ii\n   then \\<lambda>j.\n           if j = i\n           then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                 d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                d fs i\n           else if j = i - 1\n                then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                      dmu_ij_state state ii i * d fs (i - 1)) div\n                     d fs i\n                else dmu_ij_state state ii j\n   else if ii = i\n        then \\<lambda>j.\n                if j = i - 1 then d\\<mu> fs i (i - 1)\n                else dmu_ij_state state (i - 1) j\n        else dmu_ij_state state i)\n   j =\n  d\\<mu> fs'' ii j\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ii = i; j \\<noteq> i - 1\\<rbrakk>\n    \\<Longrightarrow> (if i < ii\n                       then \\<lambda>j.\n                               if j = i\n                               then (d fs (Suc i) *\n                                     dmu_ij_state state ii (i - 1) -\n                                     d\\<mu> fs i (i - 1) *\n                                     dmu_ij_state state ii j) div\n                                    d fs i\n                               else if j = i - 1\n                                    then (d\\<mu> fs i (i - 1) *\n    dmu_ij_state state ii j +\n    dmu_ij_state state ii i * d fs (i - 1)) div\n   d fs i\n                                    else dmu_ij_state state ii j\n                       else if ii = i\n                            then \\<lambda>j.\n                                    if j = i - 1 then d\\<mu> fs i (i - 1)\n                                    else dmu_ij_state state (i - 1) j\n                            else dmu_ij_state state i)\n                       j =\n                      d\\<mu> fs'' ii j\n 2. ii = i - 1 \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j\n 3. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>ii = i; j \\<noteq> i - 1\\<rbrakk>\n    \\<Longrightarrow> (if i < ii\n                       then \\<lambda>j.\n                               if j = i\n                               then (d fs (Suc i) *\n                                     dmu_ij_state state ii (i - 1) -\n                                     d\\<mu> fs i (i - 1) *\n                                     dmu_ij_state state ii j) div\n                                    d fs i\n                               else if j = i - 1\n                                    then (d\\<mu> fs i (i - 1) *\n    dmu_ij_state state ii j +\n    dmu_ij_state state ii i * d fs (i - 1)) div\n   d fs i\n                                    else dmu_ij_state state ii j\n                       else if ii = i\n                            then \\<lambda>j.\n                                    if j = i - 1 then d\\<mu> fs i (i - 1)\n                                    else dmu_ij_state state (i - 1) j\n                            else dmu_ij_state state i)\n                       j =\n                      d\\<mu> fs'' ii j\n 2. ii = i - 1 \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j\n 3. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "case (Is)"], ["proof (state)\nthis:\n  ii = i\n  j \\<noteq> i - 1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ii = i; j \\<noteq> i - 1\\<rbrakk>\n    \\<Longrightarrow> (if i < ii\n                       then \\<lambda>j.\n                               if j = i\n                               then (d fs (Suc i) *\n                                     dmu_ij_state state ii (i - 1) -\n                                     d\\<mu> fs i (i - 1) *\n                                     dmu_ij_state state ii j) div\n                                    d fs i\n                               else if j = i - 1\n                                    then (d\\<mu> fs i (i - 1) *\n    dmu_ij_state state ii j +\n    dmu_ij_state state ii i * d fs (i - 1)) div\n   d fs i\n                                    else dmu_ij_state state ii j\n                       else if ii = i\n                            then \\<lambda>j.\n                                    if j = i - 1 then d\\<mu> fs i (i - 1)\n                                    else dmu_ij_state state (i - 1) j\n                            else dmu_ij_state state i)\n                       j =\n                      d\\<mu> fs'' ii j\n 2. ii = i - 1 \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j\n 3. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "unfolding upd"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < ii\n     then if j = i\n          then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n               d fs i\n          else if j = i - 1\n               then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                     dmu_ij_state state ii i * d fs (i - 1)) div\n                    d fs i\n               else d\\<mu> fs ii j\n     else if ii = i\n          then if j = i - 1 then d\\<mu> fs i (i - 1)\n               else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i j) =\n    (if ii = i - 1 then d\\<mu> fs i j\n     else if ii = i \\<and> j \\<noteq> i - 1 then d\\<mu> fs (i - 1) j\n          else if i < ii \\<and> j = i\n               then (d fs (Suc i) * d\\<mu> fs ii (i - 1) -\n                     d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n                    d fs i\n               else if i < ii \\<and> j = i - 1\n                    then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                          d\\<mu> fs ii i * d fs (i - 1)) div\n                         d fs i\n                    else d\\<mu> fs ii j)", "using Is j simps"], ["proof (prove)\nusing this:\n  ii = i\n  j \\<noteq> i - 1\n  j < ii\n  ?j < ii \\<Longrightarrow> dmu_ij_state state ii ?j = d\\<mu> fs ii ?j\n  ?j < i - 1 \\<Longrightarrow>\n  dmu_ij_state state (i - 1) ?j = d\\<mu> fs (i - 1) ?j\n  ?j < i \\<Longrightarrow> dmu_ij_state state i ?j = d\\<mu> fs i ?j\n\ngoal (1 subgoal):\n 1. (if i < ii\n     then if j = i\n          then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n               d fs i\n          else if j = i - 1\n               then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                     dmu_ij_state state ii i * d fs (i - 1)) div\n                    d fs i\n               else d\\<mu> fs ii j\n     else if ii = i\n          then if j = i - 1 then d\\<mu> fs i (i - 1)\n               else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i j) =\n    (if ii = i - 1 then d\\<mu> fs i j\n     else if ii = i \\<and> j \\<noteq> i - 1 then d\\<mu> fs (i - 1) j\n          else if i < ii \\<and> j = i\n               then (d fs (Suc i) * d\\<mu> fs ii (i - 1) -\n                     d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n                    d fs i\n               else if i < ii \\<and> j = i - 1\n                    then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                          d\\<mu> fs ii i * d fs (i - 1)) div\n                         d fs i\n                    else d\\<mu> fs ii j)", "by auto"], ["proof (state)\nthis:\n  (if i < ii\n   then \\<lambda>j.\n           if j = i\n           then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                 d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                d fs i\n           else if j = i - 1\n                then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                      dmu_ij_state state ii i * d fs (i - 1)) div\n                     d fs i\n                else dmu_ij_state state ii j\n   else if ii = i\n        then \\<lambda>j.\n                if j = i - 1 then d\\<mu> fs i (i - 1)\n                else dmu_ij_state state (i - 1) j\n        else dmu_ij_state state i)\n   j =\n  d\\<mu> fs'' ii j\n\ngoal (2 subgoals):\n 1. ii = i - 1 \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j\n 2. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ii = i - 1 \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j\n 2. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "case (Im1)"], ["proof (state)\nthis:\n  ii = i - 1\n\ngoal (2 subgoals):\n 1. ii = i - 1 \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j\n 2. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "hence id: \"(i < ii) = False\" \"(ii = i) = False\" \"(ii = i - 1) = True\""], ["proof (prove)\nusing this:\n  ii = i - 1\n\ngoal (1 subgoal):\n 1. (i < ii) = False &&& (ii = i) = False &&& (ii = i - 1) = True", "using i0"], ["proof (prove)\nusing this:\n  ii = i - 1\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (i < ii) = False &&& (ii = i) = False &&& (ii = i - 1) = True", "by auto"], ["proof (state)\nthis:\n  (i < ii) = False\n  (ii = i) = False\n  (ii = i - 1) = True\n\ngoal (2 subgoals):\n 1. ii = i - 1 \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j\n 2. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "unfolding upd"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < ii\n     then if j = i\n          then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n               d fs i\n          else if j = i - 1\n               then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                     dmu_ij_state state ii i * d fs (i - 1)) div\n                    d fs i\n               else d\\<mu> fs ii j\n     else if ii = i\n          then if j = i - 1 then d\\<mu> fs i (i - 1)\n               else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i j) =\n    (if ii = i - 1 then d\\<mu> fs i j\n     else if ii = i \\<and> j \\<noteq> i - 1 then d\\<mu> fs (i - 1) j\n          else if i < ii \\<and> j = i\n               then (d fs (Suc i) * d\\<mu> fs ii (i - 1) -\n                     d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n                    d fs i\n               else if i < ii \\<and> j = i - 1\n                    then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                          d\\<mu> fs ii i * d fs (i - 1)) div\n                         d fs i\n                    else d\\<mu> fs ii j)", "unfolding id if_False if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. dmu_ij_state state i j = d\\<mu> fs i j", "by (rule simps, insert j Im1, auto)"], ["proof (state)\nthis:\n  (if i < ii\n   then \\<lambda>j.\n           if j = i\n           then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                 d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                d fs i\n           else if j = i - 1\n                then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                      dmu_ij_state state ii i * d fs (i - 1)) div\n                     d fs i\n                else dmu_ij_state state ii j\n   else if ii = i\n        then \\<lambda>j.\n                if j = i - 1 then d\\<mu> fs i (i - 1)\n                else dmu_ij_state state (i - 1) j\n        else dmu_ij_state state i)\n   j =\n  d\\<mu> fs'' ii j\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "case (large)"], ["proof (state)\nthis:\n  i < ii\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "hence \"i - 1 < ii\" \"i < ii\""], ["proof (prove)\nusing this:\n  i < ii\n\ngoal (1 subgoal):\n 1. i - 1 < ii &&& i < ii", "by auto"], ["proof (state)\nthis:\n  i - 1 < ii\n  i < ii\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "note simps = simps(1)[OF this(1)] simps(1)[OF this(2)]"], ["proof (state)\nthis:\n  dmu_ij_state state ii (i - 1) = d\\<mu> fs ii (i - 1)\n  dmu_ij_state state ii i = d\\<mu> fs ii i\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "from large"], ["proof (chain)\npicking this:\n  i < ii", "have id: \"(i < ii) = True\" \"(ii = i - 1) = False\" \"\\<And> x. (ii = i \\<and> x) = False\""], ["proof (prove)\nusing this:\n  i < ii\n\ngoal (1 subgoal):\n 1. (i < ii) = True &&&\n    (ii = i - 1) = False &&& (\\<And>x. (ii = i \\<and> x) = False)", "by auto"], ["proof (state)\nthis:\n  (i < ii) = True\n  (ii = i - 1) = False\n  (ii = i \\<and> ?x1) = False\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow>\n    (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < ii\n     then \\<lambda>j.\n             if j = i\n             then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                   d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                  d fs i\n             else if j = i - 1\n                  then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                        dmu_ij_state state ii i * d fs (i - 1)) div\n                       d fs i\n                  else dmu_ij_state state ii j\n     else if ii = i\n          then \\<lambda>j.\n                  if j = i - 1 then d\\<mu> fs i (i - 1)\n                  else dmu_ij_state state (i - 1) j\n          else dmu_ij_state state i)\n     j =\n    d\\<mu> fs'' ii j", "unfolding id if_True if_False upd simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j = i\n     then (d fs (Suc i) * d\\<mu> fs ii (i - 1) -\n           d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n          d fs i\n     else if j = i - 1\n          then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                d\\<mu> fs ii i * d fs (i - 1)) div\n               d fs i\n          else d\\<mu> fs ii j) =\n    (if True \\<and> j = i\n     then (d fs (Suc i) * d\\<mu> fs ii (i - 1) -\n           d\\<mu> fs i (i - 1) * d\\<mu> fs ii j) div\n          d fs i\n     else if True \\<and> j = i - 1\n          then (d\\<mu> fs i (i - 1) * d\\<mu> fs ii j +\n                d\\<mu> fs ii i * d fs (i - 1)) div\n               d fs i\n          else d\\<mu> fs ii j)", "by auto"], ["proof (state)\nthis:\n  (if i < ii\n   then \\<lambda>j.\n           if j = i\n           then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                 d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                d fs i\n           else if j = i - 1\n                then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                      dmu_ij_state state ii i * d fs (i - 1)) div\n                     d fs i\n                else dmu_ij_state state ii j\n   else if ii = i\n        then \\<lambda>j.\n                if j = i - 1 then d\\<mu> fs i (i - 1)\n                else dmu_ij_state state (i - 1) j\n        else dmu_ij_state state i)\n   j =\n  d\\<mu> fs'' ii j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if i < ii\n   then \\<lambda>j.\n           if j = i\n           then (d fs (Suc i) * dmu_ij_state state ii (i - 1) -\n                 d\\<mu> fs i (i - 1) * dmu_ij_state state ii j) div\n                d fs i\n           else if j = i - 1\n                then (d\\<mu> fs i (i - 1) * dmu_ij_state state ii j +\n                      dmu_ij_state state ii i * d fs (i - 1)) div\n                     d fs i\n                else dmu_ij_state state ii j\n   else if ii = i\n        then \\<lambda>j.\n                if j = i - 1 then d\\<mu> fs i (i - 1)\n                else dmu_ij_state state (i - 1) j\n        else dmu_ij_state state i)\n   j =\n  d\\<mu> fs'' ii j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if ii < i - 1 then mu !! ii\n   else if i < ii\n        then IArray.of_fun\n              (\\<lambda>j.\n                  if j = i\n                  then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                        d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                       d fs i\n                  else if j = i - 1\n                       then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                             mu !! ii !! i * d fs (i - 1)) div\n                            d fs i\n                       else mu !! ii !! j)\n              ii\n        else if ii = i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = i - 1 then d\\<mu> fs i (i - 1)\n                       else mu !! (i - 1) !! j)\n                   ii\n             else IArray.of_fun ((!!) (mu !! i)) ii) =\n  IArray.of_fun (d\\<mu> fs'' ii) ii\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if ii < i - 1 then mu !! ii\n   else if i < ii\n        then IArray.of_fun\n              (\\<lambda>j.\n                  if j = i\n                  then (d fs (Suc i) * mu !! ii !! (i - 1) -\n                        d\\<mu> fs i (i - 1) * mu !! ii !! j) div\n                       d fs i\n                  else if j = i - 1\n                       then (d\\<mu> fs i (i - 1) * mu !! ii !! j +\n                             mu !! ii !! i * d fs (i - 1)) div\n                            d fs i\n                       else mu !! ii !! j)\n              ii\n        else if ii = i\n             then IArray.of_fun\n                   (\\<lambda>j.\n                       if j = i - 1 then d\\<mu> fs i (i - 1)\n                       else mu !! (i - 1) !! j)\n                   ii\n             else IArray.of_fun ((!!) (mu !! i)) ii) =\n  IArray.of_fun (d\\<mu> fs'' ii) ii\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mu_repr\n   (swap_mu m mu i (dmu_ij_state state i (i - 1)) (d fs (i - 1)) (d fs i)\n     (d fs (Suc i)))\n   fs''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_impl_inv state' i' fs'\n\ngoal (1 subgoal):\n 1. local.basis_reduction_swap i fs = (upw', i', fs')", "show ?g2"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.basis_reduction_swap i fs = (upw', i', fs')", "unfolding fs_id fs''[symmetric] basis_reduction_swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (False, i - 1, fs[i := fs ! (i - 1), i - 1 := fs ! i]) =\n    (upw', i', fs[i := fs ! (i - 1), i - 1 := fs ! i])", "unfolding res"], ["proof (prove)\ngoal (1 subgoal):\n 1. (False, i - 1, fs[i := fs ! (i - 1), i - 1 := fs ! i]) =\n    (False, i - 1, fs[i := fs ! (i - 1), i - 1 := fs ! i])", ".."], ["proof (state)\nthis:\n  local.basis_reduction_swap i fs = (upw', i', fs')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_swap: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant False i fs\"\n  and res: \"LLL_Impl.basis_reduction_swap m i state = (upw',i',state')\"\n  and cond: \"sq_norm (gso fs (i - 1)) > \\<alpha> * sq_norm (gso fs i)\"\n  and i: \"i < m\" and i0: \"i \\<noteq> 0\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i' fs'\" \n  \"LLL_invariant upw' i' fs'\" \n  \"LLL_measure i' fs' < LLL_measure i fs\"\n  \"basis_reduction_swap i fs = (upw',i',fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LLL_impl_inv state' i' fs' &&& LLL_invariant upw' i' fs') &&&\n    LLL_measure i' fs' < LLL_measure i fs &&&\n    local.basis_reduction_swap i fs = (upw', i', fs')", "using basis_reduction_swap_impl[OF assms] basis_reduction_swap[OF inv _ cond i i0]"], ["proof (prove)\nusing this:\n  LLL_impl_inv state' i' fs'\n  local.basis_reduction_swap i fs = (upw', i', fs')\n  local.basis_reduction_swap i fs = (?upw', ?i', ?fs') \\<Longrightarrow>\n  LLL_invariant ?upw' ?i' ?fs'\n  local.basis_reduction_swap i fs = (?upw', ?i', ?fs') \\<Longrightarrow>\n  LLL_measure ?i' ?fs' < LLL_measure i fs\n\ngoal (1 subgoal):\n 1. (LLL_impl_inv state' i' fs' &&& LLL_invariant upw' i' fs') &&&\n    LLL_measure i' fs' < LLL_measure i fs &&&\n    local.basis_reduction_swap i fs = (upw', i', fs')", "by blast+"], ["", "lemma basis_reduction_step_impl: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_step \\<alpha> n m upw i state = (upw',i',state')\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i' fs'\"\n  \"basis_reduction_step upw i fs = (upw',i',fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' &&&\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "obtain f mu ds where state: \"state = (f,mu,ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f mu ds.\n        state = (f, mu, ds) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases state, auto)"], ["proof (state)\nthis:\n  state = (f, mu, ds)\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "note def = LLL_Impl.basis_reduction_step_def basis_reduction_step_def"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_step ?\\<alpha> ?n ?m ?upw ?i ?state =\n  (if ?i = 0 then (True, Suc ?i, inc_state ?state)\n   else let state' = LLL_Impl.basis_reduction_add_rows ?n ?upw ?i ?state;\n            di = d_state state' ?i; dsi = d_state state' (Suc ?i);\n            dim1 = d_state state' (?i - 1);\n            (num, denom) = quotient_of ?\\<alpha>\n        in if di * di * denom \\<le> num * dim1 * dsi\n           then (True, Suc ?i, inc_state state')\n           else LLL_Impl.basis_reduction_swap ?m ?i state')\n  local.basis_reduction_step ?upw ?i ?fs =\n  (if ?i = 0 then (True, Suc ?i, ?fs)\n   else let fs' = local.basis_reduction_add_rows ?upw ?i ?fs\n        in if \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs')\n                          (?i - 1)\\<parallel>\\<^sup>2\n              \\<le> \\<alpha> *\n                    \\<parallel>gram_schmidt_fs.gso n\n                                (map of_int_hom.vec_hom fs')\n                                ?i\\<parallel>\\<^sup>2\n           then (True, Suc ?i, fs') else local.basis_reduction_swap ?i fs')\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "from LLL_invD[OF inv]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i", "have len: \"length fs = m\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. length fs = m", "by auto"], ["proof (state)\nthis:\n  length fs = m\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "from fs_state[OF impl inv state len]"], ["proof (chain)\npicking this:\n  fs_state state = fs", "have fs: \"fs_state state = fs\""], ["proof (prove)\nusing this:\n  fs_state state = fs\n\ngoal (1 subgoal):\n 1. fs_state state = fs", "by auto"], ["proof (state)\nthis:\n  fs_state state = fs\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "from LLL_state_inc_state[OF impl inv state i] i\n      assms increase_i[OF inv i True] True\n      res fs' fs"], ["proof (chain)\npicking this:\n  LLL_impl_inv (inc_state state) (Suc i) fs\n  fs_state (inc_state state) = fs_state state\n  i < m\n  LLL_impl_inv state i fs\n  LLL_invariant upw i fs\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (upw', i', state')\n  i < m\n  fs' = fs_state state'\n  (i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     i\\<parallel>\\<^sup>2) \\<Longrightarrow>\n  LLL_invariant True (Suc i) fs\n  (i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     i\\<parallel>\\<^sup>2) \\<Longrightarrow>\n  LLL_measure (Suc i) fs < LLL_measure i fs\n  i = 0\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (upw', i', state')\n  fs' = fs_state state'\n  fs_state state = fs", "show ?thesis"], ["proof (prove)\nusing this:\n  LLL_impl_inv (inc_state state) (Suc i) fs\n  fs_state (inc_state state) = fs_state state\n  i < m\n  LLL_impl_inv state i fs\n  LLL_invariant upw i fs\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (upw', i', state')\n  i < m\n  fs' = fs_state state'\n  (i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     i\\<parallel>\\<^sup>2) \\<Longrightarrow>\n  LLL_invariant True (Suc i) fs\n  (i \\<noteq> 0 \\<Longrightarrow>\n   \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n               (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> *\n         \\<parallel>gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs)\n                     i\\<parallel>\\<^sup>2) \\<Longrightarrow>\n  LLL_measure (Suc i) fs < LLL_measure i fs\n  i = 0\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (upw', i', state')\n  fs' = fs_state state'\n  fs_state state = fs\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "by (auto simp: def)"], ["proof (state)\nthis:\n  LLL_impl_inv state' i' fs' \\<and>\n  local.basis_reduction_step upw i fs = (upw', i', fs')\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "hence id: \"(i = 0) = False\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (i = 0) = False", "by auto"], ["proof (state)\nthis:\n  (i = 0) = False\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "obtain state'' where state'': \"LLL_Impl.basis_reduction_add_rows n upw i state = state''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>state''.\n        LLL_Impl.basis_reduction_add_rows n upw i state =\n        state'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_add_rows n upw i state = state''\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "define fs'' where fs'': \"fs'' = fs_state state''\""], ["proof (state)\nthis:\n  fs'' = fs_state state''\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "obtain f mu ds where state: \"state'' = (f,mu,ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f mu ds.\n        state'' = (f, mu, ds) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases state'', auto)"], ["proof (state)\nthis:\n  state'' = (f, mu, ds)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "from basis_reduction_add_rows[OF impl inv state'' i fs'']"], ["proof (chain)\npicking this:\n  LLL_impl_inv state'' i fs''\n  LLL_invariant False i fs''\n  LLL_measure i fs'' = LLL_measure i fs\n  local.basis_reduction_add_rows upw i fs = fs''", "have inv: \"LLL_invariant False i fs''\"\n      and meas: \"LLL_measure i fs = LLL_measure i fs''\"\n      and impl: \"LLL_impl_inv state'' i fs''\"\n      and impl': \"basis_reduction_add_rows upw i fs = fs''\""], ["proof (prove)\nusing this:\n  LLL_impl_inv state'' i fs''\n  LLL_invariant False i fs''\n  LLL_measure i fs'' = LLL_measure i fs\n  local.basis_reduction_add_rows upw i fs = fs''\n\ngoal (1 subgoal):\n 1. (LLL_invariant False i fs'' &&&\n     LLL_measure i fs = LLL_measure i fs'') &&&\n    LLL_impl_inv state'' i fs'' &&&\n    local.basis_reduction_add_rows upw i fs = fs''", "by auto"], ["proof (state)\nthis:\n  LLL_invariant False i fs''\n  LLL_measure i fs = LLL_measure i fs''\n  LLL_impl_inv state'' i fs''\n  local.basis_reduction_add_rows upw i fs = fs''\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "note invw = LLL_inv_imp_w[OF inv]"], ["proof (state)\nthis:\n  LLL_invariant_weak fs''\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "obtain num denom where quot: \"quotient_of \\<alpha> = (num,denom)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>num denom.\n        quotient_of \\<alpha> = (num, denom) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of \\<alpha> = (num, denom)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "note d_state = d_state[OF impl inv state]"], ["proof (state)\nthis:\n  ?ii \\<le> m \\<Longrightarrow> d_state state'' ?ii = d fs'' ?ii\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "from i"], ["proof (chain)\npicking this:\n  i < m", "have le: \"i - 1 \\<le> m\" \" i \\<le> m\" \"Suc i \\<le> m\""], ["proof (prove)\nusing this:\n  i < m\n\ngoal (1 subgoal):\n 1. i - 1 \\<le> m &&& i \\<le> m &&& Suc i \\<le> m", "by auto"], ["proof (state)\nthis:\n  i - 1 \\<le> m\n  i \\<le> m\n  Suc i \\<le> m\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "note d_state = d_state[OF le(1)] d_state[OF le(2)] d_state[OF le(3)]"], ["proof (state)\nthis:\n  d_state state'' (i - 1) = d fs'' (i - 1)\n  d_state state'' i = d fs'' i\n  d_state state'' (Suc i) = d fs'' (Suc i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "interpret fs'': fs_int' n m fs_init fs''"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int' n m fs_init fs''", "by standard (use invw in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "have \"i < length fs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length fs''", "using LLL_invD[OF inv] i"], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs'')\n  length (map of_int_hom.vec_hom fs'') = m\n  set fs'' \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs'' ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow> fs''.gs.gso ?i \\<in> Rn\n  length fs'' = m\n  lattice_of fs'' = L\n  fs''.gs.weakly_reduced \\<alpha> i\n  i \\<le> m\n  fs''.gs.reduced \\<alpha> i\n  False \\<or> \\<mu>_small fs'' i\n  i < m\n\ngoal (1 subgoal):\n 1. i < length fs''", "by auto"], ["proof (state)\nthis:\n  i < length fs''\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "note d_sq_norm_comparison = fs''.d_sq_norm_comparison[OF quot this False]"], ["proof (state)\nthis:\n  (fs''.d fs'' i * fs''.d fs'' i * denom\n   \\<le> num * fs''.d fs'' (i - 1) * fs''.d fs'' (Suc i)) =\n  (\\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "note res = res[unfolded def id if_False Let_def state'' quot split d_state this]"], ["proof (state)\nthis:\n  (if d fs'' i * d fs'' i * denom\n      \\<le> num * d fs'' (i - 1) * d fs'' (Suc i)\n   then (True, Suc i, inc_state state'')\n   else LLL_Impl.basis_reduction_swap m i state'') =\n  (upw', i', state')\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "note pos = LLL_d_pos[OF invw le(1)] LLL_d_pos[OF invw le(2)] quotient_of_denom_pos[OF quot]"], ["proof (state)\nthis:\n  0 < d fs'' (i - 1)\n  0 < d fs'' i\n  0 < denom\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "from False"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "have sim1: \"Suc (i - 1) = i\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Suc (i - 1) = i", "by simp"], ["proof (state)\nthis:\n  Suc (i - 1) = i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "let ?r = \"rat_of_int\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "let ?x = \"sq_norm (gso fs'' (i - 1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "let ?y = \"\\<alpha> * sq_norm (gso fs'' i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "proof (cases \"?x \\<le> ?y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> *\n          \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')\n 2. \\<not> \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>fs''.gs.gso\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "case True"], ["proof (state)\nthis:\n  \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n    \\<le> \\<alpha> *\n          \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')\n 2. \\<not> \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>fs''.gs.gso\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "from increase_i[OF inv i _ True] True res meas LLL_state_inc_state[OF impl inv state i] fs' fs''\n        d_def d_sq_norm_comparison fs''.d_def impl' False"], ["proof (chain)\npicking this:\n  (False \\<Longrightarrow> i = 0) \\<Longrightarrow>\n  LLL_invariant True (Suc i) fs''\n  (False \\<Longrightarrow> i = 0) \\<Longrightarrow>\n  LLL_measure (Suc i) fs'' < LLL_measure i fs''\n  \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2\n  (if d fs'' i * d fs'' i * denom\n      \\<le> num * d fs'' (i - 1) * d fs'' (Suc i)\n   then (True, Suc i, inc_state state'')\n   else LLL_Impl.basis_reduction_swap m i state'') =\n  (upw', i', state')\n  LLL_measure i fs = LLL_measure i fs''\n  LLL_impl_inv (inc_state state'') (Suc i) fs''\n  fs_state (inc_state state'') = fs_state state''\n  fs' = fs_state state'\n  fs'' = fs_state state''\n  d ?fs ?k = gs.Gramian_determinant ?fs ?k\n  (fs''.d fs'' i * fs''.d fs'' i * denom\n   \\<le> num * fs''.d fs'' (i - 1) * fs''.d fs'' (Suc i)) =\n  (\\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2)\n  fs''.d ?fs ?k = gs.Gramian_determinant ?fs ?k\n  local.basis_reduction_add_rows upw i fs = fs''\n  i \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (False \\<Longrightarrow> i = 0) \\<Longrightarrow>\n  LLL_invariant True (Suc i) fs''\n  (False \\<Longrightarrow> i = 0) \\<Longrightarrow>\n  LLL_measure (Suc i) fs'' < LLL_measure i fs''\n  \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2\n  (if d fs'' i * d fs'' i * denom\n      \\<le> num * d fs'' (i - 1) * d fs'' (Suc i)\n   then (True, Suc i, inc_state state'')\n   else LLL_Impl.basis_reduction_swap m i state'') =\n  (upw', i', state')\n  LLL_measure i fs = LLL_measure i fs''\n  LLL_impl_inv (inc_state state'') (Suc i) fs''\n  fs_state (inc_state state'') = fs_state state''\n  fs' = fs_state state'\n  fs'' = fs_state state''\n  d ?fs ?k = gs.Gramian_determinant ?fs ?k\n  (fs''.d fs'' i * fs''.d fs'' i * denom\n   \\<le> num * fs''.d fs'' (i - 1) * fs''.d fs'' (Suc i)) =\n  (\\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2)\n  fs''.d ?fs ?k = gs.Gramian_determinant ?fs ?k\n  local.basis_reduction_add_rows upw i fs = fs''\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "by (auto simp: def)"], ["proof (state)\nthis:\n  LLL_impl_inv state' i' fs' \\<and>\n  local.basis_reduction_step upw i fs = (upw', i', fs')\n\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>fs''.gs.gso\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>fs''.gs.gso\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "case F: False"], ["proof (state)\nthis:\n  \\<not> \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n         \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>fs''.gs.gso\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "hence gt: \"?x > ?y\" and id: \"(?x \\<le> ?y) = False\""], ["proof (prove)\nusing this:\n  \\<not> \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n         \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2\n    < \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2 &&&\n    (\\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2) =\n    False", "by auto"], ["proof (state)\nthis:\n  \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2\n  < \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n  (\\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2) =\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>fs''.gs.gso\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "from res[unfolded id if_False] d_def d_sq_norm_comparison fs''.d_def id"], ["proof (chain)\npicking this:\n  (if d fs'' i * d fs'' i * denom\n      \\<le> num * d fs'' (i - 1) * d fs'' (Suc i)\n   then (True, Suc i, inc_state state'')\n   else LLL_Impl.basis_reduction_swap m i state'') =\n  (upw', i', state')\n  d ?fs ?k = gs.Gramian_determinant ?fs ?k\n  (fs''.d fs'' i * fs''.d fs'' i * denom\n   \\<le> num * fs''.d fs'' (i - 1) * fs''.d fs'' (Suc i)) =\n  (\\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2)\n  fs''.d ?fs ?k = gs.Gramian_determinant ?fs ?k\n  (\\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2) =\n  False", "have \"LLL_Impl.basis_reduction_swap m i state'' = (upw', i', state')\""], ["proof (prove)\nusing this:\n  (if d fs'' i * d fs'' i * denom\n      \\<le> num * d fs'' (i - 1) * d fs'' (Suc i)\n   then (True, Suc i, inc_state state'')\n   else LLL_Impl.basis_reduction_swap m i state'') =\n  (upw', i', state')\n  d ?fs ?k = gs.Gramian_determinant ?fs ?k\n  (fs''.d fs'' i * fs''.d fs'' i * denom\n   \\<le> num * fs''.d fs'' (i - 1) * fs''.d fs'' (Suc i)) =\n  (\\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2)\n  fs''.d ?fs ?k = gs.Gramian_determinant ?fs ?k\n  (\\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n   \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2) =\n  False\n\ngoal (1 subgoal):\n 1. LLL_Impl.basis_reduction_swap m i state'' = (upw', i', state')", "by auto"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_swap m i state'' = (upw', i', state')\n\ngoal (1 subgoal):\n 1. \\<not> \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n           \\<le> \\<alpha> *\n                 \\<parallel>fs''.gs.gso\n                             i\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "from basis_reduction_swap[OF impl inv this gt i False fs']"], ["proof (chain)\npicking this:\n  LLL_impl_inv state' i' fs'\n  LLL_invariant upw' i' fs'\n  LLL_measure i' fs' < LLL_measure i fs''\n  local.basis_reduction_swap i fs'' = (upw', i', fs')", "show ?thesis"], ["proof (prove)\nusing this:\n  LLL_impl_inv state' i' fs'\n  LLL_invariant upw' i' fs'\n  LLL_measure i' fs' < LLL_measure i fs''\n  local.basis_reduction_swap i fs'' = (upw', i', fs')\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "using meas F False"], ["proof (prove)\nusing this:\n  LLL_impl_inv state' i' fs'\n  LLL_invariant upw' i' fs'\n  LLL_measure i' fs' < LLL_measure i fs''\n  local.basis_reduction_swap i fs'' = (upw', i', fs')\n  LLL_measure i fs = LLL_measure i fs''\n  \\<not> \\<parallel>fs''.gs.gso (i - 1)\\<parallel>\\<^sup>2\n         \\<le> \\<alpha> * \\<parallel>fs''.gs.gso i\\<parallel>\\<^sup>2\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' i' fs' \\<and>\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "by (auto simp: def Let_def impl')"], ["proof (state)\nthis:\n  LLL_impl_inv state' i' fs' \\<and>\n  local.basis_reduction_step upw i fs = (upw', i', fs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_impl_inv state' i' fs' \\<and>\n  local.basis_reduction_step upw i fs = (upw', i', fs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_impl_inv state' i' fs' \\<and>\n  local.basis_reduction_step upw i fs = (upw', i', fs')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_step: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_step \\<alpha> n m upw i state = (upw',i',state')\"\n  and i: \"i < m\"\n  and fs': \"fs' = fs_state state'\"\nshows\n  \"LLL_impl_inv state' i' fs'\"\n  \"LLL_invariant upw' i' fs'\"\n  \"LLL_measure i' fs' < LLL_measure i fs\"\n  \"basis_reduction_step upw i fs = (upw',i',fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LLL_impl_inv state' i' fs' &&& LLL_invariant upw' i' fs') &&&\n    LLL_measure i' fs' < LLL_measure i fs &&&\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "using basis_reduction_step_impl[OF assms] basis_reduction_step[OF inv _ i]"], ["proof (prove)\nusing this:\n  LLL_impl_inv state' i' fs'\n  local.basis_reduction_step upw i fs = (upw', i', fs')\n  local.basis_reduction_step upw i fs = (?upw', ?i', ?fs') \\<Longrightarrow>\n  LLL_invariant ?upw' ?i' ?fs'\n  local.basis_reduction_step upw i fs = (?upw', ?i', ?fs') \\<Longrightarrow>\n  LLL_measure ?i' ?fs' < LLL_measure i fs\n\ngoal (1 subgoal):\n 1. (LLL_impl_inv state' i' fs' &&& LLL_invariant upw' i' fs') &&&\n    LLL_measure i' fs' < LLL_measure i fs &&&\n    local.basis_reduction_step upw i fs = (upw', i', fs')", "by blast+"], ["", "lemma basis_reduction_main_impl: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_main \\<alpha> n m upw i state = state'\"\n  and fs': \"fs' = fs_state state'\"\nshows \"LLL_impl_inv state' m fs'\"\n  \"basis_reduction_main (upw,i,fs) = fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' m fs' &&&\n    local.basis_reduction_main (upw, i, fs) = fs'", "proof (atomize(full), insert assms(1-3), induct \"LLL_measure i fs\" arbitrary: i fs upw state rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i fs upw state.\n       \\<lbrakk>\\<And>ia fsa upw state.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_impl_inv state ia fsa; LLL_invariant upw ia fsa;\n                    LLL_Impl.basis_reduction_main \\<alpha> n m upw ia\n                     state =\n                    state'\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                                     local.basis_reduction_main\n(upw, ia, fsa) =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant upw i fs;\n        LLL_Impl.basis_reduction_main \\<alpha> n m upw i state =\n        state'\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                         local.basis_reduction_main (upw, i, fs) = fs'", "case (less i fs upw)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_measure ?i1 ?fs1 < LLL_measure i fs;\n   LLL_impl_inv ?state1 ?i1 ?fs1; LLL_invariant ?upw1 ?i1 ?fs1;\n   LLL_Impl.basis_reduction_main \\<alpha> n m ?upw1 ?i1 ?state1 =\n   state'\\<rbrakk>\n  \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                    local.basis_reduction_main (?upw1, ?i1, ?fs1) = fs'\n  LLL_impl_inv state i fs\n  LLL_invariant upw i fs\n  LLL_Impl.basis_reduction_main \\<alpha> n m upw i state = state'\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw state.\n       \\<lbrakk>\\<And>ia fsa upw state.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_impl_inv state ia fsa; LLL_invariant upw ia fsa;\n                    LLL_Impl.basis_reduction_main \\<alpha> n m upw ia\n                     state =\n                    state'\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                                     local.basis_reduction_main\n(upw, ia, fsa) =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant upw i fs;\n        LLL_Impl.basis_reduction_main \\<alpha> n m upw i state =\n        state'\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                         local.basis_reduction_main (upw, i, fs) = fs'", "have id: \"LLL_invariant upw i fs = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant upw i fs = True", "using less"], ["proof (prove)\nusing this:\n  \\<lbrakk>LLL_measure ?i1 ?fs1 < LLL_measure i fs;\n   LLL_impl_inv ?state1 ?i1 ?fs1; LLL_invariant ?upw1 ?i1 ?fs1;\n   LLL_Impl.basis_reduction_main \\<alpha> n m ?upw1 ?i1 ?state1 =\n   state'\\<rbrakk>\n  \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                    local.basis_reduction_main (?upw1, ?i1, ?fs1) = fs'\n  LLL_impl_inv state i fs\n  LLL_invariant upw i fs\n  LLL_Impl.basis_reduction_main \\<alpha> n m upw i state = state'\n\ngoal (1 subgoal):\n 1. LLL_invariant upw i fs = True", "by auto"], ["proof (state)\nthis:\n  LLL_invariant upw i fs = True\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw state.\n       \\<lbrakk>\\<And>ia fsa upw state.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_impl_inv state ia fsa; LLL_invariant upw ia fsa;\n                    LLL_Impl.basis_reduction_main \\<alpha> n m upw ia\n                     state =\n                    state'\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                                     local.basis_reduction_main\n(upw, ia, fsa) =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant upw i fs;\n        LLL_Impl.basis_reduction_main \\<alpha> n m upw i state =\n        state'\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                         local.basis_reduction_main (upw, i, fs) = fs'", "note res = less(4)[unfolded LLL_Impl.basis_reduction_main.simps[of _ _ _ upw]]"], ["proof (state)\nthis:\n  (if i < m\n   then case LLL_Impl.basis_reduction_step \\<alpha> n m upw i state of\n        (upw', xa, xb) \\<Rightarrow>\n          LLL_Impl.basis_reduction_main \\<alpha> n m upw' xa xb\n   else state) =\n  state'\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw state.\n       \\<lbrakk>\\<And>ia fsa upw state.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_impl_inv state ia fsa; LLL_invariant upw ia fsa;\n                    LLL_Impl.basis_reduction_main \\<alpha> n m upw ia\n                     state =\n                    state'\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                                     local.basis_reduction_main\n(upw, ia, fsa) =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant upw i fs;\n        LLL_Impl.basis_reduction_main \\<alpha> n m upw i state =\n        state'\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                         local.basis_reduction_main (upw, i, fs) = fs'", "note inv = less(3)"], ["proof (state)\nthis:\n  LLL_invariant upw i fs\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw state.\n       \\<lbrakk>\\<And>ia fsa upw state.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_impl_inv state ia fsa; LLL_invariant upw ia fsa;\n                    LLL_Impl.basis_reduction_main \\<alpha> n m upw ia\n                     state =\n                    state'\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                                     local.basis_reduction_main\n(upw, ia, fsa) =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant upw i fs;\n        LLL_Impl.basis_reduction_main \\<alpha> n m upw i state =\n        state'\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                         local.basis_reduction_main (upw, i, fs) = fs'", "note impl = less(2)"], ["proof (state)\nthis:\n  LLL_impl_inv state i fs\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw state.\n       \\<lbrakk>\\<And>ia fsa upw state.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_impl_inv state ia fsa; LLL_invariant upw ia fsa;\n                    LLL_Impl.basis_reduction_main \\<alpha> n m upw ia\n                     state =\n                    state'\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                                     local.basis_reduction_main\n(upw, ia, fsa) =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant upw i fs;\n        LLL_Impl.basis_reduction_main \\<alpha> n m upw i state =\n        state'\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                         local.basis_reduction_main (upw, i, fs) = fs'", "note IH = less(1)"], ["proof (state)\nthis:\n  \\<lbrakk>LLL_measure ?i1 ?fs1 < LLL_measure i fs;\n   LLL_impl_inv ?state1 ?i1 ?fs1; LLL_invariant ?upw1 ?i1 ?fs1;\n   LLL_Impl.basis_reduction_main \\<alpha> n m ?upw1 ?i1 ?state1 =\n   state'\\<rbrakk>\n  \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                    local.basis_reduction_main (?upw1, ?i1, ?fs1) = fs'\n\ngoal (1 subgoal):\n 1. \\<And>i fs upw state.\n       \\<lbrakk>\\<And>ia fsa upw state.\n                   \\<lbrakk>LLL_measure ia fsa < LLL_measure i fs;\n                    LLL_impl_inv state ia fsa; LLL_invariant upw ia fsa;\n                    LLL_Impl.basis_reduction_main \\<alpha> n m upw ia\n                     state =\n                    state'\\<rbrakk>\n                   \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                                     local.basis_reduction_main\n(upw, ia, fsa) =\n                                     fs';\n        LLL_impl_inv state i fs; LLL_invariant upw i fs;\n        LLL_Impl.basis_reduction_main \\<alpha> n m upw i state =\n        state'\\<rbrakk>\n       \\<Longrightarrow> LLL_impl_inv state' m fs' \\<and>\n                         local.basis_reduction_main (upw, i, fs) = fs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "proof (cases \"i < m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'\n 2. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "case i: True"], ["proof (state)\nthis:\n  i < m\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'\n 2. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "obtain i'' state'' upw'' where step: \"LLL_Impl.basis_reduction_step \\<alpha> n m upw i state = (upw'',i'',state'')\"\n      (is \"?step = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>upw'' i'' state''.\n        LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n        (upw'', i'', state'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?step, auto)"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (upw'', i'', state'')\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'\n 2. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "with res i"], ["proof (chain)\npicking this:\n  (if i < m\n   then case LLL_Impl.basis_reduction_step \\<alpha> n m upw i state of\n        (upw', xa, xb) \\<Rightarrow>\n          LLL_Impl.basis_reduction_main \\<alpha> n m upw' xa xb\n   else state) =\n  state'\n  i < m\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (upw'', i'', state'')", "have res: \"LLL_Impl.basis_reduction_main \\<alpha> n m upw'' i'' state'' = state'\""], ["proof (prove)\nusing this:\n  (if i < m\n   then case LLL_Impl.basis_reduction_step \\<alpha> n m upw i state of\n        (upw', xa, xb) \\<Rightarrow>\n          LLL_Impl.basis_reduction_main \\<alpha> n m upw' xa xb\n   else state) =\n  state'\n  i < m\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (upw'', i'', state'')\n\ngoal (1 subgoal):\n 1. LLL_Impl.basis_reduction_main \\<alpha> n m upw'' i'' state'' = state'", "by auto"], ["proof (state)\nthis:\n  LLL_Impl.basis_reduction_main \\<alpha> n m upw'' i'' state'' = state'\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'\n 2. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "note main = basis_reduction_step[OF impl inv step i refl]"], ["proof (state)\nthis:\n  LLL_impl_inv state'' i'' (fs_state state'')\n  LLL_invariant upw'' i'' (fs_state state'')\n  LLL_measure i'' (fs_state state'') < LLL_measure i fs\n  local.basis_reduction_step upw i fs = (upw'', i'', fs_state state'')\n\ngoal (2 subgoals):\n 1. i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'\n 2. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "from IH[OF main(3,1,2) res] main(4) step res"], ["proof (chain)\npicking this:\n  LLL_impl_inv state' m fs' \\<and>\n  local.basis_reduction_main (upw'', i'', fs_state state'') = fs'\n  local.basis_reduction_step upw i fs = (upw'', i'', fs_state state'')\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (upw'', i'', state'')\n  LLL_Impl.basis_reduction_main \\<alpha> n m upw'' i'' state'' = state'", "show ?thesis"], ["proof (prove)\nusing this:\n  LLL_impl_inv state' m fs' \\<and>\n  local.basis_reduction_main (upw'', i'', fs_state state'') = fs'\n  local.basis_reduction_step upw i fs = (upw'', i'', fs_state state'')\n  LLL_Impl.basis_reduction_step \\<alpha> n m upw i state =\n  (upw'', i'', state'')\n  LLL_Impl.basis_reduction_main \\<alpha> n m upw'' i'' state'' = state'\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "by (simp add: i inv basis_reduction_main.simps)"], ["proof (state)\nthis:\n  LLL_impl_inv state' m fs' \\<and>\n  local.basis_reduction_main (upw, i, fs) = fs'\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "case False"], ["proof (state)\nthis:\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "from LLL_invD[OF inv]"], ["proof (chain)\npicking this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i", "have len: \"length fs = m\""], ["proof (prove)\nusing this:\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. length fs = m", "by auto"], ["proof (state)\nthis:\n  length fs = m\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "obtain f mu ds where state: \"state = (f,mu,ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f mu ds.\n        state = (f, mu, ds) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases state, auto)"], ["proof (state)\nthis:\n  state = (f, mu, ds)\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "from fs_state[OF impl inv state len]"], ["proof (chain)\npicking this:\n  fs_state state = fs", "have fs: \"fs_state state = fs\""], ["proof (prove)\nusing this:\n  fs_state state = fs\n\ngoal (1 subgoal):\n 1. fs_state state = fs", "by auto"], ["proof (state)\nthis:\n  fs_state state = fs\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "from False fs res fs'"], ["proof (chain)\npicking this:\n  \\<not> i < m\n  fs_state state = fs\n  (if i < m\n   then case LLL_Impl.basis_reduction_step \\<alpha> n m upw i state of\n        (upw', xa, xb) \\<Rightarrow>\n          LLL_Impl.basis_reduction_main \\<alpha> n m upw' xa xb\n   else state) =\n  state'\n  fs' = fs_state state'", "have fs_id: \"fs = fs'\""], ["proof (prove)\nusing this:\n  \\<not> i < m\n  fs_state state = fs\n  (if i < m\n   then case LLL_Impl.basis_reduction_step \\<alpha> n m upw i state of\n        (upw', xa, xb) \\<Rightarrow>\n          LLL_Impl.basis_reduction_main \\<alpha> n m upw' xa xb\n   else state) =\n  state'\n  fs' = fs_state state'\n\ngoal (1 subgoal):\n 1. fs = fs'", "by simp"], ["proof (state)\nthis:\n  fs = fs'\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "from False LLL_invD[OF inv]"], ["proof (chain)\npicking this:\n  \\<not> i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i", "have i: \"i = m\""], ["proof (prove)\nusing this:\n  \\<not> i < m\n  gs.lin_indpt_list (map of_int_hom.vec_hom fs)\n  length (map of_int_hom.vec_hom fs) = m\n  set fs \\<subseteq> carrier_vec n\n  ?i < m \\<Longrightarrow> fs ! ?i \\<in> carrier_vec n\n  ?i < m \\<Longrightarrow>\n  gram_schmidt_fs.gso n (map of_int_hom.vec_hom fs) ?i \\<in> Rn\n  length fs = m\n  lattice_of fs = L\n  gram_schmidt_fs.weakly_reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  i \\<le> m\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> i\n  upw \\<or> \\<mu>_small fs i\n\ngoal (1 subgoal):\n 1. i = m", "by auto"], ["proof (state)\nthis:\n  i = m\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "with False res inv impl fs"], ["proof (chain)\npicking this:\n  \\<not> i < m\n  (if i < m\n   then case LLL_Impl.basis_reduction_step \\<alpha> n m upw i state of\n        (upw', xa, xb) \\<Rightarrow>\n          LLL_Impl.basis_reduction_main \\<alpha> n m upw' xa xb\n   else state) =\n  state'\n  LLL_invariant upw i fs\n  LLL_impl_inv state i fs\n  fs_state state = fs\n  i = m", "have \"LLL_invariant upw m fs' \\<and> LLL_impl_inv state' m fs'\""], ["proof (prove)\nusing this:\n  \\<not> i < m\n  (if i < m\n   then case LLL_Impl.basis_reduction_step \\<alpha> n m upw i state of\n        (upw', xa, xb) \\<Rightarrow>\n          LLL_Impl.basis_reduction_main \\<alpha> n m upw' xa xb\n   else state) =\n  state'\n  LLL_invariant upw i fs\n  LLL_impl_inv state i fs\n  fs_state state = fs\n  i = m\n\ngoal (1 subgoal):\n 1. LLL_invariant upw m fs' \\<and> LLL_impl_inv state' m fs'", "by (auto simp: fs')"], ["proof (state)\nthis:\n  LLL_invariant upw m fs' \\<and> LLL_impl_inv state' m fs'\n\ngoal (1 subgoal):\n 1. \\<not> i < m \\<Longrightarrow>\n    LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "thus ?thesis"], ["proof (prove)\nusing this:\n  LLL_invariant upw m fs' \\<and> LLL_impl_inv state' m fs'\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' m fs' \\<and>\n    local.basis_reduction_main (upw, i, fs) = fs'", "unfolding basis_reduction_main.simps[of upw i fs]"], ["proof (prove)\nusing this:\n  LLL_invariant upw m fs' \\<and> LLL_impl_inv state' m fs'\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' m fs' \\<and>\n    (if i < m \\<and> LLL_invariant upw i fs\n     then local.basis_reduction_main (local.basis_reduction_step upw i fs)\n     else fs) =\n    fs'", "using False"], ["proof (prove)\nusing this:\n  LLL_invariant upw m fs' \\<and> LLL_impl_inv state' m fs'\n  \\<not> i < m\n\ngoal (1 subgoal):\n 1. LLL_impl_inv state' m fs' \\<and>\n    (if i < m \\<and> LLL_invariant upw i fs\n     then local.basis_reduction_main (local.basis_reduction_step upw i fs)\n     else fs) =\n    fs'", "by (auto simp: LLL_invariant_def fs_id)"], ["proof (state)\nthis:\n  LLL_impl_inv state' m fs' \\<and>\n  local.basis_reduction_main (upw, i, fs) = fs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LLL_impl_inv state' m fs' \\<and>\n  local.basis_reduction_main (upw, i, fs) = fs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction_main: assumes\n  impl: \"LLL_impl_inv state i fs\"\n  and inv: \"LLL_invariant upw i fs\"\n  and res: \"LLL_Impl.basis_reduction_main \\<alpha> n m upw i state = state'\"\n  and fs': \"fs' = fs_state state'\"\nshows \n  \"LLL_invariant True m fs'\"\n  \"LLL_impl_inv state' m fs'\"\n  \"basis_reduction_main (upw,i,fs) = fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True m fs' &&&\n    LLL_impl_inv state' m fs' &&&\n    local.basis_reduction_main (upw, i, fs) = fs'", "using basis_reduction_main_impl[OF assms] basis_reduction_main[OF inv]"], ["proof (prove)\nusing this:\n  LLL_impl_inv state' m fs'\n  local.basis_reduction_main (upw, i, fs) = fs'\n  local.basis_reduction_main (upw, i, fs) = ?fs' \\<Longrightarrow>\n  LLL_invariant True m ?fs'\n\ngoal (1 subgoal):\n 1. LLL_invariant True m fs' &&&\n    LLL_impl_inv state' m fs' &&&\n    local.basis_reduction_main (upw, i, fs) = fs'", "by blast+"], ["", "lemma initial_state: \"LLL_impl_inv (initial_state m fs_init) 0 fs_init\" (is ?g1)\n  \"fs_state (initial_state m fs_init) = fs_init\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init &&&\n    fs_state (initial_state m fs_init) = fs_init", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init\n 2. fs_state (initial_state m fs_init) = fs_init", "have f_repr: \"list_repr 0 ([], fs_init) (map ((!) fs_init) [0..<m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_repr 0 ([], fs_init) (map ((!) fs_init) [0..<m])", "unfolding list_repr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> length (map ((!) fs_init) [0..<m]) \\<and>\n    fst ([], fs_init) = rev (take 0 (map ((!) fs_init) [0..<m])) \\<and>\n    snd ([], fs_init) = drop 0 (map ((!) fs_init) [0..<m])", "by (simp, intro nth_equalityI, auto simp: len)"], ["proof (state)\nthis:\n  list_repr 0 ([], fs_init) (map ((!) fs_init) [0..<m])\n\ngoal (2 subgoals):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init\n 2. fs_state (initial_state m fs_init) = fs_init", "from fs_init"], ["proof (chain)\npicking this:\n  set fs_init \\<subseteq> carrier_vec n", "have Rn: \"set (RAT fs_init) \\<subseteq> Rn\""], ["proof (prove)\nusing this:\n  set fs_init \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn", "by auto"], ["proof (state)\nthis:\n  set (map of_int_hom.vec_hom fs_init) \\<subseteq> Rn\n\ngoal (2 subgoals):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init\n 2. fs_state (initial_state m fs_init) = fs_init", "have 1: \"1 = d fs_init 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = d fs_init 0", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = gs.Gramian_determinant fs_init 0", "by simp"], ["proof (state)\nthis:\n  1 = d fs_init 0\n\ngoal (2 subgoals):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init\n 2. fs_state (initial_state m fs_init) = fs_init", "define j where \"j = m\""], ["proof (state)\nthis:\n  j = m\n\ngoal (2 subgoals):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init\n 2. fs_state (initial_state m fs_init) = fs_init", "have jm: \"j \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> m", "unfolding j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m", "by auto"], ["proof (state)\nthis:\n  j \\<le> m\n\ngoal (2 subgoals):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init\n 2. fs_state (initial_state m fs_init) = fs_init", "have 0: \"0 = m - j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = m - j", "unfolding j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = m - m", "by auto"], ["proof (state)\nthis:\n  0 = m - j\n\ngoal (2 subgoals):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init\n 2. fs_state (initial_state m fs_init) = fs_init", "interpret fs_init: fs_int_indpt n fs_init"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs_int_indpt n fs_init", "by (standard) (use lin_dep in auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init\n 2. fs_state (initial_state m fs_init) = fs_init", "have mu_repr: \"mu_repr (IArray.of_fun (\\<lambda>i. IArray.of_fun ((!!) (d\\<mu>_impl fs_init !! i)) i) m) fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mu_repr\n     (IArray.of_fun\n       (\\<lambda>i. IArray.of_fun ((!!) (d\\<mu>_impl fs_init !! i)) i) m)\n     fs_init", "unfolding fs_init.d\\<mu>_impl mu_repr_def fs_init.d\\<mu>_def d\\<mu>_def fs_init.d_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          ((!!)\n            (IArray.of_fun\n              (\\<lambda>i.\n                  IArray.of_fun\n                   (\\<lambda>j.\n                       int_of_rat\n                        (rat_of_int\n                          (gs.Gramian_determinant fs_init (Suc j)) *\n                         gs.\\<mu> i j))\n                   (Suc i))\n              (length fs_init) !!\n             i))\n          i)\n     m =\n    IArray.of_fun\n     (\\<lambda>i.\n         IArray.of_fun\n          (\\<lambda>j.\n              int_of_rat\n               (rat_of_int (gs.Gramian_determinant fs_init (Suc j)) *\n                gs.\\<mu> i j))\n          i)\n     m", "apply(rule iarray_cong')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < m \\<Longrightarrow>\n       IArray.of_fun\n        ((!!)\n          (IArray.of_fun\n            (\\<lambda>i.\n                IArray.of_fun\n                 (\\<lambda>j.\n                     int_of_rat\n                      (rat_of_int (gs.Gramian_determinant fs_init (Suc j)) *\n                       gs.\\<mu> i j))\n                 (Suc i))\n            (length fs_init) !!\n           i))\n        i =\n       IArray.of_fun\n        (\\<lambda>j.\n            int_of_rat\n             (rat_of_int (gs.Gramian_determinant fs_init (Suc j)) *\n              gs.\\<mu> i j))\n        i", "unfolding len[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length fs_init \\<Longrightarrow>\n       IArray.of_fun\n        ((!!)\n          (IArray.of_fun\n            (\\<lambda>i.\n                IArray.of_fun\n                 (\\<lambda>j.\n                     int_of_rat\n                      (rat_of_int (gs.Gramian_determinant fs_init (Suc j)) *\n                       gs.\\<mu> i j))\n                 (Suc i))\n            (length fs_init) !!\n           i))\n        i =\n       IArray.of_fun\n        (\\<lambda>j.\n            int_of_rat\n             (rat_of_int (gs.Gramian_determinant fs_init (Suc j)) *\n              gs.\\<mu> i j))\n        i", "by (auto simp add: nth_append)"], ["proof (state)\nthis:\n  mu_repr\n   (IArray.of_fun\n     (\\<lambda>i. IArray.of_fun ((!!) (d\\<mu>_impl fs_init !! i)) i) m)\n   fs_init\n\ngoal (2 subgoals):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init\n 2. fs_state (initial_state m fs_init) = fs_init", "have d_repr: \"d_repr (IArray.of_fun (\\<lambda>i. if i = 0 then 1 else d\\<mu>_impl fs_init !! (i - 1) !! (i - 1)) (Suc m)) fs_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_repr\n     (IArray.of_fun\n       (\\<lambda>i.\n           if i = 0 then 1 else d\\<mu>_impl fs_init !! (i - 1) !! (i - 1))\n       (Suc m))\n     fs_init", "unfolding fs_init.d\\<mu>_impl d_repr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.of_fun\n     (\\<lambda>i.\n         if i = 0 then 1\n         else IArray.of_fun\n               (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n               (length fs_init) !!\n              (i - 1) !!\n              (i - 1))\n     (Suc m) =\n    IArray.of_fun (d fs_init) (Suc m)", "proof (intro iarray_cong', goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc m \\<Longrightarrow>\n       (if i = 0 then 1\n        else IArray.of_fun\n              (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n              (length fs_init) !!\n             (i - 1) !!\n             (i - 1)) =\n       d fs_init i", "case (1 i)"], ["proof (state)\nthis:\n  i < Suc m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc m \\<Longrightarrow>\n       (if i = 0 then 1\n        else IArray.of_fun\n              (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n              (length fs_init) !!\n             (i - 1) !!\n             (i - 1)) =\n       d fs_init i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i", "hence le: \"i - 1 < length fs_init\" \"i - 1 < i\" and id: \"(i = 0) = False\" \"Suc (i - 1) = i\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (i - 1 < length fs_init &&& i - 1 < i) &&&\n    (i = 0) = False &&& Suc (i - 1) = i", "using 1 len"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  i < Suc m\n  length fs_init = m\n\ngoal (1 subgoal):\n 1. (i - 1 < length fs_init &&& i - 1 < i) &&&\n    (i = 0) = False &&& Suc (i - 1) = i", "by auto"], ["proof (state)\nthis:\n  i - 1 < length fs_init\n  i - 1 < i\n  (i = 0) = False\n  Suc (i - 1) = i\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i", "unfolding of_fun_nth[OF le(1)] of_fun_nth[OF le(2)] id if_False\n        d\\<mu>_def fs_init.d\\<mu>_def fs_init.d_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_rat\n     (rat_of_int (gs.Gramian_determinant fs_init i) *\n      gs.\\<mu> (i - 1) (i - 1)) =\n    gs.Gramian_determinant fs_init i", "by (auto simp add: gs.\\<mu>.simps )"], ["proof (state)\nthis:\n  (if i = 0 then 1\n   else IArray.of_fun (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n         (length fs_init) !!\n        (i - 1) !!\n        (i - 1)) =\n  d fs_init i\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i", "have \"d fs_init 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d fs_init 0 = 1", "unfolding d_def gs.Gramian_determinant_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = 1", "by simp"], ["proof (state)\nthis:\n  d fs_init 0 = 1\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i", "thus ?thesis"], ["proof (prove)\nusing this:\n  d fs_init 0 = 1\n\ngoal (1 subgoal):\n 1. (if i = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (i - 1) !!\n          (i - 1)) =\n    d fs_init i", "unfolding True"], ["proof (prove)\nusing this:\n  d fs_init 0 = 1\n\ngoal (1 subgoal):\n 1. (if 0 = 0 then 1\n     else IArray.of_fun\n           (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n           (length fs_init) !!\n          (0 - 1) !!\n          (0 - 1)) =\n    d fs_init 0", "by simp"], ["proof (state)\nthis:\n  (if i = 0 then 1\n   else IArray.of_fun (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n         (length fs_init) !!\n        (i - 1) !!\n        (i - 1)) =\n  d fs_init i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if i = 0 then 1\n   else IArray.of_fun (\\<lambda>i. IArray.of_fun (fs_init.d\\<mu> i) (Suc i))\n         (length fs_init) !!\n        (i - 1) !!\n        (i - 1)) =\n  d fs_init i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_repr\n   (IArray.of_fun\n     (\\<lambda>i.\n         if i = 0 then 1 else d\\<mu>_impl fs_init !! (i - 1) !! (i - 1))\n     (Suc m))\n   fs_init\n\ngoal (2 subgoals):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init\n 2. fs_state (initial_state m fs_init) = fs_init", "show ?g1"], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_impl_inv (initial_state m fs_init) 0 fs_init", "unfolding initial_state_def Let_def LLL_impl_inv.simps id"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_repr 0 ([], fs_init) (map ((!) fs_init) [0..<m]) \\<and>\n    d_repr\n     (IArray.of_fun\n       (\\<lambda>i.\n           if i = 0 then 1 else d\\<mu>_impl fs_init !! (i - 1) !! (i - 1))\n       (Suc m))\n     fs_init \\<and>\n    mu_repr\n     (IArray.of_fun\n       (\\<lambda>i. IArray.of_fun ((!!) (d\\<mu>_impl fs_init !! i)) i) m)\n     fs_init", "by (intro conjI f_repr mu_repr d_repr)"], ["proof (state)\nthis:\n  LLL_impl_inv (initial_state m fs_init) 0 fs_init\n\ngoal (1 subgoal):\n 1. fs_state (initial_state m fs_init) = fs_init", "from fs_state[OF this LLL_inv_initial_state]"], ["proof (chain)\npicking this:\n  \\<lbrakk>initial_state m fs_init = (?f, ?mu, ?ds);\n   length fs_init = m\\<rbrakk>\n  \\<Longrightarrow> fs_state (initial_state m fs_init) = fs_init", "show ?g2"], ["proof (prove)\nusing this:\n  \\<lbrakk>initial_state m fs_init = (?f, ?mu, ?ds);\n   length fs_init = m\\<rbrakk>\n  \\<Longrightarrow> fs_state (initial_state m fs_init) = fs_init\n\ngoal (1 subgoal):\n 1. fs_state (initial_state m fs_init) = fs_init", "unfolding initial_state_def Let_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(([], fs_init),\n            IArray.of_fun\n             (\\<lambda>i. IArray.of_fun ((!!) (d\\<mu>_impl fs_init !! i)) i)\n             m,\n            IArray.of_fun\n             (\\<lambda>i.\n                 if i = 0 then 1\n                 else d\\<mu>_impl fs_init !! (i - 1) !! (i - 1))\n             (Suc m)) =\n           (?f, ?mu, ?ds);\n   length fs_init = m\\<rbrakk>\n  \\<Longrightarrow> fs_state\n                     (([], fs_init),\n                      IArray.of_fun\n                       (\\<lambda>i.\n                           IArray.of_fun ((!!) (d\\<mu>_impl fs_init !! i))\n                            i)\n                       m,\n                      IArray.of_fun\n                       (\\<lambda>i.\n                           if i = 0 then 1\n                           else d\\<mu>_impl fs_init !! (i - 1) !! (i - 1))\n                       (Suc m)) =\n                    fs_init\n\ngoal (1 subgoal):\n 1. fs_state\n     (([], fs_init),\n      IArray.of_fun\n       (\\<lambda>i. IArray.of_fun ((!!) (d\\<mu>_impl fs_init !! i)) i) m,\n      IArray.of_fun\n       (\\<lambda>i.\n           if i = 0 then 1 else d\\<mu>_impl fs_init !! (i - 1) !! (i - 1))\n       (Suc m)) =\n    fs_init", "by (simp add: of_list_repr_def)"], ["proof (state)\nthis:\n  fs_state (initial_state m fs_init) = fs_init\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_reduction: assumes res: \"basis_reduction \\<alpha> n fs_init = state\"\n  and fs: \"fs = fs_state state\"\nshows \"LLL_invariant True m fs\"\n  \"LLL_impl_inv state m fs\"\n  \"basis_reduction_main (True, 0, fs_init) = fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_invariant True m fs &&&\n    LLL_impl_inv state m fs &&&\n    local.basis_reduction_main (True, 0, fs_init) = fs", "using basis_reduction_main[OF initial_state(1) LLL_inv_initial_state res[unfolded basis_reduction_def len Let_def] fs]"], ["proof (prove)\nusing this:\n  LLL_invariant True m fs\n  LLL_impl_inv state m fs\n  local.basis_reduction_main (True, 0, fs_init) = fs\n\ngoal (1 subgoal):\n 1. LLL_invariant True m fs &&&\n    LLL_impl_inv state m fs &&&\n    local.basis_reduction_main (True, 0, fs_init) = fs", "by auto"], ["", "lemma reduce_basis_impl: \"LLL_Impl.reduce_basis \\<alpha> fs_init = reduce_basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init = local.reduce_basis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init = local.reduce_basis", "obtain fs where res: \"LLL_Impl.reduce_basis \\<alpha> fs_init = fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fs.\n        LLL_Impl.reduce_basis \\<alpha> fs_init = fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs\n\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init = local.reduce_basis", "have \"reduce_basis = fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.reduce_basis = fs", "proof (cases fs_init)"], ["proof (state)\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow> local.reduce_basis = fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow> local.reduce_basis = fs", "case (Cons f)"], ["proof (state)\nthis:\n  fs_init = f # list_\n\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow> local.reduce_basis = fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow> local.reduce_basis = fs", "from fs_init[unfolded Cons]"], ["proof (chain)\npicking this:\n  set (f # list_) \\<subseteq> carrier_vec n", "have \"dim_vec f = n\""], ["proof (prove)\nusing this:\n  set (f # list_) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec f = n", "by auto"], ["proof (state)\nthis:\n  dim_vec f = n\n\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow> local.reduce_basis = fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow> local.reduce_basis = fs", "from res[unfolded LLL_Impl.reduce_basis_def Cons list.simps this, folded Cons]"], ["proof (chain)\npicking this:\n  fs_state (basis_reduction \\<alpha> n fs_init) = fs", "have \"fs_state (LLL_Impl.basis_reduction \\<alpha> n fs_init) = fs\""], ["proof (prove)\nusing this:\n  fs_state (basis_reduction \\<alpha> n fs_init) = fs\n\ngoal (1 subgoal):\n 1. fs_state (basis_reduction \\<alpha> n fs_init) = fs", "by auto"], ["proof (state)\nthis:\n  fs_state (basis_reduction \\<alpha> n fs_init) = fs\n\ngoal (2 subgoals):\n 1. fs_init = [] \\<Longrightarrow> local.reduce_basis = fs\n 2. \\<And>a list.\n       fs_init = a # list \\<Longrightarrow> local.reduce_basis = fs", "from basis_reduction(3)[OF refl refl, unfolded this]"], ["proof (chain)\npicking this:\n  local.basis_reduction_main (True, 0, fs_init) = fs", "show \"reduce_basis = fs\""], ["proof (prove)\nusing this:\n  local.basis_reduction_main (True, 0, fs_init) = fs\n\ngoal (1 subgoal):\n 1. local.reduce_basis = fs", "unfolding reduce_basis_def"], ["proof (prove)\nusing this:\n  local.basis_reduction_main (True, 0, fs_init) = fs\n\ngoal (1 subgoal):\n 1. local.basis_reduction_main (True, 0, fs_init) = fs", "."], ["proof (state)\nthis:\n  local.reduce_basis = fs\n\ngoal (1 subgoal):\n 1. fs_init = [] \\<Longrightarrow> local.reduce_basis = fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fs_init = [] \\<Longrightarrow> local.reduce_basis = fs", "case Nil"], ["proof (state)\nthis:\n  fs_init = []\n\ngoal (1 subgoal):\n 1. fs_init = [] \\<Longrightarrow> local.reduce_basis = fs", "with len"], ["proof (chain)\npicking this:\n  length fs_init = m\n  fs_init = []", "have m0: \"m = 0\""], ["proof (prove)\nusing this:\n  length fs_init = m\n  fs_init = []\n\ngoal (1 subgoal):\n 1. m = 0", "by auto"], ["proof (state)\nthis:\n  m = 0\n\ngoal (1 subgoal):\n 1. fs_init = [] \\<Longrightarrow> local.reduce_basis = fs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.reduce_basis = fs", "using res"], ["proof (prove)\nusing this:\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs\n\ngoal (1 subgoal):\n 1. local.reduce_basis = fs", "unfolding reduce_basis_def LLL_Impl.reduce_basis_def basis_reduction_main.simps"], ["proof (prove)\nusing this:\n  (case fs_init of [] \\<Rightarrow> fs_init\n   | f # x \\<Rightarrow>\n       fs_state (basis_reduction \\<alpha> (dim_vec f) fs_init)) =\n  fs\n\ngoal (1 subgoal):\n 1. (if 0 < m \\<and> LLL_invariant True 0 fs_init\n     then local.basis_reduction_main\n           (local.basis_reduction_step True 0 fs_init)\n     else fs_init) =\n    fs", "using Nil m0"], ["proof (prove)\nusing this:\n  (case fs_init of [] \\<Rightarrow> fs_init\n   | f # x \\<Rightarrow>\n       fs_state (basis_reduction \\<alpha> (dim_vec f) fs_init)) =\n  fs\n  fs_init = []\n  m = 0\n\ngoal (1 subgoal):\n 1. (if 0 < m \\<and> LLL_invariant True 0 fs_init\n     then local.basis_reduction_main\n           (local.basis_reduction_step True 0 fs_init)\n     else fs_init) =\n    fs", "by simp"], ["proof (state)\nthis:\n  local.reduce_basis = fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.reduce_basis = fs\n\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init = local.reduce_basis", "with res"], ["proof (chain)\npicking this:\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs\n  local.reduce_basis = fs", "show ?thesis"], ["proof (prove)\nusing this:\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs\n  local.reduce_basis = fs\n\ngoal (1 subgoal):\n 1. LLL_Impl.reduce_basis \\<alpha> fs_init = local.reduce_basis", "by simp"], ["proof (state)\nthis:\n  LLL_Impl.reduce_basis \\<alpha> fs_init = local.reduce_basis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduce_basis: assumes \"LLL_Impl.reduce_basis \\<alpha> fs_init = fs\"\n  shows \"lattice_of fs = L\" \n  \"reduced fs m\" \n  \"lin_indep fs\" \n  \"length fs = m\" \n  \"LLL_invariant True m fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lattice_of fs = L &&&\n     gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m) &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) &&&\n    length fs = m &&& LLL_invariant True m fs", "using reduce_basis_impl assms reduce_basis reduce_basis_inv"], ["proof (prove)\nusing this:\n  LLL_Impl.reduce_basis \\<alpha> fs_init = local.reduce_basis\n  LLL_Impl.reduce_basis \\<alpha> fs_init = fs\n  local.reduce_basis = ?fs \\<Longrightarrow> lattice_of ?fs = L\n  local.reduce_basis = ?fs \\<Longrightarrow>\n  gram_schmidt_fs.reduced n (map of_int_hom.vec_hom ?fs) \\<alpha> m\n  local.reduce_basis = ?fs \\<Longrightarrow>\n  gs.lin_indpt_list (map of_int_hom.vec_hom ?fs)\n  local.reduce_basis = ?fs \\<Longrightarrow> length ?fs = m\n  local.reduce_basis = ?fs \\<Longrightarrow> LLL_invariant True m ?fs\n\ngoal (1 subgoal):\n 1. (lattice_of fs = L &&&\n     gram_schmidt_fs.reduced n (map of_int_hom.vec_hom fs) \\<alpha> m) &&&\n    gs.lin_indpt_list (map of_int_hom.vec_hom fs) &&&\n    length fs = m &&& LLL_invariant True m fs", "by metis+"], ["", "lemma short_vector_impl: \"LLL_Impl.short_vector \\<alpha> fs_init = short_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LLL_Impl.short_vector \\<alpha> fs_init = local.short_vector", "using reduce_basis_impl"], ["proof (prove)\nusing this:\n  LLL_Impl.reduce_basis \\<alpha> fs_init = local.reduce_basis\n\ngoal (1 subgoal):\n 1. LLL_Impl.short_vector \\<alpha> fs_init = local.short_vector", "unfolding LLL_Impl.short_vector_def short_vector_def"], ["proof (prove)\nusing this:\n  LLL_Impl.reduce_basis \\<alpha> fs_init = local.reduce_basis\n\ngoal (1 subgoal):\n 1. hd (LLL_Impl.reduce_basis \\<alpha> fs_init) = hd local.reduce_basis", "by simp"], ["", "lemma short_vector: assumes res: \"LLL_Impl.short_vector \\<alpha> fs_init = v\"\n  and m0: \"m \\<noteq> 0\"\nshows \n  \"v \\<in> carrier_vec n\"\n  \"v \\<in> L - {0\\<^sub>v n}\"\n  \"h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow> rat_of_int (sq_norm v) \\<le> \\<alpha> ^ (m - 1) * rat_of_int (sq_norm h)\"\n  \"v \\<noteq> 0\\<^sub>v j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n &&& v \\<in> L - {0\\<^sub>v n}) &&&\n    (h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) &&&\n    v \\<noteq> 0\\<^sub>v j", "using short_vector[OF assms[unfolded short_vector_impl]]"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<in> L - {0\\<^sub>v n}\n  ?h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n  rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n  \\<le> \\<alpha> ^ (m - 1) * rat_of_int \\<parallel>?h\\<parallel>\\<^sup>2\n  v \\<noteq> 0\\<^sub>v ?j\n\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n &&& v \\<in> L - {0\\<^sub>v n}) &&&\n    (h \\<in> L - {0\\<^sub>v n} \\<Longrightarrow>\n     rat_of_int \\<parallel>v\\<parallel>\\<^sup>2\n     \\<le> \\<alpha> ^ (m - 1) *\n           rat_of_int \\<parallel>h\\<parallel>\\<^sup>2) &&&\n    v \\<noteq> 0\\<^sub>v j", "by metis+"], ["", "end"], ["", "end"]]}