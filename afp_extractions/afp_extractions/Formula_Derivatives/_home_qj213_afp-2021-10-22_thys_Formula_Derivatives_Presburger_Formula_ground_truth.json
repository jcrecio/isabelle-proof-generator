{"file_name": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives/Presburger_Formula.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives", "problem_names": ["lemma len_eq0_iff: \"len n = 0 \\<longleftrightarrow> n = 0\"", "lemma len_mult2[simp]: \"len (2 * x) = (if x = 0 then 0 else Suc (len x))\"", "lemma len_mult2'[simp]: \"len (x * 2) = (if x = 0 then 0 else Suc (len x))\"", "lemma len_Suc_mult2[simp]: \"len (Suc (2 * x)) = Suc (len x)\"", "lemma len_le_iff: \"len x \\<le> l \\<longleftrightarrow> x < 2 ^ l\"", "lemma len_pow2[simp]: \"len (2 ^ x) = Suc x\"", "lemma len_div2[simp]: \"len (x div 2) = len x - 1\"", "lemma less_pow2_len[simp]: \"x < 2 ^ len x\"", "lemma len_alt: \"len x = (LEAST i. x < 2 ^ i)\"", "lemma len_mono[simp]: \"x \\<le> y \\<Longrightarrow> len x \\<le> len y\"", "lemma len_div_pow2[simp]: \"len (x div 2 ^ m) = len x - m\"", "lemma len_mult_pow2[simp]: \"len (x * 2 ^ m) = (if x = 0 then 0 else len x + m)\"", "lemma map_index'_Suc[simp]: \"map_index' (Suc i) f xs = map_index' i (\\<lambda>i. f (Suc i)) xs\"", "lemma FV0_code[code]:\n  \"FV0 x (Eq is i off) = Option.these (set (map_index (\\<lambda>i x. if x = 0 then None else Some i) is))\"", "lemma nvars_Extend[Presb_simps]: \"#\\<^sub>V (Extend () i \\<AA> P) = Suc (#\\<^sub>V \\<AA>)\"", "lemma Length_Extend[Presb_simps]: \"Length (Extend () i \\<AA> P) = max (Length \\<AA>) (len P)\"", "lemma Length0_inj[Presb_simps]: \"Length \\<AA> = 0 \\<Longrightarrow> Length \\<BB> = 0 \\<Longrightarrow> #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB> \\<Longrightarrow> \\<AA> = \\<BB>\"", "lemma ex_Length0[Presb_simps]: \"\\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\"", "lemma Extend_commute_safe[Presb_simps]: \"\\<lbrakk>j \\<le> i; i < Suc (#\\<^sub>V \\<AA>)\\<rbrakk> \\<Longrightarrow>\n  Extend k j (Extend k i \\<AA> P) Q = Extend k (Suc i) (Extend k j \\<AA> Q) P\"", "lemma Extend_commute_unsafe[Presb_simps]:\n  \"k \\<noteq> k' \\<Longrightarrow> Extend k j (Extend k' i \\<AA> P) Q = Extend k' i (Extend k j \\<AA> Q) P\"", "lemma assigns_Extend[Presb_simps]: \"i < Suc (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n  m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' = (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k else m\\<^bsup>\\<AA>\\<^esup>k')\"", "lemma assigns_SNOC_zero[Presb_simps]: \"m < #\\<^sub>V \\<AA> \\<Longrightarrow> m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k = m\\<^bsup>\\<AA>\\<^esup>k\"", "lemma Length_CONS[Presb_simps]: \"Length (CONS x \\<AA>) = Suc (Length \\<AA>)\"", "lemma Length_SNOC[Presb_simps]: \"Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\"", "lemma nvars_CONS[Presb_simps]: \"#\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\"", "lemma nvars_SNOC[Presb_simps]: \"#\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\"", "lemma Extend_CONS[Presb_simps]: \"#\\<^sub>V \\<AA> = length x \\<Longrightarrow>\n  Extend k 0 (CONS x \\<AA>) P = CONS (extend k (test_bit P 0) x) (Extend k 0 \\<AA> (downshift P))\"", "lemma Extend_SNOC[Presb_simps]: \"\\<lbrakk>#\\<^sub>V \\<AA> = length x; len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk> \\<Longrightarrow>\n  Extend k 0 (SNOC x \\<AA>) P =\n    SNOC (extend k (test_bit P (Length \\<AA>)) x) (Extend k 0 \\<AA> (cut_bits (Length \\<AA>) P))\"", "lemma odd_neq_even:\n  \"Suc (2 * x) = 2 * y \\<longleftrightarrow> False\"\n  \"2 * y = Suc (2 * x) \\<longleftrightarrow> False\"", "lemma CONS_inj[Presb_simps]: \"size x = #\\<^sub>V \\<AA> \\<Longrightarrow> size y = #\\<^sub>V \\<AA> \\<Longrightarrow> #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB> \\<Longrightarrow>\n  CONS x \\<AA> = CONS y \\<BB> \\<longleftrightarrow> (x = y \\<and> \\<AA> = \\<BB>)\"", "lemma mod_2_Suc_iff:\n  \"x mod 2 = Suc 0 \\<longleftrightarrow> x = Suc (2 * (x div 2))\"", "lemma CONS_surj[Presb_simps]: \"Length \\<AA> \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>x \\<BB>. \\<AA> = CONS x \\<BB> \\<and> #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and> size x = #\\<^sub>V \\<AA>\"", "lemma [Presb_simps]: \n  \"length (extend k b x) = Suc (length x)\"\n  \"downshift (upshift P) = P\"\n  \"downshift (set_bit 0 P) = downshift P\"\n  \"test_bit (set_bit n P) n\"\n  \"\\<not> test_bit (upshift P) 0\"\n  \"len P \\<le> p \\<Longrightarrow> \\<not> test_bit P p\"\n  \"len (cut_bits n P) \\<le> n\"\n  \"len P \\<le> n \\<Longrightarrow> cut_bits n P = P\"\n  \"len (upshift P) = (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> Suc (Suc n))\"\n  \"len (downshift P) = (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\"", "lemma Suc0_div_pow2_eq: \"Suc 0 div 2 ^ i = (if i = 0 then 1 else 0)\"", "lemma set_unset_bit_preserves_len:\n  assumes \"x div 2 ^ m = 2 * q\" \"m < len x\"\n  shows \"x + 2 ^ m < 2 ^ len x\"", "lemma len_set_bit[Presb_simps]: \"len (set_bit m P) = max (Suc m) (len P)\"", "lemma mod_pow2_div_pow2:\n  fixes p m n :: nat\n  shows \"m < n \\<Longrightarrow> p mod 2 ^ n div 2 ^ m = p div 2 ^ m mod 2 ^ (n - m)\"", "lemma irrelevant_set_bit[simp]:\n  fixes p m n :: nat\n  assumes \"n \\<le> m\"\n  shows \"(p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n\"", "lemma mod_lemma: \"\\<lbrakk> (0::nat) < c; r < b \\<rbrakk> \\<Longrightarrow> b * (q mod c) + r < b * c\"", "lemma relevant_set_bit[simp]:\n  fixes p m n :: nat\n  assumes \"m < n\" \"p div 2 ^ m = 2 * q\"\n  shows \"(p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n + 2 ^ m\"", "lemma cut_bits_set_bit[Presb_simps]: \"cut_bits n (set_bit m p) =\n  (if n \\<le> m then cut_bits n p else set_bit m (cut_bits n p))\"", "lemma wf0_decr0[Presb_simps]:\n  \"wf0 (Suc idx) a \\<Longrightarrow> l < Suc idx \\<Longrightarrow> \\<not> find0 k l a \\<Longrightarrow> wf0 idx (decr0 k l a)\"", "lemma lformula0_decr0[Presb_simps]: \"lformula0 a \\<Longrightarrow> lformula0 (decr0 k l a)\"", "lemma scalar_product_Nil[simp]: \"scalar_product [] xs = 0\"", "lemma scalar_product_Nil2[simp]: \"scalar_product xs [] = 0\"", "lemma scalar_product_Cons[simp]:\n  \"scalar_product xs (y # ys) = (case xs of x # xs \\<Rightarrow> x * y + scalar_product xs ys | [] \\<Rightarrow> 0)\"", "lemma scalar_product_append[simp]: \"scalar_product ns (xs @ ys) =\n  scalar_product (take (length xs) ns) xs + scalar_product (drop (length xs) ns) ys\"", "lemma scalar_product_trim: \"scalar_product ns xs = scalar_product (take (length xs) ns) xs\"", "lemma Extend_satisfies0_decr0[Presb_simps]:\n  assumes \"\\<not> find0 k i a\" \"i < Suc (#\\<^sub>V \\<AA>)\" \"lformula0 a \\<or> len P \\<le> Length \\<AA>\"\n  shows \"Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a\"", "lemma scalar_product_eq0: \"\\<forall>c\\<in>set ns. c = 0 \\<Longrightarrow> scalar_product ns is = 0\"", "lemma nullable0_satisfies0[Presb_simps]: \"Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = \\<AA> \\<Turnstile>0 a\"", "lemma satisfies0_cong: \"wf0 (#\\<^sub>V \\<BB>) a \\<Longrightarrow> #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB> \\<Longrightarrow> lformula0 a \\<Longrightarrow>\n  (\\<And>m k. m < #\\<^sub>V \\<BB> \\<Longrightarrow> m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k) \\<Longrightarrow> \\<AA> \\<Turnstile>0 a = \\<BB> \\<Turnstile>0 a\"", "lemma wf_lderiv0[Presb_simps]:\n  \"wf0 idx a \\<Longrightarrow> lformula0 a \\<Longrightarrow> Formula_Operations.wf (\\<lambda>_. Suc) wf0 idx (lderiv0 x a)\"", "lemma lformula_lderiv0[Presb_simps]:\n  \"lformula0 a \\<Longrightarrow> Formula_Operations.lformula lformula0 (lderiv0 x a)\"", "lemma wf_rderiv0[Presb_simps]:\n  \"wf0 idx a \\<Longrightarrow> Formula_Operations.wf (\\<lambda>_. Suc) wf0 idx (rderiv0 x a)\"", "lemma find0_FV0[Presb_simps]: \"\\<lbrakk>wf0 idx a; l < idx\\<rbrakk> \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\"", "lemma FV0_less[Presb_simps]: \"wf0 idx a \\<Longrightarrow> v \\<in> FV0 k a \\<Longrightarrow> v < idx\"", "lemma finite_FV0[Presb_simps]: \"finite (FV0 k a)\"", "lemma finite_lderiv0[Presb_simps]:\n  assumes \"lformula0 a\"\n  shows \"finite {\\<phi>. \\<exists>xs. \\<phi> = fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}\"", "lemma finite_rderiv0[Presb_simps]:\n  \"finite {\\<phi>. \\<exists>xs. \\<phi> = fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}\"", "lemma scalar_product_CONS: \"length xs = length (bs :: bool list) \\<Longrightarrow>\n  scalar_product (map_index (\\<lambda>i n. 2 * n + bs ! i) xs) is =\n  scalar_product bs is + 2 * scalar_product xs is\"", "lemma eval_tm_CONS[simp]:\n  \"\\<lbrakk>length is \\<le> #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x\\<rbrakk> \\<Longrightarrow>\n   eval_tm (CONS x \\<AA>) is = scalar_product x is + 2 * eval_tm \\<AA> is\"", "lemma satisfies_lderiv0[Presb_simps]:\n  \"\\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = length x; lformula0 a\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile> lderiv0 x a \\<longleftrightarrow> CONS x \\<AA> \\<Turnstile>0 a\"", "lemma satisfies_bounded_lderiv0[Presb_simps]:\n  \"\\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = length x; lformula0 a\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b lderiv0 x a \\<longleftrightarrow> CONS x \\<AA> \\<Turnstile>0 a\"", "lemma scalar_product_SNOC: \"length xs = length (bs :: bool list)  \\<Longrightarrow>\n  scalar_product (map_index (\\<lambda>i m. m + 2 ^ a * bs ! i) xs) is =\n  scalar_product xs is + 2 ^ a * scalar_product bs is\"", "lemma eval_tm_SNOC[simp]:\n  \"\\<lbrakk>length is \\<le> #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x\\<rbrakk> \\<Longrightarrow>\n   eval_tm (SNOC x \\<AA>) is = eval_tm \\<AA> is + 2 ^ Length \\<AA> * scalar_product x is\"", "lemma Length_eq0_eval_tm_eq0[simp]: \"Length \\<AA> = 0 \\<Longrightarrow> eval_tm \\<AA> is = 0\"", "lemma less_pow2: \"x < 2 ^ a \\<Longrightarrow> int x < 2 ^ a\"", "lemma scalar_product_upper_bound: \"\\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n  scalar_product b is \\<le> (2 ^ a - 1) * sum_list [i. i \\<leftarrow> is, i > 0]\"", "lemma scalar_product_lower_bound: \"\\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n  scalar_product b is \\<ge> (2 ^ a - 1) * sum_list [i. i \\<leftarrow> is, i < 0]\"", "lemma eval_tm_upper_bound: \"eval_tm \\<AA> is \\<le> (2 ^ Length \\<AA> - 1) * sum_list [i. i \\<leftarrow> is, i > 0]\"", "lemma eval_tm_lower_bound: \"eval_tm \\<AA> is \\<ge> (2 ^ Length \\<AA> - 1) * sum_list [i. i \\<leftarrow> is, i < 0]\"", "lemma satisfies_bounded_rderiv0[Presb_simps]:\n  \"\\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = length x\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b rderiv0 x a \\<longleftrightarrow> SNOC x \\<AA> \\<Turnstile>0 a\"", "lemma check_eqv_code[code]: \"check_eqv idx r s =\n  ((presb_wf idx r \\<and> presb_lformula r) \\<and> (presb_wf idx s \\<and> presb_lformula s) \\<and>\n  (case rtrancl_while (\\<lambda>(p, q). final idx p = final idx q)\n    (\\<lambda>(p, q). map (\\<lambda>a. (norm (deriv lderiv0 a p), norm (deriv lderiv0 a q))) (\\<sigma> idx))\n    (norm (RESTRICT r), norm (RESTRICT s)) of\n    None \\<Rightarrow> False\n  | Some ([], x) \\<Rightarrow> True\n  | Some (a # list, x) \\<Rightarrow> False))\"", "lemma check_eqv_sound: \n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> (Presb.sat \\<AA> \\<phi> \\<longleftrightarrow> Presb.sat \\<AA> \\<psi>)\"", "lemma bounded_check_eqv_sound:\n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; bounded_check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> (Presb.sat\\<^sub>b \\<AA> \\<phi> \\<longleftrightarrow> Presb.sat\\<^sub>b \\<AA> \\<psi>)\""], "translations": [["", "lemma len_eq0_iff: \"len n = 0 \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (len n = 0) = (n = 0)", "by (induct n rule: len.induct) auto"], ["", "lemma len_mult2[simp]: \"len (2 * x) = (if x = 0 then 0 else Suc (len x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (2 * x) = (if x = 0 then 0 else Suc (len x))", "proof (induct x rule: len.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. len (2 * 0) = (if 0 = 0 then 0 else Suc (len 0))\n 2. len (2 * Suc 0) = (if Suc 0 = 0 then 0 else Suc (len (Suc 0)))\n 3. \\<And>va.\n       len (2 * (Suc (Suc va) div 2)) =\n       (if Suc (Suc va) div 2 = 0 then 0\n        else Suc (len (Suc (Suc va) div 2))) \\<Longrightarrow>\n       len (2 * Suc (Suc va)) =\n       (if Suc (Suc va) = 0 then 0 else Suc (len (Suc (Suc va))))", "show \"len (2 * Suc 0) = (if Suc 0 = 0 then 0 else Suc (len (Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (2 * Suc 0) = (if Suc 0 = 0 then 0 else Suc (len (Suc 0)))", "by (simp add: numeral_eq_Suc)"], ["proof (state)\nthis:\n  len (2 * Suc 0) = (if Suc 0 = 0 then 0 else Suc (len (Suc 0)))\n\ngoal (2 subgoals):\n 1. len (2 * 0) = (if 0 = 0 then 0 else Suc (len 0))\n 2. \\<And>va.\n       len (2 * (Suc (Suc va) div 2)) =\n       (if Suc (Suc va) div 2 = 0 then 0\n        else Suc (len (Suc (Suc va) div 2))) \\<Longrightarrow>\n       len (2 * Suc (Suc va)) =\n       (if Suc (Suc va) = 0 then 0 else Suc (len (Suc (Suc va))))", "qed auto"], ["", "lemma len_mult2'[simp]: \"len (x * 2) = (if x = 0 then 0 else Suc (len x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (x * 2) = (if x = 0 then 0 else Suc (len x))", "using len_mult2 [of x]"], ["proof (prove)\nusing this:\n  len (2 * x) = (if x = 0 then 0 else Suc (len x))\n\ngoal (1 subgoal):\n 1. len (x * 2) = (if x = 0 then 0 else Suc (len x))", "by (simp add: ac_simps)"], ["", "lemma len_Suc_mult2[simp]: \"len (Suc (2 * x)) = Suc (len x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (Suc (2 * x)) = Suc (len x)", "proof (induct x rule: len.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. len (Suc (2 * 0)) = Suc (len 0)\n 2. len (Suc (2 * Suc 0)) = Suc (len (Suc 0))\n 3. \\<And>va.\n       len (Suc (2 * (Suc (Suc va) div 2))) =\n       Suc (len (Suc (Suc va) div 2)) \\<Longrightarrow>\n       len (Suc (2 * Suc (Suc va))) = Suc (len (Suc (Suc va)))", "show \"len (Suc (2 * Suc 0)) = Suc (len (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (Suc (2 * Suc 0)) = Suc (len (Suc 0))", "by (metis div_less One_nat_def div2_Suc_Suc len.simps(3) lessI mult.right_neutral numeral_2_eq_2)"], ["proof (state)\nthis:\n  len (Suc (2 * Suc 0)) = Suc (len (Suc 0))\n\ngoal (2 subgoals):\n 1. len (Suc (2 * 0)) = Suc (len 0)\n 2. \\<And>va.\n       len (Suc (2 * (Suc (Suc va) div 2))) =\n       Suc (len (Suc (Suc va) div 2)) \\<Longrightarrow>\n       len (Suc (2 * Suc (Suc va))) = Suc (len (Suc (Suc va)))", "qed auto"], ["", "lemma len_le_iff: \"len x \\<le> l \\<longleftrightarrow> x < 2 ^ l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (len x \\<le> l) = (x < 2 ^ l)", "proof (induct x arbitrary: l rule: len.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l. (len 0 \\<le> l) = (0 < 2 ^ l)\n 2. \\<And>l. (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)\n 3. \\<And>va l.\n       (\\<And>l.\n           (len (Suc (Suc va) div 2) \\<le> l) =\n           (Suc (Suc va) div 2 < 2 ^ l)) \\<Longrightarrow>\n       (len (Suc (Suc va)) \\<le> l) = (Suc (Suc va) < 2 ^ l)", "fix l"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l. (len 0 \\<le> l) = (0 < 2 ^ l)\n 2. \\<And>l. (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)\n 3. \\<And>va l.\n       (\\<And>l.\n           (len (Suc (Suc va) div 2) \\<le> l) =\n           (Suc (Suc va) div 2 < 2 ^ l)) \\<Longrightarrow>\n       (len (Suc (Suc va)) \\<le> l) = (Suc (Suc va) < 2 ^ l)", "show \"(len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)", "proof (cases l)"], ["proof (state)\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow> (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)\n 2. \\<And>nat.\n       l = Suc nat \\<Longrightarrow> (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)", "case Suc"], ["proof (state)\nthis:\n  l = Suc nat_\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow> (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)\n 2. \\<And>nat.\n       l = Suc nat \\<Longrightarrow> (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)", "then"], ["proof (chain)\npicking this:\n  l = Suc nat_", "show ?thesis"], ["proof (prove)\nusing this:\n  l = Suc nat_\n\ngoal (1 subgoal):\n 1. (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)", "using le_less"], ["proof (prove)\nusing this:\n  l = Suc nat_\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)", "by fastforce"], ["proof (state)\nthis:\n  (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)\n\ngoal (1 subgoal):\n 1. l = 0 \\<Longrightarrow> (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)", "qed simp"], ["proof (state)\nthis:\n  (len (Suc 0) \\<le> l) = (Suc 0 < 2 ^ l)\n\ngoal (2 subgoals):\n 1. \\<And>l. (len 0 \\<le> l) = (0 < 2 ^ l)\n 2. \\<And>va l.\n       (\\<And>l.\n           (len (Suc (Suc va) div 2) \\<le> l) =\n           (Suc (Suc va) div 2 < 2 ^ l)) \\<Longrightarrow>\n       (len (Suc (Suc va)) \\<le> l) = (Suc (Suc va) < 2 ^ l)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l. (len 0 \\<le> l) = (0 < 2 ^ l)\n 2. \\<And>va l.\n       (\\<And>l.\n           (len (Suc (Suc va) div 2) \\<le> l) =\n           (Suc (Suc va) div 2 < 2 ^ l)) \\<Longrightarrow>\n       (len (Suc (Suc va)) \\<le> l) = (Suc (Suc va) < 2 ^ l)", "fix v l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l. (len 0 \\<le> l) = (0 < 2 ^ l)\n 2. \\<And>va l.\n       (\\<And>l.\n           (len (Suc (Suc va) div 2) \\<le> l) =\n           (Suc (Suc va) div 2 < 2 ^ l)) \\<Longrightarrow>\n       (len (Suc (Suc va)) \\<le> l) = (Suc (Suc va) < 2 ^ l)", "assume \"\\<And>l. (len (Suc (Suc v) div 2) \\<le> l) = (Suc (Suc v) div 2 < 2 ^ l)\""], ["proof (state)\nthis:\n  (len (Suc (Suc v) div 2) \\<le> ?l) = (Suc (Suc v) div 2 < 2 ^ ?l)\n\ngoal (2 subgoals):\n 1. \\<And>l. (len 0 \\<le> l) = (0 < 2 ^ l)\n 2. \\<And>va l.\n       (\\<And>l.\n           (len (Suc (Suc va) div 2) \\<le> l) =\n           (Suc (Suc va) div 2 < 2 ^ l)) \\<Longrightarrow>\n       (len (Suc (Suc va)) \\<le> l) = (Suc (Suc va) < 2 ^ l)", "then"], ["proof (chain)\npicking this:\n  (len (Suc (Suc v) div 2) \\<le> ?l) = (Suc (Suc v) div 2 < 2 ^ ?l)", "show \"(len (Suc (Suc v)) \\<le> l) = (Suc (Suc v) < 2 ^ l)\""], ["proof (prove)\nusing this:\n  (len (Suc (Suc v) div 2) \\<le> ?l) = (Suc (Suc v) div 2 < 2 ^ ?l)\n\ngoal (1 subgoal):\n 1. (len (Suc (Suc v)) \\<le> l) = (Suc (Suc v) < 2 ^ l)", "by (cases l) (simp_all, linarith)"], ["proof (state)\nthis:\n  (len (Suc (Suc v)) \\<le> l) = (Suc (Suc v) < 2 ^ l)\n\ngoal (1 subgoal):\n 1. \\<And>l. (len 0 \\<le> l) = (0 < 2 ^ l)", "qed simp"], ["", "lemma len_pow2[simp]: \"len (2 ^ x) = Suc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (2 ^ x) = Suc x", "by (induct x) auto"], ["", "lemma len_div2[simp]: \"len (x div 2) = len x - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (x div 2) = len x - 1", "by (induct x rule: len.induct) auto"], ["", "lemma less_pow2_len[simp]: \"x < 2 ^ len x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ len x", "by (induct x rule: len.induct) auto"], ["", "lemma len_alt: \"len x = (LEAST i. x < 2 ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len x = (LEAST i. x < 2 ^ i)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. len x \\<le> (LEAST i. x < 2 ^ i)\n 2. (LEAST i. x < 2 ^ i) \\<le> len x", "show \"len x \\<le> (LEAST i. x < 2 ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len x \\<le> (LEAST i. x < 2 ^ i)", "unfolding len_le_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ (LEAST i. x < 2 ^ i)", "by (rule LeastI) (rule less_pow2_len)"], ["proof (state)\nthis:\n  len x \\<le> (LEAST i. x < 2 ^ i)\n\ngoal (1 subgoal):\n 1. (LEAST i. x < 2 ^ i) \\<le> len x", "qed (auto intro: Least_le)"], ["", "lemma len_mono[simp]: \"x \\<le> y \\<Longrightarrow> len x \\<le> len y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> len x \\<le> len y", "unfolding len_le_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x < 2 ^ len y", "using less_pow2_len[of y]"], ["proof (prove)\nusing this:\n  y < 2 ^ len y\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x < 2 ^ len y", "by linarith"], ["", "lemma len_div_pow2[simp]: \"len (x div 2 ^ m) = len x - m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (x div 2 ^ m) = len x - m", "by (induct m arbitrary: x) (auto simp: div_mult2_eq)"], ["", "lemma len_mult_pow2[simp]: \"len (x * 2 ^ m) = (if x = 0 then 0 else len x + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (x * 2 ^ m) = (if x = 0 then 0 else len x + m)", "by (induct m arbitrary: x) (auto simp: div_mult2_eq mult.assoc[symmetric] mult.commute[of _ 2])"], ["", "lemma map_index'_Suc[simp]: \"map_index' (Suc i) f xs = map_index' i (\\<lambda>i. f (Suc i)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index' (Suc i) f xs = map_index' i (\\<lambda>i. f (Suc i)) xs", "by (induct xs arbitrary: i) auto"], ["", "abbreviation (input) \"zero n \\<equiv> replicate n False\""], ["", "abbreviation (input) \"SUC \\<equiv> \\<lambda>_::unit. Suc\""], ["", "definition \"test_bit m n \\<equiv> (m :: nat) div 2 ^ n mod 2 = 1\""], ["", "definition \"downshift m \\<equiv> (m :: nat) div 2\""], ["", "definition \"upshift m \\<equiv> (m :: nat) * 2\""], ["", "definition \"set_bit n m \\<equiv> m + (if \\<not> test_bit m n then 2 ^ n else (0 :: nat))\""], ["", "definition \"cut_bits n m \\<equiv> (m :: nat) mod 2 ^ n\""], ["", "typedef interp = \"{(n :: nat, xs :: nat list). \\<forall>x \\<in> set xs. len x \\<le> n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {(n, xs). \\<forall>x\\<in>set xs. len x \\<le> n}", "by (force intro: exI[of _ \"[]\"])"], ["", "setup_lifting type_definition_interp"], ["", "type_synonym atom = \"bool list\""], ["", "type_synonym \"value\" = \"nat\""], ["", "datatype presb = Eq (tm: \"int list\") (const: int) (offset: \"int\")"], ["", "derive linorder list"], ["", "derive linorder presb"], ["", "type_synonym formula = \"(presb, unit) aformula\""], ["", "lift_definition assigns :: \"nat \\<Rightarrow> interp \\<Rightarrow> unit \\<Rightarrow> value\" (\"_\\<^bsup>_\\<^esup>_\" [900, 999, 999] 999) is\n  \"\\<lambda>n (_, I) _. if n < length I then I ! n else 0\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition nvars :: \"interp \\<Rightarrow> nat\" (\"#\\<^sub>V _\" [1000] 900) is\n  \"\\<lambda>(_, I). length I\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition Length :: \"interp \\<Rightarrow> nat\" is \"\\<lambda>(n, _). n\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition Extend :: \"unit \\<Rightarrow> nat \\<Rightarrow> interp \\<Rightarrow> value \\<Rightarrow> interp\" is\n  \"\\<lambda>_ i (n, I) m. (max n (len m), insert_nth i m I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>unit nat1 prod nat2.\n       prod\n       \\<in> {(n, xs).\n              \\<forall>x\\<in>set xs. len x \\<le> n} \\<Longrightarrow>\n       (case prod of\n        (n, I) \\<Rightarrow>\n          \\<lambda>m. (max n (len m), insert_nth nat1 m I))\n        nat2\n       \\<in> {(n, xs). \\<forall>x\\<in>set xs. len x \\<le> n}", "by (force simp: max_def dest: in_set_takeD in_set_dropD)"], ["", "lift_definition CONS :: \"atom \\<Rightarrow> interp \\<Rightarrow> interp\" is\n  \"\\<lambda>bs (n, I). (Suc n, map_index (\\<lambda>i n. 2 * n + (if bs ! i then 1 else 0)) I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list prod.\n       prod\n       \\<in> {(n, xs).\n              \\<forall>x\\<in>set xs. len x \\<le> n} \\<Longrightarrow>\n       (case prod of\n        (n, I) \\<Rightarrow>\n          (Suc n,\n           map_index (\\<lambda>i n. 2 * n + (if list ! i then 1 else 0)) I))\n       \\<in> {(n, xs). \\<forall>x\\<in>set xs. len x \\<le> n}", "by (auto simp: set_zip)"], ["", "lift_definition SNOC :: \"atom \\<Rightarrow> interp \\<Rightarrow> interp\" is\n  \"\\<lambda>bs (n, I). (Suc n, map_index (\\<lambda>i m. m + (if bs ! i then 2 ^ n else 0)) I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list prod.\n       prod\n       \\<in> {(n, xs).\n              \\<forall>x\\<in>set xs. len x \\<le> n} \\<Longrightarrow>\n       (case prod of\n        (n, I) \\<Rightarrow>\n          (Suc n,\n           map_index (\\<lambda>i m. m + (if list ! i then 2 ^ n else 0)) I))\n       \\<in> {(n, xs). \\<forall>x\\<in>set xs. len x \\<le> n}", "by (auto simp: all_set_conv_all_nth len_le_iff)"], ["", "definition extend :: \"unit \\<Rightarrow> bool \\<Rightarrow> atom \\<Rightarrow> atom\" where\n  \"extend _ b bs \\<equiv> b # bs\""], ["", "abbreviation (input) size_atom :: \"atom \\<Rightarrow> nat\" where\n  \"size_atom \\<equiv> length\""], ["", "definition FV0 :: \"unit \\<Rightarrow> presb \\<Rightarrow> nat set\" where\n  \"FV0 _ fm = (case fm of Eq is _ _ \\<Rightarrow> {n. n < length is \\<and> is!n \\<noteq> 0})\""], ["", "lemma FV0_code[code]:\n  \"FV0 x (Eq is i off) = Option.these (set (map_index (\\<lambda>i x. if x = 0 then None else Some i) is))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FV0 x (presb.Eq is i off) =\n    Option.these\n     (set (map_index (\\<lambda>i x. if x = 0 then None else Some i) is))", "unfolding FV0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case presb.Eq is i off of\n     presb.Eq is x xa \\<Rightarrow>\n       {n. n < length is \\<and> is ! n \\<noteq> 0}) =\n    Option.these\n     (set (map_index (\\<lambda>i x. if x = 0 then None else Some i) is))", "by (force simp: Option.these_def image_iff)"], ["", "primrec wf0 :: \"nat \\<Rightarrow> presb \\<Rightarrow> bool\" where\n  \"wf0 idx (Eq is _ _) = (length is = idx)\""], ["", "fun find0 where\n  \"find0 (_::unit) n (Eq is _ _) = (is ! n \\<noteq> 0)\""], ["", "primrec decr0 where\n  \"decr0 (_::unit) k (Eq is i d) = Eq (take k is @ drop (Suc k) is) i d\""], ["", "definition scalar_product :: \"nat list \\<Rightarrow> int list \\<Rightarrow> int\" where\n  \"scalar_product ns is =\n     sum_list (map_index (\\<lambda>i b. (if i < length ns then ns ! i else 0) * b) is)\""], ["", "lift_definition eval_tm :: \"interp \\<Rightarrow> int list \\<Rightarrow> int\" is\n  \"\\<lambda>(_, I). scalar_product I\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "primrec satisfies0 where\n  \"satisfies0 I (Eq is i d) = (eval_tm I is = i - (2 ^ Length I) * d)\""], ["", "inductive lformula0 where\n  \"lformula0 (Eq is i 0)\""], ["", "code_pred lformula0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "fun lderiv0 :: \"bool list \\<Rightarrow> presb \\<Rightarrow> formula\" where\n  \"lderiv0 bs (Eq is i d) = (if d \\<noteq> 0 then undefined else\n  (let v = i - scalar_product bs is\n   in if v mod 2 = 0 then FBase (Eq is (v div 2) 0) else FBool False))\""], ["", "fun rderiv0 :: \"bool list \\<Rightarrow> presb \\<Rightarrow> formula\" where\n  \"rderiv0 bs (Eq is i d) =\n  (let\n     l = - sum_list [i. i \\<leftarrow> is, i < 0];\n     h = - sum_list [i. i \\<leftarrow> is, i > 0];\n     d' = scalar_product bs is + 2 * d\n   in if d' \\<in> {min h i .. max l i} then FBase (Eq is i d') else FBool False)\""], ["", "primrec nullable0 where\n  \"nullable0 (Eq is i off) = (i = off)\""], ["", "definition \\<sigma> :: \"nat \\<Rightarrow> atom list\" where\n  \"\\<sigma> n = List.n_lists n [True, False]\""], ["", "named_theorems Presb_simps"], ["", "lemma nvars_Extend[Presb_simps]: \"#\\<^sub>V (Extend () i \\<AA> P) = Suc (#\\<^sub>V \\<AA>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #\\<^sub>V (Extend () i \\<AA> P) = Suc (#\\<^sub>V \\<AA>)", "by (transfer, auto)"], ["", "lemma Length_Extend[Presb_simps]: \"Length (Extend () i \\<AA> P) = max (Length \\<AA>) (len P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length (Extend () i \\<AA> P) = max (Length \\<AA>) (len P)", "by (transfer, auto)"], ["", "lemma Length0_inj[Presb_simps]: \"Length \\<AA> = 0 \\<Longrightarrow> Length \\<BB> = 0 \\<Longrightarrow> #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB> \\<Longrightarrow> \\<AA> = \\<BB>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n     #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n    \\<Longrightarrow> \\<AA> = \\<BB>", "by transfer (auto intro: nth_equalityI simp: all_set_conv_all_nth len_eq0_iff)"], ["", "lemma ex_Length0[Presb_simps]: \"\\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx", "by (transfer fixing: idx) (auto intro: exI[of _ \"replicate idx 0\"])"], ["", "lemma Extend_commute_safe[Presb_simps]: \"\\<lbrakk>j \\<le> i; i < Suc (#\\<^sub>V \\<AA>)\\<rbrakk> \\<Longrightarrow>\n  Extend k j (Extend k i \\<AA> P) Q = Extend k (Suc i) (Extend k j \\<AA> Q) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<le> i; i < Suc (#\\<^sub>V \\<AA>)\\<rbrakk>\n    \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                      Extend k (Suc i) (Extend k j \\<AA> Q) P", "by transfer (auto simp add: min_def take_Cons take_drop le_imp_diff_is_add split: nat.splits)"], ["", "lemma Extend_commute_unsafe[Presb_simps]:\n  \"k \\<noteq> k' \\<Longrightarrow> Extend k j (Extend k' i \\<AA> P) Q = Extend k' i (Extend k j \\<AA> Q) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> k' \\<Longrightarrow>\n    Extend k j (Extend k' i \\<AA> P) Q = Extend k' i (Extend k j \\<AA> Q) P", "by transfer auto"], ["", "lemma assigns_Extend[Presb_simps]: \"i < Suc (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n  m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' = (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k else m\\<^bsup>\\<AA>\\<^esup>k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < Suc (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n    m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n    (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n     else m\\<^bsup>\\<AA>\\<^esup>k')", "by transfer (auto simp: nth_append dec_def min_def)"], ["", "lemma assigns_SNOC_zero[Presb_simps]: \"m < #\\<^sub>V \\<AA> \\<Longrightarrow> m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k = m\\<^bsup>\\<AA>\\<^esup>k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < #\\<^sub>V \\<AA> \\<Longrightarrow>\n    m\\<^bsup>SNOC (replicate (#\\<^sub>V \\<AA>) False) \\<AA>\\<^esup>k =\n    m\\<^bsup>\\<AA>\\<^esup>k", "by transfer auto"], ["", "lemma Length_CONS[Presb_simps]: \"Length (CONS x \\<AA>) = Suc (Length \\<AA>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length (CONS x \\<AA>) = Suc (Length \\<AA>)", "by transfer auto"], ["", "lemma Length_SNOC[Presb_simps]: \"Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)", "by transfer auto"], ["", "lemma nvars_CONS[Presb_simps]: \"#\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>", "by transfer auto"], ["", "lemma nvars_SNOC[Presb_simps]: \"#\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>", "by transfer auto"], ["", "lemma Extend_CONS[Presb_simps]: \"#\\<^sub>V \\<AA> = length x \\<Longrightarrow>\n  Extend k 0 (CONS x \\<AA>) P = CONS (extend k (test_bit P 0) x) (Extend k 0 \\<AA> (downshift P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #\\<^sub>V \\<AA> = length x \\<Longrightarrow>\n    Extend k 0 (CONS x \\<AA>) P =\n    CONS (extend k (test_bit P 0) x) (Extend k 0 \\<AA> (downshift P))", "by transfer (auto simp: extend_def downshift_def test_bit_def, presburger+)"], ["", "lemma Extend_SNOC[Presb_simps]: \"\\<lbrakk>#\\<^sub>V \\<AA> = length x; len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk> \\<Longrightarrow>\n  Extend k 0 (SNOC x \\<AA>) P =\n    SNOC (extend k (test_bit P (Length \\<AA>)) x) (Extend k 0 \\<AA> (cut_bits (Length \\<AA>) P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = length x;\n     len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n    \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                      SNOC (extend k (test_bit P (Length \\<AA>)) x)\n                       (Extend k 0 \\<AA> (cut_bits (Length \\<AA>) P))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<AA> x P k.\n       \\<lbrakk>\\<AA> \\<in> {(n, xs). \\<forall>x\\<in>set xs. len x \\<le> n};\n        (case \\<AA> of (uu_, x) \\<Rightarrow> length x) = length x;\n        len P\n        \\<le> (case case \\<AA> of\n                    (n, I) \\<Rightarrow>\n                      (Suc n,\n                       map_index\n                        (\\<lambda>i m. m + (if x ! i then 2 ^ n else 0))\n                        I) of\n               (n, uu_) \\<Rightarrow> n)\\<rbrakk>\n       \\<Longrightarrow> (case case \\<AA> of\n                               (n, I) \\<Rightarrow>\n                                 (Suc n,\n                                  map_index\n                                   (\\<lambda>i m.\n m + (if x ! i then 2 ^ n else 0))\n                                   I) of\n                          (n, I) \\<Rightarrow>\n                            \\<lambda>m. (max n (len m), insert_nth 0 m I))\n                          P =\n                         (case (case \\<AA> of\n                                (n, I) \\<Rightarrow>\n                                  \\<lambda>m.\n                                     (max n (len m), insert_nth 0 m I))\n                                (cut_bits\n                                  (case \\<AA> of (n, uu_) \\<Rightarrow> n)\n                                  P) of\n                          (n, I) \\<Rightarrow>\n                            (Suc n,\n                             map_index\n                              (\\<lambda>i m.\n                                  m +\n                                  (if extend k\n (test_bit P (case \\<AA> of (n, uu_) \\<Rightarrow> n)) x !\ni\n                                   then 2 ^ n else 0))\n                              I))", "apply (auto simp: cut_bits_def extend_def test_bit_def nth_Cons' max_absorb1 len_le_iff\n    split: if_splits cong del: if_weak_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x P.\n       \\<lbrakk>\\<forall>x\\<in>set b. x < 2 ^ a; length b = length x;\n        P < 2 * 2 ^ a; P div 2 ^ a mod 2 = Suc 0\\<rbrakk>\n       \\<Longrightarrow> P = P mod 2 ^ a + 2 ^ a\n 2. \\<And>a b x P.\n       \\<lbrakk>\\<forall>x\\<in>set b. x < 2 ^ a; length b = length x;\n        P < 2 * 2 ^ a; even (P div 2 ^ a)\\<rbrakk>\n       \\<Longrightarrow> P = P mod 2 ^ a", "apply (metis add.commute mod_less mod_mult2_eq mult_numeral_1_right numeral_1_eq_Suc_0 power_commuting_commutes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x P.\n       \\<lbrakk>\\<forall>x\\<in>set b. x < 2 ^ a; length b = length x;\n        P < 2 * 2 ^ a; even (P div 2 ^ a)\\<rbrakk>\n       \\<Longrightarrow> P = P mod 2 ^ a", "apply (metis Euclidean_Division.div_eq_0_iff div_0 less_mult_imp_div_less mod_less nat_dvd_not_less semiring_normalization_rules(7))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma odd_neq_even:\n  \"Suc (2 * x) = 2 * y \\<longleftrightarrow> False\"\n  \"2 * y = Suc (2 * x) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc (2 * x) = 2 * y) = False &&& (2 * y = Suc (2 * x)) = False", "by presburger+"], ["", "lemma CONS_inj[Presb_simps]: \"size x = #\\<^sub>V \\<AA> \\<Longrightarrow> size y = #\\<^sub>V \\<AA> \\<Longrightarrow> #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB> \\<Longrightarrow>\n  CONS x \\<AA> = CONS y \\<BB> \\<longleftrightarrow> (x = y \\<and> \\<AA> = \\<BB>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length x = #\\<^sub>V \\<AA>; length y = #\\<^sub>V \\<AA>;\n     #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n    \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                      (x = y \\<and> \\<AA> = \\<BB>)", "by transfer (auto simp: list_eq_iff_nth_eq odd_neq_even split: if_splits)"], ["", "lemma mod_2_Suc_iff:\n  \"x mod 2 = Suc 0 \\<longleftrightarrow> x = Suc (2 * (x div 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x mod 2 = Suc 0) = (x = Suc (2 * (x div 2)))", "by presburger+"], ["", "lemma CONS_surj[Presb_simps]: \"Length \\<AA> \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>x \\<BB>. \\<AA> = CONS x \\<BB> \\<and> #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and> size x = #\\<^sub>V \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length \\<AA> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>x \\<BB>.\n       \\<AA> = CONS x \\<BB> \\<and>\n       #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and> length x = #\\<^sub>V \\<AA>", "by transfer\n    (auto simp: gr0_conv_Suc list_eq_iff_nth_eq len_le_iff split: if_splits\n    intro!: exI[of _ \"map (\\<lambda>n. n mod 2 \\<noteq> 0) _\"] exI[of _ \"map (\\<lambda>n. n div 2) _\"];\n    auto simp: mod_2_Suc_iff)"], ["", "lemma [Presb_simps]: \n  \"length (extend k b x) = Suc (length x)\"\n  \"downshift (upshift P) = P\"\n  \"downshift (set_bit 0 P) = downshift P\"\n  \"test_bit (set_bit n P) n\"\n  \"\\<not> test_bit (upshift P) 0\"\n  \"len P \\<le> p \\<Longrightarrow> \\<not> test_bit P p\"\n  \"len (cut_bits n P) \\<le> n\"\n  \"len P \\<le> n \\<Longrightarrow> cut_bits n P = P\"\n  \"len (upshift P) = (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> Suc (Suc n))\"\n  \"len (downshift P) = (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((length (extend k b x) = Suc (length x) &&&\n      downshift (upshift P) = P) &&&\n     downshift (set_bit 0 P) = downshift P &&&\n     test_bit (set_bit n P) n &&& \\<not> test_bit (upshift P) 0) &&&\n    ((len P \\<le> p \\<Longrightarrow> \\<not> test_bit P p) &&&\n     len (cut_bits n P) \\<le> n) &&&\n    (len P \\<le> n \\<Longrightarrow> cut_bits n P = P) &&&\n    len (upshift P) =\n    (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> Suc (Suc n)) &&&\n    len (downshift P) =\n    (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)", "by (auto simp: extend_def set_bit_def cut_bits_def upshift_def downshift_def test_bit_def\n    len_le_iff len_eq0_iff div_add_self2 split: nat.split)"], ["", "lemma Suc0_div_pow2_eq: \"Suc 0 div 2 ^ i = (if i = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 div 2 ^ i = (if i = 0 then 1 else 0)", "by (induct i) (auto simp: div_mult2_eq)"], ["", "lemma set_unset_bit_preserves_len:\n  assumes \"x div 2 ^ m = 2 * q\" \"m < len x\"\n  shows \"x + 2 ^ m < 2 ^ len x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 2 ^ m < 2 ^ len x", "using assms"], ["proof (prove)\nusing this:\n  x div 2 ^ m = 2 * q\n  m < len x\n\ngoal (1 subgoal):\n 1. x + 2 ^ m < 2 ^ len x", "proof (induct m arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x div 2 ^ 0 = 2 * q; 0 < len x\\<rbrakk>\n       \\<Longrightarrow> x + 2 ^ 0 < 2 ^ len x\n 2. \\<And>m x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x div 2 ^ m = 2 * q; m < len x\\<rbrakk>\n                   \\<Longrightarrow> x + 2 ^ m < 2 ^ len x;\n        x div 2 ^ Suc m = 2 * q; Suc m < len x\\<rbrakk>\n       \\<Longrightarrow> x + 2 ^ Suc m < 2 ^ len x", "case 0"], ["proof (state)\nthis:\n  x div 2 ^ 0 = 2 * q\n  0 < len x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x div 2 ^ 0 = 2 * q; 0 < len x\\<rbrakk>\n       \\<Longrightarrow> x + 2 ^ 0 < 2 ^ len x\n 2. \\<And>m x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x div 2 ^ m = 2 * q; m < len x\\<rbrakk>\n                   \\<Longrightarrow> x + 2 ^ m < 2 ^ len x;\n        x div 2 ^ Suc m = 2 * q; Suc m < len x\\<rbrakk>\n       \\<Longrightarrow> x + 2 ^ Suc m < 2 ^ len x", "then"], ["proof (chain)\npicking this:\n  x div 2 ^ 0 = 2 * q\n  0 < len x", "show ?case"], ["proof (prove)\nusing this:\n  x div 2 ^ 0 = 2 * q\n  0 < len x\n\ngoal (1 subgoal):\n 1. x + 2 ^ 0 < 2 ^ len x", "by (auto simp: div_mult2_eq len_Suc_mult2[symmetric]\n      simp del: len_Suc_mult2 power_Suc split: if_splits)"], ["proof (state)\nthis:\n  x + 2 ^ 0 < 2 ^ len x\n\ngoal (1 subgoal):\n 1. \\<And>m x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x div 2 ^ m = 2 * q; m < len x\\<rbrakk>\n                   \\<Longrightarrow> x + 2 ^ m < 2 ^ len x;\n        x div 2 ^ Suc m = 2 * q; Suc m < len x\\<rbrakk>\n       \\<Longrightarrow> x + 2 ^ Suc m < 2 ^ len x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x div 2 ^ m = 2 * q; m < len x\\<rbrakk>\n                   \\<Longrightarrow> x + 2 ^ m < 2 ^ len x;\n        x div 2 ^ Suc m = 2 * q; Suc m < len x\\<rbrakk>\n       \\<Longrightarrow> x + 2 ^ Suc m < 2 ^ len x", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>?x div 2 ^ m = 2 * q; m < len ?x\\<rbrakk>\n  \\<Longrightarrow> ?x + 2 ^ m < 2 ^ len ?x\n  x div 2 ^ Suc m = 2 * q\n  Suc m < len x\n\ngoal (1 subgoal):\n 1. \\<And>m x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x div 2 ^ m = 2 * q; m < len x\\<rbrakk>\n                   \\<Longrightarrow> x + 2 ^ m < 2 ^ len x;\n        x div 2 ^ Suc m = 2 * q; Suc m < len x\\<rbrakk>\n       \\<Longrightarrow> x + 2 ^ Suc m < 2 ^ len x", "with Suc(1)[of \"x div 2\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>x div 2 div 2 ^ m = 2 * q; m < len (x div 2)\\<rbrakk>\n  \\<Longrightarrow> x div 2 + 2 ^ m < 2 ^ len (x div 2)\n  \\<lbrakk>?x div 2 ^ m = 2 * q; m < len ?x\\<rbrakk>\n  \\<Longrightarrow> ?x + 2 ^ m < 2 ^ len ?x\n  x div 2 ^ Suc m = 2 * q\n  Suc m < len x", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x div 2 div 2 ^ m = 2 * q; m < len (x div 2)\\<rbrakk>\n  \\<Longrightarrow> x div 2 + 2 ^ m < 2 ^ len (x div 2)\n  \\<lbrakk>?x div 2 ^ m = 2 * q; m < len ?x\\<rbrakk>\n  \\<Longrightarrow> ?x + 2 ^ m < 2 ^ len ?x\n  x div 2 ^ Suc m = 2 * q\n  Suc m < len x\n\ngoal (1 subgoal):\n 1. x + 2 ^ Suc m < 2 ^ len x", "by (cases \"len x\") (auto simp: div_mult2_eq)"], ["proof (state)\nthis:\n  x + 2 ^ Suc m < 2 ^ len x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma len_set_bit[Presb_simps]: \"len (set_bit m P) = max (Suc m) (len P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (set_bit m P) = max (Suc m) (len P)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. len (set_bit m P) \\<le> max (Suc m) (len P)\n 2. max (Suc m) (len P) \\<le> len (set_bit m P)", "show \"len (set_bit m P) \\<le> max (Suc m) (len P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (set_bit m P) \\<le> max (Suc m) (len P)", "by (auto simp: set_bit_def test_bit_def max_def Suc_le_eq not_less len_le_iff\n      set_unset_bit_preserves_len simp del: One_nat_def)"], ["proof (state)\nthis:\n  len (set_bit m P) \\<le> max (Suc m) (len P)\n\ngoal (1 subgoal):\n 1. max (Suc m) (len P) \\<le> len (set_bit m P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. max (Suc m) (len P) \\<le> len (set_bit m P)", "have \"P < 2 ^ len (P + 2 ^ m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P < 2 ^ len (P + 2 ^ m)", "by (rule order.strict_trans2[OF less_pow2_len]) auto"], ["proof (state)\nthis:\n  P < 2 ^ len (P + 2 ^ m)\n\ngoal (1 subgoal):\n 1. max (Suc m) (len P) \\<le> len (set_bit m P)", "moreover"], ["proof (state)\nthis:\n  P < 2 ^ len (P + 2 ^ m)\n\ngoal (1 subgoal):\n 1. max (Suc m) (len P) \\<le> len (set_bit m P)", "have \"m < len (P + 2 ^ m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < len (P + 2 ^ m)", "by (rule order.strict_trans2[OF _ len_mono[of \"2 ^ m\"]]) auto"], ["proof (state)\nthis:\n  m < len (P + 2 ^ m)\n\ngoal (1 subgoal):\n 1. max (Suc m) (len P) \\<le> len (set_bit m P)", "ultimately"], ["proof (chain)\npicking this:\n  P < 2 ^ len (P + 2 ^ m)\n  m < len (P + 2 ^ m)", "show \"max (Suc m) (len P) \\<le> len (set_bit m P)\""], ["proof (prove)\nusing this:\n  P < 2 ^ len (P + 2 ^ m)\n  m < len (P + 2 ^ m)\n\ngoal (1 subgoal):\n 1. max (Suc m) (len P) \\<le> len (set_bit m P)", "by (auto simp: set_bit_def test_bit_def max_def Suc_le_eq not_less len_le_iff)"], ["proof (state)\nthis:\n  max (Suc m) (len P) \\<le> len (set_bit m P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_pow2_div_pow2:\n  fixes p m n :: nat\n  shows \"m < n \\<Longrightarrow> p mod 2 ^ n div 2 ^ m = p div 2 ^ m mod 2 ^ (n - m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow>\n    p mod 2 ^ n div 2 ^ m = p div 2 ^ m mod 2 ^ (n - m)", "by (induct m arbitrary: p n) (auto simp: div_mult2_eq mod_mult2_eq Suc_less_eq2)"], ["", "lemma irrelevant_set_bit[simp]:\n  fixes p m n :: nat\n  assumes \"n \\<le> m\"\n  shows \"(p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n", "from assms"], ["proof (chain)\npicking this:\n  n \\<le> m", "obtain q :: nat where \"2 ^ m = q * 2 ^ n\""], ["proof (prove)\nusing this:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. (\\<And>q. 2 ^ m = q * 2 ^ n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis le_add_diff_inverse mult.commute power_add)"], ["proof (state)\nthis:\n  2 ^ m = q * 2 ^ n\n\ngoal (1 subgoal):\n 1. (p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n", "then"], ["proof (chain)\npicking this:\n  2 ^ m = q * 2 ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ m = q * 2 ^ n\n\ngoal (1 subgoal):\n 1. (p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n", "by simp"], ["proof (state)\nthis:\n  (p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mod_lemma: \"\\<lbrakk> (0::nat) < c; r < b \\<rbrakk> \\<Longrightarrow> b * (q mod c) + r < b * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < c; r < b\\<rbrakk>\n    \\<Longrightarrow> b * (q mod c) + r < b * c", "by (metis add_gr_0 div_le_mono div_mult_self1_is_m less_imp_add_positive mod_less_divisor not_less split_div)"], ["", "lemma relevant_set_bit[simp]:\n  fixes p m n :: nat\n  assumes \"m < n\" \"p div 2 ^ m = 2 * q\"\n  shows \"(p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n + 2 ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n + 2 ^ m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n + 2 ^ m", "have \"p mod 2 ^ n + 2 ^ m < 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p mod 2 ^ n + 2 ^ m < 2 ^ n", "using assms"], ["proof (prove)\nusing this:\n  m < n\n  p div 2 ^ m = 2 * q\n\ngoal (1 subgoal):\n 1. p mod 2 ^ n + 2 ^ m < 2 ^ n", "proof (induct m arbitrary: p n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p n.\n       \\<lbrakk>0 < n; p div 2 ^ 0 = 2 * q\\<rbrakk>\n       \\<Longrightarrow> p mod 2 ^ n + 2 ^ 0 < 2 ^ n\n 2. \\<And>m p n.\n       \\<lbrakk>\\<And>p n.\n                   \\<lbrakk>m < n; p div 2 ^ m = 2 * q\\<rbrakk>\n                   \\<Longrightarrow> p mod 2 ^ n + 2 ^ m < 2 ^ n;\n        Suc m < n; p div 2 ^ Suc m = 2 * q\\<rbrakk>\n       \\<Longrightarrow> p mod 2 ^ n + 2 ^ Suc m < 2 ^ n", "case 0"], ["proof (state)\nthis:\n  0 < n\n  p div 2 ^ 0 = 2 * q\n\ngoal (2 subgoals):\n 1. \\<And>p n.\n       \\<lbrakk>0 < n; p div 2 ^ 0 = 2 * q\\<rbrakk>\n       \\<Longrightarrow> p mod 2 ^ n + 2 ^ 0 < 2 ^ n\n 2. \\<And>m p n.\n       \\<lbrakk>\\<And>p n.\n                   \\<lbrakk>m < n; p div 2 ^ m = 2 * q\\<rbrakk>\n                   \\<Longrightarrow> p mod 2 ^ n + 2 ^ m < 2 ^ n;\n        Suc m < n; p div 2 ^ Suc m = 2 * q\\<rbrakk>\n       \\<Longrightarrow> p mod 2 ^ n + 2 ^ Suc m < 2 ^ n", "then"], ["proof (chain)\npicking this:\n  0 < n\n  p div 2 ^ 0 = 2 * q", "show ?case"], ["proof (prove)\nusing this:\n  0 < n\n  p div 2 ^ 0 = 2 * q\n\ngoal (1 subgoal):\n 1. p mod 2 ^ n + 2 ^ 0 < 2 ^ n", "by (auto simp: gr0_conv_Suc)\n         (metis One_nat_def Suc_eq_plus1 lessI mod_lemma numeral_2_eq_2 zero_less_numeral zero_less_power)"], ["proof (state)\nthis:\n  p mod 2 ^ n + 2 ^ 0 < 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<And>m p n.\n       \\<lbrakk>\\<And>p n.\n                   \\<lbrakk>m < n; p div 2 ^ m = 2 * q\\<rbrakk>\n                   \\<Longrightarrow> p mod 2 ^ n + 2 ^ m < 2 ^ n;\n        Suc m < n; p div 2 ^ Suc m = 2 * q\\<rbrakk>\n       \\<Longrightarrow> p mod 2 ^ n + 2 ^ Suc m < 2 ^ n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m p n.\n       \\<lbrakk>\\<And>p n.\n                   \\<lbrakk>m < n; p div 2 ^ m = 2 * q\\<rbrakk>\n                   \\<Longrightarrow> p mod 2 ^ n + 2 ^ m < 2 ^ n;\n        Suc m < n; p div 2 ^ Suc m = 2 * q\\<rbrakk>\n       \\<Longrightarrow> p mod 2 ^ n + 2 ^ Suc m < 2 ^ n", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>m < ?n; ?p div 2 ^ m = 2 * q\\<rbrakk>\n  \\<Longrightarrow> ?p mod 2 ^ ?n + 2 ^ m < 2 ^ ?n\n  Suc m < n\n  p div 2 ^ Suc m = 2 * q\n\ngoal (1 subgoal):\n 1. \\<And>m p n.\n       \\<lbrakk>\\<And>p n.\n                   \\<lbrakk>m < n; p div 2 ^ m = 2 * q\\<rbrakk>\n                   \\<Longrightarrow> p mod 2 ^ n + 2 ^ m < 2 ^ n;\n        Suc m < n; p div 2 ^ Suc m = 2 * q\\<rbrakk>\n       \\<Longrightarrow> p mod 2 ^ n + 2 ^ Suc m < 2 ^ n", "from Suc(1)[of \"n - 1\" \"p div 2\"] Suc(2,3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>m < n - 1; p div 2 div 2 ^ m = 2 * q\\<rbrakk>\n  \\<Longrightarrow> p div 2 mod 2 ^ (n - 1) + 2 ^ m < 2 ^ (n - 1)\n  Suc m < n\n  p div 2 ^ Suc m = 2 * q", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>m < n - 1; p div 2 div 2 ^ m = 2 * q\\<rbrakk>\n  \\<Longrightarrow> p div 2 mod 2 ^ (n - 1) + 2 ^ m < 2 ^ (n - 1)\n  Suc m < n\n  p div 2 ^ Suc m = 2 * q\n\ngoal (1 subgoal):\n 1. p mod 2 ^ n + 2 ^ Suc m < 2 ^ n", "by (auto simp: div_mult2_eq mod_mult2_eq Suc_less_eq2)"], ["proof (state)\nthis:\n  p mod 2 ^ n + 2 ^ Suc m < 2 ^ n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p mod 2 ^ n + 2 ^ m < 2 ^ n\n\ngoal (1 subgoal):\n 1. (p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n + 2 ^ m", "with \\<open>m < n\\<close>"], ["proof (chain)\npicking this:\n  m < n\n  p mod 2 ^ n + 2 ^ m < 2 ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  m < n\n  p mod 2 ^ n + 2 ^ m < 2 ^ n\n\ngoal (1 subgoal):\n 1. (p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n + 2 ^ m", "by (subst mod_add_eq [symmetric]) auto"], ["proof (state)\nthis:\n  (p + 2 ^ m) mod 2 ^ n = p mod 2 ^ n + 2 ^ m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cut_bits_set_bit[Presb_simps]: \"cut_bits n (set_bit m p) =\n  (if n \\<le> m then cut_bits n p else set_bit m (cut_bits n p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cut_bits n (set_bit m p) =\n    (if n \\<le> m then cut_bits n p else set_bit m (cut_bits n p))", "unfolding cut_bits_def set_bit_def test_bit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p + (if p div 2 ^ m mod 2 \\<noteq> 1 then 2 ^ m else 0)) mod 2 ^ n =\n    (if n \\<le> m then p mod 2 ^ n\n     else p mod 2 ^ n +\n          (if p mod 2 ^ n div 2 ^ m mod 2 \\<noteq> 1 then 2 ^ m else 0))", "by (auto simp: not_le mod_pow2_div_pow2 mod_mod_cancel simp del: One_nat_def)"], ["", "lemma wf0_decr0[Presb_simps]:\n  \"wf0 (Suc idx) a \\<Longrightarrow> l < Suc idx \\<Longrightarrow> \\<not> find0 k l a \\<Longrightarrow> wf0 idx (decr0 k l a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf0 (Suc idx) a; l < Suc idx; \\<not> find0 k l a\\<rbrakk>\n    \\<Longrightarrow> wf0 idx (decr0 k l a)", "by (induct a) auto"], ["", "lemma lformula0_decr0[Presb_simps]: \"lformula0 a \\<Longrightarrow> lformula0 (decr0 k l a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula0 a \\<Longrightarrow> lformula0 (decr0 k l a)", "by (induct a) (auto elim: lformula0.cases intro: lformula0.intros)"], ["", "abbreviation sat0_syn (infix \"\\<Turnstile>0\" 65) where\n \"sat0_syn \\<equiv> satisfies0\""], ["", "abbreviation sat_syn (infix \"\\<Turnstile>\" 65) where\n \"sat_syn \\<equiv> Formula_Operations.satisfies Extend Length satisfies0\""], ["", "abbreviation sat_bounded_syn (infix \"\\<Turnstile>\\<^sub>b\" 65) where\n \"sat_bounded_syn \\<equiv> Formula_Operations.satisfies_bounded Extend Length len satisfies0\""], ["", "lemma scalar_product_Nil[simp]: \"scalar_product [] xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_product [] xs = 0", "by (induct xs) (auto simp: scalar_product_def)"], ["", "lemma scalar_product_Nil2[simp]: \"scalar_product xs [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_product xs [] = 0", "by (induct xs) (auto simp: scalar_product_def)"], ["", "lemma scalar_product_Cons[simp]:\n  \"scalar_product xs (y # ys) = (case xs of x # xs \\<Rightarrow> x * y + scalar_product xs ys | [] \\<Rightarrow> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_product xs (y # ys) =\n    (case xs of [] \\<Rightarrow> 0\n     | x # xs \\<Rightarrow> int x * y + scalar_product xs ys)", "by (cases xs) (simp, auto simp: scalar_product_def cong del: if_weak_cong)"], ["", "lemma scalar_product_append[simp]: \"scalar_product ns (xs @ ys) =\n  scalar_product (take (length xs) ns) xs + scalar_product (drop (length xs) ns) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_product ns (xs @ ys) =\n    scalar_product (take (length xs) ns) xs +\n    scalar_product (drop (length xs) ns) ys", "by (induct xs arbitrary: ns) (auto split: list.splits)"], ["", "lemma scalar_product_trim: \"scalar_product ns xs = scalar_product (take (length xs) ns) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_product ns xs = scalar_product (take (length xs) ns) xs", "by (induct xs arbitrary: ns) (auto split: list.splits)"], ["", "lemma Extend_satisfies0_decr0[Presb_simps]:\n  assumes \"\\<not> find0 k i a\" \"i < Suc (#\\<^sub>V \\<AA>)\" \"lformula0 a \\<or> len P \\<le> Length \\<AA>\"\n  shows \"Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a", "fix \"is\" :: \"int list\""], ["proof (state)\ngoal (1 subgoal):\n 1. Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a", "assume \"is ! i = 0\""], ["proof (state)\nthis:\n  is ! i = 0\n\ngoal (1 subgoal):\n 1. Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a", "with assms(1,2)"], ["proof (chain)\npicking this:\n  \\<not> find0 k i a\n  i < Suc (#\\<^sub>V \\<AA>)\n  is ! i = 0", "have \"eval_tm (Extend k i \\<AA> P) is = eval_tm \\<AA> (take i is @ drop (Suc i) is)\""], ["proof (prove)\nusing this:\n  \\<not> find0 k i a\n  i < Suc (#\\<^sub>V \\<AA>)\n  is ! i = 0\n\ngoal (1 subgoal):\n 1. eval_tm (Extend k i \\<AA> P) is =\n    eval_tm \\<AA> (take i is @ drop (Suc i) is)", "by (cases a, transfer)\n         (force intro: trans[OF scalar_product_trim] simp: min_def\n         arg_cong2[OF refl id_take_nth_drop, of i _ scalar_product \"take i xs @ _\" for i x xs])"], ["proof (state)\nthis:\n  eval_tm (Extend k i \\<AA> P) is =\n  eval_tm \\<AA> (take i is @ drop (Suc i) is)\n\ngoal (1 subgoal):\n 1. Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a", "}"], ["proof (state)\nthis:\n  ?is2 ! i = 0 \\<Longrightarrow>\n  eval_tm (Extend k i \\<AA> P) ?is2 =\n  eval_tm \\<AA> (take i ?is2 @ drop (Suc i) ?is2)\n\ngoal (1 subgoal):\n 1. Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a", "note * = this"], ["proof (state)\nthis:\n  ?is2 ! i = 0 \\<Longrightarrow>\n  eval_tm (Extend k i \\<AA> P) ?is2 =\n  eval_tm \\<AA> (take i ?is2 @ drop (Suc i) ?is2)\n\ngoal (1 subgoal):\n 1. Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a", "from assms"], ["proof (chain)\npicking this:\n  \\<not> find0 k i a\n  i < Suc (#\\<^sub>V \\<AA>)\n  lformula0 a \\<or> len P \\<le> Length \\<AA>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> find0 k i a\n  i < Suc (#\\<^sub>V \\<AA>)\n  lformula0 a \\<or> len P \\<le> Length \\<AA>\n\ngoal (1 subgoal):\n 1. Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a", "by (cases a) (auto dest!: * simp: Length_Extend max_def elim: lformula0.cases)"], ["proof (state)\nthis:\n  Extend k i \\<AA> P \\<Turnstile>0 a = \\<AA> \\<Turnstile>0 decr0 k i a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scalar_product_eq0: \"\\<forall>c\\<in>set ns. c = 0 \\<Longrightarrow> scalar_product ns is = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set ns. c = 0 \\<Longrightarrow> scalar_product ns is = 0", "proof (induct \"is\" arbitrary: \"ns\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ns.\n       \\<forall>c\\<in>set ns. c = 0 \\<Longrightarrow>\n       scalar_product ns [] = 0\n 2. \\<And>a is ns.\n       \\<lbrakk>\\<And>ns.\n                   \\<forall>c\\<in>set ns. c = 0 \\<Longrightarrow>\n                   scalar_product ns is = 0;\n        \\<forall>c\\<in>set ns. c = 0\\<rbrakk>\n       \\<Longrightarrow> scalar_product ns (a # is) = 0", "case Cons"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set ?ns. c = 0 \\<Longrightarrow> scalar_product ?ns is_ = 0\n  \\<forall>c\\<in>set ns. c = 0\n\ngoal (2 subgoals):\n 1. \\<And>ns.\n       \\<forall>c\\<in>set ns. c = 0 \\<Longrightarrow>\n       scalar_product ns [] = 0\n 2. \\<And>a is ns.\n       \\<lbrakk>\\<And>ns.\n                   \\<forall>c\\<in>set ns. c = 0 \\<Longrightarrow>\n                   scalar_product ns is = 0;\n        \\<forall>c\\<in>set ns. c = 0\\<rbrakk>\n       \\<Longrightarrow> scalar_product ns (a # is) = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>set ?ns. c = 0 \\<Longrightarrow> scalar_product ?ns is_ = 0\n  \\<forall>c\\<in>set ns. c = 0", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set ?ns. c = 0 \\<Longrightarrow> scalar_product ?ns is_ = 0\n  \\<forall>c\\<in>set ns. c = 0\n\ngoal (1 subgoal):\n 1. scalar_product ns (a_ # is_) = 0", "by (cases ns) (auto simp: scalar_product_def cong del: if_weak_cong)"], ["proof (state)\nthis:\n  scalar_product ns (a_ # is_) = 0\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       \\<forall>c\\<in>set ns. c = 0 \\<Longrightarrow>\n       scalar_product ns [] = 0", "qed (simp add: scalar_product_def)"], ["", "lemma nullable0_satisfies0[Presb_simps]: \"Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = \\<AA> \\<Turnstile>0 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = \\<AA> \\<Turnstile>0 a", "proof (induct a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a.\n       Length \\<AA> = 0 \\<Longrightarrow>\n       nullable0 (presb.Eq x1a x2a x3a) =\n       \\<AA> \\<Turnstile>0 presb.Eq x1a x2a x3a", "case Eq"], ["proof (state)\nthis:\n  Length \\<AA> = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a.\n       Length \\<AA> = 0 \\<Longrightarrow>\n       nullable0 (presb.Eq x1a x2a x3a) =\n       \\<AA> \\<Turnstile>0 presb.Eq x1a x2a x3a", "then"], ["proof (chain)\npicking this:\n  Length \\<AA> = 0", "show ?case"], ["proof (prove)\nusing this:\n  Length \\<AA> = 0\n\ngoal (1 subgoal):\n 1. nullable0 (presb.Eq x1a_ x2a_ x3a_) =\n    \\<AA> \\<Turnstile>0 presb.Eq x1a_ x2a_ x3a_", "unfolding nullable0.simps satisfies0.simps"], ["proof (prove)\nusing this:\n  Length \\<AA> = 0\n\ngoal (1 subgoal):\n 1. (x2a_ = x3a_) = (eval_tm \\<AA> x1a_ = x2a_ - 2 ^ Length \\<AA> * x3a_)", "by transfer (auto simp: len_eq0_iff scalar_product_eq0)"], ["proof (state)\nthis:\n  nullable0 (presb.Eq x1a_ x2a_ x3a_) =\n  \\<AA> \\<Turnstile>0 presb.Eq x1a_ x2a_ x3a_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma satisfies0_cong: \"wf0 (#\\<^sub>V \\<BB>) a \\<Longrightarrow> #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB> \\<Longrightarrow> lformula0 a \\<Longrightarrow>\n  (\\<And>m k. m < #\\<^sub>V \\<BB> \\<Longrightarrow> m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k) \\<Longrightarrow> \\<AA> \\<Turnstile>0 a = \\<BB> \\<Turnstile>0 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n     lformula0 a;\n     \\<And>m k.\n        m < #\\<^sub>V \\<BB> \\<Longrightarrow>\n        m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n    \\<Longrightarrow> \\<AA> \\<Turnstile>0 a = \\<BB> \\<Turnstile>0 a", "proof (induct a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) (presb.Eq x1a x2a x3a);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>; lformula0 (presb.Eq x1a x2a x3a);\n        \\<And>m k.\n           m < #\\<^sub>V \\<BB> \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n       \\<Longrightarrow> \\<AA> \\<Turnstile>0 presb.Eq x1a x2a x3a =\n                         \\<BB> \\<Turnstile>0 presb.Eq x1a x2a x3a", "case Eq"], ["proof (state)\nthis:\n  wf0 (#\\<^sub>V \\<BB>) (presb.Eq x1a_ x2a_ x3a_)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  lformula0 (presb.Eq x1a_ x2a_ x3a_)\n  ?m < #\\<^sub>V \\<BB> \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) (presb.Eq x1a x2a x3a);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>; lformula0 (presb.Eq x1a x2a x3a);\n        \\<And>m k.\n           m < #\\<^sub>V \\<BB> \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n       \\<Longrightarrow> \\<AA> \\<Turnstile>0 presb.Eq x1a x2a x3a =\n                         \\<BB> \\<Turnstile>0 presb.Eq x1a x2a x3a", "then"], ["proof (chain)\npicking this:\n  wf0 (#\\<^sub>V \\<BB>) (presb.Eq x1a_ x2a_ x3a_)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  lformula0 (presb.Eq x1a_ x2a_ x3a_)\n  ?m < #\\<^sub>V \\<BB> \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k", "show ?case"], ["proof (prove)\nusing this:\n  wf0 (#\\<^sub>V \\<BB>) (presb.Eq x1a_ x2a_ x3a_)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  lformula0 (presb.Eq x1a_ x2a_ x3a_)\n  ?m < #\\<^sub>V \\<BB> \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n\ngoal (1 subgoal):\n 1. \\<AA> \\<Turnstile>0 presb.Eq x1a_ x2a_ x3a_ =\n    \\<BB> \\<Turnstile>0 presb.Eq x1a_ x2a_ x3a_", "unfolding satisfies0.simps"], ["proof (prove)\nusing this:\n  wf0 (#\\<^sub>V \\<BB>) (presb.Eq x1a_ x2a_ x3a_)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  lformula0 (presb.Eq x1a_ x2a_ x3a_)\n  ?m < #\\<^sub>V \\<BB> \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n\ngoal (1 subgoal):\n 1. (eval_tm \\<AA> x1a_ = x2a_ - 2 ^ Length \\<AA> * x3a_) =\n    (eval_tm \\<BB> x1a_ = x2a_ - 2 ^ Length \\<BB> * x3a_)", "by transfer (auto simp: scalar_product_def\n      intro!: arg_cong[of _ _ sum_list] map_index_cong elim!: lformula0.cases)"], ["proof (state)\nthis:\n  \\<AA> \\<Turnstile>0 presb.Eq x1a_ x2a_ x3a_ =\n  \\<BB> \\<Turnstile>0 presb.Eq x1a_ x2a_ x3a_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_lderiv0[Presb_simps]:\n  \"wf0 idx a \\<Longrightarrow> lformula0 a \\<Longrightarrow> Formula_Operations.wf (\\<lambda>_. Suc) wf0 idx (lderiv0 x a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n    \\<Longrightarrow> Formula_Operations.wf (\\<lambda>_. Suc) wf0 idx\n                       (lderiv0 x a)", "by (induct a) (auto elim: lformula0.cases simp: Formula_Operations.wf.simps Let_def)"], ["", "lemma lformula_lderiv0[Presb_simps]:\n  \"lformula0 a \\<Longrightarrow> Formula_Operations.lformula lformula0 (lderiv0 x a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula0 a \\<Longrightarrow>\n    Formula_Operations.lformula lformula0 (lderiv0 x a)", "by (induct a)\n    (auto elim: lformula0.cases intro: lformula0.intros simp: Let_def Formula_Operations.lformula.simps)"], ["", "lemma wf_rderiv0[Presb_simps]:\n  \"wf0 idx a \\<Longrightarrow> Formula_Operations.wf (\\<lambda>_. Suc) wf0 idx (rderiv0 x a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf0 idx a \\<Longrightarrow>\n    Formula_Operations.wf (\\<lambda>_. Suc) wf0 idx (rderiv0 x a)", "by (induct a) (auto elim: lformula0.cases simp: Formula_Operations.wf.simps Let_def)"], ["", "lemma find0_FV0[Presb_simps]: \"\\<lbrakk>wf0 idx a; l < idx\\<rbrakk> \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf0 idx a; l < idx\\<rbrakk>\n    \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)", "by (induct a) (auto simp: FV0_def)"], ["", "lemma FV0_less[Presb_simps]: \"wf0 idx a \\<Longrightarrow> v \\<in> FV0 k a \\<Longrightarrow> v < idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk> \\<Longrightarrow> v < idx", "by (induct a) (auto simp: FV0_def)"], ["", "lemma finite_FV0[Presb_simps]: \"finite (FV0 k a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (FV0 k a)", "by (induct a) (auto simp: FV0_def)"], ["", "lemma finite_lderiv0[Presb_simps]:\n  assumes \"lformula0 a\"\n  shows \"finite {\\<phi>. \\<exists>xs. \\<phi> = fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "define d where \"d = Formula_Operations.deriv extend lderiv0\""], ["proof (state)\nthis:\n  d = Formula_Operations.deriv extend lderiv0\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "define l where \"l is = sum_list [i. i \\<leftarrow> is, i < 0]\" for \"is\" :: \"int list\""], ["proof (state)\nthis:\n  l ?is =\n  sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) ?is))\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "define h where \"h is = sum_list [i. i \\<leftarrow> is, i > 0]\" for \"is\" :: \"int list\""], ["proof (state)\nthis:\n  h ?is =\n  sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) ?is))\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "define \\<Phi> where \"\\<Phi> a = (case a of\n    Eq is n z \\<Rightarrow> {FBase (Eq is i 0) | i . i \\<in> {min (- h is) n .. max (- l is) n}} \\<union>\n      {FBool False :: formula})\" for a"], ["proof (state)\nthis:\n  \\<Phi> ?a =\n  (case ?a of\n   presb.Eq is n z \\<Rightarrow>\n     {FBase (presb.Eq is i 0) |i.\n      i \\<in> {min (- h is) n..max (- l is) n}} \\<union>\n     {FBool False})\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "{"], ["proof (state)\nthis:\n  \\<Phi> ?a =\n  (case ?a of\n   presb.Eq is n z \\<Rightarrow>\n     {FBase (presb.Eq is i 0) |i.\n      i \\<in> {min (- h is) n..max (- l is) n}} \\<union>\n     {FBool False})\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "note Formula_Operations.fold_deriv_FBool[simp] Formula_Operations.deriv.simps[simp] \\<Phi>_def[simp]"], ["proof (state)\nthis:\n  fold (Formula_Operations.deriv ?extend ?d0.0) ?xs (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBase ?a) = ?deriv0.0 ?x ?a\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FNot ?\\<phi>) =\n  FNot (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FOr ?\\<phi> ?\\<psi>) =\n  FOr (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAnd ?\\<phi> ?\\<psi>) =\n  FAnd (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FEx ?k ?\\<phi>) =\n  FEx ?k\n   (FOr (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n          ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAll ?k ?\\<phi>) =\n  FAll ?k\n   (FAnd\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n       ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  \\<Phi> ?a =\n  (case ?a of\n   presb.Eq is n z \\<Rightarrow>\n     {FBase (presb.Eq is i 0) |i.\n      i \\<in> {min (- h is) n..max (- l is) n}} \\<union>\n     {FBool False})\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "from \\<open>lformula0 a\\<close>"], ["proof (chain)\npicking this:\n  lformula0 a", "have \"FBase a \\<in> \\<Phi> a\""], ["proof (prove)\nusing this:\n  lformula0 a\n\ngoal (1 subgoal):\n 1. FBase a \\<in> \\<Phi> a", "by (auto simp: elim!: lformula0.cases)"], ["proof (state)\nthis:\n  FBase a \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "moreover"], ["proof (state)\nthis:\n  FBase a \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "have \"\\<And>x \\<phi>. \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d x \\<phi> \\<in> \\<Phi> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<phi>.\n       \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d x \\<phi> \\<in> \\<Phi> a", "proof (induct a, unfold \\<Phi>_def presb.case, elim UnE CollectE insertE emptyE exE conjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a i 0);\n        i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a i 0) |i.\n                                i \\<in> {min (- h x1a)\n    x2a..max (- l x1a) x2a}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a i 0) |i.\n              i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}} \\<union>\n             {FBool False}", "fix \"is\" :: \"int list\" and bs :: \"bool list\" and i n :: int and \\<phi> :: formula"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a i 0);\n        i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a i 0) |i.\n                                i \\<in> {min (- h x1a)\n    x2a..max (- l x1a) x2a}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a i 0) |i.\n              i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}} \\<union>\n             {FBool False}", "assume \"i \\<in> {min (- h is) n..max (- l is) n}\" \"\\<phi> = FBase (presb.Eq is i 0)\""], ["proof (state)\nthis:\n  i \\<in> {min (- h is) n..max (- l is) n}\n  \\<phi> = FBase (presb.Eq is i 0)\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a i 0);\n        i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a i 0) |i.\n                                i \\<in> {min (- h x1a)\n    x2a..max (- l x1a) x2a}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a i 0) |i.\n              i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}} \\<union>\n             {FBool False}", "moreover"], ["proof (state)\nthis:\n  i \\<in> {min (- h is) n..max (- l is) n}\n  \\<phi> = FBase (presb.Eq is i 0)\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a i 0);\n        i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a i 0) |i.\n                                i \\<in> {min (- h x1a)\n    x2a..max (- l x1a) x2a}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a i 0) |i.\n              i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}} \\<union>\n             {FBool False}", "have \"scalar_product bs is \\<le> h is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_product (map of_bool bs) is \\<le> h is", "proof (induct \"is\" arbitrary: bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs. scalar_product (map of_bool bs) [] \\<le> h []\n 2. \\<And>a is bs.\n       (\\<And>bs.\n           scalar_product (map of_bool bs) is \\<le> h is) \\<Longrightarrow>\n       scalar_product (map of_bool bs) (a # is) \\<le> h (a # is)", "case (Cons x xs)"], ["proof (state)\nthis:\n  scalar_product (map of_bool ?bs) xs \\<le> h xs\n\ngoal (2 subgoals):\n 1. \\<And>bs. scalar_product (map of_bool bs) [] \\<le> h []\n 2. \\<And>a is bs.\n       (\\<And>bs.\n           scalar_product (map of_bool bs) is \\<le> h is) \\<Longrightarrow>\n       scalar_product (map of_bool bs) (a # is) \\<le> h (a # is)", "from Cons[of \"tl bs\"]"], ["proof (chain)\npicking this:\n  scalar_product (map of_bool (tl bs)) xs \\<le> h xs", "show ?case"], ["proof (prove)\nusing this:\n  scalar_product (map of_bool (tl bs)) xs \\<le> h xs\n\ngoal (1 subgoal):\n 1. scalar_product (map of_bool bs) (x # xs) \\<le> h (x # xs)", "by (cases bs) (auto simp: h_def)"], ["proof (state)\nthis:\n  scalar_product (map of_bool bs) (x # xs) \\<le> h (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>bs. scalar_product (map of_bool bs) [] \\<le> h []", "qed (auto simp: h_def scalar_product_def)"], ["proof (state)\nthis:\n  scalar_product (map of_bool bs) is \\<le> h is\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a i 0);\n        i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a i 0) |i.\n                                i \\<in> {min (- h x1a)\n    x2a..max (- l x1a) x2a}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a i 0) |i.\n              i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}} \\<union>\n             {FBool False}", "moreover"], ["proof (state)\nthis:\n  scalar_product (map of_bool bs) is \\<le> h is\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a i 0);\n        i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a i 0) |i.\n                                i \\<in> {min (- h x1a)\n    x2a..max (- l x1a) x2a}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a i 0) |i.\n              i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}} \\<union>\n             {FBool False}", "have \"l is \\<le> scalar_product bs is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l is \\<le> scalar_product (map of_bool bs) is", "proof (induct \"is\" arbitrary: bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs. l [] \\<le> scalar_product (map of_bool bs) []\n 2. \\<And>a is bs.\n       (\\<And>bs.\n           l is \\<le> scalar_product (map of_bool bs) is) \\<Longrightarrow>\n       l (a # is) \\<le> scalar_product (map of_bool bs) (a # is)", "case (Cons x xs)"], ["proof (state)\nthis:\n  l xs \\<le> scalar_product (map of_bool ?bs) xs\n\ngoal (2 subgoals):\n 1. \\<And>bs. l [] \\<le> scalar_product (map of_bool bs) []\n 2. \\<And>a is bs.\n       (\\<And>bs.\n           l is \\<le> scalar_product (map of_bool bs) is) \\<Longrightarrow>\n       l (a # is) \\<le> scalar_product (map of_bool bs) (a # is)", "from Cons[of \"tl bs\"]"], ["proof (chain)\npicking this:\n  l xs \\<le> scalar_product (map of_bool (tl bs)) xs", "show ?case"], ["proof (prove)\nusing this:\n  l xs \\<le> scalar_product (map of_bool (tl bs)) xs\n\ngoal (1 subgoal):\n 1. l (x # xs) \\<le> scalar_product (map of_bool bs) (x # xs)", "by (cases bs) (auto simp: l_def)"], ["proof (state)\nthis:\n  l (x # xs) \\<le> scalar_product (map of_bool bs) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>bs. l [] \\<le> scalar_product (map of_bool bs) []", "qed (auto simp: l_def scalar_product_def)"], ["proof (state)\nthis:\n  l is \\<le> scalar_product (map of_bool bs) is\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a i 0);\n        i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a i 0) |i.\n                                i \\<in> {min (- h x1a)\n    x2a..max (- l x1a) x2a}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a i 0) |i.\n              i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}} \\<union>\n             {FBool False}", "ultimately"], ["proof (chain)\npicking this:\n  i \\<in> {min (- h is) n..max (- l is) n}\n  \\<phi> = FBase (presb.Eq is i 0)\n  scalar_product (map of_bool bs) is \\<le> h is\n  l is \\<le> scalar_product (map of_bool bs) is", "show \"d bs \\<phi> \\<in>\n        {FBase (presb.Eq is i 0) |i. i \\<in> {min (- h is) n..max (- l is) n}} \\<union> {FBool False}\""], ["proof (prove)\nusing this:\n  i \\<in> {min (- h is) n..max (- l is) n}\n  \\<phi> = FBase (presb.Eq is i 0)\n  scalar_product (map of_bool bs) is \\<le> h is\n  l is \\<le> scalar_product (map of_bool bs) is\n\ngoal (1 subgoal):\n 1. d bs \\<phi>\n    \\<in> {FBase (presb.Eq is i 0) |i.\n           i \\<in> {min (- h is) n..max (- l is) n}} \\<union>\n          {FBool False}", "by (auto simp: d_def Let_def)"], ["proof (state)\nthis:\n  d bs \\<phi>\n  \\<in> {FBase (presb.Eq is i 0) |i.\n         i \\<in> {min (- h is) n..max (- l is) n}} \\<union>\n        {FBool False}\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a i 0) |i.\n              i \\<in> {min (- h x1a) x2a..max (- l x1a) x2a}} \\<union>\n             {FBool False}", "qed (auto simp: d_def)"], ["proof (state)\nthis:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "then"], ["proof (chain)\npicking this:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a", "have \"\\<And>\\<phi>. \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs \\<phi> \\<in> \\<Phi> a\""], ["proof (prove)\nusing this:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<phi> \\<in> \\<Phi> a \\<Longrightarrow>\n       fold d xs \\<phi> \\<in> \\<Phi> a", "by (induct xs) auto"], ["proof (state)\nthis:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "ultimately"], ["proof (chain)\npicking this:\n  FBase a \\<in> \\<Phi> a\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a", "have \"fold d xs (FBase a) \\<in> \\<Phi> a\""], ["proof (prove)\nusing this:\n  FBase a \\<in> \\<Phi> a\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. fold d xs (FBase a) \\<in> \\<Phi> a", "by blast"], ["proof (state)\nthis:\n  fold d xs (FBase a) \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "}"], ["proof (state)\nthis:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "moreover"], ["proof (state)\nthis:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "have \"finite (\\<Phi> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Phi> a)", "unfolding \\<Phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (case a of\n      presb.Eq is n z \\<Rightarrow>\n        {FBase (presb.Eq is i 0) |i.\n         i \\<in> {min (- h is) n..max (- l is) n}} \\<union>\n        {FBool False})", "by (auto split: presb.splits)"], ["proof (state)\nthis:\n  finite (\\<Phi> a)\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "ultimately"], ["proof (chain)\npicking this:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n  finite (\\<Phi> a)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n  finite (\\<Phi> a)\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "unfolding d_def"], ["proof (prove)\nusing this:\n  fold (Formula_Operations.deriv extend lderiv0) ?xs2 (FBase a)\n  \\<in> \\<Phi> a\n  finite (\\<Phi> a)\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}", "by (blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite\n   {\\<phi>.\n    \\<exists>xs.\n       \\<phi> = fold (Formula_Operations.deriv extend lderiv0) xs (FBase a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_rderiv0[Presb_simps]:\n  \"finite {\\<phi>. \\<exists>xs. \\<phi> = fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "define d where \"d = Formula_Operations.deriv extend rderiv0\""], ["proof (state)\nthis:\n  d = Formula_Operations.deriv extend rderiv0\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "define l where \"l is = sum_list [i. i \\<leftarrow> is, i < 0]\"for \"is\" :: \"int list\""], ["proof (state)\nthis:\n  l ?is =\n  sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) ?is))\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "define h where \"h is = sum_list [i. i \\<leftarrow> is, i > 0]\"for \"is\" :: \"int list\""], ["proof (state)\nthis:\n  h ?is =\n  sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) ?is))\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "define \\<Phi> where \"\\<Phi> a = (case a of\n    Eq is n z \\<Rightarrow> {FBase (Eq is n i) | i . i \\<in> {min (- h is) (min n z) .. max (- l is) (max n z)}} \\<union>\n      {FBool False :: formula})\" for a"], ["proof (state)\nthis:\n  \\<Phi> ?a =\n  (case ?a of\n   presb.Eq is n z \\<Rightarrow>\n     {FBase (presb.Eq is n i) |i.\n      i \\<in> {min (- h is) (min n z)..max (- l is) (max n z)}} \\<union>\n     {FBool False})\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "{"], ["proof (state)\nthis:\n  \\<Phi> ?a =\n  (case ?a of\n   presb.Eq is n z \\<Rightarrow>\n     {FBase (presb.Eq is n i) |i.\n      i \\<in> {min (- h is) (min n z)..max (- l is) (max n z)}} \\<union>\n     {FBool False})\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "note Formula_Operations.fold_deriv_FBool[simp] Formula_Operations.deriv.simps[simp] \\<Phi>_def[simp]"], ["proof (state)\nthis:\n  fold (Formula_Operations.deriv ?extend ?d0.0) ?xs (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBase ?a) = ?deriv0.0 ?x ?a\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FNot ?\\<phi>) =\n  FNot (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FOr ?\\<phi> ?\\<psi>) =\n  FOr (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAnd ?\\<phi> ?\\<psi>) =\n  FAnd (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FEx ?k ?\\<phi>) =\n  FEx ?k\n   (FOr (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n          ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAll ?k ?\\<phi>) =\n  FAll ?k\n   (FAnd\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n       ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  \\<Phi> ?a =\n  (case ?a of\n   presb.Eq is n z \\<Rightarrow>\n     {FBase (presb.Eq is n i) |i.\n      i \\<in> {min (- h is) (min n z)..max (- l is) (max n z)}} \\<union>\n     {FBool False})\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "have \"FBase a \\<in> \\<Phi> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FBase a \\<in> \\<Phi> a", "by (auto split: presb.splits)"], ["proof (state)\nthis:\n  FBase a \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "moreover"], ["proof (state)\nthis:\n  FBase a \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "have \"\\<And>x \\<phi>. \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d x \\<phi> \\<in> \\<Phi> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<phi>.\n       \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d x \\<phi> \\<in> \\<Phi> a", "proof (induct a, unfold \\<Phi>_def presb.case, elim UnE CollectE insertE emptyE exE conjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a x2a i);\n        i \\<in> {min (- h x1a)\n                  (min x2a x3a)..max (- l x1a) (max x2a x3a)}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a x2a i) |i.\n                                i \\<in> {min (- h x1a)\n    (min x2a x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a x2a i) |i.\n              i \\<in> {min (- h x1a)\n                        (min x2a\n                          x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n             {FBool False}", "fix \"is\" :: \"int list\" and bs :: \"bool list\" and i n m :: int and \\<phi> :: formula"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a x2a i);\n        i \\<in> {min (- h x1a)\n                  (min x2a x3a)..max (- l x1a) (max x2a x3a)}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a x2a i) |i.\n                                i \\<in> {min (- h x1a)\n    (min x2a x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a x2a i) |i.\n              i \\<in> {min (- h x1a)\n                        (min x2a\n                          x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n             {FBool False}", "assume \"i \\<in> {min (- h is) (min n m)..max (- l is) (max n m)}\" \"\\<phi> = FBase (presb.Eq is n i)\""], ["proof (state)\nthis:\n  i \\<in> {min (- h is) (min n m)..max (- l is) (max n m)}\n  \\<phi> = FBase (presb.Eq is n i)\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a x2a i);\n        i \\<in> {min (- h x1a)\n                  (min x2a x3a)..max (- l x1a) (max x2a x3a)}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a x2a i) |i.\n                                i \\<in> {min (- h x1a)\n    (min x2a x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a x2a i) |i.\n              i \\<in> {min (- h x1a)\n                        (min x2a\n                          x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n             {FBool False}", "moreover"], ["proof (state)\nthis:\n  i \\<in> {min (- h is) (min n m)..max (- l is) (max n m)}\n  \\<phi> = FBase (presb.Eq is n i)\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a x2a i);\n        i \\<in> {min (- h x1a)\n                  (min x2a x3a)..max (- l x1a) (max x2a x3a)}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a x2a i) |i.\n                                i \\<in> {min (- h x1a)\n    (min x2a x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a x2a i) |i.\n              i \\<in> {min (- h x1a)\n                        (min x2a\n                          x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n             {FBool False}", "have \"scalar_product bs is \\<le> h is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_product (map of_bool bs) is \\<le> h is", "proof (induct \"is\" arbitrary: bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs. scalar_product (map of_bool bs) [] \\<le> h []\n 2. \\<And>a is bs.\n       (\\<And>bs.\n           scalar_product (map of_bool bs) is \\<le> h is) \\<Longrightarrow>\n       scalar_product (map of_bool bs) (a # is) \\<le> h (a # is)", "case (Cons x xs)"], ["proof (state)\nthis:\n  scalar_product (map of_bool ?bs) xs \\<le> h xs\n\ngoal (2 subgoals):\n 1. \\<And>bs. scalar_product (map of_bool bs) [] \\<le> h []\n 2. \\<And>a is bs.\n       (\\<And>bs.\n           scalar_product (map of_bool bs) is \\<le> h is) \\<Longrightarrow>\n       scalar_product (map of_bool bs) (a # is) \\<le> h (a # is)", "from Cons[of \"tl bs\"]"], ["proof (chain)\npicking this:\n  scalar_product (map of_bool (tl bs)) xs \\<le> h xs", "show ?case"], ["proof (prove)\nusing this:\n  scalar_product (map of_bool (tl bs)) xs \\<le> h xs\n\ngoal (1 subgoal):\n 1. scalar_product (map of_bool bs) (x # xs) \\<le> h (x # xs)", "by (cases bs) (auto simp: h_def)"], ["proof (state)\nthis:\n  scalar_product (map of_bool bs) (x # xs) \\<le> h (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>bs. scalar_product (map of_bool bs) [] \\<le> h []", "qed (auto simp: h_def scalar_product_def)"], ["proof (state)\nthis:\n  scalar_product (map of_bool bs) is \\<le> h is\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a x2a i);\n        i \\<in> {min (- h x1a)\n                  (min x2a x3a)..max (- l x1a) (max x2a x3a)}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a x2a i) |i.\n                                i \\<in> {min (- h x1a)\n    (min x2a x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a x2a i) |i.\n              i \\<in> {min (- h x1a)\n                        (min x2a\n                          x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n             {FBool False}", "moreover"], ["proof (state)\nthis:\n  scalar_product (map of_bool bs) is \\<le> h is\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a x2a i);\n        i \\<in> {min (- h x1a)\n                  (min x2a x3a)..max (- l x1a) (max x2a x3a)}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a x2a i) |i.\n                                i \\<in> {min (- h x1a)\n    (min x2a x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a x2a i) |i.\n              i \\<in> {min (- h x1a)\n                        (min x2a\n                          x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n             {FBool False}", "have \"l is \\<le> scalar_product bs is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l is \\<le> scalar_product (map of_bool bs) is", "proof (induct \"is\" arbitrary: bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs. l [] \\<le> scalar_product (map of_bool bs) []\n 2. \\<And>a is bs.\n       (\\<And>bs.\n           l is \\<le> scalar_product (map of_bool bs) is) \\<Longrightarrow>\n       l (a # is) \\<le> scalar_product (map of_bool bs) (a # is)", "case (Cons x xs)"], ["proof (state)\nthis:\n  l xs \\<le> scalar_product (map of_bool ?bs) xs\n\ngoal (2 subgoals):\n 1. \\<And>bs. l [] \\<le> scalar_product (map of_bool bs) []\n 2. \\<And>a is bs.\n       (\\<And>bs.\n           l is \\<le> scalar_product (map of_bool bs) is) \\<Longrightarrow>\n       l (a # is) \\<le> scalar_product (map of_bool bs) (a # is)", "from Cons[of \"tl bs\"]"], ["proof (chain)\npicking this:\n  l xs \\<le> scalar_product (map of_bool (tl bs)) xs", "show ?case"], ["proof (prove)\nusing this:\n  l xs \\<le> scalar_product (map of_bool (tl bs)) xs\n\ngoal (1 subgoal):\n 1. l (x # xs) \\<le> scalar_product (map of_bool bs) (x # xs)", "by (cases bs) (auto simp: l_def)"], ["proof (state)\nthis:\n  l (x # xs) \\<le> scalar_product (map of_bool bs) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>bs. l [] \\<le> scalar_product (map of_bool bs) []", "qed (auto simp: l_def scalar_product_def)"], ["proof (state)\nthis:\n  l is \\<le> scalar_product (map of_bool bs) is\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a x3a x \\<phi> i.\n       \\<lbrakk>\\<phi> = FBase (presb.Eq x1a x2a i);\n        i \\<in> {min (- h x1a)\n                  (min x2a x3a)..max (- l x1a) (max x2a x3a)}\\<rbrakk>\n       \\<Longrightarrow> d x \\<phi>\n                         \\<in> {FBase (presb.Eq x1a x2a i) |i.\n                                i \\<in> {min (- h x1a)\n    (min x2a x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n                               {FBool False}\n 2. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a x2a i) |i.\n              i \\<in> {min (- h x1a)\n                        (min x2a\n                          x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n             {FBool False}", "ultimately"], ["proof (chain)\npicking this:\n  i \\<in> {min (- h is) (min n m)..max (- l is) (max n m)}\n  \\<phi> = FBase (presb.Eq is n i)\n  scalar_product (map of_bool bs) is \\<le> h is\n  l is \\<le> scalar_product (map of_bool bs) is", "show \"d bs \\<phi> \\<in>\n        {FBase (presb.Eq is n i) |i. i \\<in> {min (- h is) (min n m)..max (- l is) (max n m)}} \\<union> {FBool False}\""], ["proof (prove)\nusing this:\n  i \\<in> {min (- h is) (min n m)..max (- l is) (max n m)}\n  \\<phi> = FBase (presb.Eq is n i)\n  scalar_product (map of_bool bs) is \\<le> h is\n  l is \\<le> scalar_product (map of_bool bs) is\n\ngoal (1 subgoal):\n 1. d bs \\<phi>\n    \\<in> {FBase (presb.Eq is n i) |i.\n           i \\<in> {min (- h is)\n                     (min n m)..max (- l is) (max n m)}} \\<union>\n          {FBool False}", "by (auto 0 1 simp: d_def Let_def h_def l_def)"], ["proof (state)\nthis:\n  d bs \\<phi>\n  \\<in> {FBase (presb.Eq is n i) |i.\n         i \\<in> {min (- h is) (min n m)..max (- l is) (max n m)}} \\<union>\n        {FBool False}\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a x \\<phi>.\n       \\<phi> = FBool False \\<Longrightarrow>\n       d x \\<phi>\n       \\<in> {FBase (presb.Eq x1a x2a i) |i.\n              i \\<in> {min (- h x1a)\n                        (min x2a\n                          x3a)..max (- l x1a) (max x2a x3a)}} \\<union>\n             {FBool False}", "qed (auto simp: d_def)"], ["proof (state)\nthis:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "then"], ["proof (chain)\npicking this:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a", "have \"\\<And>\\<phi>. \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs \\<phi> \\<in> \\<Phi> a\""], ["proof (prove)\nusing this:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<phi> \\<in> \\<Phi> a \\<Longrightarrow>\n       fold d xs \\<phi> \\<in> \\<Phi> a", "by (induct xs) auto"], ["proof (state)\nthis:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "ultimately"], ["proof (chain)\npicking this:\n  FBase a \\<in> \\<Phi> a\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a", "have \"fold d xs (FBase a) \\<in> \\<Phi> a\""], ["proof (prove)\nusing this:\n  FBase a \\<in> \\<Phi> a\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. fold d xs (FBase a) \\<in> \\<Phi> a", "by blast"], ["proof (state)\nthis:\n  fold d xs (FBase a) \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "}"], ["proof (state)\nthis:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "moreover"], ["proof (state)\nthis:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "have \"finite (\\<Phi> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Phi> a)", "unfolding \\<Phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (case a of\n      presb.Eq is n z \\<Rightarrow>\n        {FBase (presb.Eq is n i) |i.\n         i \\<in> {min (- h is) (min n z)..max (- l is) (max n z)}} \\<union>\n        {FBool False})", "by (auto split: presb.splits)"], ["proof (state)\nthis:\n  finite (\\<Phi> a)\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "ultimately"], ["proof (chain)\npicking this:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n  finite (\\<Phi> a)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n  finite (\\<Phi> a)\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "unfolding d_def"], ["proof (prove)\nusing this:\n  fold (Formula_Operations.deriv extend rderiv0) ?xs2 (FBase a)\n  \\<in> \\<Phi> a\n  finite (\\<Phi> a)\n\ngoal (1 subgoal):\n 1. finite\n     {\\<phi>.\n      \\<exists>xs.\n         \\<phi> =\n         fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}", "by (blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite\n   {\\<phi>.\n    \\<exists>xs.\n       \\<phi> = fold (Formula_Operations.deriv extend rderiv0) xs (FBase a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scalar_product_CONS: \"length xs = length (bs :: bool list) \\<Longrightarrow>\n  scalar_product (map_index (\\<lambda>i n. 2 * n + bs ! i) xs) is =\n  scalar_product bs is + 2 * scalar_product xs is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length bs \\<Longrightarrow>\n    scalar_product (map_index (\\<lambda>i n. 2 * n + map of_bool bs ! i) xs)\n     is =\n    scalar_product (map of_bool bs) is + 2 * scalar_product xs is", "by (induct \"is\" arbitrary: bs xs) (auto split: list.splits simp: algebra_simps)"], ["", "lemma eval_tm_CONS[simp]:\n  \"\\<lbrakk>length is \\<le> #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x\\<rbrakk> \\<Longrightarrow>\n   eval_tm (CONS x \\<AA>) is = scalar_product x is + 2 * eval_tm \\<AA> is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length is \\<le> #\\<^sub>V \\<AA>;\n     #\\<^sub>V \\<AA> = length x\\<rbrakk>\n    \\<Longrightarrow> eval_tm (CONS x \\<AA>) is =\n                      scalar_product (map of_bool x) is +\n                      2 * eval_tm \\<AA> is", "by transfer (auto simp: scalar_product_CONS[symmetric]\n    intro!: arg_cong2[of _ _ _ _ scalar_product] nth_equalityI)"], ["", "lemma satisfies_lderiv0[Presb_simps]:\n  \"\\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = length x; lformula0 a\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile> lderiv0 x a \\<longleftrightarrow> CONS x \\<AA> \\<Turnstile>0 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = length x;\n     lformula0 a\\<rbrakk>\n    \\<Longrightarrow> \\<AA> \\<Turnstile> lderiv0 x a =\n                      CONS x \\<AA> \\<Turnstile>0 a", "by (auto simp: Let_def Formula_Operations.satisfies_gen.simps\n    split: if_splits elim!: lformula0.cases)"], ["", "lemma satisfies_bounded_lderiv0[Presb_simps]:\n  \"\\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = length x; lformula0 a\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b lderiv0 x a \\<longleftrightarrow> CONS x \\<AA> \\<Turnstile>0 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = length x;\n     lformula0 a\\<rbrakk>\n    \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b lderiv0 x a =\n                      CONS x \\<AA> \\<Turnstile>0 a", "by (auto simp: Let_def Formula_Operations.satisfies_gen.simps\n    split: if_splits elim!: lformula0.cases)"], ["", "lemma scalar_product_SNOC: \"length xs = length (bs :: bool list)  \\<Longrightarrow>\n  scalar_product (map_index (\\<lambda>i m. m + 2 ^ a * bs ! i) xs) is =\n  scalar_product xs is + 2 ^ a * scalar_product bs is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length bs \\<Longrightarrow>\n    scalar_product\n     (map_index (\\<lambda>i m. m + 2 ^ a * map of_bool bs ! i) xs) is =\n    scalar_product xs is + 2 ^ a * scalar_product (map of_bool bs) is", "by (induct \"is\" arbitrary: bs xs) (auto split: list.splits simp: algebra_simps)"], ["", "lemma eval_tm_SNOC[simp]:\n  \"\\<lbrakk>length is \\<le> #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x\\<rbrakk> \\<Longrightarrow>\n   eval_tm (SNOC x \\<AA>) is = eval_tm \\<AA> is + 2 ^ Length \\<AA> * scalar_product x is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length is \\<le> #\\<^sub>V \\<AA>;\n     #\\<^sub>V \\<AA> = length x\\<rbrakk>\n    \\<Longrightarrow> eval_tm (SNOC x \\<AA>) is =\n                      eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is", "by transfer (auto simp: scalar_product_SNOC[symmetric]\n    intro!: arg_cong2[of _ _ _ _ scalar_product] nth_equalityI)"], ["", "lemma Length_eq0_eval_tm_eq0[simp]: \"Length \\<AA> = 0 \\<Longrightarrow> eval_tm \\<AA> is = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length \\<AA> = 0 \\<Longrightarrow> eval_tm \\<AA> is = 0", "by transfer (auto simp: len_eq0_iff scalar_product_eq0)"], ["", "lemma less_pow2: \"x < 2 ^ a \\<Longrightarrow> int x < 2 ^ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < 2 ^ a \\<Longrightarrow> int x < 2 ^ a", "by (metis of_nat_less_iff of_nat_numeral of_nat_power [symmetric])"], ["", "lemma scalar_product_upper_bound: \"\\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n  scalar_product b is \\<le> (2 ^ a - 1) * sum_list [i. i \\<leftarrow> is, i > 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n    scalar_product b is\n    \\<le> (2 ^ a - 1) *\n          sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))", "proof (induct \"is\" arbitrary: b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n       scalar_product b []\n       \\<le> (2 ^ a - 1) *\n             sum_list\n              (concat (map (\\<lambda>i. if 0 < i then [i] else []) []))\n 2. \\<And>aa is b.\n       \\<lbrakk>\\<And>b.\n                   \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n                   scalar_product b is\n                   \\<le> (2 ^ a - 1) *\n                         sum_list\n                          (concat\n                            (map (\\<lambda>i. if 0 < i then [i] else [])\n                              is));\n        \\<forall>x\\<in>set b. len x \\<le> a\\<rbrakk>\n       \\<Longrightarrow> scalar_product b (aa # is)\n                         \\<le> (2 ^ a - 1) *\n                               sum_list\n                                (concat\n                                  (map (\\<lambda>i.\n     if 0 < i then [i] else [])\n                                    (aa # is)))", "case (Cons i \"is\")"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ?b. len x \\<le> a \\<Longrightarrow>\n  scalar_product ?b is\n  \\<le> (2 ^ a - 1) *\n        sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))\n  \\<forall>x\\<in>set b. len x \\<le> a\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n       scalar_product b []\n       \\<le> (2 ^ a - 1) *\n             sum_list\n              (concat (map (\\<lambda>i. if 0 < i then [i] else []) []))\n 2. \\<And>aa is b.\n       \\<lbrakk>\\<And>b.\n                   \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n                   scalar_product b is\n                   \\<le> (2 ^ a - 1) *\n                         sum_list\n                          (concat\n                            (map (\\<lambda>i. if 0 < i then [i] else [])\n                              is));\n        \\<forall>x\\<in>set b. len x \\<le> a\\<rbrakk>\n       \\<Longrightarrow> scalar_product b (aa # is)\n                         \\<le> (2 ^ a - 1) *\n                               sum_list\n                                (concat\n                                  (map (\\<lambda>i.\n     if 0 < i then [i] else [])\n                                    (aa # is)))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set ?b. len x \\<le> a \\<Longrightarrow>\n  scalar_product ?b is\n  \\<le> (2 ^ a - 1) *\n        sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))\n  \\<forall>x\\<in>set b. len x \\<le> a", "have \"scalar_product (tl b) is \\<le> (2 ^ a - 1) * sum_list [i. i \\<leftarrow> is, i > 0]\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ?b. len x \\<le> a \\<Longrightarrow>\n  scalar_product ?b is\n  \\<le> (2 ^ a - 1) *\n        sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))\n  \\<forall>x\\<in>set b. len x \\<le> a\n\ngoal (1 subgoal):\n 1. scalar_product (tl b) is\n    \\<le> (2 ^ a - 1) *\n          sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))", "by (auto simp: in_set_tlD)"], ["proof (state)\nthis:\n  scalar_product (tl b) is\n  \\<le> (2 ^ a - 1) *\n        sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n       scalar_product b []\n       \\<le> (2 ^ a - 1) *\n             sum_list\n              (concat (map (\\<lambda>i. if 0 < i then [i] else []) []))\n 2. \\<And>aa is b.\n       \\<lbrakk>\\<And>b.\n                   \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n                   scalar_product b is\n                   \\<le> (2 ^ a - 1) *\n                         sum_list\n                          (concat\n                            (map (\\<lambda>i. if 0 < i then [i] else [])\n                              is));\n        \\<forall>x\\<in>set b. len x \\<le> a\\<rbrakk>\n       \\<Longrightarrow> scalar_product b (aa # is)\n                         \\<le> (2 ^ a - 1) *\n                               sum_list\n                                (concat\n                                  (map (\\<lambda>i.\n     if 0 < i then [i] else [])\n                                    (aa # is)))", "with Cons(2)"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set b. len x \\<le> a\n  scalar_product (tl b) is\n  \\<le> (2 ^ a - 1) *\n        sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set b. len x \\<le> a\n  scalar_product (tl b) is\n  \\<le> (2 ^ a - 1) *\n        sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))\n\ngoal (1 subgoal):\n 1. scalar_product b (i # is)\n    \\<le> (2 ^ a - 1) *\n          sum_list\n           (concat (map (\\<lambda>i. if 0 < i then [i] else []) (i # is)))", "by (auto 0 3 split: list.splits simp: len_le_iff mult_le_0_iff\n      distrib_left add.commute[of _ \"(2 ^ a - 1) * i\"] less_pow2\n      intro: add_mono elim: order_trans[OF add_mono[OF order_refl]])"], ["proof (state)\nthis:\n  scalar_product b (i # is)\n  \\<le> (2 ^ a - 1) *\n        sum_list\n         (concat (map (\\<lambda>i. if 0 < i then [i] else []) (i # is)))\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n       scalar_product b []\n       \\<le> (2 ^ a - 1) *\n             sum_list\n              (concat (map (\\<lambda>i. if 0 < i then [i] else []) []))", "qed simp"], ["", "lemma scalar_product_lower_bound: \"\\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n  scalar_product b is \\<ge> (2 ^ a - 1) * sum_list [i. i \\<leftarrow> is, i < 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n    (2 ^ a - 1) *\n    sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n    \\<le> scalar_product b is", "proof (induct \"is\" arbitrary: b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n       (2 ^ a - 1) *\n       sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) []))\n       \\<le> scalar_product b []\n 2. \\<And>aa is b.\n       \\<lbrakk>\\<And>b.\n                   \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n                   (2 ^ a - 1) *\n                   sum_list\n                    (concat\n                      (map (\\<lambda>i. if i < 0 then [i] else []) is))\n                   \\<le> scalar_product b is;\n        \\<forall>x\\<in>set b. len x \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (2 ^ a - 1) *\n                         sum_list\n                          (concat\n                            (map (\\<lambda>i. if i < 0 then [i] else [])\n                              (aa # is)))\n                         \\<le> scalar_product b (aa # is)", "case (Cons i \"is\")"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ?b. len x \\<le> a \\<Longrightarrow>\n  (2 ^ a - 1) *\n  sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n  \\<le> scalar_product ?b is\n  \\<forall>x\\<in>set b. len x \\<le> a\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n       (2 ^ a - 1) *\n       sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) []))\n       \\<le> scalar_product b []\n 2. \\<And>aa is b.\n       \\<lbrakk>\\<And>b.\n                   \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n                   (2 ^ a - 1) *\n                   sum_list\n                    (concat\n                      (map (\\<lambda>i. if i < 0 then [i] else []) is))\n                   \\<le> scalar_product b is;\n        \\<forall>x\\<in>set b. len x \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (2 ^ a - 1) *\n                         sum_list\n                          (concat\n                            (map (\\<lambda>i. if i < 0 then [i] else [])\n                              (aa # is)))\n                         \\<le> scalar_product b (aa # is)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set ?b. len x \\<le> a \\<Longrightarrow>\n  (2 ^ a - 1) *\n  sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n  \\<le> scalar_product ?b is\n  \\<forall>x\\<in>set b. len x \\<le> a", "have \"scalar_product (tl b) is \\<ge> (2 ^ a - 1) * sum_list [i. i \\<leftarrow> is, i < 0]\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ?b. len x \\<le> a \\<Longrightarrow>\n  (2 ^ a - 1) *\n  sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n  \\<le> scalar_product ?b is\n  \\<forall>x\\<in>set b. len x \\<le> a\n\ngoal (1 subgoal):\n 1. (2 ^ a - 1) *\n    sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n    \\<le> scalar_product (tl b) is", "by (auto simp: in_set_tlD)"], ["proof (state)\nthis:\n  (2 ^ a - 1) *\n  sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n  \\<le> scalar_product (tl b) is\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n       (2 ^ a - 1) *\n       sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) []))\n       \\<le> scalar_product b []\n 2. \\<And>aa is b.\n       \\<lbrakk>\\<And>b.\n                   \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n                   (2 ^ a - 1) *\n                   sum_list\n                    (concat\n                      (map (\\<lambda>i. if i < 0 then [i] else []) is))\n                   \\<le> scalar_product b is;\n        \\<forall>x\\<in>set b. len x \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (2 ^ a - 1) *\n                         sum_list\n                          (concat\n                            (map (\\<lambda>i. if i < 0 then [i] else [])\n                              (aa # is)))\n                         \\<le> scalar_product b (aa # is)", "with Cons(2)"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set b. len x \\<le> a\n  (2 ^ a - 1) *\n  sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n  \\<le> scalar_product (tl b) is", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set b. len x \\<le> a\n  (2 ^ a - 1) *\n  sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n  \\<le> scalar_product (tl b) is\n\ngoal (1 subgoal):\n 1. (2 ^ a - 1) *\n    sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) (i # is)))\n    \\<le> scalar_product b (i # is)", "by (auto 0 3 split: list.splits simp: len_le_iff mult_le_0_iff\n      distrib_left add.commute[of _ \"(2 ^ a - 1) * i\"] less_pow2\n      intro: add_mono elim: order_trans[OF add_mono[OF order_refl]] order_trans)"], ["proof (state)\nthis:\n  (2 ^ a - 1) *\n  sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) (i # is)))\n  \\<le> scalar_product b (i # is)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<forall>x\\<in>set b. len x \\<le> a \\<Longrightarrow>\n       (2 ^ a - 1) *\n       sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) []))\n       \\<le> scalar_product b []", "qed simp"], ["", "lemma eval_tm_upper_bound: \"eval_tm \\<AA> is \\<le> (2 ^ Length \\<AA> - 1) * sum_list [i. i \\<leftarrow> is, i > 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tm \\<AA> is\n    \\<le> (2 ^ Length \\<AA> - 1) *\n          sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))", "by transfer (auto simp: scalar_product_upper_bound)"], ["", "lemma eval_tm_lower_bound: \"eval_tm \\<AA> is \\<ge> (2 ^ Length \\<AA> - 1) * sum_list [i. i \\<leftarrow> is, i < 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ Length \\<AA> - 1) *\n    sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n    \\<le> eval_tm \\<AA> is", "by transfer (auto simp: scalar_product_lower_bound)"], ["", "lemma satisfies_bounded_rderiv0[Presb_simps]:\n  \"\\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = length x\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b rderiv0 x a \\<longleftrightarrow> SNOC x \\<AA> \\<Turnstile>0 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = length x\\<rbrakk>\n    \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b rderiv0 x a =\n                      SNOC x \\<AA> \\<Turnstile>0 a", "proof (induct a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (presb.Eq x1a x2a x3a);\n        #\\<^sub>V \\<AA> = length x\\<rbrakk>\n       \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b\n                         rderiv0 x (presb.Eq x1a x2a x3a) =\n                         SNOC x \\<AA> \\<Turnstile>0 presb.Eq x1a x2a x3a", "case (Eq \"is\" n d)"], ["proof (state)\nthis:\n  wf0 (#\\<^sub>V \\<AA>) (presb.Eq is n d)\n  #\\<^sub>V \\<AA> = length x\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (presb.Eq x1a x2a x3a);\n        #\\<^sub>V \\<AA> = length x\\<rbrakk>\n       \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b\n                         rderiv0 x (presb.Eq x1a x2a x3a) =\n                         SNOC x \\<AA> \\<Turnstile>0 presb.Eq x1a x2a x3a", "let ?l = \"Length \\<AA>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (presb.Eq x1a x2a x3a);\n        #\\<^sub>V \\<AA> = length x\\<rbrakk>\n       \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b\n                         rderiv0 x (presb.Eq x1a x2a x3a) =\n                         SNOC x \\<AA> \\<Turnstile>0 presb.Eq x1a x2a x3a", "define d' where \"d' = scalar_product x is + 2 * d\""], ["proof (state)\nthis:\n  d' = scalar_product (map of_bool x) is + 2 * d\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (presb.Eq x1a x2a x3a);\n        #\\<^sub>V \\<AA> = length x\\<rbrakk>\n       \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b\n                         rderiv0 x (presb.Eq x1a x2a x3a) =\n                         SNOC x \\<AA> \\<Turnstile>0 presb.Eq x1a x2a x3a", "define l where \"l = sum_list  [i. i \\<leftarrow> is, i < 0]\""], ["proof (state)\nthis:\n  l = sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (presb.Eq x1a x2a x3a);\n        #\\<^sub>V \\<AA> = length x\\<rbrakk>\n       \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b\n                         rderiv0 x (presb.Eq x1a x2a x3a) =\n                         SNOC x \\<AA> \\<Turnstile>0 presb.Eq x1a x2a x3a", "define h where \"h = sum_list  [i. i \\<leftarrow> is, i > 0]\""], ["proof (state)\nthis:\n  h = sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x3a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (presb.Eq x1a x2a x3a);\n        #\\<^sub>V \\<AA> = length x\\<rbrakk>\n       \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b\n                         rderiv0 x (presb.Eq x1a x2a x3a) =\n                         SNOC x \\<AA> \\<Turnstile>0 presb.Eq x1a x2a x3a", "from Eq"], ["proof (chain)\npicking this:\n  wf0 (#\\<^sub>V \\<AA>) (presb.Eq is n d)\n  #\\<^sub>V \\<AA> = length x", "show ?case"], ["proof (prove)\nusing this:\n  wf0 (#\\<^sub>V \\<AA>) (presb.Eq is n d)\n  #\\<^sub>V \\<AA> = length x\n\ngoal (1 subgoal):\n 1. \\<AA> \\<Turnstile>\\<^sub>b rderiv0 x (presb.Eq is n d) =\n    SNOC x \\<AA> \\<Turnstile>0 presb.Eq is n d", "unfolding wf0.simps satisfies0.simps rderiv0.simps Let_def"], ["proof (prove)\nusing this:\n  length is = #\\<^sub>V \\<AA>\n  #\\<^sub>V \\<AA> = length x\n\ngoal (1 subgoal):\n 1. \\<AA> \\<Turnstile>\\<^sub>b\n    (if scalar_product (map of_bool x) is + 2 * d\n        \\<in> {min (- sum_list\n                       (concat\n                         (map (\\<lambda>i. if 0 < i then [i] else []) is)))\n                n..max (- sum_list\n                           (concat\n                             (map (\\<lambda>i. if i < 0 then [i] else [])\n                               is)))\n                    n}\n     then FBase (presb.Eq is n (scalar_product (map of_bool x) is + 2 * d))\n     else FBool False) =\n    (eval_tm (SNOC x \\<AA>) is = n - 2 ^ Length (SNOC x \\<AA>) * d)", "proof (split if_splits, simp only: Formula_Operations.satisfies_gen.simps satisfies0.simps\n    Length_SNOC eval_tm_SNOC simp_thms(13) de_Morgan_conj not_le\n    min_less_iff_conj max_less_iff_conj d'_def[symmetric] h_def[symmetric] l_def[symmetric], safe)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"eval_tm \\<AA> is + 2 ^ ?l * scalar_product x is = n - 2 ^ Suc ?l * d\""], ["proof (state)\nthis:\n  eval_tm \\<AA> is + 2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n  n - 2 ^ Suc (Length \\<AA>) * d\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "with eval_tm_upper_bound[of \\<AA> \"is\"] eval_tm_lower_bound[of \\<AA> \"is\"]"], ["proof (chain)\npicking this:\n  eval_tm \\<AA> is\n  \\<le> (2 ^ Length \\<AA> - 1) *\n        sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))\n  (2 ^ Length \\<AA> - 1) *\n  sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n  \\<le> eval_tm \\<AA> is\n  eval_tm \\<AA> is + 2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n  n - 2 ^ Suc (Length \\<AA>) * d", "have\n      *: \"n + h \\<le> 2 ^ ?l * (h + d')\" \"2 ^ ?l * (l + d') \\<le> n + l\""], ["proof (prove)\nusing this:\n  eval_tm \\<AA> is\n  \\<le> (2 ^ Length \\<AA> - 1) *\n        sum_list (concat (map (\\<lambda>i. if 0 < i then [i] else []) is))\n  (2 ^ Length \\<AA> - 1) *\n  sum_list (concat (map (\\<lambda>i. if i < 0 then [i] else []) is))\n  \\<le> eval_tm \\<AA> is\n  eval_tm \\<AA> is + 2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n  n - 2 ^ Suc (Length \\<AA>) * d\n\ngoal (1 subgoal):\n 1. n + h \\<le> 2 ^ Length \\<AA> * (h + d') &&&\n    2 ^ Length \\<AA> * (l + d') \\<le> n + l", "by (auto simp: algebra_simps h_def l_def d'_def)"], ["proof (state)\nthis:\n  n + h \\<le> 2 ^ Length \\<AA> * (h + d')\n  2 ^ Length \\<AA> * (l + d') \\<le> n + l\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "assume **: \"d' \\<notin> {min (- h) n..max (- l) n}\""], ["proof (state)\nthis:\n  d' \\<notin> {min (- h) n..max (- l) n}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  d' \\<notin> {min (- h) n..max (- l) n}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"0 \\<le> n + h\""], ["proof (state)\nthis:\n  0 \\<le> n + h\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "from order_trans[OF this *(1)]"], ["proof (chain)\npicking this:\n  0 \\<le> 2 ^ Length \\<AA> * (h + d')", "have \"0 \\<le> h + d'\""], ["proof (prove)\nusing this:\n  0 \\<le> 2 ^ Length \\<AA> * (h + d')\n\ngoal (1 subgoal):\n 1. 0 \\<le> h + d'", "unfolding zero_le_mult_iff"], ["proof (prove)\nusing this:\n  0 \\<le> 2 ^ Length \\<AA> \\<and> 0 \\<le> h + d' \\<or>\n  2 ^ Length \\<AA> \\<le> 0 \\<and> h + d' \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> h + d'", "using zero_less_power[of 2]"], ["proof (prove)\nusing this:\n  0 \\<le> 2 ^ Length \\<AA> \\<and> 0 \\<le> h + d' \\<or>\n  2 ^ Length \\<AA> \\<le> 0 \\<and> h + d' \\<le> 0\n  (0::?'a1) < (2::?'a1) \\<Longrightarrow> (0::?'a1) < (2::?'a1) ^ ?n\n\ngoal (1 subgoal):\n 1. 0 \\<le> h + d'", "by presburger"], ["proof (state)\nthis:\n  0 \\<le> h + d'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  0 \\<le> n + h \\<Longrightarrow> 0 \\<le> h + d'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  0 \\<le> n + h \\<Longrightarrow> 0 \\<le> h + d'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  0 \\<le> n + h \\<Longrightarrow> 0 \\<le> h + d'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"n + h < 0\""], ["proof (state)\nthis:\n  n + h < 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "with *(1)"], ["proof (chain)\npicking this:\n  n + h \\<le> 2 ^ Length \\<AA> * (h + d')\n  n + h < 0", "have \"n \\<le> d'\""], ["proof (prove)\nusing this:\n  n + h \\<le> 2 ^ Length \\<AA> * (h + d')\n  n + h < 0\n\ngoal (1 subgoal):\n 1. n \\<le> d'", "by (auto dest: order_trans[OF _ mult_right_mono_neg[of 1]])"], ["proof (state)\nthis:\n  n \\<le> d'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  n + h < 0 \\<Longrightarrow> n \\<le> d'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n + h < 0 \\<Longrightarrow> n \\<le> d'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  n + h < 0 \\<Longrightarrow> n \\<le> d'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"n + l < 0\""], ["proof (state)\nthis:\n  n + l < 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "from le_less_trans[OF *(2) this]"], ["proof (chain)\npicking this:\n  2 ^ Length \\<AA> * (l + d') < 0", "have \"l + d' < 0\""], ["proof (prove)\nusing this:\n  2 ^ Length \\<AA> * (l + d') < 0\n\ngoal (1 subgoal):\n 1. l + d' < 0", "unfolding mult_less_0_iff"], ["proof (prove)\nusing this:\n  0 < 2 ^ Length \\<AA> \\<and> l + d' < 0 \\<or>\n  2 ^ Length \\<AA> < 0 \\<and> 0 < l + d'\n\ngoal (1 subgoal):\n 1. l + d' < 0", "by auto"], ["proof (state)\nthis:\n  l + d' < 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  n + l < 0 \\<Longrightarrow> l + d' < 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n + l < 0 \\<Longrightarrow> l + d' < 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  n + l < 0 \\<Longrightarrow> l + d' < 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"0 \\<le> n + l\""], ["proof (state)\nthis:\n  0 \\<le> n + l\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 \\<le> n + l", "have \"0 \\<le> l + d'\""], ["proof (prove)\nusing this:\n  0 \\<le> n + l\n\ngoal (1 subgoal):\n 1. 0 \\<le> l + d'", "using ** calculation(1-2)"], ["proof (prove)\nusing this:\n  0 \\<le> n + l\n  d' \\<notin> {min (- h) n..max (- l) n}\n  0 \\<le> n + h \\<Longrightarrow> 0 \\<le> h + d'\n  n + h < 0 \\<Longrightarrow> n \\<le> d'\n\ngoal (1 subgoal):\n 1. 0 \\<le> l + d'", "by force"], ["proof (state)\nthis:\n  0 \\<le> l + d'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "with *(2)"], ["proof (chain)\npicking this:\n  2 ^ Length \\<AA> * (l + d') \\<le> n + l\n  0 \\<le> l + d'", "have \"d' \\<le> n\""], ["proof (prove)\nusing this:\n  2 ^ Length \\<AA> * (l + d') \\<le> n + l\n  0 \\<le> l + d'\n\ngoal (1 subgoal):\n 1. d' \\<le> n", "by (force dest: order_trans[OF mult_right_mono[of 1], rotated])"], ["proof (state)\nthis:\n  d' \\<le> n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  0 \\<le> n + l \\<Longrightarrow> d' \\<le> n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> n + h \\<Longrightarrow> 0 \\<le> h + d'\n  n + h < 0 \\<Longrightarrow> n \\<le> d'\n  n + l < 0 \\<Longrightarrow> l + d' < 0\n  0 \\<le> n + l \\<Longrightarrow> d' \\<le> n", "have \"min (- h) n \\<le> d'\" \"d' \\<le> max (- l) n\""], ["proof (prove)\nusing this:\n  0 \\<le> n + h \\<Longrightarrow> 0 \\<le> h + d'\n  n + h < 0 \\<Longrightarrow> n \\<le> d'\n  n + l < 0 \\<Longrightarrow> l + d' < 0\n  0 \\<le> n + l \\<Longrightarrow> d' \\<le> n\n\ngoal (1 subgoal):\n 1. min (- h) n \\<le> d' &&& d' \\<le> max (- l) n", "by (auto simp: min_def max_def)"], ["proof (state)\nthis:\n  min (- h) n \\<le> d'\n  d' \\<le> max (- l) n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\n 3. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<notin> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> False", "with **"], ["proof (chain)\npicking this:\n  d' \\<notin> {min (- h) n..max (- l) n}\n  min (- h) n \\<le> d'\n  d' \\<le> max (- l) n", "show False"], ["proof (prove)\nusing this:\n  d' \\<notin> {min (- h) n..max (- l) n}\n  min (- h) n \\<le> d'\n  d' \\<le> max (- l) n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is +\n                      2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n                      n - 2 ^ Suc (Length \\<AA>) * d\n 2. \\<lbrakk>True; length is = length x; #\\<^sub>V \\<AA> = length x;\n     length is = #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x;\n     d' \\<in> {min (- h) n..max (- l) n};\n     eval_tm \\<AA> is +\n     2 ^ Length \\<AA> * scalar_product (map of_bool x) is =\n     n - 2 ^ Suc (Length \\<AA>) * d\\<rbrakk>\n    \\<Longrightarrow> eval_tm \\<AA> is = n - 2 ^ Length \\<AA> * d'", "qed (auto simp: algebra_simps d'_def)"], ["proof (state)\nthis:\n  \\<AA> \\<Turnstile>\\<^sub>b rderiv0 x (presb.Eq is n d) =\n  SNOC x \\<AA> \\<Turnstile>0 presb.Eq is n d\n\ngoal:\nNo subgoals!", "qed"], ["", "declare [[goals_limit = 100]]"], ["", "global_interpretation Presb: Formula\n  where SUC = SUC and LESS = \"\\<lambda>_. (<)\" and Length = Length\n  and assigns = assigns and nvars = nvars and Extend = Extend and CONS = CONS and SNOC = SNOC\n  and extend = extend and size = size_atom and zero = zero and alphabet = \\<sigma> and eval = test_bit\n  and downshift = downshift and upshift = upshift and add = set_bit and cut = cut_bits and len = len\n  and restrict = \"\\<lambda>_ _. True\" and Restrict = \"\\<lambda>_ _. FBool True\" and lformula0 = lformula0\n  and FV0 = FV0 and find0 = find0 and wf0 = wf0 and decr0 = decr0 and satisfies0 = satisfies0\n  and nullable0 = nullable0 and lderiv0 = lderiv0 and rderiv0 = rderiv0\n  and TYPEVARS = undefined\n  defines norm = \"Formula_Operations.norm find0 decr0\"\n  and nFOr = \"Formula_Operations.nFOr :: formula \\<Rightarrow> _\"\n  and nFAnd = \"Formula_Operations.nFAnd :: formula \\<Rightarrow> _\"\n  and nFNot = \"Formula_Operations.nFNot find0 decr0 :: formula \\<Rightarrow> _\"\n  and nFEx = \"Formula_Operations.nFEx find0 decr0\"\n  and nFAll = \"Formula_Operations.nFAll find0 decr0\"\n  and decr = \"Formula_Operations.decr decr0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula \\<Rightarrow> _\"\n  and find = \"Formula_Operations.find find0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula \\<Rightarrow> _\"\n  and FV = \"Formula_Operations.FV FV0\"\n  and RESTR = \"Formula_Operations.RESTR (\\<lambda>_ _. FBool True) :: _ \\<Rightarrow> formula\"\n  and RESTRICT = \"Formula_Operations.RESTRICT (\\<lambda>_ _. FBool True) FV0\"\n  and deriv = \"\\<lambda>d0 (a :: atom) (\\<phi> :: formula). Formula_Operations.deriv extend d0 a \\<phi>\"\n  and nullable = \"\\<lambda>\\<phi> :: formula. Formula_Operations.nullable nullable0 \\<phi>\"\n  and fut_default = \"Formula.fut_default extend zero rderiv0\"\n  and fut = \"Formula.fut extend zero find0 decr0 rderiv0\"\n  and finalize = \"Formula.finalize SUC extend zero find0 decr0 rderiv0\"\n  and final = \"Formula.final SUC extend zero find0 decr0\n     nullable0 rderiv0 :: nat \\<Rightarrow> formula \\<Rightarrow> _\"\n  and presb_wf = \"Formula_Operations.wf SUC (wf0 :: nat \\<Rightarrow> presb \\<Rightarrow> _)\"\n  and presb_lformula = \"Formula_Operations.lformula (lformula0 :: presb \\<Rightarrow> _) :: formula \\<Rightarrow> _\"\n  and check_eqv = \"\\<lambda>idx. DAs.check_eqv\n    (\\<sigma> idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>) :: formula)\n    (\\<lambda>a \\<phi>. norm (deriv (lderiv0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula) (a :: atom) \\<phi>))\n    (final idx) (\\<lambda>\\<phi> :: formula. presb_wf idx \\<phi> \\<and> presb_lformula \\<phi>)\n    (\\<sigma> idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>) :: formula)\n    (\\<lambda>a \\<phi>. norm (deriv (lderiv0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula) (a :: atom) \\<phi>))\n    (final idx) (\\<lambda>\\<phi> :: formula. presb_wf idx \\<phi> \\<and> presb_lformula \\<phi>)\n    (=)\"\n  and bounded_check_eqv = \"\\<lambda>idx. DAs.check_eqv\n    (\\<sigma> idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>) :: formula)\n    (\\<lambda>a \\<phi>. norm (deriv (lderiv0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula) (a :: atom) \\<phi>))\n    nullable (\\<lambda>\\<phi> :: formula. presb_wf idx \\<phi> \\<and> presb_lformula \\<phi>)\n    (\\<sigma> idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>) :: formula)\n    (\\<lambda>a \\<phi>. norm (deriv (lderiv0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula) (a :: atom) \\<phi>))\n    nullable (\\<lambda>\\<phi> :: formula. presb_wf idx \\<phi> \\<and> presb_lformula \\<phi>)\n    (=)\"\n  and automaton = \"DA.automaton\n    (\\<lambda>a \\<phi>. norm (deriv lderiv0 (a :: atom) \\<phi> :: formula))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Formula (\\<lambda>_. Suc) (\\<lambda>_. (<)) assigns nvars Extend CONS\n     SNOC Length extend length (\\<lambda>n. replicate n False) \\<sigma>\n     test_bit downshift upshift set_bit cut_bits len (\\<lambda>_ _. True)\n     (\\<lambda>_ _. FBool True) lformula0 FV0 find0 wf0 decr0\n     (\\<Turnstile>0) nullable0 lderiv0 rderiv0", "by standard (auto simp: Presb_simps \\<sigma>_def set_n_lists distinct_n_lists\n    Formula_Operations.lformula.simps Formula_Operations.satisfies_gen.simps Formula_Operations.wf.simps\n    dest: satisfies0_cong split: presb.splits if_splits)"], ["", "(*Workaround for code generation*)"], ["", "lemma check_eqv_code[code]: \"check_eqv idx r s =\n  ((presb_wf idx r \\<and> presb_lformula r) \\<and> (presb_wf idx s \\<and> presb_lformula s) \\<and>\n  (case rtrancl_while (\\<lambda>(p, q). final idx p = final idx q)\n    (\\<lambda>(p, q). map (\\<lambda>a. (norm (deriv lderiv0 a p), norm (deriv lderiv0 a q))) (\\<sigma> idx))\n    (norm (RESTRICT r), norm (RESTRICT s)) of\n    None \\<Rightarrow> False\n  | Some ([], x) \\<Rightarrow> True\n  | Some (a # list, x) \\<Rightarrow> False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_eqv idx r s =\n    ((presb_wf idx r \\<and> presb_lformula r) \\<and>\n     (presb_wf idx s \\<and> presb_lformula s) \\<and>\n     (case rtrancl_while (\\<lambda>(p, q). final idx p = final idx q)\n            (\\<lambda>(p, q).\n                map (\\<lambda>a.\n                        (norm (deriv lderiv0 a p),\n                         norm (deriv lderiv0 a q)))\n                 (\\<sigma> idx))\n            (norm (RESTRICT r), norm (RESTRICT s)) of\n      None \\<Rightarrow> False | Some ([], x) \\<Rightarrow> True\n      | Some (a # list, x) \\<Rightarrow> False))", "unfolding check_eqv_def Presb.check_eqv_def Presb.step_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((presb_wf idx r \\<and> presb_lformula r) \\<and>\n     (presb_wf idx s \\<and> presb_lformula s) \\<and>\n     (case rtrancl_while (\\<lambda>(p, q). final idx p = final idx q)\n            (\\<lambda>(p, q).\n                map (\\<lambda>a.\n                        (norm (deriv lderiv0 a p),\n                         norm (deriv lderiv0 a q)))\n                 (\\<sigma> idx))\n            (norm (RESTRICT r), norm (RESTRICT s)) of\n      None \\<Rightarrow> False | Some ([], xa) \\<Rightarrow> True\n      | Some (a # list, xa) \\<Rightarrow> False)) =\n    ((presb_wf idx r \\<and> presb_lformula r) \\<and>\n     (presb_wf idx s \\<and> presb_lformula s) \\<and>\n     (case rtrancl_while (\\<lambda>(p, q). final idx p = final idx q)\n            (\\<lambda>(p, q).\n                map (\\<lambda>a.\n                        (norm (deriv lderiv0 a p),\n                         norm (deriv lderiv0 a q)))\n                 (\\<sigma> idx))\n            (norm (RESTRICT r), norm (RESTRICT s)) of\n      None \\<Rightarrow> False | Some ([], x) \\<Rightarrow> True\n      | Some (a # list, x) \\<Rightarrow> False))", ".."], ["", "definition while where [code del, code_abbrev]: \"while idx \\<phi> = while_default (fut_default idx \\<phi>)\""], ["", "declare while_default_code[of \"fut_default idx \\<phi>\" for idx \\<phi>, folded while_def, code]"], ["", "lemma check_eqv_sound: \n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> (Presb.sat \\<AA> \\<phi> \\<longleftrightarrow> Presb.sat \\<AA> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx; check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> Presb.sat \\<AA> \\<phi> = Presb.sat \\<AA> \\<psi>", "unfolding check_eqv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx;\n     Presb.check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> Presb.sat \\<AA> \\<phi> = Presb.sat \\<AA> \\<psi>", "by (rule Presb.check_eqv_soundness)"], ["", "lemma bounded_check_eqv_sound:\n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; bounded_check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> (Presb.sat\\<^sub>b \\<AA> \\<phi> \\<longleftrightarrow> Presb.sat\\<^sub>b \\<AA> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx;\n     bounded_check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> Presb.sat\\<^sub>b \\<AA> \\<phi> =\n                      Presb.sat\\<^sub>b \\<AA> \\<psi>", "unfolding bounded_check_eqv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx;\n     Presb.bounded.check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> Presb.sat\\<^sub>b \\<AA> \\<phi> =\n                      Presb.sat\\<^sub>b \\<AA> \\<psi>", "by (rule Presb.bounded_check_eqv_soundness)"], ["", "method_setup check_equiv = \\<open>\n  let\n    fun tac ctxt =\n      let\n        val conv = @{computation_check terms: Trueprop\n          \"0 :: nat\" \"1 :: nat\" \"2 :: nat\" \"3 :: nat\" Suc\n          \"plus :: nat \\<Rightarrow> _\" \"minus :: nat \\<Rightarrow> _\"\n          \"times :: nat \\<Rightarrow> _\" \"divide :: nat \\<Rightarrow> _\" \"modulo :: nat \\<Rightarrow> _\"\n          \"0 :: int\" \"1 :: int\" \"2 :: int\" \"3 :: int\" \"-1 :: int\"\n          check_eqv datatypes: formula \"int list\" integer bool} ctxt\n      in\n        CONVERSION (Conv.params_conv ~1 (K (Conv.concl_conv ~1 conv)) ctxt) THEN'\n        resolve_tac ctxt [TrueI]\n      end\n  in\n    Scan.succeed (SIMPLE_METHOD' o tac)\n  end\n\\<close>"], ["", "end"]]}