{"file_name": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives/WS1S_Presburger_Equivalence.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives", "problem_names": ["lemma letter_eq[dest]:\n  \"letter_eq idx n a b \\<Longrightarrow> (a \\<in> set (WS1S_Prelim.\\<sigma> idx)) = (b \\<in> set (Presburger_Formula.\\<sigma> n))\"", "lemma check_eqv_code[code]: \"check_eqv idx n r s \\<longleftrightarrow>\n  ((ws1s_wf idx r \\<and> ws1s_lformula r) \\<and> (presb_wf n s \\<and> presb_lformula s) \\<and>\n  (case rtrancl_while (\\<lambda>(p, q). final idx p = Presburger_Formula.final n q)\n  (\\<lambda>(p, q).\n    map (\\<lambda>(a, b). (norm (deriv lderiv0 a p),\n      Presburger_Formula.norm (Presburger_Formula.deriv Presburger_Formula.lderiv0 b q)))\n     [(x, y)\\<leftarrow>List.product (\\<sigma> idx) (Presburger_Formula.\\<sigma> n). letter_eq idx n x y])\n    (norm (RESTRICT r), Presburger_Formula.norm (Presburger_Formula.RESTRICT s)) of\n    None \\<Rightarrow> False\n  | Some ([], x) \\<Rightarrow> True\n  | Some (a # list, x) \\<Rightarrow> False))\""], "translations": [["", "lemma letter_eq[dest]:\n  \"letter_eq idx n a b \\<Longrightarrow> (a \\<in> set (WS1S_Prelim.\\<sigma> idx)) = (b \\<in> set (Presburger_Formula.\\<sigma> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. letter_eq idx n a b \\<Longrightarrow>\n    (a \\<in> set (WS1S_Prelim.\\<sigma> idx)) =\n    (b \\<in> set (Presburger_Formula.\\<sigma> n))", "by transfer (force simp: Presburger_Formula.\\<sigma>_def set_n_lists image_iff)"], ["", "global_interpretation WS1S_Presb: DAs\n  \"WS1S_Prelim.\\<sigma> idx\"\n  \"(\\<lambda>\\<phi>. norm (RESTRICT \\<phi>) :: (ws1s, order) aformula)\"\n  \"(\\<lambda>a \\<phi>. norm (deriv lderiv0 (a :: atom) \\<phi>))\"\n  \"(WS1S.final idx)\"\n  \"(\\<lambda>\\<phi> :: formula. ws1s_wf idx \\<phi> \\<and> ws1s_lformula \\<phi>)\"\n  \"\\<lambda>\\<phi>. Formula.lang WS1S_Prelim.nvars\n     WS1S_Prelim.Extend WS1S_Prelim.CONS WS1S_Prelim.Length WS1S_Prelim.size_atom\n     WS1S_Formula.satisfies0 idx \\<phi>\"\n  \"(\\<lambda>\\<phi> :: formula. ws1s_wf idx \\<phi> \\<and> ws1s_lformula \\<phi>)\"\n  \"\\<lambda>\\<phi>. Formula.language WS1S_Prelim.assigns\n     WS1S_Prelim.nvars WS1S_Prelim.Extend WS1S_Prelim.CONS\n     WS1S_Prelim.Length WS1S_Prelim.size_atom restrict WS1S_Formula.FV0\n     WS1S_Formula.satisfies0 idx \\<phi>\"\n  \"(Presburger_Formula.\\<sigma> n)\"\n  \"(\\<lambda>\\<phi>. Presburger_Formula.norm (Presburger_Formula.RESTRICT \\<phi>))\"\n  \"(\\<lambda>a \\<phi>. Presburger_Formula.norm (Presburger_Formula.deriv Presburger_Formula.lderiv0 a \\<phi>))\"\n  \"(Presburger_Formula.final n)\"\n  \"(\\<lambda>\\<phi>. presb_wf n \\<phi> \\<and> presb_lformula \\<phi>)\"\n  \"(\\<lambda>\\<phi>. Formula.lang Presburger_Formula.nvars\n            Presburger_Formula.Extend Presburger_Formula.CONS Presburger_Formula.Length\n            Presburger_Formula.size_atom (\\<Turnstile>0) n \\<phi>)\"\n  \"(\\<lambda>\\<phi>. presb_wf n \\<phi> \\<and> presb_lformula \\<phi>)\"\n  \"(\\<lambda>\\<phi>. Formula.language Presburger_Formula.assigns\n            Presburger_Formula.nvars Presburger_Formula.Extend Presburger_Formula.CONS\n            Presburger_Formula.Length Presburger_Formula.size_atom (\\<lambda>_ _. True)\n            Presburger_Formula.FV0 (\\<Turnstile>0)\n            n \\<phi>)\"\n  \"letter_eq idx n\"\n  defines check_eqv = \"\\<lambda>idx n. DAs.check_eqv\n    (\\<sigma> idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>) :: (ws1s, order) aformula)\n    (\\<lambda>a \\<phi>. norm (deriv (lderiv0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula) (a :: atom) \\<phi>))\n    (final idx) (\\<lambda>\\<phi> :: formula. ws1s_wf idx \\<phi> \\<and> ws1s_lformula \\<phi>)\n    (Presburger_Formula.\\<sigma> n) (\\<lambda>\\<phi>. Presburger_Formula.norm (Presburger_Formula.RESTRICT \\<phi>))\n    (\\<lambda>a \\<phi>. Presburger_Formula.norm (Presburger_Formula.deriv Presburger_Formula.lderiv0 a \\<phi>))\n    (Presburger_Formula.final n) (\\<lambda>\\<phi>. presb_wf n \\<phi> \\<and> presb_lformula \\<phi>) (letter_eq idx n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DAs (WS1S_Prelim.\\<sigma> idx)\n     (\\<lambda>\\<phi>. WS1S_Formula.norm (WS1S_Formula.RESTRICT \\<phi>))\n     (\\<lambda>a \\<phi>.\n         WS1S_Formula.norm\n          (WS1S_Formula.deriv WS1S_Formula.lderiv0 a \\<phi>))\n     (WS1S_Formula.final idx)\n     (\\<lambda>\\<phi>. ws1s_wf idx \\<phi> \\<and> ws1s_lformula \\<phi>)\n     (WS1S.lang idx)\n     (\\<lambda>\\<phi>. ws1s_wf idx \\<phi> \\<and> ws1s_lformula \\<phi>)\n     (WS1S.language idx) (Presburger_Formula.\\<sigma> n)\n     (\\<lambda>\\<phi>.\n         Presburger_Formula.norm (Presburger_Formula.RESTRICT \\<phi>))\n     (\\<lambda>a \\<phi>.\n         Presburger_Formula.norm\n          (Presburger_Formula.deriv Presburger_Formula.lderiv0 a \\<phi>))\n     (Presburger_Formula.final n)\n     (\\<lambda>\\<phi>. presb_wf n \\<phi> \\<and> presb_lformula \\<phi>)\n     (Presb.lang n)\n     (\\<lambda>\\<phi>. presb_wf n \\<phi> \\<and> presb_lformula \\<phi>)\n     (Presb.language n) (letter_eq idx n)", "by unfold_locales auto"], ["", "(*Workaround for code generation*)"], ["", "lemma check_eqv_code[code]: \"check_eqv idx n r s \\<longleftrightarrow>\n  ((ws1s_wf idx r \\<and> ws1s_lformula r) \\<and> (presb_wf n s \\<and> presb_lformula s) \\<and>\n  (case rtrancl_while (\\<lambda>(p, q). final idx p = Presburger_Formula.final n q)\n  (\\<lambda>(p, q).\n    map (\\<lambda>(a, b). (norm (deriv lderiv0 a p),\n      Presburger_Formula.norm (Presburger_Formula.deriv Presburger_Formula.lderiv0 b q)))\n     [(x, y)\\<leftarrow>List.product (\\<sigma> idx) (Presburger_Formula.\\<sigma> n). letter_eq idx n x y])\n    (norm (RESTRICT r), Presburger_Formula.norm (Presburger_Formula.RESTRICT s)) of\n    None \\<Rightarrow> False\n  | Some ([], x) \\<Rightarrow> True\n  | Some (a # list, x) \\<Rightarrow> False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WS1S_Presburger_Equivalence.check_eqv idx n r s =\n    ((ws1s_wf idx r \\<and> ws1s_lformula r) \\<and>\n     (presb_wf n s \\<and> presb_lformula s) \\<and>\n     (case WS1S_Presb.closure idx n\n            (WS1S_Formula.norm (WS1S_Formula.RESTRICT r),\n             Presburger_Formula.norm (Presburger_Formula.RESTRICT s)) of\n      None \\<Rightarrow> False | Some ([], x) \\<Rightarrow> True\n      | Some (a # list, x) \\<Rightarrow> False))", "unfolding check_eqv_def WS1S_Presb.check_eqv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ws1s_wf idx r \\<and> ws1s_lformula r) \\<and>\n     (presb_wf n s \\<and> presb_lformula s) \\<and>\n     (case WS1S_Presb.closure idx n\n            (WS1S_Formula.norm (WS1S_Formula.RESTRICT r),\n             Presburger_Formula.norm (Presburger_Formula.RESTRICT s)) of\n      None \\<Rightarrow> False | Some ([], xa) \\<Rightarrow> True\n      | Some (a # list, xa) \\<Rightarrow> False)) =\n    ((ws1s_wf idx r \\<and> ws1s_lformula r) \\<and>\n     (presb_wf n s \\<and> presb_lformula s) \\<and>\n     (case WS1S_Presb.closure idx n\n            (WS1S_Formula.norm (WS1S_Formula.RESTRICT r),\n             Presburger_Formula.norm (Presburger_Formula.RESTRICT s)) of\n      None \\<Rightarrow> False | Some ([], x) \\<Rightarrow> True\n      | Some (a # list, x) \\<Rightarrow> False))", ".."], ["", "method_setup check_equiv = \\<open>\n  let\n    fun tac ctxt =\n      let\n        val conv = @{computation_check terms: Trueprop\n          \"0 :: nat\" \"1 :: nat\" \"2 :: nat\" \"3 :: nat\" Suc\n          \"plus :: nat \\<Rightarrow> _\" \"minus :: nat \\<Rightarrow> _\"\n          \"times :: nat \\<Rightarrow> _\" \"divide :: nat \\<Rightarrow> _\" \"modulo :: nat \\<Rightarrow> _\"\n          \"0 :: int\" \"1 :: int\" \"2 :: int\" \"3 :: int\" \"-1 :: int\"\n          check_eqv datatypes: idx \"(presb, unit) aformula\" \"((nat, nat) atomic, WS1S_Prelim.order) aformula\"\n          \"nat \\<times> nat\" \"nat option\" \"bool option\" \"int list\" integer} ctxt\n      in\n        CONVERSION (Conv.params_conv ~1 (K (Conv.concl_conv ~1 conv)) ctxt) THEN'\n        resolve_tac ctxt [TrueI]\n      end\n  in\n    Scan.succeed (SIMPLE_METHOD' o tac)\n  end\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}