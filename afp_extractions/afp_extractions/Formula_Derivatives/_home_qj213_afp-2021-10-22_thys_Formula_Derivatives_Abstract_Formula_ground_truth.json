{"file_name": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives/Abstract_Formula.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives", "problem_names": ["lemma pred_Diff_0[simp]: \"0 \\<notin> A \\<Longrightarrow> i \\<in> (\\<lambda>x. x - Suc 0) ` A \\<longleftrightarrow> Suc i \\<in> A\"", "lemma funpow_cycle_mult: \"(f ^^ k) x = x \\<Longrightarrow> (f ^^ (m * k)) x = x\"", "lemma funpow_cycle: \"(f ^^ k) x = x \\<Longrightarrow> (f ^^ l) x = (f ^^ (l mod k)) x\"", "lemma funpow_cycle_offset:\n  fixes f :: \"'a \\<Rightarrow> 'a\"\n  assumes \"(f ^^ k) x = (f ^^ i) x\" \"i \\<le> k\" \"i \\<le> l\"\n  shows \"(f ^^ l) x = (f ^^ ((l - i) mod (k - i) + i)) x\"", "lemma in_set_tlD: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\"", "lemma finite_juncts[simp]: \"finite (disjuncts \\<phi>)\" \"finite (conjuncts \\<phi>)\"\n  and nonempty_juncts[simp]: \"disjuncts \\<phi> \\<noteq> {}\" \"conjuncts \\<phi> \\<noteq> {}\"", "lemma juncts_eq_set_juncts_list:\n  \"disjuncts \\<phi> = set (disjuncts_list \\<phi>)\"\n  \"conjuncts \\<phi> = set (conjuncts_list \\<phi>)\"", "lemma notin_juncts:\n  \"\\<lbrakk>\\<psi> \\<in> disjuncts \\<phi>; is_FOr \\<psi>\\<rbrakk> \\<Longrightarrow> False\"\n  \"\\<lbrakk>\\<psi> \\<in> conjuncts \\<phi>; is_FAnd \\<psi>\\<rbrakk> \\<Longrightarrow> False\"", "lemma juncts_list_singleton:\n  \"\\<not> is_FOr \\<phi> \\<Longrightarrow> disjuncts_list \\<phi> = [\\<phi>]\"\n  \"\\<not> is_FAnd \\<phi> \\<Longrightarrow> conjuncts_list \\<phi> = [\\<phi>]\"", "lemma juncts_singleton:\n  \"\\<not> is_FOr \\<phi> \\<Longrightarrow> disjuncts \\<phi> = {\\<phi>}\"\n  \"\\<not> is_FAnd \\<phi> \\<Longrightarrow> conjuncts \\<phi> = {\\<phi>}\"", "lemma nonempty_juncts_list: \"conjuncts_list \\<phi> \\<noteq> []\" \"disjuncts_list \\<phi> \\<noteq> []\"", "lemma nf_ACI_D:\n  \"nf_ACI \\<phi> \\<Longrightarrow> sorted (disjuncts_list \\<phi>)\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> sorted (conjuncts_list \\<phi>)\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> distinct (disjuncts_list \\<phi>)\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> distinct (conjuncts_list \\<phi>)\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> list_all nf_ACI (disjuncts_list \\<phi>)\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> list_all nf_ACI (conjuncts_list \\<phi>)\"", "lemma disjuncts_list_nFOR:\n  \"\\<lbrakk>list_all (\\<lambda>x. \\<not> is_FOr x) \\<phi>s; \\<phi>s \\<noteq> []\\<rbrakk> \\<Longrightarrow> disjuncts_list (nFOR \\<phi>s) = \\<phi>s\"", "lemma conjuncts_list_nFAND:\n  \"\\<lbrakk>list_all (\\<lambda>x. \\<not> is_FAnd x) \\<phi>s; \\<phi>s \\<noteq> []\\<rbrakk> \\<Longrightarrow> conjuncts_list (nFAND \\<phi>s) = \\<phi>s\"", "lemma disjuncts_NFOR:\n  \"\\<lbrakk>finite X; X \\<noteq> {}; \\<forall>x \\<in> X. \\<not> is_FOr x\\<rbrakk> \\<Longrightarrow> disjuncts (NFOR X) = X\"", "lemma conjuncts_NFAND:\n  \"\\<lbrakk>finite X; X \\<noteq> {}; \\<forall>x \\<in> X. \\<not> is_FAnd x\\<rbrakk> \\<Longrightarrow> conjuncts (NFAND X) = X\"", "lemma nf_ACI_nFOR: \n  \"\\<lbrakk>sorted \\<phi>s; distinct \\<phi>s; list_all nf_ACI \\<phi>s; list_all (\\<lambda>x. \\<not> is_FOr x) \\<phi>s\\<rbrakk> \\<Longrightarrow> nf_ACI (nFOR \\<phi>s)\"", "lemma nf_ACI_nFAND: \n  \"\\<lbrakk>sorted \\<phi>s; distinct \\<phi>s; list_all nf_ACI \\<phi>s; list_all (\\<lambda>x. \\<not> is_FAnd x) \\<phi>s\\<rbrakk> \\<Longrightarrow> nf_ACI (nFAND \\<phi>s)\"", "lemma nf_ACI_juncts:\n  \"\\<lbrakk>\\<psi> \\<in> disjuncts \\<phi>; nf_ACI \\<phi>\\<rbrakk> \\<Longrightarrow> nf_ACI \\<psi>\"\n  \"\\<lbrakk>\\<psi> \\<in> conjuncts \\<phi>; nf_ACI \\<phi>\\<rbrakk> \\<Longrightarrow> nf_ACI \\<psi>\"", "lemma nf_ACI_norm_ACI: \"nf_ACI \\<langle>\\<phi>\\<rangle>\"", "lemma nFOR_Cons: \"nFOR (x # xs) = (if xs = [] then x else FOr x (nFOR xs))\"", "lemma nFAND_Cons: \"nFAND (x # xs) = (if xs = [] then x else FAnd x (nFAND xs))\"", "lemma nFOR_disjuncts: \"nf_ACI \\<psi> \\<Longrightarrow> nFOR (disjuncts_list \\<psi>) = \\<psi>\"", "lemma nFAND_conjuncts: \"nf_ACI \\<psi> \\<Longrightarrow> nFAND (conjuncts_list \\<psi>) = \\<psi>\"", "lemma NFOR_disjuncts: \"nf_ACI \\<psi> \\<Longrightarrow> NFOR (disjuncts \\<psi>) = \\<psi>\"", "lemma NFAND_conjuncts: \"nf_ACI \\<psi> \\<Longrightarrow> NFAND (conjuncts \\<psi>) = \\<psi>\"", "lemma norm_ACI_if_nf_ACI: \"nf_ACI \\<phi> \\<Longrightarrow> \\<langle>\\<phi>\\<rangle> = \\<phi>\"", "lemma norm_ACI_idem: \"\\<langle>\\<langle>\\<phi>\\<rangle>\\<rangle> = \\<langle>\\<phi>\\<rangle>\"", "lemma norm_ACI_juncts:\n  \"nf_ACI \\<phi> \\<Longrightarrow> norm_ACI ` disjuncts \\<phi> = disjuncts \\<phi>\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> norm_ACI ` conjuncts \\<phi> = conjuncts \\<phi>\"", "lemma\n  norm_ACI_NFOR: \"nf_ACI \\<phi> \\<Longrightarrow> \\<phi> = NFOR (norm_ACI ` disjuncts \\<phi>)\" and\n  norm_ACI_NFAND: \"nf_ACI \\<phi> \\<Longrightarrow> \\<phi> = NFAND (norm_ACI ` conjuncts \\<phi>)\"", "lemma fold_deriv_FBool: \"fold (deriv d0) xs (FBool b) = FBool b\"", "lemma fold_deriv_FNot:\n  \"fold (deriv d0) xs (FNot \\<phi>) = FNot (fold (deriv d0) xs \\<phi>)\"", "lemma fold_deriv_FOr:\n  \"fold (deriv d0) xs (FOr \\<phi> \\<psi>) = FOr (fold (deriv d0) xs \\<phi>) (fold (deriv d0) xs \\<psi>)\"", "lemma fold_deriv_FAnd:\n  \"fold (deriv d0) xs (FAnd \\<phi> \\<psi>) = FAnd (fold (deriv d0) xs \\<phi>) (fold (deriv d0) xs \\<psi>)\"", "lemma fold_deriv_FEx:\n  \"{\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> | xs. True} \\<subseteq>\n    {FEx k \\<psi> | \\<psi>. nf_ACI \\<psi> \\<and> disjuncts \\<psi> \\<subseteq> (\\<Union>xs. disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}\"", "lemma fold_deriv_FAll:\n  \"{\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> | xs. True} \\<subseteq>\n    {FAll k \\<psi> | \\<psi>. nf_ACI \\<psi> \\<and> conjuncts \\<psi> \\<subseteq> (\\<Union>xs. conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}\"", "lemma finite_norm_ACI_juncts:\n  fixes f :: \"('a, 'k) aformula \\<Rightarrow> ('a, 'k) aformula\"\n  shows \"finite B \\<Longrightarrow> finite {f \\<phi> | \\<phi>. nf_ACI \\<phi> \\<and> disjuncts \\<phi> \\<subseteq> B}\"\n        \"finite B \\<Longrightarrow> finite {f \\<phi> | \\<phi>. nf_ACI \\<phi> \\<and> conjuncts \\<phi> \\<subseteq> B}\"", "lemma satisfies_eqI:\n  \"\\<lbrakk>wf (#\\<^sub>V \\<AA>) \\<phi>; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>; \\<And>m k. LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow> m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k; lformula \\<phi>\\<rbrakk> \\<Longrightarrow>\n   \\<AA> \\<Turnstile> \\<phi> \\<longleftrightarrow> \\<BB> \\<Turnstile> \\<phi>\"", "lemma wf_decr:\n  \"\\<lbrakk>wf (SUC k idx) \\<phi>; LEQ k l idx; \\<not> find k l \\<phi>\\<rbrakk> \\<Longrightarrow> wf idx (decr k l \\<phi>)\"", "lemma lformula_decr:\n  \"lformula \\<phi> \\<Longrightarrow> lformula (decr k l \\<phi>)\"", "lemma Extend_satisfies_decr:\n  \"\\<lbrakk>\\<not> find k i \\<phi>; LEQ k i (#\\<^sub>V \\<AA>); lformula \\<phi>\\<rbrakk> \\<Longrightarrow> Extend k i \\<AA> P \\<Turnstile> \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> decr k i \\<phi>\"", "lemma LEQ_SUC: \"k \\<noteq> k' \\<Longrightarrow> LEQ k i (SUC k' idx) = LEQ k i idx\"", "lemma Extend_satisfies_bounded_decr:\n  \"\\<lbrakk>\\<not> find k i \\<phi>; LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk> \\<Longrightarrow>\n   Extend k i \\<AA> P \\<Turnstile>\\<^sub>b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>\"", "lemma wf_nFOr:\n  \"wf idx (FOr \\<phi> \\<psi>) \\<Longrightarrow> wf idx (nFOr \\<phi> \\<psi>)\"", "lemma wf_nFAnd:\n  \"wf idx (FAnd \\<phi> \\<psi>) \\<Longrightarrow> wf idx (nFAnd \\<phi> \\<psi>)\"", "lemma wf_nFEx:\n  \"wf idx (FEx b \\<phi>) \\<Longrightarrow> wf idx (nFEx b \\<phi>)\"", "lemma wf_nFAll:\n  \"wf idx (FAll b \\<phi>) \\<Longrightarrow> wf idx (nFAll b \\<phi>)\"", "lemma wf_nFNot:\n  \"wf idx (FNot \\<phi>) \\<Longrightarrow> wf idx (nFNot \\<phi>)\"", "lemma wf_norm: \"wf idx \\<phi> \\<Longrightarrow> wf idx (norm \\<phi>)\"", "lemma lformula_nFOr:\n  \"lformula (FOr \\<phi> \\<psi>) \\<Longrightarrow> lformula (nFOr \\<phi> \\<psi>)\"", "lemma lformula_nFAnd:\n  \"lformula (FAnd \\<phi> \\<psi>) \\<Longrightarrow> lformula (nFAnd \\<phi> \\<psi>)\"", "lemma lformula_nFEx:\n  \"lformula (FEx b \\<phi>) \\<Longrightarrow> lformula (nFEx b \\<phi>)\"", "lemma lformula_nFAll:\n  \"lformula (FAll b \\<phi>) \\<Longrightarrow> lformula (nFAll b \\<phi>)\"", "lemma lformula_nFNot:\n  \"lformula (FNot \\<phi>) \\<Longrightarrow> lformula (nFNot \\<phi>)\"", "lemma lformula_norm: \"lformula \\<phi> \\<Longrightarrow> lformula (norm \\<phi>)\"", "lemma satisfies_nFOr:\n  \"\\<AA> \\<Turnstile> nFOr \\<phi> \\<psi> \\<longleftrightarrow> \\<AA> \\<Turnstile> FOr \\<phi> \\<psi>\"", "lemma satisfies_nFAnd:\n  \"\\<AA> \\<Turnstile> nFAnd \\<phi> \\<psi> \\<longleftrightarrow> \\<AA> \\<Turnstile> FAnd \\<phi> \\<psi>\"", "lemma satisfies_nFEx: \"lformula \\<phi> \\<Longrightarrow> \\<AA> \\<Turnstile> nFEx b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> FEx b \\<phi>\"", "lemma satisfies_nFAll: \"lformula \\<phi> \\<Longrightarrow> \\<AA> \\<Turnstile> nFAll b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> FAll b \\<phi>\"", "lemma satisfies_nFNot:\n  \"lformula \\<phi> \\<Longrightarrow> \\<AA> \\<Turnstile> nFNot \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> FNot \\<phi>\"", "lemma satisfies_norm: \"lformula \\<phi> \\<Longrightarrow> \\<AA> \\<Turnstile> norm \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> \\<phi>\"", "lemma satisfies_bounded_nFOr:\n  \"\\<AA> \\<Turnstile>\\<^sub>b nFOr \\<phi> \\<psi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b FOr \\<phi> \\<psi>\"", "lemma satisfies_bounded_nFAnd:\n  \"\\<AA> \\<Turnstile>\\<^sub>b nFAnd \\<phi> \\<psi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b FAnd \\<phi> \\<psi>\"", "lemma len_cut_0: \"len (cut 0 P) = 0\"", "lemma satisfies_bounded_nFEx: \"\\<AA> \\<Turnstile>\\<^sub>b nFEx b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b FEx b \\<phi>\"", "lemma satisfies_bounded_nFAll: \"\\<AA> \\<Turnstile>\\<^sub>b nFAll b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b FAll b \\<phi>\"", "lemma satisfies_bounded_nFNot:\n  \"\\<AA> \\<Turnstile>\\<^sub>b nFNot \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>\"", "lemma satisfies_bounded_norm: \"\\<AA> \\<Turnstile>\\<^sub>b norm \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\"", "lemma wf_lderiv:\n  \"\\<lbrakk>wf idx \\<phi>; lformula \\<phi>\\<rbrakk> \\<Longrightarrow> wf idx (lderiv x \\<phi>)\"", "lemma lformula_lderiv:\n  \"lformula \\<phi> \\<Longrightarrow> lformula (lderiv x \\<phi>)\"", "lemma wf_rderiv:\n  \"wf idx \\<phi> \\<Longrightarrow> wf idx (rderiv x \\<phi>)\"", "theorem satisfies_lderiv:\n  \"\\<lbrakk>wf (#\\<^sub>V \\<AA>) \\<phi>; #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile> lderiv x \\<phi> \\<longleftrightarrow> CONS x \\<AA> \\<Turnstile> \\<phi>\"", "theorem satisfies_bounded_lderiv:\n  \"\\<lbrakk>wf (#\\<^sub>V \\<AA>) \\<phi>; #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi> \\<longleftrightarrow> CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\"", "theorem satisfies_bounded_rderiv:\n  \"\\<lbrakk>wf (#\\<^sub>V \\<AA>) \\<phi>; #\\<^sub>V \\<AA> = size x\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi> \\<longleftrightarrow> SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\"", "lemma wf_norm_rderivs: \"wf idx \\<phi> \\<Longrightarrow> wf idx (((norm \\<circ> rderiv (zero idx)) ^^ k) \\<phi>)\"", "lemma finite_fold_deriv:\n  assumes \"(d0 = lderiv0 \\<and> lformula \\<phi>) \\<or> d0 = rderiv0\"\n  shows \"finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> | xs. True}\"", "lemma lformula_nFOR: \"lformula (nFOR \\<phi>s) = (\\<forall>\\<phi> \\<in> set \\<phi>s. lformula \\<phi>)\"", "lemma lformula_nFAND: \"lformula (nFAND \\<phi>s) = (\\<forall>\\<phi> \\<in> set \\<phi>s. lformula \\<phi>)\"", "lemma lformula_NFOR: \"finite \\<Phi> \\<Longrightarrow> lformula (NFOR \\<Phi>) = (\\<forall>\\<phi> \\<in> \\<Phi>. lformula \\<phi>)\"", "lemma lformula_NFAND: \"finite \\<Phi> \\<Longrightarrow> lformula (NFAND \\<Phi>) = (\\<forall>\\<phi> \\<in> \\<Phi>. lformula \\<phi>)\"", "lemma lformula_disjuncts: \"(\\<forall>\\<psi> \\<in> disjuncts \\<phi>. lformula \\<psi>) = lformula \\<phi>\"", "lemma lformula_conjuncts: \"(\\<forall>\\<psi> \\<in> conjuncts \\<phi>. lformula \\<psi>) = lformula \\<phi>\"", "lemma lformula_norm_ACI: \"lformula \\<langle>\\<phi>\\<rangle> = lformula \\<phi>\"", "theorem\n  finite_fold_lderiv: \"lformula \\<phi> \\<Longrightarrow> finite {\\<langle>fold lderiv xs \\<langle>\\<phi>\\<rangle>\\<rangle> | xs. True}\" and\n  finite_fold_rderiv: \"finite {\\<langle>fold rderiv xs \\<langle>\\<phi>\\<rangle>\\<rangle> | xs. True}\"", "lemma wf_nFOR: \"wf idx (nFOR \\<phi>s) \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> set \\<phi>s. wf idx \\<phi>)\"", "lemma wf_nFAND: \"wf idx (nFAND \\<phi>s) \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> set \\<phi>s. wf idx \\<phi>)\"", "lemma wf_NFOR: \"finite \\<Phi> \\<Longrightarrow> wf idx (NFOR \\<Phi>) \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> \\<Phi>. wf idx \\<phi>)\"", "lemma wf_NFAND: \"finite \\<Phi> \\<Longrightarrow> wf idx (NFAND \\<Phi>) \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> \\<Phi>. wf idx \\<phi>)\"", "lemma satisfies_bounded_nFOR: \"\\<AA> \\<Turnstile>\\<^sub>b nFOR \\<phi>s \\<longleftrightarrow> (\\<exists>\\<phi> \\<in> set \\<phi>s. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\"", "lemma satisfies_bounded_nFAND: \"\\<AA> \\<Turnstile>\\<^sub>b nFAND \\<phi>s \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> set \\<phi>s. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\"", "lemma satisfies_bounded_NFOR: \"finite \\<Phi> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b NFOR \\<Phi> \\<longleftrightarrow> (\\<exists>\\<phi> \\<in> \\<Phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\"", "lemma satisfies_bounded_NFAND: \"finite \\<Phi> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b NFAND \\<Phi> \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> \\<Phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\"", "lemma wf_juncts:\n  \"wf idx \\<phi> \\<longleftrightarrow> (\\<forall>\\<psi> \\<in> disjuncts \\<phi>. wf idx \\<psi>)\"\n  \"wf idx \\<phi> \\<longleftrightarrow> (\\<forall>\\<psi> \\<in> conjuncts \\<phi>. wf idx \\<psi>)\"", "lemma wf_norm_ACI: \"wf idx \\<langle>\\<phi>\\<rangle> = wf idx \\<phi>\"", "lemma satisfies_bounded_disjuncts:\n  \"\\<AA> \\<Turnstile>\\<^sub>b \\<phi> \\<longleftrightarrow> (\\<exists>\\<psi> \\<in> disjuncts \\<phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<psi>)\"", "lemma satisfies_bounded_conjuncts:\n  \"\\<AA> \\<Turnstile>\\<^sub>b \\<phi> \\<longleftrightarrow> (\\<forall>\\<psi> \\<in> conjuncts \\<phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<psi>)\"", "lemma satisfies_bounded_norm_ACI: \"\\<AA> \\<Turnstile>\\<^sub>b \\<langle>\\<phi>\\<rangle> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\"", "lemma nvars_SNOCs: \"#\\<^sub>V ((SNOC x^^k) \\<AA>) = #\\<^sub>V \\<AA>\"", "lemma wf_fold_rderiv: \"wf idx \\<phi> \\<Longrightarrow> wf idx (fold rderiv (replicate k x) \\<phi>)\"", "lemma satisfies_bounded_fold_rderiv:\n  \"\\<lbrakk>wf idx \\<phi>; #\\<^sub>V \\<AA> = idx; size x = idx\\<rbrakk> \\<Longrightarrow>\n     \\<AA> \\<Turnstile>\\<^sub>b fold rderiv (replicate k x) \\<phi> \\<longleftrightarrow> (SNOC x^^k) \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\"", "lemma fut_derivs_Suc[simp]: \"norm (rderiv (zero idx) (fut_derivs k \\<phi>)) = fut_derivs (Suc k) \\<phi>\"", "lemma finite_fold_rderiv_zeros: \"finite {\\<langle>fold rderiv (replicate k (zero idx)) \\<langle>\\<psi>\\<rangle>\\<rangle> | k. True}\"", "lemma wf_fut_derivs:\n  \"wf idx (fut_derivs k \\<psi>)\"", "lemma satisfies_bounded_fut_derivs:\n  \"#\\<^sub>V \\<AA> = idx \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b fut_derivs k \\<psi> \\<longleftrightarrow> (SNOC (zero idx)^^k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>\"", "lemma fut_init: \"fut_invariant (\\<psi>, [])\"", "lemma fut_spec_default: \"fut_spec fut_default\"", "lemma fut_invariant: \"fut_invariant \\<phi>\\<Phi> \\<Longrightarrow> fut_test \\<phi>\\<Phi> \\<Longrightarrow> fut_invariant (fut_step \\<phi>\\<Phi>)\"", "lemma fut_terminate: \"fut_invariant \\<phi>\\<Phi> \\<Longrightarrow> \\<not> fut_test \\<phi>\\<Phi> \\<Longrightarrow> fut_spec \\<phi>\\<Phi>\"", "lemma fut_spec_while_default:\n  \"fut_spec (while_default fut_default fut_test fut_step (\\<psi>, []))\"", "lemma wf_fut: \"wf idx fut\"", "lemma satisfies_bounded_fut:\n  assumes \"#\\<^sub>V \\<AA> = idx\"\n  shows \"\\<AA> \\<Turnstile>\\<^sub>b fut \\<longleftrightarrow>\n    (if b then (\\<exists>k. (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>) else (\\<forall>k. (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>))\"", "lemma wf_finalize: \"wf idx \\<phi> \\<Longrightarrow> wf idx (finalize idx \\<phi>)\"", "lemma Length_SNOCs: \"Length ((SNOC x ^^ i) \\<AA>) = Length \\<AA> + i\"", "lemma assigns_SNOCs_zero:\n  \"\\<lbrakk>LESS k m (#\\<^sub>V \\<AA>); #\\<^sub>V \\<AA> = idx\\<rbrakk>  \\<Longrightarrow> m\\<^bsup>(SNOC (zero idx) ^^ i) \\<AA>\\<^esup>k = m\\<^bsup>\\<AA>\\<^esup>k\"", "lemma Extend_SNOCs_zero_satisfies: \"\\<lbrakk>wf (SUC k idx) \\<phi>; #\\<^sub>V \\<AA> = idx; lformula \\<phi>\\<rbrakk> \\<Longrightarrow>\n  Extend k 0 ((SNOC (zero (#\\<^sub>V \\<AA>)) ^^ i) \\<AA>) P \\<Turnstile> \\<phi> \\<longleftrightarrow> Extend k 0 \\<AA> P \\<Turnstile> \\<phi>\"", "lemma finalize_satisfies: \"\\<lbrakk>wf idx \\<phi>; #\\<^sub>V \\<AA> = idx; lformula \\<phi>\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b finalize idx \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> \\<phi>\"", "lemma Extend_empty_satisfies0:\n  \"\\<lbrakk>Length \\<AA> = 0; len P = 0\\<rbrakk> \\<Longrightarrow> Extend k i \\<AA> P \\<Turnstile>\\<^sub>0 a \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>0 a\"", "lemma Extend_empty_satisfies_bounded:\n  \"\\<lbrakk>Length \\<AA> = 0; len P = 0\\<rbrakk> \\<Longrightarrow> Extend k 0 \\<AA> P \\<Turnstile>\\<^sub>b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\"", "lemma nullable_satisfies_bounded: \"Length \\<AA> = 0 \\<Longrightarrow> nullable \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\"", "lemma final_satisfies:\n  \"\\<lbrakk>wf idx \\<phi> \\<and> lformula \\<phi>; Length \\<AA> = 0; #\\<^sub>V \\<AA> = idx\\<rbrakk> \\<Longrightarrow> final idx \\<phi> = (\\<AA> \\<Turnstile> \\<phi>)\"", "lemma satisfies_gen_restrict_RESTR:\n  \"satisfies_gen (\\<lambda>k P n. restrict k P \\<and> r k P n) \\<AA> \\<phi> \\<longleftrightarrow> satisfies_gen r \\<AA> (RESTR \\<phi>)\"", "lemma finite_FV: \"finite (FV \\<phi> k)\"", "lemma satisfies_gen_restrict:\n  \"satisfies_gen r \\<AA> \\<phi> \\<and> (\\<forall>x\\<in>set V. restrict k (x\\<^bsup>\\<AA>\\<^esup>k)) \\<longleftrightarrow>\n   satisfies_gen r \\<AA> (foldr (\\<lambda>x. FAnd (Restrict k x)) V \\<phi>)\"", "lemma sat_vars_RESTRICT_VARS:\n  fixes \\<phi>\n  defines \"vs \\<equiv> sorted_list_of_set o FV \\<phi>\"\n  assumes \"\\<forall>k \\<in> set ks. finite (FV \\<phi> k)\"\n  shows \"sat_vars_gen r (set ks) \\<AA> \\<phi> \\<longleftrightarrow> satisfies_gen r \\<AA> (RESTRICT_VARS ks vs \\<phi>)\"", "lemma sat_RESTRICT: \"sat \\<AA> \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> RESTRICT \\<phi>\"", "lemma sat\\<^sub>b_RESTRICT: \"sat\\<^sub>b \\<AA> \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b RESTRICT \\<phi>\"", "lemma wf_RESTR: \"wf idx \\<phi> \\<Longrightarrow> wf idx (RESTR \\<phi>)\"", "lemma wf_RESTRICT_VARS: \"\\<lbrakk>wf idx \\<phi>; \\<forall>k \\<in> set ks. \\<forall>v \\<in> set (vs k). LESS k v idx\\<rbrakk> \\<Longrightarrow>\n  wf idx (RESTRICT_VARS ks vs \\<phi>)\"", "lemma wf_FV_LESS: \"\\<lbrakk>wf idx \\<phi>; v \\<in> FV \\<phi> k\\<rbrakk> \\<Longrightarrow> LESS k v idx\"", "lemma wf_RESTRICT: \"wf idx \\<phi> \\<Longrightarrow> wf idx (RESTRICT \\<phi>)\"", "lemma lformula_RESTR: \"lformula \\<phi> \\<Longrightarrow> lformula (RESTR \\<phi>)\"", "lemma lformula_RESTRICT_VARS: \"lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS ks vs \\<phi>)\"", "lemma lformula_RESTRICT: \"lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT \\<phi>)\"", "lemma ex_fold_CONS: \"\\<exists>xs \\<BB>. \\<AA> = fold CONS xs \\<BB> \\<and> Length \\<BB> = 0 \\<and> Length \\<AA> = length xs \\<and>\n   #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and> (\\<forall>x \\<in> set xs. size x = #\\<^sub>V \\<AA>)\"", "lemma L_empty: \"L idx {} = Zero\"", "lemma L_alt: \"L idx I =\n    to_language {xs. \\<exists>\\<AA> \\<in> I. \\<exists>\\<BB>. \\<AA> = fold CONS (rev xs) \\<BB> \\<and> Length \\<BB> = 0 \\<and>\n      #\\<^sub>V \\<BB> = idx \\<and> (\\<forall>x \\<in> set xs. size x = idx)}\"", "lemma \"lformula \\<phi> \\<Longrightarrow> lang n (norm \\<phi>) = lang n \\<phi>\"", "lemma in_language_Zero[simp]: \"\\<not> in_language Zero w\"", "lemma in_language_L_size: \"in_language (L idx I) w \\<Longrightarrow> x \\<in> set w \\<Longrightarrow> size x = idx\"", "lemma (in Formula) check_eqv_soundness:\n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> sat \\<AA> \\<phi> \\<longleftrightarrow> sat \\<AA> \\<psi>\"", "lemma (in Formula) bounded_check_eqv_soundness:\n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; bounded.check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> sat\\<^sub>b \\<AA> \\<phi> \\<longleftrightarrow> sat\\<^sub>b \\<AA> \\<psi>\""], "translations": [["", "lemma pred_Diff_0[simp]: \"0 \\<notin> A \\<Longrightarrow> i \\<in> (\\<lambda>x. x - Suc 0) ` A \\<longleftrightarrow> Suc i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> A \\<Longrightarrow>\n    (i \\<in> (\\<lambda>x. x - Suc 0) ` A) = (Suc i \\<in> A)", "by (cases i) (fastforce simp: image_iff le_Suc_eq  elim: contrapos_np)+"], ["", "lemma funpow_cycle_mult: \"(f ^^ k) x = x \\<Longrightarrow> (f ^^ (m * k)) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ k) x = x \\<Longrightarrow> (f ^^ (m * k)) x = x", "by (induct m) (auto simp: funpow_add)"], ["", "lemma funpow_cycle: \"(f ^^ k) x = x \\<Longrightarrow> (f ^^ l) x = (f ^^ (l mod k)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ k) x = x \\<Longrightarrow> (f ^^ l) x = (f ^^ (l mod k)) x", "by (subst div_mult_mod_eq[symmetric, of l k])\n    (simp only: add.commute funpow_add funpow_cycle_mult o_apply)"], ["", "lemma funpow_cycle_offset:\n  fixes f :: \"'a \\<Rightarrow> 'a\"\n  assumes \"(f ^^ k) x = (f ^^ i) x\" \"i \\<le> k\" \"i \\<le> l\"\n  shows \"(f ^^ l) x = (f ^^ ((l - i) mod (k - i) + i)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ l) x = (f ^^ ((l - i) mod (k - i) + i)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f ^^ l) x = (f ^^ ((l - i) mod (k - i) + i)) x", "from assms"], ["proof (chain)\npicking this:\n  (f ^^ k) x = (f ^^ i) x\n  i \\<le> k\n  i \\<le> l", "have\n    \"(f ^^ (k - i)) ((f ^^ i) x) = ((f ^^ i) x)\"\n    \"(f ^^ l) x = (f ^^ (l - i)) ((f ^^ i) x)\""], ["proof (prove)\nusing this:\n  (f ^^ k) x = (f ^^ i) x\n  i \\<le> k\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. (f ^^ (k - i)) ((f ^^ i) x) = (f ^^ i) x &&&\n    (f ^^ l) x = (f ^^ (l - i)) ((f ^^ i) x)", "unfolding fun_cong[OF funpow_add[symmetric, unfolded o_def]]"], ["proof (prove)\nusing this:\n  (f ^^ k) x = (f ^^ i) x\n  i \\<le> k\n  i \\<le> l\n\ngoal (1 subgoal):\n 1. (f ^^ (k - i + i)) x = (f ^^ i) x &&& (f ^^ l) x = (f ^^ (l - i + i)) x", "by simp_all"], ["proof (state)\nthis:\n  (f ^^ (k - i)) ((f ^^ i) x) = (f ^^ i) x\n  (f ^^ l) x = (f ^^ (l - i)) ((f ^^ i) x)\n\ngoal (1 subgoal):\n 1. (f ^^ l) x = (f ^^ ((l - i) mod (k - i) + i)) x", "from funpow_cycle[OF this(1), of \"l - i\"] this(2)"], ["proof (chain)\npicking this:\n  (f ^^ (l - i)) ((f ^^ i) x) = (f ^^ ((l - i) mod (k - i))) ((f ^^ i) x)\n  (f ^^ l) x = (f ^^ (l - i)) ((f ^^ i) x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (f ^^ (l - i)) ((f ^^ i) x) = (f ^^ ((l - i) mod (k - i))) ((f ^^ i) x)\n  (f ^^ l) x = (f ^^ (l - i)) ((f ^^ i) x)\n\ngoal (1 subgoal):\n 1. (f ^^ l) x = (f ^^ ((l - i) mod (k - i) + i)) x", "by (simp add: funpow_add)"], ["proof (state)\nthis:\n  (f ^^ l) x = (f ^^ ((l - i) mod (k - i) + i)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_tlD: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs", "by (cases xs) auto"], ["", "definition \"dec k m = (if m > k then m - Suc 0 else m :: nat)\""], ["", "subsection \\<open>Abstract formulas\\<close>"], ["", "datatype (discs_sels) ('a, 'k) aformula =\n  FBool bool\n| FBase 'a\n| FNot \"('a, 'k) aformula\"\n| FOr \"('a, 'k) aformula\" \"('a, 'k) aformula\"\n| FAnd \"('a, 'k) aformula\" \"('a, 'k) aformula\"\n| FEx 'k \"('a, 'k) aformula\"\n| FAll 'k \"('a, 'k) aformula\""], ["", "derive linorder aformula"], ["", "fun nFOR where\n  \"nFOR [] = FBool False\"\n| \"nFOR [x] = x\"\n| \"nFOR (x # xs) = FOr x (nFOR xs)\""], ["", "fun nFAND where\n  \"nFAND [] = FBool True\"\n| \"nFAND [x] = x\"\n| \"nFAND (x # xs) = FAnd x (nFAND xs)\""], ["", "definition \"NFOR = nFOR o sorted_list_of_set\""], ["", "definition \"NFAND = nFAND o sorted_list_of_set\""], ["", "fun disjuncts where\n  \"disjuncts (FOr \\<phi> \\<psi>) = disjuncts \\<phi> \\<union> disjuncts \\<psi>\"\n| \"disjuncts \\<phi> = {\\<phi>}\""], ["", "fun conjuncts where\n  \"conjuncts (FAnd \\<phi> \\<psi>) = conjuncts \\<phi> \\<union> conjuncts \\<psi>\"\n| \"conjuncts \\<phi> = {\\<phi>}\""], ["", "fun disjuncts_list where\n  \"disjuncts_list (FOr \\<phi> \\<psi>) = disjuncts_list \\<phi> @ disjuncts_list \\<psi>\"\n| \"disjuncts_list \\<phi> = [\\<phi>]\""], ["", "fun conjuncts_list where\n  \"conjuncts_list (FAnd \\<phi> \\<psi>) = conjuncts_list \\<phi> @ conjuncts_list \\<psi>\"\n| \"conjuncts_list \\<phi> = [\\<phi>]\""], ["", "lemma finite_juncts[simp]: \"finite (disjuncts \\<phi>)\" \"finite (conjuncts \\<phi>)\"\n  and nonempty_juncts[simp]: \"disjuncts \\<phi> \\<noteq> {}\" \"conjuncts \\<phi> \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite (disjuncts \\<phi>) &&& finite (conjuncts \\<phi>)) &&&\n    disjuncts \\<phi> \\<noteq> {} &&& conjuncts \\<phi> \\<noteq> {}", "by (induct \\<phi>) auto"], ["", "lemma juncts_eq_set_juncts_list:\n  \"disjuncts \\<phi> = set (disjuncts_list \\<phi>)\"\n  \"conjuncts \\<phi> = set (conjuncts_list \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjuncts \\<phi> = set (disjuncts_list \\<phi>) &&&\n    conjuncts \\<phi> = set (conjuncts_list \\<phi>)", "by (induct \\<phi>) auto"], ["", "lemma notin_juncts:\n  \"\\<lbrakk>\\<psi> \\<in> disjuncts \\<phi>; is_FOr \\<psi>\\<rbrakk> \\<Longrightarrow> False\"\n  \"\\<lbrakk>\\<psi> \\<in> conjuncts \\<phi>; is_FAnd \\<psi>\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<psi> \\<in> disjuncts \\<phi>; is_FOr \\<psi>\\<rbrakk>\n     \\<Longrightarrow> False) &&&\n    (\\<lbrakk>\\<psi> \\<in> conjuncts \\<phi>; is_FAnd \\<psi>\\<rbrakk>\n     \\<Longrightarrow> False)", "by (induct \\<phi>) auto"], ["", "lemma juncts_list_singleton:\n  \"\\<not> is_FOr \\<phi> \\<Longrightarrow> disjuncts_list \\<phi> = [\\<phi>]\"\n  \"\\<not> is_FAnd \\<phi> \\<Longrightarrow> conjuncts_list \\<phi> = [\\<phi>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_FOr \\<phi> \\<Longrightarrow>\n     disjuncts_list \\<phi> = [\\<phi>]) &&&\n    (\\<not> is_FAnd \\<phi> \\<Longrightarrow>\n     conjuncts_list \\<phi> = [\\<phi>])", "by (induct \\<phi>) auto"], ["", "lemma juncts_singleton:\n  \"\\<not> is_FOr \\<phi> \\<Longrightarrow> disjuncts \\<phi> = {\\<phi>}\"\n  \"\\<not> is_FAnd \\<phi> \\<Longrightarrow> conjuncts \\<phi> = {\\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_FOr \\<phi> \\<Longrightarrow> disjuncts \\<phi> = {\\<phi>}) &&&\n    (\\<not> is_FAnd \\<phi> \\<Longrightarrow> conjuncts \\<phi> = {\\<phi>})", "by (induct \\<phi>) auto"], ["", "lemma nonempty_juncts_list: \"conjuncts_list \\<phi> \\<noteq> []\" \"disjuncts_list \\<phi> \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjuncts_list \\<phi> \\<noteq> [] &&& disjuncts_list \\<phi> \\<noteq> []", "using nonempty_juncts[of \\<phi>]"], ["proof (prove)\nusing this:\n  disjuncts \\<phi> \\<noteq> {}\n  conjuncts \\<phi> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. conjuncts_list \\<phi> \\<noteq> [] &&& disjuncts_list \\<phi> \\<noteq> []", "by (auto simp: Suc_le_eq juncts_eq_set_juncts_list)"], ["", "primrec norm_ACI (\"\\<langle>_\\<rangle>\") where\n  \"\\<langle>FBool b\\<rangle> = FBool b\"\n| \"\\<langle>FBase a\\<rangle> = FBase a\"\n| \"\\<langle>FNot \\<phi>\\<rangle> = FNot \\<langle>\\<phi>\\<rangle>\"\n| \"\\<langle>FOr \\<phi> \\<psi>\\<rangle> = NFOR (disjuncts (FOr \\<langle>\\<phi>\\<rangle> \\<langle>\\<psi>\\<rangle>))\"\n| \"\\<langle>FAnd \\<phi> \\<psi>\\<rangle> = NFAND (conjuncts (FAnd \\<langle>\\<phi>\\<rangle> \\<langle>\\<psi>\\<rangle>))\"\n| \"\\<langle>FEx k \\<phi>\\<rangle> = FEx k \\<langle>\\<phi>\\<rangle>\"\n| \"\\<langle>FAll k \\<phi>\\<rangle> = FAll k \\<langle>\\<phi>\\<rangle>\""], ["", "fun nf_ACI where\n  \"nf_ACI (FOr \\<psi>1 \\<psi>2) = (\\<not> is_FOr \\<psi>1 \\<and> (let \\<phi>s = \\<psi>1 # disjuncts_list \\<psi>2 in\n    sorted \\<phi>s \\<and> distinct \\<phi>s \\<and> nf_ACI \\<psi>1 \\<and> nf_ACI \\<psi>2))\"\n| \"nf_ACI (FAnd \\<psi>1 \\<psi>2) = (\\<not> is_FAnd \\<psi>1 \\<and> (let \\<phi>s = \\<psi>1 # conjuncts_list \\<psi>2 in\n    sorted \\<phi>s \\<and> distinct \\<phi>s \\<and> nf_ACI \\<psi>1 \\<and> nf_ACI \\<psi>2))\"\n| \"nf_ACI (FNot \\<phi>) = nf_ACI \\<phi>\"\n| \"nf_ACI (FEx k \\<phi>) = nf_ACI \\<phi>\"\n| \"nf_ACI (FAll k \\<phi>) = nf_ACI \\<phi>\"\n| \"nf_ACI \\<phi> = True\""], ["", "lemma nf_ACI_D:\n  \"nf_ACI \\<phi> \\<Longrightarrow> sorted (disjuncts_list \\<phi>)\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> sorted (conjuncts_list \\<phi>)\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> distinct (disjuncts_list \\<phi>)\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> distinct (conjuncts_list \\<phi>)\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> list_all nf_ACI (disjuncts_list \\<phi>)\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> list_all nf_ACI (conjuncts_list \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((nf_ACI \\<phi> \\<Longrightarrow> sorted (disjuncts_list \\<phi>)) &&&\n     (nf_ACI \\<phi> \\<Longrightarrow> sorted (conjuncts_list \\<phi>)) &&&\n     (nf_ACI \\<phi> \\<Longrightarrow> distinct (disjuncts_list \\<phi>))) &&&\n    (nf_ACI \\<phi> \\<Longrightarrow> distinct (conjuncts_list \\<phi>)) &&&\n    (nf_ACI \\<phi> \\<Longrightarrow>\n     list_all nf_ACI (disjuncts_list \\<phi>)) &&&\n    (nf_ACI \\<phi> \\<Longrightarrow>\n     list_all nf_ACI (conjuncts_list \\<phi>))", "by (induct \\<phi>) (auto simp: juncts_list_singleton)"], ["", "lemma disjuncts_list_nFOR:\n  \"\\<lbrakk>list_all (\\<lambda>x. \\<not> is_FOr x) \\<phi>s; \\<phi>s \\<noteq> []\\<rbrakk> \\<Longrightarrow> disjuncts_list (nFOR \\<phi>s) = \\<phi>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (\\<lambda>x. \\<not> is_FOr x) \\<phi>s;\n     \\<phi>s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> disjuncts_list (nFOR \\<phi>s) = \\<phi>s", "by (induct \\<phi>s rule: nFOR.induct) (auto simp: juncts_list_singleton)"], ["", "lemma conjuncts_list_nFAND:\n  \"\\<lbrakk>list_all (\\<lambda>x. \\<not> is_FAnd x) \\<phi>s; \\<phi>s \\<noteq> []\\<rbrakk> \\<Longrightarrow> conjuncts_list (nFAND \\<phi>s) = \\<phi>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (\\<lambda>x. \\<not> is_FAnd x) \\<phi>s;\n     \\<phi>s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> conjuncts_list (nFAND \\<phi>s) = \\<phi>s", "by (induct \\<phi>s rule: nFAND.induct) (auto simp: juncts_list_singleton)"], ["", "lemma disjuncts_NFOR:\n  \"\\<lbrakk>finite X; X \\<noteq> {}; \\<forall>x \\<in> X. \\<not> is_FOr x\\<rbrakk> \\<Longrightarrow> disjuncts (NFOR X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; X \\<noteq> {};\n     \\<forall>x\\<in>X. \\<not> is_FOr x\\<rbrakk>\n    \\<Longrightarrow> disjuncts (NFOR X) = X", "unfolding NFOR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; X \\<noteq> {};\n     \\<forall>x\\<in>X. \\<not> is_FOr x\\<rbrakk>\n    \\<Longrightarrow> disjuncts ((nFOR \\<circ> sorted_list_of_set) X) = X", "by (auto simp: juncts_eq_set_juncts_list list_all_iff disjuncts_list_nFOR)"], ["", "lemma conjuncts_NFAND:\n  \"\\<lbrakk>finite X; X \\<noteq> {}; \\<forall>x \\<in> X. \\<not> is_FAnd x\\<rbrakk> \\<Longrightarrow> conjuncts (NFAND X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; X \\<noteq> {};\n     \\<forall>x\\<in>X. \\<not> is_FAnd x\\<rbrakk>\n    \\<Longrightarrow> conjuncts (NFAND X) = X", "unfolding NFAND_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; X \\<noteq> {};\n     \\<forall>x\\<in>X. \\<not> is_FAnd x\\<rbrakk>\n    \\<Longrightarrow> conjuncts ((nFAND \\<circ> sorted_list_of_set) X) = X", "by (auto simp: juncts_eq_set_juncts_list list_all_iff conjuncts_list_nFAND)"], ["", "lemma nf_ACI_nFOR: \n  \"\\<lbrakk>sorted \\<phi>s; distinct \\<phi>s; list_all nf_ACI \\<phi>s; list_all (\\<lambda>x. \\<not> is_FOr x) \\<phi>s\\<rbrakk> \\<Longrightarrow> nf_ACI (nFOR \\<phi>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted \\<phi>s; distinct \\<phi>s; list_all nf_ACI \\<phi>s;\n     list_all (\\<lambda>x. \\<not> is_FOr x) \\<phi>s\\<rbrakk>\n    \\<Longrightarrow> nf_ACI (nFOR \\<phi>s)", "by (induct \\<phi>s rule: nFOR.induct)\n    (auto simp: juncts_list_singleton disjuncts_list_nFOR nf_ACI_D)"], ["", "lemma nf_ACI_nFAND: \n  \"\\<lbrakk>sorted \\<phi>s; distinct \\<phi>s; list_all nf_ACI \\<phi>s; list_all (\\<lambda>x. \\<not> is_FAnd x) \\<phi>s\\<rbrakk> \\<Longrightarrow> nf_ACI (nFAND \\<phi>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted \\<phi>s; distinct \\<phi>s; list_all nf_ACI \\<phi>s;\n     list_all (\\<lambda>x. \\<not> is_FAnd x) \\<phi>s\\<rbrakk>\n    \\<Longrightarrow> nf_ACI (nFAND \\<phi>s)", "by (induct \\<phi>s rule: nFAND.induct)\n    (auto simp: juncts_list_singleton conjuncts_list_nFAND nf_ACI_D)"], ["", "lemma nf_ACI_juncts:\n  \"\\<lbrakk>\\<psi> \\<in> disjuncts \\<phi>; nf_ACI \\<phi>\\<rbrakk> \\<Longrightarrow> nf_ACI \\<psi>\"\n  \"\\<lbrakk>\\<psi> \\<in> conjuncts \\<phi>; nf_ACI \\<phi>\\<rbrakk> \\<Longrightarrow> nf_ACI \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<psi> \\<in> disjuncts \\<phi>; nf_ACI \\<phi>\\<rbrakk>\n     \\<Longrightarrow> nf_ACI \\<psi>) &&&\n    (\\<lbrakk>\\<psi> \\<in> conjuncts \\<phi>; nf_ACI \\<phi>\\<rbrakk>\n     \\<Longrightarrow> nf_ACI \\<psi>)", "by (induct \\<phi>) auto"], ["", "lemma nf_ACI_norm_ACI: \"nf_ACI \\<langle>\\<phi>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_ACI \\<langle>\\<phi>\\<rangle>", "by (induct \\<phi>)\n    (force simp: NFOR_def NFAND_def list_all_iff\n      intro!: nf_ACI_nFOR nf_ACI_nFAND elim: nf_ACI_juncts notin_juncts)+"], ["", "lemma nFOR_Cons: \"nFOR (x # xs) = (if xs = [] then x else FOr x (nFOR xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nFOR (x # xs) = (if xs = [] then x else FOr x (nFOR xs))", "by (cases xs) simp_all"], ["", "lemma nFAND_Cons: \"nFAND (x # xs) = (if xs = [] then x else FAnd x (nFAND xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nFAND (x # xs) = (if xs = [] then x else FAnd x (nFAND xs))", "by (cases xs) simp_all"], ["", "lemma nFOR_disjuncts: \"nf_ACI \\<psi> \\<Longrightarrow> nFOR (disjuncts_list \\<psi>) = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_ACI \\<psi> \\<Longrightarrow> nFOR (disjuncts_list \\<psi>) = \\<psi>", "by (induct \\<psi>) (auto simp: juncts_list_singleton nFOR_Cons)"], ["", "lemma nFAND_conjuncts: \"nf_ACI \\<psi> \\<Longrightarrow> nFAND (conjuncts_list \\<psi>) = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_ACI \\<psi> \\<Longrightarrow> nFAND (conjuncts_list \\<psi>) = \\<psi>", "by (induct \\<psi>) (auto simp: juncts_list_singleton nFAND_Cons)"], ["", "lemma NFOR_disjuncts: \"nf_ACI \\<psi> \\<Longrightarrow> NFOR (disjuncts \\<psi>) = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_ACI \\<psi> \\<Longrightarrow> NFOR (disjuncts \\<psi>) = \\<psi>", "using nFOR_disjuncts[of \\<psi>]"], ["proof (prove)\nusing this:\n  nf_ACI \\<psi> \\<Longrightarrow> nFOR (disjuncts_list \\<psi>) = \\<psi>\n\ngoal (1 subgoal):\n 1. nf_ACI \\<psi> \\<Longrightarrow> NFOR (disjuncts \\<psi>) = \\<psi>", "unfolding NFOR_def o_apply juncts_eq_set_juncts_list"], ["proof (prove)\nusing this:\n  nf_ACI \\<psi> \\<Longrightarrow> nFOR (disjuncts_list \\<psi>) = \\<psi>\n\ngoal (1 subgoal):\n 1. nf_ACI \\<psi> \\<Longrightarrow>\n    nFOR (sorted_list_of_set (set (disjuncts_list \\<psi>))) = \\<psi>", "by (metis finite_set finite_sorted_distinct_unique nf_ACI_D(1,3) sorted_list_of_set)"], ["", "lemma NFAND_conjuncts: \"nf_ACI \\<psi> \\<Longrightarrow> NFAND (conjuncts \\<psi>) = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_ACI \\<psi> \\<Longrightarrow> NFAND (conjuncts \\<psi>) = \\<psi>", "using nFAND_conjuncts[of \\<psi>]"], ["proof (prove)\nusing this:\n  nf_ACI \\<psi> \\<Longrightarrow> nFAND (conjuncts_list \\<psi>) = \\<psi>\n\ngoal (1 subgoal):\n 1. nf_ACI \\<psi> \\<Longrightarrow> NFAND (conjuncts \\<psi>) = \\<psi>", "unfolding NFAND_def o_apply juncts_eq_set_juncts_list"], ["proof (prove)\nusing this:\n  nf_ACI \\<psi> \\<Longrightarrow> nFAND (conjuncts_list \\<psi>) = \\<psi>\n\ngoal (1 subgoal):\n 1. nf_ACI \\<psi> \\<Longrightarrow>\n    nFAND (sorted_list_of_set (set (conjuncts_list \\<psi>))) = \\<psi>", "by (metis finite_set finite_sorted_distinct_unique nf_ACI_D(2,4) sorted_list_of_set)"], ["", "lemma norm_ACI_if_nf_ACI: \"nf_ACI \\<phi> \\<Longrightarrow> \\<langle>\\<phi>\\<rangle> = \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_ACI \\<phi> \\<Longrightarrow> \\<langle>\\<phi>\\<rangle> = \\<phi>", "by (induct \\<phi>)\n    (auto simp: juncts_list_singleton juncts_eq_set_juncts_list nonempty_juncts_list\n      NFOR_def NFAND_def nFOR_Cons nFAND_Cons nFOR_disjuncts nFAND_conjuncts\n      sorted_list_of_set_sort_remdups distinct_remdups_id sorted_sort_id insort_is_Cons)"], ["", "lemma norm_ACI_idem: \"\\<langle>\\<langle>\\<phi>\\<rangle>\\<rangle> = \\<langle>\\<phi>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>\\<phi>\\<rangle>\\<rangle> = \\<langle>\\<phi>\\<rangle>", "by (metis nf_ACI_norm_ACI norm_ACI_if_nf_ACI)"], ["", "lemma norm_ACI_juncts:\n  \"nf_ACI \\<phi> \\<Longrightarrow> norm_ACI ` disjuncts \\<phi> = disjuncts \\<phi>\"\n  \"nf_ACI \\<phi> \\<Longrightarrow> norm_ACI ` conjuncts \\<phi> = conjuncts \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nf_ACI \\<phi> \\<Longrightarrow>\n     norm_ACI ` disjuncts \\<phi> = disjuncts \\<phi>) &&&\n    (nf_ACI \\<phi> \\<Longrightarrow>\n     norm_ACI ` conjuncts \\<phi> = conjuncts \\<phi>)", "by (drule nf_ACI_D(5,6), force simp: list_all_iff juncts_eq_set_juncts_list norm_ACI_if_nf_ACI)+"], ["", "lemma\n  norm_ACI_NFOR: \"nf_ACI \\<phi> \\<Longrightarrow> \\<phi> = NFOR (norm_ACI ` disjuncts \\<phi>)\" and\n  norm_ACI_NFAND: \"nf_ACI \\<phi> \\<Longrightarrow> \\<phi> = NFAND (norm_ACI ` conjuncts \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nf_ACI \\<phi> \\<Longrightarrow>\n     \\<phi> = NFOR (norm_ACI ` disjuncts \\<phi>)) &&&\n    (nf_ACI \\<phi> \\<Longrightarrow>\n     \\<phi> = NFAND (norm_ACI ` conjuncts \\<phi>))", "by (simp_all add: norm_ACI_juncts NFOR_disjuncts NFAND_conjuncts)"], ["", "(*\n'a - atomic formula\n'i - interpretation\n'k - kind of quantifier\n'n - De Brujin index\n'x - alphabet element\n'v - valuation\n*)"], ["", "locale Formula_Operations =\n  fixes TYPEVARS :: \"'a :: linorder \\<times> 'i \\<times> 'k :: {linorder, enum} \\<times> 'n \\<times> 'x \\<times> 'v\"\n\n  (* De Bruijn indices abstractly *)\n  and SUC :: \"'k \\<Rightarrow> 'n \\<Rightarrow> 'n\"\n  and LESS :: \"'k \\<Rightarrow> nat \\<Rightarrow> 'n \\<Rightarrow> bool\"\n\n  (* Interpratations *)\n  and assigns :: \"nat \\<Rightarrow> 'i \\<Rightarrow> 'k \\<Rightarrow> 'v\" (\"_\\<^bsup>_\\<^esup>_\" [900, 999, 999] 999)\n  and nvars :: \"'i \\<Rightarrow> 'n\" (\"#\\<^sub>V _\" [1000] 900)\n  and Extend :: \"'k \\<Rightarrow> nat \\<Rightarrow> 'i \\<Rightarrow> 'v \\<Rightarrow> 'i\"\n  and CONS :: \"'x \\<Rightarrow> 'i \\<Rightarrow> 'i\"\n  and SNOC :: \"'x \\<Rightarrow> 'i \\<Rightarrow> 'i\"\n  and Length :: \"'i \\<Rightarrow> nat\"\n\n  (* Alphabet elements *)\n  and extend :: \"'k \\<Rightarrow> bool \\<Rightarrow> 'x \\<Rightarrow> 'x\"\n  and size :: \"'x \\<Rightarrow> 'n\"\n  and zero :: \"'n \\<Rightarrow> 'x\"\n  and alphabet :: \"'n \\<Rightarrow> 'x list\"\n\n  (* Valuations *)\n  and eval :: \"'v \\<Rightarrow> nat \\<Rightarrow> bool\"\n  and downshift :: \"'v \\<Rightarrow> 'v\"\n  and upshift :: \"'v \\<Rightarrow> 'v\"\n  and add :: \"nat \\<Rightarrow> 'v \\<Rightarrow> 'v\"\n  and cut :: \"nat \\<Rightarrow> 'v \\<Rightarrow> 'v\"\n  and len :: \"'v \\<Rightarrow> nat\"\n\n  (* Restrictions *)\n  and restrict :: \"'k \\<Rightarrow> 'v \\<Rightarrow> bool\"\n  and Restrict :: \"'k \\<Rightarrow> nat \\<Rightarrow> ('a, 'k) aformula\"\n\n  (* Function extensions for the base cases *)\n  and lformula0 :: \"'a \\<Rightarrow> bool\"\n  and FV0 :: \"'k \\<Rightarrow> 'a \\<Rightarrow> nat set\"\n  and find0 :: \"'k \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and wf0 :: \"'n \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and decr0 :: \"'k \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  and satisfies0 :: \"'i \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<Turnstile>\\<^sub>0\" 50)\n  and nullable0 :: \"'a \\<Rightarrow> bool\"\n  and lderiv0 :: \"'x \\<Rightarrow> 'a \\<Rightarrow> ('a, 'k) aformula\"\n  and rderiv0 :: \"'x \\<Rightarrow> 'a \\<Rightarrow> ('a, 'k) aformula\"\nbegin"], ["", "abbreviation \"LEQ k l n \\<equiv> LESS k l (SUC k n)\""], ["", "primrec FV where\n  \"FV (FBool _) k = {}\"\n| \"FV (FBase a) k = FV0 k a\"\n| \"FV (FNot \\<phi>) k = FV \\<phi> k\"\n| \"FV (FOr \\<phi> \\<psi>) k = FV \\<phi> k \\<union> FV \\<psi> k\"\n| \"FV (FAnd \\<phi> \\<psi>) k = FV \\<phi> k \\<union> FV \\<psi> k\"\n| \"FV (FEx k' \\<phi>) k = (if k' = k then (\\<lambda>x. x - 1) ` (FV \\<phi> k - {0}) else FV \\<phi> k)\"\n| \"FV (FAll k' \\<phi>) k = (if k' = k then (\\<lambda>x. x - 1) ` (FV \\<phi> k - {0}) else FV \\<phi> k)\""], ["", "primrec find where\n  \"find k l (FBool _) = False\"\n| \"find k l (FBase a) = find0 k l a\"\n| \"find k l (FNot \\<phi>) = find k l \\<phi>\"\n| \"find k l (FOr \\<phi> \\<psi>) = (find k l \\<phi> \\<or> find k l \\<psi>)\"\n| \"find k l (FAnd \\<phi> \\<psi>) = (find k l \\<phi> \\<or> find k l \\<psi>)\"\n| \"find k l (FEx k' \\<phi>) = find k (if k = k' then Suc l else l) \\<phi>\"\n| \"find k l (FAll k' \\<phi>) = find k (if k = k' then Suc l else l) \\<phi>\""], ["", "primrec wf :: \"'n \\<Rightarrow> ('a, 'k) aformula \\<Rightarrow> bool\" where\n  \"wf n (FBool _) = True\"\n| \"wf n (FBase a) = wf0 n a\"\n| \"wf n (FNot \\<phi>) = wf n \\<phi>\"\n| \"wf n (FOr \\<phi> \\<psi>) = (wf n \\<phi> \\<and> wf n \\<psi>)\"\n| \"wf n (FAnd \\<phi> \\<psi>) = (wf n \\<phi> \\<and> wf n \\<psi>)\"\n| \"wf n (FEx k \\<phi>) = wf (SUC k n) \\<phi>\"\n| \"wf n (FAll k \\<phi>) = wf (SUC k n) \\<phi>\""], ["", "primrec lformula :: \"('a, 'k) aformula \\<Rightarrow> bool\" where\n  \"lformula (FBool _) = True\"\n| \"lformula (FBase a) = lformula0 a\"\n| \"lformula (FNot \\<phi>) = lformula \\<phi>\"\n| \"lformula (FOr \\<phi> \\<psi>) = (lformula \\<phi> \\<and> lformula \\<psi>)\"\n| \"lformula (FAnd \\<phi> \\<psi>) = (lformula \\<phi> \\<and> lformula \\<psi>)\"\n| \"lformula (FEx k \\<phi>) = lformula \\<phi>\"\n| \"lformula (FAll k \\<phi>) = lformula \\<phi>\""], ["", "primrec decr :: \"'k \\<Rightarrow> nat \\<Rightarrow> ('a, 'k) aformula \\<Rightarrow> ('a, 'k) aformula\" where\n  \"decr k l (FBool b) = FBool b\"\n| \"decr k l (FBase a) = FBase (decr0 k l a)\"\n| \"decr k l (FNot \\<phi>) = FNot (decr k l \\<phi>)\"\n| \"decr k l (FOr \\<phi> \\<psi>) = FOr (decr k l \\<phi>) (decr k l \\<psi>)\"\n| \"decr k l (FAnd \\<phi> \\<psi>) = FAnd (decr k l \\<phi>) (decr k l \\<psi>)\"\n| \"decr k l (FEx k' \\<phi>) = FEx k' (decr k (if k = k' then Suc l else l) \\<phi>)\"\n| \"decr k l (FAll k' \\<phi>) = FAll k' (decr k (if k = k' then Suc l else l) \\<phi>)\""], ["", "primrec satisfies_gen :: \"('k \\<Rightarrow> 'v \\<Rightarrow> nat \\<Rightarrow> bool) \\<Rightarrow> 'i \\<Rightarrow> ('a, 'k) aformula \\<Rightarrow> bool\" where\n  \"satisfies_gen r \\<AA> (FBool b) = b\"\n| \"satisfies_gen r \\<AA> (FBase a) = (\\<AA> \\<Turnstile>\\<^sub>0 a)\"\n| \"satisfies_gen r \\<AA> (FNot \\<phi>) = (\\<not> satisfies_gen r \\<AA> \\<phi>)\"\n| \"satisfies_gen r \\<AA> (FOr \\<phi>\\<^sub>1 \\<phi>\\<^sub>2) = (satisfies_gen r \\<AA> \\<phi>\\<^sub>1 \\<or> satisfies_gen r \\<AA> \\<phi>\\<^sub>2)\"\n| \"satisfies_gen r \\<AA> (FAnd \\<phi>\\<^sub>1 \\<phi>\\<^sub>2) = (satisfies_gen r \\<AA> \\<phi>\\<^sub>1 \\<and> satisfies_gen r \\<AA> \\<phi>\\<^sub>2)\"\n| \"satisfies_gen r \\<AA> (FEx k \\<phi>) = (\\<exists>P. r k P (Length \\<AA>) \\<and> satisfies_gen r (Extend k 0 \\<AA> P) \\<phi>)\"\n| \"satisfies_gen r \\<AA> (FAll k \\<phi>) = (\\<forall>P. r k P (Length \\<AA>) \\<longrightarrow> satisfies_gen r (Extend k 0 \\<AA> P) \\<phi>)\""], ["", "abbreviation satisfies (infix \"\\<Turnstile>\" 50) where\n  \"\\<AA> \\<Turnstile> \\<phi> \\<equiv> satisfies_gen (\\<lambda>_ _ _. True) \\<AA> \\<phi>\""], ["", "abbreviation satisfies_bounded (infix \"\\<Turnstile>\\<^sub>b\" 50) where\n  \"\\<AA> \\<Turnstile>\\<^sub>b \\<phi> \\<equiv> satisfies_gen (\\<lambda>_ P n. len P \\<le> n) \\<AA> \\<phi>\""], ["", "abbreviation sat_vars_gen where\n  \"sat_vars_gen r K \\<AA> \\<phi> \\<equiv>\n    satisfies_gen (\\<lambda>k P n. restrict k P \\<and> r k P n) \\<AA> \\<phi> \\<and> (\\<forall>k \\<in> K. \\<forall>x \\<in> FV \\<phi> k. restrict k (x\\<^bsup>\\<AA>\\<^esup>k))\""], ["", "definition sat where\n  \"sat \\<AA> \\<phi> \\<equiv> sat_vars_gen (\\<lambda>_ _ _. True) UNIV \\<AA> \\<phi>\""], ["", "definition sat\\<^sub>b where\n  \"sat\\<^sub>b \\<AA> \\<phi> \\<equiv> sat_vars_gen (\\<lambda>_ P n. len P \\<le> n) UNIV \\<AA> \\<phi>\""], ["", "fun RESTR where\n  \"RESTR (FOr \\<phi> \\<psi>) = FOr (RESTR \\<phi>) (RESTR \\<psi>)\"\n| \"RESTR (FAnd \\<phi> \\<psi>) = FAnd (RESTR \\<phi>) (RESTR \\<psi>)\"\n| \"RESTR (FNot \\<phi>) = FNot (RESTR \\<phi>)\"\n| \"RESTR (FEx k \\<phi>) = FEx k (FAnd (Restrict k 0) (RESTR \\<phi>))\"\n| \"RESTR (FAll k \\<phi>) = FAll k (FOr (FNot (Restrict k 0)) (RESTR \\<phi>))\"\n| \"RESTR \\<phi> = \\<phi>\""], ["", "abbreviation RESTRICT_VARS where\n  \"RESTRICT_VARS ks V \\<phi> \\<equiv>\n     foldr (%k \\<phi>. foldr (\\<lambda>x \\<phi>. FAnd (Restrict k x) \\<phi>) (V k) \\<phi>) ks (RESTR \\<phi>)\""], ["", "definition RESTRICT where\n  \"RESTRICT \\<phi> \\<equiv> RESTRICT_VARS Enum.enum (sorted_list_of_set o FV \\<phi>) \\<phi>\""], ["", "primrec nullable :: \"('a, 'k) aformula \\<Rightarrow> bool\" where\n  \"nullable (FBool b) = b\"\n| \"nullable (FBase a) = nullable0 a\"\n| \"nullable (FNot \\<phi>) = (\\<not> nullable \\<phi>)\"\n| \"nullable (FOr \\<phi> \\<psi>) = (nullable \\<phi> \\<or> nullable \\<psi>)\"\n| \"nullable (FAnd \\<phi> \\<psi>) = (nullable \\<phi> \\<and> nullable \\<psi>)\"\n| \"nullable (FEx k \\<phi>) = nullable \\<phi>\"\n| \"nullable (FAll k \\<phi>) = nullable \\<phi>\""], ["", "fun nFOr :: \"('a, 'k) aformula \\<Rightarrow> ('a, 'k) aformula \\<Rightarrow> ('a, 'k) aformula\" where\n  \"nFOr (FBool b1) (FBool b2) = FBool (b1 \\<or> b2)\"\n| \"nFOr (FBool b) \\<psi> = (if b then FBool True else \\<psi>)\"\n| \"nFOr \\<phi> (FBool b) = (if b then FBool True else \\<phi>)\"\n| \"nFOr (FOr \\<phi>1 \\<phi>2) \\<psi> = nFOr \\<phi>1 (nFOr \\<phi>2 \\<psi>)\"\n| \"nFOr \\<phi> (FOr \\<psi>1 \\<psi>2) =\n  (if \\<phi> = \\<psi>1 then FOr \\<psi>1 \\<psi>2\n  else if \\<phi> < \\<psi>1 then FOr \\<phi> (FOr \\<psi>1 \\<psi>2)\n  else FOr \\<psi>1 (nFOr \\<phi> \\<psi>2))\"\n| \"nFOr \\<phi> \\<psi> =\n  (if \\<phi> = \\<psi> then \\<phi>\n  else if \\<phi> < \\<psi> then FOr \\<phi> \\<psi>\n  else FOr \\<psi> \\<phi>)\""], ["", "fun nFAnd :: \"('a, 'k) aformula \\<Rightarrow> ('a, 'k) aformula \\<Rightarrow> ('a, 'k) aformula\" where\n  \"nFAnd (FBool b1) (FBool b2) = FBool (b1 \\<and> b2)\"\n| \"nFAnd (FBool b) \\<psi> = (if b then \\<psi> else FBool False)\"\n| \"nFAnd \\<phi> (FBool b) = (if b then \\<phi> else FBool False)\"\n| \"nFAnd (FAnd \\<phi>1 \\<phi>2) \\<psi> = nFAnd \\<phi>1 (nFAnd \\<phi>2 \\<psi>)\"\n| \"nFAnd \\<phi> (FAnd \\<psi>1 \\<psi>2) =\n  (if \\<phi> = \\<psi>1 then FAnd \\<psi>1 \\<psi>2\n  else if \\<phi> < \\<psi>1 then FAnd \\<phi> (FAnd \\<psi>1 \\<psi>2)\n  else FAnd \\<psi>1 (nFAnd \\<phi> \\<psi>2))\"\n| \"nFAnd \\<phi> \\<psi> =\n  (if \\<phi> = \\<psi> then \\<phi>\n  else if \\<phi> < \\<psi> then FAnd \\<phi> \\<psi>\n  else FAnd \\<psi> \\<phi>)\""], ["", "fun nFEx :: \"'k \\<Rightarrow> ('a, 'k) aformula \\<Rightarrow> ('a, 'k) aformula\" where\n  \"nFEx k (FOr \\<phi> \\<psi>) = nFOr (nFEx k \\<phi>) (nFEx k \\<psi>)\"\n| \"nFEx k \\<phi> = (if find k 0 \\<phi> then FEx k \\<phi> else decr k 0 \\<phi>)\""], ["", "fun nFAll where\n  \"nFAll k (FAnd \\<phi> \\<psi>) = nFAnd (nFAll k \\<phi>) (nFAll k \\<psi>)\"\n| \"nFAll k \\<phi> = (if find k 0 \\<phi> then FAll k \\<phi> else decr k 0 \\<phi>)\""], ["", "fun nFNot :: \"('a, 'k) aformula \\<Rightarrow> ('a, 'k) aformula\" where\n  \"nFNot (FNot \\<phi>) = \\<phi>\"\n| \"nFNot (FOr \\<phi> \\<psi>) = nFAnd (nFNot \\<phi>) (nFNot \\<psi>)\"\n| \"nFNot (FAnd \\<phi> \\<psi>) = nFOr (nFNot \\<phi>) (nFNot \\<psi>)\"\n| \"nFNot (FEx b \\<phi>) = nFAll b (nFNot \\<phi>)\"\n| \"nFNot (FAll b \\<phi>) = nFEx b (nFNot \\<phi>)\"\n| \"nFNot (FBool b) = FBool (\\<not> b)\"\n| \"nFNot \\<phi> = FNot \\<phi>\""], ["", "fun norm where\n  \"norm (FOr \\<phi> \\<psi>) = nFOr (norm \\<phi>) (norm \\<psi>)\"\n| \"norm (FAnd \\<phi> \\<psi>) = nFAnd (norm \\<phi>) (norm \\<psi>)\"\n| \"norm (FNot \\<phi>) = nFNot (norm \\<phi>)\"\n| \"norm (FEx k \\<phi>) = nFEx k (norm \\<phi>)\"\n| \"norm (FAll k \\<phi>) = nFAll k (norm \\<phi>)\"\n| \"norm \\<phi> = \\<phi>\""], ["", "context\nfixes deriv0 :: \"'x \\<Rightarrow> 'a \\<Rightarrow> ('a, 'k) aformula\"\nbegin"], ["", "primrec deriv :: \"'x \\<Rightarrow> ('a, 'k) aformula \\<Rightarrow> ('a, 'k) aformula\" where\n  \"deriv x (FBool b) = FBool b\"\n| \"deriv x (FBase a) = deriv0 x a\"\n| \"deriv x (FNot \\<phi>) = FNot (deriv x \\<phi>)\"\n| \"deriv x (FOr \\<phi> \\<psi>) = FOr (deriv x \\<phi>) (deriv x \\<psi>)\"\n| \"deriv x (FAnd \\<phi> \\<psi>) = FAnd (deriv x \\<phi>) (deriv x \\<psi>)\"\n| \"deriv x (FEx k \\<phi>) = FEx k (FOr (deriv (extend k True x) \\<phi>) (deriv (extend k False x) \\<phi>))\"\n| \"deriv x (FAll k \\<phi>) = FAll k (FAnd (deriv (extend k True x) \\<phi>) (deriv (extend k False x) \\<phi>))\""], ["", "end"], ["", "abbreviation \"lderiv \\<equiv> deriv lderiv0\""], ["", "abbreviation \"rderiv \\<equiv> deriv rderiv0\""], ["", "lemma fold_deriv_FBool: \"fold (deriv d0) xs (FBool b) = FBool b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (deriv d0) xs (FBool b) = FBool b", "by (induct xs) auto"], ["", "lemma fold_deriv_FNot:\n  \"fold (deriv d0) xs (FNot \\<phi>) = FNot (fold (deriv d0) xs \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (deriv d0) xs (FNot \\<phi>) = FNot (fold (deriv d0) xs \\<phi>)", "by (induct xs arbitrary: \\<phi>) auto"], ["", "lemma fold_deriv_FOr:\n  \"fold (deriv d0) xs (FOr \\<phi> \\<psi>) = FOr (fold (deriv d0) xs \\<phi>) (fold (deriv d0) xs \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (deriv d0) xs (FOr \\<phi> \\<psi>) =\n    FOr (fold (deriv d0) xs \\<phi>) (fold (deriv d0) xs \\<psi>)", "by (induct xs arbitrary: \\<phi> \\<psi>) auto"], ["", "lemma fold_deriv_FAnd:\n  \"fold (deriv d0) xs (FAnd \\<phi> \\<psi>) = FAnd (fold (deriv d0) xs \\<phi>) (fold (deriv d0) xs \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (deriv d0) xs (FAnd \\<phi> \\<psi>) =\n    FAnd (fold (deriv d0) xs \\<phi>) (fold (deriv d0) xs \\<psi>)", "by (induct xs arbitrary: \\<phi> \\<psi>) auto"], ["", "lemma fold_deriv_FEx:\n  \"{\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> | xs. True} \\<subseteq>\n    {FEx k \\<psi> | \\<psi>. nf_ACI \\<psi> \\<and> disjuncts \\<psi> \\<subseteq> (\\<Union>xs. disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FEx k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 disjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 disjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FEx k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 disjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 disjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FEx k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 disjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 disjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FEx k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 disjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 disjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "have \"\\<exists>\\<psi>. \\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> = FEx k \\<psi> \\<and>\n      nf_ACI \\<psi> \\<and> disjuncts \\<psi> \\<subseteq> (\\<Union>xs. disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       \\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> =\n       FEx k \\<psi> \\<and>\n       nf_ACI \\<psi> \\<and>\n       disjuncts \\<psi>\n       \\<subseteq> (\\<Union>xs.\n                       disjuncts\n                        \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "proof (induct xs arbitrary: \\<phi>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) [] (FEx k \\<phi>)\\<rangle> =\n          FEx k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          disjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          disjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n 2. \\<And>a xs \\<phi>.\n       (\\<And>\\<phi>.\n           \\<exists>\\<psi>.\n              \\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> =\n              FEx k \\<psi> \\<and>\n              nf_ACI \\<psi> \\<and>\n              disjuncts \\<psi>\n              \\<subseteq> (\\<Union>xs.\n                              disjuncts\n                               \\<langle>fold (deriv d0) xs\n   \\<phi>\\<rangle>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) (a # xs) (FEx k \\<phi>)\\<rangle> =\n          FEx k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          disjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          disjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) xs (FEx k ?\\<phi>)\\<rangle> =\n     FEx k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts \\<langle>fold (deriv d0) xs ?\\<phi>\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) [] (FEx k \\<phi>)\\<rangle> =\n          FEx k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          disjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          disjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n 2. \\<And>a xs \\<phi>.\n       (\\<And>\\<phi>.\n           \\<exists>\\<psi>.\n              \\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> =\n              FEx k \\<psi> \\<and>\n              nf_ACI \\<psi> \\<and>\n              disjuncts \\<psi>\n              \\<subseteq> (\\<Union>xs.\n                              disjuncts\n                               \\<langle>fold (deriv d0) xs\n   \\<phi>\\<rangle>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) (a # xs) (FEx k \\<phi>)\\<rangle> =\n          FEx k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          disjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          disjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "let ?\\<phi> = \"FOr (deriv d0 (extend k True x) \\<phi>) (deriv d0 (extend k False x) \\<phi>)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) [] (FEx k \\<phi>)\\<rangle> =\n          FEx k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          disjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          disjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n 2. \\<And>a xs \\<phi>.\n       (\\<And>\\<phi>.\n           \\<exists>\\<psi>.\n              \\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> =\n              FEx k \\<psi> \\<and>\n              nf_ACI \\<psi> \\<and>\n              disjuncts \\<psi>\n              \\<subseteq> (\\<Union>xs.\n                              disjuncts\n                               \\<langle>fold (deriv d0) xs\n   \\<phi>\\<rangle>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) (a # xs) (FEx k \\<phi>)\\<rangle> =\n          FEx k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          disjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          disjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "from Cons[of ?\\<phi>]"], ["proof (chain)\npicking this:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) xs\n               (FEx k\n                 (FOr (deriv d0 (extend k True x) \\<phi>)\n                   (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n     FEx k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FOr (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)", "obtain \\<psi> where \"\\<langle>fold (deriv d0) xs (FEx k ?\\<phi>)\\<rangle> = FEx k \\<psi>\"\n        \"nf_ACI \\<psi>\" and *: \"disjuncts \\<psi> \\<subseteq> (\\<Union>xs. disjuncts \\<langle>fold (deriv d0) xs ?\\<phi>\\<rangle>)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) xs\n               (FEx k\n                 (FOr (deriv d0 (extend k True x) \\<phi>)\n                   (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n     FEx k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FOr (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        \\<lbrakk>\\<langle>fold (deriv d0) xs\n                           (FEx k\n                             (FOr (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>)))\\<rangle> =\n                 FEx k \\<psi>;\n         nf_ACI \\<psi>;\n         disjuncts \\<psi>\n         \\<subseteq> (\\<Union>xs.\n                         disjuncts\n                          \\<langle>fold (deriv d0) xs\n                                    (FOr (deriv d0 (extend k True x) \\<phi>)\n(deriv d0 (extend k False x) \\<phi>))\\<rangle>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  \\<langle>fold (deriv d0) xs\n            (FEx k\n              (FOr (deriv d0 (extend k True x) \\<phi>)\n                (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n  FEx k \\<psi>\n  nf_ACI \\<psi>\n  disjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  disjuncts\n                   \\<langle>fold (deriv d0) xs\n                             (FOr (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>))\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) [] (FEx k \\<phi>)\\<rangle> =\n          FEx k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          disjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          disjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n 2. \\<And>a xs \\<phi>.\n       (\\<And>\\<phi>.\n           \\<exists>\\<psi>.\n              \\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> =\n              FEx k \\<psi> \\<and>\n              nf_ACI \\<psi> \\<and>\n              disjuncts \\<psi>\n              \\<subseteq> (\\<Union>xs.\n                              disjuncts\n                               \\<langle>fold (deriv d0) xs\n   \\<phi>\\<rangle>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) (a # xs) (FEx k \\<phi>)\\<rangle> =\n          FEx k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          disjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          disjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "then"], ["proof (chain)\npicking this:\n  \\<langle>fold (deriv d0) xs\n            (FEx k\n              (FOr (deriv d0 (extend k True x) \\<phi>)\n                (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n  FEx k \\<psi>\n  nf_ACI \\<psi>\n  disjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  disjuncts\n                   \\<langle>fold (deriv d0) xs\n                             (FOr (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>))\\<rangle>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<langle>fold (deriv d0) xs\n            (FEx k\n              (FOr (deriv d0 (extend k True x) \\<phi>)\n                (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n  FEx k \\<psi>\n  nf_ACI \\<psi>\n  disjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  disjuncts\n                   \\<langle>fold (deriv d0) xs\n                             (FOr (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>))\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       \\<langle>fold (deriv d0) (x # xs) (FEx k \\<phi>)\\<rangle> =\n       FEx k \\<psi> \\<and>\n       nf_ACI \\<psi> \\<and>\n       disjuncts \\<psi>\n       \\<subseteq> (\\<Union>xs.\n                       disjuncts\n                        \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "proof (intro exI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FEx k\n                         (FOr (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FEx k \\<psi>;\n     nf_ACI \\<psi>;\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FOr (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> \\<langle>fold (deriv d0) (x # xs)\n                                (FEx k \\<phi>)\\<rangle> =\n                      FEx k ?\\<psi>3\n 2. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FEx k\n                         (FOr (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FEx k \\<psi>;\n     nf_ACI \\<psi>;\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FOr (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> nf_ACI ?\\<psi>3\n 3. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FEx k\n                         (FOr (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FEx k \\<psi>;\n     nf_ACI \\<psi>;\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FOr (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> disjuncts ?\\<psi>3\n                      \\<subseteq> (\\<Union>xs.\ndisjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "have \"(\\<Union>xs. disjuncts \\<langle>fold (deriv d0) xs ?\\<phi>\\<rangle>) \\<subseteq>\n          (\\<Union>xs. disjuncts \\<langle>fold (Formula_Operations.deriv extend d0) xs \\<phi>\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>xs.\n        disjuncts\n         \\<langle>fold (deriv d0) xs\n                   (FOr (deriv d0 (extend k True x) \\<phi>)\n                     (deriv d0 (extend k False x) \\<phi>))\\<rangle>)\n    \\<subseteq> (\\<Union>xs.\n                    disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "by (force simp: fold_deriv_FOr nf_ACI_juncts nf_ACI_norm_ACI\n          dest: notin_juncts subsetD[OF equalityD1[OF disjuncts_NFOR], rotated -1]\n          intro: exI[of _ \"extend k b x # xs\" for b xs])"], ["proof (state)\nthis:\n  (\\<Union>xs.\n      disjuncts\n       \\<langle>fold (deriv d0) xs\n                 (FOr (deriv d0 (extend k True x) \\<phi>)\n                   (deriv d0 (extend k False x) \\<phi>))\\<rangle>)\n  \\<subseteq> (\\<Union>xs.\n                  disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FEx k\n                         (FOr (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FEx k \\<psi>;\n     nf_ACI \\<psi>;\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FOr (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> \\<langle>fold (deriv d0) (x # xs)\n                                (FEx k \\<phi>)\\<rangle> =\n                      FEx k ?\\<psi>3\n 2. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FEx k\n                         (FOr (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FEx k \\<psi>;\n     nf_ACI \\<psi>;\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FOr (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> nf_ACI ?\\<psi>3\n 3. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FEx k\n                         (FOr (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FEx k \\<psi>;\n     nf_ACI \\<psi>;\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FOr (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> disjuncts ?\\<psi>3\n                      \\<subseteq> (\\<Union>xs.\ndisjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "with *"], ["proof (chain)\npicking this:\n  disjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  disjuncts\n                   \\<langle>fold (deriv d0) xs\n                             (FOr (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>))\\<rangle>)\n  (\\<Union>xs.\n      disjuncts\n       \\<langle>fold (deriv d0) xs\n                 (FOr (deriv d0 (extend k True x) \\<phi>)\n                   (deriv d0 (extend k False x) \\<phi>))\\<rangle>)\n  \\<subseteq> (\\<Union>xs.\n                  disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "show \"disjuncts \\<psi> \\<subseteq> \\<dots>\""], ["proof (prove)\nusing this:\n  disjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  disjuncts\n                   \\<langle>fold (deriv d0) xs\n                             (FOr (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>))\\<rangle>)\n  (\\<Union>xs.\n      disjuncts\n       \\<langle>fold (deriv d0) xs\n                 (FOr (deriv d0 (extend k True x) \\<phi>)\n                   (deriv d0 (extend k False x) \\<phi>))\\<rangle>)\n  \\<subseteq> (\\<Union>xs.\n                  disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. disjuncts \\<psi>\n    \\<subseteq> (\\<Union>xs.\n                    disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "by blast"], ["proof (state)\nthis:\n  disjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FEx k\n                         (FOr (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FEx k \\<psi>;\n     nf_ACI \\<psi>;\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FOr (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> \\<langle>fold (deriv d0) (x # xs)\n                                (FEx k \\<phi>)\\<rangle> =\n                      FEx k \\<psi>\n 2. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FEx k\n                         (FOr (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FEx k \\<psi>;\n     nf_ACI \\<psi>;\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FOr (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> nf_ACI \\<psi>", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) (x # xs) (FEx k \\<phi>)\\<rangle> =\n     FEx k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) [] (FEx k \\<phi>)\\<rangle> =\n          FEx k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          disjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          disjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "qed (auto simp: nf_ACI_norm_ACI intro!: exI[of _ \"[]\"])"], ["proof (state)\nthis:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> =\n     FEx k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FEx k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 disjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 disjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "}"], ["proof (state)\nthis:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) ?xs2 (FEx k \\<phi>)\\<rangle> =\n     FEx k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FEx k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 disjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 disjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) ?xs2 (FEx k \\<phi>)\\<rangle> =\n     FEx k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) ?xs2 (FEx k \\<phi>)\\<rangle> =\n     FEx k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     disjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FEx k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 disjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 disjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "by blast"], ["proof (state)\nthis:\n  {\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> |xs. True}\n  \\<subseteq> {FEx k \\<psi> |\\<psi>.\n               nf_ACI \\<psi> \\<and>\n               disjuncts \\<psi>\n               \\<subseteq> (\\<Union>xs.\n                               disjuncts\n                                \\<langle>fold (deriv d0) xs\n    \\<phi>\\<rangle>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_deriv_FAll:\n  \"{\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> | xs. True} \\<subseteq>\n    {FAll k \\<psi> | \\<psi>. nf_ACI \\<psi> \\<and> conjuncts \\<psi> \\<subseteq> (\\<Union>xs. conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FAll k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 conjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 conjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FAll k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 conjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 conjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FAll k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 conjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 conjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FAll k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 conjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 conjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "have \"\\<exists>\\<psi>. \\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> = FAll k \\<psi> \\<and>\n      nf_ACI \\<psi> \\<and> conjuncts \\<psi> \\<subseteq> (\\<Union>xs. conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       \\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> =\n       FAll k \\<psi> \\<and>\n       nf_ACI \\<psi> \\<and>\n       conjuncts \\<psi>\n       \\<subseteq> (\\<Union>xs.\n                       conjuncts\n                        \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "proof (induct xs arbitrary: \\<phi>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) [] (FAll k \\<phi>)\\<rangle> =\n          FAll k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          conjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          conjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n 2. \\<And>a xs \\<phi>.\n       (\\<And>\\<phi>.\n           \\<exists>\\<psi>.\n              \\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> =\n              FAll k \\<psi> \\<and>\n              nf_ACI \\<psi> \\<and>\n              conjuncts \\<psi>\n              \\<subseteq> (\\<Union>xs.\n                              conjuncts\n                               \\<langle>fold (deriv d0) xs\n   \\<phi>\\<rangle>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) (a # xs) (FAll k \\<phi>)\\<rangle> =\n          FAll k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          conjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          conjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) xs (FAll k ?\\<phi>)\\<rangle> =\n     FAll k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts \\<langle>fold (deriv d0) xs ?\\<phi>\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) [] (FAll k \\<phi>)\\<rangle> =\n          FAll k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          conjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          conjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n 2. \\<And>a xs \\<phi>.\n       (\\<And>\\<phi>.\n           \\<exists>\\<psi>.\n              \\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> =\n              FAll k \\<psi> \\<and>\n              nf_ACI \\<psi> \\<and>\n              conjuncts \\<psi>\n              \\<subseteq> (\\<Union>xs.\n                              conjuncts\n                               \\<langle>fold (deriv d0) xs\n   \\<phi>\\<rangle>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) (a # xs) (FAll k \\<phi>)\\<rangle> =\n          FAll k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          conjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          conjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "let ?\\<phi> = \"FAnd (deriv d0 (extend k True x) \\<phi>) (deriv d0 (extend k False x) \\<phi>)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) [] (FAll k \\<phi>)\\<rangle> =\n          FAll k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          conjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          conjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n 2. \\<And>a xs \\<phi>.\n       (\\<And>\\<phi>.\n           \\<exists>\\<psi>.\n              \\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> =\n              FAll k \\<psi> \\<and>\n              nf_ACI \\<psi> \\<and>\n              conjuncts \\<psi>\n              \\<subseteq> (\\<Union>xs.\n                              conjuncts\n                               \\<langle>fold (deriv d0) xs\n   \\<phi>\\<rangle>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) (a # xs) (FAll k \\<phi>)\\<rangle> =\n          FAll k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          conjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          conjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "from Cons[of ?\\<phi>]"], ["proof (chain)\npicking this:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) xs\n               (FAll k\n                 (FAnd (deriv d0 (extend k True x) \\<phi>)\n                   (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n     FAll k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FAnd (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)", "obtain \\<psi> where \"\\<langle>fold (deriv d0) xs (FAll k ?\\<phi>)\\<rangle> = FAll k \\<psi>\"\n        \"nf_ACI \\<psi>\" and *: \"conjuncts \\<psi> \\<subseteq> (\\<Union>xs. conjuncts \\<langle>fold (deriv d0) xs ?\\<phi>\\<rangle>)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) xs\n               (FAll k\n                 (FAnd (deriv d0 (extend k True x) \\<phi>)\n                   (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n     FAll k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FAnd (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        \\<lbrakk>\\<langle>fold (deriv d0) xs\n                           (FAll k\n                             (FAnd (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>)))\\<rangle> =\n                 FAll k \\<psi>;\n         nf_ACI \\<psi>;\n         conjuncts \\<psi>\n         \\<subseteq> (\\<Union>xs.\n                         conjuncts\n                          \\<langle>fold (deriv d0) xs\n                                    (FAnd\n(deriv d0 (extend k True x) \\<phi>)\n(deriv d0 (extend k False x) \\<phi>))\\<rangle>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  \\<langle>fold (deriv d0) xs\n            (FAll k\n              (FAnd (deriv d0 (extend k True x) \\<phi>)\n                (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n  FAll k \\<psi>\n  nf_ACI \\<psi>\n  conjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  conjuncts\n                   \\<langle>fold (deriv d0) xs\n                             (FAnd (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>))\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>.\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) [] (FAll k \\<phi>)\\<rangle> =\n          FAll k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          conjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          conjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n 2. \\<And>a xs \\<phi>.\n       (\\<And>\\<phi>.\n           \\<exists>\\<psi>.\n              \\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> =\n              FAll k \\<psi> \\<and>\n              nf_ACI \\<psi> \\<and>\n              conjuncts \\<psi>\n              \\<subseteq> (\\<Union>xs.\n                              conjuncts\n                               \\<langle>fold (deriv d0) xs\n   \\<phi>\\<rangle>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) (a # xs) (FAll k \\<phi>)\\<rangle> =\n          FAll k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          conjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          conjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "then"], ["proof (chain)\npicking this:\n  \\<langle>fold (deriv d0) xs\n            (FAll k\n              (FAnd (deriv d0 (extend k True x) \\<phi>)\n                (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n  FAll k \\<psi>\n  nf_ACI \\<psi>\n  conjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  conjuncts\n                   \\<langle>fold (deriv d0) xs\n                             (FAnd (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>))\\<rangle>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<langle>fold (deriv d0) xs\n            (FAll k\n              (FAnd (deriv d0 (extend k True x) \\<phi>)\n                (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n  FAll k \\<psi>\n  nf_ACI \\<psi>\n  conjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  conjuncts\n                   \\<langle>fold (deriv d0) xs\n                             (FAnd (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>))\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       \\<langle>fold (deriv d0) (x # xs) (FAll k \\<phi>)\\<rangle> =\n       FAll k \\<psi> \\<and>\n       nf_ACI \\<psi> \\<and>\n       conjuncts \\<psi>\n       \\<subseteq> (\\<Union>xs.\n                       conjuncts\n                        \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "proof (intro exI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FAll k\n                         (FAnd (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FAll k \\<psi>;\n     nf_ACI \\<psi>;\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FAnd (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> \\<langle>fold (deriv d0) (x # xs)\n                                (FAll k \\<phi>)\\<rangle> =\n                      FAll k ?\\<psi>3\n 2. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FAll k\n                         (FAnd (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FAll k \\<psi>;\n     nf_ACI \\<psi>;\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FAnd (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> nf_ACI ?\\<psi>3\n 3. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FAll k\n                         (FAnd (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FAll k \\<psi>;\n     nf_ACI \\<psi>;\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FAnd (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> conjuncts ?\\<psi>3\n                      \\<subseteq> (\\<Union>xs.\nconjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "have \"(\\<Union>xs. conjuncts \\<langle>fold (deriv d0) xs ?\\<phi>\\<rangle>) \\<subseteq>\n          (\\<Union>xs. conjuncts \\<langle>fold (Formula_Operations.deriv extend d0) xs \\<phi>\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>xs.\n        conjuncts\n         \\<langle>fold (deriv d0) xs\n                   (FAnd (deriv d0 (extend k True x) \\<phi>)\n                     (deriv d0 (extend k False x) \\<phi>))\\<rangle>)\n    \\<subseteq> (\\<Union>xs.\n                    conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "by (force simp: fold_deriv_FAnd nf_ACI_juncts nf_ACI_norm_ACI\n          dest: notin_juncts subsetD[OF equalityD1[OF conjuncts_NFAND], rotated -1]\n          intro: exI[of _ \"extend k b x # xs\" for b xs])"], ["proof (state)\nthis:\n  (\\<Union>xs.\n      conjuncts\n       \\<langle>fold (deriv d0) xs\n                 (FAnd (deriv d0 (extend k True x) \\<phi>)\n                   (deriv d0 (extend k False x) \\<phi>))\\<rangle>)\n  \\<subseteq> (\\<Union>xs.\n                  conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FAll k\n                         (FAnd (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FAll k \\<psi>;\n     nf_ACI \\<psi>;\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FAnd (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> \\<langle>fold (deriv d0) (x # xs)\n                                (FAll k \\<phi>)\\<rangle> =\n                      FAll k ?\\<psi>3\n 2. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FAll k\n                         (FAnd (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FAll k \\<psi>;\n     nf_ACI \\<psi>;\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FAnd (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> nf_ACI ?\\<psi>3\n 3. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FAll k\n                         (FAnd (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FAll k \\<psi>;\n     nf_ACI \\<psi>;\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FAnd (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> conjuncts ?\\<psi>3\n                      \\<subseteq> (\\<Union>xs.\nconjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "with *"], ["proof (chain)\npicking this:\n  conjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  conjuncts\n                   \\<langle>fold (deriv d0) xs\n                             (FAnd (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>))\\<rangle>)\n  (\\<Union>xs.\n      conjuncts\n       \\<langle>fold (deriv d0) xs\n                 (FAnd (deriv d0 (extend k True x) \\<phi>)\n                   (deriv d0 (extend k False x) \\<phi>))\\<rangle>)\n  \\<subseteq> (\\<Union>xs.\n                  conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "show \"conjuncts \\<psi> \\<subseteq> \\<dots>\""], ["proof (prove)\nusing this:\n  conjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  conjuncts\n                   \\<langle>fold (deriv d0) xs\n                             (FAnd (deriv d0 (extend k True x) \\<phi>)\n                               (deriv d0 (extend k False x)\n                                 \\<phi>))\\<rangle>)\n  (\\<Union>xs.\n      conjuncts\n       \\<langle>fold (deriv d0) xs\n                 (FAnd (deriv d0 (extend k True x) \\<phi>)\n                   (deriv d0 (extend k False x) \\<phi>))\\<rangle>)\n  \\<subseteq> (\\<Union>xs.\n                  conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. conjuncts \\<psi>\n    \\<subseteq> (\\<Union>xs.\n                    conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "by blast"], ["proof (state)\nthis:\n  conjuncts \\<psi>\n  \\<subseteq> (\\<Union>xs.\n                  conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FAll k\n                         (FAnd (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FAll k \\<psi>;\n     nf_ACI \\<psi>;\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FAnd (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> \\<langle>fold (deriv d0) (x # xs)\n                                (FAll k \\<phi>)\\<rangle> =\n                      FAll k \\<psi>\n 2. \\<lbrakk>\\<langle>fold (deriv d0) xs\n                       (FAll k\n                         (FAnd (deriv d0 (extend k True x) \\<phi>)\n                           (deriv d0 (extend k False x) \\<phi>)))\\<rangle> =\n             FAll k \\<psi>;\n     nf_ACI \\<psi>;\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts\n                      \\<langle>fold (deriv d0) xs\n                                (FAnd (deriv d0 (extend k True x) \\<phi>)\n                                  (deriv d0 (extend k False x)\n                                    \\<phi>))\\<rangle>)\\<rbrakk>\n    \\<Longrightarrow> nf_ACI \\<psi>", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) (x # xs) (FAll k \\<phi>)\\<rangle> =\n     FAll k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<exists>\\<psi>.\n          \\<langle>fold (deriv d0) [] (FAll k \\<phi>)\\<rangle> =\n          FAll k \\<psi> \\<and>\n          nf_ACI \\<psi> \\<and>\n          conjuncts \\<psi>\n          \\<subseteq> (\\<Union>xs.\n                          conjuncts\n                           \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "qed (auto simp: nf_ACI_norm_ACI intro!: exI[of _ \"[]\"])"], ["proof (state)\nthis:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> =\n     FAll k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FAll k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 conjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 conjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "}"], ["proof (state)\nthis:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) ?xs2 (FAll k \\<phi>)\\<rangle> =\n     FAll k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FAll k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 conjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 conjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) ?xs2 (FAll k \\<phi>)\\<rangle> =\n     FAll k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>\\<psi>.\n     \\<langle>fold (deriv d0) ?xs2 (FAll k \\<phi>)\\<rangle> =\n     FAll k \\<psi> \\<and>\n     nf_ACI \\<psi> \\<and>\n     conjuncts \\<psi>\n     \\<subseteq> (\\<Union>xs.\n                     conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. {\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> |xs. True}\n    \\<subseteq> {FAll k \\<psi> |\\<psi>.\n                 nf_ACI \\<psi> \\<and>\n                 conjuncts \\<psi>\n                 \\<subseteq> (\\<Union>xs.\n                                 conjuncts\n                                  \\<langle>fold (deriv d0) xs\n      \\<phi>\\<rangle>)}", "by blast"], ["proof (state)\nthis:\n  {\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> |xs. True}\n  \\<subseteq> {FAll k \\<psi> |\\<psi>.\n               nf_ACI \\<psi> \\<and>\n               conjuncts \\<psi>\n               \\<subseteq> (\\<Union>xs.\n                               conjuncts\n                                \\<langle>fold (deriv d0) xs\n    \\<phi>\\<rangle>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_norm_ACI_juncts:\n  fixes f :: \"('a, 'k) aformula \\<Rightarrow> ('a, 'k) aformula\"\n  shows \"finite B \\<Longrightarrow> finite {f \\<phi> | \\<phi>. nf_ACI \\<phi> \\<and> disjuncts \\<phi> \\<subseteq> B}\"\n        \"finite B \\<Longrightarrow> finite {f \\<phi> | \\<phi>. nf_ACI \\<phi> \\<and> conjuncts \\<phi> \\<subseteq> B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite B \\<Longrightarrow>\n     finite\n      {f \\<phi> |\\<phi>.\n       nf_ACI \\<phi> \\<and> disjuncts \\<phi> \\<subseteq> B}) &&&\n    (finite B \\<Longrightarrow>\n     finite\n      {f \\<phi> |\\<phi>.\n       nf_ACI \\<phi> \\<and> conjuncts \\<phi> \\<subseteq> B})", "by (elim finite_surj[OF iffD2[OF finite_Pow_iff], of _ _ \"f o NFOR o image norm_ACI\"]\n    finite_surj[OF iffD2[OF finite_Pow_iff], of _ _ \"f o NFAND o image norm_ACI\"],\n    force simp: Pow_def image_Collect intro: arg_cong[OF norm_ACI_NFOR] arg_cong[OF norm_ACI_NFAND])+"], ["", "end"], ["", "locale Formula = Formula_Operations\n  where TYPEVARS = TYPEVARS\n  for TYPEVARS :: \"'a :: linorder \\<times> 'i \\<times> 'k :: {linorder, enum} \\<times> 'n \\<times> 'x \\<times> 'v\" +\n  (* De Bruijn indices abstractly *)\n  assumes SUC_SUC: \"SUC k (SUC k' idx) = SUC k' (SUC k idx)\"\n  and LEQ_0: \"LEQ k 0 idx\"\n  and LESS_SUC: \"LEQ k (Suc l) idx = LESS k l idx\"\n    \"k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\"\n\n  (* Interpretations *)\n  and nvars_Extend: \"#\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\"\n  and Length_Extend: \"Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\"\n  and Length_0_inj: \"\\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk> \\<Longrightarrow> \\<AA> = \\<BB>\"\n  and ex_Length_0: \"\\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\"\n  and Extend_commute_safe: \"\\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk> \\<Longrightarrow>\n      Extend k j (Extend k i \\<AA> P) Q = Extend k (Suc i) (Extend k j \\<AA> Q) P\"\n  and Extend_commute_unsafe: \"k \\<noteq> k' \\<Longrightarrow>\n      Extend k j (Extend k' i \\<AA> P) Q = Extend k' i (Extend k j \\<AA> Q) P\"\n  and assigns_Extend:  \"LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n    m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' = (if k = k' then (if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k) else m\\<^bsup>\\<AA>\\<^esup>k')\"\n  and assigns_SNOC_zero: \"LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow> m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k = m\\<^bsup>\\<AA>\\<^esup>k\"\n  and Length_CONS: \"Length (CONS x \\<AA>) = Length \\<AA> + 1\"\n  and Length_SNOC: \"Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\"\n  and nvars_CONS: \"#\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\"\n  and nvars_SNOC: \"#\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\"\n  and Extend_CONS: \"#\\<^sub>V \\<AA> = size x \\<Longrightarrow> Extend k 0 (CONS x \\<AA>) P =\n      CONS (extend k (if eval P 0 then True else False) x) (Extend k 0 \\<AA> (downshift P))\"\n  and Extend_SNOC_cut: \"#\\<^sub>V \\<AA> = size x \\<Longrightarrow> len P \\<le> Length (SNOC x \\<AA>) \\<Longrightarrow>\n    Extend k 0 (SNOC x \\<AA>) P =\n    SNOC (extend k (if eval P (Length \\<AA>) then True else False) x) (Extend k 0 \\<AA> (cut (Length \\<AA>) P))\"\n  and CONS_inj: \"size x = #\\<^sub>V \\<AA> \\<Longrightarrow> size y = #\\<^sub>V \\<AA> \\<Longrightarrow> #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB> \\<Longrightarrow>\n    CONS x \\<AA> = CONS y \\<BB> \\<longleftrightarrow> (x = y \\<and> \\<AA> = \\<BB>)\"\n  and CONS_surj: \"Length \\<AA> \\<noteq> 0 \\<Longrightarrow> #\\<^sub>V \\<AA> = idx \\<Longrightarrow>\n    \\<exists>x \\<BB>. \\<AA> = CONS x \\<BB> \\<and> #\\<^sub>V \\<BB> = idx \\<and> size x = idx\"\n\n  (* Alphabet elements *)\n  and size_zero: \"size (zero idx) = idx\"\n  and size_extend: \"size (extend k b x) = SUC k (size x)\"\n  and distinct_alphabet: \"distinct (alphabet idx)\"\n  and alphabet_size: \"x \\<in> set (alphabet idx) \\<longleftrightarrow> size x = idx\"\n\n  (* Valuations *)\n  and downshift_upshift: \"downshift (upshift P) = P\"\n  and downshift_add_zero: \"downshift (add 0 P) = downshift P\"\n  and eval_add: \"eval (add n P) n\"\n  and eval_upshift: \"\\<not> eval (upshift P) 0\"\n  and eval_ge_len: \"p \\<ge> len P \\<Longrightarrow> \\<not> eval P p\"\n  and len_cut_le: \"len (cut n P) \\<le> n\"\n  and len_cut: \"len P \\<le> n \\<Longrightarrow> cut n P = P\"\n  and cut_add: \"cut n (add m P) = (if m \\<ge> n then cut n P else add m (cut n P))\"\n  and len_add: \"len (add m P) = max (Suc m) (len P)\"\n  and len_upshift: \"len (upshift P) = (case len P of 0 \\<Rightarrow> 0 | n \\<Rightarrow> Suc n)\"\n  and len_downshift: \"len (downshift P) = (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\"\n\n  (* Function extensions for the base cases *)\n  and wf0_decr0: \"\\<lbrakk>wf0 (SUC k idx) a; LESS k l (SUC k idx); \\<not> find0 k l a\\<rbrakk> \\<Longrightarrow> wf0 idx (decr0 k l a)\"\n  and lformula0_decr0: \"lformula0 \\<phi> \\<Longrightarrow> lformula0 (decr0 k l \\<phi>)\"\n  and Extend_satisfies0: \"\\<lbrakk>\\<not> find0 k i a; LESS k i (SUC k (#\\<^sub>V \\<AA>)); lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk> \\<Longrightarrow>\n      Extend k i \\<AA> P \\<Turnstile>\\<^sub>0 a \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>0 decr0 k i a\"\n  and nullable0_satisfies0: \"Length \\<AA> = 0 \\<Longrightarrow> nullable0 a \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>0 a\"\n  and satisfies0_eqI: \"wf0 (#\\<^sub>V \\<BB>) a \\<Longrightarrow> #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB> \\<Longrightarrow> lformula0 a \\<Longrightarrow>\n    (\\<And>m k. LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow> m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k) \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>0 a \\<longleftrightarrow> \\<BB> \\<Turnstile>\\<^sub>0 a\"\n  and wf_lderiv0: \"\\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk> \\<Longrightarrow> wf idx (lderiv0 x a)\"\n  and lformula_lderiv0: \"lformula0 a \\<Longrightarrow> lformula (lderiv0 x a)\"\n  and wf_rderiv0: \"wf0 idx a \\<Longrightarrow> wf idx (rderiv0 x a)\"\n  and satisfies_lderiv0:\n    \"\\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size x; lformula0 a\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile> lderiv0 x a \\<longleftrightarrow> CONS x \\<AA> \\<Turnstile>\\<^sub>0 a\"\n  and satisfies_bounded_lderiv0:\n    \"\\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size x; lformula0 a\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b lderiv0 x a \\<longleftrightarrow> CONS x \\<AA> \\<Turnstile>\\<^sub>0 a\"\n  and satisfies_bounded_rderiv0:\n    \"\\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size x\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b rderiv0 x a \\<longleftrightarrow> SNOC x \\<AA> \\<Turnstile>\\<^sub>0 a\"\n  and find0_FV0: \"\\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk> \\<Longrightarrow> find0 k l a \\<longleftrightarrow> l \\<in> FV0 k a\"\n  and finite_FV0: \"finite (FV0 k a)\"\n  and wf0_FV0_LESS: \"\\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk> \\<Longrightarrow> LESS k v idx\"\n  and restrict_Restrict: \"i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow> restrict k P \\<longleftrightarrow> satisfies_gen r \\<AA> (Restrict k i)\"\n  and wf_Restrict: \"LESS k i idx \\<Longrightarrow> wf idx (Restrict k i)\"\n  and lformula_Restrict: \"lformula (Restrict k i)\"\n  and finite_lderiv0: \"lformula0 a \\<Longrightarrow> finite {fold lderiv xs (FBase a) | xs. True}\"\n  and finite_rderiv0: \"finite {fold rderiv xs (FBase a) | xs. True}\""], ["", "context Formula\nbegin"], ["", "lemma satisfies_eqI:\n  \"\\<lbrakk>wf (#\\<^sub>V \\<AA>) \\<phi>; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>; \\<And>m k. LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow> m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k; lformula \\<phi>\\<rbrakk> \\<Longrightarrow>\n   \\<AA> \\<Turnstile> \\<phi> \\<longleftrightarrow> \\<BB> \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n     #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n     \\<And>m k.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n     lformula \\<phi>\\<rbrakk>\n    \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                      (\\<BB> \\<Turnstile> \\<phi>)", "proof (induct \\<phi> arbitrary: \\<AA> \\<BB>)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FNot \\<phi>) =\n                         (\\<BB> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FEx x1a \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FEx x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FEx x1a \\<phi>) =\n                         (\\<BB> \\<Turnstile> FEx x1a \\<phi>)\n 7. \\<And>x1a \\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAll x1a \\<phi>) =\n                         (\\<BB> \\<Turnstile> FAll x1a \\<phi>)", "case (FEx k \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf (#\\<^sub>V ?\\<AA>) \\<phi>;\n   #\\<^sub>V ?\\<AA> = #\\<^sub>V ?\\<BB>;\n   \\<And>m k.\n      LESS k m (#\\<^sub>V ?\\<AA>) \\<Longrightarrow>\n      m\\<^bsup>?\\<AA>\\<^esup>k = m\\<^bsup>?\\<BB>\\<^esup>k;\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (?\\<AA> \\<Turnstile> \\<phi>) =\n                    (?\\<BB> \\<Turnstile> \\<phi>)\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula (FEx k \\<phi>)\n\ngoal (7 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FNot \\<phi>) =\n                         (\\<BB> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FEx x1a \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FEx x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FEx x1a \\<phi>) =\n                         (\\<BB> \\<Turnstile> FEx x1a \\<phi>)\n 7. \\<And>x1a \\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAll x1a \\<phi>) =\n                         (\\<BB> \\<Turnstile> FAll x1a \\<phi>)", "from FEx.prems"], ["proof (chain)\npicking this:\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula (FEx k \\<phi>)", "have \"\\<And>P. (Extend k 0 \\<AA> P \\<Turnstile> \\<phi>) \\<longleftrightarrow> (Extend k 0 \\<BB> P \\<Turnstile> \\<phi>)\""], ["proof (prove)\nusing this:\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula (FEx k \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       (Extend k 0 \\<AA> P \\<Turnstile> \\<phi>) =\n       (Extend k 0 \\<BB> P \\<Turnstile> \\<phi>)", "by (intro FEx.hyps) (auto simp: nvars_Extend assigns_Extend dec_def gr0_conv_Suc LEQ_0 LESS_SUC)"], ["proof (state)\nthis:\n  (Extend k 0 \\<AA> ?P \\<Turnstile> \\<phi>) =\n  (Extend k 0 \\<BB> ?P \\<Turnstile> \\<phi>)\n\ngoal (7 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FNot \\<phi>) =\n                         (\\<BB> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FEx x1a \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FEx x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FEx x1a \\<phi>) =\n                         (\\<BB> \\<Turnstile> FEx x1a \\<phi>)\n 7. \\<And>x1a \\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAll x1a \\<phi>) =\n                         (\\<BB> \\<Turnstile> FAll x1a \\<phi>)", "then"], ["proof (chain)\npicking this:\n  (Extend k 0 \\<AA> ?P \\<Turnstile> \\<phi>) =\n  (Extend k 0 \\<BB> ?P \\<Turnstile> \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  (Extend k 0 \\<AA> ?P \\<Turnstile> \\<phi>) =\n  (Extend k 0 \\<BB> ?P \\<Turnstile> \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile> FEx k \\<phi>) = (\\<BB> \\<Turnstile> FEx k \\<phi>)", "by simp"], ["proof (state)\nthis:\n  (\\<AA> \\<Turnstile> FEx k \\<phi>) = (\\<BB> \\<Turnstile> FEx k \\<phi>)\n\ngoal (6 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FNot \\<phi>) =\n                         (\\<BB> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAll x1a \\<phi>) =\n                         (\\<BB> \\<Turnstile> FAll x1a \\<phi>)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FNot \\<phi>) =\n                         (\\<BB> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAll x1a \\<phi>) =\n                         (\\<BB> \\<Turnstile> FAll x1a \\<phi>)", "case (FAll k \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf (#\\<^sub>V ?\\<AA>) \\<phi>;\n   #\\<^sub>V ?\\<AA> = #\\<^sub>V ?\\<BB>;\n   \\<And>m k.\n      LESS k m (#\\<^sub>V ?\\<AA>) \\<Longrightarrow>\n      m\\<^bsup>?\\<AA>\\<^esup>k = m\\<^bsup>?\\<BB>\\<^esup>k;\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (?\\<AA> \\<Turnstile> \\<phi>) =\n                    (?\\<BB> \\<Turnstile> \\<phi>)\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula (FAll k \\<phi>)\n\ngoal (6 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FNot \\<phi>) =\n                         (\\<BB> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAll x1a \\<phi>) =\n                         (\\<BB> \\<Turnstile> FAll x1a \\<phi>)", "from FAll.prems"], ["proof (chain)\npicking this:\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula (FAll k \\<phi>)", "have \"\\<And>P. (Extend k 0 \\<AA> P \\<Turnstile> \\<phi>) \\<longleftrightarrow> (Extend k 0 \\<BB> P \\<Turnstile> \\<phi>)\""], ["proof (prove)\nusing this:\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula (FAll k \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       (Extend k 0 \\<AA> P \\<Turnstile> \\<phi>) =\n       (Extend k 0 \\<BB> P \\<Turnstile> \\<phi>)", "by (intro FAll.hyps) (auto simp: nvars_Extend assigns_Extend dec_def gr0_conv_Suc LEQ_0 LESS_SUC)"], ["proof (state)\nthis:\n  (Extend k 0 \\<AA> ?P \\<Turnstile> \\<phi>) =\n  (Extend k 0 \\<BB> ?P \\<Turnstile> \\<phi>)\n\ngoal (6 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FNot \\<phi>) =\n                         (\\<BB> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAll x1a \\<phi>) =\n                         (\\<BB> \\<Turnstile> FAll x1a \\<phi>)", "then"], ["proof (chain)\npicking this:\n  (Extend k 0 \\<AA> ?P \\<Turnstile> \\<phi>) =\n  (Extend k 0 \\<BB> ?P \\<Turnstile> \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  (Extend k 0 \\<AA> ?P \\<Turnstile> \\<phi>) =\n  (Extend k 0 \\<BB> ?P \\<Turnstile> \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile> FAll k \\<phi>) = (\\<BB> \\<Turnstile> FAll k \\<phi>)", "by simp"], ["proof (state)\nthis:\n  (\\<AA> \\<Turnstile> FAll k \\<phi>) = (\\<BB> \\<Turnstile> FAll k \\<phi>)\n\ngoal (5 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FNot \\<phi>) =\n                         (\\<BB> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FNot \\<phi>) =\n                         (\\<BB> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)", "case (FNot \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf (#\\<^sub>V ?\\<AA>) \\<phi>;\n   #\\<^sub>V ?\\<AA> = #\\<^sub>V ?\\<BB>;\n   \\<And>m k.\n      LESS k m (#\\<^sub>V ?\\<AA>) \\<Longrightarrow>\n      m\\<^bsup>?\\<AA>\\<^esup>k = m\\<^bsup>?\\<BB>\\<^esup>k;\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (?\\<AA> \\<Turnstile> \\<phi>) =\n                    (?\\<BB> \\<Turnstile> \\<phi>)\n  local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula (FNot \\<phi>)\n\ngoal (5 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FNot \\<phi>) =\n                         (\\<BB> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)", "from FNot.prems"], ["proof (chain)\npicking this:\n  local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula (FNot \\<phi>)", "have \"(\\<AA> \\<Turnstile> \\<phi>) \\<longleftrightarrow> (\\<BB> \\<Turnstile> \\<phi>)\""], ["proof (prove)\nusing this:\n  local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>)\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula (FNot \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile> \\<phi>) = (\\<BB> \\<Turnstile> \\<phi>)", "by (intro FNot.hyps) simp_all"], ["proof (state)\nthis:\n  (\\<AA> \\<Turnstile> \\<phi>) = (\\<BB> \\<Turnstile> \\<phi>)\n\ngoal (5 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>) =\n                                     (\\<BB> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FNot \\<phi>) =\n                         (\\<BB> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)", "then"], ["proof (chain)\npicking this:\n  (\\<AA> \\<Turnstile> \\<phi>) = (\\<BB> \\<Turnstile> \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<AA> \\<Turnstile> \\<phi>) = (\\<BB> \\<Turnstile> \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile> FNot \\<phi>) = (\\<BB> \\<Turnstile> FNot \\<phi>)", "by simp"], ["proof (state)\nthis:\n  (\\<AA> \\<Turnstile> FNot \\<phi>) = (\\<BB> \\<Turnstile> FNot \\<phi>)\n\ngoal (4 subgoals):\n 1. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBool x) =\n                         (\\<BB> \\<Turnstile> FBool x)\n 2. \\<And>x \\<AA> \\<BB>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FBase x) =\n                         (\\<BB> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 4. \\<And>\\<phi>1 \\<phi>2 \\<AA> \\<BB>.\n       \\<lbrakk>\\<And>\\<AA> \\<BB>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n                    \\<And>m k.\n                       LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n                       m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n                    lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>1) =\n                                     (\\<BB> \\<Turnstile> \\<phi>1);\n        \\<And>\\<AA> \\<BB>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n            \\<And>m k.\n               LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n               m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n            lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> \\<phi>2) =\n                             (\\<BB> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n        \\<And>m k.\n           LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n           m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k;\n        lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2) =\n                         (\\<BB> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)", "qed (auto dest: satisfies0_eqI)"], ["", "lemma wf_decr:\n  \"\\<lbrakk>wf (SUC k idx) \\<phi>; LEQ k l idx; \\<not> find k l \\<phi>\\<rbrakk> \\<Longrightarrow> wf idx (decr k l \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf (SUC k idx) \\<phi>; LEQ k l idx;\n     \\<not> local.find k l \\<phi>\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (decr k l \\<phi>)", "by (induct \\<phi> arbitrary: idx l) (auto simp: wf0_decr0 LESS_SUC SUC_SUC)"], ["", "lemma lformula_decr:\n  \"lformula \\<phi> \\<Longrightarrow> lformula (decr k l \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (decr k l \\<phi>)", "by (induct \\<phi> arbitrary: l) (auto simp: lformula0_decr0)"], ["", "lemma Extend_satisfies_decr:\n  \"\\<lbrakk>\\<not> find k i \\<phi>; LEQ k i (#\\<^sub>V \\<AA>); lformula \\<phi>\\<rbrakk> \\<Longrightarrow> Extend k i \\<AA> P \\<Turnstile> \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> decr k i \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> local.find k i \\<phi>; LEQ k i (#\\<^sub>V \\<AA>);\n     lformula \\<phi>\\<rbrakk>\n    \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile> \\<phi>) =\n                      (\\<AA> \\<Turnstile> decr k i \\<phi>)", "by (induct \\<phi> arbitrary: i \\<AA>)\n    (auto simp: Extend_commute_unsafe[of _ k 0 _ _ P] Extend_commute_safe\n      Extend_satisfies0 nvars_Extend LESS_SUC SUC_SUC split: bool.splits)"], ["", "lemma LEQ_SUC: \"k \\<noteq> k' \\<Longrightarrow> LEQ k i (SUC k' idx) = LEQ k i idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> k' \\<Longrightarrow> LEQ k i (SUC k' idx) = LEQ k i idx", "by (metis LESS_SUC(2) SUC_SUC)"], ["", "lemma Extend_satisfies_bounded_decr:\n  \"\\<lbrakk>\\<not> find k i \\<phi>; LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk> \\<Longrightarrow>\n   Extend k i \\<AA> P \\<Turnstile>\\<^sub>b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> local.find k i \\<phi>; LEQ k i (#\\<^sub>V \\<AA>);\n     len P \\<le> Length \\<AA>\\<rbrakk>\n    \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b \\<phi>) =\n                      (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>)", "proof (induct \\<phi> arbitrary: i \\<AA> P)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBool x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBool x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBool x))\n 2. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBase x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBase x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBase x))\n 3. \\<And>\\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FNot \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FNot \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FNot \\<phi>))\n 4. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FOr \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FOr \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FAnd \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FAnd \\<phi>1 \\<phi>2))\n 6. \\<And>x1a \\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FEx x1a \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FEx x1a \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FEx x1a \\<phi>))\n 7. \\<And>x1a \\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FAll x1a \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FAll x1a \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FAll x1a \\<phi>))", "case (FEx k' \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> local.find k ?i \\<phi>; LEQ k ?i (#\\<^sub>V ?\\<AA>);\n   len ?P \\<le> Length ?\\<AA>\\<rbrakk>\n  \\<Longrightarrow> (Extend k ?i ?\\<AA> ?P \\<Turnstile>\\<^sub>b \\<phi>) =\n                    (?\\<AA> \\<Turnstile>\\<^sub>b decr k ?i \\<phi>)\n  \\<not> local.find k i (FEx k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n\ngoal (7 subgoals):\n 1. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBool x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBool x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBool x))\n 2. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBase x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBase x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBase x))\n 3. \\<And>\\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FNot \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FNot \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FNot \\<phi>))\n 4. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FOr \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FOr \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FAnd \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FAnd \\<phi>1 \\<phi>2))\n 6. \\<And>x1a \\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FEx x1a \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FEx x1a \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FEx x1a \\<phi>))\n 7. \\<And>x1a \\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FAll x1a \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FAll x1a \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FAll x1a \\<phi>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))", "proof (cases \"k = k'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))\n 2. k \\<noteq> k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))", "case True"], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))\n 2. k \\<noteq> k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))", "with FEx(2,3,4)"], ["proof (chain)\npicking this:\n  \\<not> local.find k i (FEx k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k = k'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> local.find k i (FEx k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k = k'\n\ngoal (1 subgoal):\n 1. (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))", "using FEx(1)[of \"Suc i\" \"Extend k' 0 \\<AA> Q\" P for Q j]"], ["proof (prove)\nusing this:\n  \\<not> local.find k i (FEx k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k = k'\n  \\<lbrakk>\\<not> local.find k (Suc i) \\<phi>;\n   LEQ k (Suc i) (#\\<^sub>V (Extend k' 0 \\<AA> ?Q2));\n   len P \\<le> Length (Extend k' 0 \\<AA> ?Q2)\\<rbrakk>\n  \\<Longrightarrow> (Extend k (Suc i) (Extend k' 0 \\<AA> ?Q2)\n                      P \\<Turnstile>\\<^sub>b\n                     \\<phi>) =\n                    (Extend k' 0 \\<AA> ?Q2 \\<Turnstile>\\<^sub>b\n                     decr k (Suc i) \\<phi>)\n\ngoal (1 subgoal):\n 1. (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))", "by (auto simp: Extend_commute_safe LESS_SUC Length_Extend nvars_Extend max_def)"], ["proof (state)\nthis:\n  (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n  (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))\n\ngoal (1 subgoal):\n 1. k \\<noteq> k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. k \\<noteq> k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))", "with FEx(2,3,4)"], ["proof (chain)\npicking this:\n  \\<not> local.find k i (FEx k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k \\<noteq> k'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> local.find k i (FEx k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))", "using FEx(1)[of \"i\" \"Extend k' j \\<AA> Q\" P for Q j]"], ["proof (prove)\nusing this:\n  \\<not> local.find k i (FEx k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k \\<noteq> k'\n  \\<lbrakk>\\<not> local.find k i \\<phi>;\n   LEQ k i (#\\<^sub>V (Extend k' ?j2 \\<AA> ?Q2));\n   len P \\<le> Length (Extend k' ?j2 \\<AA> ?Q2)\\<rbrakk>\n  \\<Longrightarrow> (Extend k i (Extend k' ?j2 \\<AA> ?Q2)\n                      P \\<Turnstile>\\<^sub>b\n                     \\<phi>) =\n                    (Extend k' ?j2 \\<AA> ?Q2 \\<Turnstile>\\<^sub>b\n                     decr k i \\<phi>)\n\ngoal (1 subgoal):\n 1. (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))", "by (auto simp: Extend_commute_unsafe LEQ_SUC Length_Extend nvars_Extend max_def)"], ["proof (state)\nthis:\n  (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n  (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FEx k' \\<phi>) =\n  (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FEx k' \\<phi>))\n\ngoal (6 subgoals):\n 1. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBool x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBool x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBool x))\n 2. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBase x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBase x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBase x))\n 3. \\<And>\\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FNot \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FNot \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FNot \\<phi>))\n 4. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FOr \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FOr \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FAnd \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FAnd \\<phi>1 \\<phi>2))\n 6. \\<And>x1a \\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FAll x1a \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FAll x1a \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FAll x1a \\<phi>))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBool x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBool x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBool x))\n 2. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBase x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBase x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBase x))\n 3. \\<And>\\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FNot \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FNot \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FNot \\<phi>))\n 4. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FOr \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FOr \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FAnd \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FAnd \\<phi>1 \\<phi>2))\n 6. \\<And>x1a \\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FAll x1a \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FAll x1a \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FAll x1a \\<phi>))", "case (FAll k' \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> local.find k ?i \\<phi>; LEQ k ?i (#\\<^sub>V ?\\<AA>);\n   len ?P \\<le> Length ?\\<AA>\\<rbrakk>\n  \\<Longrightarrow> (Extend k ?i ?\\<AA> ?P \\<Turnstile>\\<^sub>b \\<phi>) =\n                    (?\\<AA> \\<Turnstile>\\<^sub>b decr k ?i \\<phi>)\n  \\<not> local.find k i (FAll k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n\ngoal (6 subgoals):\n 1. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBool x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBool x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBool x))\n 2. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBase x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBase x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBase x))\n 3. \\<And>\\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FNot \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FNot \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FNot \\<phi>))\n 4. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FOr \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FOr \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FAnd \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FAnd \\<phi>1 \\<phi>2))\n 6. \\<And>x1a \\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FAll x1a \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FAll x1a \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FAll x1a \\<phi>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))", "proof (cases \"k = k'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))\n 2. k \\<noteq> k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))", "case True"], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))\n 2. k \\<noteq> k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))", "with FAll(2,3,4)"], ["proof (chain)\npicking this:\n  \\<not> local.find k i (FAll k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k = k'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> local.find k i (FAll k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k = k'\n\ngoal (1 subgoal):\n 1. (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))", "using FAll(1)[of \"Suc i\" \"Extend k' 0 \\<AA> Q\" P for Q j]"], ["proof (prove)\nusing this:\n  \\<not> local.find k i (FAll k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k = k'\n  \\<lbrakk>\\<not> local.find k (Suc i) \\<phi>;\n   LEQ k (Suc i) (#\\<^sub>V (Extend k' 0 \\<AA> ?Q2));\n   len P \\<le> Length (Extend k' 0 \\<AA> ?Q2)\\<rbrakk>\n  \\<Longrightarrow> (Extend k (Suc i) (Extend k' 0 \\<AA> ?Q2)\n                      P \\<Turnstile>\\<^sub>b\n                     \\<phi>) =\n                    (Extend k' 0 \\<AA> ?Q2 \\<Turnstile>\\<^sub>b\n                     decr k (Suc i) \\<phi>)\n\ngoal (1 subgoal):\n 1. (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))", "by (auto simp: Extend_commute_safe LESS_SUC Length_Extend nvars_Extend max_def)"], ["proof (state)\nthis:\n  (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n  (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))\n\ngoal (1 subgoal):\n 1. k \\<noteq> k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. k \\<noteq> k' \\<Longrightarrow>\n    (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))", "with FAll(2,3,4)"], ["proof (chain)\npicking this:\n  \\<not> local.find k i (FAll k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k \\<noteq> k'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> local.find k i (FAll k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))", "using FAll(1)[of \"i\" \"Extend k' j \\<AA> Q\" P for Q j]"], ["proof (prove)\nusing this:\n  \\<not> local.find k i (FAll k' \\<phi>)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n  k \\<noteq> k'\n  \\<lbrakk>\\<not> local.find k i \\<phi>;\n   LEQ k i (#\\<^sub>V (Extend k' ?j2 \\<AA> ?Q2));\n   len P \\<le> Length (Extend k' ?j2 \\<AA> ?Q2)\\<rbrakk>\n  \\<Longrightarrow> (Extend k i (Extend k' ?j2 \\<AA> ?Q2)\n                      P \\<Turnstile>\\<^sub>b\n                     \\<phi>) =\n                    (Extend k' ?j2 \\<AA> ?Q2 \\<Turnstile>\\<^sub>b\n                     decr k i \\<phi>)\n\ngoal (1 subgoal):\n 1. (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))", "by (auto simp: Extend_commute_unsafe LEQ_SUC Length_Extend nvars_Extend max_def)"], ["proof (state)\nthis:\n  (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n  (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FAll k' \\<phi>) =\n  (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FAll k' \\<phi>))\n\ngoal (5 subgoals):\n 1. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBool x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBool x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBool x))\n 2. \\<And>x i \\<AA> P.\n       \\<lbrakk>\\<not> local.find k i (FBase x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b FBase x) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FBase x))\n 3. \\<And>\\<phi> i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>);\n        \\<not> local.find k i (FNot \\<phi>); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FNot \\<phi>) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b decr k i (FNot \\<phi>))\n 4. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FOr \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FOr \\<phi>1 \\<phi>2))\n 5. \\<And>\\<phi>1 \\<phi>2 i \\<AA> P.\n       \\<lbrakk>\\<And>i \\<AA> P.\n                   \\<lbrakk>\\<not> local.find k i \\<phi>1;\n                    LEQ k i (#\\<^sub>V \\<AA>);\n                    len P \\<le> Length \\<AA>\\<rbrakk>\n                   \\<Longrightarrow> (Extend k i \\<AA>\n P \\<Turnstile>\\<^sub>b\n\\<phi>1) =\n                                     (\\<AA> \\<Turnstile>\\<^sub>b\ndecr k i \\<phi>1);\n        \\<And>i \\<AA> P.\n           \\<lbrakk>\\<not> local.find k i \\<phi>2;\n            LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n           \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                              \\<phi>2) =\n                             (\\<AA> \\<Turnstile>\\<^sub>b decr k i \\<phi>2);\n        \\<not> local.find k i (FAnd \\<phi>1 \\<phi>2);\n        LEQ k i (#\\<^sub>V \\<AA>); len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2) =\n                         (\\<AA> \\<Turnstile>\\<^sub>b\n                          decr k i (FAnd \\<phi>1 \\<phi>2))", "qed (auto simp: Extend_satisfies0 split: bool.splits)"], ["", "subsection \\<open>Normalization\\<close>"], ["", "lemma wf_nFOr:\n  \"wf idx (FOr \\<phi> \\<psi>) \\<Longrightarrow> wf idx (nFOr \\<phi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx (FOr \\<phi> \\<psi>) \\<Longrightarrow>\n    local.wf idx (nFOr \\<phi> \\<psi>)", "by (induct \\<phi> \\<psi> rule: nFOr.induct) (simp_all add: Let_def)"], ["", "lemma wf_nFAnd:\n  \"wf idx (FAnd \\<phi> \\<psi>) \\<Longrightarrow> wf idx (nFAnd \\<phi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx (FAnd \\<phi> \\<psi>) \\<Longrightarrow>\n    local.wf idx (nFAnd \\<phi> \\<psi>)", "by (induct \\<phi> \\<psi> rule: nFAnd.induct) (simp_all add: Let_def)"], ["", "lemma wf_nFEx:\n  \"wf idx (FEx b \\<phi>) \\<Longrightarrow> wf idx (nFEx b \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx (FEx b \\<phi>) \\<Longrightarrow>\n    local.wf idx (nFEx b \\<phi>)", "by (induct \\<phi> arbitrary: idx rule: nFEx.induct)\n    (auto simp: SUC_SUC LEQ_0 LESS_SUC(1) gr0_conv_Suc wf_nFOr intro: wf0_decr0 wf_decr)"], ["", "lemma wf_nFAll:\n  \"wf idx (FAll b \\<phi>) \\<Longrightarrow> wf idx (nFAll b \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx (FAll b \\<phi>) \\<Longrightarrow>\n    local.wf idx (nFAll b \\<phi>)", "by (induct \\<phi> arbitrary: idx rule: nFAll.induct)\n    (auto simp: SUC_SUC LEQ_0 LESS_SUC(1) gr0_conv_Suc wf_nFAnd intro: wf0_decr0 wf_decr)"], ["", "lemma wf_nFNot:\n  \"wf idx (FNot \\<phi>) \\<Longrightarrow> wf idx (nFNot \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx (FNot \\<phi>) \\<Longrightarrow> local.wf idx (nFNot \\<phi>)", "by (induct \\<phi> arbitrary: idx rule: nFNot.induct) (auto simp: wf_nFOr wf_nFAnd wf_nFEx wf_nFAll)"], ["", "lemma wf_norm: \"wf idx \\<phi> \\<Longrightarrow> wf idx (norm \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx \\<phi> \\<Longrightarrow> local.wf idx (norm \\<phi>)", "by (induct \\<phi> arbitrary: idx) (simp_all add: wf_nFOr wf_nFAnd wf_nFNot wf_nFEx wf_nFAll)"], ["", "lemma lformula_nFOr:\n  \"lformula (FOr \\<phi> \\<psi>) \\<Longrightarrow> lformula (nFOr \\<phi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula (FOr \\<phi> \\<psi>) \\<Longrightarrow>\n    lformula (nFOr \\<phi> \\<psi>)", "by (induct \\<phi> \\<psi> rule: nFOr.induct) (simp_all add: Let_def)"], ["", "lemma lformula_nFAnd:\n  \"lformula (FAnd \\<phi> \\<psi>) \\<Longrightarrow> lformula (nFAnd \\<phi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula (FAnd \\<phi> \\<psi>) \\<Longrightarrow>\n    lformula (nFAnd \\<phi> \\<psi>)", "by (induct \\<phi> \\<psi> rule: nFAnd.induct) (simp_all add: Let_def)"], ["", "lemma lformula_nFEx:\n  \"lformula (FEx b \\<phi>) \\<Longrightarrow> lformula (nFEx b \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula (FEx b \\<phi>) \\<Longrightarrow> lformula (nFEx b \\<phi>)", "by (induct \\<phi> rule: nFEx.induct)\n    (auto simp: lformula_nFOr lformula0_decr0 lformula_decr)"], ["", "lemma lformula_nFAll:\n  \"lformula (FAll b \\<phi>) \\<Longrightarrow> lformula (nFAll b \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula (FAll b \\<phi>) \\<Longrightarrow> lformula (nFAll b \\<phi>)", "by (induct \\<phi> rule: nFAll.induct)\n    (auto simp: lformula_nFAnd lformula0_decr0 lformula_decr)"], ["", "lemma lformula_nFNot:\n  \"lformula (FNot \\<phi>) \\<Longrightarrow> lformula (nFNot \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula (FNot \\<phi>) \\<Longrightarrow> lformula (nFNot \\<phi>)", "by (induct \\<phi> rule: nFNot.induct) (auto simp: lformula_nFOr lformula_nFAnd lformula_nFEx lformula_nFAll)"], ["", "lemma lformula_norm: \"lformula \\<phi> \\<Longrightarrow> lformula (norm \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (norm \\<phi>)", "by (induct \\<phi>) (simp_all add: lformula_nFOr lformula_nFAnd lformula_nFNot\n    lformula_nFEx lformula_nFAll)"], ["", "lemma satisfies_nFOr:\n  \"\\<AA> \\<Turnstile> nFOr \\<phi> \\<psi> \\<longleftrightarrow> \\<AA> \\<Turnstile> FOr \\<phi> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile> nFOr \\<phi> \\<psi>) =\n    (\\<AA> \\<Turnstile> FOr \\<phi> \\<psi>)", "by (induct \\<phi> \\<psi> arbitrary: \\<AA> rule: nFOr.induct) auto"], ["", "lemma satisfies_nFAnd:\n  \"\\<AA> \\<Turnstile> nFAnd \\<phi> \\<psi> \\<longleftrightarrow> \\<AA> \\<Turnstile> FAnd \\<phi> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile> nFAnd \\<phi> \\<psi>) =\n    (\\<AA> \\<Turnstile> FAnd \\<phi> \\<psi>)", "by (induct \\<phi> \\<psi> arbitrary: \\<AA> rule: nFAnd.induct) auto"], ["", "lemma satisfies_nFEx: \"lformula \\<phi> \\<Longrightarrow> \\<AA> \\<Turnstile> nFEx b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> FEx b \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow>\n    (\\<AA> \\<Turnstile> nFEx b \\<phi>) = (\\<AA> \\<Turnstile> FEx b \\<phi>)", "by (induct \\<phi> rule: nFEx.induct)\n    (auto simp add: satisfies_nFOr Extend_satisfies_decr\n      LEQ_0 LESS_SUC(1) nvars_Extend Extend_satisfies0 Extend_commute_safe Extend_commute_unsafe)"], ["", "lemma satisfies_nFAll: \"lformula \\<phi> \\<Longrightarrow> \\<AA> \\<Turnstile> nFAll b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> FAll b \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow>\n    (\\<AA> \\<Turnstile> nFAll b \\<phi>) = (\\<AA> \\<Turnstile> FAll b \\<phi>)", "by (induct \\<phi> rule: nFAll.induct)\n    (auto simp add: satisfies_nFAnd Extend_satisfies_decr\n      Extend_satisfies0 LEQ_0 LESS_SUC(1) nvars_Extend Extend_commute_safe Extend_commute_unsafe)"], ["", "lemma satisfies_nFNot:\n  \"lformula \\<phi> \\<Longrightarrow> \\<AA> \\<Turnstile> nFNot \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> FNot \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow>\n    (\\<AA> \\<Turnstile> nFNot \\<phi>) = (\\<AA> \\<Turnstile> FNot \\<phi>)", "by (induct \\<phi> arbitrary: \\<AA>)\n    (simp_all add: satisfies_nFOr satisfies_nFAnd satisfies_nFEx satisfies_nFAll\n    lformula_nFNot)"], ["", "lemma satisfies_norm: \"lformula \\<phi> \\<Longrightarrow> \\<AA> \\<Turnstile> norm \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow>\n    (\\<AA> \\<Turnstile> norm \\<phi>) = (\\<AA> \\<Turnstile> \\<phi>)", "using satisfies_nFOr satisfies_nFAnd satisfies_nFNot satisfies_nFEx satisfies_nFAll"], ["proof (prove)\nusing this:\n  (?\\<AA> \\<Turnstile> nFOr ?\\<phi> ?\\<psi>) =\n  (?\\<AA> \\<Turnstile> FOr ?\\<phi> ?\\<psi>)\n  (?\\<AA> \\<Turnstile> nFAnd ?\\<phi> ?\\<psi>) =\n  (?\\<AA> \\<Turnstile> FAnd ?\\<phi> ?\\<psi>)\n  lformula ?\\<phi> \\<Longrightarrow>\n  (?\\<AA> \\<Turnstile> nFNot ?\\<phi>) = (?\\<AA> \\<Turnstile> FNot ?\\<phi>)\n  lformula ?\\<phi> \\<Longrightarrow>\n  (?\\<AA> \\<Turnstile> nFEx ?b ?\\<phi>) =\n  (?\\<AA> \\<Turnstile> FEx ?b ?\\<phi>)\n  lformula ?\\<phi> \\<Longrightarrow>\n  (?\\<AA> \\<Turnstile> nFAll ?b ?\\<phi>) =\n  (?\\<AA> \\<Turnstile> FAll ?b ?\\<phi>)\n\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow>\n    (\\<AA> \\<Turnstile> norm \\<phi>) = (\\<AA> \\<Turnstile> \\<phi>)", "by (induct \\<phi> arbitrary: \\<AA>) (simp_all add: lformula_norm)"], ["", "lemma satisfies_bounded_nFOr:\n  \"\\<AA> \\<Turnstile>\\<^sub>b nFOr \\<phi> \\<psi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b FOr \\<phi> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b nFOr \\<phi> \\<psi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b FOr \\<phi> \\<psi>)", "by (induct \\<phi> \\<psi> arbitrary: \\<AA> rule: nFOr.induct) auto"], ["", "lemma satisfies_bounded_nFAnd:\n  \"\\<AA> \\<Turnstile>\\<^sub>b nFAnd \\<phi> \\<psi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b FAnd \\<phi> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b nFAnd \\<phi> \\<psi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b FAnd \\<phi> \\<psi>)", "by (induct \\<phi> \\<psi> arbitrary: \\<AA> rule: nFAnd.induct) auto"], ["", "lemma len_cut_0: \"len (cut 0 P) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (cut 0 P) = 0", "by (metis le_0_eq len_cut_le)"], ["", "lemma satisfies_bounded_nFEx: \"\\<AA> \\<Turnstile>\\<^sub>b nFEx b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b FEx b \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b nFEx b \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b FEx b \\<phi>)", "by (induct \\<phi> rule: nFEx.induct)\n    (auto 4 4 simp add: satisfies_bounded_nFOr Extend_satisfies_bounded_decr\n      LEQ_0 LESS_SUC(1) nvars_Extend Length_Extend len_cut_0\n      Extend_satisfies0 Extend_commute_safe Extend_commute_unsafe cong: ex_cong split: bool.splits\n      intro: exI[where P = \"\\<lambda>x. P x \\<and> Q x\" for P Q, OF conjI[rotated]] exI[of _ \"cut 0 P\" for P])"], ["", "lemma satisfies_bounded_nFAll: \"\\<AA> \\<Turnstile>\\<^sub>b nFAll b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b FAll b \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b nFAll b \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b FAll b \\<phi>)", "by (induct \\<phi> rule: nFAll.induct)\n    (auto 4 4 simp add: satisfies_bounded_nFAnd Extend_satisfies_bounded_decr\n      LEQ_0 LESS_SUC(1) nvars_Extend Length_Extend len_cut_0\n      Extend_satisfies0 Extend_commute_safe Extend_commute_unsafe cong: split: bool.splits\n      intro: exI[where P = \"\\<lambda>x. P x \\<and> Q x\" for P Q, OF conjI[rotated]] dest: spec[of _ \"cut 0 P\" for P])"], ["", "lemma satisfies_bounded_nFNot:\n  \"\\<AA> \\<Turnstile>\\<^sub>b nFNot \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b nFNot \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)", "by (induct \\<phi> arbitrary: \\<AA>)\n    (auto simp: satisfies_bounded_nFOr satisfies_bounded_nFAnd satisfies_bounded_nFEx satisfies_bounded_nFAll)"], ["", "lemma satisfies_bounded_norm: \"\\<AA> \\<Turnstile>\\<^sub>b norm \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b norm \\<phi>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "by (induct \\<phi> arbitrary: \\<AA>)\n    (simp_all add: satisfies_bounded_nFOr satisfies_bounded_nFAnd\n      satisfies_bounded_nFNot satisfies_bounded_nFEx satisfies_bounded_nFAll)"], ["", "subsection \\<open>Derivatives of Formulas\\<close>"], ["", "lemma wf_lderiv:\n  \"\\<lbrakk>wf idx \\<phi>; lformula \\<phi>\\<rbrakk> \\<Longrightarrow> wf idx (lderiv x \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf idx \\<phi>; lformula \\<phi>\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (lderiv x \\<phi>)", "by (induct \\<phi> arbitrary: x idx) (auto simp: wf_lderiv0)"], ["", "lemma lformula_lderiv:\n  \"lformula \\<phi> \\<Longrightarrow> lformula (lderiv x \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (lderiv x \\<phi>)", "by (induct \\<phi> arbitrary: x) (auto simp: lformula_lderiv0)"], ["", "lemma wf_rderiv:\n  \"wf idx \\<phi> \\<Longrightarrow> wf idx (rderiv x \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx \\<phi> \\<Longrightarrow> local.wf idx (rderiv x \\<phi>)", "by (induct \\<phi> arbitrary: x idx) (auto simp: wf_rderiv0)"], ["", "theorem satisfies_lderiv:\n  \"\\<lbrakk>wf (#\\<^sub>V \\<AA>) \\<phi>; #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile> lderiv x \\<phi> \\<longleftrightarrow> CONS x \\<AA> \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>; #\\<^sub>V \\<AA> = size x;\n     lformula \\<phi>\\<rbrakk>\n    \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                      (CONS x \\<AA> \\<Turnstile> \\<phi>)", "proof (induct \\<phi> arbitrary: x \\<AA>)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FEx x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FEx x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FEx x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FEx x1a \\<phi>)\n 7. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FAll x1a \\<phi>)", "case (FEx k \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf (#\\<^sub>V ?\\<AA>) \\<phi>; #\\<^sub>V ?\\<AA> = size ?x;\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (?\\<AA> \\<Turnstile> lderiv ?x \\<phi>) =\n                    (CONS ?x ?\\<AA> \\<Turnstile> \\<phi>)\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FEx k \\<phi>)\n\ngoal (7 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FEx x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FEx x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FEx x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FEx x1a \\<phi>)\n 7. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FAll x1a \\<phi>)", "from FEx.prems FEx.hyps[of \"Extend k 0 \\<AA> P\" \"extend k b x\" for P b]"], ["proof (chain)\npicking this:\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FEx k \\<phi>)\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x);\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\n                     lderiv (extend k ?b2 x) \\<phi>) =\n                    (CONS (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\n                     \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FEx k \\<phi>)\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x);\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\n                     lderiv (extend k ?b2 x) \\<phi>) =\n                    (CONS (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\n                     \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile> lderiv x (FEx k \\<phi>)) =\n    (CONS x \\<AA> \\<Turnstile> FEx k \\<phi>)", "by (auto simp: nvars_Extend size_extend Extend_CONS\n      downshift_upshift eval_add eval_upshift downshift_add_zero\n      intro: exI[of _ \"add 0 (upshift P)\" for P] exI[of _ \"upshift P\" for P])"], ["proof (state)\nthis:\n  (\\<AA> \\<Turnstile> lderiv x (FEx k \\<phi>)) =\n  (CONS x \\<AA> \\<Turnstile> FEx k \\<phi>)\n\ngoal (6 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FAll x1a \\<phi>)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FAll x1a \\<phi>)", "case (FAll k \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf (#\\<^sub>V ?\\<AA>) \\<phi>; #\\<^sub>V ?\\<AA> = size ?x;\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (?\\<AA> \\<Turnstile> lderiv ?x \\<phi>) =\n                    (CONS ?x ?\\<AA> \\<Turnstile> \\<phi>)\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FAll k \\<phi>)\n\ngoal (6 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FAll x1a \\<phi>)", "from FAll.prems FAll.hyps[of \"Extend k 0 \\<AA> P\" \"extend k b x\" for P b]"], ["proof (chain)\npicking this:\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FAll k \\<phi>)\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x);\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\n                     lderiv (extend k ?b2 x) \\<phi>) =\n                    (CONS (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\n                     \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FAll k \\<phi>)\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x);\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\n                     lderiv (extend k ?b2 x) \\<phi>) =\n                    (CONS (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\n                     \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile> lderiv x (FAll k \\<phi>)) =\n    (CONS x \\<AA> \\<Turnstile> FAll k \\<phi>)", "by (auto simp: nvars_Extend size_extend Extend_CONS\n      downshift_upshift eval_add eval_upshift downshift_add_zero\n      dest: spec[of _ \"add 0 (upshift P)\" for P] spec[of _ \"upshift P\" for P])"], ["proof (state)\nthis:\n  (\\<AA> \\<Turnstile> lderiv x (FAll k \\<phi>)) =\n  (CONS x \\<AA> \\<Turnstile> FAll k \\<phi>)\n\ngoal (5 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile> FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile> FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile> \\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile> lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile> \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile> FAnd \\<phi>1 \\<phi>2)", "qed (simp_all add: satisfies_lderiv0 split: bool.splits)"], ["", "theorem satisfies_bounded_lderiv:\n  \"\\<lbrakk>wf (#\\<^sub>V \\<AA>) \\<phi>; #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi> \\<longleftrightarrow> CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>; #\\<^sub>V \\<AA> = size x;\n     lformula \\<phi>\\<rbrakk>\n    \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>) =\n                      (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "proof (induct \\<phi> arbitrary: x \\<AA>)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FEx x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FEx x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FEx x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FEx x1a \\<phi>)\n 7. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "case (FEx k \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf (#\\<^sub>V ?\\<AA>) \\<phi>; #\\<^sub>V ?\\<AA> = size ?x;\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (?\\<AA> \\<Turnstile>\\<^sub>b lderiv ?x \\<phi>) =\n                    (CONS ?x ?\\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FEx k \\<phi>)\n\ngoal (7 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FEx x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FEx x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FEx x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FEx x1a \\<phi>)\n 7. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "note [simp] = nvars_Extend size_extend Extend_CONS Length_CONS\n    downshift_upshift eval_add eval_upshift downshift_add_zero len_add len_upshift len_downshift"], ["proof (state)\nthis:\n  #\\<^sub>V (Extend ?k ?i ?\\<AA> ?P) = SUC ?k (#\\<^sub>V ?\\<AA>)\n  size (extend ?k ?b ?x) = SUC ?k (size ?x)\n  #\\<^sub>V ?\\<AA> = size ?x \\<Longrightarrow>\n  Extend ?k 0 (CONS ?x ?\\<AA>) ?P =\n  CONS (extend ?k (if eval ?P 0 then True else False) ?x)\n   (Extend ?k 0 ?\\<AA> (downshift ?P))\n  Length (CONS ?x ?\\<AA>) = Length ?\\<AA> + 1\n  downshift (upshift ?P) = ?P\n  eval (add ?n ?P) ?n\n  \\<not> eval (upshift ?P) 0\n  downshift (add 0 ?P) = downshift ?P\n  len (add ?m ?P) = max (Suc ?m) (len ?P)\n  len (upshift ?P) =\n  (case len ?P of 0 \\<Rightarrow> 0 | Suc nat \\<Rightarrow> Suc (Suc nat))\n  len (downshift ?P) =\n  (case len ?P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n\ngoal (7 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FEx x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FEx x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FEx x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FEx x1a \\<phi>)\n 7. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "from FEx.prems FEx.hyps[of \"Extend k 0 \\<AA> P\" \"extend k b x\" for P b]"], ["proof (chain)\npicking this:\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FEx k \\<phi>)\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x);\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\\<^sub>b\n                     lderiv (extend k ?b2 x) \\<phi>) =\n                    (CONS (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\\<^sub>b\n                     \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FEx k \\<phi>)\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x);\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\\<^sub>b\n                     lderiv (extend k ?b2 x) \\<phi>) =\n                    (CONS (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\\<^sub>b\n                     \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b lderiv x (FEx k \\<phi>)) =\n    (CONS x \\<AA> \\<Turnstile>\\<^sub>b FEx k \\<phi>)", "by auto (force intro: exI[of _ \"add 0 (upshift P)\" for P] exI[of _ \"upshift P\" for P] split: nat.splits)+"], ["proof (state)\nthis:\n  (\\<AA> \\<Turnstile>\\<^sub>b lderiv x (FEx k \\<phi>)) =\n  (CONS x \\<AA> \\<Turnstile>\\<^sub>b FEx k \\<phi>)\n\ngoal (6 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "case (FAll k \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf (#\\<^sub>V ?\\<AA>) \\<phi>; #\\<^sub>V ?\\<AA> = size ?x;\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (?\\<AA> \\<Turnstile>\\<^sub>b lderiv ?x \\<phi>) =\n                    (CONS ?x ?\\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FAll k \\<phi>)\n\ngoal (6 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "note [simp] = nvars_Extend size_extend Extend_CONS Length_CONS\n    downshift_upshift eval_add eval_upshift downshift_add_zero len_add len_upshift len_downshift"], ["proof (state)\nthis:\n  #\\<^sub>V (Extend ?k ?i ?\\<AA> ?P) = SUC ?k (#\\<^sub>V ?\\<AA>)\n  size (extend ?k ?b ?x) = SUC ?k (size ?x)\n  #\\<^sub>V ?\\<AA> = size ?x \\<Longrightarrow>\n  Extend ?k 0 (CONS ?x ?\\<AA>) ?P =\n  CONS (extend ?k (if eval ?P 0 then True else False) ?x)\n   (Extend ?k 0 ?\\<AA> (downshift ?P))\n  Length (CONS ?x ?\\<AA>) = Length ?\\<AA> + 1\n  downshift (upshift ?P) = ?P\n  eval (add ?n ?P) ?n\n  \\<not> eval (upshift ?P) 0\n  downshift (add 0 ?P) = downshift ?P\n  len (add ?m ?P) = max (Suc ?m) (len ?P)\n  len (upshift ?P) =\n  (case len ?P of 0 \\<Rightarrow> 0 | Suc nat \\<Rightarrow> Suc (Suc nat))\n  len (downshift ?P) =\n  (case len ?P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n\ngoal (6 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x; lformula (FAll x1a \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAll x1a \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "from FAll.prems FAll.hyps[of \"Extend k 0 \\<AA> P\" \"extend k b x\" for P b]"], ["proof (chain)\npicking this:\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FAll k \\<phi>)\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x);\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\\<^sub>b\n                     lderiv (extend k ?b2 x) \\<phi>) =\n                    (CONS (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\\<^sub>b\n                     \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  lformula (FAll k \\<phi>)\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x);\n   lformula \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\\<^sub>b\n                     lderiv (extend k ?b2 x) \\<phi>) =\n                    (CONS (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\\<^sub>b\n                     \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b lderiv x (FAll k \\<phi>)) =\n    (CONS x \\<AA> \\<Turnstile>\\<^sub>b FAll k \\<phi>)", "by auto (force dest: spec[of _ \"add 0 (upshift P)\" for P] spec[of _ \"upshift P\" for P] split: nat.splits)+"], ["proof (state)\nthis:\n  (\\<AA> \\<Turnstile>\\<^sub>b lderiv x (FAll k \\<phi>)) =\n  (CONS x \\<AA> \\<Turnstile>\\<^sub>b FAll k \\<phi>)\n\ngoal (5 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBool x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBool x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa; lformula (FBase x)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv xa (FBase x)) =\n                         (CONS xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>); #\\<^sub>V \\<AA> = size x;\n        lformula (FNot \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FNot \\<phi>)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FOr \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x; lformula \\<phi>1\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nlderiv x \\<phi>1) =\n                                     (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x; lformula \\<phi>2\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b lderiv x \\<phi>2) =\n                             (CONS x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x; lformula (FAnd \\<phi>1 \\<phi>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          lderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (CONS x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)", "qed (simp_all add: satisfies_bounded_lderiv0 split: bool.splits)"], ["", "theorem satisfies_bounded_rderiv:\n  \"\\<lbrakk>wf (#\\<^sub>V \\<AA>) \\<phi>; #\\<^sub>V \\<AA> = size x\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi> \\<longleftrightarrow> SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n     #\\<^sub>V \\<AA> = size x\\<rbrakk>\n    \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>) =\n                      (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "proof (induct \\<phi> arbitrary: x \\<AA>)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBool x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBase x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FNot \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FEx x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FEx x1a \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FEx x1a \\<phi>)\n 7. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FAll x1a \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "case (FEx k \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf (#\\<^sub>V ?\\<AA>) \\<phi>;\n   #\\<^sub>V ?\\<AA> = size ?x\\<rbrakk>\n  \\<Longrightarrow> (?\\<AA> \\<Turnstile>\\<^sub>b rderiv ?x \\<phi>) =\n                    (SNOC ?x ?\\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n\ngoal (7 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBool x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBase x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FNot \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FEx x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FEx x1a \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FEx x1a \\<phi>)\n 7. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FAll x1a \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "from FEx.prems FEx.hyps[of \"Extend k 0 \\<AA> P\" \"extend k b x\" for P b]"], ["proof (chain)\npicking this:\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x)\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\\<^sub>b\n                     rderiv (extend k ?b2 x) \\<phi>) =\n                    (SNOC (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\\<^sub>b\n                     \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  local.wf (#\\<^sub>V \\<AA>) (FEx k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x)\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\\<^sub>b\n                     rderiv (extend k ?b2 x) \\<phi>) =\n                    (SNOC (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\\<^sub>b\n                     \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b rderiv x (FEx k \\<phi>)) =\n    (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FEx k \\<phi>)", "by (auto simp: nvars_Extend size_extend Extend_SNOC_cut len_cut_le eval_ge_len \n      eval_add cut_add Length_SNOC len_add len_cut le_Suc_eq max_def\n      intro: exI[of _ \"cut (Length \\<AA>) P\" for P] exI[of _ \"add (Length \\<AA>) P\" for P] split: if_splits)"], ["proof (state)\nthis:\n  (\\<AA> \\<Turnstile>\\<^sub>b rderiv x (FEx k \\<phi>)) =\n  (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FEx k \\<phi>)\n\ngoal (6 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBool x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBase x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FNot \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FAll x1a \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBool x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBase x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FNot \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FAll x1a \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "case (FAll k \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf (#\\<^sub>V ?\\<AA>) \\<phi>;\n   #\\<^sub>V ?\\<AA> = size ?x\\<rbrakk>\n  \\<Longrightarrow> (?\\<AA> \\<Turnstile>\\<^sub>b rderiv ?x \\<phi>) =\n                    (SNOC ?x ?\\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n\ngoal (6 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBool x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBase x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FNot \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)\n 6. \\<And>x1a \\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FAll x1a \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FAll x1a \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FAll x1a \\<phi>)", "from FAll.prems FAll.hyps[of \"Extend k 0 \\<AA> P\" \"extend k b x\" for P b]"], ["proof (chain)\npicking this:\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x)\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\\<^sub>b\n                     rderiv (extend k ?b2 x) \\<phi>) =\n                    (SNOC (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\\<^sub>b\n                     \\<phi>)", "show ?case"], ["proof (prove)\nusing this:\n  local.wf (#\\<^sub>V \\<AA>) (FAll k \\<phi>)\n  #\\<^sub>V \\<AA> = size x\n  \\<lbrakk>local.wf (#\\<^sub>V (Extend k 0 \\<AA> ?P2)) \\<phi>;\n   #\\<^sub>V (Extend k 0 \\<AA> ?P2) = size (extend k ?b2 x)\\<rbrakk>\n  \\<Longrightarrow> (Extend k 0 \\<AA> ?P2 \\<Turnstile>\\<^sub>b\n                     rderiv (extend k ?b2 x) \\<phi>) =\n                    (SNOC (extend k ?b2 x)\n                      (Extend k 0 \\<AA> ?P2) \\<Turnstile>\\<^sub>b\n                     \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b rderiv x (FAll k \\<phi>)) =\n    (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FAll k \\<phi>)", "by (auto simp: nvars_Extend size_extend Extend_SNOC_cut len_cut_le eval_ge_len \n      eval_add cut_add Length_SNOC len_add len_cut le_Suc_eq max_def\n      dest: spec[of _ \"cut (Length \\<AA>) P\" for P] spec[of _ \"add (Length \\<AA>) P\" for P] split: if_splits)"], ["proof (state)\nthis:\n  (\\<AA> \\<Turnstile>\\<^sub>b rderiv x (FAll k \\<phi>)) =\n  (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FAll k \\<phi>)\n\ngoal (5 subgoals):\n 1. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBool x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBool x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBool x)\n 2. \\<And>x xa \\<AA>.\n       \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) (FBase x);\n        #\\<^sub>V \\<AA> = size xa\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv xa (FBase x)) =\n                         (SNOC xa \\<AA> \\<Turnstile>\\<^sub>b FBase x)\n 3. \\<And>\\<phi> x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>);\n        local.wf (#\\<^sub>V \\<AA>) (FNot \\<phi>);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FNot \\<phi>)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b FNot \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FOr \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FOr \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FOr \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi>1 \\<phi>2 x \\<AA>.\n       \\<lbrakk>\\<And>x \\<AA>.\n                   \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>1;\n                    #\\<^sub>V \\<AA> = size x\\<rbrakk>\n                   \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\nrderiv x \\<phi>1) =\n                                     (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n\\<phi>1);\n        \\<And>x \\<AA>.\n           \\<lbrakk>local.wf (#\\<^sub>V \\<AA>) \\<phi>2;\n            #\\<^sub>V \\<AA> = size x\\<rbrakk>\n           \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b rderiv x \\<phi>2) =\n                             (SNOC x \\<AA> \\<Turnstile>\\<^sub>b \\<phi>2);\n        local.wf (#\\<^sub>V \\<AA>) (FAnd \\<phi>1 \\<phi>2);\n        #\\<^sub>V \\<AA> = size x\\<rbrakk>\n       \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                          rderiv x (FAnd \\<phi>1 \\<phi>2)) =\n                         (SNOC x \\<AA> \\<Turnstile>\\<^sub>b\n                          FAnd \\<phi>1 \\<phi>2)", "qed (simp_all add: satisfies_bounded_rderiv0 split: bool.splits)"], ["", "lemma wf_norm_rderivs: \"wf idx \\<phi> \\<Longrightarrow> wf idx (((norm \\<circ> rderiv (zero idx)) ^^ k) \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx \\<phi> \\<Longrightarrow>\n    local.wf idx (((norm \\<circ> rderiv (zero idx)) ^^ k) \\<phi>)", "by (induct k) (auto simp: wf_norm wf_rderiv)"], ["", "subsection \\<open>Finiteness of Derivatives Modulo ACI\\<close>"], ["", "lemma finite_fold_deriv:\n  assumes \"(d0 = lderiv0 \\<and> lformula \\<phi>) \\<or> d0 = rderiv0\"\n  shows \"finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> | xs. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}", "using assms"], ["proof (prove)\nusing this:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0\n\ngoal (1 subgoal):\n 1. finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}", "proof (induct \\<phi>)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBase x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBase x)\\<rangle> |xs. True}\n 3. \\<And>\\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FNot \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FNot \\<phi>)\\<rangle> |\n                           xs. True}\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FOr \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FOr \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAnd \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAnd \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 6. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 7. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "case (FBase a)"], ["proof (state)\nthis:\n  d0 = lderiv0 \\<and> lformula (FBase a) \\<or> d0 = rderiv0\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBase x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBase x)\\<rangle> |xs. True}\n 3. \\<And>\\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FNot \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FNot \\<phi>)\\<rangle> |\n                           xs. True}\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FOr \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FOr \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAnd \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAnd \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 6. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 7. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  d0 = lderiv0 \\<and> lformula (FBase a) \\<or> d0 = rderiv0", "show ?case"], ["proof (prove)\nusing this:\n  d0 = lderiv0 \\<and> lformula (FBase a) \\<or> d0 = rderiv0\n\ngoal (1 subgoal):\n 1. finite {\\<langle>fold (deriv d0) xs (FBase a)\\<rangle> |xs. True}", "by (auto intro:\n      finite_subset[OF _ finite_imageI[OF finite_lderiv0]]\n      finite_subset[OF _ finite_imageI[OF finite_rderiv0]])"], ["proof (state)\nthis:\n  finite {\\<langle>fold (deriv d0) xs (FBase a)\\<rangle> |xs. True}\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>\\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FNot \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FNot \\<phi>)\\<rangle> |\n                           xs. True}\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FOr \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FOr \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAnd \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAnd \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 5. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 6. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>\\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FNot \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FNot \\<phi>)\\<rangle> |\n                           xs. True}\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FOr \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FOr \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAnd \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAnd \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 5. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 6. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "case (FNot \\<phi>)"], ["proof (state)\nthis:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FNot \\<phi>) \\<or> d0 = rderiv0\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>\\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FNot \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FNot \\<phi>)\\<rangle> |\n                           xs. True}\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FOr \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FOr \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAnd \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAnd \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 5. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 6. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FNot \\<phi>) \\<or> d0 = rderiv0", "show ?case"], ["proof (prove)\nusing this:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FNot \\<phi>) \\<or> d0 = rderiv0\n\ngoal (1 subgoal):\n 1. finite {\\<langle>fold (deriv d0) xs (FNot \\<phi>)\\<rangle> |xs. True}", "by (auto simp: fold_deriv_FNot intro!: finite_surj[OF FNot(1)])"], ["proof (state)\nthis:\n  finite {\\<langle>fold (deriv d0) xs (FNot \\<phi>)\\<rangle> |xs. True}\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FOr \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FOr \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAnd \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAnd \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 4. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 5. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FOr \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FOr \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAnd \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAnd \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 4. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 5. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "case (FOr \\<phi> \\<psi>)"], ["proof (state)\nthis:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula \\<psi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<psi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FOr \\<phi> \\<psi>) \\<or> d0 = rderiv0\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FOr \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FOr \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAnd \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAnd \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 4. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 5. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula \\<psi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<psi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FOr \\<phi> \\<psi>) \\<or> d0 = rderiv0", "show ?case"], ["proof (prove)\nusing this:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula \\<psi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<psi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FOr \\<phi> \\<psi>) \\<or> d0 = rderiv0\n\ngoal (1 subgoal):\n 1. finite\n     {\\<langle>fold (deriv d0) xs (FOr \\<phi> \\<psi>)\\<rangle> |xs. True}", "by (auto simp: fold_deriv_FOr intro!: finite_surj[OF finite_cartesian_product[OF FOr(1,2)]])"], ["proof (state)\nthis:\n  finite\n   {\\<langle>fold (deriv d0) xs (FOr \\<phi> \\<psi>)\\<rangle> |xs. True}\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAnd \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAnd \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 3. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 4. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAnd \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAnd \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 3. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 4. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "case (FAnd \\<phi> \\<psi>)"], ["proof (state)\nthis:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula \\<psi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<psi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FAnd \\<phi> \\<psi>) \\<or> d0 = rderiv0\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi>1 \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>1\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula \\<phi>2 \\<or>\n        d0 = rderiv0 \\<Longrightarrow>\n        finite {\\<langle>fold (deriv d0) xs \\<phi>2\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAnd \\<phi>1 \\<phi>2) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAnd \\<phi>1 \\<phi>2)\\<rangle> |\n                           xs. True}\n 3. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 4. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula \\<psi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<psi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FAnd \\<phi> \\<psi>) \\<or> d0 = rderiv0", "show ?case"], ["proof (prove)\nusing this:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula \\<psi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<psi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FAnd \\<phi> \\<psi>) \\<or> d0 = rderiv0\n\ngoal (1 subgoal):\n 1. finite\n     {\\<langle>fold (deriv d0) xs (FAnd \\<phi> \\<psi>)\\<rangle> |xs. True}", "by (auto simp: fold_deriv_FAnd intro!: finite_surj[OF finite_cartesian_product[OF FAnd(1,2)]])"], ["proof (state)\nthis:\n  finite\n   {\\<langle>fold (deriv d0) xs (FAnd \\<phi> \\<psi>)\\<rangle> |xs. True}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 3. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 3. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "case (FEx k \\<phi>)"], ["proof (state)\nthis:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FEx k \\<phi>) \\<or> d0 = rderiv0\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 3. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FEx k \\<phi>) \\<or> d0 = rderiv0", "have \"finite (\\<Union> (disjuncts ` {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> | xs . True}))\""], ["proof (prove)\nusing this:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FEx k \\<phi>) \\<or> d0 = rderiv0\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>\n       (disjuncts `\n        {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}))", "by auto"], ["proof (state)\nthis:\n  finite\n   (\\<Union>\n     (disjuncts ` {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 3. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  finite\n   (\\<Union>\n     (disjuncts ` {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}))", "have \"finite (\\<Union>xs. disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\""], ["proof (prove)\nusing this:\n  finite\n   (\\<Union>\n     (disjuncts ` {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}))\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>xs. disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "by (rule finite_subset[rotated]) auto"], ["proof (state)\nthis:\n  finite (\\<Union>xs. disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 3. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  finite (\\<Union>xs. disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "have \"finite {FEx k \\<psi> | \\<psi>. nf_ACI \\<psi> \\<and> disjuncts \\<psi> \\<subseteq> (\\<Union>xs. disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}\""], ["proof (prove)\nusing this:\n  finite (\\<Union>xs. disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. finite\n     {FEx k \\<psi> |\\<psi>.\n      nf_ACI \\<psi> \\<and>\n      disjuncts \\<psi>\n      \\<subseteq> (\\<Union>xs.\n                      disjuncts\n                       \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}", "by (rule finite_norm_ACI_juncts)"], ["proof (state)\nthis:\n  finite\n   {FEx k \\<psi> |\\<psi>.\n    nf_ACI \\<psi> \\<and>\n    disjuncts \\<psi>\n    \\<subseteq> (\\<Union>xs.\n                    disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FEx x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FEx x1a \\<phi>)\\<rangle> |\n                           xs. True}\n 3. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  finite\n   {FEx k \\<psi> |\\<psi>.\n    nf_ACI \\<psi> \\<and>\n    disjuncts \\<psi>\n    \\<subseteq> (\\<Union>xs.\n                    disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}", "show ?case"], ["proof (prove)\nusing this:\n  finite\n   {FEx k \\<psi> |\\<psi>.\n    nf_ACI \\<psi> \\<and>\n    disjuncts \\<psi>\n    \\<subseteq> (\\<Union>xs.\n                    disjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}\n\ngoal (1 subgoal):\n 1. finite {\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> |xs. True}", "by (rule finite_subset[OF fold_deriv_FEx])"], ["proof (state)\nthis:\n  finite {\\<langle>fold (deriv d0) xs (FEx k \\<phi>)\\<rangle> |xs. True}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "case (FAll k \\<phi>)"], ["proof (state)\nthis:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FAll k \\<phi>) \\<or> d0 = rderiv0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FAll k \\<phi>) \\<or> d0 = rderiv0", "have \"finite (\\<Union> (conjuncts ` {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> | xs . True}))\""], ["proof (prove)\nusing this:\n  d0 = lderiv0 \\<and> lformula \\<phi> \\<or> d0 = rderiv0 \\<Longrightarrow>\n  finite {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}\n  d0 = lderiv0 \\<and> lformula (FAll k \\<phi>) \\<or> d0 = rderiv0\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>\n       (conjuncts `\n        {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}))", "by auto"], ["proof (state)\nthis:\n  finite\n   (\\<Union>\n     (conjuncts ` {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  finite\n   (\\<Union>\n     (conjuncts ` {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}))", "have \"finite (\\<Union>xs. conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\""], ["proof (prove)\nusing this:\n  finite\n   (\\<Union>\n     (conjuncts ` {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True}))\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>xs. conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "by (rule finite_subset[rotated]) auto"], ["proof (state)\nthis:\n  finite (\\<Union>xs. conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  finite (\\<Union>xs. conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)", "have \"finite {FAll k \\<psi> | \\<psi>. nf_ACI \\<psi> \\<and> conjuncts \\<psi> \\<subseteq> (\\<Union>xs. conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}\""], ["proof (prove)\nusing this:\n  finite (\\<Union>xs. conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. finite\n     {FAll k \\<psi> |\\<psi>.\n      nf_ACI \\<psi> \\<and>\n      conjuncts \\<psi>\n      \\<subseteq> (\\<Union>xs.\n                      conjuncts\n                       \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}", "by (rule finite_norm_ACI_juncts)"], ["proof (state)\nthis:\n  finite\n   {FAll k \\<psi> |\\<psi>.\n    nf_ACI \\<psi> \\<and>\n    conjuncts \\<psi>\n    \\<subseteq> (\\<Union>xs.\n                    conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}\n 2. \\<And>x1a \\<phi>.\n       \\<lbrakk>d0 = lderiv0 \\<and> lformula \\<phi> \\<or>\n                d0 = rderiv0 \\<Longrightarrow>\n                finite\n                 {\\<langle>fold (deriv d0) xs \\<phi>\\<rangle> |xs. True};\n        d0 = lderiv0 \\<and> lformula (FAll x1a \\<phi>) \\<or>\n        d0 = rderiv0\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<langle>fold (deriv d0) xs\n                                     (FAll x1a \\<phi>)\\<rangle> |\n                           xs. True}", "then"], ["proof (chain)\npicking this:\n  finite\n   {FAll k \\<psi> |\\<psi>.\n    nf_ACI \\<psi> \\<and>\n    conjuncts \\<psi>\n    \\<subseteq> (\\<Union>xs.\n                    conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}", "show ?case"], ["proof (prove)\nusing this:\n  finite\n   {FAll k \\<psi> |\\<psi>.\n    nf_ACI \\<psi> \\<and>\n    conjuncts \\<psi>\n    \\<subseteq> (\\<Union>xs.\n                    conjuncts \\<langle>fold (deriv d0) xs \\<phi>\\<rangle>)}\n\ngoal (1 subgoal):\n 1. finite {\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> |xs. True}", "by (rule finite_subset[OF fold_deriv_FAll])"], ["proof (state)\nthis:\n  finite {\\<langle>fold (deriv d0) xs (FAll k \\<phi>)\\<rangle> |xs. True}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       d0 = lderiv0 \\<and> lformula (FBool x) \\<or>\n       d0 = rderiv0 \\<Longrightarrow>\n       finite {\\<langle>fold (deriv d0) xs (FBool x)\\<rangle> |xs. True}", "qed (simp add: fold_deriv_FBool)"], ["", "lemma lformula_nFOR: \"lformula (nFOR \\<phi>s) = (\\<forall>\\<phi> \\<in> set \\<phi>s. lformula \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula (nFOR \\<phi>s) = Ball (set \\<phi>s) lformula", "by (induct \\<phi>s rule: nFOR.induct) auto"], ["", "lemma lformula_nFAND: \"lformula (nFAND \\<phi>s) = (\\<forall>\\<phi> \\<in> set \\<phi>s. lformula \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula (nFAND \\<phi>s) = Ball (set \\<phi>s) lformula", "by (induct \\<phi>s rule: nFAND.induct) auto"], ["", "lemma lformula_NFOR: \"finite \\<Phi> \\<Longrightarrow> lformula (NFOR \\<Phi>) = (\\<forall>\\<phi> \\<in> \\<Phi>. lformula \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    lformula (NFOR \\<Phi>) = Ball \\<Phi> lformula", "unfolding NFOR_def o_apply lformula_nFOR"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    Ball (set (sorted_list_of_set \\<Phi>)) lformula = Ball \\<Phi> lformula", "by simp"], ["", "lemma lformula_NFAND: \"finite \\<Phi> \\<Longrightarrow> lformula (NFAND \\<Phi>) = (\\<forall>\\<phi> \\<in> \\<Phi>. lformula \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    lformula (NFAND \\<Phi>) = Ball \\<Phi> lformula", "unfolding NFAND_def o_apply lformula_nFAND"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    Ball (set (sorted_list_of_set \\<Phi>)) lformula = Ball \\<Phi> lformula", "by simp"], ["", "lemma lformula_disjuncts: \"(\\<forall>\\<psi> \\<in> disjuncts \\<phi>. lformula \\<psi>) = lformula \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (disjuncts \\<phi>) lformula = lformula \\<phi>", "by (induct \\<phi> rule: disjuncts.induct) fastforce+"], ["", "lemma lformula_conjuncts: \"(\\<forall>\\<psi> \\<in> conjuncts \\<phi>. lformula \\<psi>) = lformula \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (conjuncts \\<phi>) lformula = lformula \\<phi>", "by (induct \\<phi> rule: conjuncts.induct) fastforce+"], ["", "lemma lformula_norm_ACI: \"lformula \\<langle>\\<phi>\\<rangle> = lformula \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<langle>\\<phi>\\<rangle> = lformula \\<phi>", "by (induct \\<phi>) (simp_all add: ball_Un\n    lformula_NFOR lformula_disjuncts lformula_NFAND lformula_conjuncts)"], ["", "theorem\n  finite_fold_lderiv: \"lformula \\<phi> \\<Longrightarrow> finite {\\<langle>fold lderiv xs \\<langle>\\<phi>\\<rangle>\\<rangle> | xs. True}\" and\n  finite_fold_rderiv: \"finite {\\<langle>fold rderiv xs \\<langle>\\<phi>\\<rangle>\\<rangle> | xs. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lformula \\<phi> \\<Longrightarrow>\n     finite\n      {\\<langle>fold lderiv xs \\<langle>\\<phi>\\<rangle>\\<rangle> |xs.\n       True}) &&&\n    finite\n     {\\<langle>fold rderiv xs \\<langle>\\<phi>\\<rangle>\\<rangle> |xs. True}", "by (subst (asm) lformula_norm_ACI[symmetric]) (blast intro: nf_ACI_norm_ACI finite_fold_deriv)+"], ["", "lemma wf_nFOR: \"wf idx (nFOR \\<phi>s) \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> set \\<phi>s. wf idx \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx (nFOR \\<phi>s) =\n    (\\<forall>\\<phi>\\<in>set \\<phi>s. local.wf idx \\<phi>)", "by (induct rule: nFOR.induct) auto"], ["", "lemma wf_nFAND: \"wf idx (nFAND \\<phi>s) \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> set \\<phi>s. wf idx \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx (nFAND \\<phi>s) =\n    (\\<forall>\\<phi>\\<in>set \\<phi>s. local.wf idx \\<phi>)", "by (induct rule: nFAND.induct) auto"], ["", "lemma wf_NFOR: \"finite \\<Phi> \\<Longrightarrow> wf idx (NFOR \\<Phi>) \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> \\<Phi>. wf idx \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    local.wf idx (NFOR \\<Phi>) =\n    (\\<forall>\\<phi>\\<in>\\<Phi>. local.wf idx \\<phi>)", "unfolding NFOR_def o_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    local.wf idx (nFOR (sorted_list_of_set \\<Phi>)) =\n    (\\<forall>\\<phi>\\<in>\\<Phi>. local.wf idx \\<phi>)", "by (auto simp: wf_nFOR)"], ["", "lemma wf_NFAND: \"finite \\<Phi> \\<Longrightarrow> wf idx (NFAND \\<Phi>) \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> \\<Phi>. wf idx \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    local.wf idx (NFAND \\<Phi>) =\n    (\\<forall>\\<phi>\\<in>\\<Phi>. local.wf idx \\<phi>)", "unfolding NFAND_def o_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    local.wf idx (nFAND (sorted_list_of_set \\<Phi>)) =\n    (\\<forall>\\<phi>\\<in>\\<Phi>. local.wf idx \\<phi>)", "by (auto simp: wf_nFAND)"], ["", "lemma satisfies_bounded_nFOR: \"\\<AA> \\<Turnstile>\\<^sub>b nFOR \\<phi>s \\<longleftrightarrow> (\\<exists>\\<phi> \\<in> set \\<phi>s. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b nFOR \\<phi>s) =\n    (\\<exists>\\<phi>\\<in>set \\<phi>s. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "by (induct rule: nFOR.induct) (auto simp: satisfies_bounded_nFOr)"], ["", "lemma satisfies_bounded_nFAND: \"\\<AA> \\<Turnstile>\\<^sub>b nFAND \\<phi>s \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> set \\<phi>s. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b nFAND \\<phi>s) =\n    (\\<forall>\\<phi>\\<in>set \\<phi>s. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "by (induct rule: nFAND.induct) (auto simp: satisfies_bounded_nFAnd)"], ["", "lemma satisfies_bounded_NFOR: \"finite \\<Phi> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b NFOR \\<Phi> \\<longleftrightarrow> (\\<exists>\\<phi> \\<in> \\<Phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    (\\<AA> \\<Turnstile>\\<^sub>b NFOR \\<Phi>) =\n    (\\<exists>\\<phi>\\<in>\\<Phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "unfolding NFOR_def o_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    (\\<AA> \\<Turnstile>\\<^sub>b nFOR (sorted_list_of_set \\<Phi>)) =\n    (\\<exists>\\<phi>\\<in>\\<Phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "by (auto simp: satisfies_bounded_nFOR)"], ["", "lemma satisfies_bounded_NFAND: \"finite \\<Phi> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b NFAND \\<Phi> \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> \\<Phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    (\\<AA> \\<Turnstile>\\<^sub>b NFAND \\<Phi>) =\n    (\\<forall>\\<phi>\\<in>\\<Phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "unfolding NFAND_def o_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<Phi> \\<Longrightarrow>\n    (\\<AA> \\<Turnstile>\\<^sub>b nFAND (sorted_list_of_set \\<Phi>)) =\n    (\\<forall>\\<phi>\\<in>\\<Phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "by (auto simp: satisfies_bounded_nFAND)"], ["", "lemma wf_juncts:\n  \"wf idx \\<phi> \\<longleftrightarrow> (\\<forall>\\<psi> \\<in> disjuncts \\<phi>. wf idx \\<psi>)\"\n  \"wf idx \\<phi> \\<longleftrightarrow> (\\<forall>\\<psi> \\<in> conjuncts \\<phi>. wf idx \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx \\<phi> =\n    (\\<forall>\\<psi>\\<in>disjuncts \\<phi>. local.wf idx \\<psi>) &&&\n    local.wf idx \\<phi> =\n    (\\<forall>\\<psi>\\<in>conjuncts \\<phi>. local.wf idx \\<psi>)", "by (induct \\<phi>) auto"], ["", "lemma wf_norm_ACI: \"wf idx \\<langle>\\<phi>\\<rangle> = wf idx \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx \\<langle>\\<phi>\\<rangle> = local.wf idx \\<phi>", "by (induct \\<phi> arbitrary: idx) (auto simp: wf_NFOR wf_NFAND ball_Un wf_juncts[symmetric])"], ["", "lemma satisfies_bounded_disjuncts:\n  \"\\<AA> \\<Turnstile>\\<^sub>b \\<phi> \\<longleftrightarrow> (\\<exists>\\<psi> \\<in> disjuncts \\<phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b \\<phi>) =\n    (\\<exists>\\<psi>\\<in>disjuncts \\<phi>.\n        \\<AA> \\<Turnstile>\\<^sub>b \\<psi>)", "by (induct \\<phi> arbitrary: \\<AA>) auto"], ["", "lemma satisfies_bounded_conjuncts:\n  \"\\<AA> \\<Turnstile>\\<^sub>b \\<phi> \\<longleftrightarrow> (\\<forall>\\<psi> \\<in> conjuncts \\<phi>. \\<AA> \\<Turnstile>\\<^sub>b \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b \\<phi>) =\n    (\\<forall>\\<psi>\\<in>conjuncts \\<phi>.\n        \\<AA> \\<Turnstile>\\<^sub>b \\<psi>)", "by (induct \\<phi> arbitrary: \\<AA>) auto"], ["", "lemma satisfies_bounded_norm_ACI: \"\\<AA> \\<Turnstile>\\<^sub>b \\<langle>\\<phi>\\<rangle> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b \\<langle>\\<phi>\\<rangle>) =\n    (\\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "by (rule sym, induct \\<phi> arbitrary: \\<AA>)\n    (auto simp: satisfies_bounded_NFOR satisfies_bounded_NFAND\n      intro: iffD2[OF satisfies_bounded_disjuncts] iffD2[OF satisfies_bounded_conjuncts]\n      dest: iffD1[OF satisfies_bounded_disjuncts] iffD1[OF satisfies_bounded_conjuncts])"], ["", "lemma nvars_SNOCs: \"#\\<^sub>V ((SNOC x^^k) \\<AA>) = #\\<^sub>V \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #\\<^sub>V ((SNOC x ^^ k) \\<AA>) = #\\<^sub>V \\<AA>", "by (induct k) (auto simp: nvars_SNOC)"], ["", "lemma wf_fold_rderiv: \"wf idx \\<phi> \\<Longrightarrow> wf idx (fold rderiv (replicate k x) \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx \\<phi> \\<Longrightarrow>\n    local.wf idx (fold rderiv (replicate k x) \\<phi>)", "by (induct k arbitrary: \\<phi>) (auto simp: wf_rderiv)"], ["", "lemma satisfies_bounded_fold_rderiv:\n  \"\\<lbrakk>wf idx \\<phi>; #\\<^sub>V \\<AA> = idx; size x = idx\\<rbrakk> \\<Longrightarrow>\n     \\<AA> \\<Turnstile>\\<^sub>b fold rderiv (replicate k x) \\<phi> \\<longleftrightarrow> (SNOC x^^k) \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf idx \\<phi>; #\\<^sub>V \\<AA> = idx;\n     size x = idx\\<rbrakk>\n    \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b\n                       fold rderiv (replicate k x) \\<phi>) =\n                      ((SNOC x ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "by (induct k arbitrary: \\<AA> \\<phi>) (auto simp: satisfies_bounded_rderiv wf_rderiv nvars_SNOCs)"], ["", "subsection \\<open>Emptiness Check\\<close>"], ["", "context\n  fixes b :: bool\n  and idx :: 'n\n  and \\<psi> :: \"('a, 'k) aformula\"\nbegin"], ["", "abbreviation \"fut_test \\<equiv> \\<lambda>(\\<phi>, \\<Phi>). \\<phi> \\<notin> set \\<Phi>\""], ["", "abbreviation \"fut_step \\<equiv> \\<lambda>(\\<phi>, \\<Phi>). (norm (rderiv (zero idx) \\<phi>), \\<phi> # \\<Phi>)\""], ["", "definition \"fut_derivs k \\<phi> \\<equiv> ((norm o rderiv (zero idx))^^k) \\<phi>\""], ["", "lemma fut_derivs_Suc[simp]: \"norm (rderiv (zero idx) (fut_derivs k \\<phi>)) = fut_derivs (Suc k) \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (rderiv (zero idx) (fut_derivs k \\<phi>)) =\n    fut_derivs (Suc k) \\<phi>", "unfolding fut_derivs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm\n     (rderiv (zero idx) (((norm \\<circ> rderiv (zero idx)) ^^ k) \\<phi>)) =\n    ((norm \\<circ> rderiv (zero idx)) ^^ Suc k) \\<phi>", "by auto"], ["", "definition \"fut_invariant =\n  (\\<lambda>(\\<phi>, \\<Phi>). wf idx \\<phi> \\<and> (\\<forall>\\<phi> \\<in> set \\<Phi>. wf idx \\<phi>) \\<and>\n    (\\<exists>k. \\<phi> = fut_derivs k \\<psi> \\<and> \\<Phi> = map (\\<lambda>i. fut_derivs i \\<psi>) (rev [0 ..< k])))\""], ["", "definition \"fut_spec \\<phi>\\<Phi> \\<equiv> (\\<forall>\\<phi> \\<in> set (snd \\<phi>\\<Phi>). wf idx \\<phi>) \\<and>\n  (\\<forall>\\<AA>. #\\<^sub>V \\<AA> = idx \\<longrightarrow>\n    (if b then (\\<exists>k. (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>) \\<longleftrightarrow> (\\<exists>\\<phi> \\<in> set (snd \\<phi>\\<Phi>). \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\n    else (\\<forall>k. (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>) \\<longleftrightarrow> (\\<forall>\\<phi> \\<in> set (snd \\<phi>\\<Phi>). \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)))\""], ["", "definition \"fut_default =\n  (\\<psi>, sorted_list_of_set {\\<langle>fold rderiv (replicate k (zero idx)) \\<langle>\\<psi>\\<rangle>\\<rangle> | k. True})\""], ["", "lemma finite_fold_rderiv_zeros: \"finite {\\<langle>fold rderiv (replicate k (zero idx)) \\<langle>\\<psi>\\<rangle>\\<rangle> | k. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {\\<langle>fold rderiv (replicate k (zero idx))\n                \\<langle>\\<psi>\\<rangle>\\<rangle> |\n      k. True}", "by (rule finite_subset[OF _ finite_fold_rderiv[of \\<psi>]]) blast"], ["", "definition fut :: \"('a, 'k) aformula\" where\n  \"fut = (if b then nFOR else nFAND) (snd (while_default fut_default fut_test fut_step (\\<psi>, [])))\""], ["", "context\n  assumes wf: \"wf idx \\<psi>\"\nbegin"], ["", "lemma wf_fut_derivs:\n  \"wf idx (fut_derivs k \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx (fut_derivs k \\<psi>)", "by (induct k) (auto simp: wf_norm wf_rderiv wf fut_derivs_def)"], ["", "lemma satisfies_bounded_fut_derivs:\n  \"#\\<^sub>V \\<AA> = idx \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b fut_derivs k \\<psi> \\<longleftrightarrow> (SNOC (zero idx)^^k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #\\<^sub>V \\<AA> = idx \\<Longrightarrow>\n    (\\<AA> \\<Turnstile>\\<^sub>b fut_derivs k \\<psi>) =\n    ((SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>)", "by (induct k arbitrary: \\<AA>) (auto simp: fut_derivs_def satisfies_bounded_rderiv satisfies_bounded_norm\n    wf_norm_rderivs size_zero nvars_SNOC funpow_swap1[of \"SNOC x\" for x] wf)"], ["", "lemma fut_init: \"fut_invariant (\\<psi>, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fut_invariant (\\<psi>, [])", "unfolding fut_invariant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (\\<psi>, []) of\n    (\\<phi>, \\<Phi>) \\<Rightarrow>\n      local.wf idx \\<phi> \\<and>\n      Ball (set \\<Phi>) (local.wf idx) \\<and>\n      (\\<exists>k.\n          \\<phi> = fut_derivs k \\<psi> \\<and>\n          \\<Phi> = map (\\<lambda>i. fut_derivs i \\<psi>) (rev [0..<k]))", "by (auto simp: fut_derivs_def wf)"], ["", "lemma fut_spec_default: \"fut_spec fut_default\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fut_spec fut_default", "using satisfies_bounded_fold_rderiv[OF iffD2[OF wf_norm_ACI wf] sym size_zero]"], ["proof (prove)\nusing this:\n  idx = #\\<^sub>V ?\\<AA> \\<Longrightarrow>\n  (?\\<AA> \\<Turnstile>\\<^sub>b\n   fold rderiv (replicate ?k (zero idx)) \\<langle>\\<psi>\\<rangle>) =\n  ((SNOC (zero idx) ^^ ?k) ?\\<AA> \\<Turnstile>\\<^sub>b\n   \\<langle>\\<psi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. fut_spec fut_default", "unfolding fut_spec_def fut_default_def snd_conv\n    set_sorted_list_of_set[OF finite_fold_rderiv_zeros]"], ["proof (prove)\nusing this:\n  idx = #\\<^sub>V ?\\<AA> \\<Longrightarrow>\n  (?\\<AA> \\<Turnstile>\\<^sub>b\n   fold rderiv (replicate ?k (zero idx)) \\<langle>\\<psi>\\<rangle>) =\n  ((SNOC (zero idx) ^^ ?k) ?\\<AA> \\<Turnstile>\\<^sub>b\n   \\<langle>\\<psi>\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<phi>\n              \\<in>{\\<langle>fold rderiv (replicate k (zero idx))\n                              \\<langle>\\<psi>\\<rangle>\\<rangle> |\n                    k. True}.\n        local.wf idx \\<phi>) \\<and>\n    (\\<forall>\\<AA>.\n        #\\<^sub>V \\<AA> = idx \\<longrightarrow>\n        (if b\n         then (\\<exists>k.\n                  (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b\n                  \\<psi>) =\n              (\\<exists>\\<phi>\n                        \\<in>{\\<langle>fold rderiv (replicate k (zero idx))\n  \\<langle>\\<psi>\\<rangle>\\<rangle> |\n                              k. True}.\n                  \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\n         else (\\<forall>k.\n                  (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b\n                  \\<psi>) =\n              (\\<forall>\\<phi>\n                        \\<in>{\\<langle>fold rderiv (replicate k (zero idx))\n  \\<langle>\\<psi>\\<rangle>\\<rangle> |\n                              k. True}.\n                  \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)))", "by (auto simp: satisfies_bounded_norm_ACI wf_fold_rderiv wf wf_norm_ACI simp del: fold_replicate)"], ["", "lemma fut_invariant: \"fut_invariant \\<phi>\\<Phi> \\<Longrightarrow> fut_test \\<phi>\\<Phi> \\<Longrightarrow> fut_invariant (fut_step \\<phi>\\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fut_invariant \\<phi>\\<Phi>;\n     case \\<phi>\\<Phi> of\n     (\\<phi>, \\<Phi>) \\<Rightarrow> \\<phi> \\<notin> set \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> fut_invariant (fut_step \\<phi>\\<Phi>)", "by (cases \\<phi>\\<Phi>) (auto simp: fut_invariant_def wf_norm wf_rderiv split: if_splits)"], ["", "lemma fut_terminate: \"fut_invariant \\<phi>\\<Phi> \\<Longrightarrow> \\<not> fut_test \\<phi>\\<Phi> \\<Longrightarrow> fut_spec \\<phi>\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fut_invariant \\<phi>\\<Phi>;\n     \\<not> (case \\<phi>\\<Phi> of\n             (\\<phi>, \\<Phi>) \\<Rightarrow>\n               \\<phi> \\<notin> set \\<Phi>)\\<rbrakk>\n    \\<Longrightarrow> fut_spec \\<phi>\\<Phi>", "proof (induct \\<phi>\\<Phi>, unfold prod.case not_not)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fut_invariant (a, b); a \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> fut_spec (a, b)", "fix \\<phi> \\<Phi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fut_invariant (a, b); a \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> fut_spec (a, b)", "assume \"fut_invariant (\\<phi>, \\<Phi>)\" \"\\<phi> \\<in> set \\<Phi>\""], ["proof (state)\nthis:\n  fut_invariant (\\<phi>, \\<Phi>)\n  \\<phi> \\<in> set \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fut_invariant (a, b); a \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> fut_spec (a, b)", "then"], ["proof (chain)\npicking this:\n  fut_invariant (\\<phi>, \\<Phi>)\n  \\<phi> \\<in> set \\<Phi>", "obtain i k where \"i < k\" and \\<phi>_def: \"\\<phi> = fut_derivs i \\<psi>\"\n    and \\<Phi>_def: \"\\<Phi> = map (\\<lambda>i. fut_derivs i \\<psi>) (rev [0..<k])\"\n    and *: \"fut_derivs k \\<psi> = fut_derivs i \\<psi>\""], ["proof (prove)\nusing this:\n  fut_invariant (\\<phi>, \\<Phi>)\n  \\<phi> \\<in> set \\<Phi>\n\ngoal (1 subgoal):\n 1. (\\<And>i k.\n        \\<lbrakk>i < k; \\<phi> = fut_derivs i \\<psi>;\n         \\<Phi> = map (\\<lambda>i. fut_derivs i \\<psi>) (rev [0..<k]);\n         fut_derivs k \\<psi> = fut_derivs i \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fut_invariant_def"], ["proof (prove)\nusing this:\n  case (\\<phi>, \\<Phi>) of\n  (\\<phi>, \\<Phi>) \\<Rightarrow>\n    local.wf idx \\<phi> \\<and>\n    Ball (set \\<Phi>) (local.wf idx) \\<and>\n    (\\<exists>k.\n        \\<phi> = fut_derivs k \\<psi> \\<and>\n        \\<Phi> = map (\\<lambda>i. fut_derivs i \\<psi>) (rev [0..<k]))\n  \\<phi> \\<in> set \\<Phi>\n\ngoal (1 subgoal):\n 1. (\\<And>i k.\n        \\<lbrakk>i < k; \\<phi> = fut_derivs i \\<psi>;\n         \\<Phi> = map (\\<lambda>i. fut_derivs i \\<psi>) (rev [0..<k]);\n         fut_derivs k \\<psi> = fut_derivs i \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < k\n  \\<phi> = fut_derivs i \\<psi>\n  \\<Phi> = map (\\<lambda>i. fut_derivs i \\<psi>) (rev [0..<k])\n  fut_derivs k \\<psi> = fut_derivs i \\<psi>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fut_invariant (a, b); a \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> fut_spec (a, b)", "have \"set \\<Phi> = {fut_derivs k \\<psi> | k . True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<Phi> = {fut_derivs k \\<psi> |k. True}", "unfolding \\<Phi>_def set_map set_rev set_upt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k} =\n    {fut_derivs k \\<psi> |k. True}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x i.\n       i \\<in> {0..<k} \\<Longrightarrow>\n       \\<exists>k. fut_derivs i \\<psi> = fut_derivs k \\<psi> \\<and> True\n 2. \\<And>x ka.\n       True \\<Longrightarrow>\n       fut_derivs ka \\<psi>\n       \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x i.\n       i \\<in> {0..<k} \\<Longrightarrow>\n       \\<exists>k. fut_derivs i \\<psi> = fut_derivs k \\<psi> \\<and> True\n 2. \\<And>x ka.\n       True \\<Longrightarrow>\n       fut_derivs ka \\<psi>\n       \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}", "show \"fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}", "proof (cases \"j < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow>\n    fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}\n 2. \\<not> j < k \\<Longrightarrow>\n    fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}", "case False"], ["proof (state)\nthis:\n  \\<not> j < k\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow>\n    fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}\n 2. \\<not> j < k \\<Longrightarrow>\n    fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}", "with * \\<open>i < k\\<close>"], ["proof (chain)\npicking this:\n  fut_derivs k \\<psi> = fut_derivs i \\<psi>\n  i < k\n  \\<not> j < k", "have \"fut_derivs j \\<psi> = fut_derivs ((j - i) mod (k - i) + i) \\<psi>\""], ["proof (prove)\nusing this:\n  fut_derivs k \\<psi> = fut_derivs i \\<psi>\n  i < k\n  \\<not> j < k\n\ngoal (1 subgoal):\n 1. fut_derivs j \\<psi> = fut_derivs ((j - i) mod (k - i) + i) \\<psi>", "unfolding fut_derivs_def"], ["proof (prove)\nusing this:\n  ((norm \\<circ> rderiv (zero idx)) ^^ k) \\<psi> =\n  ((norm \\<circ> rderiv (zero idx)) ^^ i) \\<psi>\n  i < k\n  \\<not> j < k\n\ngoal (1 subgoal):\n 1. ((norm \\<circ> rderiv (zero idx)) ^^ j) \\<psi> =\n    ((norm \\<circ> rderiv (zero idx)) ^^ ((j - i) mod (k - i) + i)) \\<psi>", "by (auto intro: funpow_cycle_offset)"], ["proof (state)\nthis:\n  fut_derivs j \\<psi> = fut_derivs ((j - i) mod (k - i) + i) \\<psi>\n\ngoal (2 subgoals):\n 1. j < k \\<Longrightarrow>\n    fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}\n 2. \\<not> j < k \\<Longrightarrow>\n    fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}", "then"], ["proof (chain)\npicking this:\n  fut_derivs j \\<psi> = fut_derivs ((j - i) mod (k - i) + i) \\<psi>", "show ?thesis"], ["proof (prove)\nusing this:\n  fut_derivs j \\<psi> = fut_derivs ((j - i) mod (k - i) + i) \\<psi>\n\ngoal (1 subgoal):\n 1. fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}", "using \\<open>i < k\\<close> \\<open>\\<not> j < k\\<close>"], ["proof (prove)\nusing this:\n  fut_derivs j \\<psi> = fut_derivs ((j - i) mod (k - i) + i) \\<psi>\n  i < k\n  \\<not> j < k\n\ngoal (1 subgoal):\n 1. fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}", "by (metis image_eqI atLeastLessThan_iff le0 less_diff_conv mod_less_divisor zero_less_diff)"], ["proof (state)\nthis:\n  fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}\n\ngoal (1 subgoal):\n 1. j < k \\<Longrightarrow>\n    fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}", "qed simp"], ["proof (state)\nthis:\n  fut_derivs j \\<psi> \\<in> (\\<lambda>i. fut_derivs i \\<psi>) ` {0..<k}\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       i \\<in> {0..<k} \\<Longrightarrow>\n       \\<exists>k. fut_derivs i \\<psi> = fut_derivs k \\<psi> \\<and> True", "qed (blast intro: *)"], ["proof (state)\nthis:\n  set \\<Phi> = {fut_derivs k \\<psi> |k. True}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fut_invariant (a, b); a \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> fut_spec (a, b)", "then"], ["proof (chain)\npicking this:\n  set \\<Phi> = {fut_derivs k \\<psi> |k. True}", "show \"fut_spec (\\<phi>, \\<Phi>)\""], ["proof (prove)\nusing this:\n  set \\<Phi> = {fut_derivs k \\<psi> |k. True}\n\ngoal (1 subgoal):\n 1. fut_spec (\\<phi>, \\<Phi>)", "unfolding fut_spec_def"], ["proof (prove)\nusing this:\n  set \\<Phi> = {fut_derivs k \\<psi> |k. True}\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<phi>\\<in>set (snd (\\<phi>, \\<Phi>)).\n        local.wf idx \\<phi>) \\<and>\n    (\\<forall>\\<AA>.\n        #\\<^sub>V \\<AA> = idx \\<longrightarrow>\n        (if b\n         then (\\<exists>k.\n                  (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b\n                  \\<psi>) =\n              (\\<exists>\\<phi>\\<in>set (snd (\\<phi>, \\<Phi>)).\n                  \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\n         else (\\<forall>k.\n                  (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b\n                  \\<psi>) =\n              (\\<forall>\\<phi>\\<in>set (snd (\\<phi>, \\<Phi>)).\n                  \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)))", "using satisfies_bounded_fut_derivs"], ["proof (prove)\nusing this:\n  set \\<Phi> = {fut_derivs k \\<psi> |k. True}\n  #\\<^sub>V ?\\<AA> = idx \\<Longrightarrow>\n  (?\\<AA> \\<Turnstile>\\<^sub>b fut_derivs ?k \\<psi>) =\n  ((SNOC (zero idx) ^^ ?k) ?\\<AA> \\<Turnstile>\\<^sub>b \\<psi>)\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<phi>\\<in>set (snd (\\<phi>, \\<Phi>)).\n        local.wf idx \\<phi>) \\<and>\n    (\\<forall>\\<AA>.\n        #\\<^sub>V \\<AA> = idx \\<longrightarrow>\n        (if b\n         then (\\<exists>k.\n                  (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b\n                  \\<psi>) =\n              (\\<exists>\\<phi>\\<in>set (snd (\\<phi>, \\<Phi>)).\n                  \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\n         else (\\<forall>k.\n                  (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b\n                  \\<psi>) =\n              (\\<forall>\\<phi>\\<in>set (snd (\\<phi>, \\<Phi>)).\n                  \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)))", "by (auto simp: wf_fut_derivs)"], ["proof (state)\nthis:\n  fut_spec (\\<phi>, \\<Phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fut_spec_while_default:\n  \"fut_spec (while_default fut_default fut_test fut_step (\\<psi>, []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fut_spec\n     (while_default fut_default\n       (\\<lambda>(\\<phi>, \\<Phi>). \\<phi> \\<notin> set \\<Phi>) fut_step\n       (\\<psi>, []))", "using fut_invariant fut_terminate fut_init fut_spec_default"], ["proof (prove)\nusing this:\n  \\<lbrakk>fut_invariant ?\\<phi>\\<Phi>;\n   case ?\\<phi>\\<Phi> of\n   (\\<phi>, \\<Phi>) \\<Rightarrow> \\<phi> \\<notin> set \\<Phi>\\<rbrakk>\n  \\<Longrightarrow> fut_invariant (fut_step ?\\<phi>\\<Phi>)\n  \\<lbrakk>fut_invariant ?\\<phi>\\<Phi>;\n   \\<not> (case ?\\<phi>\\<Phi> of\n           (\\<phi>, \\<Phi>) \\<Rightarrow>\n             \\<phi> \\<notin> set \\<Phi>)\\<rbrakk>\n  \\<Longrightarrow> fut_spec ?\\<phi>\\<Phi>\n  fut_invariant (\\<psi>, [])\n  fut_spec fut_default\n\ngoal (1 subgoal):\n 1. fut_spec\n     (while_default fut_default\n       (\\<lambda>(\\<phi>, \\<Phi>). \\<phi> \\<notin> set \\<Phi>) fut_step\n       (\\<psi>, []))", "by (rule while_default_rule)"], ["", "lemma wf_fut: \"wf idx fut\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx fut", "using fut_spec_while_default"], ["proof (prove)\nusing this:\n  fut_spec\n   (while_default fut_default\n     (\\<lambda>(\\<phi>, \\<Phi>). \\<phi> \\<notin> set \\<Phi>) fut_step\n     (\\<psi>, []))\n\ngoal (1 subgoal):\n 1. local.wf idx fut", "unfolding fut_def fut_spec_def"], ["proof (prove)\nusing this:\n  (\\<forall>\\<phi>\n            \\<in>set (snd (while_default fut_default\n                            (\\<lambda>(\\<phi>, \\<Phi>).\n                                \\<phi> \\<notin> set \\<Phi>)\n                            fut_step (\\<psi>, []))).\n      local.wf idx \\<phi>) \\<and>\n  (\\<forall>\\<AA>.\n      #\\<^sub>V \\<AA> = idx \\<longrightarrow>\n      (if b\n       then (\\<exists>k.\n                (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>) =\n            (\\<exists>\\<phi>\n                      \\<in>set (snd (while_default fut_default\n(\\<lambda>(\\<phi>, \\<Phi>). \\<phi> \\<notin> set \\<Phi>) fut_step\n(\\<psi>, []))).\n                \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\n       else (\\<forall>k.\n                (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>) =\n            (\\<forall>\\<phi>\n                      \\<in>set (snd (while_default fut_default\n(\\<lambda>(\\<phi>, \\<Phi>). \\<phi> \\<notin> set \\<Phi>) fut_step\n(\\<psi>, []))).\n                \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)))\n\ngoal (1 subgoal):\n 1. local.wf idx\n     ((if b then nFOR else nFAND)\n       (snd (while_default fut_default\n              (\\<lambda>(\\<phi>, \\<Phi>). \\<phi> \\<notin> set \\<Phi>)\n              fut_step (\\<psi>, []))))", "by (auto simp: wf_nFOR wf_nFAND)"], ["", "lemma satisfies_bounded_fut:\n  assumes \"#\\<^sub>V \\<AA> = idx\"\n  shows \"\\<AA> \\<Turnstile>\\<^sub>b fut \\<longleftrightarrow>\n    (if b then (\\<exists>k. (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>) else (\\<forall>k. (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b fut) =\n    (if b\n     then \\<exists>k.\n             (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>\n     else \\<forall>k.\n             (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>)", "using fut_spec_while_default assms"], ["proof (prove)\nusing this:\n  fut_spec\n   (while_default fut_default\n     (\\<lambda>(\\<phi>, \\<Phi>). \\<phi> \\<notin> set \\<Phi>) fut_step\n     (\\<psi>, []))\n  #\\<^sub>V \\<AA> = idx\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b fut) =\n    (if b\n     then \\<exists>k.\n             (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>\n     else \\<forall>k.\n             (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>)", "unfolding fut_def fut_spec_def"], ["proof (prove)\nusing this:\n  (\\<forall>\\<phi>\n            \\<in>set (snd (while_default fut_default\n                            (\\<lambda>(\\<phi>, \\<Phi>).\n                                \\<phi> \\<notin> set \\<Phi>)\n                            fut_step (\\<psi>, []))).\n      local.wf idx \\<phi>) \\<and>\n  (\\<forall>\\<AA>.\n      #\\<^sub>V \\<AA> = idx \\<longrightarrow>\n      (if b\n       then (\\<exists>k.\n                (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>) =\n            (\\<exists>\\<phi>\n                      \\<in>set (snd (while_default fut_default\n(\\<lambda>(\\<phi>, \\<Phi>). \\<phi> \\<notin> set \\<Phi>) fut_step\n(\\<psi>, []))).\n                \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)\n       else (\\<forall>k.\n                (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>) =\n            (\\<forall>\\<phi>\n                      \\<in>set (snd (while_default fut_default\n(\\<lambda>(\\<phi>, \\<Phi>). \\<phi> \\<notin> set \\<Phi>) fut_step\n(\\<psi>, []))).\n                \\<AA> \\<Turnstile>\\<^sub>b \\<phi>)))\n  #\\<^sub>V \\<AA> = idx\n\ngoal (1 subgoal):\n 1. (\\<AA> \\<Turnstile>\\<^sub>b\n     (if b then nFOR else nFAND)\n      (snd (while_default fut_default\n             (\\<lambda>(\\<phi>, \\<Phi>). \\<phi> \\<notin> set \\<Phi>)\n             fut_step (\\<psi>, [])))) =\n    (if b\n     then \\<exists>k.\n             (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>\n     else \\<forall>k.\n             (SNOC (zero idx) ^^ k) \\<AA> \\<Turnstile>\\<^sub>b \\<psi>)", "by (auto simp: satisfies_bounded_nFOR satisfies_bounded_nFAND)"], ["", "end"], ["", "end"], ["", "fun finalize :: \"'n \\<Rightarrow> ('a, 'k) aformula \\<Rightarrow> ('a, 'k) aformula\" where\n  \"finalize idx (FEx k \\<phi>) = fut True idx (nFEx k (finalize (SUC k idx) \\<phi>))\"\n| \"finalize idx (FAll k \\<phi>) = fut False idx (nFAll k (finalize (SUC k idx) \\<phi>))\"\n| \"finalize idx (FOr \\<phi> \\<psi>) = FOr (finalize idx \\<phi>) (finalize idx \\<psi>)\"\n| \"finalize idx (FAnd \\<phi> \\<psi>) = FAnd (finalize idx \\<phi>) (finalize idx \\<psi>)\"\n| \"finalize idx (FNot \\<phi>) = FNot (finalize idx \\<phi>)\"\n| \"finalize idx \\<phi> = \\<phi>\""], ["", "definition final :: \"'n \\<Rightarrow> ('a, 'k) aformula \\<Rightarrow> bool\" where\n  \"final idx = nullable o finalize idx\""], ["", "lemma wf_finalize: \"wf idx \\<phi> \\<Longrightarrow> wf idx (finalize idx \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx \\<phi> \\<Longrightarrow> local.wf idx (finalize idx \\<phi>)", "by (induct \\<phi> arbitrary: idx) (auto simp: wf_fut wf_nFEx wf_nFAll)"], ["", "lemma Length_SNOCs: \"Length ((SNOC x ^^ i) \\<AA>) = Length \\<AA> + i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length ((SNOC x ^^ i) \\<AA>) = Length \\<AA> + i", "by (induct i arbitrary: \\<AA>) (auto simp: Length_SNOC)"], ["", "lemma assigns_SNOCs_zero:\n  \"\\<lbrakk>LESS k m (#\\<^sub>V \\<AA>); #\\<^sub>V \\<AA> = idx\\<rbrakk>  \\<Longrightarrow> m\\<^bsup>(SNOC (zero idx) ^^ i) \\<AA>\\<^esup>k = m\\<^bsup>\\<AA>\\<^esup>k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LESS k m (#\\<^sub>V \\<AA>); #\\<^sub>V \\<AA> = idx\\<rbrakk>\n    \\<Longrightarrow> m\\<^bsup>(SNOC (zero idx) ^^ i) \\<AA>\\<^esup>k =\n                      m\\<^bsup>\\<AA>\\<^esup>k", "by (induct i arbitrary: \\<AA>) (auto simp: assigns_SNOC_zero nvars_SNOC funpow_swap1)"], ["", "lemma Extend_SNOCs_zero_satisfies: \"\\<lbrakk>wf (SUC k idx) \\<phi>; #\\<^sub>V \\<AA> = idx; lformula \\<phi>\\<rbrakk> \\<Longrightarrow>\n  Extend k 0 ((SNOC (zero (#\\<^sub>V \\<AA>)) ^^ i) \\<AA>) P \\<Turnstile> \\<phi> \\<longleftrightarrow> Extend k 0 \\<AA> P \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf (SUC k idx) \\<phi>; #\\<^sub>V \\<AA> = idx;\n     lformula \\<phi>\\<rbrakk>\n    \\<Longrightarrow> (Extend k 0\n                        ((SNOC (zero (#\\<^sub>V \\<AA>)) ^^ i) \\<AA>)\n                        P \\<Turnstile>\n                       \\<phi>) =\n                      (Extend k 0 \\<AA> P \\<Turnstile> \\<phi>)", "by (rule satisfies_eqI)\n   (auto simp: nvars_Extend nvars_SNOCs assigns_Extend assigns_SNOCs_zero LEQ_0 LESS_SUC\n     dec_def gr0_conv_Suc)"], ["", "lemma finalize_satisfies: \"\\<lbrakk>wf idx \\<phi>; #\\<^sub>V \\<AA> = idx; lformula \\<phi>\\<rbrakk> \\<Longrightarrow> \\<AA> \\<Turnstile>\\<^sub>b finalize idx \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf idx \\<phi>; #\\<^sub>V \\<AA> = idx;\n     lformula \\<phi>\\<rbrakk>\n    \\<Longrightarrow> (\\<AA> \\<Turnstile>\\<^sub>b finalize idx \\<phi>) =\n                      (\\<AA> \\<Turnstile> \\<phi>)", "by (induct \\<phi> arbitrary: idx \\<AA>)\n    (force simp add: wf_nFEx wf_nFAll wf_finalize Length_SNOCs nvars_Extend nvars_SNOCs\n      satisfies_bounded_fut satisfies_bounded_nFEx satisfies_bounded_nFAll Extend_SNOCs_zero_satisfies\n      intro: le_add2)+"], ["", "lemma Extend_empty_satisfies0:\n  \"\\<lbrakk>Length \\<AA> = 0; len P = 0\\<rbrakk> \\<Longrightarrow> Extend k i \\<AA> P \\<Turnstile>\\<^sub>0 a \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>0 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Length \\<AA> = 0; len P = 0\\<rbrakk>\n    \\<Longrightarrow> (Extend k i \\<AA> P \\<Turnstile>\\<^sub>0 a) =\n                      (\\<AA> \\<Turnstile>\\<^sub>0 a)", "by (intro box_equals[OF _ nullable0_satisfies0 nullable0_satisfies0])\n    (auto simp: nvars_Extend Length_Extend)"], ["", "lemma Extend_empty_satisfies_bounded:\n  \"\\<lbrakk>Length \\<AA> = 0; len P = 0\\<rbrakk> \\<Longrightarrow> Extend k 0 \\<AA> P \\<Turnstile>\\<^sub>b \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Length \\<AA> = 0; len P = 0\\<rbrakk>\n    \\<Longrightarrow> (Extend k 0 \\<AA> P \\<Turnstile>\\<^sub>b \\<phi>) =\n                      (\\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "by (induct \\<phi> arbitrary: k \\<AA> P)\n    (auto simp: Extend_empty_satisfies0 Length_Extend split: bool.splits)"], ["", "lemma nullable_satisfies_bounded: \"Length \\<AA> = 0 \\<Longrightarrow> nullable \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length \\<AA> = 0 \\<Longrightarrow>\n    nullable \\<phi> = (\\<AA> \\<Turnstile>\\<^sub>b \\<phi>)", "by (induct \\<phi>) (auto simp: nullable0_satisfies0 Extend_empty_satisfies_bounded len_cut_0\n    intro: exI[of _ \"cut 0 P\" for P])"], ["", "lemma final_satisfies:\n  \"\\<lbrakk>wf idx \\<phi> \\<and> lformula \\<phi>; Length \\<AA> = 0; #\\<^sub>V \\<AA> = idx\\<rbrakk> \\<Longrightarrow> final idx \\<phi> = (\\<AA> \\<Turnstile> \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf idx \\<phi> \\<and> lformula \\<phi>; Length \\<AA> = 0;\n     #\\<^sub>V \\<AA> = idx\\<rbrakk>\n    \\<Longrightarrow> final idx \\<phi> = (\\<AA> \\<Turnstile> \\<phi>)", "by (simp only: final_def o_apply nullable_satisfies_bounded finalize_satisfies)"], ["", "subsection \\<open>Restrictions\\<close>"], ["", "lemma satisfies_gen_restrict_RESTR:\n  \"satisfies_gen (\\<lambda>k P n. restrict k P \\<and> r k P n) \\<AA> \\<phi> \\<longleftrightarrow> satisfies_gen r \\<AA> (RESTR \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfies_gen (\\<lambda>k P n. restrict k P \\<and> r k P n) \\<AA>\n     \\<phi> =\n    satisfies_gen r \\<AA> (RESTR \\<phi>)", "by (induct \\<phi> arbitrary: \\<AA>) (auto simp: restrict_Restrict[symmetric] assigns_Extend LEQ_0)"], ["", "lemma finite_FV: \"finite (FV \\<phi> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (FV \\<phi> k)", "by (induct \\<phi>) (auto simp: finite_FV0)"], ["", "lemma satisfies_gen_restrict:\n  \"satisfies_gen r \\<AA> \\<phi> \\<and> (\\<forall>x\\<in>set V. restrict k (x\\<^bsup>\\<AA>\\<^esup>k)) \\<longleftrightarrow>\n   satisfies_gen r \\<AA> (foldr (\\<lambda>x. FAnd (Restrict k x)) V \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (satisfies_gen r \\<AA> \\<phi> \\<and>\n     (\\<forall>x\\<in>set V. restrict k (x\\<^bsup>\\<AA>\\<^esup>k))) =\n    satisfies_gen r \\<AA> (foldr (\\<lambda>x. FAnd (Restrict k x)) V \\<phi>)", "by (induct V arbitrary: \\<phi>) (auto simp: restrict_Restrict[symmetric])"], ["", "lemma sat_vars_RESTRICT_VARS:\n  fixes \\<phi>\n  defines \"vs \\<equiv> sorted_list_of_set o FV \\<phi>\"\n  assumes \"\\<forall>k \\<in> set ks. finite (FV \\<phi> k)\"\n  shows \"sat_vars_gen r (set ks) \\<AA> \\<phi> \\<longleftrightarrow> satisfies_gen r \\<AA> (RESTRICT_VARS ks vs \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_vars_gen r (set ks) \\<AA> \\<phi> =\n    satisfies_gen r \\<AA> (RESTRICT_VARS ks vs \\<phi>)", "using assms"], ["proof (prove)\nusing this:\n  vs \\<equiv> sorted_list_of_set \\<circ> FV \\<phi>\n  \\<forall>k\\<in>set ks. finite (FV \\<phi> k)\n\ngoal (1 subgoal):\n 1. sat_vars_gen r (set ks) \\<AA> \\<phi> =\n    satisfies_gen r \\<AA> (RESTRICT_VARS ks vs \\<phi>)", "proof (induct ks)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>vs = sorted_list_of_set \\<circ> FV \\<phi>;\n     \\<forall>k\\<in>set []. finite (FV \\<phi> k)\\<rbrakk>\n    \\<Longrightarrow> sat_vars_gen r (set []) \\<AA> \\<phi> =\n                      satisfies_gen r \\<AA> (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>\\<lbrakk>vs = sorted_list_of_set \\<circ> FV \\<phi>;\n                 \\<forall>k\\<in>set ks. finite (FV \\<phi> k)\\<rbrakk>\n                \\<Longrightarrow> sat_vars_gen r (set ks) \\<AA> \\<phi> =\n                                  satisfies_gen r \\<AA>\n                                   (RESTRICT_VARS ks vs \\<phi>);\n        vs = sorted_list_of_set \\<circ> FV \\<phi>;\n        \\<forall>k\\<in>set (a # ks). finite (FV \\<phi> k)\\<rbrakk>\n       \\<Longrightarrow> sat_vars_gen r (set (a # ks)) \\<AA> \\<phi> =\n                         satisfies_gen r \\<AA>\n                          (RESTRICT_VARS (a # ks) vs \\<phi>)", "case (Cons k ks)"], ["proof (state)\nthis:\n  \\<lbrakk>vs = sorted_list_of_set \\<circ> FV \\<phi>;\n   \\<forall>k\\<in>set ks. finite (FV \\<phi> k)\\<rbrakk>\n  \\<Longrightarrow> sat_vars_gen r (set ks) \\<AA> \\<phi> =\n                    satisfies_gen r \\<AA> (RESTRICT_VARS ks vs \\<phi>)\n  vs = sorted_list_of_set \\<circ> FV \\<phi>\n  \\<forall>k\\<in>set (k # ks). finite (FV \\<phi> k)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vs = sorted_list_of_set \\<circ> FV \\<phi>;\n     \\<forall>k\\<in>set []. finite (FV \\<phi> k)\\<rbrakk>\n    \\<Longrightarrow> sat_vars_gen r (set []) \\<AA> \\<phi> =\n                      satisfies_gen r \\<AA> (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>\\<lbrakk>vs = sorted_list_of_set \\<circ> FV \\<phi>;\n                 \\<forall>k\\<in>set ks. finite (FV \\<phi> k)\\<rbrakk>\n                \\<Longrightarrow> sat_vars_gen r (set ks) \\<AA> \\<phi> =\n                                  satisfies_gen r \\<AA>\n                                   (RESTRICT_VARS ks vs \\<phi>);\n        vs = sorted_list_of_set \\<circ> FV \\<phi>;\n        \\<forall>k\\<in>set (a # ks). finite (FV \\<phi> k)\\<rbrakk>\n       \\<Longrightarrow> sat_vars_gen r (set (a # ks)) \\<AA> \\<phi> =\n                         satisfies_gen r \\<AA>\n                          (RESTRICT_VARS (a # ks) vs \\<phi>)", "with satisfies_gen_restrict[of r \\<AA> \"(RESTRICT_VARS ks vs \\<phi>)\" \"vs k\"]"], ["proof (chain)\npicking this:\n  (satisfies_gen r \\<AA> (RESTRICT_VARS ks vs \\<phi>) \\<and>\n   (\\<forall>x\\<in>set (vs k). restrict ?k (x\\<^bsup>\\<AA>\\<^esup>?k))) =\n  satisfies_gen r \\<AA>\n   (foldr (\\<lambda>x. FAnd (Restrict ?k x)) (vs k)\n     (RESTRICT_VARS ks vs \\<phi>))\n  \\<lbrakk>vs = sorted_list_of_set \\<circ> FV \\<phi>;\n   \\<forall>k\\<in>set ks. finite (FV \\<phi> k)\\<rbrakk>\n  \\<Longrightarrow> sat_vars_gen r (set ks) \\<AA> \\<phi> =\n                    satisfies_gen r \\<AA> (RESTRICT_VARS ks vs \\<phi>)\n  vs = sorted_list_of_set \\<circ> FV \\<phi>\n  \\<forall>k\\<in>set (k # ks). finite (FV \\<phi> k)", "show ?case"], ["proof (prove)\nusing this:\n  (satisfies_gen r \\<AA> (RESTRICT_VARS ks vs \\<phi>) \\<and>\n   (\\<forall>x\\<in>set (vs k). restrict ?k (x\\<^bsup>\\<AA>\\<^esup>?k))) =\n  satisfies_gen r \\<AA>\n   (foldr (\\<lambda>x. FAnd (Restrict ?k x)) (vs k)\n     (RESTRICT_VARS ks vs \\<phi>))\n  \\<lbrakk>vs = sorted_list_of_set \\<circ> FV \\<phi>;\n   \\<forall>k\\<in>set ks. finite (FV \\<phi> k)\\<rbrakk>\n  \\<Longrightarrow> sat_vars_gen r (set ks) \\<AA> \\<phi> =\n                    satisfies_gen r \\<AA> (RESTRICT_VARS ks vs \\<phi>)\n  vs = sorted_list_of_set \\<circ> FV \\<phi>\n  \\<forall>k\\<in>set (k # ks). finite (FV \\<phi> k)\n\ngoal (1 subgoal):\n 1. sat_vars_gen r (set (k # ks)) \\<AA> \\<phi> =\n    satisfies_gen r \\<AA> (RESTRICT_VARS (k # ks) vs \\<phi>)", "by auto"], ["proof (state)\nthis:\n  sat_vars_gen r (set (k # ks)) \\<AA> \\<phi> =\n  satisfies_gen r \\<AA> (RESTRICT_VARS (k # ks) vs \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs = sorted_list_of_set \\<circ> FV \\<phi>;\n     \\<forall>k\\<in>set []. finite (FV \\<phi> k)\\<rbrakk>\n    \\<Longrightarrow> sat_vars_gen r (set []) \\<AA> \\<phi> =\n                      satisfies_gen r \\<AA> (RESTRICT_VARS [] vs \\<phi>)", "qed (simp add: satisfies_gen_restrict_RESTR)"], ["", "lemma sat_RESTRICT: \"sat \\<AA> \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile> RESTRICT \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat \\<AA> \\<phi> = (\\<AA> \\<Turnstile> RESTRICT \\<phi>)", "unfolding sat_def RESTRICT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_vars_gen (\\<lambda>k P n. True) UNIV \\<AA> \\<phi> =\n    (\\<AA> \\<Turnstile>\n     RESTRICT_VARS enum_class.enum (sorted_list_of_set \\<circ> FV \\<phi>)\n      \\<phi>)", "using sat_vars_RESTRICT_VARS[of Enum.enum, symmetric]"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>set enum_class.enum.\n     finite (FV ?\\<phi> k) \\<Longrightarrow>\n  satisfies_gen ?r ?\\<AA>\n   (RESTRICT_VARS enum_class.enum (sorted_list_of_set \\<circ> FV ?\\<phi>)\n     ?\\<phi>) =\n  sat_vars_gen ?r (set enum_class.enum) ?\\<AA> ?\\<phi>\n\ngoal (1 subgoal):\n 1. sat_vars_gen (\\<lambda>k P n. True) UNIV \\<AA> \\<phi> =\n    (\\<AA> \\<Turnstile>\n     RESTRICT_VARS enum_class.enum (sorted_list_of_set \\<circ> FV \\<phi>)\n      \\<phi>)", "by (auto simp: finite_FV enum_UNIV)"], ["", "lemma sat\\<^sub>b_RESTRICT: \"sat\\<^sub>b \\<AA> \\<phi> \\<longleftrightarrow> \\<AA> \\<Turnstile>\\<^sub>b RESTRICT \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat\\<^sub>b \\<AA> \\<phi> = (\\<AA> \\<Turnstile>\\<^sub>b RESTRICT \\<phi>)", "unfolding sat\\<^sub>b_def RESTRICT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_vars_gen (\\<lambda>k P. (\\<le>) (len P)) UNIV \\<AA> \\<phi> =\n    (\\<AA> \\<Turnstile>\\<^sub>b\n     RESTRICT_VARS enum_class.enum (sorted_list_of_set \\<circ> FV \\<phi>)\n      \\<phi>)", "using sat_vars_RESTRICT_VARS[of Enum.enum, symmetric]"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>set enum_class.enum.\n     finite (FV ?\\<phi> k) \\<Longrightarrow>\n  satisfies_gen ?r ?\\<AA>\n   (RESTRICT_VARS enum_class.enum (sorted_list_of_set \\<circ> FV ?\\<phi>)\n     ?\\<phi>) =\n  sat_vars_gen ?r (set enum_class.enum) ?\\<AA> ?\\<phi>\n\ngoal (1 subgoal):\n 1. sat_vars_gen (\\<lambda>k P. (\\<le>) (len P)) UNIV \\<AA> \\<phi> =\n    (\\<AA> \\<Turnstile>\\<^sub>b\n     RESTRICT_VARS enum_class.enum (sorted_list_of_set \\<circ> FV \\<phi>)\n      \\<phi>)", "by (auto simp: finite_FV enum_UNIV)"], ["", "lemma wf_RESTR: \"wf idx \\<phi> \\<Longrightarrow> wf idx (RESTR \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx \\<phi> \\<Longrightarrow> local.wf idx (RESTR \\<phi>)", "by (induct \\<phi> arbitrary: idx) (auto simp: wf_Restrict LESS_SUC LEQ_0)"], ["", "lemma wf_RESTRICT_VARS: \"\\<lbrakk>wf idx \\<phi>; \\<forall>k \\<in> set ks. \\<forall>v \\<in> set (vs k). LESS k v idx\\<rbrakk> \\<Longrightarrow>\n  wf idx (RESTRICT_VARS ks vs \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf idx \\<phi>;\n     \\<forall>k\\<in>set ks. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>)", "proof (induct ks)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>local.wf idx \\<phi>;\n     \\<forall>k\\<in>set []. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>\\<lbrakk>local.wf idx \\<phi>;\n                 \\<forall>k\\<in>set ks.\n                    \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n                \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>);\n        local.wf idx \\<phi>;\n        \\<forall>k\\<in>set (a # ks).\n           \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n       \\<Longrightarrow> local.wf idx (RESTRICT_VARS (a # ks) vs \\<phi>)", "case (Cons k ks)"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf idx \\<phi>;\n   \\<forall>k\\<in>set ks. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n  \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>)\n  local.wf idx \\<phi>\n  \\<forall>k\\<in>set (k # ks). \\<forall>v\\<in>set (vs k). LESS k v idx\n\ngoal (2 subgoals):\n 1. \\<lbrakk>local.wf idx \\<phi>;\n     \\<forall>k\\<in>set []. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>\\<lbrakk>local.wf idx \\<phi>;\n                 \\<forall>k\\<in>set ks.\n                    \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n                \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>);\n        local.wf idx \\<phi>;\n        \\<forall>k\\<in>set (a # ks).\n           \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n       \\<Longrightarrow> local.wf idx (RESTRICT_VARS (a # ks) vs \\<phi>)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf idx \\<phi>;\n   \\<forall>k\\<in>set ks. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n  \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>)\n  local.wf idx \\<phi>\n  \\<forall>k\\<in>set (k # ks). \\<forall>v\\<in>set (vs k). LESS k v idx\n\ngoal (2 subgoals):\n 1. \\<lbrakk>local.wf idx \\<phi>;\n     \\<forall>k\\<in>set []. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>\\<lbrakk>local.wf idx \\<phi>;\n                 \\<forall>k\\<in>set ks.\n                    \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n                \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>);\n        local.wf idx \\<phi>;\n        \\<forall>k\\<in>set (a # ks).\n           \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n       \\<Longrightarrow> local.wf idx (RESTRICT_VARS (a # ks) vs \\<phi>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf idx \\<phi>;\n   \\<forall>k\\<in>set ks. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n  \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>)\n  local.wf idx \\<phi>\n  \\<forall>k\\<in>set (k # ks). \\<forall>v\\<in>set (vs k). LESS k v idx\n\ngoal (2 subgoals):\n 1. \\<lbrakk>local.wf idx \\<phi>;\n     \\<forall>k\\<in>set []. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>\\<lbrakk>local.wf idx \\<phi>;\n                 \\<forall>k\\<in>set ks.\n                    \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n                \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>);\n        local.wf idx \\<phi>;\n        \\<forall>k\\<in>set (a # ks).\n           \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n       \\<Longrightarrow> local.wf idx (RESTRICT_VARS (a # ks) vs \\<phi>)", "fix vs \\<phi>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>local.wf idx \\<phi>;\n     \\<forall>k\\<in>set []. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>\\<lbrakk>local.wf idx \\<phi>;\n                 \\<forall>k\\<in>set ks.\n                    \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n                \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>);\n        local.wf idx \\<phi>;\n        \\<forall>k\\<in>set (a # ks).\n           \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n       \\<Longrightarrow> local.wf idx (RESTRICT_VARS (a # ks) vs \\<phi>)", "assume \"\\<forall>v \\<in> set vs. LESS k v idx\" \"wf idx \\<phi>\""], ["proof (state)\nthis:\n  \\<forall>v\\<in>set vs. LESS k v idx\n  local.wf idx \\<phi>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>local.wf idx \\<phi>;\n     \\<forall>k\\<in>set []. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>\\<lbrakk>local.wf idx \\<phi>;\n                 \\<forall>k\\<in>set ks.\n                    \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n                \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>);\n        local.wf idx \\<phi>;\n        \\<forall>k\\<in>set (a # ks).\n           \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n       \\<Longrightarrow> local.wf idx (RESTRICT_VARS (a # ks) vs \\<phi>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>set vs. LESS k v idx\n  local.wf idx \\<phi>", "have \"wf idx (foldr (\\<lambda>x. FAnd (Restrict k x)) vs \\<phi>)\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set vs. LESS k v idx\n  local.wf idx \\<phi>\n\ngoal (1 subgoal):\n 1. local.wf idx (foldr (\\<lambda>x. FAnd (Restrict k x)) vs \\<phi>)", "by (induct vs arbitrary: \\<phi>) (auto simp: wf_Restrict)"], ["proof (state)\nthis:\n  local.wf idx (foldr (\\<lambda>x. FAnd (Restrict k x)) vs \\<phi>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>local.wf idx \\<phi>;\n     \\<forall>k\\<in>set []. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>\\<lbrakk>local.wf idx \\<phi>;\n                 \\<forall>k\\<in>set ks.\n                    \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n                \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>);\n        local.wf idx \\<phi>;\n        \\<forall>k\\<in>set (a # ks).\n           \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n       \\<Longrightarrow> local.wf idx (RESTRICT_VARS (a # ks) vs \\<phi>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v\\<in>set ?vsa3. LESS k v idx;\n   local.wf idx ?\\<phi>'3\\<rbrakk>\n  \\<Longrightarrow> local.wf idx\n                     (foldr (\\<lambda>x. FAnd (Restrict k x)) ?vsa3\n                       ?\\<phi>'3)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>local.wf idx \\<phi>;\n     \\<forall>k\\<in>set []. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>\\<lbrakk>local.wf idx \\<phi>;\n                 \\<forall>k\\<in>set ks.\n                    \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n                \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>);\n        local.wf idx \\<phi>;\n        \\<forall>k\\<in>set (a # ks).\n           \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n       \\<Longrightarrow> local.wf idx (RESTRICT_VARS (a # ks) vs \\<phi>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>local.wf idx \\<phi>;\n   \\<forall>k\\<in>set ks. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n  \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>)\n  local.wf idx \\<phi>\n  \\<forall>k\\<in>set (k # ks). \\<forall>v\\<in>set (vs k). LESS k v idx\n  \\<lbrakk>\\<forall>v\\<in>set ?vsa3. LESS k v idx;\n   local.wf idx ?\\<phi>'3\\<rbrakk>\n  \\<Longrightarrow> local.wf idx\n                     (foldr (\\<lambda>x. FAnd (Restrict k x)) ?vsa3\n                       ?\\<phi>'3)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>local.wf idx \\<phi>;\n   \\<forall>k\\<in>set ks. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n  \\<Longrightarrow> local.wf idx (RESTRICT_VARS ks vs \\<phi>)\n  local.wf idx \\<phi>\n  \\<forall>k\\<in>set (k # ks). \\<forall>v\\<in>set (vs k). LESS k v idx\n  \\<lbrakk>\\<forall>v\\<in>set ?vsa3. LESS k v idx;\n   local.wf idx ?\\<phi>'3\\<rbrakk>\n  \\<Longrightarrow> local.wf idx\n                     (foldr (\\<lambda>x. FAnd (Restrict k x)) ?vsa3\n                       ?\\<phi>'3)\n\ngoal (1 subgoal):\n 1. local.wf idx (RESTRICT_VARS (k # ks) vs \\<phi>)", "by auto"], ["proof (state)\nthis:\n  local.wf idx (RESTRICT_VARS (k # ks) vs \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf idx \\<phi>;\n     \\<forall>k\\<in>set []. \\<forall>v\\<in>set (vs k). LESS k v idx\\<rbrakk>\n    \\<Longrightarrow> local.wf idx (RESTRICT_VARS [] vs \\<phi>)", "qed (simp add: wf_RESTR)"], ["", "lemma wf_FV_LESS: \"\\<lbrakk>wf idx \\<phi>; v \\<in> FV \\<phi> k\\<rbrakk> \\<Longrightarrow> LESS k v idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf idx \\<phi>; v \\<in> FV \\<phi> k\\<rbrakk>\n    \\<Longrightarrow> LESS k v idx", "by (induct \\<phi> arbitrary: idx v)\n    (force simp: wf0_FV0_LESS LESS_SUC split: if_splits)+"], ["", "lemma wf_RESTRICT: \"wf idx \\<phi> \\<Longrightarrow> wf idx (RESTRICT \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx \\<phi> \\<Longrightarrow> local.wf idx (RESTRICT \\<phi>)", "unfolding RESTRICT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf idx \\<phi> \\<Longrightarrow>\n    local.wf idx\n     (RESTRICT_VARS enum_class.enum (sorted_list_of_set \\<circ> FV \\<phi>)\n       \\<phi>)", "by (rule wf_RESTRICT_VARS) (auto simp: list_all_iff wf_FV_LESS finite_FV)"], ["", "lemma lformula_RESTR: \"lformula \\<phi> \\<Longrightarrow> lformula (RESTR \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTR \\<phi>)", "by (induct \\<phi>) (auto simp: lformula_Restrict)"], ["", "lemma lformula_RESTRICT_VARS: \"lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS ks vs \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS ks vs \\<phi>)", "proof (induct ks)"], ["proof (state)\ngoal (2 subgoals):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>lformula \\<phi> \\<Longrightarrow>\n                lformula (RESTRICT_VARS ks vs \\<phi>);\n        lformula \\<phi>\\<rbrakk>\n       \\<Longrightarrow> lformula (RESTRICT_VARS (a # ks) vs \\<phi>)", "case (Cons k ks)"], ["proof (state)\nthis:\n  lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS ks vs \\<phi>)\n  lformula \\<phi>\n\ngoal (2 subgoals):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>lformula \\<phi> \\<Longrightarrow>\n                lformula (RESTRICT_VARS ks vs \\<phi>);\n        lformula \\<phi>\\<rbrakk>\n       \\<Longrightarrow> lformula (RESTRICT_VARS (a # ks) vs \\<phi>)", "moreover"], ["proof (state)\nthis:\n  lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS ks vs \\<phi>)\n  lformula \\<phi>\n\ngoal (2 subgoals):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>lformula \\<phi> \\<Longrightarrow>\n                lformula (RESTRICT_VARS ks vs \\<phi>);\n        lformula \\<phi>\\<rbrakk>\n       \\<Longrightarrow> lformula (RESTRICT_VARS (a # ks) vs \\<phi>)", "{"], ["proof (state)\nthis:\n  lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS ks vs \\<phi>)\n  lformula \\<phi>\n\ngoal (2 subgoals):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>lformula \\<phi> \\<Longrightarrow>\n                lformula (RESTRICT_VARS ks vs \\<phi>);\n        lformula \\<phi>\\<rbrakk>\n       \\<Longrightarrow> lformula (RESTRICT_VARS (a # ks) vs \\<phi>)", "fix vs \\<phi>"], ["proof (state)\ngoal (2 subgoals):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>lformula \\<phi> \\<Longrightarrow>\n                lformula (RESTRICT_VARS ks vs \\<phi>);\n        lformula \\<phi>\\<rbrakk>\n       \\<Longrightarrow> lformula (RESTRICT_VARS (a # ks) vs \\<phi>)", "assume \"lformula \\<phi>\""], ["proof (state)\nthis:\n  lformula \\<phi>\n\ngoal (2 subgoals):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>lformula \\<phi> \\<Longrightarrow>\n                lformula (RESTRICT_VARS ks vs \\<phi>);\n        lformula \\<phi>\\<rbrakk>\n       \\<Longrightarrow> lformula (RESTRICT_VARS (a # ks) vs \\<phi>)", "then"], ["proof (chain)\npicking this:\n  lformula \\<phi>", "have \"lformula (foldr (\\<lambda>x. FAnd (Restrict k x)) vs \\<phi>)\""], ["proof (prove)\nusing this:\n  lformula \\<phi>\n\ngoal (1 subgoal):\n 1. lformula (foldr (\\<lambda>x. FAnd (Restrict k x)) vs \\<phi>)", "by (induct vs arbitrary: \\<phi>) (auto simp: lformula_Restrict)"], ["proof (state)\nthis:\n  lformula (foldr (\\<lambda>x. FAnd (Restrict k x)) vs \\<phi>)\n\ngoal (2 subgoals):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>lformula \\<phi> \\<Longrightarrow>\n                lformula (RESTRICT_VARS ks vs \\<phi>);\n        lformula \\<phi>\\<rbrakk>\n       \\<Longrightarrow> lformula (RESTRICT_VARS (a # ks) vs \\<phi>)", "}"], ["proof (state)\nthis:\n  lformula ?\\<phi>'3 \\<Longrightarrow>\n  lformula (foldr (\\<lambda>x. FAnd (Restrict k x)) ?vsa3 ?\\<phi>'3)\n\ngoal (2 subgoals):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS [] vs \\<phi>)\n 2. \\<And>a ks.\n       \\<lbrakk>lformula \\<phi> \\<Longrightarrow>\n                lformula (RESTRICT_VARS ks vs \\<phi>);\n        lformula \\<phi>\\<rbrakk>\n       \\<Longrightarrow> lformula (RESTRICT_VARS (a # ks) vs \\<phi>)", "ultimately"], ["proof (chain)\npicking this:\n  lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS ks vs \\<phi>)\n  lformula \\<phi>\n  lformula ?\\<phi>'3 \\<Longrightarrow>\n  lformula (foldr (\\<lambda>x. FAnd (Restrict k x)) ?vsa3 ?\\<phi>'3)", "show ?case"], ["proof (prove)\nusing this:\n  lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS ks vs \\<phi>)\n  lformula \\<phi>\n  lformula ?\\<phi>'3 \\<Longrightarrow>\n  lformula (foldr (\\<lambda>x. FAnd (Restrict k x)) ?vsa3 ?\\<phi>'3)\n\ngoal (1 subgoal):\n 1. lformula (RESTRICT_VARS (k # ks) vs \\<phi>)", "by auto"], ["proof (state)\nthis:\n  lformula (RESTRICT_VARS (k # ks) vs \\<phi>)\n\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT_VARS [] vs \\<phi>)", "qed (simp add: lformula_RESTR)"], ["", "lemma lformula_RESTRICT: \"lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow> lformula (RESTRICT \\<phi>)", "unfolding RESTRICT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow>\n    lformula\n     (RESTRICT_VARS enum_class.enum (sorted_list_of_set \\<circ> FV \\<phi>)\n       \\<phi>)", "by (rule lformula_RESTRICT_VARS)"], ["", "lemma ex_fold_CONS: \"\\<exists>xs \\<BB>. \\<AA> = fold CONS xs \\<BB> \\<and> Length \\<BB> = 0 \\<and> Length \\<AA> = length xs \\<and>\n   #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and> (\\<forall>x \\<in> set xs. size x = #\\<^sub>V \\<AA>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs \\<BB>.\n       \\<AA> = fold CONS xs \\<BB> \\<and>\n       Length \\<BB> = 0 \\<and>\n       Length \\<AA> = length xs \\<and>\n       #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n       (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)", "proof (induct \"Length \\<AA>\" arbitrary: \\<AA>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<AA>.\n       0 = Length \\<AA> \\<Longrightarrow>\n       \\<exists>xs \\<BB>.\n          \\<AA> = fold CONS xs \\<BB> \\<and>\n          Length \\<BB> = 0 \\<and>\n          Length \\<AA> = length xs \\<and>\n          #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n          (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)\n 2. \\<And>x \\<AA>.\n       \\<lbrakk>\\<And>\\<AA>.\n                   x = Length \\<AA> \\<Longrightarrow>\n                   \\<exists>xs \\<BB>.\n                      \\<AA> = fold CONS xs \\<BB> \\<and>\n                      Length \\<BB> = 0 \\<and>\n                      Length \\<AA> = length xs \\<and>\n                      #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                      (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>);\n        Suc x = Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs \\<BB>.\n                            \\<AA> = fold CONS xs \\<BB> \\<and>\n                            Length \\<BB> = 0 \\<and>\n                            Length \\<AA> = length xs \\<and>\n                            #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                            (\\<forall>x\\<in>set xs.\n                                size x = #\\<^sub>V \\<AA>)", "case (Suc m)"], ["proof (state)\nthis:\n  m = Length ?\\<AA>1 \\<Longrightarrow>\n  \\<exists>xs \\<BB>.\n     ?\\<AA>1 = fold CONS xs \\<BB> \\<and>\n     Length \\<BB> = 0 \\<and>\n     Length ?\\<AA>1 = length xs \\<and>\n     #\\<^sub>V \\<BB> = #\\<^sub>V ?\\<AA>1 \\<and>\n     (\\<forall>x\\<in>set xs. size x = #\\<^sub>V ?\\<AA>1)\n  Suc m = Length \\<AA>\n\ngoal (2 subgoals):\n 1. \\<And>\\<AA>.\n       0 = Length \\<AA> \\<Longrightarrow>\n       \\<exists>xs \\<BB>.\n          \\<AA> = fold CONS xs \\<BB> \\<and>\n          Length \\<BB> = 0 \\<and>\n          Length \\<AA> = length xs \\<and>\n          #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n          (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)\n 2. \\<And>x \\<AA>.\n       \\<lbrakk>\\<And>\\<AA>.\n                   x = Length \\<AA> \\<Longrightarrow>\n                   \\<exists>xs \\<BB>.\n                      \\<AA> = fold CONS xs \\<BB> \\<and>\n                      Length \\<BB> = 0 \\<and>\n                      Length \\<AA> = length xs \\<and>\n                      #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                      (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>);\n        Suc x = Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs \\<BB>.\n                            \\<AA> = fold CONS xs \\<BB> \\<and>\n                            Length \\<BB> = 0 \\<and>\n                            Length \\<AA> = length xs \\<and>\n                            #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                            (\\<forall>x\\<in>set xs.\n                                size x = #\\<^sub>V \\<AA>)", "from Suc(2) CONS_surj"], ["proof (chain)\npicking this:\n  Suc m = Length \\<AA>\n  \\<lbrakk>Length ?\\<AA> \\<noteq> 0; #\\<^sub>V ?\\<AA> = ?idx\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x \\<BB>.\n                       ?\\<AA> = CONS x \\<BB> \\<and>\n                       #\\<^sub>V \\<BB> = ?idx \\<and> size x = ?idx", "obtain a \\<BB> where \"\\<AA> = CONS a \\<BB>\" \"#\\<^sub>V \\<BB> = #\\<^sub>V \\<AA>\" \"size a = #\\<^sub>V \\<AA>\""], ["proof (prove)\nusing this:\n  Suc m = Length \\<AA>\n  \\<lbrakk>Length ?\\<AA> \\<noteq> 0; #\\<^sub>V ?\\<AA> = ?idx\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x \\<BB>.\n                       ?\\<AA> = CONS x \\<BB> \\<and>\n                       #\\<^sub>V \\<BB> = ?idx \\<and> size x = ?idx\n\ngoal (1 subgoal):\n 1. (\\<And>a \\<BB>.\n        \\<lbrakk>\\<AA> = CONS a \\<BB>; #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA>;\n         size a = #\\<^sub>V \\<AA>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  \\<AA> = CONS a \\<BB>\n  #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA>\n  size a = #\\<^sub>V \\<AA>\n\ngoal (2 subgoals):\n 1. \\<And>\\<AA>.\n       0 = Length \\<AA> \\<Longrightarrow>\n       \\<exists>xs \\<BB>.\n          \\<AA> = fold CONS xs \\<BB> \\<and>\n          Length \\<BB> = 0 \\<and>\n          Length \\<AA> = length xs \\<and>\n          #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n          (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)\n 2. \\<And>x \\<AA>.\n       \\<lbrakk>\\<And>\\<AA>.\n                   x = Length \\<AA> \\<Longrightarrow>\n                   \\<exists>xs \\<BB>.\n                      \\<AA> = fold CONS xs \\<BB> \\<and>\n                      Length \\<BB> = 0 \\<and>\n                      Length \\<AA> = length xs \\<and>\n                      #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                      (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>);\n        Suc x = Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs \\<BB>.\n                            \\<AA> = fold CONS xs \\<BB> \\<and>\n                            Length \\<BB> = 0 \\<and>\n                            Length \\<AA> = length xs \\<and>\n                            #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                            (\\<forall>x\\<in>set xs.\n                                size x = #\\<^sub>V \\<AA>)", "moreover"], ["proof (state)\nthis:\n  \\<AA> = CONS a \\<BB>\n  #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA>\n  size a = #\\<^sub>V \\<AA>\n\ngoal (2 subgoals):\n 1. \\<And>\\<AA>.\n       0 = Length \\<AA> \\<Longrightarrow>\n       \\<exists>xs \\<BB>.\n          \\<AA> = fold CONS xs \\<BB> \\<and>\n          Length \\<BB> = 0 \\<and>\n          Length \\<AA> = length xs \\<and>\n          #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n          (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)\n 2. \\<And>x \\<AA>.\n       \\<lbrakk>\\<And>\\<AA>.\n                   x = Length \\<AA> \\<Longrightarrow>\n                   \\<exists>xs \\<BB>.\n                      \\<AA> = fold CONS xs \\<BB> \\<and>\n                      Length \\<BB> = 0 \\<and>\n                      Length \\<AA> = length xs \\<and>\n                      #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                      (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>);\n        Suc x = Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs \\<BB>.\n                            \\<AA> = fold CONS xs \\<BB> \\<and>\n                            Length \\<BB> = 0 \\<and>\n                            Length \\<AA> = length xs \\<and>\n                            #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                            (\\<forall>x\\<in>set xs.\n                                size x = #\\<^sub>V \\<AA>)", "with Suc(2)"], ["proof (chain)\npicking this:\n  Suc m = Length \\<AA>\n  \\<AA> = CONS a \\<BB>\n  #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA>\n  size a = #\\<^sub>V \\<AA>", "have \"Length \\<BB> = m\""], ["proof (prove)\nusing this:\n  Suc m = Length \\<AA>\n  \\<AA> = CONS a \\<BB>\n  #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA>\n  size a = #\\<^sub>V \\<AA>\n\ngoal (1 subgoal):\n 1. Length \\<BB> = m", "by (simp add: Length_CONS)"], ["proof (state)\nthis:\n  Length \\<BB> = m\n\ngoal (2 subgoals):\n 1. \\<And>\\<AA>.\n       0 = Length \\<AA> \\<Longrightarrow>\n       \\<exists>xs \\<BB>.\n          \\<AA> = fold CONS xs \\<BB> \\<and>\n          Length \\<BB> = 0 \\<and>\n          Length \\<AA> = length xs \\<and>\n          #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n          (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)\n 2. \\<And>x \\<AA>.\n       \\<lbrakk>\\<And>\\<AA>.\n                   x = Length \\<AA> \\<Longrightarrow>\n                   \\<exists>xs \\<BB>.\n                      \\<AA> = fold CONS xs \\<BB> \\<and>\n                      Length \\<BB> = 0 \\<and>\n                      Length \\<AA> = length xs \\<and>\n                      #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                      (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>);\n        Suc x = Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs \\<BB>.\n                            \\<AA> = fold CONS xs \\<BB> \\<and>\n                            Length \\<BB> = 0 \\<and>\n                            Length \\<AA> = length xs \\<and>\n                            #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                            (\\<forall>x\\<in>set xs.\n                                size x = #\\<^sub>V \\<AA>)", "with Suc(1)[of \\<BB>]"], ["proof (chain)\npicking this:\n  m = Length \\<BB> \\<Longrightarrow>\n  \\<exists>xs \\<BB>'.\n     \\<BB> = fold CONS xs \\<BB>' \\<and>\n     Length \\<BB>' = 0 \\<and>\n     Length \\<BB> = length xs \\<and>\n     #\\<^sub>V \\<BB>' = #\\<^sub>V \\<BB> \\<and>\n     (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<BB>)\n  Length \\<BB> = m", "obtain xs \\<CC> where \"\\<BB> = fold CONS xs \\<CC>\" \"Length \\<CC> = 0\" \"Length \\<BB> = length xs\"\n    \"#\\<^sub>V \\<CC> = #\\<^sub>V \\<BB>\" \"\\<forall>x \\<in> set xs. size x = #\\<^sub>V \\<BB>\""], ["proof (prove)\nusing this:\n  m = Length \\<BB> \\<Longrightarrow>\n  \\<exists>xs \\<BB>'.\n     \\<BB> = fold CONS xs \\<BB>' \\<and>\n     Length \\<BB>' = 0 \\<and>\n     Length \\<BB> = length xs \\<and>\n     #\\<^sub>V \\<BB>' = #\\<^sub>V \\<BB> \\<and>\n     (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<BB>)\n  Length \\<BB> = m\n\ngoal (1 subgoal):\n 1. (\\<And>xs \\<CC>.\n        \\<lbrakk>\\<BB> = fold CONS xs \\<CC>; Length \\<CC> = 0;\n         Length \\<BB> = length xs; #\\<^sub>V \\<CC> = #\\<^sub>V \\<BB>;\n         \\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<BB> = fold CONS xs \\<CC>\n  Length \\<CC> = 0\n  Length \\<BB> = length xs\n  #\\<^sub>V \\<CC> = #\\<^sub>V \\<BB>\n  \\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<BB>\n\ngoal (2 subgoals):\n 1. \\<And>\\<AA>.\n       0 = Length \\<AA> \\<Longrightarrow>\n       \\<exists>xs \\<BB>.\n          \\<AA> = fold CONS xs \\<BB> \\<and>\n          Length \\<BB> = 0 \\<and>\n          Length \\<AA> = length xs \\<and>\n          #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n          (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)\n 2. \\<And>x \\<AA>.\n       \\<lbrakk>\\<And>\\<AA>.\n                   x = Length \\<AA> \\<Longrightarrow>\n                   \\<exists>xs \\<BB>.\n                      \\<AA> = fold CONS xs \\<BB> \\<and>\n                      Length \\<BB> = 0 \\<and>\n                      Length \\<AA> = length xs \\<and>\n                      #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                      (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>);\n        Suc x = Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs \\<BB>.\n                            \\<AA> = fold CONS xs \\<BB> \\<and>\n                            Length \\<BB> = 0 \\<and>\n                            Length \\<AA> = length xs \\<and>\n                            #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n                            (\\<forall>x\\<in>set xs.\n                                size x = #\\<^sub>V \\<AA>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<AA> = CONS a \\<BB>\n  #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA>\n  size a = #\\<^sub>V \\<AA>\n  \\<BB> = fold CONS xs \\<CC>\n  Length \\<CC> = 0\n  Length \\<BB> = length xs\n  #\\<^sub>V \\<CC> = #\\<^sub>V \\<BB>\n  \\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<BB>", "show ?case"], ["proof (prove)\nusing this:\n  \\<AA> = CONS a \\<BB>\n  #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA>\n  size a = #\\<^sub>V \\<AA>\n  \\<BB> = fold CONS xs \\<CC>\n  Length \\<CC> = 0\n  Length \\<BB> = length xs\n  #\\<^sub>V \\<CC> = #\\<^sub>V \\<BB>\n  \\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<BB>\n\ngoal (1 subgoal):\n 1. \\<exists>xs \\<BB>.\n       \\<AA> = fold CONS xs \\<BB> \\<and>\n       Length \\<BB> = 0 \\<and>\n       Length \\<AA> = length xs \\<and>\n       #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n       (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)", "by (intro exI[of _ \"xs @ [a]\"] exI[of _ \\<CC>]) (auto simp: Length_CONS)"], ["proof (state)\nthis:\n  \\<exists>xs \\<BB>.\n     \\<AA> = fold CONS xs \\<BB> \\<and>\n     Length \\<BB> = 0 \\<and>\n     Length \\<AA> = length xs \\<and>\n     #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n     (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<AA>.\n       0 = Length \\<AA> \\<Longrightarrow>\n       \\<exists>xs \\<BB>.\n          \\<AA> = fold CONS xs \\<BB> \\<and>\n          Length \\<BB> = 0 \\<and>\n          Length \\<AA> = length xs \\<and>\n          #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n          (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)", "qed simp"], ["", "primcorec L where\n  \"L idx I = Lang (\\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx \\<and> \\<AA> \\<in> I)\n    (\\<lambda>a. if size a = idx then L idx {\\<BB>. CONS a \\<BB> \\<in> I} else Zero)\""], ["", "lemma L_empty: \"L idx {} = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L idx {} = Zero", "by coinduction auto"], ["", "lemma L_alt: \"L idx I =\n    to_language {xs. \\<exists>\\<AA> \\<in> I. \\<exists>\\<BB>. \\<AA> = fold CONS (rev xs) \\<BB> \\<and> Length \\<BB> = 0 \\<and>\n      #\\<^sub>V \\<BB> = idx \\<and> (\\<forall>x \\<in> set xs. size x = idx)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L idx I =\n    to_language\n     {xs.\n      \\<exists>\\<AA>\\<in>I.\n         \\<exists>\\<BB>.\n            \\<AA> = fold CONS (rev xs) \\<BB> \\<and>\n            Length \\<BB> = 0 \\<and>\n            #\\<^sub>V \\<BB> = idx \\<and>\n            (\\<forall>x\\<in>set xs. size x = idx)}", "by (coinduction arbitrary: I)\n    (auto 0 4 simp: L_empty intro: exI[of _ \"{}\"] arg_cong[of _ _ to_language])"], ["", "definition \"lang idx \\<phi> = L idx {\\<AA>. \\<AA> \\<Turnstile> \\<phi> \\<and> #\\<^sub>V \\<AA> = idx}\""], ["", "definition \"lang\\<^sub>b idx \\<phi> = L idx {\\<AA>. \\<AA> \\<Turnstile>\\<^sub>b \\<phi> \\<and> #\\<^sub>V \\<AA> = idx}\""], ["", "definition \"language idx \\<phi> = L idx {\\<AA>. sat \\<AA> \\<phi> \\<and> #\\<^sub>V \\<AA> = idx}\""], ["", "definition \"language\\<^sub>b idx \\<phi> = L idx {\\<AA>. sat\\<^sub>b \\<AA> \\<phi> \\<and> #\\<^sub>V \\<AA> = idx}\""], ["", "lemma \"lformula \\<phi> \\<Longrightarrow> lang n (norm \\<phi>) = lang n \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow> lang n (norm \\<phi>) = lang n \\<phi>", "unfolding lang_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow>\n    L n {\\<AA>. \\<AA> \\<Turnstile> norm \\<phi> \\<and> #\\<^sub>V \\<AA> = n} =\n    L n {\\<AA>. \\<AA> \\<Turnstile> \\<phi> \\<and> #\\<^sub>V \\<AA> = n}", "using satisfies_norm"], ["proof (prove)\nusing this:\n  lformula ?\\<phi> \\<Longrightarrow>\n  (?\\<AA> \\<Turnstile> norm ?\\<phi>) = (?\\<AA> \\<Turnstile> ?\\<phi>)\n\ngoal (1 subgoal):\n 1. lformula \\<phi> \\<Longrightarrow>\n    L n {\\<AA>. \\<AA> \\<Turnstile> norm \\<phi> \\<and> #\\<^sub>V \\<AA> = n} =\n    L n {\\<AA>. \\<AA> \\<Turnstile> \\<phi> \\<and> #\\<^sub>V \\<AA> = n}", "by auto"], ["", "lemma in_language_Zero[simp]: \"\\<not> in_language Zero w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> in_language Zero w", "by (induct w) auto"], ["", "lemma in_language_L_size: \"in_language (L idx I) w \\<Longrightarrow> x \\<in> set w \\<Longrightarrow> size x = idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_language (L idx I) w; x \\<in> set w\\<rbrakk>\n    \\<Longrightarrow> size x = idx", "by (induct w arbitrary: x I) (auto split: if_splits)"], ["", "end"], ["", "sublocale Formula <\n  bounded: DA \"alphabet idx\" \"\\<lambda>\\<phi>. norm (RESTRICT \\<phi>)\" \"\\<lambda>a \\<phi>. norm (lderiv a \\<phi>)\" \"nullable\"\n     \"\\<lambda>\\<phi>. wf idx \\<phi> \\<and> lformula \\<phi>\" \"lang\\<^sub>b idx\"\n     \"\\<lambda>\\<phi>. wf idx \\<phi> \\<and> lformula \\<phi>\" \"language\\<^sub>b idx\" for idx"], ["proof (prove)\ngoal (1 subgoal):\n 1. DA (alphabet idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>))\n     (\\<lambda>a \\<phi>. norm (lderiv a \\<phi>)) nullable\n     (\\<lambda>\\<phi>. local.wf idx \\<phi> \\<and> lformula \\<phi>)\n     (lang\\<^sub>b idx)\n     (\\<lambda>\\<phi>. local.wf idx \\<phi> \\<and> lformula \\<phi>)\n     (language\\<^sub>b idx)", "using ex_Length_0[of idx]"], ["proof (prove)\nusing this:\n  \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n\ngoal (1 subgoal):\n 1. DA (alphabet idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>))\n     (\\<lambda>a \\<phi>. norm (lderiv a \\<phi>)) nullable\n     (\\<lambda>\\<phi>. local.wf idx \\<phi> \\<and> lformula \\<phi>)\n     (lang\\<^sub>b idx)\n     (\\<lambda>\\<phi>. local.wf idx \\<phi> \\<and> lformula \\<phi>)\n     (language\\<^sub>b idx)", "by unfold_locales\n    (auto simp: lformula_norm lformula_lderiv distinct_alphabet alphabet_size wf_norm wf_lderiv\n    lang\\<^sub>b_def language\\<^sub>b_def nullable_satisfies_bounded wf_RESTRICT lformula_RESTRICT sat\\<^sub>b_RESTRICT\n    satisfies_bounded_norm in_language_L_size satisfies_bounded_lderiv nvars_CONS\n    dest: Length_0_inj intro: arg_cong[of _ _ \"L (size _)\"])"], ["", "sublocale Formula <\n  unbounded?: DA \"alphabet idx\" \"\\<lambda>\\<phi>. norm (RESTRICT \\<phi>)\" \"\\<lambda>a \\<phi>. norm (lderiv a \\<phi>)\" \"final idx\"\n     \"\\<lambda>\\<phi>. wf idx \\<phi> \\<and> lformula \\<phi>\" \"lang idx\"\n     \"\\<lambda>\\<phi>. wf idx \\<phi> \\<and> lformula \\<phi>\" \"language idx\" for idx"], ["proof (prove)\ngoal (1 subgoal):\n 1. DA (alphabet idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>))\n     (\\<lambda>a \\<phi>. norm (lderiv a \\<phi>)) (final idx)\n     (\\<lambda>\\<phi>. local.wf idx \\<phi> \\<and> lformula \\<phi>)\n     (lang idx)\n     (\\<lambda>\\<phi>. local.wf idx \\<phi> \\<and> lformula \\<phi>)\n     (language idx)", "using ex_Length_0[of idx]"], ["proof (prove)\nusing this:\n  \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n\ngoal (1 subgoal):\n 1. DA (alphabet idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>))\n     (\\<lambda>a \\<phi>. norm (lderiv a \\<phi>)) (final idx)\n     (\\<lambda>\\<phi>. local.wf idx \\<phi> \\<and> lformula \\<phi>)\n     (lang idx)\n     (\\<lambda>\\<phi>. local.wf idx \\<phi> \\<and> lformula \\<phi>)\n     (language idx)", "by unfold_locales\n    (auto simp: lformula_norm lformula_lderiv distinct_alphabet alphabet_size wf_norm wf_lderiv\n    lang_def language_def final_satisfies wf_RESTRICT lformula_RESTRICT sat_RESTRICT\n    satisfies_norm in_language_L_size satisfies_lderiv nvars_CONS\n    dest: Length_0_inj intro: arg_cong[of _ _ \"L (size _)\"])"], ["", "lemma (in Formula) check_eqv_soundness:\n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> sat \\<AA> \\<phi> \\<longleftrightarrow> sat \\<AA> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx; check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> sat \\<AA> \\<phi> = sat \\<AA> \\<psi>", "using ex_fold_CONS[of \\<AA>]"], ["proof (prove)\nusing this:\n  \\<exists>xs \\<BB>.\n     \\<AA> = fold CONS xs \\<BB> \\<and>\n     Length \\<BB> = 0 \\<and>\n     Length \\<AA> = length xs \\<and>\n     #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n     (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx; check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> sat \\<AA> \\<phi> = sat \\<AA> \\<psi>", "by (auto simp: language_def L_alt set_eq_iff\n    dest!: soundness[unfolded rel_language_eq] injD[OF bij_is_inj[OF to_language_bij]])\n    (metis Length_0_inj rev_rev_ident set_rev)+"], ["", "lemma (in Formula) bounded_check_eqv_soundness:\n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; bounded.check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> sat\\<^sub>b \\<AA> \\<phi> \\<longleftrightarrow> sat\\<^sub>b \\<AA> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx;\n     bounded.check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> sat\\<^sub>b \\<AA> \\<phi> = sat\\<^sub>b \\<AA> \\<psi>", "using ex_fold_CONS[of \\<AA>]"], ["proof (prove)\nusing this:\n  \\<exists>xs \\<BB>.\n     \\<AA> = fold CONS xs \\<BB> \\<and>\n     Length \\<BB> = 0 \\<and>\n     Length \\<AA> = length xs \\<and>\n     #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n     (\\<forall>x\\<in>set xs. size x = #\\<^sub>V \\<AA>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx;\n     bounded.check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> sat\\<^sub>b \\<AA> \\<phi> = sat\\<^sub>b \\<AA> \\<psi>", "by (auto simp: language\\<^sub>b_def L_alt set_eq_iff\n    dest!: bounded.soundness[unfolded rel_language_eq] injD[OF bij_is_inj[OF to_language_bij]])\n    (metis Length_0_inj rev_rev_ident set_rev)+"], ["", "end"]]}