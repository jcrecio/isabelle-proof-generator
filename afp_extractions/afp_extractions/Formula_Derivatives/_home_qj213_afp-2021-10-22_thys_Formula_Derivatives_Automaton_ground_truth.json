{"file_name": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives/Automaton.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives", "problem_names": ["lemma rel_language_alt:\n  \"rel_language R L K = rel_fun (list_all2 R) (=) (in_language L) (in_language K)\"", "lemma rel_language_eq: \"rel_language (=) = (=)\"", "lemma in_language_\\<dd>s: \"in_language (\\<dd>s w L) v \\<longleftrightarrow> in_language L (w @ v)\"", "lemma \\<oo>_\\<dd>s: \"\\<oo> (\\<dd>s w L) \\<longleftrightarrow> in_language L w\"", "lemma in_language_to_language[simp]: \"in_language (to_language L) w \\<longleftrightarrow> w \\<in> L\"", "lemma rtrancl_fold_product:\nshows \"{((r, s), (f a r, g b s)) | a b r s. a \\<in> A \\<and> b \\<in> B \\<and> R a b}^* =\n       {((r, s), (fold f w1 r, fold g w2 s)) | w1 w2 r s. w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\"\n  (is \"?L = ?R\")", "lemma rtrancl_fold_product1:\nshows \"{(r, s). \\<exists>a \\<in> A. s = f a r}^* = {(r, s). \\<exists>a \\<in> lists A. s = fold f a r}\" (is \"?L = ?R\")", "lemma lang_eq_ext_Nil_fold_Deriv:\n  fixes K L A R\n  assumes\n    \"\\<And>w. in_language K w \\<Longrightarrow> w \\<in> lists A\"\n    \"\\<And>w. in_language L w \\<Longrightarrow> w \\<in> lists B\"\n    \"\\<And>a b. R a b \\<Longrightarrow> a \\<in> A \\<longleftrightarrow> b \\<in> B\"\n  defines \"\\<BB> \\<equiv> {(\\<dd>s w1 K, \\<dd>s w2 L) | w1 w2. w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\"\n  shows \"rel_language R K L \\<longleftrightarrow> (\\<forall>(K, L) \\<in> \\<BB>. \\<oo> K \\<longleftrightarrow> \\<oo> L)\"", "lemma this: \"DA alphabet init delta accept wellformed Language wf Lang\"", "lemma wellformed_deltas:\n  \"\\<lbrakk>wellformed s; w \\<in> lists (set alphabet)\\<rbrakk> \\<Longrightarrow> wellformed (fold delta w s)\"", "lemma Language_deltas:\n  \"\\<lbrakk>wellformed s; w \\<in> lists (set alphabet)\\<rbrakk> \\<Longrightarrow> Language (fold delta w s) = \\<dd>s w (Language s)\"", "lemma match_correct:\n  assumes \"wellformed s\" \"w \\<in> lists (set alphabet)\"\n  shows \"match s w \\<longleftrightarrow> in_language (Language s) w\"", "theorem closure_sound_complete:\nassumes wf: \"wf1 r\" \"wf2 s\"\nand result: \"closure (init1 r, init2 s) = Some (ws, R)\" (is \"closure (?r, ?s) = _\")\nshows \"ws = [] \\<longleftrightarrow> rel_language letter_eq (Lang1 r) (Lang2 s)\"", "lemma soundness: \nassumes \"check_eqv r s\" shows \"rel_language letter_eq (Lang1 r) (Lang2 s)\"", "lemma finite_rtrancl_delta_Image1:\n  \"wellformed r \\<Longrightarrow> finite ({(r, s). \\<exists>a \\<in> set alphabet. s = delta a r}^* `` {r})\"", "lemma\n  assumes \"wellformed r\" \"set as \\<subseteq> set alphabet\"\n  shows reachable: \"reachable as r = {fold delta w r | w. w \\<in> lists (set as)}\"\n  and finite_reachable: \"finite (reachable as r)\"", "lemma finite_rtrancl_delta_Image:\n  \"\\<lbrakk>wellformed1 r; wellformed2 s\\<rbrakk> \\<Longrightarrow>\n  finite ({((r, s), (delta1 a r, delta2 b s))| a b r s.\n    a \\<in> set alphabet1 \\<and> b \\<in> set alphabet2 \\<and> R a b}^* `` {(r, s)})\"", "lemma \"termination\":\n  assumes \"wellformed1 r\" \"wellformed2 s\"\n  shows \"\\<exists>st. closure (r, s) = Some st\" (is \"\\<exists>_. closure  ?i = _\")", "lemma completeness: \nassumes \"wf1 r\" \"wf2 s\" \"rel_language letter_eq (Lang1 r) (Lang2 s)\" shows \"check_eqv r s\"", "lemma (in DA) step_alt: \"step = (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) alphabet)\""], "translations": [["", "lemma rel_language_alt:\n  \"rel_language R L K = rel_fun (list_all2 R) (=) (in_language L) (in_language K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_language R L K =\n    rel_fun (list_all2 R) (=) (in_language L) (in_language K)", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_language R L K =\n    (\\<forall>x y.\n        list_all2 R x y \\<longrightarrow> in_language L x = in_language K y)", "proof (rule iffI, safe del: iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>rel_language R L K; list_all2 R x y\\<rbrakk>\n       \\<Longrightarrow> in_language L x = in_language K y\n 2. \\<forall>x y.\n       list_all2 R x y \\<longrightarrow>\n       in_language L x = in_language K y \\<Longrightarrow>\n    rel_language R L K", "fix xs ys"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>rel_language R L K; list_all2 R x y\\<rbrakk>\n       \\<Longrightarrow> in_language L x = in_language K y\n 2. \\<forall>x y.\n       list_all2 R x y \\<longrightarrow>\n       in_language L x = in_language K y \\<Longrightarrow>\n    rel_language R L K", "assume \"list_all2 R xs ys\" \"rel_language R L K\""], ["proof (state)\nthis:\n  list_all2 R xs ys\n  rel_language R L K\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>rel_language R L K; list_all2 R x y\\<rbrakk>\n       \\<Longrightarrow> in_language L x = in_language K y\n 2. \\<forall>x y.\n       list_all2 R x y \\<longrightarrow>\n       in_language L x = in_language K y \\<Longrightarrow>\n    rel_language R L K", "then"], ["proof (chain)\npicking this:\n  list_all2 R xs ys\n  rel_language R L K", "show \"in_language L xs = in_language K ys\""], ["proof (prove)\nusing this:\n  list_all2 R xs ys\n  rel_language R L K\n\ngoal (1 subgoal):\n 1. in_language L xs = in_language K ys", "by (induct xs ys arbitrary: L K) (auto del: iffI elim: rel_language.cases)"], ["proof (state)\nthis:\n  in_language L xs = in_language K ys\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       list_all2 R x y \\<longrightarrow>\n       in_language L x = in_language K y \\<Longrightarrow>\n    rel_language R L K", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       list_all2 R x y \\<longrightarrow>\n       in_language L x = in_language K y \\<Longrightarrow>\n    rel_language R L K", "assume \"\\<forall>xs ys. list_all2 R xs ys \\<longrightarrow> in_language L xs = in_language K ys\""], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     list_all2 R xs ys \\<longrightarrow> in_language L xs = in_language K ys\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       list_all2 R x y \\<longrightarrow>\n       in_language L x = in_language K y \\<Longrightarrow>\n    rel_language R L K", "then"], ["proof (chain)\npicking this:\n  \\<forall>xs ys.\n     list_all2 R xs ys \\<longrightarrow> in_language L xs = in_language K ys", "show \"rel_language R L K\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     list_all2 R xs ys \\<longrightarrow> in_language L xs = in_language K ys\n\ngoal (1 subgoal):\n 1. rel_language R L K", "by (coinduction arbitrary: L K) (auto dest: spec2)"], ["proof (state)\nthis:\n  rel_language R L K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_language_eq: \"rel_language (=) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_language (=) = (=)", "unfolding rel_language_alt[abs_def] list.rel_eq fun.rel_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>L K. in_language L = in_language K) = (=)", "by (subst (2) fun_eq_iff)+\n    (auto intro: box_equals[OF _ to_language_in_language to_language_in_language])"], ["", "abbreviation \"\\<dd>s \\<equiv> fold (\\<lambda>a L. \\<dd> L a)\""], ["", "lemma in_language_\\<dd>s: \"in_language (\\<dd>s w L) v \\<longleftrightarrow> in_language L (w @ v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language (\\<dd>s w L) v = in_language L (w @ v)", "by (induct w arbitrary: L) simp_all"], ["", "lemma \\<oo>_\\<dd>s: \"\\<oo> (\\<dd>s w L) \\<longleftrightarrow> in_language L w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> (\\<dd>s w L) = in_language L w", "by (induct w arbitrary: L) auto"], ["", "lemma in_language_to_language[simp]: \"in_language (to_language L) w \\<longleftrightarrow> w \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language (to_language L) w = (w \\<in> L)", "by (metis in_language_to_language mem_Collect_eq)"], ["", "lemma rtrancl_fold_product:\nshows \"{((r, s), (f a r, g b s)) | a b r s. a \\<in> A \\<and> b \\<in> B \\<and> R a b}^* =\n       {((r, s), (fold f w1 r, fold g w2 s)) | w1 w2 r s. w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\"\n  (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "fix r s r' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "have \"((r, s), (r', s')) : ?L \\<Longrightarrow> ((r, s), (r', s')) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r, s), r', s')\n    \\<in> {((r, s), f a r, g b s) |a b r s.\n           a \\<in> A \\<and>\n           b \\<in> B \\<and> R a b}\\<^sup>* \\<Longrightarrow>\n    ((r, s), r', s')\n    \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n           w1 \\<in> lists A \\<and>\n           w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "proof(induction rule: converse_rtrancl_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((r', s'), r', s')\n    \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n           w1 \\<in> lists A \\<and>\n           w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), f a r, g b s) |a b r s.\n                       a \\<in> A \\<and> b \\<in> B \\<and> R a b};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), f a r, g b s) |a b r s.\n               a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n               w1 \\<in> lists A \\<and>\n               w2 \\<in> lists B \\<and> list_all2 R w1 w2}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r\n                                s. w1 \\<in> lists A \\<and>\n                                   w2 \\<in> lists B \\<and>\n                                   list_all2 R w1 w2}", "case refl"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ((r', s'), r', s')\n    \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n           w1 \\<in> lists A \\<and>\n           w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), f a r, g b s) |a b r s.\n                       a \\<in> A \\<and> b \\<in> B \\<and> R a b};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), f a r, g b s) |a b r s.\n               a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n               w1 \\<in> lists A \\<and>\n               w2 \\<in> lists B \\<and> list_all2 R w1 w2}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r\n                                s. w1 \\<in> lists A \\<and>\n                                   w2 \\<in> lists B \\<and>\n                                   list_all2 R w1 w2}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r', s'), r', s')\n    \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n           w1 \\<in> lists A \\<and>\n           w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "by(force intro!: fold_simps(1)[symmetric])"], ["proof (state)\nthis:\n  ((r', s'), r', s')\n  \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n         w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), f a r, g b s) |a b r s.\n                       a \\<in> A \\<and> b \\<in> B \\<and> R a b};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), f a r, g b s) |a b r s.\n               a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n               w1 \\<in> lists A \\<and>\n               w2 \\<in> lists B \\<and> list_all2 R w1 w2}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r\n                                s. w1 \\<in> lists A \\<and>\n                                   w2 \\<in> lists B \\<and>\n                                   list_all2 R w1 w2}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), f a r, g b s) |a b r s.\n                       a \\<in> A \\<and> b \\<in> B \\<and> R a b};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), f a r, g b s) |a b r s.\n               a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n               w1 \\<in> lists A \\<and>\n               w2 \\<in> lists B \\<and> list_all2 R w1 w2}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r\n                                s. w1 \\<in> lists A \\<and>\n                                   w2 \\<in> lists B \\<and>\n                                   list_all2 R w1 w2}", "case step"], ["proof (state)\nthis:\n  ((a___, b___), a_, b_)\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\n  ((a_, b_), r', s')\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n  ((a_, b_), r', s')\n  \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n         w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), f a r, g b s) |a b r s.\n                       a \\<in> A \\<and> b \\<in> B \\<and> R a b};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), f a r, g b s) |a b r s.\n               a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n               w1 \\<in> lists A \\<and>\n               w2 \\<in> lists B \\<and> list_all2 R w1 w2}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r\n                                s. w1 \\<in> lists A \\<and>\n                                   w2 \\<in> lists B \\<and>\n                                   list_all2 R w1 w2}", "thus ?case"], ["proof (prove)\nusing this:\n  ((a___, b___), a_, b_)\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\n  ((a_, b_), r', s')\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n  ((a_, b_), r', s')\n  \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n         w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n\ngoal (1 subgoal):\n 1. ((a___, b___), r', s')\n    \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n           w1 \\<in> lists A \\<and>\n           w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "by(force intro!: fold_simps(2)[symmetric])"], ["proof (state)\nthis:\n  ((a___, b___), r', s')\n  \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n         w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((r, s), r', s')\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* \\<Longrightarrow>\n  ((r, s), r', s')\n  \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n         w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "}"], ["proof (state)\nthis:\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n         w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "hence \"\\<And>x. x \\<in> ?L \\<Longrightarrow> x \\<in> ?R\""], ["proof (prove)\nusing this:\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n         w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {((r, s), f a r, g b s) |a b r s.\n                a \\<in> A \\<and>\n                b \\<in> B \\<and> R a b}\\<^sup>* \\<Longrightarrow>\n       x \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n                w1 \\<in> lists A \\<and>\n                w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "by force"], ["proof (state)\nthis:\n  ?x \\<in> {((r, s), f a r, g b s) |a b r s.\n            a \\<in> A \\<and>\n            b \\<in> B \\<and> R a b}\\<^sup>* \\<Longrightarrow>\n  ?x \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n            w1 \\<in> lists A \\<and>\n            w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> {((r, s), f a r, g b s) |a b r s.\n            a \\<in> A \\<and>\n            b \\<in> B \\<and> R a b}\\<^sup>* \\<Longrightarrow>\n  ?x \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n            w1 \\<in> lists A \\<and>\n            w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "{"], ["proof (state)\nthis:\n  ?x \\<in> {((r, s), f a r, g b s) |a b r s.\n            a \\<in> A \\<and>\n            b \\<in> B \\<and> R a b}\\<^sup>* \\<Longrightarrow>\n  ?x \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n            w1 \\<in> lists A \\<and>\n            w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "fix r s r' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "fix w1 w2"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "assume \"list_all2 R w1 w2\" \"w1 \\<in> lists A\" \"w2 \\<in> lists B\""], ["proof (state)\nthis:\n  list_all2 R w1 w2\n  w1 \\<in> lists A\n  w2 \\<in> lists B\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "then"], ["proof (chain)\npicking this:\n  list_all2 R w1 w2\n  w1 \\<in> lists A\n  w2 \\<in> lists B", "have \"((r, s), fold f w1 r, fold g w2 s) \\<in> ?L\""], ["proof (prove)\nusing this:\n  list_all2 R w1 w2\n  w1 \\<in> lists A\n  w2 \\<in> lists B\n\ngoal (1 subgoal):\n 1. ((r, s), fold f w1 r, fold g w2 s)\n    \\<in> {((r, s), f a r, g b s) |a b r s.\n           a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*", "proof(induction w1 w2 arbitrary: r s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r s.\n       \\<lbrakk>[] \\<in> lists A; [] \\<in> lists B\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f [] r, fold g [] s)\n                         \\<in> {((r, s), f a r, g b s) |a b r s.\n                                a \\<in> A \\<and>\n                                b \\<in> B \\<and> R a b}\\<^sup>*\n 2. \\<And>x xs y ys r s.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        \\<And>r s.\n           \\<lbrakk>xs \\<in> lists A; ys \\<in> lists B\\<rbrakk>\n           \\<Longrightarrow> ((r, s), fold f xs r, fold g ys s)\n                             \\<in> {((r, s), f a r, g b s) |a b r s.\n                                    a \\<in> A \\<and>\n                                    b \\<in> B \\<and> R a b}\\<^sup>*;\n        x # xs \\<in> lists A; y # ys \\<in> lists B\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f (x # xs) r, fold g (y # ys) s)\n                         \\<in> {((r, s), f a r, g b s) |a b r s.\n                                a \\<in> A \\<and>\n                                b \\<in> B \\<and> R a b}\\<^sup>*", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> lists A\n  [] \\<in> lists B\n\ngoal (2 subgoals):\n 1. \\<And>r s.\n       \\<lbrakk>[] \\<in> lists A; [] \\<in> lists B\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f [] r, fold g [] s)\n                         \\<in> {((r, s), f a r, g b s) |a b r s.\n                                a \\<in> A \\<and>\n                                b \\<in> B \\<and> R a b}\\<^sup>*\n 2. \\<And>x xs y ys r s.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        \\<And>r s.\n           \\<lbrakk>xs \\<in> lists A; ys \\<in> lists B\\<rbrakk>\n           \\<Longrightarrow> ((r, s), fold f xs r, fold g ys s)\n                             \\<in> {((r, s), f a r, g b s) |a b r s.\n                                    a \\<in> A \\<and>\n                                    b \\<in> B \\<and> R a b}\\<^sup>*;\n        x # xs \\<in> lists A; y # ys \\<in> lists B\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f (x # xs) r, fold g (y # ys) s)\n                         \\<in> {((r, s), f a r, g b s) |a b r s.\n                                a \\<in> A \\<and>\n                                b \\<in> B \\<and> R a b}\\<^sup>*", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r, s), fold f [] r, fold g [] s)\n    \\<in> {((r, s), f a r, g b s) |a b r s.\n           a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  ((r, s), fold f [] r, fold g [] s)\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys r s.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        \\<And>r s.\n           \\<lbrakk>xs \\<in> lists A; ys \\<in> lists B\\<rbrakk>\n           \\<Longrightarrow> ((r, s), fold f xs r, fold g ys s)\n                             \\<in> {((r, s), f a r, g b s) |a b r s.\n                                    a \\<in> A \\<and>\n                                    b \\<in> B \\<and> R a b}\\<^sup>*;\n        x # xs \\<in> lists A; y # ys \\<in> lists B\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f (x # xs) r, fold g (y # ys) s)\n                         \\<in> {((r, s), f a r, g b s) |a b r s.\n                                a \\<in> A \\<and>\n                                b \\<in> B \\<and> R a b}\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys r s.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        \\<And>r s.\n           \\<lbrakk>xs \\<in> lists A; ys \\<in> lists B\\<rbrakk>\n           \\<Longrightarrow> ((r, s), fold f xs r, fold g ys s)\n                             \\<in> {((r, s), f a r, g b s) |a b r s.\n                                    a \\<in> A \\<and>\n                                    b \\<in> B \\<and> R a b}\\<^sup>*;\n        x # xs \\<in> lists A; y # ys \\<in> lists B\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f (x # xs) r, fold g (y # ys) s)\n                         \\<in> {((r, s), f a r, g b s) |a b r s.\n                                a \\<in> A \\<and>\n                                b \\<in> B \\<and> R a b}\\<^sup>*", "case Cons"], ["proof (state)\nthis:\n  R x_ y_\n  list_all2 R xs_ ys_\n  \\<lbrakk>xs_ \\<in> lists A; ys_ \\<in> lists B\\<rbrakk>\n  \\<Longrightarrow> ((?r, ?s), fold f xs_ ?r, fold g ys_ ?s)\n                    \\<in> {((r, s), f a r, g b s) |a b r s.\n                           a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n  x_ # xs_ \\<in> lists A\n  y_ # ys_ \\<in> lists B\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys r s.\n       \\<lbrakk>R x y; list_all2 R xs ys;\n        \\<And>r s.\n           \\<lbrakk>xs \\<in> lists A; ys \\<in> lists B\\<rbrakk>\n           \\<Longrightarrow> ((r, s), fold f xs r, fold g ys s)\n                             \\<in> {((r, s), f a r, g b s) |a b r s.\n                                    a \\<in> A \\<and>\n                                    b \\<in> B \\<and> R a b}\\<^sup>*;\n        x # xs \\<in> lists A; y # ys \\<in> lists B\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f (x # xs) r, fold g (y # ys) s)\n                         \\<in> {((r, s), f a r, g b s) |a b r s.\n                                a \\<in> A \\<and>\n                                b \\<in> B \\<and> R a b}\\<^sup>*", "thus ?case"], ["proof (prove)\nusing this:\n  R x_ y_\n  list_all2 R xs_ ys_\n  \\<lbrakk>xs_ \\<in> lists A; ys_ \\<in> lists B\\<rbrakk>\n  \\<Longrightarrow> ((?r, ?s), fold f xs_ ?r, fold g ys_ ?s)\n                    \\<in> {((r, s), f a r, g b s) |a b r s.\n                           a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n  x_ # xs_ \\<in> lists A\n  y_ # ys_ \\<in> lists B\n\ngoal (1 subgoal):\n 1. ((r, s), fold f (x_ # xs_) r, fold g (y_ # ys_) s)\n    \\<in> {((r, s), f a r, g b s) |a b r s.\n           a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*", "by (force elim!: converse_rtrancl_into_rtrancl[rotated])"], ["proof (state)\nthis:\n  ((r, s), fold f (x_ # xs_) r, fold g (y_ # ys_) s)\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((r, s), fold f w1 r, fold g w2 s)\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>list_all2 R ?w1.2 ?w2.2; ?w1.2 \\<in> lists A;\n   ?w2.2 \\<in> lists B\\<rbrakk>\n  \\<Longrightarrow> ((r, s), fold f ?w1.2 r, fold g ?w2.2 s)\n                    \\<in> {((r, s), f a r, g b s) |a b r s.\n                           a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "hence \"((r, s), (r', s')) \\<in> ?R \\<Longrightarrow> ((r, s), (r', s')) \\<in> ?L\""], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all2 R ?w1.2 ?w2.2; ?w1.2 \\<in> lists A;\n   ?w2.2 \\<in> lists B\\<rbrakk>\n  \\<Longrightarrow> ((r, s), fold f ?w1.2 r, fold g ?w2.2 s)\n                    \\<in> {((r, s), f a r, g b s) |a b r s.\n                           a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n\ngoal (1 subgoal):\n 1. ((r, s), r', s')\n    \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n           w1 \\<in> lists A \\<and>\n           w2 \\<in> lists B \\<and> list_all2 R w1 w2} \\<Longrightarrow>\n    ((r, s), r', s')\n    \\<in> {((r, s), f a r, g b s) |a b r s.\n           a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  ((r, s), r', s')\n  \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n         w1 \\<in> lists A \\<and>\n         w2 \\<in> lists B \\<and> list_all2 R w1 w2} \\<Longrightarrow>\n  ((r, s), r', s')\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "}"], ["proof (state)\nthis:\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n         w1 \\<in> lists A \\<and>\n         w2 \\<in> lists B \\<and> list_all2 R w1 w2} \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "hence \"\\<And>x. x \\<in> ?R \\<Longrightarrow> x \\<in> ?L\""], ["proof (prove)\nusing this:\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n         w1 \\<in> lists A \\<and>\n         w2 \\<in> lists B \\<and> list_all2 R w1 w2} \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), f a r, g b s) |a b r s.\n         a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n                w1 \\<in> lists A \\<and>\n                w2 \\<in> lists B \\<and> list_all2 R w1 w2} \\<Longrightarrow>\n       x \\<in> {((r, s), f a r, g b s) |a b r s.\n                a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n            w1 \\<in> lists A \\<and>\n            w2 \\<in> lists B \\<and> list_all2 R w1 w2} \\<Longrightarrow>\n  ?x \\<in> {((r, s), f a r, g b s) |a b r s.\n            a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> {((r, s), f a r, g b s) |a b r s.\n            a \\<in> A \\<and>\n            b \\<in> B \\<and> R a b}\\<^sup>* \\<Longrightarrow>\n  ?x \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n            w1 \\<in> lists A \\<and>\n            w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n  ?x \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n            w1 \\<in> lists A \\<and>\n            w2 \\<in> lists B \\<and> list_all2 R w1 w2} \\<Longrightarrow>\n  ?x \\<in> {((r, s), f a r, g b s) |a b r s.\n            a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> {((r, s), f a r, g b s) |a b r s.\n            a \\<in> A \\<and>\n            b \\<in> B \\<and> R a b}\\<^sup>* \\<Longrightarrow>\n  ?x \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n            w1 \\<in> lists A \\<and>\n            w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n  ?x \\<in> {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n            w1 \\<in> lists A \\<and>\n            w2 \\<in> lists B \\<and> list_all2 R w1 w2} \\<Longrightarrow>\n  ?x \\<in> {((r, s), f a r, g b s) |a b r s.\n            a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, g b s) |a b r s.\n     a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n    {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n     w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}", "by blast"], ["proof (state)\nthis:\n  {((r, s), f a r, g b s) |a b r s.\n   a \\<in> A \\<and> b \\<in> B \\<and> R a b}\\<^sup>* =\n  {((r, s), fold f w1 r, fold g w2 s) |w1 w2 r s.\n   w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rtrancl_fold_product1:\nshows \"{(r, s). \\<exists>a \\<in> A. s = f a r}^* = {(r, s). \\<exists>a \\<in> lists A. s = fold f a r}\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "fix r s"], ["proof (state)\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "have \"(r, s) \\<in> ?L \\<Longrightarrow> (r, s) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r, s)\n    \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* \\<Longrightarrow>\n    (r, s) \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "proof(induction rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (s, s)\n    \\<in> {a. case a of\n              (r, s) \\<Rightarrow> \\<exists>a\\<in>lists A. s = fold f a r}\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r};\n        (z, s) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*;\n        (z, s)\n        \\<in> {a. case a of\n                  (r, s) \\<Rightarrow>\n                    \\<exists>a\\<in>lists A. s = fold f a r}\\<rbrakk>\n       \\<Longrightarrow> (y, s)\n                         \\<in> {a. case a of\n                                   (r, s) \\<Rightarrow>\n                                     \\<exists>a\\<in>lists A. s = fold f a r}", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (s, s)\n    \\<in> {a. case a of\n              (r, s) \\<Rightarrow> \\<exists>a\\<in>lists A. s = fold f a r}\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r};\n        (z, s) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*;\n        (z, s)\n        \\<in> {a. case a of\n                  (r, s) \\<Rightarrow>\n                    \\<exists>a\\<in>lists A. s = fold f a r}\\<rbrakk>\n       \\<Longrightarrow> (y, s)\n                         \\<in> {a. case a of\n                                   (r, s) \\<Rightarrow>\n                                     \\<exists>a\\<in>lists A. s = fold f a r}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s)\n    \\<in> {a. case a of\n              (r, s) \\<Rightarrow> \\<exists>a\\<in>lists A. s = fold f a r}", "by(force intro!: fold_simps(1)[symmetric])"], ["proof (state)\nthis:\n  (s, s)\n  \\<in> {a. case a of\n            (r, s) \\<Rightarrow> \\<exists>a\\<in>lists A. s = fold f a r}\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r};\n        (z, s) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*;\n        (z, s)\n        \\<in> {a. case a of\n                  (r, s) \\<Rightarrow>\n                    \\<exists>a\\<in>lists A. s = fold f a r}\\<rbrakk>\n       \\<Longrightarrow> (y, s)\n                         \\<in> {a. case a of\n                                   (r, s) \\<Rightarrow>\n                                     \\<exists>a\\<in>lists A. s = fold f a r}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r};\n        (z, s) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*;\n        (z, s)\n        \\<in> {a. case a of\n                  (r, s) \\<Rightarrow>\n                    \\<exists>a\\<in>lists A. s = fold f a r}\\<rbrakk>\n       \\<Longrightarrow> (y, s)\n                         \\<in> {a. case a of\n                                   (r, s) \\<Rightarrow>\n                                     \\<exists>a\\<in>lists A. s = fold f a r}", "case step"], ["proof (state)\nthis:\n  (y_, z_) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\n  (z_, s) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n  (z_, s)\n  \\<in> {a. case a of\n            (r, s) \\<Rightarrow> \\<exists>a\\<in>lists A. s = fold f a r}\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r};\n        (z, s) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*;\n        (z, s)\n        \\<in> {a. case a of\n                  (r, s) \\<Rightarrow>\n                    \\<exists>a\\<in>lists A. s = fold f a r}\\<rbrakk>\n       \\<Longrightarrow> (y, s)\n                         \\<in> {a. case a of\n                                   (r, s) \\<Rightarrow>\n                                     \\<exists>a\\<in>lists A. s = fold f a r}", "thus ?case"], ["proof (prove)\nusing this:\n  (y_, z_) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\n  (z_, s) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n  (z_, s)\n  \\<in> {a. case a of\n            (r, s) \\<Rightarrow> \\<exists>a\\<in>lists A. s = fold f a r}\n\ngoal (1 subgoal):\n 1. (y_, s)\n    \\<in> {a. case a of\n              (r, s) \\<Rightarrow> \\<exists>a\\<in>lists A. s = fold f a r}", "by(force intro!: fold_simps(2)[symmetric])"], ["proof (state)\nthis:\n  (y_, s)\n  \\<in> {a. case a of\n            (r, s) \\<Rightarrow> \\<exists>a\\<in>lists A. s = fold f a r}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (r, s)\n  \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* \\<Longrightarrow>\n  (r, s) \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}\n\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "}"], ["proof (state)\nthis:\n  (?r2, ?s2)\n  \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* \\<Longrightarrow>\n  (?r2, ?s2) \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}\n\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "moreover"], ["proof (state)\nthis:\n  (?r2, ?s2)\n  \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* \\<Longrightarrow>\n  (?r2, ?s2) \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}\n\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "{"], ["proof (state)\nthis:\n  (?r2, ?s2)\n  \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* \\<Longrightarrow>\n  (?r2, ?s2) \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}\n\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "fix r s"], ["proof (state)\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "assume \"w \\<in> lists A\""], ["proof (state)\nthis:\n  w \\<in> lists A\n\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "then"], ["proof (chain)\npicking this:\n  w \\<in> lists A", "have \"(r, fold f w r) \\<in> ?L\""], ["proof (prove)\nusing this:\n  w \\<in> lists A\n\ngoal (1 subgoal):\n 1. (r, fold f w r) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*", "proof(induction w rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> lists A \\<Longrightarrow>\n    (r, fold f [] r) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists A \\<Longrightarrow>\n                (r, fold f xs r)\n                \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*;\n        xs @ [x] \\<in> lists A\\<rbrakk>\n       \\<Longrightarrow> (r, fold f (xs @ [x]) r)\n                         \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> lists A\n\ngoal (2 subgoals):\n 1. [] \\<in> lists A \\<Longrightarrow>\n    (r, fold f [] r) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists A \\<Longrightarrow>\n                (r, fold f xs r)\n                \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*;\n        xs @ [x] \\<in> lists A\\<rbrakk>\n       \\<Longrightarrow> (r, fold f (xs @ [x]) r)\n                         \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r, fold f [] r)\n    \\<in> {a. case a of\n              (r, s) \\<Rightarrow> \\<exists>a\\<in>A. s = f a r}\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (r, fold f [] r)\n  \\<in> {a. case a of\n            (r, s) \\<Rightarrow> \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists A \\<Longrightarrow>\n                (r, fold f xs r)\n                \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*;\n        xs @ [x] \\<in> lists A\\<rbrakk>\n       \\<Longrightarrow> (r, fold f (xs @ [x]) r)\n                         \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists A \\<Longrightarrow>\n                (r, fold f xs r)\n                \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*;\n        xs @ [x] \\<in> lists A\\<rbrakk>\n       \\<Longrightarrow> (r, fold f (xs @ [x]) r)\n                         \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*", "case snoc"], ["proof (state)\nthis:\n  xs_ \\<in> lists A \\<Longrightarrow>\n  (r, fold f xs_ r)\n  \\<in> {a. case a of\n            (r, s) \\<Rightarrow> \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n  xs_ @ [x_] \\<in> lists A\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists A \\<Longrightarrow>\n                (r, fold f xs r)\n                \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*;\n        xs @ [x] \\<in> lists A\\<rbrakk>\n       \\<Longrightarrow> (r, fold f (xs @ [x]) r)\n                         \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*", "thus ?case"], ["proof (prove)\nusing this:\n  xs_ \\<in> lists A \\<Longrightarrow>\n  (r, fold f xs_ r)\n  \\<in> {a. case a of\n            (r, s) \\<Rightarrow> \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n  xs_ @ [x_] \\<in> lists A\n\ngoal (1 subgoal):\n 1. (r, fold f (xs_ @ [x_]) r)\n    \\<in> {a. case a of\n              (r, s) \\<Rightarrow> \\<exists>a\\<in>A. s = f a r}\\<^sup>*", "by (force elim!: rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (r, fold f (xs_ @ [x_]) r)\n  \\<in> {a. case a of\n            (r, s) \\<Rightarrow> \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (r, fold f w r) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "}"], ["proof (state)\nthis:\n  ?w2 \\<in> lists A \\<Longrightarrow>\n  (r, fold f ?w2 r) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "hence \"(r, s) \\<in> ?R \\<Longrightarrow> (r, s) \\<in> ?L\""], ["proof (prove)\nusing this:\n  ?w2 \\<in> lists A \\<Longrightarrow>\n  (r, fold f ?w2 r) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n\ngoal (1 subgoal):\n 1. (r, s)\n    \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r} \\<Longrightarrow>\n    (r, s) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (r, s)\n  \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r} \\<Longrightarrow>\n  (r, s) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "}"], ["proof (state)\nthis:\n  (?r2, ?s2)\n  \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r} \\<Longrightarrow>\n  (?r2, ?s2) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "ultimately"], ["proof (chain)\npicking this:\n  (?r2, ?s2)\n  \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* \\<Longrightarrow>\n  (?r2, ?s2) \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}\n  (?r2, ?s2)\n  \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r} \\<Longrightarrow>\n  (?r2, ?s2) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  (?r2, ?s2)\n  \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* \\<Longrightarrow>\n  (?r2, ?s2) \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}\n  (?r2, ?s2)\n  \\<in> {(r, s). \\<exists>a\\<in>lists A. s = fold f a r} \\<Longrightarrow>\n  (?r2, ?s2) \\<in> {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n    {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}", "by (auto 10 0)"], ["proof (state)\nthis:\n  {(r, s). \\<exists>a\\<in>A. s = f a r}\\<^sup>* =\n  {(r, s). \\<exists>a\\<in>lists A. s = fold f a r}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lang_eq_ext_Nil_fold_Deriv:\n  fixes K L A R\n  assumes\n    \"\\<And>w. in_language K w \\<Longrightarrow> w \\<in> lists A\"\n    \"\\<And>w. in_language L w \\<Longrightarrow> w \\<in> lists B\"\n    \"\\<And>a b. R a b \\<Longrightarrow> a \\<in> A \\<longleftrightarrow> b \\<in> B\"\n  defines \"\\<BB> \\<equiv> {(\\<dd>s w1 K, \\<dd>s w2 L) | w1 w2. w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2}\"\n  shows \"rel_language R K L \\<longleftrightarrow> (\\<forall>(K, L) \\<in> \\<BB>. \\<oo> K \\<longleftrightarrow> \\<oo> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_language R K L = (\\<forall>(K, L)\\<in>\\<BB>. \\<oo> K = \\<oo> L)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rel_language R K L \\<Longrightarrow>\n    \\<forall>(K, L)\\<in>\\<BB>. \\<oo> K = \\<oo> L\n 2. \\<forall>(K, L)\\<in>\\<BB>. \\<oo> K = \\<oo> L \\<Longrightarrow>\n    rel_language R K L", "assume \"\\<forall>(K, L)\\<in>\\<BB>. \\<oo> K = \\<oo> L\""], ["proof (state)\nthis:\n  \\<forall>(K, L)\\<in>\\<BB>. \\<oo> K = \\<oo> L\n\ngoal (2 subgoals):\n 1. rel_language R K L \\<Longrightarrow>\n    \\<forall>(K, L)\\<in>\\<BB>. \\<oo> K = \\<oo> L\n 2. \\<forall>(K, L)\\<in>\\<BB>. \\<oo> K = \\<oo> L \\<Longrightarrow>\n    rel_language R K L", "then"], ["proof (chain)\npicking this:\n  \\<forall>(K, L)\\<in>\\<BB>. \\<oo> K = \\<oo> L", "show \"rel_language R K L\""], ["proof (prove)\nusing this:\n  \\<forall>(K, L)\\<in>\\<BB>. \\<oo> K = \\<oo> L\n\ngoal (1 subgoal):\n 1. rel_language R K L", "unfolding \\<BB>_def"], ["proof (prove)\nusing this:\n  \\<forall>(K, L)\n           \\<in>{(\\<dd>s w1 K, \\<dd>s w2 L) |w1 w2.\n                 w1 \\<in> lists A \\<and>\n                 w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n     \\<oo> K = \\<oo> L\n\ngoal (1 subgoal):\n 1. rel_language R K L", "using assms(1,2)"], ["proof (prove)\nusing this:\n  \\<forall>(K, L)\n           \\<in>{(\\<dd>s w1 K, \\<dd>s w2 L) |w1 w2.\n                 w1 \\<in> lists A \\<and>\n                 w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n     \\<oo> K = \\<oo> L\n  in_language K ?w \\<Longrightarrow> ?w \\<in> lists A\n  in_language L ?w \\<Longrightarrow> ?w \\<in> lists B\n\ngoal (1 subgoal):\n 1. rel_language R K L", "proof (coinduction arbitrary: K L)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K L.\n       \\<lbrakk>\\<forall>(K, L)\n                         \\<in>{(\\<dd>s w1 K, \\<dd>s w2 L) |w1 w2.\n                               w1 \\<in> lists A \\<and>\n                               w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n                   \\<oo> K = \\<oo> L;\n        \\<forall>w. in_language K w \\<longrightarrow> w \\<in> lists A;\n        \\<forall>w.\n           in_language L w \\<longrightarrow> w \\<in> lists B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>La Ka Ra.\n                            R = Ra \\<and>\n                            K = La \\<and>\n                            L = Ka \\<and>\n                            \\<oo> La = \\<oo> Ka \\<and>\n                            (\\<forall>x xa.\n                                Ra x xa \\<longrightarrow>\n                                (\\<exists>K L.\n                                    Ra = R \\<and>\n                                    \\<dd> La x = K \\<and>\n                                    \\<dd> Ka xa = L \\<and>\n                                    (\\<forall>(K, L)\n        \\<in>{(\\<dd>s w1 K, \\<dd>s w2 L) |w1 w2.\n              w1 \\<in> lists A \\<and>\n              w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n  \\<oo> K = \\<oo> L) \\<and>\n                                    (\\<forall>w.\n  in_language K w \\<longrightarrow> w \\<in> lists A) \\<and>\n                                    (\\<forall>w.\n  in_language L w \\<longrightarrow> w \\<in> lists B)) \\<or>\n                                rel_language Ra (\\<dd> La x) (\\<dd> Ka xa))", "case (Lang K L)"], ["proof (state)\nthis:\n  \\<forall>(K, L)\n           \\<in>{(\\<dd>s w1 K, \\<dd>s w2 L) |w1 w2.\n                 w1 \\<in> lists A \\<and>\n                 w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n     \\<oo> K = \\<oo> L\n  \\<forall>w. in_language K w \\<longrightarrow> w \\<in> lists A\n  \\<forall>w. in_language L w \\<longrightarrow> w \\<in> lists B\n\ngoal (1 subgoal):\n 1. \\<And>K L.\n       \\<lbrakk>\\<forall>(K, L)\n                         \\<in>{(\\<dd>s w1 K, \\<dd>s w2 L) |w1 w2.\n                               w1 \\<in> lists A \\<and>\n                               w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n                   \\<oo> K = \\<oo> L;\n        \\<forall>w. in_language K w \\<longrightarrow> w \\<in> lists A;\n        \\<forall>w.\n           in_language L w \\<longrightarrow> w \\<in> lists B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>La Ka Ra.\n                            R = Ra \\<and>\n                            K = La \\<and>\n                            L = Ka \\<and>\n                            \\<oo> La = \\<oo> Ka \\<and>\n                            (\\<forall>x xa.\n                                Ra x xa \\<longrightarrow>\n                                (\\<exists>K L.\n                                    Ra = R \\<and>\n                                    \\<dd> La x = K \\<and>\n                                    \\<dd> Ka xa = L \\<and>\n                                    (\\<forall>(K, L)\n        \\<in>{(\\<dd>s w1 K, \\<dd>s w2 L) |w1 w2.\n              w1 \\<in> lists A \\<and>\n              w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n  \\<oo> K = \\<oo> L) \\<and>\n                                    (\\<forall>w.\n  in_language K w \\<longrightarrow> w \\<in> lists A) \\<and>\n                                    (\\<forall>w.\n  in_language L w \\<longrightarrow> w \\<in> lists B)) \\<or>\n                                rel_language Ra (\\<dd> La x) (\\<dd> Ka xa))", "then"], ["proof (chain)\npicking this:\n  \\<forall>(K, L)\n           \\<in>{(\\<dd>s w1 K, \\<dd>s w2 L) |w1 w2.\n                 w1 \\<in> lists A \\<and>\n                 w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n     \\<oo> K = \\<oo> L\n  \\<forall>w. in_language K w \\<longrightarrow> w \\<in> lists A\n  \\<forall>w. in_language L w \\<longrightarrow> w \\<in> lists B", "have CIH: \"\\<And>K' L'. \\<exists>w1 w2.\n      K' = \\<dd>s w1 K \\<and> L' = \\<dd>s w2 L \\<and> w1 \\<in> lists A \\<and> w2 \\<in> lists B \\<and> list_all2 R w1 w2 \\<Longrightarrow> \\<oo> K' = \\<oo> L'\" and\n      [dest]: \"\\<And>w. in_language K w \\<Longrightarrow> w \\<in> lists A\" \"\\<And>w. in_language L w \\<Longrightarrow> w \\<in> lists B\""], ["proof (prove)\nusing this:\n  \\<forall>(K, L)\n           \\<in>{(\\<dd>s w1 K, \\<dd>s w2 L) |w1 w2.\n                 w1 \\<in> lists A \\<and>\n                 w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n     \\<oo> K = \\<oo> L\n  \\<forall>w. in_language K w \\<longrightarrow> w \\<in> lists A\n  \\<forall>w. in_language L w \\<longrightarrow> w \\<in> lists B\n\ngoal (1 subgoal):\n 1. (\\<And>K' L'.\n        \\<exists>w1 w2.\n           K' = \\<dd>s w1 K \\<and>\n           L' = \\<dd>s w2 L \\<and>\n           w1 \\<in> lists A \\<and>\n           w2 \\<in> lists B \\<and> list_all2 R w1 w2 \\<Longrightarrow>\n        \\<oo> K' = \\<oo> L') &&&\n    (\\<And>w. in_language K w \\<Longrightarrow> w \\<in> lists A) &&&\n    (\\<And>w. in_language L w \\<Longrightarrow> w \\<in> lists B)", "by blast+"], ["proof (state)\nthis:\n  \\<exists>w1 w2.\n     ?K' = \\<dd>s w1 K \\<and>\n     ?L' = \\<dd>s w2 L \\<and>\n     w1 \\<in> lists A \\<and>\n     w2 \\<in> lists B \\<and> list_all2 R w1 w2 \\<Longrightarrow>\n  \\<oo> ?K' = \\<oo> ?L'\n  in_language K ?w \\<Longrightarrow> ?w \\<in> lists A\n  in_language L ?w \\<Longrightarrow> ?w \\<in> lists B\n\ngoal (1 subgoal):\n 1. \\<And>K L.\n       \\<lbrakk>\\<forall>(K, L)\n                         \\<in>{(\\<dd>s w1 K, \\<dd>s w2 L) |w1 w2.\n                               w1 \\<in> lists A \\<and>\n                               w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n                   \\<oo> K = \\<oo> L;\n        \\<forall>w. in_language K w \\<longrightarrow> w \\<in> lists A;\n        \\<forall>w.\n           in_language L w \\<longrightarrow> w \\<in> lists B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>La Ka Ra.\n                            R = Ra \\<and>\n                            K = La \\<and>\n                            L = Ka \\<and>\n                            \\<oo> La = \\<oo> Ka \\<and>\n                            (\\<forall>x xa.\n                                Ra x xa \\<longrightarrow>\n                                (\\<exists>K L.\n                                    Ra = R \\<and>\n                                    \\<dd> La x = K \\<and>\n                                    \\<dd> Ka xa = L \\<and>\n                                    (\\<forall>(K, L)\n        \\<in>{(\\<dd>s w1 K, \\<dd>s w2 L) |w1 w2.\n              w1 \\<in> lists A \\<and>\n              w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n  \\<oo> K = \\<oo> L) \\<and>\n                                    (\\<forall>w.\n  in_language K w \\<longrightarrow> w \\<in> lists A) \\<and>\n                                    (\\<forall>w.\n  in_language L w \\<longrightarrow> w \\<in> lists B)) \\<or>\n                                rel_language Ra (\\<dd> La x) (\\<dd> Ka xa))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L K Ra.\n       R = Ra \\<and>\n       K = L \\<and>\n       L = K \\<and>\n       \\<oo> L = \\<oo> K \\<and>\n       (\\<forall>x xa.\n           Ra x xa \\<longrightarrow>\n           (\\<exists>Ka La.\n               Ra = R \\<and>\n               \\<dd> L x = Ka \\<and>\n               \\<dd> K xa = La \\<and>\n               (\\<forall>(K, L)\n                         \\<in>{(\\<dd>s w1 Ka, \\<dd>s w2 La) |w1 w2.\n                               w1 \\<in> lists A \\<and>\n                               w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n                   \\<oo> K = \\<oo> L) \\<and>\n               (\\<forall>w.\n                   in_language Ka w \\<longrightarrow>\n                   w \\<in> lists A) \\<and>\n               (\\<forall>w.\n                   in_language La w \\<longrightarrow>\n                   w \\<in> lists B)) \\<or>\n           rel_language Ra (\\<dd> L x) (\\<dd> K xa))", "unfolding ex_simps simp_thms"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> K = \\<oo> L \\<and>\n    (\\<forall>x xa.\n        R x xa \\<longrightarrow>\n        (\\<forall>(K, L)\n                  \\<in>{(\\<dd>s w1 (\\<dd> K x), \\<dd>s w2 (\\<dd> L xa)) |w1\n                        w2.\n                        w1 \\<in> lists A \\<and>\n                        w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n            \\<oo> K = \\<oo> L) \\<and>\n        (\\<forall>w.\n            in_language (\\<dd> K x) w \\<longrightarrow>\n            w \\<in> lists A) \\<and>\n        (\\<forall>w.\n            in_language (\\<dd> L xa) w \\<longrightarrow>\n            w \\<in> lists B) \\<or>\n        rel_language R (\\<dd> K x) (\\<dd> L xa))", "proof (safe del: iffI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<oo> K = \\<oo> L\n 2. \\<And>x xa a b w1 w2.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        \\<forall>x\\<in>set w1. x \\<in> A; list_all2 R w1 w2;\n        \\<forall>x\\<in>set w2. x \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<oo> (\\<dd>s w1 (\\<dd> K x)) =\n                         \\<oo> (\\<dd>s w2 (\\<dd> L xa))\n 3. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> K x) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> A\n 4. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> L xa) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> B", "show \"\\<oo> K = \\<oo> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<oo> K = \\<oo> L", "by (intro CIH[OF exI[where x = \"[]\"]]) simp"], ["proof (state)\nthis:\n  \\<oo> K = \\<oo> L\n\ngoal (3 subgoals):\n 1. \\<And>x xa a b w1 w2.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        \\<forall>x\\<in>set w1. x \\<in> A; list_all2 R w1 w2;\n        \\<forall>x\\<in>set w2. x \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<oo> (\\<dd>s w1 (\\<dd> K x)) =\n                         \\<oo> (\\<dd>s w2 (\\<dd> L xa))\n 2. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> K x) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> A\n 3. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> L xa) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> B", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa a b w1 w2.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        \\<forall>x\\<in>set w1. x \\<in> A; list_all2 R w1 w2;\n        \\<forall>x\\<in>set w2. x \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<oo> (\\<dd>s w1 (\\<dd> K x)) =\n                         \\<oo> (\\<dd>s w2 (\\<dd> L xa))\n 2. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> K x) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> A\n 3. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> L xa) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> B", "fix x y w1 w2"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa a b w1 w2.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        \\<forall>x\\<in>set w1. x \\<in> A; list_all2 R w1 w2;\n        \\<forall>x\\<in>set w2. x \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<oo> (\\<dd>s w1 (\\<dd> K x)) =\n                         \\<oo> (\\<dd>s w2 (\\<dd> L xa))\n 2. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> K x) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> A\n 3. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> L xa) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> B", "assume \"\\<forall>x\\<in>set w1. x \\<in> A\" \"\\<forall>x\\<in>set w2. x \\<in> B\" \"list_all2 R w1 w2\" \"R x y\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>set w1. x \\<in> A\n  \\<forall>x\\<in>set w2. x \\<in> B\n  list_all2 R w1 w2\n  R x y\n\ngoal (3 subgoals):\n 1. \\<And>x xa a b w1 w2.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        \\<forall>x\\<in>set w1. x \\<in> A; list_all2 R w1 w2;\n        \\<forall>x\\<in>set w2. x \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<oo> (\\<dd>s w1 (\\<dd> K x)) =\n                         \\<oo> (\\<dd>s w2 (\\<dd> L xa))\n 2. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> K x) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> A\n 3. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> L xa) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> B", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set w1. x \\<in> A\n  \\<forall>x\\<in>set w2. x \\<in> B\n  list_all2 R w1 w2\n  R x y", "show \"\\<oo> (\\<dd>s w1 (\\<dd> K x)) = \\<oo> (\\<dd>s w2 (\\<dd> L y))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set w1. x \\<in> A\n  \\<forall>x\\<in>set w2. x \\<in> B\n  list_all2 R w1 w2\n  R x y\n\ngoal (1 subgoal):\n 1. \\<oo> (\\<dd>s w1 (\\<dd> K x)) = \\<oo> (\\<dd>s w2 (\\<dd> L y))", "proof (cases \"x \\<in> A \\<and> y \\<in> B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set w1. x \\<in> A;\n     \\<forall>x\\<in>set w2. x \\<in> B; list_all2 R w1 w2; R x y;\n     x \\<in> A \\<and> y \\<in> B\\<rbrakk>\n    \\<Longrightarrow> \\<oo> (\\<dd>s w1 (\\<dd> K x)) =\n                      \\<oo> (\\<dd>s w2 (\\<dd> L y))\n 2. \\<lbrakk>\\<forall>x\\<in>set w1. x \\<in> A;\n     \\<forall>x\\<in>set w2. x \\<in> B; list_all2 R w1 w2; R x y;\n     \\<not> (x \\<in> A \\<and> y \\<in> B)\\<rbrakk>\n    \\<Longrightarrow> \\<oo> (\\<dd>s w1 (\\<dd> K x)) =\n                      \\<oo> (\\<dd>s w2 (\\<dd> L y))", "assume \"\\<not> (x \\<in> A \\<and> y \\<in> B)\""], ["proof (state)\nthis:\n  \\<not> (x \\<in> A \\<and> y \\<in> B)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set w1. x \\<in> A;\n     \\<forall>x\\<in>set w2. x \\<in> B; list_all2 R w1 w2; R x y;\n     x \\<in> A \\<and> y \\<in> B\\<rbrakk>\n    \\<Longrightarrow> \\<oo> (\\<dd>s w1 (\\<dd> K x)) =\n                      \\<oo> (\\<dd>s w2 (\\<dd> L y))\n 2. \\<lbrakk>\\<forall>x\\<in>set w1. x \\<in> A;\n     \\<forall>x\\<in>set w2. x \\<in> B; list_all2 R w1 w2; R x y;\n     \\<not> (x \\<in> A \\<and> y \\<in> B)\\<rbrakk>\n    \\<Longrightarrow> \\<oo> (\\<dd>s w1 (\\<dd> K x)) =\n                      \\<oo> (\\<dd>s w2 (\\<dd> L y))", "with assms(3)[OF \\<open>R x y\\<close>]"], ["proof (chain)\npicking this:\n  (x \\<in> A) = (y \\<in> B)\n  \\<not> (x \\<in> A \\<and> y \\<in> B)", "show ?thesis"], ["proof (prove)\nusing this:\n  (x \\<in> A) = (y \\<in> B)\n  \\<not> (x \\<in> A \\<and> y \\<in> B)\n\ngoal (1 subgoal):\n 1. \\<oo> (\\<dd>s w1 (\\<dd> K x)) = \\<oo> (\\<dd>s w2 (\\<dd> L y))", "by (auto simp: in_language_\\<dd>s in_language.simps[symmetric] simp del: in_language.simps)"], ["proof (state)\nthis:\n  \\<oo> (\\<dd>s w1 (\\<dd> K x)) = \\<oo> (\\<dd>s w2 (\\<dd> L y))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set w1. x \\<in> A;\n     \\<forall>x\\<in>set w2. x \\<in> B; list_all2 R w1 w2; R x y;\n     x \\<in> A \\<and> y \\<in> B\\<rbrakk>\n    \\<Longrightarrow> \\<oo> (\\<dd>s w1 (\\<dd> K x)) =\n                      \\<oo> (\\<dd>s w2 (\\<dd> L y))", "qed (intro CIH exI[where x = \"x # w1\"] exI[where x = \"y # w2\"], auto)"], ["proof (state)\nthis:\n  \\<oo> (\\<dd>s w1 (\\<dd> K x)) = \\<oo> (\\<dd>s w2 (\\<dd> L y))\n\ngoal (2 subgoals):\n 1. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> K x) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> A\n 2. \\<And>x xa w xb.\n       \\<lbrakk>R x xa; \\<not> rel_language R (\\<dd> K x) (\\<dd> L xa);\n        in_language (\\<dd> L xa) w; xb \\<in> set w\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> B", "qed (auto simp add: in_language.simps[symmetric] simp del: in_language.simps)"], ["proof (state)\nthis:\n  \\<exists>L K Ra.\n     R = Ra \\<and>\n     K = L \\<and>\n     L = K \\<and>\n     \\<oo> L = \\<oo> K \\<and>\n     (\\<forall>x xa.\n         Ra x xa \\<longrightarrow>\n         (\\<exists>Ka La.\n             Ra = R \\<and>\n             \\<dd> L x = Ka \\<and>\n             \\<dd> K xa = La \\<and>\n             (\\<forall>(K, L)\n                       \\<in>{(\\<dd>s w1 Ka, \\<dd>s w2 La) |w1 w2.\n                             w1 \\<in> lists A \\<and>\n                             w2 \\<in> lists B \\<and> list_all2 R w1 w2}.\n                 \\<oo> K = \\<oo> L) \\<and>\n             (\\<forall>w.\n                 in_language Ka w \\<longrightarrow> w \\<in> lists A) \\<and>\n             (\\<forall>w.\n                 in_language La w \\<longrightarrow> w \\<in> lists B)) \\<or>\n         rel_language Ra (\\<dd> L x) (\\<dd> K xa))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_language R K L\n\ngoal (1 subgoal):\n 1. rel_language R K L \\<Longrightarrow>\n    \\<forall>(K, L)\\<in>\\<BB>. \\<oo> K = \\<oo> L", "qed (auto simp: \\<BB>_def rel_language_alt rel_fun_def \\<oo>_\\<dd>s)"], ["", "subsection \\<open>Abstract Deterministic Automaton\\<close>"], ["", "locale DA =\nfixes alphabet :: \"'a list\"\nfixes init :: \"'t \\<Rightarrow> 's\"\nfixes delta :: \"'a \\<Rightarrow> 's \\<Rightarrow> 's\"\nfixes accept :: \"'s \\<Rightarrow> bool\"\nfixes wellformed :: \"'s \\<Rightarrow> bool\"\nfixes Language :: \"'s \\<Rightarrow> 'a language\"\nfixes wf :: \"'t \\<Rightarrow> bool\"\nfixes Lang :: \"'t \\<Rightarrow> 'a language\"\nassumes distinct_alphabet: \"distinct alphabet\"\nassumes Language_init: \"wf t \\<Longrightarrow> Language (init t) = Lang t\"\nassumes wellformed_init: \"wf t \\<Longrightarrow> wellformed (init t)\"\nassumes Language_alphabet: \"\\<lbrakk>wellformed s; in_language (Language s) w\\<rbrakk> \\<Longrightarrow> w \\<in> lists (set alphabet)\"\nassumes wellformed_delta: \"\\<lbrakk>wellformed s; a \\<in> set alphabet\\<rbrakk> \\<Longrightarrow> wellformed (delta a s)\"\nassumes Language_delta: \"\\<lbrakk>wellformed s; a \\<in> set alphabet\\<rbrakk> \\<Longrightarrow> Language (delta a s) = \\<dd> (Language s) a\"\nassumes accept_Language: \"wellformed s \\<Longrightarrow> accept s \\<longleftrightarrow> \\<oo> (Language s)\"\nbegin"], ["", "lemma this: \"DA alphabet init delta accept wellformed Language wf Lang\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DA alphabet init delta accept wellformed Language wf Lang", "by unfold_locales"], ["", "lemma wellformed_deltas:\n  \"\\<lbrakk>wellformed s; w \\<in> lists (set alphabet)\\<rbrakk> \\<Longrightarrow> wellformed (fold delta w s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed s; w \\<in> lists (set alphabet)\\<rbrakk>\n    \\<Longrightarrow> wellformed (fold delta w s)", "by (induction w arbitrary: s) (auto simp add: Language_delta wellformed_delta)"], ["", "lemma Language_deltas:\n  \"\\<lbrakk>wellformed s; w \\<in> lists (set alphabet)\\<rbrakk> \\<Longrightarrow> Language (fold delta w s) = \\<dd>s w (Language s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed s; w \\<in> lists (set alphabet)\\<rbrakk>\n    \\<Longrightarrow> Language (fold delta w s) = \\<dd>s w (Language s)", "by (induction w arbitrary: s) (auto simp add: Language_delta wellformed_delta)"], ["", "text\\<open>Auxiliary functions:\\<close>"], ["", "definition reachable :: \"'a list \\<Rightarrow> 's \\<Rightarrow> 's set\" where\n  \"reachable as s = snd (the (rtrancl_while (\\<lambda>_. True) (\\<lambda>s. map (\\<lambda>a. delta a s) as) s))\""], ["", "definition automaton :: \"'a list \\<Rightarrow> 's \\<Rightarrow> (('s * 'a) * 's) set\" where\n  \"automaton as s =\n    snd (the\n    (let start = (([s], {s}), {});\n         test = \\<lambda>((ws, Z), A). ws \\<noteq> [];\n         step = \\<lambda>((ws, Z), A).\n           (let s = hd ws;\n                new_edges = map (\\<lambda>a. ((s, a), delta a s)) as;\n                new = remdups (filter (\\<lambda>ss. ss \\<notin> Z) (map snd new_edges))\n           in ((new @ tl ws, set new \\<union> Z), set new_edges \\<union> A))\n    in while_option test step start))\""], ["", "definition match :: \"'s \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  \"match s w = accept (fold delta w s)\""], ["", "lemma match_correct:\n  assumes \"wellformed s\" \"w \\<in> lists (set alphabet)\"\n  shows \"match s w \\<longleftrightarrow> in_language (Language s) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match s w = in_language (Language s) w", "unfolding match_def accept_Language[OF wellformed_deltas[OF assms]] Language_deltas[OF assms] \\<oo>_\\<dd>s"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_language (Language s) w = in_language (Language s) w", ".."], ["", "end"], ["", "locale DAs =\n  M: DA alphabet1 init1 delta1 accept1 wellformed1 Language1 wf1 Lang1 +\n  N: DA alphabet2 init2 delta2 accept2 wellformed2 Language2 wf2 Lang2\n  for alphabet1 :: \"'a1 list\" and init1 :: \"'t1 \\<Rightarrow> 's1\" and delta1 accept1 wellformed1 Language1 wf1 Lang1\n  and alphabet2 :: \"'a2 list\" and init2 :: \"'t2 \\<Rightarrow> 's2\" and delta2 accept2 wellformed2 Language2 wf2 Lang2 +\n  fixes letter_eq :: \"'a1 \\<Rightarrow> 'a2 \\<Rightarrow> bool\"\n  assumes letter_eq: \"\\<And>a b. letter_eq a b \\<Longrightarrow> a \\<in> set alphabet1 \\<longleftrightarrow> b \\<in> set alphabet2\"\nbegin"], ["", "abbreviation step where\n  \"step \\<equiv> (\\<lambda>(p, q). map (\\<lambda>(a, b). (delta1 a p, delta2 b q))\n    (filter (case_prod letter_eq) (List.product alphabet1 alphabet2)))\""], ["", "abbreviation closure :: \"'s1 * 's2 \\<Rightarrow> (('s1 * 's2) list * ('s1 * 's2) set) option\" where\n  \"closure \\<equiv> rtrancl_while (\\<lambda>(p, q). accept1 p = accept2 q) step\""], ["", "theorem closure_sound_complete:\nassumes wf: \"wf1 r\" \"wf2 s\"\nand result: \"closure (init1 r, init2 s) = Some (ws, R)\" (is \"closure (?r, ?s) = _\")\nshows \"ws = [] \\<longleftrightarrow> rel_language letter_eq (Lang1 r) (Lang2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "from wf"], ["proof (chain)\npicking this:\n  wf1 r\n  wf2 s", "have wellformed: \"wellformed1 ?r\" \"wellformed2 ?s\""], ["proof (prove)\nusing this:\n  wf1 r\n  wf2 s\n\ngoal (1 subgoal):\n 1. wellformed1 (init1 r) &&& wellformed2 (init2 s)", "using M.wellformed_init N.wellformed_init"], ["proof (prove)\nusing this:\n  wf1 r\n  wf2 s\n  wf1 ?t \\<Longrightarrow> wellformed1 (init1 ?t)\n  wf2 ?t \\<Longrightarrow> wellformed2 (init2 ?t)\n\ngoal (1 subgoal):\n 1. wellformed1 (init1 r) &&& wellformed2 (init2 s)", "by blast+"], ["proof (state)\nthis:\n  wellformed1 (init1 r)\n  wellformed2 (init2 s)\n\ngoal (1 subgoal):\n 1. (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "note Language_alphabets[simp] =\n    M.Language_alphabet[OF wellformed(1)] N.Language_alphabet[OF wellformed(2)]"], ["proof (state)\nthis:\n  in_language (Language1 (init1 r)) ?w \\<Longrightarrow>\n  ?w \\<in> lists (set alphabet1)\n  in_language (Language2 (init2 s)) ?w \\<Longrightarrow>\n  ?w \\<in> lists (set alphabet2)\n\ngoal (1 subgoal):\n 1. (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "note Language_deltass = M.Language_deltas[OF wellformed(1)] N.Language_deltas[OF wellformed(2)]"], ["proof (state)\nthis:\n  ?w \\<in> lists (set alphabet1) \\<Longrightarrow>\n  Language1 (fold delta1 ?w (init1 r)) = \\<dd>s ?w (Language1 (init1 r))\n  ?w \\<in> lists (set alphabet2) \\<Longrightarrow>\n  Language2 (fold delta2 ?w (init2 s)) = \\<dd>s ?w (Language2 (init2 s))\n\ngoal (1 subgoal):\n 1. (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "have bisim: \"rel_language letter_eq (Language1 ?r) (Language2 ?s) =\n    (\\<forall>a b. (\\<exists>w1 w2. a = \\<dd>s w1 (Language1 ?r) \\<and> b = \\<dd>s w2 (Language2 ?s) \\<and>\n      w1 \\<in> lists (set alphabet1) \\<and> w2 \\<in> lists (set alphabet2) \\<and> list_all2 letter_eq w1 w2) \\<longrightarrow>\n    \\<oo> a = \\<oo> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_language letter_eq (Language1 (init1 r)) (Language2 (init2 s)) =\n    (\\<forall>a b.\n        (\\<exists>w1 w2.\n            a = \\<dd>s w1 (Language1 (init1 r)) \\<and>\n            b = \\<dd>s w2 (Language2 (init2 s)) \\<and>\n            w1 \\<in> lists (set alphabet1) \\<and>\n            w2 \\<in> lists (set alphabet2) \\<and>\n            list_all2 letter_eq w1 w2) \\<longrightarrow>\n        \\<oo> a = \\<oo> b)", "by (subst lang_eq_ext_Nil_fold_Deriv) (auto dest: letter_eq)"], ["proof (state)\nthis:\n  rel_language letter_eq (Language1 (init1 r)) (Language2 (init2 s)) =\n  (\\<forall>a b.\n      (\\<exists>w1 w2.\n          a = \\<dd>s w1 (Language1 (init1 r)) \\<and>\n          b = \\<dd>s w2 (Language2 (init2 s)) \\<and>\n          w1 \\<in> lists (set alphabet1) \\<and>\n          w2 \\<in> lists (set alphabet2) \\<and>\n          list_all2 letter_eq w1 w2) \\<longrightarrow>\n      \\<oo> a = \\<oo> b)\n\ngoal (1 subgoal):\n 1. (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "have leq: \"rel_language letter_eq (Language1 ?r) (Language2 ?s) =\n  (\\<forall>(r', s') \\<in> {((r, s), (delta1 a r, delta2 b s)) | a b r s.\n    a \\<in> set alphabet1 \\<and> b \\<in> set alphabet2 \\<and> letter_eq a b}^* `` {(?r, ?s)}.\n    accept1 r' = accept2 s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_language letter_eq (Language1 (init1 r)) (Language2 (init2 s)) =\n    (\\<forall>(r', s')\n              \\<in>{((r, s), delta1 a r, delta2 b s) |a b r s.\n                    a \\<in> set alphabet1 \\<and>\n                    b \\<in> set alphabet2 \\<and> letter_eq a b}\\<^sup>* ``\n                   {(init1 r, init2 s)}.\n        accept1 r' = accept2 s')", "using Language_deltass\n      M.accept_Language[OF M.wellformed_deltas[OF wellformed(1)]]\n      N.accept_Language[OF N.wellformed_deltas[OF wellformed(2)]]"], ["proof (prove)\nusing this:\n  ?w \\<in> lists (set alphabet1) \\<Longrightarrow>\n  Language1 (fold delta1 ?w (init1 r)) = \\<dd>s ?w (Language1 (init1 r))\n  ?w \\<in> lists (set alphabet2) \\<Longrightarrow>\n  Language2 (fold delta2 ?w (init2 s)) = \\<dd>s ?w (Language2 (init2 s))\n  ?w1 \\<in> lists (set alphabet1) \\<Longrightarrow>\n  accept1 (fold delta1 ?w1 (init1 r)) =\n  \\<oo> (Language1 (fold delta1 ?w1 (init1 r)))\n  ?w1 \\<in> lists (set alphabet2) \\<Longrightarrow>\n  accept2 (fold delta2 ?w1 (init2 s)) =\n  \\<oo> (Language2 (fold delta2 ?w1 (init2 s)))\n\ngoal (1 subgoal):\n 1. rel_language letter_eq (Language1 (init1 r)) (Language2 (init2 s)) =\n    (\\<forall>(r', s')\n              \\<in>{((r, s), delta1 a r, delta2 b s) |a b r s.\n                    a \\<in> set alphabet1 \\<and>\n                    b \\<in> set alphabet2 \\<and> letter_eq a b}\\<^sup>* ``\n                   {(init1 r, init2 s)}.\n        accept1 r' = accept2 s')", "unfolding rtrancl_fold_product in_lists_conv_set bisim"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ?w. x \\<in> set alphabet1 \\<Longrightarrow>\n  Language1 (fold delta1 ?w (init1 r)) = \\<dd>s ?w (Language1 (init1 r))\n  \\<forall>x\\<in>set ?w. x \\<in> set alphabet2 \\<Longrightarrow>\n  Language2 (fold delta2 ?w (init2 s)) = \\<dd>s ?w (Language2 (init2 s))\n  \\<forall>x\\<in>set ?w1. x \\<in> set alphabet1 \\<Longrightarrow>\n  accept1 (fold delta1 ?w1 (init1 r)) =\n  \\<oo> (Language1 (fold delta1 ?w1 (init1 r)))\n  \\<forall>x\\<in>set ?w1. x \\<in> set alphabet2 \\<Longrightarrow>\n  accept2 (fold delta2 ?w1 (init2 s)) =\n  \\<oo> (Language2 (fold delta2 ?w1 (init2 s)))\n\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        (\\<exists>w1 w2.\n            a = \\<dd>s w1 (Language1 (init1 r)) \\<and>\n            b = \\<dd>s w2 (Language2 (init2 s)) \\<and>\n            (\\<forall>x\\<in>set w1. x \\<in> set alphabet1) \\<and>\n            (\\<forall>x\\<in>set w2. x \\<in> set alphabet2) \\<and>\n            list_all2 letter_eq w1 w2) \\<longrightarrow>\n        \\<oo> a = \\<oo> b) =\n    (\\<forall>(r', s')\n              \\<in>{((r, s), fold delta1 w1 r, fold delta2 w2 s) |w1 w2 r s.\n                    (\\<forall>x\\<in>set w1. x \\<in> set alphabet1) \\<and>\n                    (\\<forall>x\\<in>set w2. x \\<in> set alphabet2) \\<and>\n                    list_all2 letter_eq w1 w2} ``\n                   {(init1 r, init2 s)}.\n        accept1 r' = accept2 s')", "by (auto 10 0)"], ["proof (state)\nthis:\n  rel_language letter_eq (Language1 (init1 r)) (Language2 (init2 s)) =\n  (\\<forall>(r', s')\n            \\<in>{((r, s), delta1 a r, delta2 b s) |a b r s.\n                  a \\<in> set alphabet1 \\<and>\n                  b \\<in> set alphabet2 \\<and> letter_eq a b}\\<^sup>* ``\n                 {(init1 r, init2 s)}.\n      accept1 r' = accept2 s')\n\ngoal (1 subgoal):\n 1. (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "have \"{(x,y). y \\<in> set (step x)} =\n    {((r, s), (delta1 a r, delta2 b s)) | a b r s. a \\<in> set alphabet1 \\<and> b \\<in> set alphabet2 \\<and> letter_eq a b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). y \\<in> set (step x)} =\n    {((r, s), delta1 a r, delta2 b s) |a b r s.\n     a \\<in> set alphabet1 \\<and>\n     b \\<in> set alphabet2 \\<and> letter_eq a b}", "by auto"], ["proof (state)\nthis:\n  {(x, y). y \\<in> set (step x)} =\n  {((r, s), delta1 a r, delta2 b s) |a b r s.\n   a \\<in> set alphabet1 \\<and> b \\<in> set alphabet2 \\<and> letter_eq a b}\n\ngoal (1 subgoal):\n 1. (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "with rtrancl_while_Some[OF result]"], ["proof (chain)\npicking this:\n  if ws = []\n  then R =\n       {(x, y). y \\<in> set (step x)}\\<^sup>* `` {(init1 r, init2 s)} \\<and>\n       (\\<forall>z\\<in>R.\n           case z of (p, q) \\<Rightarrow> accept1 p = accept2 q)\n  else \\<not> (case hd ws of\n               (p, q) \\<Rightarrow> accept1 p = accept2 q) \\<and>\n       hd ws\n       \\<in> {(x, y). y \\<in> set (step x)}\\<^sup>* `` {(init1 r, init2 s)}\n  {(x, y). y \\<in> set (step x)} =\n  {((r, s), delta1 a r, delta2 b s) |a b r s.\n   a \\<in> set alphabet1 \\<and> b \\<in> set alphabet2 \\<and> letter_eq a b}", "have \"(ws = []) = rel_language letter_eq (Language1 ?r) (Language2 ?s)\""], ["proof (prove)\nusing this:\n  if ws = []\n  then R =\n       {(x, y). y \\<in> set (step x)}\\<^sup>* `` {(init1 r, init2 s)} \\<and>\n       (\\<forall>z\\<in>R.\n           case z of (p, q) \\<Rightarrow> accept1 p = accept2 q)\n  else \\<not> (case hd ws of\n               (p, q) \\<Rightarrow> accept1 p = accept2 q) \\<and>\n       hd ws\n       \\<in> {(x, y). y \\<in> set (step x)}\\<^sup>* `` {(init1 r, init2 s)}\n  {(x, y). y \\<in> set (step x)} =\n  {((r, s), delta1 a r, delta2 b s) |a b r s.\n   a \\<in> set alphabet1 \\<and> b \\<in> set alphabet2 \\<and> letter_eq a b}\n\ngoal (1 subgoal):\n 1. (ws = []) =\n    rel_language letter_eq (Language1 (init1 r)) (Language2 (init2 s))", "by (auto simp add: leq Ball_def split: if_splits)"], ["proof (state)\nthis:\n  (ws = []) =\n  rel_language letter_eq (Language1 (init1 r)) (Language2 (init2 s))\n\ngoal (1 subgoal):\n 1. (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "then"], ["proof (chain)\npicking this:\n  (ws = []) =\n  rel_language letter_eq (Language1 (init1 r)) (Language2 (init2 s))", "show ?thesis"], ["proof (prove)\nusing this:\n  (ws = []) =\n  rel_language letter_eq (Language1 (init1 r)) (Language2 (init2 s))\n\ngoal (1 subgoal):\n 1. (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "unfolding M.Language_init[OF wf(1)] N.Language_init[OF wf(2)]"], ["proof (prove)\nusing this:\n  (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)\n\ngoal (1 subgoal):\n 1. (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "."], ["proof (state)\nthis:\n  (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The overall procedure\\<close>"], ["", "definition check_eqv :: \"'t1 \\<Rightarrow> 't2 \\<Rightarrow> bool\" where\n\"check_eqv r s = (wf1 r \\<and> wf2 s \\<and> (case closure (init1 r, init2 s) of Some([], _) \\<Rightarrow> True | _ \\<Rightarrow> False))\""], ["", "lemma soundness: \nassumes \"check_eqv r s\" shows \"rel_language letter_eq (Lang1 r) (Lang2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_language letter_eq (Lang1 r) (Lang2 s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_language letter_eq (Lang1 r) (Lang2 s)", "obtain R where \"wf1 r\" \"wf2 s\" \"closure (init1 r, init2 s) = Some([], R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf1 r; wf2 s;\n         closure (init1 r, init2 s) = Some ([], R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  check_eqv r s\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf1 r; wf2 s;\n         closure (init1 r, init2 s) = Some ([], R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: check_eqv_def Let_def split: option.splits list.splits)"], ["proof (state)\nthis:\n  wf1 r\n  wf2 s\n  closure (init1 r, init2 s) = Some ([], R)\n\ngoal (1 subgoal):\n 1. rel_language letter_eq (Lang1 r) (Lang2 s)", "from closure_sound_complete[OF this]"], ["proof (chain)\npicking this:\n  ([] = []) = rel_language letter_eq (Lang1 r) (Lang2 s)", "show \"rel_language letter_eq (Lang1 r) (Lang2 s)\""], ["proof (prove)\nusing this:\n  ([] = []) = rel_language letter_eq (Lang1 r) (Lang2 s)\n\ngoal (1 subgoal):\n 1. rel_language letter_eq (Lang1 r) (Lang2 s)", "by simp"], ["proof (state)\nthis:\n  rel_language letter_eq (Lang1 r) (Lang2 s)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* completeness needs termination of closure, otherwise result could be None *)"], ["", "end"], ["", "subsection \\<open>Abstract Deterministic Finite Automaton\\<close>"], ["", "locale DFA = DA +\nassumes fin: \"wellformed s \\<Longrightarrow> finite {fold delta w s | w. w \\<in> lists (set alphabet)}\"\nbegin"], ["", "lemma finite_rtrancl_delta_Image1:\n  \"wellformed r \\<Longrightarrow> finite ({(r, s). \\<exists>a \\<in> set alphabet. s = delta a r}^* `` {r})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed r \\<Longrightarrow>\n    finite\n     ({(r, s). \\<exists>a\\<in>set alphabet. s = delta a r}\\<^sup>* `` {r})", "unfolding rtrancl_fold_product1"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed r \\<Longrightarrow>\n    finite\n     ({(r, s). \\<exists>a\\<in>lists (set alphabet). s = fold delta a r} ``\n      {r})", "by (auto intro: finite_subset[OF _ fin])"], ["", "lemma\n  assumes \"wellformed r\" \"set as \\<subseteq> set alphabet\"\n  shows reachable: \"reachable as r = {fold delta w r | w. w \\<in> lists (set as)}\"\n  and finite_reachable: \"finite (reachable as r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable as r = {fold delta w r |w. w \\<in> lists (set as)} &&&\n    finite (reachable as r)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. reachable as r = {fold delta w r |w. w \\<in> lists (set as)}\n 2. finite (reachable as r)", "obtain wsZ where *: \"rtrancl_while (\\<lambda>_. True) (\\<lambda>s. map (\\<lambda>a. delta a s) as) r = Some wsZ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>wsZ.\n        rtrancl_while (\\<lambda>_. True)\n         (\\<lambda>s. map (\\<lambda>a. delta a s) as) r =\n        Some wsZ \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  wellformed r\n  set as \\<subseteq> set alphabet\n\ngoal (1 subgoal):\n 1. (\\<And>wsZ.\n        rtrancl_while (\\<lambda>_. True)\n         (\\<lambda>s. map (\\<lambda>a. delta a s) as) r =\n        Some wsZ \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim, intro rtrancl_while_finite_Some Image_mono rtrancl_mono\n      finite_subset[OF _ finite_rtrancl_delta_Image1[of r]]) auto"], ["proof (state)\nthis:\n  rtrancl_while (\\<lambda>_. True)\n   (\\<lambda>s. map (\\<lambda>a. delta a s) as) r =\n  Some wsZ\n\ngoal (2 subgoals):\n 1. reachable as r = {fold delta w r |w. w \\<in> lists (set as)}\n 2. finite (reachable as r)", "then"], ["proof (chain)\npicking this:\n  rtrancl_while (\\<lambda>_. True)\n   (\\<lambda>s. map (\\<lambda>a. delta a s) as) r =\n  Some wsZ", "show \"reachable as r = {fold delta w r | w. w \\<in> lists (set as)}\""], ["proof (prove)\nusing this:\n  rtrancl_while (\\<lambda>_. True)\n   (\\<lambda>s. map (\\<lambda>a. delta a s) as) r =\n  Some wsZ\n\ngoal (1 subgoal):\n 1. reachable as r = {fold delta w r |w. w \\<in> lists (set as)}", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  rtrancl_while (\\<lambda>_. True)\n   (\\<lambda>s. map (\\<lambda>a. delta a s) as) r =\n  Some wsZ\n\ngoal (1 subgoal):\n 1. snd (the (rtrancl_while (\\<lambda>_. True)\n               (\\<lambda>s. map (\\<lambda>a. delta a s) as) r)) =\n    {fold delta w r |w. w \\<in> lists (set as)}", "by (cases wsZ)\n      (auto dest!: rtrancl_while_Some split: if_splits simp: rtrancl_fold_product1 image_iff)"], ["proof (state)\nthis:\n  reachable as r = {fold delta w r |w. w \\<in> lists (set as)}\n\ngoal (1 subgoal):\n 1. finite (reachable as r)", "then"], ["proof (chain)\npicking this:\n  reachable as r = {fold delta w r |w. w \\<in> lists (set as)}", "show \"finite (reachable as r)\""], ["proof (prove)\nusing this:\n  reachable as r = {fold delta w r |w. w \\<in> lists (set as)}\n\ngoal (1 subgoal):\n 1. finite (reachable as r)", "using assms"], ["proof (prove)\nusing this:\n  reachable as r = {fold delta w r |w. w \\<in> lists (set as)}\n  wellformed r\n  set as \\<subseteq> set alphabet\n\ngoal (1 subgoal):\n 1. finite (reachable as r)", "by (force intro: finite_subset[OF _ fin])"], ["proof (state)\nthis:\n  finite (reachable as r)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale DFAs =\n  M: DFA alphabet1 init1 delta1 accept1 wellformed1 Language1 wf1 Lang1 +\n  N: DFA alphabet2 init2 delta2 accept2 wellformed2 Language2 wf2 Lang2\n  for alphabet1 :: \"'a1 list\" and init1 :: \"'t1 \\<Rightarrow> 's1\" and delta1 accept1 wellformed1 Language1 wf1 Lang1\n  and alphabet2 :: \"'a2 list\" and init2 :: \"'t2 \\<Rightarrow> 's2\" and delta2 accept2 wellformed2 Language2 wf2 Lang2 +\n  fixes letter_eq :: \"'a1 \\<Rightarrow> 'a2 \\<Rightarrow> bool\"\n  assumes letter_eq: \"\\<And>a b. letter_eq a b \\<Longrightarrow> a \\<in> set alphabet1 \\<longleftrightarrow> b \\<in> set alphabet2\"\nbegin"], ["", "interpretation DAs"], ["proof (prove)\ngoal (1 subgoal):\n 1. DAs alphabet1 init1 delta1 accept1 wellformed1 Language1 wf1 Lang1\n     alphabet2 init2 delta2 accept2 wellformed2 Language2 wf2 Lang2\n     letter_eq", "by unfold_locales (auto dest: letter_eq)"], ["", "lemma finite_rtrancl_delta_Image:\n  \"\\<lbrakk>wellformed1 r; wellformed2 s\\<rbrakk> \\<Longrightarrow>\n  finite ({((r, s), (delta1 a r, delta2 b s))| a b r s.\n    a \\<in> set alphabet1 \\<and> b \\<in> set alphabet2 \\<and> R a b}^* `` {(r, s)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed1 r; wellformed2 s\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ({((r, s), delta1 a r, delta2 b s) |a b r s.\n                         a \\<in> set alphabet1 \\<and>\n                         b \\<in> set alphabet2 \\<and> R a b}\\<^sup>* ``\n                        {(r, s)})", "unfolding rtrancl_fold_product Image_singleton"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wellformed1 r; wellformed2 s\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {b. ((r, s), b)\n                           \\<in> {((r, s), fold delta1 w1 r,\n                                   fold delta2 w2 s) |\n                                  w1 w2 r s.\n                                  w1 \\<in> lists (set alphabet1) \\<and>\n                                  w2 \\<in> lists (set alphabet2) \\<and>\n                                  list_all2 R w1 w2}}", "by (auto intro: finite_subset[OF _ finite_cartesian_product[OF M.fin N.fin]])"], ["", "lemma \"termination\":\n  assumes \"wellformed1 r\" \"wellformed2 s\"\n  shows \"\\<exists>st. closure (r, s) = Some st\" (is \"\\<exists>_. closure  ?i = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>st. closure (r, s) = Some st", "proof (rule rtrancl_while_finite_Some)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite ({(x, st). st \\<in> set (step x)}\\<^sup>* `` {(r, s)})", "show \"finite ({(x, st). st \\<in> set (step x)}\\<^sup>* `` {?i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({(x, st). st \\<in> set (step x)}\\<^sup>* `` {(r, s)})", "by (rule finite_subset[OF Image_mono[OF rtrancl_mono]\n      finite_rtrancl_delta_Image[OF assms, of letter_eq]]) auto"], ["proof (state)\nthis:\n  finite ({(x, st). st \\<in> set (step x)}\\<^sup>* `` {(r, s)})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma completeness: \nassumes \"wf1 r\" \"wf2 s\" \"rel_language letter_eq (Lang1 r) (Lang2 s)\" shows \"check_eqv r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_eqv r s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. check_eqv r s", "obtain ws R where 1: \"closure (init1 r, init2 s) = Some (ws, R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ws R.\n        closure (init1 r, init2 s) = Some (ws, R) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \"termination\"\n    M.wellformed_init N.wellformed_init assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellformed1 ?r; wellformed2 ?s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>st. closure (?r, ?s) = Some st\n  wf1 ?t \\<Longrightarrow> wellformed1 (init1 ?t)\n  wf2 ?t \\<Longrightarrow> wellformed2 (init2 ?t)\n  wf1 r\n  wf2 s\n  rel_language letter_eq (Lang1 r) (Lang2 s)\n\ngoal (1 subgoal):\n 1. (\\<And>ws R.\n        closure (init1 r, init2 s) = Some (ws, R) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  closure (init1 r, init2 s) = Some (ws, R)\n\ngoal (1 subgoal):\n 1. check_eqv r s", "with closure_sound_complete[OF _ _ this] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf1 r; wf2 s\\<rbrakk>\n  \\<Longrightarrow> (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)\n  wf1 r\n  wf2 s\n  rel_language letter_eq (Lang1 r) (Lang2 s)\n  closure (init1 r, init2 s) = Some (ws, R)", "show \"check_eqv r s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf1 r; wf2 s\\<rbrakk>\n  \\<Longrightarrow> (ws = []) = rel_language letter_eq (Lang1 r) (Lang2 s)\n  wf1 r\n  wf2 s\n  rel_language letter_eq (Lang1 r) (Lang2 s)\n  closure (init1 r, init2 s) = Some (ws, R)\n\ngoal (1 subgoal):\n 1. check_eqv r s", "by (simp add: check_eqv_def)"], ["proof (state)\nthis:\n  check_eqv r s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale DA < DAs\n  alphabet init delta accept wellformed Language wf Lang\n  alphabet init delta accept wellformed Language wf Lang \"(=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DAs alphabet init delta accept wellformed Language wf Lang alphabet init\n     delta accept wellformed Language wf Lang (=)", "by unfold_locales auto"], ["", "sublocale DFA < DFAs\n  alphabet init delta accept wellformed Language wf Lang\n  alphabet init delta accept wellformed Language wf Lang \"(=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DFAs alphabet init delta accept wellformed Language wf Lang alphabet\n     init delta accept wellformed Language wf Lang (=)", "by unfold_locales auto"], ["", "lemma (in DA) step_alt: \"step = (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) alphabet)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) alphabet)", "using distinct_alphabet"], ["proof (prove)\nusing this:\n  distinct alphabet\n\ngoal (1 subgoal):\n 1. step =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) alphabet)", "proof (induct alphabet)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct xs \\<Longrightarrow>\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow>\n        map (\\<lambda>a.\n                case a of (a, b) \\<Rightarrow> (delta a p, delta b q))\n         (filter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a = b)\n           (List.product xs xs))) =\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow> map (\\<lambda>a. (delta a p, delta a q)) xs)\n  distinct (x # xs)\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "moreover"], ["proof (state)\nthis:\n  distinct xs \\<Longrightarrow>\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow>\n        map (\\<lambda>a.\n                case a of (a, b) \\<Rightarrow> (delta a p, delta b q))\n         (filter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a = b)\n           (List.product xs xs))) =\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow> map (\\<lambda>a. (delta a p, delta a q)) xs)\n  distinct (x # xs)\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "{"], ["proof (state)\nthis:\n  distinct xs \\<Longrightarrow>\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow>\n        map (\\<lambda>a.\n                case a of (a, b) \\<Rightarrow> (delta a p, delta b q))\n         (filter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a = b)\n           (List.product xs xs))) =\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow> map (\\<lambda>a. (delta a p, delta a q)) xs)\n  distinct (x # xs)\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "fix x :: 'a and xs ys :: \"'a list\""], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "assume \"x \\<notin> set xs\""], ["proof (state)\nthis:\n  x \\<notin> set xs\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "then"], ["proof (chain)\npicking this:\n  x \\<notin> set xs", "have \"[(x, y)\\<leftarrow>List.product xs (x # ys) . x = y] = [(x, y)\\<leftarrow>List.product xs ys . x = y]\""], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>(x, y). x = y) (List.product xs (x # ys)) =\n    filter (\\<lambda>(x, y). x = y) (List.product xs ys)", "by (induct xs arbitrary: x) auto"], ["proof (state)\nthis:\n  filter (\\<lambda>(x, y). x = y) (List.product xs (x # ys)) =\n  filter (\\<lambda>(x, y). x = y) (List.product xs ys)\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "}"], ["proof (state)\nthis:\n  ?xa2 \\<notin> set ?xsa2 \\<Longrightarrow>\n  filter (\\<lambda>(x, y). x = y) (List.product ?xsa2 (?xa2 # ?ys2)) =\n  filter (\\<lambda>(x, y). x = y) (List.product ?xsa2 ?ys2)\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "moreover"], ["proof (state)\nthis:\n  ?xa2 \\<notin> set ?xsa2 \\<Longrightarrow>\n  filter (\\<lambda>(x, y). x = y) (List.product ?xsa2 (?xa2 # ?ys2)) =\n  filter (\\<lambda>(x, y). x = y) (List.product ?xsa2 ?ys2)\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "{"], ["proof (state)\nthis:\n  ?xa2 \\<notin> set ?xsa2 \\<Longrightarrow>\n  filter (\\<lambda>(x, y). x = y) (List.product ?xsa2 (?xa2 # ?ys2)) =\n  filter (\\<lambda>(x, y). x = y) (List.product ?xsa2 ?ys2)\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "fix x :: 'a and xs :: \"'a list\""], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "assume \"x \\<notin> set xs\""], ["proof (state)\nthis:\n  x \\<notin> set xs\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "then"], ["proof (chain)\npicking this:\n  x \\<notin> set xs", "have \"[(x, y)\\<leftarrow>map (Pair x) xs . x = y] = []\""], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>(x, y). x = y) (map (Pair x) xs) = []", "by (induct xs) auto"], ["proof (state)\nthis:\n  filter (\\<lambda>(x, y). x = y) (map (Pair x) xs) = []\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "}"], ["proof (state)\nthis:\n  ?xa2 \\<notin> set ?xsa2 \\<Longrightarrow>\n  filter (\\<lambda>(x, y). x = y) (map (Pair ?xa2) ?xsa2) = []\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])\n 2. \\<And>a alphabet.\n       \\<lbrakk>distinct alphabet \\<Longrightarrow>\n                (\\<lambda>(p, q).\n                    map (\\<lambda>(a, b). (delta a p, delta b q))\n                     (filter (\\<lambda>(x, y). x = y)\n                       (List.product alphabet alphabet))) =\n                (\\<lambda>(p, q).\n                    map (\\<lambda>a. (delta a p, delta a q)) alphabet);\n        distinct (a # alphabet)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(p, q).\n                             map (\\<lambda>(a, b). (delta a p, delta b q))\n                              (filter (\\<lambda>(x, y). x = y)\n                                (List.product (a # alphabet)\n                                  (a # alphabet)))) =\n                         (\\<lambda>(p, q).\n                             map (\\<lambda>a. (delta a p, delta a q))\n                              (a # alphabet))", "ultimately"], ["proof (chain)\npicking this:\n  distinct xs \\<Longrightarrow>\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow>\n        map (\\<lambda>a.\n                case a of (a, b) \\<Rightarrow> (delta a p, delta b q))\n         (filter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a = b)\n           (List.product xs xs))) =\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow> map (\\<lambda>a. (delta a p, delta a q)) xs)\n  distinct (x # xs)\n  ?xa2 \\<notin> set ?xsa2 \\<Longrightarrow>\n  filter (\\<lambda>(x, y). x = y) (List.product ?xsa2 (?xa2 # ?ys2)) =\n  filter (\\<lambda>(x, y). x = y) (List.product ?xsa2 ?ys2)\n  ?xa2 \\<notin> set ?xsa2 \\<Longrightarrow>\n  filter (\\<lambda>(x, y). x = y) (map (Pair ?xa2) ?xsa2) = []", "show ?case"], ["proof (prove)\nusing this:\n  distinct xs \\<Longrightarrow>\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow>\n        map (\\<lambda>a.\n                case a of (a, b) \\<Rightarrow> (delta a p, delta b q))\n         (filter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a = b)\n           (List.product xs xs))) =\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow> map (\\<lambda>a. (delta a p, delta a q)) xs)\n  distinct (x # xs)\n  ?xa2 \\<notin> set ?xsa2 \\<Longrightarrow>\n  filter (\\<lambda>(x, y). x = y) (List.product ?xsa2 (?xa2 # ?ys2)) =\n  filter (\\<lambda>(x, y). x = y) (List.product ?xsa2 ?ys2)\n  ?xa2 \\<notin> set ?xsa2 \\<Longrightarrow>\n  filter (\\<lambda>(x, y). x = y) (map (Pair ?xa2) ?xsa2) = []\n\ngoal (1 subgoal):\n 1. (\\<lambda>a.\n        case a of\n        (p, q) \\<Rightarrow>\n          map (\\<lambda>a.\n                  case a of (a, b) \\<Rightarrow> (delta a p, delta b q))\n           (filter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a = b)\n             (List.product (x # xs) (x # xs)))) =\n    (\\<lambda>a.\n        case a of\n        (p, q) \\<Rightarrow>\n          map (\\<lambda>a. (delta a p, delta a q)) (x # xs))", "by (auto simp: fun_eq_iff)"], ["proof (state)\nthis:\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow>\n        map (\\<lambda>a.\n                case a of (a, b) \\<Rightarrow> (delta a p, delta b q))\n         (filter (\\<lambda>a. case a of (a, b) \\<Rightarrow> a = b)\n           (List.product (x # xs) (x # xs)))) =\n  (\\<lambda>a.\n      case a of\n      (p, q) \\<Rightarrow>\n        map (\\<lambda>a. (delta a p, delta a q)) (x # xs))\n\ngoal (1 subgoal):\n 1. distinct [] \\<Longrightarrow>\n    (\\<lambda>(p, q).\n        map (\\<lambda>(a, b). (delta a p, delta b q))\n         (filter (\\<lambda>(x, y). x = y) (List.product [] []))) =\n    (\\<lambda>(p, q). map (\\<lambda>a. (delta a p, delta a q)) [])", "qed simp"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}