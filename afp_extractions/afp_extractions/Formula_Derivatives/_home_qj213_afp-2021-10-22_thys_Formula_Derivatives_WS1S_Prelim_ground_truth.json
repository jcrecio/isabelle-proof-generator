{"file_name": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives/WS1S_Prelim.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives", "problem_names": ["lemmas enum_defs = enum_order_def enum_all_order_def enum_ex_order_def", "lemma MSB_Nil[simp]: \"MSB [] = 0\"", "lemma MSB_Cons[simp]: \"MSB (I # Is) = max (if I = {||} then 0 else Suc (fMax I)) (MSB Is)\"", "lemma MSB_append[simp]: \"MSB (I1 @ I2) = max (MSB I1) (MSB I2)\"", "lemma MSB_insert_nth[simp]:\n  \"MSB (insert_nth n P Is) = max (if P = {||} then 0 else Suc (fMax P)) (MSB Is)\"", "lemma MSB_greater:\n  \"\\<lbrakk>i < length Is; p |\\<in>| Is ! i\\<rbrakk> \\<Longrightarrow> p < MSB Is\"", "lemma MSB_mono: \"set I1 \\<subseteq> set I2 \\<Longrightarrow> MSB I1 \\<le> MSB I2\"", "lemma MSB_map_index'_CONS[simp]:\n  \"MSB (map_index' i (lift bs) Is) =\n  (if MSB Is = 0 \\<and> (\\<forall>i \\<in> {i ..< i + length Is}. \\<not> bs ! i) then 0 else Suc (MSB Is))\"", "lemma MSB_map_index'_SNOC[simp]:\n  \"MSB Is \\<le> n \\<Longrightarrow> MSB (map_index' i (snoc n bs) Is) =\n  (if (\\<forall>i \\<in> {i ..< i + length Is}. \\<not> bs ! i) then MSB Is else Suc n)\"", "lemma MSB_replicate[simp]: \"MSB (replicate n P) = (if P = {||} \\<or> n = 0 then 0 else Suc (fMax P))\"", "lemma fMin_fimage_Suc[simp]: \"x |\\<in>| A \\<Longrightarrow> fMin (Suc |`| A) = Suc (fMin A)\"", "lemma fMin_eq_0[simp]: \"0 |\\<in>| A \\<Longrightarrow> fMin A = (0 :: nat)\"", "lemma insert_nth_Cons[simp]:\n  \"insert_nth i x (y # xs) = (case i of 0 \\<Rightarrow> x # y # xs | Suc i \\<Rightarrow> y # insert_nth i x xs)\"", "lemma insert_nth_commute[simp]:\n  assumes \"j \\<le> i\" \"i \\<le> length xs\"\n  shows \"insert_nth j y (insert_nth i x xs) = insert_nth (Suc i) x (insert_nth j y xs)\"", "lemma SUC_SUC[simp]: \"SUC ord (SUC ord' idx) = SUC ord' (SUC ord idx)\"", "lemma LESS_SUC[simp]:\n  \"LESS ord 0 (SUC ord idx)\"\n  \"LESS ord (Suc l) (SUC ord idx) = LESS ord l idx\"\n  \"ord \\<noteq> ord' \\<Longrightarrow> LESS ord l (SUC ord' idx) = LESS ord l idx\"\n  \"LESS ord l idx \\<Longrightarrow> LESS ord l (SUC ord' idx)\"", "lemma nvars_Extend[simp]:\n  \"#\\<^sub>V (Extend ord i \\<AA> P) = SUC ord (#\\<^sub>V \\<AA>)\"", "lemma Length_Extend[simp]:\n  \"Length (Extend k i \\<AA> P) = max (Length \\<AA>) (if P = {||} then 0 else Suc (fMax P))\"", "lemma assigns_Extend[simp]:\n  \"LEQ ord i (#\\<^sub>V \\<AA>) \\<Longrightarrow>m\\<^bsup>Extend ord i \\<AA> P\\<^esup>ord = (if m = i then P else (if m > i then m - Suc 0 else m)\\<^bsup>\\<AA>\\<^esup>ord)\"\n  \"ord \\<noteq> ord' \\<Longrightarrow> m\\<^bsup>Extend ord i \\<AA> P\\<^esup>ord' = m\\<^bsup>\\<AA>\\<^esup>ord'\"", "lemma Extend_commute_safe[simp]:\n  \"\\<lbrakk>j \\<le> i; LEQ ord i (#\\<^sub>V \\<AA>)\\<rbrakk> \\<Longrightarrow>\n    Extend ord j (Extend ord i \\<AA> P1) P2 = Extend ord (Suc i) (Extend ord j \\<AA> P2) P1\"", "lemma Extend_commute_unsafe:\n  \"ord \\<noteq> ord' \\<Longrightarrow> Extend ord j (Extend ord' i \\<AA> P1) P2 = Extend ord' i (Extend ord j \\<AA> P2) P1\"", "lemma Length_CONS[simp]:\n  \"Length (CONS x \\<AA>) = Suc (Length \\<AA>)\"", "lemma Length_SNOC[simp]:\n  \"Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\"", "lemma nvars_CONS[simp]:\n  \"#\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\"", "lemma nvars_SNOC[simp]:\n  \"#\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\"", "lemma assigns_CONS[simp]:\n  assumes \"#\\<^sub>V \\<AA> = size_atom bs1_bs2\"\n  shows \"LESS ord x (#\\<^sub>V \\<AA>) \\<Longrightarrow> x\\<^bsup>CONS bs1_bs2 \\<AA>\\<^esup>ord =\n    (if case_prod case_order bs1_bs2 ord ! x then finsert 0 (upshift (x\\<^bsup>\\<AA>\\<^esup>ord)) else upshift (x\\<^bsup>\\<AA>\\<^esup>ord))\"", "lemma assigns_SNOC[simp]:\n  assumes \"#\\<^sub>V \\<AA> = size_atom bs1_bs2\"\n  shows \"LESS ord x (#\\<^sub>V \\<AA>) \\<Longrightarrow> x\\<^bsup>SNOC bs1_bs2 \\<AA>\\<^esup>ord =\n    (if case_prod case_order bs1_bs2 ord ! x then finsert (Length \\<AA>) (x\\<^bsup>\\<AA>\\<^esup>ord) else x\\<^bsup>\\<AA>\\<^esup>ord)\"", "lemma map_index'_eq_conv[simp]:\n  \"map_index' i f xs = map_index' j g xs = (\\<forall>k < length xs. f (i + k) (xs ! k) = g (j + k) (xs ! k))\"", "lemma fMax_Diff_0[simp]: \"Suc m |\\<in>| P \\<Longrightarrow> fMax (P |-| {|0|}) = fMax P\"", "lemma Suc_fMax_pred_fimage[simp]:\n  assumes \"Suc p |\\<in>| P\" \"0 |\\<notin>| P\"\n  shows \"Suc (fMax ((\\<lambda>x. x - Suc 0) |`| P)) = fMax P\"", "lemma Extend_CONS[simp]: \"#\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow> Extend ord 0 (CONS x \\<AA>) P =\n  CONS (extend ord (eval P 0) x) (Extend ord 0 \\<AA> (downshift P))\"", "lemma size_atom_extend[simp]:\n  \"size_atom (extend ord b x) = SUC ord (size_atom x)\"", "lemma size_atom_zero[simp]:\n  \"size_atom (zero idx) = idx\"", "lemma interp_eqI:\n  \"\\<lbrakk>Length \\<AA> = Length \\<BB>; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>; \\<And>m k. LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow> m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk> \\<Longrightarrow> \\<AA> = \\<BB>\"", "lemma Extend_SNOC_cut[unfolded eval_def cut_def Length_SNOC, simp]:\n  \"\\<lbrakk>len P \\<le> Length (SNOC x \\<AA>); #\\<^sub>V \\<AA> = size_atom x\\<rbrakk> \\<Longrightarrow>\n  Extend ord 0 (SNOC x \\<AA>) P =\n    SNOC (extend ord (if eval P (Length \\<AA>) then True else False) x) (Extend ord 0 \\<AA> (cut (Length \\<AA>) P))\"", "lemma nth_replicate_simp: \"replicate m x ! i = (if i < m then x else [] ! (i - m))\"", "lemma MSB_eq_SucD: \"MSB Is = Suc x \\<Longrightarrow> \\<exists>P\\<in>set Is. x |\\<in>| P\"", "lemma append_replicate_inj:\n  assumes \"xs \\<noteq> [] \\<Longrightarrow> last xs \\<noteq> x\" and \"ys \\<noteq> [] \\<Longrightarrow> last ys \\<noteq> x\"\n  shows \"xs @ replicate m x = ys @ replicate n x \\<longleftrightarrow> (xs = ys \\<and> m = n)\"", "lemma fin_lift[simp]: \"m |\\<in>| lift bs i (I ! i) \\<longleftrightarrow> (case m of 0 \\<Rightarrow> bs ! i | Suc m \\<Rightarrow> m |\\<in>| I ! i)\"", "lemma ex_Length_0[simp]:\n  \"\\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\"", "lemma is_empty_inj[simp]: \"\\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk> \\<Longrightarrow> \\<AA> = \\<BB>\"", "lemma set_\\<sigma>_length_atom[simp]: \"(x \\<in> set (\\<sigma> idx)) \\<longleftrightarrow> idx = size_atom x\"", "lemma distinct_\\<sigma>[simp]: \"distinct (\\<sigma> idx)\"", "lemma fMin_less_Length[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> fMin (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\"", "lemma fMax_less_Length[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> fMax (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\"", "lemma min_Length_fMin[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> min (Length \\<AA>) (fMin (m1\\<^bsup>\\<AA>\\<^esup>k)) = fMin (m1\\<^bsup>\\<AA>\\<^esup>k)\"", "lemma max_Length_fMin[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> max (Length \\<AA>) (fMin (m1\\<^bsup>\\<AA>\\<^esup>k)) = Length \\<AA>\"", "lemma min_Length_fMax[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> min (Length \\<AA>) (fMax (m1\\<^bsup>\\<AA>\\<^esup>k)) = fMax (m1\\<^bsup>\\<AA>\\<^esup>k)\"", "lemma max_Length_fMax[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> max (Length \\<AA>) (fMax (m1\\<^bsup>\\<AA>\\<^esup>k)) = Length \\<AA>\"", "lemma assigns_less_Length[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> x < Length \\<AA>\"", "lemma Length_notin_assigns[simp]: \"Length \\<AA> |\\<notin>| m\\<^bsup>\\<AA>\\<^esup>k\"", "lemma nth_zero[simp]: \"LESS ord m (#\\<^sub>V \\<AA>) \\<Longrightarrow> \\<not> case_prod case_order (zero (#\\<^sub>V \\<AA>)) ord ! m\"", "lemma in_fimage_Suc[simp]: \"x |\\<in>| Suc |`| A \\<longleftrightarrow> (\\<exists>y. y |\\<in>| A \\<and> x = Suc y)\"", "lemma fimage_Suc_inj[simp]: \"Suc |`| A = Suc |`| B \\<longleftrightarrow> A = B\"", "lemma MSB_eq0_D: \"MSB I = 0 \\<Longrightarrow> x < length I \\<Longrightarrow> I ! x = {||}\"", "lemma Suc_in_fimage_Suc: \"Suc x |\\<in>| Suc |`| X \\<longleftrightarrow> x |\\<in>| X\"", "lemma Suc_in_fimage_Suc_o_Suc[simp]: \"Suc x |\\<in>| (Suc \\<circ> Suc) |`| X \\<longleftrightarrow> x |\\<in>| Suc |`| X\"", "lemma finsert_same_eq_iff[simp]: \"finsert k X = finsert k Y \\<longleftrightarrow> X |-| {|k|} = Y |-| {|k|}\"", "lemma fimage_Suc_o_Suc_eq_fimage_Suc_iff[simp]:\n  \"((Suc \\<circ> Suc) |`| X = Suc |`| Y) \\<longleftrightarrow> (Suc |`| X = Y)\"", "lemma fMax_image_Suc[simp]: \"x |\\<in>| P \\<Longrightarrow> fMax (Suc |`| P) = Suc (fMax P)\"", "lemma fimage_Suc_eq_singleton[simp]: \"(fimage Suc Z = {|y|}) \\<longleftrightarrow> (\\<exists>x. Z = {|x|} \\<and> Suc x = y)\"", "lemma len_downshift_helper:\n  \"x |\\<in>| P \\<Longrightarrow> Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P \\<Longrightarrow> xa |\\<in>| P \\<Longrightarrow> xa = 0\"", "lemma CONS_inj[simp]: \"size_atom x = #\\<^sub>V \\<AA> \\<Longrightarrow> size_atom y = #\\<^sub>V \\<AA> \\<Longrightarrow> #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB> \\<Longrightarrow>\n  CONS x \\<AA> = CONS y \\<BB> \\<longleftrightarrow> (x = y \\<and> \\<AA> = \\<BB>)\"", "lemma Suc_minus1: \"Suc (x - Suc 0) = (if x = 0 then Suc 0 else x)\"", "lemma fset_eq_empty_iff: \"(fset X = {}) = (X = {||})\"", "lemma fset_le_singleton_iff: \"(fset X \\<subseteq> {x}) = (X = {||} \\<or> X = {|x|})\"", "lemma MSB_decreases:\n  \"MSB I \\<le> Suc m \\<Longrightarrow> MSB (map (\\<lambda>X. (\\<lambda>I1. I1 - Suc 0) |`| (X |-| {|0|})) I) \\<le> m\"", "lemma CONS_surj[dest]: \"Length \\<AA> > 0 \\<Longrightarrow>\n  \\<exists>x \\<BB>. \\<AA> = CONS x \\<BB> \\<and> #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and> size_atom x = #\\<^sub>V \\<AA>\""], "translations": [["", "lemmas enum_defs = enum_order_def enum_all_order_def enum_ex_order_def"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(WS1S_Prelim.order, enum_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. UNIV = set enum_class.enum\n 2. distinct enum_class.enum\n 3. \\<And>P. enum_class.enum_all P = Ball UNIV P\n 4. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "qed (auto simp: enum_defs, (metis (full_types) order.exhaust)+)"], ["", "end"], ["", "typedef idx = \"UNIV :: (nat \\<times> nat) set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", "by (rule UNIV_witness)"], ["", "setup_lifting type_definition_idx"], ["", "lift_definition SUC :: \"order \\<Rightarrow> idx \\<Rightarrow> idx\" is\n  \"\\<lambda>ord (m, n). case ord of FO \\<Rightarrow> (Suc m, n) | SO \\<Rightarrow> (m, Suc n)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition LESS :: \"order \\<Rightarrow> nat \\<Rightarrow> idx \\<Rightarrow> bool\" is\n  \"\\<lambda>ord l (m, n). case ord of FO \\<Rightarrow> l < m | SO \\<Rightarrow> l < n\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation \"LEQ ord l idx \\<equiv> LESS ord l (SUC ord idx)\""], ["", "definition \"MSB Is \\<equiv>\n  if \\<forall>P \\<in> set Is. P = {||} then 0 else Suc (Max (\\<Union>P \\<in> set Is. fset P))\""], ["", "lemma MSB_Nil[simp]: \"MSB [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MSB [] = 0", "unfolding MSB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>P\\<in>set []. P = {||} then 0\n     else Suc (Max (\\<Union> (fset ` set [])))) =\n    0", "by simp"], ["", "lemma MSB_Cons[simp]: \"MSB (I # Is) = max (if I = {||} then 0 else Suc (fMax I)) (MSB Is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MSB (I # Is) = max (if I = {||} then 0 else Suc (fMax I)) (MSB Is)", "unfolding MSB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>P\\<in>set (I # Is). P = {||} then 0\n     else Suc (Max (\\<Union> (fset ` set (I # Is))))) =\n    max (if I = {||} then 0 else Suc (fMax I))\n     (if \\<forall>P\\<in>set Is. P = {||} then 0\n      else Suc (Max (\\<Union> (fset ` set Is))))", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>P\\<in>set (I # Is). P = {||} then 0\n     else Suc (Max (\\<Union> (fset ` set (I # Is))))) =\n    max (if I = {||} then 0 else Suc (fMax I))\n     (if \\<forall>P\\<in>set Is. P = {||} then 0\n      else Suc (Max (\\<Union> (fset ` set Is))))", "by transfer (auto simp: Max_Un list_all_iff Sup_bot_conv(2)[symmetric] simp del: Sup_bot_conv(2))"], ["", "lemma MSB_append[simp]: \"MSB (I1 @ I2) = max (MSB I1) (MSB I2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MSB (I1 @ I2) = max (MSB I1) (MSB I2)", "by (induct I1) auto"], ["", "lemma MSB_insert_nth[simp]:\n  \"MSB (insert_nth n P Is) = max (if P = {||} then 0 else Suc (fMax P)) (MSB Is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MSB (insert_nth n P Is) =\n    max (if P = {||} then 0 else Suc (fMax P)) (MSB Is)", "by (subst (2) append_take_drop_id[of n Is, symmetric])\n    (simp only: insert_nth_take_drop MSB_append MSB_Cons MSB_Nil)"], ["", "lemma MSB_greater:\n  \"\\<lbrakk>i < length Is; p |\\<in>| Is ! i\\<rbrakk> \\<Longrightarrow> p < MSB Is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length Is; p |\\<in>| Is ! i\\<rbrakk>\n    \\<Longrightarrow> p < MSB Is", "unfolding MSB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length Is; p |\\<in>| Is ! i\\<rbrakk>\n    \\<Longrightarrow> p < (if \\<forall>P\\<in>set Is. P = {||} then 0\n                           else Suc (Max (\\<Union> (fset ` set Is))))", "by (fastforce simp: Bex_def in_set_conv_nth less_Suc_eq_le intro: Max_ge)"], ["", "lemma MSB_mono: \"set I1 \\<subseteq> set I2 \\<Longrightarrow> MSB I1 \\<le> MSB I2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set I1 \\<subseteq> set I2 \\<Longrightarrow> MSB I1 \\<le> MSB I2", "unfolding MSB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set I1 \\<subseteq> set I2 \\<Longrightarrow>\n    (if \\<forall>P\\<in>set I1. P = {||} then 0\n     else Suc (Max (\\<Union> (fset ` set I1))))\n    \\<le> (if \\<forall>P\\<in>set I2. P = {||} then 0\n           else Suc (Max (\\<Union> (fset ` set I2))))", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. set I1 \\<subseteq> set I2 \\<Longrightarrow>\n    (if \\<forall>P\\<in>set I1. P = {||} then 0\n     else Suc (Max (\\<Union> (fset ` set I1))))\n    \\<le> (if \\<forall>P\\<in>set I2. P = {||} then 0\n           else Suc (Max (\\<Union> (fset ` set I2))))", "by transfer (auto simp: list_all_iff intro!: Max_ge)"], ["", "lemma MSB_map_index'_CONS[simp]:\n  \"MSB (map_index' i (lift bs) Is) =\n  (if MSB Is = 0 \\<and> (\\<forall>i \\<in> {i ..< i + length Is}. \\<not> bs ! i) then 0 else Suc (MSB Is))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MSB (map_index' i (lift bs) Is) =\n    (if MSB Is = 0 \\<and>\n        (\\<forall>i\\<in>{i..<i + length Is}. \\<not> bs ! i)\n     then 0 else Suc (MSB Is))", "by (induct Is arbitrary: i)\n   (auto split: if_splits simp: mono_fMax_commute[where f = Suc, symmetric] mono_def\n    lift_def upshift_def,\n    metis atLeastLessThan_iff le_antisym not_less_eq_eq)"], ["", "lemma MSB_map_index'_SNOC[simp]:\n  \"MSB Is \\<le> n \\<Longrightarrow> MSB (map_index' i (snoc n bs) Is) =\n  (if (\\<forall>i \\<in> {i ..< i + length Is}. \\<not> bs ! i) then MSB Is else Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MSB Is \\<le> n \\<Longrightarrow>\n    MSB (map_index' i (snoc n bs) Is) =\n    (if \\<forall>i\\<in>{i..<i + length Is}. \\<not> bs ! i then MSB Is\n     else Suc n)", "by (induct Is arbitrary: i)\n    (auto split: if_splits simp: mono_fMax_commute[where f = Suc, symmetric] mono_def\n    snoc_def, (metis atLeastLessThan_iff le_antisym not_less_eq_eq)+)"], ["", "lemma MSB_replicate[simp]: \"MSB (replicate n P) = (if P = {||} \\<or> n = 0 then 0 else Suc (fMax P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MSB (replicate n P) = (if P = {||} \\<or> n = 0 then 0 else Suc (fMax P))", "by (induct n) auto"], ["", "typedef interp =\n  \"{(n :: nat, I1 :: nat fset list, I2  :: nat fset list) | n I1 I2. MSB (I1 @ I2) \\<le> n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {(n, I1, I2) |n I1 I2. MSB (I1 @ I2) \\<le> n}", "by auto"], ["", "setup_lifting type_definition_interp"], ["", "lift_definition assigns :: \"nat \\<Rightarrow> interp \\<Rightarrow> order \\<Rightarrow> nat fset\" (\"_\\<^bsup>_\\<^esup>_\" [900, 999, 999] 999)\n  is \"\\<lambda>n (_, I1, I2) ord. case ord of FO \\<Rightarrow> if n < length I1 then I1 ! n else {||}\n    | SO \\<Rightarrow> if n < length I2 then I2 ! n else {||}\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition nvars :: \"interp \\<Rightarrow> idx\" (\"#\\<^sub>V _\" [1000] 900)\n  is \"\\<lambda>(_, I1, I2). (length I1, length I2)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition Length :: \"interp \\<Rightarrow> nat\"\n  is \"\\<lambda>(n, _, _). n\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition Extend :: \"order \\<Rightarrow> nat \\<Rightarrow> interp \\<Rightarrow> nat fset \\<Rightarrow> interp\"\n  is \"\\<lambda>ord i (n, I1, I2) P. case ord of\n      FO \\<Rightarrow> (max n (if P = {||} then 0 else Suc (fMax P)), insert_nth i P I1, I2)\n    | SO \\<Rightarrow> (max n (if P = {||} then 0 else Suc (fMax P)), I1, insert_nth i P I2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>order nat prod fset.\n       \\<exists>n I1 I2.\n          prod = (n, I1, I2) \\<and> MSB (I1 @ I2) \\<le> n \\<Longrightarrow>\n       \\<exists>n I1 I2.\n          (case prod of\n           (n, I1, I2) \\<Rightarrow>\n             \\<lambda>P.\n                case order of\n                FO \\<Rightarrow>\n                  (max n (if P = {||} then 0 else Suc (fMax P)),\n                   insert_nth nat P I1, I2)\n                | SO \\<Rightarrow>\n                    (max n (if P = {||} then 0 else Suc (fMax P)), I1,\n                     insert_nth nat P I2))\n           fset =\n          (n, I1, I2) \\<and>\n          MSB (I1 @ I2) \\<le> n", "using MSB_mono"], ["proof (prove)\nusing this:\n  set ?I1.0 \\<subseteq> set ?I2.0 \\<Longrightarrow>\n  MSB ?I1.0 \\<le> MSB ?I2.0\n\ngoal (1 subgoal):\n 1. \\<And>order nat prod fset.\n       \\<exists>n I1 I2.\n          prod = (n, I1, I2) \\<and> MSB (I1 @ I2) \\<le> n \\<Longrightarrow>\n       \\<exists>n I1 I2.\n          (case prod of\n           (n, I1, I2) \\<Rightarrow>\n             \\<lambda>P.\n                case order of\n                FO \\<Rightarrow>\n                  (max n (if P = {||} then 0 else Suc (fMax P)),\n                   insert_nth nat P I1, I2)\n                | SO \\<Rightarrow>\n                    (max n (if P = {||} then 0 else Suc (fMax P)), I1,\n                     insert_nth nat P I2))\n           fset =\n          (n, I1, I2) \\<and>\n          MSB (I1 @ I2) \\<le> n", "by (auto simp del: insert_nth_take_drop split: order.splits)"], ["", "lift_definition CONS :: \"(bool list \\<times> bool list) \\<Rightarrow> interp \\<Rightarrow> interp\"\n  is \"\\<lambda>(bs1, bs2) (n, I1, I2).\n   (Suc n, map_index (lift bs1) I1, map_index (lift bs2) I2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       \\<exists>n I1 I2.\n          prod2 = (n, I1, I2) \\<and> MSB (I1 @ I2) \\<le> n \\<Longrightarrow>\n       \\<exists>n I1 I2.\n          (case prod1 of\n           (bs1, bs2) \\<Rightarrow>\n             \\<lambda>(n, I1, I2).\n                (Suc n, map_index (lift bs1) I1, map_index (lift bs2) I2))\n           prod2 =\n          (n, I1, I2) \\<and>\n          MSB (I1 @ I2) \\<le> n", "by auto"], ["", "lift_definition SNOC :: \"(bool list \\<times> bool list) \\<Rightarrow> interp \\<Rightarrow> interp\"\n  is \"\\<lambda>(bs1, bs2) (n, I1, I2).\n   (Suc n, map_index (snoc n bs1) I1, map_index (snoc n bs2) I2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       \\<exists>n I1 I2.\n          prod2 = (n, I1, I2) \\<and> MSB (I1 @ I2) \\<le> n \\<Longrightarrow>\n       \\<exists>n I1 I2.\n          (case prod1 of\n           (bs1, bs2) \\<Rightarrow>\n             \\<lambda>(n, I1, I2).\n                (Suc n, map_index (snoc n bs1) I1,\n                 map_index (snoc n bs2) I2))\n           prod2 =\n          (n, I1, I2) \\<and>\n          MSB (I1 @ I2) \\<le> n", "by (auto simp: Let_def)"], ["", "type_synonym atom = \"bool list \\<times> bool list\""], ["", "lift_definition zero :: \"idx \\<Rightarrow> atom\"\n  is \"\\<lambda>(m, n). (replicate m False, replicate n False)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"extend ord b \\<equiv>\n  \\<lambda>(bs1, bs2). case ord of FO \\<Rightarrow> (b # bs1, bs2) | SO \\<Rightarrow> (bs1, b # bs2)\""], ["", "lift_definition size_atom :: \"bool list \\<times> bool list \\<Rightarrow> idx\"\n  is \"\\<lambda>(bs1, bs2). (length bs1, length bs2)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition \\<sigma> :: \"idx \\<Rightarrow> atom list\"\n  is \"(\\<lambda>(n, N). map (\\<lambda>bs. (take n bs, drop n bs)) (List.n_lists (n + N) [True, False]))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma fMin_fimage_Suc[simp]: \"x |\\<in>| A \\<Longrightarrow> fMin (Suc |`| A) = Suc (fMin A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| A \\<Longrightarrow> fMin (Suc |`| A) = Suc (fMin A)", "by (rule fMin_eqI) (auto intro: fMin_in)"], ["", "lemma fMin_eq_0[simp]: \"0 |\\<in>| A \\<Longrightarrow> fMin A = (0 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 |\\<in>| A \\<Longrightarrow> fMin A = 0", "by (rule fMin_eqI) auto"], ["", "lemma insert_nth_Cons[simp]:\n  \"insert_nth i x (y # xs) = (case i of 0 \\<Rightarrow> x # y # xs | Suc i \\<Rightarrow> y # insert_nth i x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_nth i x (y # xs) =\n    (case i of 0 \\<Rightarrow> x # y # xs\n     | Suc i \\<Rightarrow> y # insert_nth i x xs)", "by (cases i) simp_all"], ["", "lemma insert_nth_commute[simp]:\n  assumes \"j \\<le> i\" \"i \\<le> length xs\"\n  shows \"insert_nth j y (insert_nth i x xs) = insert_nth (Suc i) x (insert_nth j y xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_nth j y (insert_nth i x xs) =\n    insert_nth (Suc i) x (insert_nth j y xs)", "using assms"], ["proof (prove)\nusing this:\n  j \\<le> i\n  i \\<le> length xs\n\ngoal (1 subgoal):\n 1. insert_nth j y (insert_nth i x xs) =\n    insert_nth (Suc i) x (insert_nth j y xs)", "by (induct xs arbitrary: i j) (auto simp del: insert_nth_take_drop split: nat.splits)"], ["", "lemma SUC_SUC[simp]: \"SUC ord (SUC ord' idx) = SUC ord' (SUC ord idx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SUC ord (SUC ord' idx) = SUC ord' (SUC ord idx)", "by transfer (auto split: order.splits)"], ["", "lemma LESS_SUC[simp]:\n  \"LESS ord 0 (SUC ord idx)\"\n  \"LESS ord (Suc l) (SUC ord idx) = LESS ord l idx\"\n  \"ord \\<noteq> ord' \\<Longrightarrow> LESS ord l (SUC ord' idx) = LESS ord l idx\"\n  \"LESS ord l idx \\<Longrightarrow> LESS ord l (SUC ord' idx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEQ ord 0 idx &&& LEQ ord (Suc l) idx = LESS ord l idx) &&&\n    (ord \\<noteq> ord' \\<Longrightarrow>\n     LESS ord l (SUC ord' idx) = LESS ord l idx) &&&\n    (LESS ord l idx \\<Longrightarrow> LESS ord l (SUC ord' idx))", "by (transfer, force split: order.splits)+"], ["", "lemma nvars_Extend[simp]:\n  \"#\\<^sub>V (Extend ord i \\<AA> P) = SUC ord (#\\<^sub>V \\<AA>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #\\<^sub>V (Extend ord i \\<AA> P) = SUC ord (#\\<^sub>V \\<AA>)", "by (transfer, force split: order.splits)"], ["", "lemma Length_Extend[simp]:\n  \"Length (Extend k i \\<AA> P) = max (Length \\<AA>) (if P = {||} then 0 else Suc (fMax P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length (Extend k i \\<AA> P) =\n    max (Length \\<AA>) (if P = {||} then 0 else Suc (fMax P))", "unfolding max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Length (Extend k i \\<AA> P) =\n    (if Length \\<AA> \\<le> (if P = {||} then 0 else Suc (fMax P))\n     then if P = {||} then 0 else Suc (fMax P) else Length \\<AA>)", "by (split if_splits, transfer) (force split: order.splits)"], ["", "lemma assigns_Extend[simp]:\n  \"LEQ ord i (#\\<^sub>V \\<AA>) \\<Longrightarrow>m\\<^bsup>Extend ord i \\<AA> P\\<^esup>ord = (if m = i then P else (if m > i then m - Suc 0 else m)\\<^bsup>\\<AA>\\<^esup>ord)\"\n  \"ord \\<noteq> ord' \\<Longrightarrow> m\\<^bsup>Extend ord i \\<AA> P\\<^esup>ord' = m\\<^bsup>\\<AA>\\<^esup>ord'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEQ ord i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n     m\\<^bsup>Extend ord i \\<AA> P\\<^esup>ord =\n     (if m = i then P\n      else (if i < m then m - Suc 0 else m)\\<^bsup>\\<AA>\\<^esup>ord)) &&&\n    (ord \\<noteq> ord' \\<Longrightarrow>\n     m\\<^bsup>Extend ord i \\<AA> P\\<^esup>ord' = m\\<^bsup>\\<AA>\\<^esup>ord')", "by (transfer, force simp: min_def nth_append split: order.splits)+"], ["", "lemma Extend_commute_safe[simp]:\n  \"\\<lbrakk>j \\<le> i; LEQ ord i (#\\<^sub>V \\<AA>)\\<rbrakk> \\<Longrightarrow>\n    Extend ord j (Extend ord i \\<AA> P1) P2 = Extend ord (Suc i) (Extend ord j \\<AA> P2) P1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<le> i; LEQ ord i (#\\<^sub>V \\<AA>)\\<rbrakk>\n    \\<Longrightarrow> Extend ord j (Extend ord i \\<AA> P1) P2 =\n                      Extend ord (Suc i) (Extend ord j \\<AA> P2) P1", "by (transfer,\n    force simp del: insert_nth_take_drop simp: replicate_add[symmetric] split: order.splits)"], ["", "lemma Extend_commute_unsafe:\n  \"ord \\<noteq> ord' \\<Longrightarrow> Extend ord j (Extend ord' i \\<AA> P1) P2 = Extend ord' i (Extend ord j \\<AA> P2) P1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord \\<noteq> ord' \\<Longrightarrow>\n    Extend ord j (Extend ord' i \\<AA> P1) P2 =\n    Extend ord' i (Extend ord j \\<AA> P2) P1", "by (transfer, force simp: replicate_add[symmetric] split: order.splits)"], ["", "lemma Length_CONS[simp]:\n  \"Length (CONS x \\<AA>) = Suc (Length \\<AA>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length (CONS x \\<AA>) = Suc (Length \\<AA>)", "by (transfer, force split: order.splits)"], ["", "lemma Length_SNOC[simp]:\n  \"Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)", "by (transfer, force simp: Let_def split: order.splits)"], ["", "lemma nvars_CONS[simp]:\n  \"#\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>", "by (transfer, force)"], ["", "lemma nvars_SNOC[simp]:\n  \"#\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>", "by (transfer, force simp: Let_def)"], ["", "lemma assigns_CONS[simp]:\n  assumes \"#\\<^sub>V \\<AA> = size_atom bs1_bs2\"\n  shows \"LESS ord x (#\\<^sub>V \\<AA>) \\<Longrightarrow> x\\<^bsup>CONS bs1_bs2 \\<AA>\\<^esup>ord =\n    (if case_prod case_order bs1_bs2 ord ! x then finsert 0 (upshift (x\\<^bsup>\\<AA>\\<^esup>ord)) else upshift (x\\<^bsup>\\<AA>\\<^esup>ord))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LESS ord x (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n    x\\<^bsup>CONS bs1_bs2 \\<AA>\\<^esup>ord =\n    (if (case bs1_bs2 of\n         (x, xa) \\<Rightarrow> WS1S_Prelim.order.case_order x xa)\n         ord !\n        x\n     then finsert 0 (upshift (x\\<^bsup>\\<AA>\\<^esup>ord))\n     else upshift (x\\<^bsup>\\<AA>\\<^esup>ord))", "by (insert assms, transfer) (auto simp: lift_def split: order.splits)"], ["", "lemma assigns_SNOC[simp]:\n  assumes \"#\\<^sub>V \\<AA> = size_atom bs1_bs2\"\n  shows \"LESS ord x (#\\<^sub>V \\<AA>) \\<Longrightarrow> x\\<^bsup>SNOC bs1_bs2 \\<AA>\\<^esup>ord =\n    (if case_prod case_order bs1_bs2 ord ! x then finsert (Length \\<AA>) (x\\<^bsup>\\<AA>\\<^esup>ord) else x\\<^bsup>\\<AA>\\<^esup>ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LESS ord x (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n    x\\<^bsup>SNOC bs1_bs2 \\<AA>\\<^esup>ord =\n    (if (case bs1_bs2 of\n         (x, xa) \\<Rightarrow> WS1S_Prelim.order.case_order x xa)\n         ord !\n        x\n     then finsert (Length \\<AA>) (x\\<^bsup>\\<AA>\\<^esup>ord)\n     else x\\<^bsup>\\<AA>\\<^esup>ord)", "by (insert assms, transfer) (force simp: snoc_def Let_def split: order.splits)"], ["", "lemma map_index'_eq_conv[simp]:\n  \"map_index' i f xs = map_index' j g xs = (\\<forall>k < length xs. f (i + k) (xs ! k) = g (j + k) (xs ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_index' i f xs = map_index' j g xs) =\n    (\\<forall>k<length xs. f (i + k) (xs ! k) = g (j + k) (xs ! k))", "proof (induct xs arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       (map_index' i f [] = map_index' j g []) =\n       (\\<forall>k<length []. f (i + k) ([] ! k) = g (j + k) ([] ! k))\n 2. \\<And>a xs i j.\n       (\\<And>i j.\n           (map_index' i f xs = map_index' j g xs) =\n           (\\<forall>k<length xs.\n               f (i + k) (xs ! k) = g (j + k) (xs ! k))) \\<Longrightarrow>\n       (map_index' i f (a # xs) = map_index' j g (a # xs)) =\n       (\\<forall>k<length (a # xs).\n           f (i + k) ((a # xs) ! k) = g (j + k) ((a # xs) ! k))", "case Cons"], ["proof (state)\nthis:\n  (map_index' ?i f xs_ = map_index' ?j g xs_) =\n  (\\<forall>k<length xs_. f (?i + k) (xs_ ! k) = g (?j + k) (xs_ ! k))\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       (map_index' i f [] = map_index' j g []) =\n       (\\<forall>k<length []. f (i + k) ([] ! k) = g (j + k) ([] ! k))\n 2. \\<And>a xs i j.\n       (\\<And>i j.\n           (map_index' i f xs = map_index' j g xs) =\n           (\\<forall>k<length xs.\n               f (i + k) (xs ! k) = g (j + k) (xs ! k))) \\<Longrightarrow>\n       (map_index' i f (a # xs) = map_index' j g (a # xs)) =\n       (\\<forall>k<length (a # xs).\n           f (i + k) ((a # xs) ! k) = g (j + k) ((a # xs) ! k))", "from Cons(1)[of \"Suc i\" \"Suc j\"]"], ["proof (chain)\npicking this:\n  (map_index' (Suc i) f xs_ = map_index' (Suc j) g xs_) =\n  (\\<forall>k<length xs_. f (Suc i + k) (xs_ ! k) = g (Suc j + k) (xs_ ! k))", "show ?case"], ["proof (prove)\nusing this:\n  (map_index' (Suc i) f xs_ = map_index' (Suc j) g xs_) =\n  (\\<forall>k<length xs_. f (Suc i + k) (xs_ ! k) = g (Suc j + k) (xs_ ! k))\n\ngoal (1 subgoal):\n 1. (map_index' i f (a_ # xs_) = map_index' j g (a_ # xs_)) =\n    (\\<forall>k<length (a_ # xs_).\n        f (i + k) ((a_ # xs_) ! k) = g (j + k) ((a_ # xs_) ! k))", "by (auto simp: nth_Cons split: nat.splits)"], ["proof (state)\nthis:\n  (map_index' i f (a_ # xs_) = map_index' j g (a_ # xs_)) =\n  (\\<forall>k<length (a_ # xs_).\n      f (i + k) ((a_ # xs_) ! k) = g (j + k) ((a_ # xs_) ! k))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (map_index' i f [] = map_index' j g []) =\n       (\\<forall>k<length []. f (i + k) ([] ! k) = g (j + k) ([] ! k))", "qed simp"], ["", "lemma fMax_Diff_0[simp]: \"Suc m |\\<in>| P \\<Longrightarrow> fMax (P |-| {|0|}) = fMax P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc m |\\<in>| P \\<Longrightarrow> fMax (P |-| {|0|}) = fMax P", "by (rule fMax_eqI) (auto intro: fMax_in dest: fMax_ge)"], ["", "lemma Suc_fMax_pred_fimage[simp]:\n  assumes \"Suc p |\\<in>| P\" \"0 |\\<notin>| P\"\n  shows \"Suc (fMax ((\\<lambda>x. x - Suc 0) |`| P)) = fMax P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (fMax ((\\<lambda>x. x - Suc 0) |`| P)) = fMax P", "using assms"], ["proof (prove)\nusing this:\n  Suc p |\\<in>| P\n  0 |\\<notin>| P\n\ngoal (1 subgoal):\n 1. Suc (fMax ((\\<lambda>x. x - Suc 0) |`| P)) = fMax P", "by (subst mono_fMax_commute[of Suc, unfolded mono_def, simplified]) (auto simp: o_def)"], ["", "lemma Extend_CONS[simp]: \"#\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow> Extend ord 0 (CONS x \\<AA>) P =\n  CONS (extend ord (eval P 0) x) (Extend ord 0 \\<AA> (downshift P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n    Extend ord 0 (CONS x \\<AA>) P =\n    CONS (extend ord (eval P 0) x) (Extend ord 0 \\<AA> (downshift P))", "by transfer (auto simp: extend_def o_def gr0_conv_Suc\n    mono_fMax_commute[of Suc, symmetric, unfolded mono_def, simplified]\n    lift_def upshift_def downshift_def eval_def\n    dest!: fsubset_fsingletonD split: order.splits)"], ["", "lemma size_atom_extend[simp]:\n  \"size_atom (extend ord b x) = SUC ord (size_atom x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_atom (extend ord b x) = SUC ord (size_atom x)", "unfolding extend_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. size_atom\n     (case x of\n      (bs1, bs2) \\<Rightarrow>\n        case ord of FO \\<Rightarrow> (b # bs1, bs2)\n        | SO \\<Rightarrow> (bs1, b # bs2)) =\n    SUC ord (size_atom x)", "by transfer (simp split: prod.splits order.splits)"], ["", "lemma size_atom_zero[simp]:\n  \"size_atom (zero idx) = idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_atom (zero idx) = idx", "unfolding extend_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. size_atom (zero idx) = idx", "by transfer (simp split: prod.splits order.splits)"], ["", "lemma interp_eqI:\n  \"\\<lbrakk>Length \\<AA> = Length \\<BB>; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>; \\<And>m k. LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow> m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk> \\<Longrightarrow> \\<AA> = \\<BB>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Length \\<AA> = Length \\<BB>; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n     \\<And>m k.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n    \\<Longrightarrow> \\<AA> = \\<BB>", "by transfer (force split: order.splits intro!: nth_equalityI)"], ["", "lemma Extend_SNOC_cut[unfolded eval_def cut_def Length_SNOC, simp]:\n  \"\\<lbrakk>len P \\<le> Length (SNOC x \\<AA>); #\\<^sub>V \\<AA> = size_atom x\\<rbrakk> \\<Longrightarrow>\n  Extend ord 0 (SNOC x \\<AA>) P =\n    SNOC (extend ord (if eval P (Length \\<AA>) then True else False) x) (Extend ord 0 \\<AA> (cut (Length \\<AA>) P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>len P \\<le> Length (SNOC x \\<AA>);\n     #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n    \\<Longrightarrow> Extend ord 0 (SNOC x \\<AA>) P =\n                      SNOC\n                       (extend ord\n                         (if eval P (Length \\<AA>) then True else False) x)\n                       (Extend ord 0 \\<AA> (cut (Length \\<AA>) P))", "by transfer (fastforce simp: extend_def len_def cut_def ffilter_eq_fempty_iff snoc_def eval_def\n    split: if_splits order.splits dest: fMax_ge fMax_boundedD intro: fMax_in)"], ["", "lemma nth_replicate_simp: \"replicate m x ! i = (if i < m then x else [] ! (i - m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate m x ! i = (if i < m then x else [] ! (i - m))", "by (induct m arbitrary: i) (auto simp: nth_Cons')"], ["", "lemma MSB_eq_SucD: \"MSB Is = Suc x \\<Longrightarrow> \\<exists>P\\<in>set Is. x |\\<in>| P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MSB Is = Suc x \\<Longrightarrow> \\<exists>P\\<in>set Is. x |\\<in>| P", "using Max_in[of \"\\<Union>x\\<in>set Is. fset x\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (\\<Union> (fset ` set Is));\n   \\<Union> (fset ` set Is) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Max (\\<Union> (fset ` set Is))\n                    \\<in> \\<Union> (fset ` set Is)\n\ngoal (1 subgoal):\n 1. MSB Is = Suc x \\<Longrightarrow> \\<exists>P\\<in>set Is. x |\\<in>| P", "unfolding MSB_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (\\<Union> (fset ` set Is));\n   \\<Union> (fset ` set Is) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Max (\\<Union> (fset ` set Is))\n                    \\<in> \\<Union> (fset ` set Is)\n\ngoal (1 subgoal):\n 1. (if \\<forall>P\\<in>set Is. P = {||} then 0\n     else Suc (Max (\\<Union> (fset ` set Is)))) =\n    Suc x \\<Longrightarrow>\n    \\<exists>P\\<in>set Is. x |\\<in>| P", "by (force simp: fmember_def split: if_splits)"], ["", "lemma append_replicate_inj:\n  assumes \"xs \\<noteq> [] \\<Longrightarrow> last xs \\<noteq> x\" and \"ys \\<noteq> [] \\<Longrightarrow> last ys \\<noteq> x\"\n  shows \"xs @ replicate m x = ys @ replicate n x \\<longleftrightarrow> (xs = ys \\<and> m = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ replicate m x = ys @ replicate n x) = (xs = ys \\<and> m = n)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> xs = ys\n 2. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> m = n", "from assms"], ["proof (chain)\npicking this:\n  xs \\<noteq> [] \\<Longrightarrow> last xs \\<noteq> x\n  ys \\<noteq> [] \\<Longrightarrow> last ys \\<noteq> x", "have assms': \"xs \\<noteq> [] \\<Longrightarrow> rev xs ! 0 \\<noteq> x\" \"ys \\<noteq> [] \\<Longrightarrow> rev ys ! 0 \\<noteq> x\""], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow> last xs \\<noteq> x\n  ys \\<noteq> [] \\<Longrightarrow> last ys \\<noteq> x\n\ngoal (1 subgoal):\n 1. (xs \\<noteq> [] \\<Longrightarrow> rev xs ! 0 \\<noteq> x) &&&\n    (ys \\<noteq> [] \\<Longrightarrow> rev ys ! 0 \\<noteq> x)", "by (auto simp: hd_rev hd_conv_nth[symmetric])"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<Longrightarrow> rev xs ! 0 \\<noteq> x\n  ys \\<noteq> [] \\<Longrightarrow> rev ys ! 0 \\<noteq> x\n\ngoal (2 subgoals):\n 1. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> xs = ys\n 2. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> m = n", "assume *: \"xs @ replicate m x = ys @ replicate n x\""], ["proof (state)\nthis:\n  xs @ replicate m x = ys @ replicate n x\n\ngoal (2 subgoals):\n 1. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> xs = ys\n 2. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> m = n", "then"], ["proof (chain)\npicking this:\n  xs @ replicate m x = ys @ replicate n x", "have \"rev (xs @ replicate m x) = rev (ys @ replicate n x)\""], ["proof (prove)\nusing this:\n  xs @ replicate m x = ys @ replicate n x\n\ngoal (1 subgoal):\n 1. rev (xs @ replicate m x) = rev (ys @ replicate n x)", ".."], ["proof (state)\nthis:\n  rev (xs @ replicate m x) = rev (ys @ replicate n x)\n\ngoal (2 subgoals):\n 1. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> xs = ys\n 2. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> m = n", "then"], ["proof (chain)\npicking this:\n  rev (xs @ replicate m x) = rev (ys @ replicate n x)", "have \"replicate m x @ rev xs = replicate n x @ rev ys\""], ["proof (prove)\nusing this:\n  rev (xs @ replicate m x) = rev (ys @ replicate n x)\n\ngoal (1 subgoal):\n 1. replicate m x @ rev xs = replicate n x @ rev ys", "by simp"], ["proof (state)\nthis:\n  replicate m x @ rev xs = replicate n x @ rev ys\n\ngoal (2 subgoals):\n 1. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> xs = ys\n 2. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> m = n", "then"], ["proof (chain)\npicking this:\n  replicate m x @ rev xs = replicate n x @ rev ys", "have \"take (max m n) (replicate m x @ rev xs) = take (max m n) (replicate n x @ rev ys)\""], ["proof (prove)\nusing this:\n  replicate m x @ rev xs = replicate n x @ rev ys\n\ngoal (1 subgoal):\n 1. take (max m n) (replicate m x @ rev xs) =\n    take (max m n) (replicate n x @ rev ys)", "by simp"], ["proof (state)\nthis:\n  take (max m n) (replicate m x @ rev xs) =\n  take (max m n) (replicate n x @ rev ys)\n\ngoal (2 subgoals):\n 1. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> xs = ys\n 2. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> m = n", "then"], ["proof (chain)\npicking this:\n  take (max m n) (replicate m x @ rev xs) =\n  take (max m n) (replicate n x @ rev ys)", "have \"replicate m x @ take (max m n - m) (rev xs) =\n    replicate n x @ take (max m n - n) (rev ys)\""], ["proof (prove)\nusing this:\n  take (max m n) (replicate m x @ rev xs) =\n  take (max m n) (replicate n x @ rev ys)\n\ngoal (1 subgoal):\n 1. replicate m x @ take (max m n - m) (rev xs) =\n    replicate n x @ take (max m n - n) (rev ys)", "by (auto simp: min_def max_def split: if_splits)"], ["proof (state)\nthis:\n  replicate m x @ take (max m n - m) (rev xs) =\n  replicate n x @ take (max m n - n) (rev ys)\n\ngoal (2 subgoals):\n 1. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> xs = ys\n 2. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> m = n", "then"], ["proof (chain)\npicking this:\n  replicate m x @ take (max m n - m) (rev xs) =\n  replicate n x @ take (max m n - n) (rev ys)", "have \"(replicate m x @ take (max m n - m) (rev xs)) ! min m n =\n    (replicate n x @ take (max m n - n) (rev ys)) ! min m n\""], ["proof (prove)\nusing this:\n  replicate m x @ take (max m n - m) (rev xs) =\n  replicate n x @ take (max m n - n) (rev ys)\n\ngoal (1 subgoal):\n 1. (replicate m x @ take (max m n - m) (rev xs)) ! min m n =\n    (replicate n x @ take (max m n - n) (rev ys)) ! min m n", "by simp"], ["proof (state)\nthis:\n  (replicate m x @ take (max m n - m) (rev xs)) ! min m n =\n  (replicate n x @ take (max m n - n) (rev ys)) ! min m n\n\ngoal (2 subgoals):\n 1. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> xs = ys\n 2. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> m = n", "with arg_cong[OF *, of length, simplified] assms'"], ["proof (chain)\npicking this:\n  length xs + m = length ys + n\n  xs \\<noteq> [] \\<Longrightarrow> rev xs ! 0 \\<noteq> x\n  ys \\<noteq> [] \\<Longrightarrow> rev ys ! 0 \\<noteq> x\n  (replicate m x @ take (max m n - m) (rev xs)) ! min m n =\n  (replicate n x @ take (max m n - n) (rev ys)) ! min m n", "show \"m = n\""], ["proof (prove)\nusing this:\n  length xs + m = length ys + n\n  xs \\<noteq> [] \\<Longrightarrow> rev xs ! 0 \\<noteq> x\n  ys \\<noteq> [] \\<Longrightarrow> rev ys ! 0 \\<noteq> x\n  (replicate m x @ take (max m n - m) (rev xs)) ! min m n =\n  (replicate n x @ take (max m n - n) (rev ys)) ! min m n\n\ngoal (1 subgoal):\n 1. m = n", "by (cases \"xs = []\" \"ys = []\" rule: bool.exhaust[case_product bool.exhaust])\n      (auto simp: min_def nth_append split: if_splits)"], ["proof (state)\nthis:\n  m = n\n\ngoal (1 subgoal):\n 1. xs @ replicate m x = ys @ replicate n x \\<Longrightarrow> xs = ys", "with *"], ["proof (chain)\npicking this:\n  xs @ replicate m x = ys @ replicate n x\n  m = n", "show \"xs = ys\""], ["proof (prove)\nusing this:\n  xs @ replicate m x = ys @ replicate n x\n  m = n\n\ngoal (1 subgoal):\n 1. xs = ys", "by auto"], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fin_lift[simp]: \"m |\\<in>| lift bs i (I ! i) \\<longleftrightarrow> (case m of 0 \\<Rightarrow> bs ! i | Suc m \\<Rightarrow> m |\\<in>| I ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m |\\<in>| lift bs i (I ! i)) =\n    (case m of 0 \\<Rightarrow> bs ! i | Suc m \\<Rightarrow> m |\\<in>| I ! i)", "unfolding lift_def upshift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m |\\<in>|\n     (if bs ! i then finsert 0 (Suc |`| I ! i) else Suc |`| I ! i)) =\n    (case m of 0 \\<Rightarrow> bs ! i | Suc m \\<Rightarrow> m |\\<in>| I ! i)", "by (auto split: nat.splits)"], ["", "lemma ex_Length_0[simp]:\n  \"\\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx", "by transfer (auto intro!: exI[of _ \"replicate m {||}\" for m])"], ["", "lemma is_empty_inj[simp]: \"\\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk> \\<Longrightarrow> \\<AA> = \\<BB>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n     #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n    \\<Longrightarrow> \\<AA> = \\<BB>", "by transfer (simp add: list_eq_iff_nth_eq split: prod.splits,\n    metis MSB_greater fMax_in less_nat_zero_code)"], ["", "lemma set_\\<sigma>_length_atom[simp]: \"(x \\<in> set (\\<sigma> idx)) \\<longleftrightarrow> idx = size_atom x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (\\<sigma> idx)) = (idx = size_atom x)", "by transfer (auto simp: set_n_lists enum_UNIV image_iff intro!: exI[of _ \"I1 @ I2\" for I1 I2])"], ["", "lemma distinct_\\<sigma>[simp]: \"distinct (\\<sigma> idx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (\\<sigma> idx)", "by transfer (auto 0 4 simp: distinct_map distinct_n_lists set_n_lists inj_on_def\n    intro: iffD2[OF append_eq_append_conv]\n      box_equals[OF _ append_take_drop_id append_take_drop_id, of n _ n for n])"], ["", "lemma fMin_less_Length[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> fMin (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    fMin (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>", "by transfer\n    (force elim: order.strict_trans2[OF MSB_greater, rotated -1] intro: fMin_in split: order.splits)"], ["", "lemma fMax_less_Length[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> fMax (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    fMax (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>", "by transfer\n    (force elim: order.strict_trans2[OF MSB_greater, rotated -1] intro: fMax_in split: order.splits)"], ["", "lemma min_Length_fMin[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> min (Length \\<AA>) (fMin (m1\\<^bsup>\\<AA>\\<^esup>k)) = fMin (m1\\<^bsup>\\<AA>\\<^esup>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    min (Length \\<AA>) (fMin (m1\\<^bsup>\\<AA>\\<^esup>k)) =\n    fMin (m1\\<^bsup>\\<AA>\\<^esup>k)", "using fMin_less_Length[of x m1 \\<AA> k]"], ["proof (prove)\nusing this:\n  x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n  fMin (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\n\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    min (Length \\<AA>) (fMin (m1\\<^bsup>\\<AA>\\<^esup>k)) =\n    fMin (m1\\<^bsup>\\<AA>\\<^esup>k)", "unfolding fMin_def"], ["proof (prove)\nusing this:\n  x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n  semilattice_fset.F min (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\n\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    min (Length \\<AA>) (semilattice_fset.F min (m1\\<^bsup>\\<AA>\\<^esup>k)) =\n    semilattice_fset.F min (m1\\<^bsup>\\<AA>\\<^esup>k)", "by auto"], ["", "lemma max_Length_fMin[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> max (Length \\<AA>) (fMin (m1\\<^bsup>\\<AA>\\<^esup>k)) = Length \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    max (Length \\<AA>) (fMin (m1\\<^bsup>\\<AA>\\<^esup>k)) = Length \\<AA>", "using fMin_less_Length[of x m1 \\<AA> k]"], ["proof (prove)\nusing this:\n  x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n  fMin (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\n\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    max (Length \\<AA>) (fMin (m1\\<^bsup>\\<AA>\\<^esup>k)) = Length \\<AA>", "unfolding fMin_def"], ["proof (prove)\nusing this:\n  x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n  semilattice_fset.F min (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\n\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    max (Length \\<AA>) (semilattice_fset.F min (m1\\<^bsup>\\<AA>\\<^esup>k)) =\n    Length \\<AA>", "by auto"], ["", "lemma min_Length_fMax[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> min (Length \\<AA>) (fMax (m1\\<^bsup>\\<AA>\\<^esup>k)) = fMax (m1\\<^bsup>\\<AA>\\<^esup>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    min (Length \\<AA>) (fMax (m1\\<^bsup>\\<AA>\\<^esup>k)) =\n    fMax (m1\\<^bsup>\\<AA>\\<^esup>k)", "using fMax_less_Length[of x m1 \\<AA> k]"], ["proof (prove)\nusing this:\n  x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n  fMax (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\n\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    min (Length \\<AA>) (fMax (m1\\<^bsup>\\<AA>\\<^esup>k)) =\n    fMax (m1\\<^bsup>\\<AA>\\<^esup>k)", "unfolding fMax_def"], ["proof (prove)\nusing this:\n  x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n  semilattice_fset.F max (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\n\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    min (Length \\<AA>) (semilattice_fset.F max (m1\\<^bsup>\\<AA>\\<^esup>k)) =\n    semilattice_fset.F max (m1\\<^bsup>\\<AA>\\<^esup>k)", "by auto"], ["", "lemma max_Length_fMax[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> max (Length \\<AA>) (fMax (m1\\<^bsup>\\<AA>\\<^esup>k)) = Length \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    max (Length \\<AA>) (fMax (m1\\<^bsup>\\<AA>\\<^esup>k)) = Length \\<AA>", "using fMax_less_Length[of x m1 \\<AA> k]"], ["proof (prove)\nusing this:\n  x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n  fMax (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\n\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    max (Length \\<AA>) (fMax (m1\\<^bsup>\\<AA>\\<^esup>k)) = Length \\<AA>", "unfolding fMax_def"], ["proof (prove)\nusing this:\n  x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n  semilattice_fset.F max (m1\\<^bsup>\\<AA>\\<^esup>k) < Length \\<AA>\n\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow>\n    max (Length \\<AA>) (semilattice_fset.F max (m1\\<^bsup>\\<AA>\\<^esup>k)) =\n    Length \\<AA>", "by auto"], ["", "lemma assigns_less_Length[simp]: \"x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> x < Length \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| m1\\<^bsup>\\<AA>\\<^esup>k \\<Longrightarrow> x < Length \\<AA>", "by transfer (force dest: MSB_greater split: order.splits if_splits)"], ["", "lemma Length_notin_assigns[simp]: \"Length \\<AA> |\\<notin>| m\\<^bsup>\\<AA>\\<^esup>k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Length \\<AA> |\\<notin>| m\\<^bsup>\\<AA>\\<^esup>k", "by (metis assigns_less_Length less_not_refl)"], ["", "lemma nth_zero[simp]: \"LESS ord m (#\\<^sub>V \\<AA>) \\<Longrightarrow> \\<not> case_prod case_order (zero (#\\<^sub>V \\<AA>)) ord ! m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LESS ord m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n    \\<not> (case zero (#\\<^sub>V \\<AA>) of\n            (x, xa) \\<Rightarrow> WS1S_Prelim.order.case_order x xa)\n            ord !\n           m", "by transfer (auto split: order.splits)"], ["", "lemma in_fimage_Suc[simp]: \"x |\\<in>| Suc |`| A \\<longleftrightarrow> (\\<exists>y. y |\\<in>| A \\<and> x = Suc y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x |\\<in>| Suc |`| A) = (\\<exists>y. y |\\<in>| A \\<and> x = Suc y)", "by blast"], ["", "lemma fimage_Suc_inj[simp]: \"Suc |`| A = Suc |`| B \\<longleftrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc |`| A = Suc |`| B) = (A = B)", "by blast"], ["", "lemma MSB_eq0_D: \"MSB I = 0 \\<Longrightarrow> x < length I \\<Longrightarrow> I ! x = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MSB I = 0; x < length I\\<rbrakk> \\<Longrightarrow> I ! x = {||}", "unfolding MSB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if \\<forall>P\\<in>set I. P = {||} then 0\n              else Suc (Max (\\<Union> (fset ` set I)))) =\n             0;\n     x < length I\\<rbrakk>\n    \\<Longrightarrow> I ! x = {||}", "by (auto split: if_splits)"], ["", "lemma Suc_in_fimage_Suc: \"Suc x |\\<in>| Suc |`| X \\<longleftrightarrow> x |\\<in>| X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc x |\\<in>| Suc |`| X) = (x |\\<in>| X)", "by auto"], ["", "lemma Suc_in_fimage_Suc_o_Suc[simp]: \"Suc x |\\<in>| (Suc \\<circ> Suc) |`| X \\<longleftrightarrow> x |\\<in>| Suc |`| X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc x |\\<in>| (Suc \\<circ> Suc) |`| X) = (x |\\<in>| Suc |`| X)", "by auto"], ["", "lemma finsert_same_eq_iff[simp]: \"finsert k X = finsert k Y \\<longleftrightarrow> X |-| {|k|} = Y |-| {|k|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finsert k X = finsert k Y) = (X |-| {|k|} = Y |-| {|k|})", "by auto"], ["", "lemma fimage_Suc_o_Suc_eq_fimage_Suc_iff[simp]:\n  \"((Suc \\<circ> Suc) |`| X = Suc |`| Y) \\<longleftrightarrow> (Suc |`| X = Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Suc \\<circ> Suc) |`| X = Suc |`| Y) = (Suc |`| X = Y)", "by (metis fimage_Suc_inj fset.map_comp)"], ["", "lemma fMax_image_Suc[simp]: \"x |\\<in>| P \\<Longrightarrow> fMax (Suc |`| P) = Suc (fMax P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| P \\<Longrightarrow> fMax (Suc |`| P) = Suc (fMax P)", "by (rule fMax_eqI) (metis Suc_le_mono fMax_ge fimageE, metis fimageI fempty_iff fMax_in)"], ["", "lemma fimage_Suc_eq_singleton[simp]: \"(fimage Suc Z = {|y|}) \\<longleftrightarrow> (\\<exists>x. Z = {|x|} \\<and> Suc x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc |`| Z = {|y|}) = (\\<exists>x. Z = {|x|} \\<and> Suc x = y)", "by (cases y) auto"], ["", "lemma len_downshift_helper:\n  \"x |\\<in>| P \\<Longrightarrow> Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P \\<Longrightarrow> xa |\\<in>| P \\<Longrightarrow> xa = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| P;\n     Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P;\n     xa |\\<in>| P\\<rbrakk>\n    \\<Longrightarrow> xa = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| P;\n     Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P;\n     xa |\\<in>| P\\<rbrakk>\n    \\<Longrightarrow> xa = 0", "assume a1: \"xa |\\<in>| P\""], ["proof (state)\nthis:\n  xa |\\<in>| P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| P;\n     Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P;\n     xa |\\<in>| P\\<rbrakk>\n    \\<Longrightarrow> xa = 0", "assume a2: \"Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P\""], ["proof (state)\nthis:\n  Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| P;\n     Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P;\n     xa |\\<in>| P\\<rbrakk>\n    \\<Longrightarrow> xa = 0", "have \"xa |\\<in>| {|0|} \\<longrightarrow> xa = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa |\\<in>| {|0|} \\<longrightarrow> xa = 0", "by fastforce"], ["proof (state)\nthis:\n  xa |\\<in>| {|0|} \\<longrightarrow> xa = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| P;\n     Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P;\n     xa |\\<in>| P\\<rbrakk>\n    \\<Longrightarrow> xa = 0", "moreover"], ["proof (state)\nthis:\n  xa |\\<in>| {|0|} \\<longrightarrow> xa = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| P;\n     Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P;\n     xa |\\<in>| P\\<rbrakk>\n    \\<Longrightarrow> xa = 0", "{"], ["proof (state)\nthis:\n  xa |\\<in>| {|0|} \\<longrightarrow> xa = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| P;\n     Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P;\n     xa |\\<in>| P\\<rbrakk>\n    \\<Longrightarrow> xa = 0", "assume \"xa |\\<notin>| {|0|}\""], ["proof (state)\nthis:\n  xa |\\<notin>| {|0|}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| P;\n     Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P;\n     xa |\\<in>| P\\<rbrakk>\n    \\<Longrightarrow> xa = 0", "hence \"0 |\\<notin>| P |-| {|0|} \\<and> xa |\\<notin>| {|0|}\""], ["proof (prove)\nusing this:\n  xa |\\<notin>| {|0|}\n\ngoal (1 subgoal):\n 1. 0 |\\<notin>| P |-| {|0|} \\<and> xa |\\<notin>| {|0|}", "by blast"], ["proof (state)\nthis:\n  0 |\\<notin>| P |-| {|0|} \\<and> xa |\\<notin>| {|0|}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| P;\n     Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P;\n     xa |\\<in>| P\\<rbrakk>\n    \\<Longrightarrow> xa = 0", "then"], ["proof (chain)\npicking this:\n  0 |\\<notin>| P |-| {|0|} \\<and> xa |\\<notin>| {|0|}", "obtain esk1\\<^sub>1 :: \"nat \\<Rightarrow> nat\" where \"xa = 0\""], ["proof (prove)\nusing this:\n  0 |\\<notin>| P |-| {|0|} \\<and> xa |\\<notin>| {|0|}\n\ngoal (1 subgoal):\n 1. (xa = 0 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using a1 a2"], ["proof (prove)\nusing this:\n  0 |\\<notin>| P |-| {|0|} \\<and> xa |\\<notin>| {|0|}\n  xa |\\<in>| P\n  Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P\n\ngoal (1 subgoal):\n 1. (xa = 0 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis Suc_fMax_pred_fimage fMax_Diff_0 fminus_iff not0_implies_Suc)"], ["proof (state)\nthis:\n  xa = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| P;\n     Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P;\n     xa |\\<in>| P\\<rbrakk>\n    \\<Longrightarrow> xa = 0", "}"], ["proof (state)\nthis:\n  xa |\\<notin>| {|0|} \\<Longrightarrow> xa = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| P;\n     Suc (fMax ((\\<lambda>x. x - Suc 0) |`| (P |-| {|0|}))) \\<noteq> fMax P;\n     xa |\\<in>| P\\<rbrakk>\n    \\<Longrightarrow> xa = 0", "ultimately"], ["proof (chain)\npicking this:\n  xa |\\<in>| {|0|} \\<longrightarrow> xa = 0\n  xa |\\<notin>| {|0|} \\<Longrightarrow> xa = 0", "show \"xa = 0\""], ["proof (prove)\nusing this:\n  xa |\\<in>| {|0|} \\<longrightarrow> xa = 0\n  xa |\\<notin>| {|0|} \\<Longrightarrow> xa = 0\n\ngoal (1 subgoal):\n 1. xa = 0", "by blast"], ["proof (state)\nthis:\n  xa = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CONS_inj[simp]: \"size_atom x = #\\<^sub>V \\<AA> \\<Longrightarrow> size_atom y = #\\<^sub>V \\<AA> \\<Longrightarrow> #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB> \\<Longrightarrow>\n  CONS x \\<AA> = CONS y \\<BB> \\<longleftrightarrow> (x = y \\<and> \\<AA> = \\<BB>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>; size_atom y = #\\<^sub>V \\<AA>;\n     #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n    \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                      (x = y \\<and> \\<AA> = \\<BB>)", "by transfer (auto simp: list_eq_iff_nth_eq lift_def upshift_def split: if_splits; blast)"], ["", "lemma Suc_minus1: \"Suc (x - Suc 0) = (if x = 0 then Suc 0 else x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (x - Suc 0) = (if x = 0 then Suc 0 else x)", "by auto"], ["", "lemma fset_eq_empty_iff: \"(fset X = {}) = (X = {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fset X = {}) = (X = {||})", "by (metis bot_fset.rep_eq fset_inverse)"], ["", "lemma fset_le_singleton_iff: \"(fset X \\<subseteq> {x}) = (X = {||} \\<or> X = {|x|})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fset X \\<subseteq> {x}) = (X = {||} \\<or> X = {|x|})", "by (metis finsert.rep_eq fset_eq_empty_iff fset_inject order_refl singleton_insert_inj_eq subset_singletonD)"], ["", "lemma MSB_decreases:\n  \"MSB I \\<le> Suc m \\<Longrightarrow> MSB (map (\\<lambda>X. (\\<lambda>I1. I1 - Suc 0) |`| (X |-| {|0|})) I) \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MSB I \\<le> Suc m \\<Longrightarrow>\n    MSB (map (\\<lambda>X. (\\<lambda>I1. I1 - Suc 0) |`| (X |-| {|0|})) I)\n    \\<le> m", "unfolding MSB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>P\\<in>set I. P = {||} then 0\n     else Suc (Max (\\<Union> (fset ` set I))))\n    \\<le> Suc m \\<Longrightarrow>\n    (if \\<forall>P\\<in>set (map (\\<lambda>X.\n                                    (\\<lambda>I1. I1 - Suc 0) |`|\n                                    (X |-| {|0|}))\n                             I).\n           P = {||}\n     then 0\n     else Suc (Max (\\<Union>\n                     (fset `\n                      set (map (\\<lambda>X.\n                                   (\\<lambda>I1. I1 - Suc 0) |`|\n                                   (X |-| {|0|}))\n                            I)))))\n    \\<le> m", "by (auto simp add: not_le less_Suc_eq_le fset_eq_empty_iff fset_le_singleton_iff\n    split: if_splits dest!: iffD1[OF Max_le_iff, rotated -1] iffD1[OF Max_ge_iff, rotated -1]; force)"], ["", "lemma CONS_surj[dest]: \"Length \\<AA> > 0 \\<Longrightarrow>\n  \\<exists>x \\<BB>. \\<AA> = CONS x \\<BB> \\<and> #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and> size_atom x = #\\<^sub>V \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Length \\<AA> \\<Longrightarrow>\n    \\<exists>x \\<BB>.\n       \\<AA> = CONS x \\<BB> \\<and>\n       #\\<^sub>V \\<BB> = #\\<^sub>V \\<AA> \\<and>\n       size_atom x = #\\<^sub>V \\<AA>", "by transfer (auto simp: gr0_conv_Suc list_eq_iff_nth_eq lift_def upshift_def split: if_splits\n    intro!: exI[of _ \"map (\\<lambda>X. 0 |\\<in>| X) _\"] exI[of _ \"map (\\<lambda>X. (\\<lambda>x. x - Suc 0) |`| (X |-| {|0|})) _\"],\n    auto simp: MSB_decreases upshift_def Suc_minus1 fimage_iff intro: rev_fBexI split: if_splits)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}