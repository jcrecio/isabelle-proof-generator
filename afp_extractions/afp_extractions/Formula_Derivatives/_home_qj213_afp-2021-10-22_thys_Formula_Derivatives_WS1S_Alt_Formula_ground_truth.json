{"file_name": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives/WS1S_Alt_Formula.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formula_Derivatives", "problem_names": ["lemma fimage_Suc_fsubset0[simp]: \"Suc |`| A |\\<subseteq>| {|0|} \\<longleftrightarrow> A = {||}\"", "lemma fsubset_singleton_iff: \"A |\\<subseteq>| {|x|} \\<longleftrightarrow> A = {||} \\<or> A = {|x|}\"", "lemma check_eqv_code[code]: \"check_eqv idx r s =\n  ((ws1s_wf idx r \\<and> ws1s_lformula r) \\<and> (ws1s_wf idx s \\<and> ws1s_lformula s) \\<and>\n  (case rtrancl_while (\\<lambda>(p, q). final idx p = final idx q)\n    (\\<lambda>(p, q). map (\\<lambda>a. (norm (deriv lderiv0 a p), norm (deriv lderiv0 a q))) (\\<sigma> idx))\n    (norm (RESTRICT r), norm (RESTRICT s)) of\n    None \\<Rightarrow> False\n  | Some ([], x) \\<Rightarrow> True\n  | Some (a # list, x) \\<Rightarrow> False))\"", "lemma check_eqv_sound: \n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> (WS1S_Alt.sat \\<AA> \\<phi> \\<longleftrightarrow> WS1S_Alt.sat \\<AA> \\<psi>)\"", "lemma bounded_check_eqv_sound:\n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; bounded_check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> (WS1S_Alt.sat\\<^sub>b \\<AA> \\<phi> \\<longleftrightarrow> WS1S_Alt.sat\\<^sub>b \\<AA> \\<psi>)\""], "translations": [["", "lemma fimage_Suc_fsubset0[simp]: \"Suc |`| A |\\<subseteq>| {|0|} \\<longleftrightarrow> A = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc |`| A |\\<subseteq>| {|0|}) = (A = {||})", "by blast"], ["", "lemma fsubset_singleton_iff: \"A |\\<subseteq>| {|x|} \\<longleftrightarrow> A = {||} \\<or> A = {|x|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A |\\<subseteq>| {|x|}) = (A = {||} \\<or> A = {|x|})", "by blast"], ["", "definition \"restrict ord P = (case ord of FO \\<Rightarrow> \\<exists>x. P = {|x|} | SO \\<Rightarrow> True)\""], ["", "definition \"Restrict ord i = (case ord of FO \\<Rightarrow> FBase (Fo i) | SO \\<Rightarrow> FBool True)\""], ["", "declare [[goals_limit = 50]]"], ["", "global_interpretation WS1S_Alt: Formula SUC LESS assigns nvars Extend CONS SNOC Length\n  extend size_atom zero \\<sigma> eval downshift upshift finsert cut len restrict Restrict\n  lformula0 FV0 find0 wf0 decr0 satisfies0 nullable0 lderiv0 rderiv0 undefined\n  defines norm = \"Formula_Operations.norm find0 decr0\"\n  and nFOr = \"Formula_Operations.nFOr :: formula \\<Rightarrow> _\"\n  and nFAnd = \"Formula_Operations.nFAnd :: formula \\<Rightarrow> _\"\n  and nFNot = \"Formula_Operations.nFNot find0 decr0 :: formula \\<Rightarrow> _\"\n  and nFEx = \"Formula_Operations.nFEx find0 decr0\"\n  and nFAll = \"Formula_Operations.nFAll find0 decr0\"\n  and decr = \"Formula_Operations.decr decr0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula \\<Rightarrow> _\"\n  and find = \"Formula_Operations.find find0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula \\<Rightarrow> _\"\n  and FV = \"Formula_Operations.FV FV0\"\n  and RESTR = \"Formula_Operations.RESTR Restrict :: _ \\<Rightarrow> formula\"\n  and RESTRICT = \"Formula_Operations.RESTRICT Restrict FV0\"\n  and deriv = \"\\<lambda>d0 (a :: atom) (\\<phi> :: formula). Formula_Operations.deriv extend d0 a \\<phi>\"\n  and nullable = \"\\<lambda>\\<phi> :: formula. Formula_Operations.nullable nullable0 \\<phi>\"\n  and fut_default = \"Formula.fut_default extend zero rderiv0\"\n  and fut = \"Formula.fut extend zero find0 decr0 rderiv0\"\n  and finalize = \"Formula.finalize SUC extend zero find0 decr0 rderiv0\"\n  and final = \"Formula.final SUC extend zero find0 decr0\n     nullable0 rderiv0 :: idx \\<Rightarrow> formula \\<Rightarrow> _\"\n  and ws1s_wf = \"Formula_Operations.wf SUC (wf0 :: idx \\<Rightarrow> ws1s \\<Rightarrow> _)\"\n  and ws1s_lformula = \"Formula_Operations.lformula lformula0 :: formula \\<Rightarrow> _\"\n  and check_eqv = \"\\<lambda>idx. DAs.check_eqv\n    (\\<sigma> idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>) :: (ws1s, order) aformula)\n    (\\<lambda>a \\<phi>. norm (deriv (lderiv0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula) (a :: atom) \\<phi>))\n    (final idx) (\\<lambda>\\<phi> :: formula. ws1s_wf idx \\<phi> \\<and> ws1s_lformula \\<phi>)\n    (\\<sigma> idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>) :: (ws1s, order) aformula)\n    (\\<lambda>a \\<phi>. norm (deriv (lderiv0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula) (a :: atom) \\<phi>))\n    (final idx) (\\<lambda>\\<phi> :: formula. ws1s_wf idx \\<phi> \\<and> ws1s_lformula \\<phi>) (=)\"\n  and bounded_check_eqv = \"\\<lambda>idx. DAs.check_eqv\n    (\\<sigma> idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>) :: (ws1s, order) aformula)\n    (\\<lambda>a \\<phi>. norm (deriv (lderiv0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula) (a :: atom) \\<phi>))\n    nullable (\\<lambda>\\<phi> :: formula. ws1s_wf idx \\<phi> \\<and> ws1s_lformula \\<phi>)\n    (\\<sigma> idx) (\\<lambda>\\<phi>. norm (RESTRICT \\<phi>) :: (ws1s, order) aformula)\n    (\\<lambda>a \\<phi>. norm (deriv (lderiv0 :: _ \\<Rightarrow> _ \\<Rightarrow> formula) (a :: atom) \\<phi>))\n    nullable (\\<lambda>\\<phi> :: formula. ws1s_wf idx \\<phi> \\<and> ws1s_lformula \\<phi>) (=)\"\n  and automaton = \"DA.automaton\n    (\\<lambda>a \\<phi>. norm (deriv lderiv0 (a :: atom) \\<phi> :: formula))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Formula SUC LESS assigns nvars Extend CONS SNOC Length extend size_atom\n     zero \\<sigma> eval downshift upshift finsert WS1S_Prelim.cut len\n     restrict Restrict lformula0 FV0 find0 wf0 decr0 satisfies0 nullable0\n     lderiv0 rderiv0", "proof"], ["proof (state)\ngoal (54 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>k idx a l.\n        \\<lbrakk>wf0 (SUC k idx) a; LEQ k l idx; \\<not> find0 k l a\\<rbrakk>\n        \\<Longrightarrow> wf0 idx (decr0 k l a)\n 37. \\<And>\\<phi> k l.\n        lformula0 \\<phi> \\<Longrightarrow> lformula0 (decr0 k l \\<phi>)\n 38. \\<And>k i a \\<AA> P.\n        \\<lbrakk>\\<not> find0 k i a; LEQ k i (#\\<^sub>V \\<AA>);\n         lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk>\n        \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) a =\n                          satisfies0 \\<AA> (decr0 k i a)\n 39. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 40. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 41. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 42. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 43. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 44. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 45. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 46. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 47. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 48. \\<And>k a. finite (FV0 k a)\n 49. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 50. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\nA total of 54 subgoals...", "fix k idx and a :: ws1s and l"], ["proof (state)\ngoal (54 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>k idx a l.\n        \\<lbrakk>wf0 (SUC k idx) a; LEQ k l idx; \\<not> find0 k l a\\<rbrakk>\n        \\<Longrightarrow> wf0 idx (decr0 k l a)\n 37. \\<And>\\<phi> k l.\n        lformula0 \\<phi> \\<Longrightarrow> lformula0 (decr0 k l \\<phi>)\n 38. \\<And>k i a \\<AA> P.\n        \\<lbrakk>\\<not> find0 k i a; LEQ k i (#\\<^sub>V \\<AA>);\n         lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk>\n        \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) a =\n                          satisfies0 \\<AA> (decr0 k i a)\n 39. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 40. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 41. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 42. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 43. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 44. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 45. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 46. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 47. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 48. \\<And>k a. finite (FV0 k a)\n 49. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 50. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\nA total of 54 subgoals...", "assume \"wf0 (SUC k idx) a\" \"LESS k l (SUC k idx)\" \"\\<not> find0 k l a\""], ["proof (state)\nthis:\n  wf0 (SUC k idx) a\n  LEQ k l idx\n  \\<not> find0 k l a\n\ngoal (54 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>k idx a l.\n        \\<lbrakk>wf0 (SUC k idx) a; LEQ k l idx; \\<not> find0 k l a\\<rbrakk>\n        \\<Longrightarrow> wf0 idx (decr0 k l a)\n 37. \\<And>\\<phi> k l.\n        lformula0 \\<phi> \\<Longrightarrow> lformula0 (decr0 k l \\<phi>)\n 38. \\<And>k i a \\<AA> P.\n        \\<lbrakk>\\<not> find0 k i a; LEQ k i (#\\<^sub>V \\<AA>);\n         lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk>\n        \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) a =\n                          satisfies0 \\<AA> (decr0 k i a)\n 39. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 40. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 41. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 42. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 43. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 44. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 45. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 46. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 47. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 48. \\<And>k a. finite (FV0 k a)\n 49. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 50. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\nA total of 54 subgoals...", "then"], ["proof (chain)\npicking this:\n  wf0 (SUC k idx) a\n  LEQ k l idx\n  \\<not> find0 k l a", "show \"wf0 idx (decr0 k l a)\""], ["proof (prove)\nusing this:\n  wf0 (SUC k idx) a\n  LEQ k l idx\n  \\<not> find0 k l a\n\ngoal (1 subgoal):\n 1. wf0 idx (decr0 k l a)", "by (induct a) (unfold wf0.simps atomic.map find0.simps,\n     (transfer, force simp: dec_def split: if_splits order.splits)+) \\<comment> \\<open>slow\\<close>"], ["proof (state)\nthis:\n  wf0 idx (decr0 k l a)\n\ngoal (53 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<phi> k l.\n        lformula0 \\<phi> \\<Longrightarrow> lformula0 (decr0 k l \\<phi>)\n 37. \\<And>k i a \\<AA> P.\n        \\<lbrakk>\\<not> find0 k i a; LEQ k i (#\\<^sub>V \\<AA>);\n         lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk>\n        \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) a =\n                          satisfies0 \\<AA> (decr0 k i a)\n 38. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 39. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 40. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 41. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 42. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 44. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 45. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 46. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 47. \\<And>k a. finite (FV0 k a)\n 48. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 49. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 50. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\nA total of 53 subgoals...", "next"], ["proof (state)\ngoal (53 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<phi> k l.\n        lformula0 \\<phi> \\<Longrightarrow> lformula0 (decr0 k l \\<phi>)\n 37. \\<And>k i a \\<AA> P.\n        \\<lbrakk>\\<not> find0 k i a; LEQ k i (#\\<^sub>V \\<AA>);\n         lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk>\n        \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) a =\n                          satisfies0 \\<AA> (decr0 k i a)\n 38. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 39. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 40. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 41. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 42. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 44. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 45. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 46. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 47. \\<And>k a. finite (FV0 k a)\n 48. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 49. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 50. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\nA total of 53 subgoals...", "fix k and a :: ws1s and l"], ["proof (state)\ngoal (53 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<phi> k l.\n        lformula0 \\<phi> \\<Longrightarrow> lformula0 (decr0 k l \\<phi>)\n 37. \\<And>k i a \\<AA> P.\n        \\<lbrakk>\\<not> find0 k i a; LEQ k i (#\\<^sub>V \\<AA>);\n         lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk>\n        \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) a =\n                          satisfies0 \\<AA> (decr0 k i a)\n 38. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 39. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 40. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 41. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 42. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 44. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 45. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 46. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 47. \\<And>k a. finite (FV0 k a)\n 48. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 49. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 50. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\nA total of 53 subgoals...", "assume \"lformula0 a\""], ["proof (state)\nthis:\n  lformula0 a\n\ngoal (53 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<phi> k l.\n        lformula0 \\<phi> \\<Longrightarrow> lformula0 (decr0 k l \\<phi>)\n 37. \\<And>k i a \\<AA> P.\n        \\<lbrakk>\\<not> find0 k i a; LEQ k i (#\\<^sub>V \\<AA>);\n         lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk>\n        \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) a =\n                          satisfies0 \\<AA> (decr0 k i a)\n 38. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 39. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 40. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 41. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 42. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 44. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 45. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 46. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 47. \\<And>k a. finite (FV0 k a)\n 48. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 49. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 50. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\nA total of 53 subgoals...", "then"], ["proof (chain)\npicking this:\n  lformula0 a", "show \"lformula0 (decr0 k l a)\""], ["proof (prove)\nusing this:\n  lformula0 a\n\ngoal (1 subgoal):\n 1. lformula0 (decr0 k l a)", "by (induct a) auto"], ["proof (state)\nthis:\n  lformula0 (decr0 k l a)\n\ngoal (52 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>k i a \\<AA> P.\n        \\<lbrakk>\\<not> find0 k i a; LEQ k i (#\\<^sub>V \\<AA>);\n         lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk>\n        \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) a =\n                          satisfies0 \\<AA> (decr0 k i a)\n 37. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 38. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 39. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 40. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 41. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 44. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 45. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 46. \\<And>k a. finite (FV0 k a)\n 47. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 48. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 49. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 50. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\nA total of 52 subgoals...", "next"], ["proof (state)\ngoal (52 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>k i a \\<AA> P.\n        \\<lbrakk>\\<not> find0 k i a; LEQ k i (#\\<^sub>V \\<AA>);\n         lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk>\n        \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) a =\n                          satisfies0 \\<AA> (decr0 k i a)\n 37. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 38. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 39. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 40. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 41. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 44. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 45. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 46. \\<And>k a. finite (FV0 k a)\n 47. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 48. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 49. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 50. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\nA total of 52 subgoals...", "fix i k and a :: ws1s and \\<AA> :: interp and P"], ["proof (state)\ngoal (52 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>k i a \\<AA> P.\n        \\<lbrakk>\\<not> find0 k i a; LEQ k i (#\\<^sub>V \\<AA>);\n         lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk>\n        \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) a =\n                          satisfies0 \\<AA> (decr0 k i a)\n 37. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 38. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 39. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 40. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 41. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 44. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 45. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 46. \\<And>k a. finite (FV0 k a)\n 47. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 48. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 49. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 50. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\nA total of 52 subgoals...", "assume *: \"\\<not> find0 k i a\" \"LESS k i (SUC k (#\\<^sub>V \\<AA>))\"\n    and disj: \"lformula0 a \\<or> len P \\<le> Length \\<AA>\""], ["proof (state)\nthis:\n  \\<not> find0 k i a\n  LEQ k i (#\\<^sub>V \\<AA>)\n  lformula0 a \\<or> len P \\<le> Length \\<AA>\n\ngoal (52 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>k i a \\<AA> P.\n        \\<lbrakk>\\<not> find0 k i a; LEQ k i (#\\<^sub>V \\<AA>);\n         lformula0 a \\<or> len P \\<le> Length \\<AA>\\<rbrakk>\n        \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) a =\n                          satisfies0 \\<AA> (decr0 k i a)\n 37. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 38. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 39. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 40. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 41. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 44. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 45. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 46. \\<And>k a. finite (FV0 k a)\n 47. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 48. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 49. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 50. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\nA total of 52 subgoals...", "from disj"], ["proof (chain)\npicking this:\n  lformula0 a \\<or> len P \\<le> Length \\<AA>", "show \"satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)\""], ["proof (prove)\nusing this:\n  lformula0 a \\<or> len P \\<le> Length \\<AA>\n\ngoal (1 subgoal):\n 1. satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lformula0 a \\<Longrightarrow>\n    satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)\n 2. len P \\<le> Length \\<AA> \\<Longrightarrow>\n    satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)", "assume \"lformula0 a\""], ["proof (state)\nthis:\n  lformula0 a\n\ngoal (2 subgoals):\n 1. lformula0 a \\<Longrightarrow>\n    satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)\n 2. len P \\<le> Length \\<AA> \\<Longrightarrow>\n    satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)", "then"], ["proof (chain)\npicking this:\n  lformula0 a", "show ?thesis"], ["proof (prove)\nusing this:\n  lformula0 a\n\ngoal (1 subgoal):\n 1. satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)", "using *"], ["proof (prove)\nusing this:\n  lformula0 a\n  \\<not> find0 k i a\n  LEQ k i (#\\<^sub>V \\<AA>)\n\ngoal (1 subgoal):\n 1. satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)", "by (induct a)\n        (auto simp: dec_def split: if_splits order.split option.splits bool.splits) \\<comment> \\<open>slow\\<close>"], ["proof (state)\nthis:\n  satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)\n\ngoal (1 subgoal):\n 1. len P \\<le> Length \\<AA> \\<Longrightarrow>\n    satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. len P \\<le> Length \\<AA> \\<Longrightarrow>\n    satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)", "assume \"len P \\<le> Length \\<AA>\""], ["proof (state)\nthis:\n  len P \\<le> Length \\<AA>\n\ngoal (1 subgoal):\n 1. len P \\<le> Length \\<AA> \\<Longrightarrow>\n    satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)", "with *"], ["proof (chain)\npicking this:\n  \\<not> find0 k i a\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> find0 k i a\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n\ngoal (1 subgoal):\n 1. satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)", "proof (induct a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> find0 k i (Fo x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Fo x) =\n                         satisfies0 \\<AA> (decr0 k i (Fo x))\n 2. \\<And>x.\n       \\<lbrakk>\\<not> find0 k i (Z x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Z x) =\n                         satisfies0 \\<AA> (decr0 k i (Z x))\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (Less x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Less x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (Less x1a x2a))\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (In x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (In x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (In x1a x2a))", "case Fo"], ["proof (state)\nthis:\n  \\<not> find0 k i (Fo x_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> find0 k i (Fo x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Fo x) =\n                         satisfies0 \\<AA> (decr0 k i (Fo x))\n 2. \\<And>x.\n       \\<lbrakk>\\<not> find0 k i (Z x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Z x) =\n                         satisfies0 \\<AA> (decr0 k i (Z x))\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (Less x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Less x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (Less x1a x2a))\n 4. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (In x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (In x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (In x1a x2a))", "then"], ["proof (chain)\npicking this:\n  \\<not> find0 k i (Fo x_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> find0 k i (Fo x_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n\ngoal (1 subgoal):\n 1. satisfies0 (Extend k i \\<AA> P) (Fo x_) =\n    satisfies0 \\<AA> (decr0 k i (Fo x_))", "by (cases k) (auto simp: dec_def)"], ["proof (state)\nthis:\n  satisfies0 (Extend k i \\<AA> P) (Fo x_) =\n  satisfies0 \\<AA> (decr0 k i (Fo x_))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> find0 k i (Z x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Z x) =\n                         satisfies0 \\<AA> (decr0 k i (Z x))\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (Less x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Less x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (Less x1a x2a))\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (In x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (In x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (In x1a x2a))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> find0 k i (Z x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Z x) =\n                         satisfies0 \\<AA> (decr0 k i (Z x))\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (Less x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Less x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (Less x1a x2a))\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (In x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (In x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (In x1a x2a))", "case Z"], ["proof (state)\nthis:\n  \\<not> find0 k i (Z x_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> find0 k i (Z x); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Z x) =\n                         satisfies0 \\<AA> (decr0 k i (Z x))\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (Less x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Less x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (Less x1a x2a))\n 3. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (In x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (In x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (In x1a x2a))", "then"], ["proof (chain)\npicking this:\n  \\<not> find0 k i (Z x_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> find0 k i (Z x_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n\ngoal (1 subgoal):\n 1. satisfies0 (Extend k i \\<AA> P) (Z x_) =\n    satisfies0 \\<AA> (decr0 k i (Z x_))", "by (cases k) (auto simp: dec_def)"], ["proof (state)\nthis:\n  satisfies0 (Extend k i \\<AA> P) (Z x_) =\n  satisfies0 \\<AA> (decr0 k i (Z x_))\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (Less x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Less x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (Less x1a x2a))\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (In x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (In x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (In x1a x2a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (Less x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Less x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (Less x1a x2a))\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (In x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (In x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (In x1a x2a))", "case Less"], ["proof (state)\nthis:\n  \\<not> find0 k i (Less x1a_ x2a_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (Less x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (Less x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (Less x1a x2a))\n 2. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (In x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (In x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (In x1a x2a))", "then"], ["proof (chain)\npicking this:\n  \\<not> find0 k i (Less x1a_ x2a_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> find0 k i (Less x1a_ x2a_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n\ngoal (1 subgoal):\n 1. satisfies0 (Extend k i \\<AA> P) (Less x1a_ x2a_) =\n    satisfies0 \\<AA> (decr0 k i (Less x1a_ x2a_))", "by (cases k) (auto simp: dec_def)"], ["proof (state)\nthis:\n  satisfies0 (Extend k i \\<AA> P) (Less x1a_ x2a_) =\n  satisfies0 \\<AA> (decr0 k i (Less x1a_ x2a_))\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (In x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (In x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (In x1a x2a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (In x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (In x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (In x1a x2a))", "case In"], ["proof (state)\nthis:\n  \\<not> find0 k i (In x1a_ x2a_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a.\n       \\<lbrakk>\\<not> find0 k i (In x1a x2a); LEQ k i (#\\<^sub>V \\<AA>);\n        len P \\<le> Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> satisfies0 (Extend k i \\<AA> P) (In x1a x2a) =\n                         satisfies0 \\<AA> (decr0 k i (In x1a x2a))", "then"], ["proof (chain)\npicking this:\n  \\<not> find0 k i (In x1a_ x2a_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> find0 k i (In x1a_ x2a_)\n  LEQ k i (#\\<^sub>V \\<AA>)\n  len P \\<le> Length \\<AA>\n\ngoal (1 subgoal):\n 1. satisfies0 (Extend k i \\<AA> P) (In x1a_ x2a_) =\n    satisfies0 \\<AA> (decr0 k i (In x1a_ x2a_))", "by (cases k) (auto simp: dec_def)"], ["proof (state)\nthis:\n  satisfies0 (Extend k i \\<AA> P) (In x1a_ x2a_) =\n  satisfies0 \\<AA> (decr0 k i (In x1a_ x2a_))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  satisfies0 (Extend k i \\<AA> P) a = satisfies0 \\<AA> (decr0 k i a)\n\ngoal (51 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 39. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 40. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 44. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 45. \\<And>k a. finite (FV0 k a)\n 46. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 47. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 48. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 49. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 50. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\nA total of 51 subgoals...", "next"], ["proof (state)\ngoal (51 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 39. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 40. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 44. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 45. \\<And>k a. finite (FV0 k a)\n 46. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 47. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 48. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 49. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 50. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\nA total of 51 subgoals...", "fix idx and a :: ws1s and x"], ["proof (state)\ngoal (51 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 39. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 40. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 44. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 45. \\<And>k a. finite (FV0 k a)\n 46. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 47. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 48. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 49. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 50. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\nA total of 51 subgoals...", "assume \"lformula0 a\" \"wf0 idx a\""], ["proof (state)\nthis:\n  lformula0 a\n  wf0 idx a\n\ngoal (51 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>idx a x.\n        \\<lbrakk>wf0 idx a; lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n 39. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 40. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 43. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 44. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 45. \\<And>k a. finite (FV0 k a)\n 46. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 47. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 48. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 49. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 50. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\nA total of 51 subgoals...", "then"], ["proof (chain)\npicking this:\n  lformula0 a\n  wf0 idx a", "show \"Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\""], ["proof (prove)\nusing this:\n  lformula0 a\n  wf0 idx a\n\ngoal (1 subgoal):\n 1. Formula_Operations.wf SUC wf0 idx (lderiv0 x a)", "by (induct a rule: lderiv0.induct)\n      (auto simp: Formula_Operations.wf.simps Let_def split: bool.splits order.splits)"], ["proof (state)\nthis:\n  Formula_Operations.wf SUC wf0 idx (lderiv0 x a)\n\ngoal (50 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 39. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 43. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 44. \\<And>k a. finite (FV0 k a)\n 45. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 46. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 47. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 48. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 49. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 50. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "next"], ["proof (state)\ngoal (50 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 39. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 43. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 44. \\<And>k a. finite (FV0 k a)\n 45. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 46. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 47. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 48. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 49. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 50. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "fix a :: ws1s and x"], ["proof (state)\ngoal (50 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 39. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 43. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 44. \\<And>k a. finite (FV0 k a)\n 45. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 46. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 47. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 48. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 49. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 50. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "assume \"lformula0 a\""], ["proof (state)\nthis:\n  lformula0 a\n\ngoal (50 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>a x.\n        lformula0 a \\<Longrightarrow>\n        Formula_Operations.lformula lformula0 (lderiv0 x a)\n 39. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 42. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 43. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 44. \\<And>k a. finite (FV0 k a)\n 45. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 46. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 47. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 48. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 49. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 50. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "then"], ["proof (chain)\npicking this:\n  lformula0 a", "show \"Formula_Operations.lformula lformula0 (lderiv0 x a)\""], ["proof (prove)\nusing this:\n  lformula0 a\n\ngoal (1 subgoal):\n 1. Formula_Operations.lformula lformula0 (lderiv0 x a)", "by (induct a rule: lderiv0.induct)\n      (auto simp: Formula_Operations.lformula.simps split: bool.splits)"], ["proof (state)\nthis:\n  Formula_Operations.lformula lformula0 (lderiv0 x a)\n\ngoal (49 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 42. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 43. \\<And>k a. finite (FV0 k a)\n 44. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 45. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 46. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 47. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 48. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 49. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "next"], ["proof (state)\ngoal (49 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 42. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 43. \\<And>k a. finite (FV0 k a)\n 44. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 45. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 46. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 47. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 48. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 49. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "fix idx and a :: ws1s and x"], ["proof (state)\ngoal (49 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 42. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 43. \\<And>k a. finite (FV0 k a)\n 44. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 45. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 46. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 47. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 48. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 49. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "assume \"wf0 idx a\""], ["proof (state)\nthis:\n  wf0 idx a\n\ngoal (49 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>idx a x.\n        wf0 idx a \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 41. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 42. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 43. \\<And>k a. finite (FV0 k a)\n 44. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 45. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 46. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 47. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 48. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 49. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "then"], ["proof (chain)\npicking this:\n  wf0 idx a", "show \"Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\""], ["proof (prove)\nusing this:\n  wf0 idx a\n\ngoal (1 subgoal):\n 1. Formula_Operations.wf SUC wf0 idx (rderiv0 x a)", "by (induct a rule: lderiv0.induct)\n      (auto simp: Formula_Operations.wf.simps Let_def sorted_append\n        split: bool.splits order.splits nat.splits)"], ["proof (state)\nthis:\n  Formula_Operations.wf SUC wf0 idx (rderiv0 x a)\n\ngoal (48 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 41. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 42. \\<And>k a. finite (FV0 k a)\n 43. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 44. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 45. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 46. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 47. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 48. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "next"], ["proof (state)\ngoal (48 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 41. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 42. \\<And>k a. finite (FV0 k a)\n 43. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 44. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 45. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 46. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 47. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 48. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "fix \\<AA> :: interp and a :: ws1s"], ["proof (state)\ngoal (48 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 41. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 42. \\<And>k a. finite (FV0 k a)\n 43. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 44. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 45. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 46. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 47. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 48. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "note fmember.rep_eq[symmetric, simp]"], ["proof (state)\nthis:\n  (?x \\<in> fset ?xa) = (?x |\\<in>| ?xa)\n\ngoal (48 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 41. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 42. \\<And>k a. finite (FV0 k a)\n 43. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 44. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 45. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 46. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 47. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 48. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "assume \"Length \\<AA> = 0\""], ["proof (state)\nthis:\n  Length \\<AA> = 0\n\ngoal (48 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<AA> a.\n        Length \\<AA> = 0 \\<Longrightarrow> nullable0 a = satisfies0 \\<AA> a\n 37. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 40. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 41. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 42. \\<And>k a. finite (FV0 k a)\n 43. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 44. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 45. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 46. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 47. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 48. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "then"], ["proof (chain)\npicking this:\n  Length \\<AA> = 0", "show \"nullable0 a = satisfies0 \\<AA> a\""], ["proof (prove)\nusing this:\n  Length \\<AA> = 0\n\ngoal (1 subgoal):\n 1. nullable0 a = satisfies0 \\<AA> a", "by (induct a, unfold wf0.simps nullable0.simps satisfies0.simps Let_def)\n      (transfer, (auto 0 3 dest: MSB_greater split: prod.splits if_splits option.splits bool.splits nat.splits) [])+  \\<comment> \\<open>slow\\<close>"], ["proof (state)\nthis:\n  nullable0 a = satisfies0 \\<AA> a\n\ngoal (47 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 40. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 41. \\<And>k a. finite (FV0 k a)\n 42. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 43. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 44. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 45. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 46. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 47. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "next"], ["proof (state)\ngoal (47 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 40. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 41. \\<And>k a. finite (FV0 k a)\n 42. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 43. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 44. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 45. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 46. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 47. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "note Formula_Operations.satisfies_gen.simps[simp] Let_def[simp] upshift_def[simp]"], ["proof (state)\nthis:\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FBool ?b) =\n  ?b\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FBase ?a) =\n  ?satisfies0.0 ?\\<AA> ?a\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FNot ?\\<phi>) =\n  (\\<not> Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r\n           ?\\<AA> ?\\<phi>)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FOr ?\\<phi>\\<^sub>1 ?\\<phi>\\<^sub>2) =\n  (Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>1 \\<or>\n   Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>2)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FAnd ?\\<phi>\\<^sub>1 ?\\<phi>\\<^sub>2) =\n  (Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>1 \\<and>\n   Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>2)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FEx ?k ?\\<phi>) =\n  (\\<exists>P.\n      ?r ?k P (?Length ?\\<AA>) \\<and>\n      Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r\n       (?Extend ?k 0 ?\\<AA> P) ?\\<phi>)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FAll ?k ?\\<phi>) =\n  (\\<forall>P.\n      ?r ?k P (?Length ?\\<AA>) \\<longrightarrow>\n      Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r\n       (?Extend ?k 0 ?\\<AA> P) ?\\<phi>)\n  Let ?s ?f \\<equiv> ?f ?s\n  upshift ?P = Suc |`| ?P\n\ngoal (47 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 40. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 41. \\<And>k a. finite (FV0 k a)\n 42. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 43. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 44. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 45. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 46. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 47. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "fix x :: atom and a :: ws1s and \\<AA> :: interp"], ["proof (state)\ngoal (47 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 40. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 41. \\<And>k a. finite (FV0 k a)\n 42. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 43. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 44. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 45. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 46. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 47. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "assume \"lformula0 a\" \"wf0 (#\\<^sub>V \\<AA>) a\" \"#\\<^sub>V \\<AA> = size_atom x\""], ["proof (state)\nthis:\n  lformula0 a\n  wf0 (#\\<^sub>V \\<AA>) a\n  #\\<^sub>V \\<AA> = size_atom x\n\ngoal (47 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 39. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 40. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 41. \\<And>k a. finite (FV0 k a)\n 42. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 43. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 44. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 45. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 46. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 47. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "then"], ["proof (chain)\npicking this:\n  lformula0 a\n  wf0 (#\\<^sub>V \\<AA>) a\n  #\\<^sub>V \\<AA> = size_atom x", "show \"Formula_Operations.satisfies Extend Length satisfies0 \\<AA> (lderiv0 x a) =\n     satisfies0 (CONS x \\<AA>) a\""], ["proof (prove)\nusing this:\n  lformula0 a\n  wf0 (#\\<^sub>V \\<AA>) a\n  #\\<^sub>V \\<AA> = size_atom x\n\ngoal (1 subgoal):\n 1. Formula_Operations.satisfies_gen Extend Length satisfies0\n     (\\<lambda>_ _ _. True) \\<AA> (lderiv0 x a) =\n    satisfies0 (CONS x \\<AA>) a", "proof (induct a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Fo m);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                          (lderiv0 x (Fo m)) =\n                         satisfies0 (CONS x \\<AA>) (Fo m)\n 2. \\<And>m.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Z m);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                          (lderiv0 x (Z m)) =\n                         satisfies0 (CONS x \\<AA>) (Z m)\n 3. \\<And>m1 m2.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Less m1 m2);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                          (lderiv0 x (Less m1 m2)) =\n                         satisfies0 (CONS x \\<AA>) (Less m1 m2)\n 4. \\<And>m M.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (In m M);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ _ _. True) \\<AA>\n                          (lderiv0 x (In m M)) =\n                         satisfies0 (CONS x \\<AA>) (In m M)", "qed (auto split: prod.splits bool.splits)"], ["proof (state)\nthis:\n  Formula_Operations.satisfies_gen Extend Length satisfies0\n   (\\<lambda>_ _ _. True) \\<AA> (lderiv0 x a) =\n  satisfies0 (CONS x \\<AA>) a\n\ngoal (46 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 39. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 40. \\<And>k a. finite (FV0 k a)\n 41. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 42. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 43. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 44. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 45. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 46. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "next"], ["proof (state)\ngoal (46 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 39. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 40. \\<And>k a. finite (FV0 k a)\n 41. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 42. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 43. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 44. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 45. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 46. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "note Formula_Operations.satisfies_gen.simps[simp] Let_def[simp] upshift_def[simp]"], ["proof (state)\nthis:\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FBool ?b) =\n  ?b\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FBase ?a) =\n  ?satisfies0.0 ?\\<AA> ?a\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FNot ?\\<phi>) =\n  (\\<not> Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r\n           ?\\<AA> ?\\<phi>)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FOr ?\\<phi>\\<^sub>1 ?\\<phi>\\<^sub>2) =\n  (Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>1 \\<or>\n   Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>2)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FAnd ?\\<phi>\\<^sub>1 ?\\<phi>\\<^sub>2) =\n  (Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>1 \\<and>\n   Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>2)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FEx ?k ?\\<phi>) =\n  (\\<exists>P.\n      ?r ?k P (?Length ?\\<AA>) \\<and>\n      Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r\n       (?Extend ?k 0 ?\\<AA> P) ?\\<phi>)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FAll ?k ?\\<phi>) =\n  (\\<forall>P.\n      ?r ?k P (?Length ?\\<AA>) \\<longrightarrow>\n      Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r\n       (?Extend ?k 0 ?\\<AA> P) ?\\<phi>)\n  Let ?s ?f \\<equiv> ?f ?s\n  upshift ?P = Suc |`| ?P\n\ngoal (46 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 39. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 40. \\<And>k a. finite (FV0 k a)\n 41. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 42. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 43. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 44. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 45. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 46. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "fix x :: atom and a :: ws1s and \\<AA> :: interp"], ["proof (state)\ngoal (46 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 39. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 40. \\<And>k a. finite (FV0 k a)\n 41. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 42. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 43. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 44. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 45. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 46. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "assume \"lformula0 a\" \"wf0 (#\\<^sub>V \\<AA>) a\" \"#\\<^sub>V \\<AA> = size_atom x\""], ["proof (state)\nthis:\n  lformula0 a\n  wf0 (#\\<^sub>V \\<AA>) a\n  #\\<^sub>V \\<AA> = size_atom x\n\ngoal (46 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a; #\\<^sub>V \\<AA> = size_atom x;\n         lformula0 a\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (lderiv0 x a) =\n                          satisfies0 (CONS x \\<AA>) a\n 38. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 39. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 40. \\<And>k a. finite (FV0 k a)\n 41. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 42. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 43. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 44. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 45. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 46. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "then"], ["proof (chain)\npicking this:\n  lformula0 a\n  wf0 (#\\<^sub>V \\<AA>) a\n  #\\<^sub>V \\<AA> = size_atom x", "show \"Formula_Operations.satisfies_bounded Extend Length len satisfies0 \\<AA> (lderiv0 x a) =\n     satisfies0 (CONS x \\<AA>) a\""], ["proof (prove)\nusing this:\n  lformula0 a\n  wf0 (#\\<^sub>V \\<AA>) a\n  #\\<^sub>V \\<AA> = size_atom x\n\ngoal (1 subgoal):\n 1. Formula_Operations.satisfies_gen Extend Length satisfies0\n     (\\<lambda>_ P. (\\<le>) (len P)) \\<AA> (lderiv0 x a) =\n    satisfies0 (CONS x \\<AA>) a", "by (induct a) (auto split: prod.splits bool.splits)"], ["proof (state)\nthis:\n  Formula_Operations.satisfies_gen Extend Length satisfies0\n   (\\<lambda>_ P. (\\<le>) (len P)) \\<AA> (lderiv0 x a) =\n  satisfies0 (CONS x \\<AA>) a\n\ngoal (45 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 38. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 39. \\<And>k a. finite (FV0 k a)\n 40. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 41. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 42. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 43. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 44. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 45. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "next"], ["proof (state)\ngoal (45 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 38. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 39. \\<And>k a. finite (FV0 k a)\n 40. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 41. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 42. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 43. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 44. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 45. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "note Formula_Operations.satisfies_gen.simps[simp] Let_def[simp]"], ["proof (state)\nthis:\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FBool ?b) =\n  ?b\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FBase ?a) =\n  ?satisfies0.0 ?\\<AA> ?a\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FNot ?\\<phi>) =\n  (\\<not> Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r\n           ?\\<AA> ?\\<phi>)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FOr ?\\<phi>\\<^sub>1 ?\\<phi>\\<^sub>2) =\n  (Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>1 \\<or>\n   Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>2)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FAnd ?\\<phi>\\<^sub>1 ?\\<phi>\\<^sub>2) =\n  (Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>1 \\<and>\n   Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n    ?\\<phi>\\<^sub>2)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FEx ?k ?\\<phi>) =\n  (\\<exists>P.\n      ?r ?k P (?Length ?\\<AA>) \\<and>\n      Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r\n       (?Extend ?k 0 ?\\<AA> P) ?\\<phi>)\n  Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r ?\\<AA>\n   (FAll ?k ?\\<phi>) =\n  (\\<forall>P.\n      ?r ?k P (?Length ?\\<AA>) \\<longrightarrow>\n      Formula_Operations.satisfies_gen ?Extend ?Length ?satisfies0.0 ?r\n       (?Extend ?k 0 ?\\<AA> P) ?\\<phi>)\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (45 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 38. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 39. \\<And>k a. finite (FV0 k a)\n 40. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 41. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 42. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 43. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 44. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 45. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "fix x :: atom and a :: ws1s and \\<AA> :: interp"], ["proof (state)\ngoal (45 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 38. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 39. \\<And>k a. finite (FV0 k a)\n 40. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 41. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 42. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 43. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 44. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 45. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "assume \"wf0 (#\\<^sub>V \\<AA>) a\" \"#\\<^sub>V \\<AA> = size_atom x\""], ["proof (state)\nthis:\n  wf0 (#\\<^sub>V \\<AA>) a\n  #\\<^sub>V \\<AA> = size_atom x\n\ngoal (45 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>\\<AA> a x.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) a;\n         #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n        \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                           satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                           (rderiv0 x a) =\n                          satisfies0 (SNOC x \\<AA>) a\n 38. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 39. \\<And>k a. finite (FV0 k a)\n 40. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 41. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 42. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 43. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 44. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 45. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "then"], ["proof (chain)\npicking this:\n  wf0 (#\\<^sub>V \\<AA>) a\n  #\\<^sub>V \\<AA> = size_atom x", "show \"Formula_Operations.satisfies_bounded Extend Length len satisfies0 \\<AA> (rderiv0 x a) =\n     satisfies0 (SNOC x \\<AA>) a\""], ["proof (prove)\nusing this:\n  wf0 (#\\<^sub>V \\<AA>) a\n  #\\<^sub>V \\<AA> = size_atom x\n\ngoal (1 subgoal):\n 1. Formula_Operations.satisfies_gen Extend Length satisfies0\n     (\\<lambda>_ P. (\\<le>) (len P)) \\<AA> (rderiv0 x a) =\n    satisfies0 (SNOC x \\<AA>) a", "proof (induct a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Fo xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Fo xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Fo xa)\n 2. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Z xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Z xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Z xa)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Less x1a x2a);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Less x1a x2a)) =\n                         satisfies0 (SNOC x \\<AA>) (Less x1a x2a)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (In x1a x2a);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (In x1a x2a)) =\n                         satisfies0 (SNOC x \\<AA>) (In x1a x2a)", "case Less"], ["proof (state)\nthis:\n  wf0 (#\\<^sub>V \\<AA>) (Less x1a_ x2a_)\n  #\\<^sub>V \\<AA> = size_atom x\n\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Fo xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Fo xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Fo xa)\n 2. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Z xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Z xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Z xa)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Less x1a x2a);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Less x1a x2a)) =\n                         satisfies0 (SNOC x \\<AA>) (Less x1a x2a)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (In x1a x2a);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (In x1a x2a)) =\n                         satisfies0 (SNOC x \\<AA>) (In x1a x2a)", "then"], ["proof (chain)\npicking this:\n  wf0 (#\\<^sub>V \\<AA>) (Less x1a_ x2a_)\n  #\\<^sub>V \\<AA> = size_atom x", "show ?case"], ["proof (prove)\nusing this:\n  wf0 (#\\<^sub>V \\<AA>) (Less x1a_ x2a_)\n  #\\<^sub>V \\<AA> = size_atom x\n\ngoal (1 subgoal):\n 1. Formula_Operations.satisfies_gen Extend Length satisfies0\n     (\\<lambda>_ P. (\\<le>) (len P)) \\<AA> (rderiv0 x (Less x1a_ x2a_)) =\n    satisfies0 (SNOC x \\<AA>) (Less x1a_ x2a_)", "apply (auto 2 0 split: prod.splits option.splits bool.splits)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        \\<forall>x. x1a_\\<^bsup>\\<AA>\\<^esup>FO \\<noteq> {|x|};\n        x = (x1, x2); x1 ! x1a_; x1 ! x2a_;\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO |\\<subseteq>| {|Length \\<AA>|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO |\\<subseteq>| {|Length \\<AA>|};\n        fthe_elem (finsert (Length \\<AA>) (x1a_\\<^bsup>\\<AA>\\<^esup>FO))\n        < fthe_elem\n           (finsert (Length \\<AA>) (x2a_\\<^bsup>\\<AA>\\<^esup>FO))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x1 x2 xa.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        \\<forall>x. x1a_\\<^bsup>\\<AA>\\<^esup>FO \\<noteq> {|x|};\n        x = (x1, x2); x1 ! x1a_; \\<not> x1 ! x2a_;\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO |\\<subseteq>| {|Length \\<AA>|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|};\n        fthe_elem (finsert (Length \\<AA>) (x1a_\\<^bsup>\\<AA>\\<^esup>FO))\n        < xa\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x1 x2.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        \\<forall>x. x2a_\\<^bsup>\\<AA>\\<^esup>FO \\<noteq> {|x|};\n        x = (x1, x2); x1 ! x1a_; x1 ! x2a_;\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO |\\<subseteq>| {|Length \\<AA>|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO |\\<subseteq>| {|Length \\<AA>|};\n        fthe_elem (finsert (Length \\<AA>) (x1a_\\<^bsup>\\<AA>\\<^esup>FO))\n        < fthe_elem\n           (finsert (Length \\<AA>) (x2a_\\<^bsup>\\<AA>\\<^esup>FO))\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x1 x2 xa.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2)); \\<forall>x. {||} \\<noteq> {|x|};\n        x = (x1, x2); \\<not> x1 ! x1a_; x1 ! x2a_;\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {||}\\<rbrakk>\n       \\<Longrightarrow> xa < Length \\<AA>\n 5. \\<And>x1 xa x2.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|Length \\<AA>|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|}; x = (x1, x2); x1 ! x1a_;\n        \\<not> x1 ! x2a_; Length \\<AA> < xa\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x1 xa x2.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {|Length \\<AA>|}; x = (x1, x2);\n        \\<not> x1 ! x1a_; x1 ! x2a_; xa < Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp add: fsubset_singleton_iff)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 xa.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2)); \\<forall>x. {||} \\<noteq> {|x|};\n        x = (x1, x2); x1 ! x1a_; \\<not> x1 ! x2a_;\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {||};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|}; Length \\<AA> < xa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x1 x2 xa.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2)); \\<forall>x. {||} \\<noteq> {|x|};\n        x = (x1, x2); \\<not> x1 ! x1a_; x1 ! x2a_;\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {||}\\<rbrakk>\n       \\<Longrightarrow> xa < Length \\<AA>\n 3. \\<And>x1 xa x2.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|Length \\<AA>|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|}; x = (x1, x2); x1 ! x1a_;\n        \\<not> x1 ! x2a_; Length \\<AA> < xa\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x1 xa x2.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {|Length \\<AA>|}; x = (x1, x2);\n        \\<not> x1 ! x1a_; x1 ! x2a_; xa < Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis assigns_less_Length finsertCI less_not_sym)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 xa.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2)); \\<forall>x. {||} \\<noteq> {|x|};\n        x = (x1, x2); \\<not> x1 ! x1a_; x1 ! x2a_;\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {||}\\<rbrakk>\n       \\<Longrightarrow> xa < Length \\<AA>\n 2. \\<And>x1 xa x2.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|Length \\<AA>|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|}; x = (x1, x2); x1 ! x1a_;\n        \\<not> x1 ! x2a_; Length \\<AA> < xa\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x1 xa x2.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {|Length \\<AA>|}; x = (x1, x2);\n        \\<not> x1 ! x1a_; x1 ! x2a_; xa < Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> False", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 xa x2.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|Length \\<AA>|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|}; x = (x1, x2); x1 ! x1a_;\n        \\<not> x1 ! x2a_; Length \\<AA> < xa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x1 xa x2.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {|Length \\<AA>|}; x = (x1, x2);\n        \\<not> x1 ! x1a_; x1 ! x2a_; xa < Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis assigns_less_Length finsertCI less_not_sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 xa x2.\n       \\<lbrakk>#\\<^sub>V \\<AA> = size_atom (x1, x2);\n        LESS FO x1a_ (size_atom (x1, x2));\n        LESS FO x2a_ (size_atom (x1, x2));\n        x1a_\\<^bsup>\\<AA>\\<^esup>FO = {|xa|};\n        x2a_\\<^bsup>\\<AA>\\<^esup>FO = {|Length \\<AA>|}; x = (x1, x2);\n        \\<not> x1 ! x1a_; x1 ! x2a_; xa < Length \\<AA>\\<rbrakk>\n       \\<Longrightarrow> False", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Formula_Operations.satisfies_gen Extend Length satisfies0\n   (\\<lambda>_ P. (\\<le>) (len P)) \\<AA> (rderiv0 x (Less x1a_ x2a_)) =\n  satisfies0 (SNOC x \\<AA>) (Less x1a_ x2a_)\n\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Fo xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Fo xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Fo xa)\n 2. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Z xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Z xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Z xa)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (In x1a x2a);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (In x1a x2a)) =\n                         satisfies0 (SNOC x \\<AA>) (In x1a x2a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Fo xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Fo xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Fo xa)\n 2. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Z xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Z xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Z xa)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (In x1a x2a);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (In x1a x2a)) =\n                         satisfies0 (SNOC x \\<AA>) (In x1a x2a)", "case In"], ["proof (state)\nthis:\n  wf0 (#\\<^sub>V \\<AA>) (In x1a_ x2a_)\n  #\\<^sub>V \\<AA> = size_atom x\n\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Fo xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Fo xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Fo xa)\n 2. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Z xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Z xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Z xa)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (In x1a x2a);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (In x1a x2a)) =\n                         satisfies0 (SNOC x \\<AA>) (In x1a x2a)", "then"], ["proof (chain)\npicking this:\n  wf0 (#\\<^sub>V \\<AA>) (In x1a_ x2a_)\n  #\\<^sub>V \\<AA> = size_atom x", "show ?case"], ["proof (prove)\nusing this:\n  wf0 (#\\<^sub>V \\<AA>) (In x1a_ x2a_)\n  #\\<^sub>V \\<AA> = size_atom x\n\ngoal (1 subgoal):\n 1. Formula_Operations.satisfies_gen Extend Length satisfies0\n     (\\<lambda>_ P. (\\<le>) (len P)) \\<AA> (rderiv0 x (In x1a_ x2a_)) =\n    satisfies0 (SNOC x \\<AA>) (In x1a_ x2a_)", "by (force split: prod.splits)"], ["proof (state)\nthis:\n  Formula_Operations.satisfies_gen Extend Length satisfies0\n   (\\<lambda>_ P. (\\<le>) (len P)) \\<AA> (rderiv0 x (In x1a_ x2a_)) =\n  satisfies0 (SNOC x \\<AA>) (In x1a_ x2a_)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Fo xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Fo xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Fo xa)\n 2. \\<And>xa.\n       \\<lbrakk>wf0 (#\\<^sub>V \\<AA>) (Z xa);\n        #\\<^sub>V \\<AA> = size_atom x\\<rbrakk>\n       \\<Longrightarrow> Formula_Operations.satisfies_gen Extend Length\n                          satisfies0 (\\<lambda>_ P. (\\<le>) (len P)) \\<AA>\n                          (rderiv0 x (Z xa)) =\n                         satisfies0 (SNOC x \\<AA>) (Z xa)", "qed (auto split: prod.splits)"], ["proof (state)\nthis:\n  Formula_Operations.satisfies_gen Extend Length satisfies0\n   (\\<lambda>_ P. (\\<le>) (len P)) \\<AA> (rderiv0 x a) =\n  satisfies0 (SNOC x \\<AA>) a\n\ngoal (44 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 38. \\<And>k a. finite (FV0 k a)\n 39. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 40. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 41. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 42. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 43. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 44. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "next"], ["proof (state)\ngoal (44 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 38. \\<And>k a. finite (FV0 k a)\n 39. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 40. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 41. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 42. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 43. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 44. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "fix a :: ws1s and \\<AA> \\<BB> :: interp"], ["proof (state)\ngoal (44 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 38. \\<And>k a. finite (FV0 k a)\n 39. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 40. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 41. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 42. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 43. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 44. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "assume \"wf0 (#\\<^sub>V \\<BB>) a\" \"#\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\" \"(\\<And>m k. LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow> m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k)\" \"lformula0 a\""], ["proof (state)\nthis:\n  wf0 (#\\<^sub>V \\<BB>) a\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula0 a\n\ngoal (44 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>\\<BB> a \\<AA>.\n        \\<lbrakk>wf0 (#\\<^sub>V \\<BB>) a; #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>;\n         lformula0 a;\n         \\<And>m k.\n            LESS k m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n            m\\<^bsup>\\<AA>\\<^esup>k = m\\<^bsup>\\<BB>\\<^esup>k\\<rbrakk>\n        \\<Longrightarrow> satisfies0 \\<AA> a = satisfies0 \\<BB> a\n 37. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 38. \\<And>k a. finite (FV0 k a)\n 39. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 40. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 41. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 42. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 43. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 44. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "then"], ["proof (chain)\npicking this:\n  wf0 (#\\<^sub>V \\<BB>) a\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula0 a", "show \"satisfies0 \\<AA> a \\<longleftrightarrow> satisfies0 \\<BB> a\""], ["proof (prove)\nusing this:\n  wf0 (#\\<^sub>V \\<BB>) a\n  #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\n  LESS ?k ?m (#\\<^sub>V \\<BB>) \\<Longrightarrow>\n  ?m\\<^bsup>\\<AA>\\<^esup>?k = ?m\\<^bsup>\\<BB>\\<^esup>?k\n  lformula0 a\n\ngoal (1 subgoal):\n 1. satisfies0 \\<AA> a = satisfies0 \\<BB> a", "by (induct a) auto"], ["proof (state)\nthis:\n  satisfies0 \\<AA> a = satisfies0 \\<BB> a\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "next"], ["proof (state)\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "fix a :: ws1s"], ["proof (state)\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "assume \"lformula0 a\""], ["proof (state)\nthis:\n  lformula0 a\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "moreover"], ["proof (state)\nthis:\n  lformula0 a\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "define d where \"d = Formula_Operations.deriv extend lderiv0\""], ["proof (state)\nthis:\n  d = Formula_Operations.deriv extend lderiv0\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "define \\<Phi> :: \"_ \\<Rightarrow> (ws1s, order) aformula set\"\n     where \"\\<Phi> a =\n       (case a of\n         Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n       | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n       | Less m1 m2 \\<Rightarrow> {FBase (Less m1 m2),\n          FAnd (FBase (Z m1)) (FBase (Fo m2)),\n          FAnd (FBase (Z m1)) (FBase (Z m2)),\n          FAnd (FBase (Z m1)) (FBool False),\n          FAnd (FBool False) (FBase (Fo m2)),\n          FAnd (FBool False) (FBase (Z m2)),\n          FAnd (FBool False) (FBool False),\n         FBool False}\n       | In i I \\<Rightarrow> {FBase (In i I),  FBase (Z i), FBool False})\" for a"], ["proof (state)\nthis:\n  \\<Phi> ?a =\n  (case ?a of Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n   | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n   | Less m1 m2 \\<Rightarrow>\n       {FBase (Less m1 m2), FAnd (FBase (Z m1)) (FBase (Fo m2)),\n        FAnd (FBase (Z m1)) (FBase (Z m2)),\n        FAnd (FBase (Z m1)) (FBool False),\n        FAnd (FBool False) (FBase (Fo m2)),\n        FAnd (FBool False) (FBase (Z m2)), FAnd (FBool False) (FBool False),\n        FBool False}\n   | In i I \\<Rightarrow> {FBase (In i I), FBase (Z i), FBool False})\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "{"], ["proof (state)\nthis:\n  \\<Phi> ?a =\n  (case ?a of Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n   | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n   | Less m1 m2 \\<Rightarrow>\n       {FBase (Less m1 m2), FAnd (FBase (Z m1)) (FBase (Fo m2)),\n        FAnd (FBase (Z m1)) (FBase (Z m2)),\n        FAnd (FBase (Z m1)) (FBool False),\n        FAnd (FBool False) (FBase (Fo m2)),\n        FAnd (FBool False) (FBase (Z m2)), FAnd (FBool False) (FBool False),\n        FBool False}\n   | In i I \\<Rightarrow> {FBase (In i I), FBase (Z i), FBool False})\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "fix xs"], ["proof (state)\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "note Formula_Operations.fold_deriv_FBool[simp] Formula_Operations.deriv.simps[simp] \\<Phi>_def[simp]"], ["proof (state)\nthis:\n  fold (Formula_Operations.deriv ?extend ?d0.0) ?xs (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBase ?a) = ?deriv0.0 ?x ?a\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FNot ?\\<phi>) =\n  FNot (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FOr ?\\<phi> ?\\<psi>) =\n  FOr (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAnd ?\\<phi> ?\\<psi>) =\n  FAnd (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FEx ?k ?\\<phi>) =\n  FEx ?k\n   (FOr (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n          ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAll ?k ?\\<phi>) =\n  FAll ?k\n   (FAnd\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n       ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  \\<Phi> ?a =\n  (case ?a of Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n   | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n   | Less m1 m2 \\<Rightarrow>\n       {FBase (Less m1 m2), FAnd (FBase (Z m1)) (FBase (Fo m2)),\n        FAnd (FBase (Z m1)) (FBase (Z m2)),\n        FAnd (FBase (Z m1)) (FBool False),\n        FAnd (FBool False) (FBase (Fo m2)),\n        FAnd (FBool False) (FBase (Z m2)), FAnd (FBool False) (FBool False),\n        FBool False}\n   | In i I \\<Rightarrow> {FBase (In i I), FBase (Z i), FBool False})\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "from \\<open>lformula0 a\\<close>"], ["proof (chain)\npicking this:\n  lformula0 a", "have \"FBase a \\<in> \\<Phi> a\""], ["proof (prove)\nusing this:\n  lformula0 a\n\ngoal (1 subgoal):\n 1. FBase a \\<in> \\<Phi> a", "by (cases a) auto"], ["proof (state)\nthis:\n  FBase a \\<in> \\<Phi> a\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "moreover"], ["proof (state)\nthis:\n  FBase a \\<in> \\<Phi> a\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "have \"\\<And>x \\<phi>. \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d x \\<phi> \\<in> \\<Phi> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<phi>.\n       \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d x \\<phi> \\<in> \\<Phi> a", "by (auto simp: d_def split: atomic.splits list.splits bool.splits if_splits option.splits)"], ["proof (state)\nthis:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "then"], ["proof (chain)\npicking this:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a", "have \"\\<And>\\<phi>. \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs \\<phi> \\<in> \\<Phi> a\""], ["proof (prove)\nusing this:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<phi> \\<in> \\<Phi> a \\<Longrightarrow>\n       fold d xs \\<phi> \\<in> \\<Phi> a", "by (induct xs) auto"], ["proof (state)\nthis:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "ultimately"], ["proof (chain)\npicking this:\n  FBase a \\<in> \\<Phi> a\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a", "have \"fold d xs (FBase a) \\<in> \\<Phi> a\""], ["proof (prove)\nusing this:\n  FBase a \\<in> \\<Phi> a\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. fold d xs (FBase a) \\<in> \\<Phi> a", "by blast"], ["proof (state)\nthis:\n  fold d xs (FBase a) \\<in> \\<Phi> a\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "}"], ["proof (state)\nthis:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "moreover"], ["proof (state)\nthis:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "have \"finite (\\<Phi> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Phi> a)", "using \\<open>lformula0 a\\<close>"], ["proof (prove)\nusing this:\n  lformula0 a\n\ngoal (1 subgoal):\n 1. finite (\\<Phi> a)", "unfolding \\<Phi>_def"], ["proof (prove)\nusing this:\n  lformula0 a\n\ngoal (1 subgoal):\n 1. finite\n     (case a of Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n      | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n      | Less m1 m2 \\<Rightarrow>\n          {FBase (Less m1 m2), FAnd (FBase (Z m1)) (FBase (Fo m2)),\n           FAnd (FBase (Z m1)) (FBase (Z m2)),\n           FAnd (FBase (Z m1)) (FBool False),\n           FAnd (FBool False) (FBase (Fo m2)),\n           FAnd (FBool False) (FBase (Z m2)),\n           FAnd (FBool False) (FBool False), FBool False}\n      | In i I \\<Rightarrow> {FBase (In i I), FBase (Z i), FBool False})", "by (auto split: atomic.splits)"], ["proof (state)\nthis:\n  finite (\\<Phi> a)\n\ngoal (43 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        lformula0 a \\<Longrightarrow>\n        finite\n         {fold (Formula_Operations.deriv extend lderiv0) xs (FBase a) |xs.\n          True}\n 43. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "ultimately"], ["proof (chain)\npicking this:\n  lformula0 a\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n  finite (\\<Phi> a)", "show \"finite {fold d xs (FBase a) | xs. True}\""], ["proof (prove)\nusing this:\n  lformula0 a\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n  finite (\\<Phi> a)\n\ngoal (1 subgoal):\n 1. finite {fold d xs (FBase a) |xs. True}", "by (blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite {fold d xs (FBase a) |xs. True}\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "next"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "fix a :: ws1s"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "define d where \"d = Formula_Operations.deriv extend rderiv0\""], ["proof (state)\nthis:\n  d = Formula_Operations.deriv extend rderiv0\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "define \\<Phi> :: \"_ \\<Rightarrow> (ws1s, order) aformula set\"\n     where \"\\<Phi> a =\n       (case a of\n         Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n       | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n       | Less m1 m2 \\<Rightarrow> {FBase (Less m1 m2),\n          FAnd (FBase (Z m2)) (FBase (Fo m1)) ,\n          FAnd (FBase (Z m2)) (FBase (Z m1)),\n          FAnd (FBase (Z m2)) (FBool False),\n          FAnd (FBool False) (FBase (Fo m1)),\n          FAnd (FBool False) (FBase (Z m1)),\n          FAnd (FBool False) (FBool False),\n         FBool False}\n       | In i I \\<Rightarrow> {FBase (In i I),  FBase (Z i), FBool False})\" for a"], ["proof (state)\nthis:\n  \\<Phi> ?a =\n  (case ?a of Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n   | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n   | Less m1 m2 \\<Rightarrow>\n       {FBase (Less m1 m2), FAnd (FBase (Z m2)) (FBase (Fo m1)),\n        FAnd (FBase (Z m2)) (FBase (Z m1)),\n        FAnd (FBase (Z m2)) (FBool False),\n        FAnd (FBool False) (FBase (Fo m1)),\n        FAnd (FBool False) (FBase (Z m1)), FAnd (FBool False) (FBool False),\n        FBool False}\n   | In i I \\<Rightarrow> {FBase (In i I), FBase (Z i), FBool False})\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "{"], ["proof (state)\nthis:\n  \\<Phi> ?a =\n  (case ?a of Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n   | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n   | Less m1 m2 \\<Rightarrow>\n       {FBase (Less m1 m2), FAnd (FBase (Z m2)) (FBase (Fo m1)),\n        FAnd (FBase (Z m2)) (FBase (Z m1)),\n        FAnd (FBase (Z m2)) (FBool False),\n        FAnd (FBool False) (FBase (Fo m1)),\n        FAnd (FBool False) (FBase (Z m1)), FAnd (FBool False) (FBool False),\n        FBool False}\n   | In i I \\<Rightarrow> {FBase (In i I), FBase (Z i), FBool False})\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "fix xs"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "note Formula_Operations.fold_deriv_FBool[simp] Formula_Operations.deriv.simps[simp] \\<Phi>_def[simp]"], ["proof (state)\nthis:\n  fold (Formula_Operations.deriv ?extend ?d0.0) ?xs (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBase ?a) = ?deriv0.0 ?x ?a\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FNot ?\\<phi>) =\n  FNot (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FOr ?\\<phi> ?\\<psi>) =\n  FOr (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAnd ?\\<phi> ?\\<psi>) =\n  FAnd (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FEx ?k ?\\<phi>) =\n  FEx ?k\n   (FOr (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n          ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAll ?k ?\\<phi>) =\n  FAll ?k\n   (FAnd\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n       ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  \\<Phi> ?a =\n  (case ?a of Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n   | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n   | Less m1 m2 \\<Rightarrow>\n       {FBase (Less m1 m2), FAnd (FBase (Z m2)) (FBase (Fo m1)),\n        FAnd (FBase (Z m2)) (FBase (Z m1)),\n        FAnd (FBase (Z m2)) (FBool False),\n        FAnd (FBool False) (FBase (Fo m1)),\n        FAnd (FBool False) (FBase (Z m1)), FAnd (FBool False) (FBool False),\n        FBool False}\n   | In i I \\<Rightarrow> {FBase (In i I), FBase (Z i), FBool False})\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "then"], ["proof (chain)\npicking this:\n  fold (Formula_Operations.deriv ?extend ?d0.0) ?xs (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBase ?a) = ?deriv0.0 ?x ?a\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FNot ?\\<phi>) =\n  FNot (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FOr ?\\<phi> ?\\<psi>) =\n  FOr (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAnd ?\\<phi> ?\\<psi>) =\n  FAnd (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FEx ?k ?\\<phi>) =\n  FEx ?k\n   (FOr (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n          ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAll ?k ?\\<phi>) =\n  FAll ?k\n   (FAnd\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n       ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  \\<Phi> ?a =\n  (case ?a of Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n   | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n   | Less m1 m2 \\<Rightarrow>\n       {FBase (Less m1 m2), FAnd (FBase (Z m2)) (FBase (Fo m1)),\n        FAnd (FBase (Z m2)) (FBase (Z m1)),\n        FAnd (FBase (Z m2)) (FBool False),\n        FAnd (FBool False) (FBase (Fo m1)),\n        FAnd (FBool False) (FBase (Z m1)), FAnd (FBool False) (FBool False),\n        FBool False}\n   | In i I \\<Rightarrow> {FBase (In i I), FBase (Z i), FBool False})", "have \"FBase a \\<in> \\<Phi> a\""], ["proof (prove)\nusing this:\n  fold (Formula_Operations.deriv ?extend ?d0.0) ?xs (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBool ?b) = FBool ?b\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FBase ?a) = ?deriv0.0 ?x ?a\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FNot ?\\<phi>) =\n  FNot (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FOr ?\\<phi> ?\\<psi>) =\n  FOr (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAnd ?\\<phi> ?\\<psi>) =\n  FAnd (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<phi>)\n   (Formula_Operations.deriv ?extend ?deriv0.0 ?x ?\\<psi>)\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FEx ?k ?\\<phi>) =\n  FEx ?k\n   (FOr (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n          ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  Formula_Operations.deriv ?extend ?deriv0.0 ?x (FAll ?k ?\\<phi>) =\n  FAll ?k\n   (FAnd\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k True ?x)\n       ?\\<phi>)\n     (Formula_Operations.deriv ?extend ?deriv0.0 (?extend ?k False ?x)\n       ?\\<phi>))\n  \\<Phi> ?a =\n  (case ?a of Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n   | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n   | Less m1 m2 \\<Rightarrow>\n       {FBase (Less m1 m2), FAnd (FBase (Z m2)) (FBase (Fo m1)),\n        FAnd (FBase (Z m2)) (FBase (Z m1)),\n        FAnd (FBase (Z m2)) (FBool False),\n        FAnd (FBool False) (FBase (Fo m1)),\n        FAnd (FBool False) (FBase (Z m1)), FAnd (FBool False) (FBool False),\n        FBool False}\n   | In i I \\<Rightarrow> {FBase (In i I), FBase (Z i), FBool False})\n\ngoal (1 subgoal):\n 1. FBase a \\<in> \\<Phi> a", "by (auto split: atomic.splits option.splits)"], ["proof (state)\nthis:\n  FBase a \\<in> \\<Phi> a\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "moreover"], ["proof (state)\nthis:\n  FBase a \\<in> \\<Phi> a\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "have \"\\<And>x \\<phi>. \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d x \\<phi> \\<in> \\<Phi> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<phi>.\n       \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d x \\<phi> \\<in> \\<Phi> a", "by (auto simp add: d_def Let_def not_le gr0_conv_Suc\n         split: atomic.splits list.splits bool.splits if_splits option.splits nat.splits)"], ["proof (state)\nthis:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "then"], ["proof (chain)\npicking this:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a", "have \"\\<And>\\<phi>. \\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs \\<phi> \\<in> \\<Phi> a\""], ["proof (prove)\nusing this:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> d ?x ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>.\n       \\<phi> \\<in> \\<Phi> a \\<Longrightarrow>\n       fold d xs \\<phi> \\<in> \\<Phi> a", "by (induct xs) auto"], ["proof (state)\nthis:\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "ultimately"], ["proof (chain)\npicking this:\n  FBase a \\<in> \\<Phi> a\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a", "have \"fold d xs (FBase a) \\<in> \\<Phi> a\""], ["proof (prove)\nusing this:\n  FBase a \\<in> \\<Phi> a\n  ?\\<phi> \\<in> \\<Phi> a \\<Longrightarrow> fold d xs ?\\<phi> \\<in> \\<Phi> a\n\ngoal (1 subgoal):\n 1. fold d xs (FBase a) \\<in> \\<Phi> a", "by blast"], ["proof (state)\nthis:\n  fold d xs (FBase a) \\<in> \\<Phi> a\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "}"], ["proof (state)\nthis:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "moreover"], ["proof (state)\nthis:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "have \"finite (\\<Phi> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Phi> a)", "unfolding \\<Phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (case a of Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n      | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n      | Less m1 m2 \\<Rightarrow>\n          {FBase (Less m1 m2), FAnd (FBase (Z m2)) (FBase (Fo m1)),\n           FAnd (FBase (Z m2)) (FBase (Z m1)),\n           FAnd (FBase (Z m2)) (FBool False),\n           FAnd (FBool False) (FBase (Fo m1)),\n           FAnd (FBool False) (FBase (Z m1)),\n           FAnd (FBool False) (FBool False), FBool False}\n      | In i I \\<Rightarrow> {FBase (In i I), FBase (Z i), FBool False})", "using [[simproc add: finite_Collect]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (case a of Fo m \\<Rightarrow> {FBase (Fo m), FBase (Z m), FBool False}\n      | Z m \\<Rightarrow> {FBase (Z m), FBool False}\n      | Less m1 m2 \\<Rightarrow>\n          {FBase (Less m1 m2), FAnd (FBase (Z m2)) (FBase (Fo m1)),\n           FAnd (FBase (Z m2)) (FBase (Z m1)),\n           FAnd (FBase (Z m2)) (FBool False),\n           FAnd (FBool False) (FBase (Fo m1)),\n           FAnd (FBool False) (FBase (Z m1)),\n           FAnd (FBool False) (FBool False), FBool False}\n      | In i I \\<Rightarrow> {FBase (In i I), FBase (Z i), FBool False})", "by (auto split: atomic.splits)"], ["proof (state)\nthis:\n  finite (\\<Phi> a)\n\ngoal (42 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)\n 42. \\<And>a.\n        finite\n         {fold (Formula_Operations.deriv extend rderiv0) xs (FBase a) |xs.\n          True}", "ultimately"], ["proof (chain)\npicking this:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n  finite (\\<Phi> a)", "show \"finite {fold d xs (FBase a) | xs. True}\""], ["proof (prove)\nusing this:\n  fold d ?xs2 (FBase a) \\<in> \\<Phi> a\n  finite (\\<Phi> a)\n\ngoal (1 subgoal):\n 1. finite {fold d xs (FBase a) |xs. True}", "by (blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite {fold d xs (FBase a) |xs. True}\n\ngoal (41 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "next"], ["proof (state)\ngoal (41 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "fix k l and a :: ws1s"], ["proof (state)\ngoal (41 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a k l.\n        \\<lbrakk>wf0 idx a; LESS k l idx\\<rbrakk>\n        \\<Longrightarrow> find0 k l a = (l \\<in> FV0 k a)\n 37. \\<And>k a. finite (FV0 k a)\n 38. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 39. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 40. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 41. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "show \"find0 k l a \\<longleftrightarrow> l \\<in> FV0 k a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find0 k l a = (l \\<in> FV0 k a)", "by (induct a rule: find0.induct) auto"], ["proof (state)\nthis:\n  find0 k l a = (l \\<in> FV0 k a)\n\ngoal (40 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>k a. finite (FV0 k a)\n 37. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 38. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 39. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 40. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "next"], ["proof (state)\ngoal (40 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>k a. finite (FV0 k a)\n 37. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 38. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 39. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 40. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "fix a :: ws1s and k :: order"], ["proof (state)\ngoal (40 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>k a. finite (FV0 k a)\n 37. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 38. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 39. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 40. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "show \"finite (FV0 k a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (FV0 k a)", "by (cases k) (induct a, auto)+"], ["proof (state)\nthis:\n  finite (FV0 k a)\n\ngoal (39 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 37. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 38. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 39. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "next"], ["proof (state)\ngoal (39 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 37. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 38. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 39. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "fix idx a k v"], ["proof (state)\ngoal (39 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 37. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 38. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 39. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "assume \"wf0 idx a\" \"v \\<in> FV0 k a\""], ["proof (state)\nthis:\n  wf0 idx a\n  v \\<in> FV0 k a\n\ngoal (39 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>idx a v k.\n        \\<lbrakk>wf0 idx a; v \\<in> FV0 k a\\<rbrakk>\n        \\<Longrightarrow> LESS k v idx\n 37. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 38. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 39. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "then"], ["proof (chain)\npicking this:\n  wf0 idx a\n  v \\<in> FV0 k a", "show \"LESS k v idx\""], ["proof (prove)\nusing this:\n  wf0 idx a\n  v \\<in> FV0 k a\n\ngoal (1 subgoal):\n 1. LESS k v idx", "by (cases k) (induct a, auto)+"], ["proof (state)\nthis:\n  LESS k v idx\n\ngoal (38 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 37. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 38. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "next"], ["proof (state)\ngoal (38 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 37. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 38. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "fix idx k i"], ["proof (state)\ngoal (38 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 37. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 38. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "assume \"LESS k i idx\""], ["proof (state)\nthis:\n  LESS k i idx\n\ngoal (38 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 37. \\<And>k i idx.\n        LESS k i idx \\<Longrightarrow>\n        Formula_Operations.wf SUC wf0 idx (Restrict k i)\n 38. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "then"], ["proof (chain)\npicking this:\n  LESS k i idx", "show \"Formula_Operations.wf SUC wf0 idx (Restrict k i)\""], ["proof (prove)\nusing this:\n  LESS k i idx\n\ngoal (1 subgoal):\n 1. Formula_Operations.wf SUC wf0 idx (Restrict k i)", "unfolding Restrict_def"], ["proof (prove)\nusing this:\n  LESS k i idx\n\ngoal (1 subgoal):\n 1. Formula_Operations.wf SUC wf0 idx\n     (case k of FO \\<Rightarrow> FBase (Fo i) | SO \\<Rightarrow> FBool True)", "by (cases k) (auto simp: Formula_Operations.wf.simps)"], ["proof (state)\nthis:\n  Formula_Operations.wf SUC wf0 idx (Restrict k i)\n\ngoal (37 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 37. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "next"], ["proof (state)\ngoal (37 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 37. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "fix k and i :: nat"], ["proof (state)\ngoal (37 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)\n 37. \\<And>k i. Formula_Operations.lformula lformula0 (Restrict k i)", "show \"Formula_Operations.lformula lformula0 (Restrict k i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Formula_Operations.lformula lformula0 (Restrict k i)", "unfolding Restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Formula_Operations.lformula lformula0\n     (case k of FO \\<Rightarrow> FBase (Fo i) | SO \\<Rightarrow> FBool True)", "by (cases k) (auto simp: Formula_Operations.lformula.simps)"], ["proof (state)\nthis:\n  Formula_Operations.lformula lformula0 (Restrict k i)\n\ngoal (36 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)", "next"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)", "fix i \\<AA> k P r"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)", "assume \"i\\<^bsup>\\<AA>\\<^esup>k = P\""], ["proof (state)\nthis:\n  i\\<^bsup>\\<AA>\\<^esup>k = P\n\ngoal (36 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)\n 36. \\<And>i \\<AA> k P r.\n        i\\<^bsup>\\<AA>\\<^esup>k = P \\<Longrightarrow>\n        restrict k P =\n        Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n         (Restrict k i)", "then"], ["proof (chain)\npicking this:\n  i\\<^bsup>\\<AA>\\<^esup>k = P", "show \"restrict k P \\<longleftrightarrow>\n    Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA> (Restrict k i)\""], ["proof (prove)\nusing this:\n  i\\<^bsup>\\<AA>\\<^esup>k = P\n\ngoal (1 subgoal):\n 1. restrict k P =\n    Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n     (Restrict k i)", "unfolding restrict_def Restrict_def"], ["proof (prove)\nusing this:\n  i\\<^bsup>\\<AA>\\<^esup>k = P\n\ngoal (1 subgoal):\n 1. (case k of FO \\<Rightarrow> \\<exists>x. P = {|x|}\n     | SO \\<Rightarrow> True) =\n    Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n     (case k of FO \\<Rightarrow> FBase (Fo i) | SO \\<Rightarrow> FBool True)", "by (cases k) (auto simp: Formula_Operations.satisfies_gen.simps)"], ["proof (state)\nthis:\n  restrict k P =\n  Formula_Operations.satisfies_gen Extend Length satisfies0 r \\<AA>\n   (Restrict k i)\n\ngoal (35 subgoals):\n 1. \\<And>k k' idx. SUC k (SUC k' idx) = SUC k' (SUC k idx)\n 2. \\<And>k idx. LEQ k 0 idx\n 3. \\<And>k l idx. LEQ k (Suc l) idx = LESS k l idx\n 4. \\<And>k k' l idx.\n       k \\<noteq> k' \\<Longrightarrow> LESS k l (SUC k' idx) = LESS k l idx\n 5. \\<And>k i \\<AA> P.\n       #\\<^sub>V (Extend k i \\<AA> P) = SUC k (#\\<^sub>V \\<AA>)\n 6. \\<And>k i \\<AA> P.\n       Length (Extend k i \\<AA> P) = max (Length \\<AA>) (len P)\n 7. \\<And>\\<AA> \\<BB>.\n       \\<lbrakk>Length \\<AA> = 0; Length \\<BB> = 0;\n        #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n       \\<Longrightarrow> \\<AA> = \\<BB>\n 8. \\<And>idx. \\<exists>\\<AA>. Length \\<AA> = 0 \\<and> #\\<^sub>V \\<AA> = idx\n 9. \\<And>j i k \\<AA> P Q.\n       \\<lbrakk>j \\<le> i; LEQ k i (#\\<^sub>V \\<AA>)\\<rbrakk>\n       \\<Longrightarrow> Extend k j (Extend k i \\<AA> P) Q =\n                         Extend k (Suc i) (Extend k j \\<AA> Q) P\n 10. \\<And>k k' j i \\<AA> P Q.\n        k \\<noteq> k' \\<Longrightarrow>\n        Extend k j (Extend k' i \\<AA> P) Q =\n        Extend k' i (Extend k j \\<AA> Q) P\n 11. \\<And>k i \\<AA> m P k'.\n        LEQ k i (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>Extend k i \\<AA> P\\<^esup>k' =\n        (if k = k' then if m = i then P else dec i m\\<^bsup>\\<AA>\\<^esup>k\n         else m\\<^bsup>\\<AA>\\<^esup>k')\n 12. \\<And>k m \\<AA>.\n        LESS k m (#\\<^sub>V \\<AA>) \\<Longrightarrow>\n        m\\<^bsup>SNOC (zero (#\\<^sub>V \\<AA>)) \\<AA>\\<^esup>k =\n        m\\<^bsup>\\<AA>\\<^esup>k\n 13. \\<And>x \\<AA>. Length (CONS x \\<AA>) = Length \\<AA> + 1\n 14. \\<And>x \\<AA>. Length (SNOC x \\<AA>) = Suc (Length \\<AA>)\n 15. \\<And>x \\<AA>. #\\<^sub>V (CONS x \\<AA>) = #\\<^sub>V \\<AA>\n 16. \\<And>x \\<AA>. #\\<^sub>V (SNOC x \\<AA>) = #\\<^sub>V \\<AA>\n 17. \\<And>\\<AA> x k P.\n        #\\<^sub>V \\<AA> = size_atom x \\<Longrightarrow>\n        Extend k 0 (CONS x \\<AA>) P =\n        CONS (extend k (if eval P 0 then True else False) x)\n         (Extend k 0 \\<AA> (downshift P))\n 18. \\<And>\\<AA> x P k.\n        \\<lbrakk>#\\<^sub>V \\<AA> = size_atom x;\n         len P \\<le> Length (SNOC x \\<AA>)\\<rbrakk>\n        \\<Longrightarrow> Extend k 0 (SNOC x \\<AA>) P =\n                          SNOC\n                           (extend k\n                             (if eval P (Length \\<AA>) then True else False)\n                             x)\n                           (Extend k 0 \\<AA>\n                             (WS1S_Prelim.cut (Length \\<AA>) P))\n 19. \\<And>x \\<AA> y \\<BB>.\n        \\<lbrakk>size_atom x = #\\<^sub>V \\<AA>;\n         size_atom y = #\\<^sub>V \\<AA>;\n         #\\<^sub>V \\<AA> = #\\<^sub>V \\<BB>\\<rbrakk>\n        \\<Longrightarrow> (CONS x \\<AA> = CONS y \\<BB>) =\n                          (x = y \\<and> \\<AA> = \\<BB>)\n 20. \\<And>\\<AA> idx.\n        \\<lbrakk>Length \\<AA> \\<noteq> 0; #\\<^sub>V \\<AA> = idx\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x \\<BB>.\n                             \\<AA> = CONS x \\<BB> \\<and>\n                             #\\<^sub>V \\<BB> = idx \\<and> size_atom x = idx\n 21. \\<And>idx. size_atom (zero idx) = idx\n 22. \\<And>k b x. size_atom (extend k b x) = SUC k (size_atom x)\n 23. \\<And>idx. distinct (\\<sigma> idx)\n 24. \\<And>x idx. (x \\<in> set (\\<sigma> idx)) = (size_atom x = idx)\n 25. \\<And>P. downshift (upshift P) = P\n 26. \\<And>P. downshift (finsert 0 P) = downshift P\n 27. \\<And>n P. eval (finsert n P) n\n 28. \\<And>P. \\<not> eval (upshift P) 0\n 29. \\<And>P p. len P \\<le> p \\<Longrightarrow> \\<not> eval P p\n 30. \\<And>n P. len (WS1S_Prelim.cut n P) \\<le> n\n 31. \\<And>P n. len P \\<le> n \\<Longrightarrow> WS1S_Prelim.cut n P = P\n 32. \\<And>n m P.\n        WS1S_Prelim.cut n (finsert m P) =\n        (if n \\<le> m then WS1S_Prelim.cut n P\n         else finsert m (WS1S_Prelim.cut n P))\n 33. \\<And>m P. len (finsert m P) = max (Suc m) (len P)\n 34. \\<And>P.\n        len (upshift P) =\n        (case len P of 0 \\<Rightarrow> 0\n         | Suc nat \\<Rightarrow> Suc (Suc nat))\n 35. \\<And>P.\n        len (downshift P) =\n        (case len P of 0 \\<Rightarrow> 0 | Suc n \\<Rightarrow> n)", "qed (auto simp: Extend_commute_unsafe downshift_def upshift_def fimage_iff Suc_le_eq len_def\n  dec_def eval_def cut_def len_downshift_helper CONS_inj dest!: CONS_surj\n  dest: fMax_ge fMax_ffilter_less fMax_boundedD fsubset_fsingletonD\n  split: order.splits if_splits)"], ["", "(*Workaround for code generation*)"], ["", "lemma check_eqv_code[code]: \"check_eqv idx r s =\n  ((ws1s_wf idx r \\<and> ws1s_lformula r) \\<and> (ws1s_wf idx s \\<and> ws1s_lformula s) \\<and>\n  (case rtrancl_while (\\<lambda>(p, q). final idx p = final idx q)\n    (\\<lambda>(p, q). map (\\<lambda>a. (norm (deriv lderiv0 a p), norm (deriv lderiv0 a q))) (\\<sigma> idx))\n    (norm (RESTRICT r), norm (RESTRICT s)) of\n    None \\<Rightarrow> False\n  | Some ([], x) \\<Rightarrow> True\n  | Some (a # list, x) \\<Rightarrow> False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_eqv idx r s =\n    ((ws1s_wf idx r \\<and> ws1s_lformula r) \\<and>\n     (ws1s_wf idx s \\<and> ws1s_lformula s) \\<and>\n     (case rtrancl_while (\\<lambda>(p, q). final idx p = final idx q)\n            (\\<lambda>(p, q).\n                map (\\<lambda>a.\n                        (norm (deriv lderiv0 a p),\n                         norm (deriv lderiv0 a q)))\n                 (\\<sigma> idx))\n            (norm (RESTRICT r), norm (RESTRICT s)) of\n      None \\<Rightarrow> False | Some ([], x) \\<Rightarrow> True\n      | Some (a # list, x) \\<Rightarrow> False))", "unfolding check_eqv_def WS1S_Alt.check_eqv_def WS1S_Alt.step_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ws1s_wf idx r \\<and> ws1s_lformula r) \\<and>\n     (ws1s_wf idx s \\<and> ws1s_lformula s) \\<and>\n     (case rtrancl_while (\\<lambda>(p, q). final idx p = final idx q)\n            (\\<lambda>(p, q).\n                map (\\<lambda>a.\n                        (norm (deriv lderiv0 a p),\n                         norm (deriv lderiv0 a q)))\n                 (\\<sigma> idx))\n            (norm (RESTRICT r), norm (RESTRICT s)) of\n      None \\<Rightarrow> False | Some ([], xa) \\<Rightarrow> True\n      | Some (a # list, xa) \\<Rightarrow> False)) =\n    ((ws1s_wf idx r \\<and> ws1s_lformula r) \\<and>\n     (ws1s_wf idx s \\<and> ws1s_lformula s) \\<and>\n     (case rtrancl_while (\\<lambda>(p, q). final idx p = final idx q)\n            (\\<lambda>(p, q).\n                map (\\<lambda>a.\n                        (norm (deriv lderiv0 a p),\n                         norm (deriv lderiv0 a q)))\n                 (\\<sigma> idx))\n            (norm (RESTRICT r), norm (RESTRICT s)) of\n      None \\<Rightarrow> False | Some ([], x) \\<Rightarrow> True\n      | Some (a # list, x) \\<Rightarrow> False))", ".."], ["", "definition while where [code del, code_abbrev]: \"while idx \\<phi> = while_default (fut_default idx \\<phi>)\""], ["", "declare while_default_code[of \"fut_default idx \\<phi>\" for idx \\<phi>, folded while_def, code]"], ["", "lemma check_eqv_sound: \n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> (WS1S_Alt.sat \\<AA> \\<phi> \\<longleftrightarrow> WS1S_Alt.sat \\<AA> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx; check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> WS1S_Alt.sat \\<AA> \\<phi> = WS1S_Alt.sat \\<AA> \\<psi>", "unfolding check_eqv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx;\n     WS1S_Alt.check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> WS1S_Alt.sat \\<AA> \\<phi> = WS1S_Alt.sat \\<AA> \\<psi>", "by (rule WS1S_Alt.check_eqv_soundness)"], ["", "lemma bounded_check_eqv_sound:\n  \"\\<lbrakk>#\\<^sub>V \\<AA> = idx; bounded_check_eqv idx \\<phi> \\<psi>\\<rbrakk> \\<Longrightarrow> (WS1S_Alt.sat\\<^sub>b \\<AA> \\<phi> \\<longleftrightarrow> WS1S_Alt.sat\\<^sub>b \\<AA> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx;\n     bounded_check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> WS1S_Alt.sat\\<^sub>b \\<AA> \\<phi> =\n                      WS1S_Alt.sat\\<^sub>b \\<AA> \\<psi>", "unfolding bounded_check_eqv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>#\\<^sub>V \\<AA> = idx;\n     WS1S_Alt.bounded.check_eqv idx \\<phi> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> WS1S_Alt.sat\\<^sub>b \\<AA> \\<phi> =\n                      WS1S_Alt.sat\\<^sub>b \\<AA> \\<psi>", "by (rule WS1S_Alt.bounded_check_eqv_soundness)"], ["", "method_setup check_equiv = \\<open>\n  let\n    fun tac ctxt =\n      let\n        val conv = @{computation_check terms: Trueprop\n          \"0 :: nat\" \"1 :: nat\" \"2 :: nat\" \"3 :: nat\" Suc\n          \"plus :: nat \\<Rightarrow> _\" \"minus :: nat \\<Rightarrow> _\"\n          \"times :: nat \\<Rightarrow> _\" \"divide :: nat \\<Rightarrow> _\" \"modulo :: nat \\<Rightarrow> _\"\n          \"0 :: int\" \"1 :: int\" \"2 :: int\" \"3 :: int\" \"-1 :: int\"\n          check_eqv datatypes: formula \"int list\" integer idx\n          \"nat \\<times> nat\" \"nat option\" \"bool option\"} ctxt\n      in\n        CONVERSION (Conv.params_conv ~1 (K (Conv.concl_conv ~1 conv)) ctxt) THEN'\n        resolve_tac ctxt [TrueI]\n      end\n  in\n    Scan.succeed (SIMPLE_METHOD' o tac)\n  end\n\\<close>"], ["", "end"]]}