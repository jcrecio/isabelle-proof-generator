{"file_name": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude/Definedness.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude", "problem_names": ["lemma defined_bottom [simp]: \"\\<not> defined \\<bottom>\"", "lemma defined_seq [simp]: \"defined x \\<Longrightarrow> seq\\<cdot>x\\<cdot>y = y\"", "lemma defined_Bool_simps [simp]:\n  \"defined (Def i)\"\n  \"defined TT\"\n  \"defined FF\"", "lemma val_Bool_simp1 [simp]:\n  \"\\<lbrakk>Def i\\<rbrakk> = i\"", "lemma val_Bool_simp2 [simp]:\n  \"\\<lbrakk>TT\\<rbrakk> = True\"\n  \"\\<lbrakk>FF\\<rbrakk> = False\"", "lemma IF_simps [simp]:\n  \"defined b \\<Longrightarrow> \\<lbrakk> b \\<rbrakk> \\<Longrightarrow> (If b then x else y) = x\"\n  \"defined b \\<Longrightarrow> \\<lbrakk> b \\<rbrakk> = False \\<Longrightarrow> (If b then x else y) = y\"", "lemma defined_neg [simp]: \"defined (neg\\<cdot>b) \\<longleftrightarrow> defined b\"", "lemma val_Bool_neg [simp]: \"defined b \\<Longrightarrow> \\<lbrakk> neg \\<cdot> b \\<rbrakk> = (\\<not> \\<lbrakk> b \\<rbrakk>)\"", "lemma defined_Integer_simps [simp]:\n  \"defined (MkI\\<cdot>i)\"\n  \"defined (0::Integer)\"\n  \"defined (1::Integer)\"", "lemma defined_numeral [simp]: \"defined (numeral x :: Integer)\"", "lemma val_Integer_simps [simp]:\n  \"\\<lbrakk>MkI\\<cdot>i\\<rbrakk> = i\"\n  \"\\<lbrakk>0\\<rbrakk> = 0\"\n  \"\\<lbrakk>1\\<rbrakk> = 1\"", "lemma val_Integer_numeral [simp]: \"\\<lbrakk> numeral x :: Integer \\<rbrakk> = numeral x\"", "lemma val_Integer_to_MkI:\n  \"defined i \\<Longrightarrow> i = (MkI \\<cdot> \\<lbrakk> i \\<rbrakk>)\"", "lemma defined_Integer_minus [simp]: \"defined i \\<Longrightarrow> defined j \\<Longrightarrow> defined (i - (j::Integer))\"", "lemma val_Integer_minus [simp]: \"defined i \\<Longrightarrow> defined j \\<Longrightarrow> \\<lbrakk> i - j \\<rbrakk> = \\<lbrakk> i \\<rbrakk> - \\<lbrakk> j \\<rbrakk>\"", "lemma defined_Integer_plus [simp]: \"defined i \\<Longrightarrow> defined j \\<Longrightarrow> defined (i + (j::Integer))\"", "lemma val_Integer_plus [simp]: \"defined i \\<Longrightarrow> defined j \\<Longrightarrow> \\<lbrakk> i + j \\<rbrakk> = \\<lbrakk> i \\<rbrakk> + \\<lbrakk> j \\<rbrakk>\"", "lemma defined_Integer_eq [simp]: \"defined (eq\\<cdot>a\\<cdot>b) \\<longleftrightarrow> defined a \\<and> defined (b::Integer)\"", "lemma val_Integer_eq [simp]: \"defined a \\<Longrightarrow> defined b \\<Longrightarrow> \\<lbrakk> eq\\<cdot>a\\<cdot>b \\<rbrakk> = (\\<lbrakk> a \\<rbrakk> = (\\<lbrakk> b \\<rbrakk> :: int))\"", "lemma nonneg_full_Int_induct [consumes 1, case_names neg Suc]:\n  assumes defined: \"defined i\"\n  assumes neg: \"\\<And> i. defined i \\<Longrightarrow> \\<lbrakk>i\\<rbrakk> < 0 \\<Longrightarrow> P i\"\n  assumes step: \"\\<And> i. defined i \\<Longrightarrow> 0 \\<le> \\<lbrakk>i\\<rbrakk> \\<Longrightarrow> (\\<And> j. defined j \\<Longrightarrow> \\<lbrakk> j \\<rbrakk> < \\<lbrakk> i \\<rbrakk> \\<Longrightarrow> P j) \\<Longrightarrow> P i\"\n  shows \"P (i::Integer)\"", "lemma nth_tail: (* TODO: move *)\n  \"defined n \\<Longrightarrow> \\<lbrakk> n \\<rbrakk> \\<ge> 0  \\<Longrightarrow> tail\\<cdot>xs !! n = xs !! (1 + n)\"", "lemma nth_zipWith: (* TODO: move *)\n  assumes f1 [simp]: \"\\<And>y. f\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\"\n  assumes f2 [simp]: \"\\<And>x. f\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"zipWith\\<cdot>f\\<cdot>xs\\<cdot>ys !! n = f\\<cdot>(xs !! n)\\<cdot>(ys !! n)\"", "lemma nth_neg [simp]: \"defined n \\<Longrightarrow> \\<lbrakk> n \\<rbrakk> < 0 \\<Longrightarrow> nth\\<cdot>xs\\<cdot>n = \\<bottom>\"", "lemma nth_Cons_simp [simp]:\n  \"defined n \\<Longrightarrow> \\<lbrakk> n \\<rbrakk> = 0 \\<Longrightarrow> nth\\<cdot>(x : xs)\\<cdot>n = x\"\n  \"defined n \\<Longrightarrow> \\<lbrakk> n \\<rbrakk> > 0 \\<Longrightarrow> nth\\<cdot>(x : xs)\\<cdot>n = nth\\<cdot>xs\\<cdot>(n - 1)\""], "translations": [["", "lemma defined_bottom [simp]: \"\\<not> defined \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> defined \\<bottom>", "by (simp add: defined_def)"], ["", "lemma defined_seq [simp]: \"defined x \\<Longrightarrow> seq\\<cdot>x\\<cdot>y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defined x \\<Longrightarrow> seq\\<cdot>x\\<cdot>y = y", "by (simp add: defined_def)"], ["", "consts val :: \"'a::type \\<Rightarrow> 'b::type\" (\"\\<lbrakk>_\\<rbrakk>\")"], ["", "text \\<open>val for booleans\\<close>"], ["", "definition val_Bool :: \"tr \\<Rightarrow> bool\" where\n  \"val_Bool i = (THE j. i = Def j)\""], ["", "adhoc_overloading\n  val val_Bool"], ["", "lemma defined_Bool_simps [simp]:\n  \"defined (Def i)\"\n  \"defined TT\"\n  \"defined FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defined (Def i) &&& defined TT &&& defined FF", "by (simp_all add: defined_def)"], ["", "lemma val_Bool_simp1 [simp]:\n  \"\\<lbrakk>Def i\\<rbrakk> = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Def i\\<rbrakk> = i", "by (simp_all add: val_Bool_def TT_def FF_def)"], ["", "lemma val_Bool_simp2 [simp]:\n  \"\\<lbrakk>TT\\<rbrakk> = True\"\n  \"\\<lbrakk>FF\\<rbrakk> = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>TT\\<rbrakk> = True &&& \\<lbrakk>FF\\<rbrakk> = False", "by (simp_all add: TT_def FF_def)"], ["", "lemma IF_simps [simp]:\n  \"defined b \\<Longrightarrow> \\<lbrakk> b \\<rbrakk> \\<Longrightarrow> (If b then x else y) = x\"\n  \"defined b \\<Longrightarrow> \\<lbrakk> b \\<rbrakk> = False \\<Longrightarrow> (If b then x else y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>defined b; \\<lbrakk>b\\<rbrakk>\\<rbrakk>\n     \\<Longrightarrow> If b then x else y = x) &&&\n    (\\<lbrakk>defined b; \\<lbrakk>b\\<rbrakk> = False\\<rbrakk>\n     \\<Longrightarrow> If b then x else y = y)", "by (cases b, simp_all)+"], ["", "lemma defined_neg [simp]: \"defined (neg\\<cdot>b) \\<longleftrightarrow> defined b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defined (neg\\<cdot>b) = defined b", "by (cases b, auto)"], ["", "lemma val_Bool_neg [simp]: \"defined b \\<Longrightarrow> \\<lbrakk> neg \\<cdot> b \\<rbrakk> = (\\<not> \\<lbrakk> b \\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defined b \\<Longrightarrow>\n    \\<lbrakk>neg\\<cdot>b\\<rbrakk> = (\\<not> \\<lbrakk>b\\<rbrakk>)", "by (cases b, auto)"], ["", "text \\<open>val for integers\\<close>"], ["", "definition val_Integer :: \"Integer \\<Rightarrow> int\" where\n  \"val_Integer i = (THE j. i = MkI\\<cdot>j)\""], ["", "adhoc_overloading\n  val val_Integer"], ["", "lemma defined_Integer_simps [simp]:\n  \"defined (MkI\\<cdot>i)\"\n  \"defined (0::Integer)\"\n  \"defined (1::Integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defined (MkI\\<cdot>i) &&& defined 0 &&& defined 1", "by (simp_all add: defined_def)"], ["", "lemma defined_numeral [simp]: \"defined (numeral x :: Integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defined (numeral x)", "by (simp add: defined_def)"], ["", "lemma val_Integer_simps [simp]:\n  \"\\<lbrakk>MkI\\<cdot>i\\<rbrakk> = i\"\n  \"\\<lbrakk>0\\<rbrakk> = 0\"\n  \"\\<lbrakk>1\\<rbrakk> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MkI\\<cdot>i\\<rbrakk> = i &&&\n    \\<lbrakk>0\\<rbrakk> = 0 &&& \\<lbrakk>1\\<rbrakk> = 1", "by (simp_all add: val_Integer_def)"], ["", "lemma val_Integer_numeral [simp]: \"\\<lbrakk> numeral x :: Integer \\<rbrakk> = numeral x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>numeral x\\<rbrakk> = numeral x", "by (simp_all add: val_Integer_def)"], ["", "lemma val_Integer_to_MkI:\n  \"defined i \\<Longrightarrow> i = (MkI \\<cdot> \\<lbrakk> i \\<rbrakk>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defined i \\<Longrightarrow> i = MkI\\<cdot>\\<lbrakk>i\\<rbrakk>", "apply (cases i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>defined i; i = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> i = MkI\\<cdot>\\<lbrakk>i\\<rbrakk>\n 2. \\<And>int.\n       \\<lbrakk>defined i; i = MkI\\<cdot>int\\<rbrakk>\n       \\<Longrightarrow> i = MkI\\<cdot>\\<lbrakk>i\\<rbrakk>", "apply (auto simp add: val_Integer_def defined_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma defined_Integer_minus [simp]: \"defined i \\<Longrightarrow> defined j \\<Longrightarrow> defined (i - (j::Integer))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>defined i; defined j\\<rbrakk> \\<Longrightarrow> defined (i - j)", "apply (cases i, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int.\n       \\<lbrakk>defined j; i = MkI\\<cdot>int\\<rbrakk>\n       \\<Longrightarrow> defined (MkI\\<cdot>int - j)", "apply (cases j, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma val_Integer_minus [simp]: \"defined i \\<Longrightarrow> defined j \\<Longrightarrow> \\<lbrakk> i - j \\<rbrakk> = \\<lbrakk> i \\<rbrakk> - \\<lbrakk> j \\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>defined i; defined j\\<rbrakk>\n    \\<Longrightarrow> \\<lbrakk>i - j\\<rbrakk> =\n                      \\<lbrakk>i\\<rbrakk> - \\<lbrakk>j\\<rbrakk>", "apply (cases i, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int.\n       \\<lbrakk>defined j; i = MkI\\<cdot>int\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>MkI\\<cdot>int - j\\<rbrakk> =\n                         int - \\<lbrakk>j\\<rbrakk>", "apply (cases j, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma defined_Integer_plus [simp]: \"defined i \\<Longrightarrow> defined j \\<Longrightarrow> defined (i + (j::Integer))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>defined i; defined j\\<rbrakk> \\<Longrightarrow> defined (i + j)", "apply (cases i, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int.\n       \\<lbrakk>defined j; i = MkI\\<cdot>int\\<rbrakk>\n       \\<Longrightarrow> defined (MkI\\<cdot>int + j)", "apply (cases j, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma val_Integer_plus [simp]: \"defined i \\<Longrightarrow> defined j \\<Longrightarrow> \\<lbrakk> i + j \\<rbrakk> = \\<lbrakk> i \\<rbrakk> + \\<lbrakk> j \\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>defined i; defined j\\<rbrakk>\n    \\<Longrightarrow> \\<lbrakk>i + j\\<rbrakk> =\n                      \\<lbrakk>i\\<rbrakk> + \\<lbrakk>j\\<rbrakk>", "apply (cases i, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int.\n       \\<lbrakk>defined j; i = MkI\\<cdot>int\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>MkI\\<cdot>int + j\\<rbrakk> =\n                         int + \\<lbrakk>j\\<rbrakk>", "apply (cases j, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma defined_Integer_eq [simp]: \"defined (eq\\<cdot>a\\<cdot>b) \\<longleftrightarrow> defined a \\<and> defined (b::Integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defined (eq\\<cdot>a\\<cdot>b) = (defined a \\<and> defined b)", "apply (cases a, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int.\n       a = MkI\\<cdot>int \\<Longrightarrow>\n       defined (eq\\<cdot>a\\<cdot>b) = (defined a \\<and> defined b)", "apply (cases b, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int inta.\n       \\<lbrakk>a = MkI\\<cdot>int; b = MkI\\<cdot>inta\\<rbrakk>\n       \\<Longrightarrow> defined (eq\\<cdot>a\\<cdot>b) =\n                         (defined a \\<and> defined b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma val_Integer_eq [simp]: \"defined a \\<Longrightarrow> defined b \\<Longrightarrow> \\<lbrakk> eq\\<cdot>a\\<cdot>b \\<rbrakk> = (\\<lbrakk> a \\<rbrakk> = (\\<lbrakk> b \\<rbrakk> :: int))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>defined a; defined b\\<rbrakk>\n    \\<Longrightarrow> \\<lbrakk>eq\\<cdot>a\\<cdot>b\\<rbrakk> =\n                      (\\<lbrakk>a\\<rbrakk> = \\<lbrakk>b\\<rbrakk>)", "apply (cases a, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int.\n       \\<lbrakk>defined a; defined b; a = MkI\\<cdot>int\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>eq\\<cdot>a\\<cdot>b\\<rbrakk> =\n                         (\\<lbrakk>a\\<rbrakk> = \\<lbrakk>b\\<rbrakk>)", "apply (cases b, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int inta.\n       \\<lbrakk>defined a; defined b; a = MkI\\<cdot>int;\n        b = MkI\\<cdot>inta\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>eq\\<cdot>a\\<cdot>b\\<rbrakk> =\n                         (\\<lbrakk>a\\<rbrakk> = \\<lbrakk>b\\<rbrakk>)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Full induction for non-negative integers\\<close>"], ["", "lemma nonneg_full_Int_induct [consumes 1, case_names neg Suc]:\n  assumes defined: \"defined i\"\n  assumes neg: \"\\<And> i. defined i \\<Longrightarrow> \\<lbrakk>i\\<rbrakk> < 0 \\<Longrightarrow> P i\"\n  assumes step: \"\\<And> i. defined i \\<Longrightarrow> 0 \\<le> \\<lbrakk>i\\<rbrakk> \\<Longrightarrow> (\\<And> j. defined j \\<Longrightarrow> \\<lbrakk> j \\<rbrakk> < \\<lbrakk> i \\<rbrakk> \\<Longrightarrow> P j) \\<Longrightarrow> P i\"\n  shows \"P (i::Integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P i", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = \\<bottom> \\<Longrightarrow> P i\n 2. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "case bottom"], ["proof (state)\nthis:\n  i = \\<bottom>\n\ngoal (2 subgoals):\n 1. i = \\<bottom> \\<Longrightarrow> P i\n 2. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "then"], ["proof (chain)\npicking this:\n  i = \\<bottom>", "have False"], ["proof (prove)\nusing this:\n  i = \\<bottom>\n\ngoal (1 subgoal):\n 1. False", "using defined"], ["proof (prove)\nusing this:\n  i = \\<bottom>\n  defined i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. i = \\<bottom> \\<Longrightarrow> P i\n 2. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. P i", ".."], ["proof (state)\nthis:\n  P i\n\ngoal (1 subgoal):\n 1. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "case (MkI integer)"], ["proof (state)\nthis:\n  i = MkI\\<cdot>integer\n\ngoal (1 subgoal):\n 1. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P i", "proof (cases integer)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i\n 2. \\<And>n. integer = - int (Suc n) \\<Longrightarrow> P i", "case neg"], ["proof (state)\nthis:\n  integer = - int (Suc n_)\n\ngoal (2 subgoals):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i\n 2. \\<And>n. integer = - int (Suc n) \\<Longrightarrow> P i", "then"], ["proof (chain)\npicking this:\n  integer = - int (Suc n_)", "show ?thesis"], ["proof (prove)\nusing this:\n  integer = - int (Suc n_)\n\ngoal (1 subgoal):\n 1. P i", "using assms(2) MkI"], ["proof (prove)\nusing this:\n  integer = - int (Suc n_)\n  \\<lbrakk>defined ?i; \\<lbrakk>?i\\<rbrakk> < 0\\<rbrakk>\n  \\<Longrightarrow> P ?i\n  i = MkI\\<cdot>integer\n\ngoal (1 subgoal):\n 1. P i", "by simp"], ["proof (state)\nthis:\n  P i\n\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i", "case (nonneg nat)"], ["proof (state)\nthis:\n  integer = int nat\n\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i", "have \"P (MkI\\<cdot>(int nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (MkI\\<cdot>(int nat))", "proof(induction nat rule:full_nat_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m.\n          Suc m \\<le> n \\<longrightarrow>\n          P (MkI\\<cdot>(int m)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int n))", "case (1 nat)"], ["proof (state)\nthis:\n  \\<forall>m. Suc m \\<le> nat \\<longrightarrow> P (MkI\\<cdot>(int m))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m.\n          Suc m \\<le> n \\<longrightarrow>\n          P (MkI\\<cdot>(int m)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int n))", "have \"defined (MkI\\<cdot>(int nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defined (MkI\\<cdot>(int nat))", "by simp"], ["proof (state)\nthis:\n  defined (MkI\\<cdot>(int nat))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m.\n          Suc m \\<le> n \\<longrightarrow>\n          P (MkI\\<cdot>(int m)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int n))", "moreover"], ["proof (state)\nthis:\n  defined (MkI\\<cdot>(int nat))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m.\n          Suc m \\<le> n \\<longrightarrow>\n          P (MkI\\<cdot>(int m)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int n))", "have \"0 \\<le> \\<lbrakk> MkI\\<cdot>(int nat) \\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lbrakk>MkI\\<cdot>(int nat)\\<rbrakk>", "by simp"], ["proof (state)\nthis:\n  0 \\<le> \\<lbrakk>MkI\\<cdot>(int nat)\\<rbrakk>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m.\n          Suc m \\<le> n \\<longrightarrow>\n          P (MkI\\<cdot>(int m)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int n))", "moreover"], ["proof (state)\nthis:\n  0 \\<le> \\<lbrakk>MkI\\<cdot>(int nat)\\<rbrakk>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m.\n          Suc m \\<le> n \\<longrightarrow>\n          P (MkI\\<cdot>(int m)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int n))", "{"], ["proof (state)\nthis:\n  0 \\<le> \\<lbrakk>MkI\\<cdot>(int nat)\\<rbrakk>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m.\n          Suc m \\<le> n \\<longrightarrow>\n          P (MkI\\<cdot>(int m)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int n))", "fix j::Integer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m.\n          Suc m \\<le> n \\<longrightarrow>\n          P (MkI\\<cdot>(int m)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int n))", "assume \"defined j\" and le: \"\\<lbrakk> j \\<rbrakk> < \\<lbrakk> MkI\\<cdot>(int nat) \\<rbrakk>\""], ["proof (state)\nthis:\n  defined j\n  \\<lbrakk>j\\<rbrakk> < \\<lbrakk>MkI\\<cdot>(int nat)\\<rbrakk>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m.\n          Suc m \\<le> n \\<longrightarrow>\n          P (MkI\\<cdot>(int m)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int n))", "have \"P j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P j", "proof(cases j)"], ["proof (state)\ngoal (2 subgoals):\n 1. j = \\<bottom> \\<Longrightarrow> P j\n 2. \\<And>int. j = MkI\\<cdot>int \\<Longrightarrow> P j", "case bottom"], ["proof (state)\nthis:\n  j = \\<bottom>\n\ngoal (2 subgoals):\n 1. j = \\<bottom> \\<Longrightarrow> P j\n 2. \\<And>int. j = MkI\\<cdot>int \\<Longrightarrow> P j", "with \\<open>defined j\\<close>"], ["proof (chain)\npicking this:\n  defined j\n  j = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  defined j\n  j = \\<bottom>\n\ngoal (1 subgoal):\n 1. P j", "by simp"], ["proof (state)\nthis:\n  P j\n\ngoal (1 subgoal):\n 1. \\<And>int. j = MkI\\<cdot>int \\<Longrightarrow> P j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>int. j = MkI\\<cdot>int \\<Longrightarrow> P j", "case (MkI integer)"], ["proof (state)\nthis:\n  j = MkI\\<cdot>integer\n\ngoal (1 subgoal):\n 1. \\<And>int. j = MkI\\<cdot>int \\<Longrightarrow> P j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P j", "proof(cases integer)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P j\n 2. \\<And>n. integer = - int (Suc n) \\<Longrightarrow> P j", "case (neg nat)"], ["proof (state)\nthis:\n  integer = - int (Suc nat)\n\ngoal (2 subgoals):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P j\n 2. \\<And>n. integer = - int (Suc n) \\<Longrightarrow> P j", "have \"\\<lbrakk>j\\<rbrakk> < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j\\<rbrakk> < 0", "using neg MkI"], ["proof (prove)\nusing this:\n  integer = - int (Suc nat)\n  j = MkI\\<cdot>integer\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j\\<rbrakk> < 0", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>j\\<rbrakk> < 0\n\ngoal (2 subgoals):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P j\n 2. \\<And>n. integer = - int (Suc n) \\<Longrightarrow> P j", "with \\<open>defined j\\<close>"], ["proof (chain)\npicking this:\n  defined j\n  \\<lbrakk>j\\<rbrakk> < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  defined j\n  \\<lbrakk>j\\<rbrakk> < 0\n\ngoal (1 subgoal):\n 1. P j", "by (rule assms(2))"], ["proof (state)\nthis:\n  P j\n\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P j", "case (nonneg m)"], ["proof (state)\nthis:\n  integer = int m\n\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P j", "have \"Suc m \\<le> nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc m \\<le> nat", "using le nonneg MkI"], ["proof (prove)\nusing this:\n  \\<lbrakk>j\\<rbrakk> < \\<lbrakk>MkI\\<cdot>(int nat)\\<rbrakk>\n  integer = int m\n  j = MkI\\<cdot>integer\n\ngoal (1 subgoal):\n 1. Suc m \\<le> nat", "by simp"], ["proof (state)\nthis:\n  Suc m \\<le> nat\n\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P j", "then"], ["proof (chain)\npicking this:\n  Suc m \\<le> nat", "have \"P (MkI\\<cdot>(int m))\""], ["proof (prove)\nusing this:\n  Suc m \\<le> nat\n\ngoal (1 subgoal):\n 1. P (MkI\\<cdot>(int m))", "by (metis \"1.IH\")"], ["proof (state)\nthis:\n  P (MkI\\<cdot>(int m))\n\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P j", "then"], ["proof (chain)\npicking this:\n  P (MkI\\<cdot>(int m))", "show ?thesis"], ["proof (prove)\nusing this:\n  P (MkI\\<cdot>(int m))\n\ngoal (1 subgoal):\n 1. P j", "using nonneg MkI"], ["proof (prove)\nusing this:\n  P (MkI\\<cdot>(int m))\n  integer = int m\n  j = MkI\\<cdot>integer\n\ngoal (1 subgoal):\n 1. P j", "by simp"], ["proof (state)\nthis:\n  P j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P j\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m.\n          Suc m \\<le> n \\<longrightarrow>\n          P (MkI\\<cdot>(int m)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int n))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>defined ?j2;\n   \\<lbrakk>?j2\\<rbrakk> < \\<lbrakk>MkI\\<cdot>(int nat)\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> P ?j2\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m.\n          Suc m \\<le> n \\<longrightarrow>\n          P (MkI\\<cdot>(int m)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int n))", "ultimately"], ["proof (chain)\npicking this:\n  defined (MkI\\<cdot>(int nat))\n  0 \\<le> \\<lbrakk>MkI\\<cdot>(int nat)\\<rbrakk>\n  \\<lbrakk>defined ?j2;\n   \\<lbrakk>?j2\\<rbrakk> < \\<lbrakk>MkI\\<cdot>(int nat)\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> P ?j2", "show ?case"], ["proof (prove)\nusing this:\n  defined (MkI\\<cdot>(int nat))\n  0 \\<le> \\<lbrakk>MkI\\<cdot>(int nat)\\<rbrakk>\n  \\<lbrakk>defined ?j2;\n   \\<lbrakk>?j2\\<rbrakk> < \\<lbrakk>MkI\\<cdot>(int nat)\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> P ?j2\n\ngoal (1 subgoal):\n 1. P (MkI\\<cdot>(int nat))", "by (rule step)"], ["proof (state)\nthis:\n  P (MkI\\<cdot>(int nat))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (MkI\\<cdot>(int nat))\n\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i", "then"], ["proof (chain)\npicking this:\n  P (MkI\\<cdot>(int nat))", "show ?thesis"], ["proof (prove)\nusing this:\n  P (MkI\\<cdot>(int nat))\n\ngoal (1 subgoal):\n 1. P i", "using nonneg MkI"], ["proof (prove)\nusing this:\n  P (MkI\\<cdot>(int nat))\n  integer = int nat\n  i = MkI\\<cdot>integer\n\ngoal (1 subgoal):\n 1. P i", "by simp"], ["proof (state)\nthis:\n  P i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P i\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Some list lemmas re-done with the new setup.\\<close>"], ["", "lemma nth_tail: (* TODO: move *)\n  \"defined n \\<Longrightarrow> \\<lbrakk> n \\<rbrakk> \\<ge> 0  \\<Longrightarrow> tail\\<cdot>xs !! n = xs !! (1 + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>defined n; 0 \\<le> \\<lbrakk>n\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> tail\\<cdot>xs !! n = xs !! (1 + n)", "apply (cases xs, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>defined n; 0 \\<le> \\<lbrakk>n\\<rbrakk>;\n        xs = a : list\\<rbrakk>\n       \\<Longrightarrow> list !! n = (a : list) !! (1 + n)", "apply (cases n, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list int.\n       \\<lbrakk>defined n; 0 \\<le> \\<lbrakk>n\\<rbrakk>; xs = a : list;\n        n = MkI\\<cdot>int\\<rbrakk>\n       \\<Longrightarrow> list !! n = (a : list) !! (1 + n)", "apply (simp add: one_Integer_def zero_Integer_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_zipWith: (* TODO: move *)\n  assumes f1 [simp]: \"\\<And>y. f\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\"\n  assumes f2 [simp]: \"\\<And>x. f\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"zipWith\\<cdot>f\\<cdot>xs\\<cdot>ys !! n = f\\<cdot>(xs !! n)\\<cdot>(ys !! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zipWith\\<cdot>f\\<cdot>xs\\<cdot>ys !! n =\n    f\\<cdot>(xs !! n)\\<cdot>(ys !! n)", "proof (induct xs arbitrary: ys n)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x xa.\n               zipWith\\<cdot>f\\<cdot>a\\<cdot>x !! xa =\n               f\\<cdot>(a !! xa)\\<cdot>(x !! xa))\n 2. \\<And>ys n.\n       zipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys !! n =\n       f\\<cdot>(\\<bottom> !! n)\\<cdot>(ys !! n)\n 3. \\<And>ys n.\n       zipWith\\<cdot>f\\<cdot>[]\\<cdot>ys !! n =\n       f\\<cdot>([] !! n)\\<cdot>(ys !! n)\n 4. \\<And>a xs ys n.\n       (\\<And>ys n.\n           zipWith\\<cdot>f\\<cdot>xs\\<cdot>ys !! n =\n           f\\<cdot>(xs !! n)\\<cdot>(ys !! n)) \\<Longrightarrow>\n       zipWith\\<cdot>f\\<cdot>(a : xs)\\<cdot>ys !! n =\n       f\\<cdot>((a : xs) !! n)\\<cdot>(ys !! n)", "case (Cons x xs ys n)"], ["proof (state)\nthis:\n  zipWith\\<cdot>f\\<cdot>xs\\<cdot>?ys !! ?n =\n  f\\<cdot>(xs !! ?n)\\<cdot>(?ys !! ?n)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x xa.\n               zipWith\\<cdot>f\\<cdot>a\\<cdot>x !! xa =\n               f\\<cdot>(a !! xa)\\<cdot>(x !! xa))\n 2. \\<And>ys n.\n       zipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys !! n =\n       f\\<cdot>(\\<bottom> !! n)\\<cdot>(ys !! n)\n 3. \\<And>ys n.\n       zipWith\\<cdot>f\\<cdot>[]\\<cdot>ys !! n =\n       f\\<cdot>([] !! n)\\<cdot>(ys !! n)\n 4. \\<And>a xs ys n.\n       (\\<And>ys n.\n           zipWith\\<cdot>f\\<cdot>xs\\<cdot>ys !! n =\n           f\\<cdot>(xs !! n)\\<cdot>(ys !! n)) \\<Longrightarrow>\n       zipWith\\<cdot>f\\<cdot>(a : xs)\\<cdot>ys !! n =\n       f\\<cdot>((a : xs) !! n)\\<cdot>(ys !! n)", "then"], ["proof (chain)\npicking this:\n  zipWith\\<cdot>f\\<cdot>xs\\<cdot>?ys !! ?n =\n  f\\<cdot>(xs !! ?n)\\<cdot>(?ys !! ?n)", "show ?case"], ["proof (prove)\nusing this:\n  zipWith\\<cdot>f\\<cdot>xs\\<cdot>?ys !! ?n =\n  f\\<cdot>(xs !! ?n)\\<cdot>(?ys !! ?n)\n\ngoal (1 subgoal):\n 1. zipWith\\<cdot>f\\<cdot>(x : xs)\\<cdot>ys !! n =\n    f\\<cdot>((x : xs) !! n)\\<cdot>(ys !! n)", "by (cases ys, simp_all split:nth_Cons_split)"], ["proof (state)\nthis:\n  zipWith\\<cdot>f\\<cdot>(x : xs)\\<cdot>ys !! n =\n  f\\<cdot>((x : xs) !! n)\\<cdot>(ys !! n)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x xa.\n               zipWith\\<cdot>f\\<cdot>a\\<cdot>x !! xa =\n               f\\<cdot>(a !! xa)\\<cdot>(x !! xa))\n 2. \\<And>ys n.\n       zipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys !! n =\n       f\\<cdot>(\\<bottom> !! n)\\<cdot>(ys !! n)\n 3. \\<And>ys n.\n       zipWith\\<cdot>f\\<cdot>[]\\<cdot>ys !! n =\n       f\\<cdot>([] !! n)\\<cdot>(ys !! n)", "qed simp_all"], ["", "lemma nth_neg [simp]: \"defined n \\<Longrightarrow> \\<lbrakk> n \\<rbrakk> < 0 \\<Longrightarrow> nth\\<cdot>xs\\<cdot>n = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n    \\<Longrightarrow> xs !! n = \\<bottom>", "proof (induction xs arbitrary: n)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               defined x \\<longrightarrow>\n               \\<lbrakk>x\\<rbrakk> < 0 \\<longrightarrow> a !! x = \\<bottom>)\n 2. \\<And>n.\n       \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> \\<bottom> !! n = \\<bottom>\n 3. \\<And>n.\n       \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> [] !! n = \\<bottom>\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n                   \\<Longrightarrow> xs !! n = \\<bottom>;\n        defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> (a : xs) !! n = \\<bottom>", "have [simp]: \"eq\\<cdot>n\\<cdot>0 = TT \\<longleftrightarrow> (n::Integer) = 0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq\\<cdot>n\\<cdot>0 = TT) = (n = 0)", "by (cases n, auto simp add: zero_Integer_def)"], ["proof (state)\nthis:\n  (eq\\<cdot>?n\\<cdot>0 = TT) = (?n = 0)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               defined x \\<longrightarrow>\n               \\<lbrakk>x\\<rbrakk> < 0 \\<longrightarrow> a !! x = \\<bottom>)\n 2. \\<And>n.\n       \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> \\<bottom> !! n = \\<bottom>\n 3. \\<And>n.\n       \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> [] !! n = \\<bottom>\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n                   \\<Longrightarrow> xs !! n = \\<bottom>;\n        defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> (a : xs) !! n = \\<bottom>", "case (Cons a xs n)"], ["proof (state)\nthis:\n  \\<lbrakk>defined ?n; \\<lbrakk>?n\\<rbrakk> < 0\\<rbrakk>\n  \\<Longrightarrow> xs !! ?n = \\<bottom>\n  defined n\n  \\<lbrakk>n\\<rbrakk> < 0\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               defined x \\<longrightarrow>\n               \\<lbrakk>x\\<rbrakk> < 0 \\<longrightarrow> a !! x = \\<bottom>)\n 2. \\<And>n.\n       \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> \\<bottom> !! n = \\<bottom>\n 3. \\<And>n.\n       \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> [] !! n = \\<bottom>\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n                   \\<Longrightarrow> xs !! n = \\<bottom>;\n        defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> (a : xs) !! n = \\<bottom>", "have \"eq\\<cdot>n\\<cdot>0 = FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>n\\<cdot>0 = FF", "using Cons.prems"], ["proof (prove)\nusing this:\n  defined n\n  \\<lbrakk>n\\<rbrakk> < 0\n\ngoal (1 subgoal):\n 1. eq\\<cdot>n\\<cdot>0 = FF", "by (cases \"eq\\<cdot>n\\<cdot>0\") auto"], ["proof (state)\nthis:\n  eq\\<cdot>n\\<cdot>0 = FF\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               defined x \\<longrightarrow>\n               \\<lbrakk>x\\<rbrakk> < 0 \\<longrightarrow> a !! x = \\<bottom>)\n 2. \\<And>n.\n       \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> \\<bottom> !! n = \\<bottom>\n 3. \\<And>n.\n       \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> [] !! n = \\<bottom>\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n                   \\<Longrightarrow> xs !! n = \\<bottom>;\n        defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> (a : xs) !! n = \\<bottom>", "then"], ["proof (chain)\npicking this:\n  eq\\<cdot>n\\<cdot>0 = FF", "show ?case"], ["proof (prove)\nusing this:\n  eq\\<cdot>n\\<cdot>0 = FF\n\ngoal (1 subgoal):\n 1. (a : xs) !! n = \\<bottom>", "using Cons.prems"], ["proof (prove)\nusing this:\n  eq\\<cdot>n\\<cdot>0 = FF\n  defined n\n  \\<lbrakk>n\\<rbrakk> < 0\n\ngoal (1 subgoal):\n 1. (a : xs) !! n = \\<bottom>", "by (auto intro: Cons.IH)"], ["proof (state)\nthis:\n  (a : xs) !! n = \\<bottom>\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               defined x \\<longrightarrow>\n               \\<lbrakk>x\\<rbrakk> < 0 \\<longrightarrow> a !! x = \\<bottom>)\n 2. \\<And>n.\n       \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> \\<bottom> !! n = \\<bottom>\n 3. \\<And>n.\n       \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> < 0\\<rbrakk>\n       \\<Longrightarrow> [] !! n = \\<bottom>", "qed simp_all"], ["", "lemma nth_Cons_simp [simp]:\n  \"defined n \\<Longrightarrow> \\<lbrakk> n \\<rbrakk> = 0 \\<Longrightarrow> nth\\<cdot>(x : xs)\\<cdot>n = x\"\n  \"defined n \\<Longrightarrow> \\<lbrakk> n \\<rbrakk> > 0 \\<Longrightarrow> nth\\<cdot>(x : xs)\\<cdot>n = nth\\<cdot>xs\\<cdot>(n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> = 0\\<rbrakk>\n     \\<Longrightarrow> (x : xs) !! n = x) &&&\n    (\\<lbrakk>defined n; 0 < \\<lbrakk>n\\<rbrakk>\\<rbrakk>\n     \\<Longrightarrow> (x : xs) !! n = xs !! (n - 1))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> = 0\\<rbrakk>\n    \\<Longrightarrow> (x : xs) !! n = x\n 2. \\<lbrakk>defined n; 0 < \\<lbrakk>n\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (x : xs) !! n = xs !! (n - 1)", "assume \"defined n\" and \"\\<lbrakk> n \\<rbrakk> = 0\""], ["proof (state)\nthis:\n  defined n\n  \\<lbrakk>n\\<rbrakk> = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> = 0\\<rbrakk>\n    \\<Longrightarrow> (x : xs) !! n = x\n 2. \\<lbrakk>defined n; 0 < \\<lbrakk>n\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (x : xs) !! n = xs !! (n - 1)", "then"], ["proof (chain)\npicking this:\n  defined n\n  \\<lbrakk>n\\<rbrakk> = 0", "have \"n = 0\""], ["proof (prove)\nusing this:\n  defined n\n  \\<lbrakk>n\\<rbrakk> = 0\n\ngoal (1 subgoal):\n 1. n = 0", "by (cases n) auto"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>defined n; \\<lbrakk>n\\<rbrakk> = 0\\<rbrakk>\n    \\<Longrightarrow> (x : xs) !! n = x\n 2. \\<lbrakk>defined n; 0 < \\<lbrakk>n\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (x : xs) !! n = xs !! (n - 1)", "then"], ["proof (chain)\npicking this:\n  n = 0", "show \"nth\\<cdot>(x : xs)\\<cdot>n = x\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. (x : xs) !! n = x", "by simp"], ["proof (state)\nthis:\n  (x : xs) !! n = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>defined n; 0 < \\<lbrakk>n\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (x : xs) !! n = xs !! (n - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>defined n; 0 < \\<lbrakk>n\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (x : xs) !! n = xs !! (n - 1)", "assume \"defined n\" and \"\\<lbrakk> n \\<rbrakk> > 0\""], ["proof (state)\nthis:\n  defined n\n  0 < \\<lbrakk>n\\<rbrakk>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>defined n; 0 < \\<lbrakk>n\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (x : xs) !! n = xs !! (n - 1)", "then"], ["proof (chain)\npicking this:\n  defined n\n  0 < \\<lbrakk>n\\<rbrakk>", "have \"eq\\<cdot>n\\<cdot>0 = FF\""], ["proof (prove)\nusing this:\n  defined n\n  0 < \\<lbrakk>n\\<rbrakk>\n\ngoal (1 subgoal):\n 1. eq\\<cdot>n\\<cdot>0 = FF", "by (cases \"eq\\<cdot>n\\<cdot>0\") auto"], ["proof (state)\nthis:\n  eq\\<cdot>n\\<cdot>0 = FF\n\ngoal (1 subgoal):\n 1. \\<lbrakk>defined n; 0 < \\<lbrakk>n\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (x : xs) !! n = xs !! (n - 1)", "then"], ["proof (chain)\npicking this:\n  eq\\<cdot>n\\<cdot>0 = FF", "show \"nth\\<cdot>(x : xs)\\<cdot>n = nth\\<cdot>xs\\<cdot>(n - 1)\""], ["proof (prove)\nusing this:\n  eq\\<cdot>n\\<cdot>0 = FF\n\ngoal (1 subgoal):\n 1. (x : xs) !! n = xs !! (n - 1)", "by simp"], ["proof (state)\nthis:\n  (x : xs) !! n = xs !! (n - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}