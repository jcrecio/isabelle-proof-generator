{"file_name": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude/examples/GHC_Rewrite_Rules.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude", "problem_names": ["lemma cont_listfun_body [simp]:\n  \"cont (\\<lambda>g. Product_Type.fst (Rep_listfun g))\"", "lemma cont_build_body [simp]:\n  \"cont (\\<lambda>g. Product_Type.snd (Rep_listfun g))\"", "lemma build_Abs_listfun:\n  assumes \"abstract_list xs = f\"\n  shows \"build\\<cdot>(Abs_listfun (f, xs)) = xs\"", "lemma listfun_Abs_listfun [simp]:\n  assumes \"abstract_list xs = f\"\n  shows \"listfun\\<cdot>(Abs_listfun (f, xs)) = f\"", "lemma augment_Abs_listfun [simp]:\n  assumes \"abstract_list xs = f\"\n  shows \"augment\\<cdot>(Abs_listfun (f, xs))\\<cdot>ys = xs ++ ys\"", "lemma cont_augment_body [simp]:\n  \"cont (\\<lambda>g. Abs_cfun ((++) (Product_Type.snd (Rep_listfun g))))\"", "lemma \"fold/build\":\n  fixes g :: \"('a, 'b) listfun\"\n  shows \"foldr\\<cdot>k\\<cdot>z\\<cdot>(build\\<cdot>g) = listfun\\<cdot>g\\<cdot>k\\<cdot>z\"", "lemma \"foldr/augment\":\n  fixes g :: \"('a, 'b) listfun\"\n  shows \"foldr\\<cdot>k\\<cdot>z\\<cdot>(augment\\<cdot>g\\<cdot>xs) = listfun\\<cdot>g\\<cdot>k\\<cdot>(foldr\\<cdot>k\\<cdot>z\\<cdot>xs)\"", "lemma \"foldr/id\":\n  \"foldr\\<cdot>(:)\\<cdot>[] = (\\<Lambda> x. x)\"", "lemma \"foldr/app\":\n  \"foldr\\<cdot>(:)\\<cdot>ys = (\\<Lambda> xs. xs ++ ys)\"", "lemma \"foldr/cons\": \"foldr\\<cdot>k\\<cdot>z\\<cdot>(x:xs) = k\\<cdot>x\\<cdot>(foldr\\<cdot>k\\<cdot>z\\<cdot>xs)\"", "lemma \"foldr/single\": \"foldr\\<cdot>k\\<cdot>z\\<cdot>[x] = k\\<cdot>x\\<cdot>z\"", "lemma \"foldr/nil\": \"foldr\\<cdot>k\\<cdot>z\\<cdot>[] = z\"", "lemma cont_listfun_comp_body1 [simp]:\n  \"cont (\\<lambda>h. Abs_listfun (\\<Lambda> c n. listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n), build\\<cdot>g ++ build\\<cdot>h))\"", "lemma cont_listfun_comp_body2 [simp]:\n  \"cont (\\<lambda>g. Abs_listfun (\\<Lambda> c n. listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n), build\\<cdot>g ++ build\\<cdot>h))\"", "lemma cont_listfun_comp_body [simp]:\n  \"cont (\\<lambda>g. \\<Lambda> h. Abs_listfun (\\<Lambda> c n. listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n), build\\<cdot>g ++ build\\<cdot>h))\"", "lemma abstract_list_build_append:\n  \"abstract_list (build\\<cdot>g ++ build\\<cdot>h) = (\\<Lambda> c n. listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n))\"", "lemma \"augment/build\":\n  \"augment\\<cdot>g\\<cdot>(build\\<cdot>h) = build\\<cdot>(g \\<circ>lf h)\"", "lemma \"augment/nil\":\n  \"augment\\<cdot>g\\<cdot>[] = build\\<cdot>g\"", "lemma build_listfun_comp [simp]:\n  \"build\\<cdot>(g \\<circ>lf h) = build\\<cdot>g ++ build\\<cdot>h\"", "lemma augment_augment:\n  \"augment\\<cdot>g\\<cdot>(augment\\<cdot>h\\<cdot>xs) = augment\\<cdot>(g \\<circ>lf h)\\<cdot>xs\"", "lemma abstract_list_map [simp]:\n  \"abstract_list (map\\<cdot>f\\<cdot>xs) = (\\<Lambda> c n. foldr\\<cdot>(mapFB\\<cdot>c\\<cdot>f)\\<cdot>n\\<cdot>xs)\"", "lemma \"map\":\n  \"map\\<cdot>f\\<cdot>xs = build\\<cdot>(Abs_listfun (\\<Lambda> c n. foldr\\<cdot>(mapFB\\<cdot>c\\<cdot>f)\\<cdot>n\\<cdot>xs, map\\<cdot>f\\<cdot>xs))\"", "lemma \"mapList\":\n  \"foldr\\<cdot>(mapFB\\<cdot>(:)\\<cdot>f)\\<cdot>[] = map\\<cdot>f\"", "lemma \"mapFB\":\n  \"mapFB\\<cdot>(mapFB\\<cdot>c\\<cdot>f)\\<cdot>g = mapFB\\<cdot>c\\<cdot>(f oo g)\"", "lemma \"++\":\n  \"xs ++ ys = augment\\<cdot>(Abs_listfun (abstract_list xs, xs))\\<cdot>ys\"", "lemma down'_strict [simp]: \"down'\\<cdot>\\<bottom> = \\<bottom>\"", "lemma abstract_list_down' [simp]:\n  \"abstract_list (down'\\<cdot>v\\<cdot>(:)\\<cdot>[]) = down'\\<cdot>v\"", "lemma cont_Abs_listfun_down' [simp]:\n  \"cont (\\<lambda>v. Abs_listfun (down'\\<cdot>v, down'\\<cdot>v\\<cdot>(:)\\<cdot>[]))\"", "lemma sum_down:\n  \"sum\\<cdot>((down TYPE(Integer))\\<cdot>v) = down'\\<cdot>v\\<cdot>(+)\\<cdot>0\""], "translations": [["", "lemma cont_listfun_body [simp]:\n  \"cont (\\<lambda>g. Product_Type.fst (Rep_listfun g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>g. prod.fst (Rep_listfun g))", "by (simp add: cont_Rep_listfun)"], ["", "lemma cont_build_body [simp]:\n  \"cont (\\<lambda>g. Product_Type.snd (Rep_listfun g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>g. prod.snd (Rep_listfun g))", "by (simp add: cont_Rep_listfun)"], ["", "lemma build_Abs_listfun:\n  assumes \"abstract_list xs = f\"\n  shows \"build\\<cdot>(Abs_listfun (f, xs)) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build\\<cdot>(Abs_listfun (f, xs)) = xs", "using assms and Abs_listfun_inverse [of \"(f, xs)\"]"], ["proof (prove)\nusing this:\n  (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs) = f\n  (f, xs)\n  \\<in> {(f, xs).\n         f =\n         (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)} \\<Longrightarrow>\n  Rep_listfun (Abs_listfun (f, xs)) = (f, xs)\n\ngoal (1 subgoal):\n 1. build\\<cdot>(Abs_listfun (f, xs)) = xs", "by (simp add: build_def)"], ["", "lemma listfun_Abs_listfun [simp]:\n  assumes \"abstract_list xs = f\"\n  shows \"listfun\\<cdot>(Abs_listfun (f, xs)) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. listfun\\<cdot>(Abs_listfun (f, xs)) = f", "using assms and Abs_listfun_inverse [of \"(f, xs)\"]"], ["proof (prove)\nusing this:\n  (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs) = f\n  (f, xs)\n  \\<in> {(f, xs).\n         f =\n         (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)} \\<Longrightarrow>\n  Rep_listfun (Abs_listfun (f, xs)) = (f, xs)\n\ngoal (1 subgoal):\n 1. listfun\\<cdot>(Abs_listfun (f, xs)) = f", "by (simp add: listfun_def)"], ["", "lemma augment_Abs_listfun [simp]:\n  assumes \"abstract_list xs = f\"\n  shows \"augment\\<cdot>(Abs_listfun (f, xs))\\<cdot>ys = xs ++ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment\\<cdot>(Abs_listfun (f, xs))\\<cdot>ys = xs ++ ys", "using assms and Abs_listfun_inverse [of \"(f, xs)\"]"], ["proof (prove)\nusing this:\n  (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs) = f\n  (f, xs)\n  \\<in> {(f, xs).\n         f =\n         (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)} \\<Longrightarrow>\n  Rep_listfun (Abs_listfun (f, xs)) = (f, xs)\n\ngoal (1 subgoal):\n 1. augment\\<cdot>(Abs_listfun (f, xs))\\<cdot>ys = xs ++ ys", "by (simp add: augment_def build_Abs_listfun)"], ["", "lemma cont_augment_body [simp]:\n  \"cont (\\<lambda>g. Abs_cfun ((++) (Product_Type.snd (Rep_listfun g))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>g. Abs_cfun ((++) (prod.snd (Rep_listfun g))))", "by (simp add: cont_Rep_listfun)"], ["", "lemma \"fold/build\":\n  fixes g :: \"('a, 'b) listfun\"\n  shows \"foldr\\<cdot>k\\<cdot>z\\<cdot>(build\\<cdot>g) = listfun\\<cdot>g\\<cdot>k\\<cdot>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>k\\<cdot>z\\<cdot>(build\\<cdot>g) =\n    listfun\\<cdot>g\\<cdot>k\\<cdot>z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldr\\<cdot>k\\<cdot>z\\<cdot>(build\\<cdot>g) =\n    listfun\\<cdot>g\\<cdot>k\\<cdot>z", "from Rep_listfun"], ["proof (chain)\npicking this:\n  Rep_listfun ?x\n  \\<in> {(f, xs). f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)}", "obtain f xs where\n    \"Rep_listfun g = (f, xs)\" and \"f = abstract_list xs\""], ["proof (prove)\nusing this:\n  Rep_listfun ?x\n  \\<in> {(f, xs). f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)}\n\ngoal (1 subgoal):\n 1. (\\<And>f xs.\n        \\<lbrakk>Rep_listfun g = (f, xs);\n         f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Rep_listfun g = (f, xs)\n  f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. foldr\\<cdot>k\\<cdot>z\\<cdot>(build\\<cdot>g) =\n    listfun\\<cdot>g\\<cdot>k\\<cdot>z", "then"], ["proof (chain)\npicking this:\n  Rep_listfun g = (f, xs)\n  f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  Rep_listfun g = (f, xs)\n  f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. foldr\\<cdot>k\\<cdot>z\\<cdot>(build\\<cdot>g) =\n    listfun\\<cdot>g\\<cdot>k\\<cdot>z", "by (simp add: build_def listfun_def)"], ["proof (state)\nthis:\n  foldr\\<cdot>k\\<cdot>z\\<cdot>(build\\<cdot>g) =\n  listfun\\<cdot>g\\<cdot>k\\<cdot>z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"foldr/augment\":\n  fixes g :: \"('a, 'b) listfun\"\n  shows \"foldr\\<cdot>k\\<cdot>z\\<cdot>(augment\\<cdot>g\\<cdot>xs) = listfun\\<cdot>g\\<cdot>k\\<cdot>(foldr\\<cdot>k\\<cdot>z\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>k\\<cdot>z\\<cdot>(augment\\<cdot>g\\<cdot>xs) =\n    listfun\\<cdot>g\\<cdot>k\\<cdot>(foldr\\<cdot>k\\<cdot>z\\<cdot>xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldr\\<cdot>k\\<cdot>z\\<cdot>(augment\\<cdot>g\\<cdot>xs) =\n    listfun\\<cdot>g\\<cdot>k\\<cdot>(foldr\\<cdot>k\\<cdot>z\\<cdot>xs)", "from Rep_listfun"], ["proof (chain)\npicking this:\n  Rep_listfun ?x\n  \\<in> {(f, xs). f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)}", "obtain f ys where\n    \"Rep_listfun g = (f, ys)\" and \"f = abstract_list ys\""], ["proof (prove)\nusing this:\n  Rep_listfun ?x\n  \\<in> {(f, xs). f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)}\n\ngoal (1 subgoal):\n 1. (\\<And>f ys.\n        \\<lbrakk>Rep_listfun g = (f, ys);\n         f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Rep_listfun g = (f, ys)\n  f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>ys)\n\ngoal (1 subgoal):\n 1. foldr\\<cdot>k\\<cdot>z\\<cdot>(augment\\<cdot>g\\<cdot>xs) =\n    listfun\\<cdot>g\\<cdot>k\\<cdot>(foldr\\<cdot>k\\<cdot>z\\<cdot>xs)", "then"], ["proof (chain)\npicking this:\n  Rep_listfun g = (f, ys)\n  f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  Rep_listfun g = (f, ys)\n  f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>ys)\n\ngoal (1 subgoal):\n 1. foldr\\<cdot>k\\<cdot>z\\<cdot>(augment\\<cdot>g\\<cdot>xs) =\n    listfun\\<cdot>g\\<cdot>k\\<cdot>(foldr\\<cdot>k\\<cdot>z\\<cdot>xs)", "by (simp add: augment_def build_def listfun_def)"], ["proof (state)\nthis:\n  foldr\\<cdot>k\\<cdot>z\\<cdot>(augment\\<cdot>g\\<cdot>xs) =\n  listfun\\<cdot>g\\<cdot>k\\<cdot>(foldr\\<cdot>k\\<cdot>z\\<cdot>xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"foldr/id\":\n  \"foldr\\<cdot>(:)\\<cdot>[] = (\\<Lambda> x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>Cons\\<cdot>[] = (\\<Lambda> x. x)", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldr\\<cdot>Cons\\<cdot>[]\\<cdot>x = (\\<Lambda> x. x)\\<cdot>x", "fix xs :: \"['a]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldr\\<cdot>Cons\\<cdot>[]\\<cdot>x = (\\<Lambda> x. x)\\<cdot>x", "show \"foldr\\<cdot>(:)\\<cdot>[]\\<cdot>xs = (\\<Lambda> x. x)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>Cons\\<cdot>[]\\<cdot>xs = (\\<Lambda> x. x)\\<cdot>xs", "by (induction xs) simp+"], ["proof (state)\nthis:\n  foldr\\<cdot>Cons\\<cdot>[]\\<cdot>xs = (\\<Lambda> x. x)\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"foldr/app\":\n  \"foldr\\<cdot>(:)\\<cdot>ys = (\\<Lambda> xs. xs ++ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>Cons\\<cdot>ys = (\\<Lambda> xs. xs ++ ys)", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       foldr\\<cdot>Cons\\<cdot>ys\\<cdot>x = (\\<Lambda> xs. xs ++ ys)\\<cdot>x", "fix xs :: \"['a]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       foldr\\<cdot>Cons\\<cdot>ys\\<cdot>x = (\\<Lambda> xs. xs ++ ys)\\<cdot>x", "show \"foldr\\<cdot>(:)\\<cdot>ys\\<cdot>xs = (\\<Lambda> xs. xs ++ ys)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>Cons\\<cdot>ys\\<cdot>xs = (\\<Lambda> xs. xs ++ ys)\\<cdot>xs", "by (induct xs) simp+"], ["proof (state)\nthis:\n  foldr\\<cdot>Cons\\<cdot>ys\\<cdot>xs = (\\<Lambda> xs. xs ++ ys)\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"foldr/cons\": \"foldr\\<cdot>k\\<cdot>z\\<cdot>(x:xs) = k\\<cdot>x\\<cdot>(foldr\\<cdot>k\\<cdot>z\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>k\\<cdot>z\\<cdot>(x : xs) =\n    k\\<cdot>x\\<cdot>(foldr\\<cdot>k\\<cdot>z\\<cdot>xs)", "by simp"], ["", "lemma \"foldr/single\": \"foldr\\<cdot>k\\<cdot>z\\<cdot>[x] = k\\<cdot>x\\<cdot>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>k\\<cdot>z\\<cdot>[x] = k\\<cdot>x\\<cdot>z", "by simp"], ["", "lemma \"foldr/nil\": \"foldr\\<cdot>k\\<cdot>z\\<cdot>[] = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>k\\<cdot>z\\<cdot>[] = z", "by simp"], ["", "lemma cont_listfun_comp_body1 [simp]:\n  \"cont (\\<lambda>h. Abs_listfun (\\<Lambda> c n. listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n), build\\<cdot>g ++ build\\<cdot>h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>h.\n         Abs_listfun\n          (\\<Lambda> c n.\n              listfun\\<cdot>g\\<cdot>c\\<cdot>\n              (listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n           build\\<cdot>g ++ build\\<cdot>h))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>h.\n         Abs_listfun\n          (\\<Lambda> c n.\n              listfun\\<cdot>g\\<cdot>c\\<cdot>\n              (listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n           build\\<cdot>g ++ build\\<cdot>h))", "have \"\\<And>h.\n    (\\<Lambda> c n. listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n), build\\<cdot>g ++ build\\<cdot>h) \\<in> {(f, xs). f = abstract_list xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (\\<Lambda> c n.\n           listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n        build\\<cdot>g ++ build\\<cdot>h)\n       \\<in> {(f, xs). f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)}", "by (simp add: \"fold/build\")"], ["proof (state)\nthis:\n  (\\<Lambda> c n.\n      listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>?h\\<cdot>c\\<cdot>n),\n   build\\<cdot>g ++ build\\<cdot>?h)\n  \\<in> {(f, xs). f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)}\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>h.\n         Abs_listfun\n          (\\<Lambda> c n.\n              listfun\\<cdot>g\\<cdot>c\\<cdot>\n              (listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n           build\\<cdot>g ++ build\\<cdot>h))", "from cont_Abs_listfun [OF this, of \"\\<lambda>x. x\"]"], ["proof (chain)\npicking this:\n  cont\n   (\\<lambda>x.\n       (\\<Lambda> c n.\n           listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>x\\<cdot>c\\<cdot>n),\n        build\\<cdot>g ++ build\\<cdot>x)) \\<Longrightarrow>\n  cont\n   (\\<lambda>x.\n       Abs_listfun\n        (\\<Lambda> c n.\n            listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>x\\<cdot>c\\<cdot>n),\n         build\\<cdot>g ++ build\\<cdot>x))", "show ?thesis"], ["proof (prove)\nusing this:\n  cont\n   (\\<lambda>x.\n       (\\<Lambda> c n.\n           listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>x\\<cdot>c\\<cdot>n),\n        build\\<cdot>g ++ build\\<cdot>x)) \\<Longrightarrow>\n  cont\n   (\\<lambda>x.\n       Abs_listfun\n        (\\<Lambda> c n.\n            listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>x\\<cdot>c\\<cdot>n),\n         build\\<cdot>g ++ build\\<cdot>x))\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>h.\n         Abs_listfun\n          (\\<Lambda> c n.\n              listfun\\<cdot>g\\<cdot>c\\<cdot>\n              (listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n           build\\<cdot>g ++ build\\<cdot>h))", "by simp"], ["proof (state)\nthis:\n  cont\n   (\\<lambda>h.\n       Abs_listfun\n        (\\<Lambda> c n.\n            listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n         build\\<cdot>g ++ build\\<cdot>h))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cont_listfun_comp_body2 [simp]:\n  \"cont (\\<lambda>g. Abs_listfun (\\<Lambda> c n. listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n), build\\<cdot>g ++ build\\<cdot>h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>g.\n         Abs_listfun\n          (\\<Lambda> c n.\n              listfun\\<cdot>g\\<cdot>c\\<cdot>\n              (listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n           build\\<cdot>g ++ build\\<cdot>h))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>g.\n         Abs_listfun\n          (\\<Lambda> c n.\n              listfun\\<cdot>g\\<cdot>c\\<cdot>\n              (listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n           build\\<cdot>g ++ build\\<cdot>h))", "have \"\\<And>g.\n    (\\<Lambda> c n. listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n), build\\<cdot>g ++ build\\<cdot>h) \\<in> {(f, xs). f = abstract_list xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (\\<Lambda> c n.\n           listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n        build\\<cdot>g ++ build\\<cdot>h)\n       \\<in> {(f, xs). f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)}", "by (simp add: \"fold/build\")"], ["proof (state)\nthis:\n  (\\<Lambda> c n.\n      listfun\\<cdot>?g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n   build\\<cdot>?g ++ build\\<cdot>h)\n  \\<in> {(f, xs). f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)}\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>g.\n         Abs_listfun\n          (\\<Lambda> c n.\n              listfun\\<cdot>g\\<cdot>c\\<cdot>\n              (listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n           build\\<cdot>g ++ build\\<cdot>h))", "from cont_Abs_listfun [OF this, of \"\\<lambda>x. x\"]"], ["proof (chain)\npicking this:\n  cont\n   (\\<lambda>x.\n       (\\<Lambda> c n.\n           listfun\\<cdot>x\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n        build\\<cdot>x ++ build\\<cdot>h)) \\<Longrightarrow>\n  cont\n   (\\<lambda>x.\n       Abs_listfun\n        (\\<Lambda> c n.\n            listfun\\<cdot>x\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n         build\\<cdot>x ++ build\\<cdot>h))", "show ?thesis"], ["proof (prove)\nusing this:\n  cont\n   (\\<lambda>x.\n       (\\<Lambda> c n.\n           listfun\\<cdot>x\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n        build\\<cdot>x ++ build\\<cdot>h)) \\<Longrightarrow>\n  cont\n   (\\<lambda>x.\n       Abs_listfun\n        (\\<Lambda> c n.\n            listfun\\<cdot>x\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n         build\\<cdot>x ++ build\\<cdot>h))\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>g.\n         Abs_listfun\n          (\\<Lambda> c n.\n              listfun\\<cdot>g\\<cdot>c\\<cdot>\n              (listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n           build\\<cdot>g ++ build\\<cdot>h))", "by simp"], ["proof (state)\nthis:\n  cont\n   (\\<lambda>g.\n       Abs_listfun\n        (\\<Lambda> c n.\n            listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n         build\\<cdot>g ++ build\\<cdot>h))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cont_listfun_comp_body [simp]:\n  \"cont (\\<lambda>g. \\<Lambda> h. Abs_listfun (\\<Lambda> c n. listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n), build\\<cdot>g ++ build\\<cdot>h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>g.\n         \\<Lambda> h.\n            Abs_listfun\n             (\\<Lambda> c n.\n                 listfun\\<cdot>g\\<cdot>c\\<cdot>\n                 (listfun\\<cdot>h\\<cdot>c\\<cdot>n),\n              build\\<cdot>g ++ build\\<cdot>h))", "by (rule cont2cont_LAM) simp+"], ["", "lemma abstract_list_build_append:\n  \"abstract_list (build\\<cdot>g ++ build\\<cdot>h) = (\\<Lambda> c n. listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>(build\\<cdot>g ++ build\\<cdot>h)) =\n    (\\<Lambda> c n.\n        listfun\\<cdot>g\\<cdot>c\\<cdot>(listfun\\<cdot>h\\<cdot>c\\<cdot>n))", "by (intro cfun_eqI) (simp add: \"fold/build\")"], ["", "lemma \"augment/build\":\n  \"augment\\<cdot>g\\<cdot>(build\\<cdot>h) = build\\<cdot>(g \\<circ>lf h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment\\<cdot>g\\<cdot>(build\\<cdot>h) = build\\<cdot>(g \\<circ>lf h)", "by (simp add: listfun_comp_def augment_def build_Abs_listfun [OF abstract_list_build_append])"], ["", "lemma \"augment/nil\":\n  \"augment\\<cdot>g\\<cdot>[] = build\\<cdot>g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment\\<cdot>g\\<cdot>[] = build\\<cdot>g", "by (simp add: augment_def)"], ["", "lemma build_listfun_comp [simp]:\n  \"build\\<cdot>(g \\<circ>lf h) = build\\<cdot>g ++ build\\<cdot>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build\\<cdot>(g \\<circ>lf h) = build\\<cdot>g ++ build\\<cdot>h", "unfolding \"augment/build\" [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. augment\\<cdot>g\\<cdot>(build\\<cdot>h) = build\\<cdot>g ++ build\\<cdot>h", "by (simp add: augment_def)"], ["", "lemma augment_augment:\n  \"augment\\<cdot>g\\<cdot>(augment\\<cdot>h\\<cdot>xs) = augment\\<cdot>(g \\<circ>lf h)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment\\<cdot>g\\<cdot>(augment\\<cdot>h\\<cdot>xs) =\n    augment\\<cdot>(g \\<circ>lf h)\\<cdot>xs", "by (simp add: augment_def)"], ["", "lemma abstract_list_map [simp]:\n  \"abstract_list (map\\<cdot>f\\<cdot>xs) = (\\<Lambda> c n. foldr\\<cdot>(mapFB\\<cdot>c\\<cdot>f)\\<cdot>n\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>(map\\<cdot>f\\<cdot>xs)) =\n    (\\<Lambda> c n. foldr\\<cdot>(mapFB\\<cdot>c\\<cdot>f)\\<cdot>n\\<cdot>xs)", "by (intro cfun_eqI, induct xs) simp+"], ["", "lemma \"map\":\n  \"map\\<cdot>f\\<cdot>xs = build\\<cdot>(Abs_listfun (\\<Lambda> c n. foldr\\<cdot>(mapFB\\<cdot>c\\<cdot>f)\\<cdot>n\\<cdot>xs, map\\<cdot>f\\<cdot>xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>f\\<cdot>xs =\n    build\\<cdot>\n    (Abs_listfun\n      (\\<Lambda> c n. foldr\\<cdot>(mapFB\\<cdot>c\\<cdot>f)\\<cdot>n\\<cdot>xs,\n       map\\<cdot>f\\<cdot>xs))", "by (simp add: build_Abs_listfun)"], ["", "lemma \"mapList\":\n  \"foldr\\<cdot>(mapFB\\<cdot>(:)\\<cdot>f)\\<cdot>[] = map\\<cdot>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>(mapFB\\<cdot>Cons\\<cdot>f)\\<cdot>[] = map\\<cdot>f", "by (rule cfun_eqI, rename_tac x, induct_tac x) simp+"], ["", "lemma \"mapFB\":\n  \"mapFB\\<cdot>(mapFB\\<cdot>c\\<cdot>f)\\<cdot>g = mapFB\\<cdot>c\\<cdot>(f oo g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapFB\\<cdot>(mapFB\\<cdot>c\\<cdot>f)\\<cdot>g =\n    mapFB\\<cdot>c\\<cdot>(f oo g)", "by simp"], ["", "lemma \"++\":\n  \"xs ++ ys = augment\\<cdot>(Abs_listfun (abstract_list xs, xs))\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ++ ys =\n    augment\\<cdot>\n    (Abs_listfun (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs, xs))\\<cdot>\n    ys", "by simp"], ["", "subsection \\<open>Examples\\<close>"], ["", "fixrec sum :: \"[Integer] \\<rightarrow> Integer\" where\n  \"sum\\<cdot>xs = foldr\\<cdot>(+)\\<cdot>0\\<cdot>xs\""], ["", "fixrec down' :: \"Integer \\<rightarrow> (Integer \\<rightarrow> 'a \\<rightarrow> 'a) \\<rightarrow> 'a \\<rightarrow> 'a\" where\n  \"down'\\<cdot>v\\<cdot>c\\<cdot>n = If le\\<cdot>1\\<cdot>v then c\\<cdot>v\\<cdot>(down'\\<cdot>(v - 1)\\<cdot>c\\<cdot>n) else n\""], ["", "declare down'.simps [simp del]"], ["", "lemma down'_strict [simp]: \"down'\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. down'\\<cdot>\\<bottom> = \\<bottom>", "by (fixrec_simp)"], ["", "definition down :: \"'b itself \\<Rightarrow> Integer \\<rightarrow> [Integer]\" where\n  \"down C_type = (\\<Lambda> v. build\\<cdot>(Abs_listfun (\n    (down' :: Integer \\<rightarrow> (Integer \\<rightarrow> 'b \\<rightarrow> 'b) \\<rightarrow> 'b \\<rightarrow> 'b)\\<cdot>v,\n    down'\\<cdot>v\\<cdot>(:)\\<cdot>[])))\""], ["", "lemma abstract_list_down' [simp]:\n  \"abstract_list (down'\\<cdot>v\\<cdot>(:)\\<cdot>[]) = down'\\<cdot>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>(down'\\<cdot>v\\<cdot>Cons\\<cdot>[])) =\n    down'\\<cdot>v", "proof (intro cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<Lambda> c n.\n           foldr\\<cdot>c\\<cdot>n\\<cdot>\n           (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n       x\\<cdot>\n       xa =\n       down'\\<cdot>v\\<cdot>x\\<cdot>xa", "fix c :: \"Integer \\<rightarrow> 'b \\<rightarrow> 'b\" and n :: \"'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<Lambda> c n.\n           foldr\\<cdot>c\\<cdot>n\\<cdot>\n           (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n       x\\<cdot>\n       xa =\n       down'\\<cdot>v\\<cdot>x\\<cdot>xa", "show \"(abstract_list (down'\\<cdot>v\\<cdot>(:)\\<cdot>[]))\\<cdot>c\\<cdot>n = down'\\<cdot>v\\<cdot>c\\<cdot>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "proof (cases \"le\\<cdot>1\\<cdot>v\")"], ["proof (state)\ngoal (3 subgoals):\n 1. le\\<cdot>1\\<cdot>v = \\<bottom> \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n\n 2. le\\<cdot>1\\<cdot>v = TT \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n\n 3. le\\<cdot>1\\<cdot>v = FF \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "assume \"le\\<cdot>1\\<cdot>v = \\<bottom>\""], ["proof (state)\nthis:\n  le\\<cdot>1\\<cdot>v = \\<bottom>\n\ngoal (3 subgoals):\n 1. le\\<cdot>1\\<cdot>v = \\<bottom> \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n\n 2. le\\<cdot>1\\<cdot>v = TT \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n\n 3. le\\<cdot>1\\<cdot>v = FF \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "then"], ["proof (chain)\npicking this:\n  le\\<cdot>1\\<cdot>v = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  le\\<cdot>1\\<cdot>v = \\<bottom>\n\ngoal (1 subgoal):\n 1. (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "by simp"], ["proof (state)\nthis:\n  (\\<Lambda> c n.\n      foldr\\<cdot>c\\<cdot>n\\<cdot>\n      (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n  c\\<cdot>\n  n =\n  down'\\<cdot>v\\<cdot>c\\<cdot>n\n\ngoal (2 subgoals):\n 1. le\\<cdot>1\\<cdot>v = TT \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n\n 2. le\\<cdot>1\\<cdot>v = FF \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. le\\<cdot>1\\<cdot>v = TT \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n\n 2. le\\<cdot>1\\<cdot>v = FF \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "assume \"le\\<cdot>1\\<cdot>v = FF\""], ["proof (state)\nthis:\n  le\\<cdot>1\\<cdot>v = FF\n\ngoal (2 subgoals):\n 1. le\\<cdot>1\\<cdot>v = TT \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n\n 2. le\\<cdot>1\\<cdot>v = FF \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "then"], ["proof (chain)\npicking this:\n  le\\<cdot>1\\<cdot>v = FF", "show ?thesis"], ["proof (prove)\nusing this:\n  le\\<cdot>1\\<cdot>v = FF\n\ngoal (1 subgoal):\n 1. (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "by (subst (1 2) down'.simps) simp"], ["proof (state)\nthis:\n  (\\<Lambda> c n.\n      foldr\\<cdot>c\\<cdot>n\\<cdot>\n      (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n  c\\<cdot>\n  n =\n  down'\\<cdot>v\\<cdot>c\\<cdot>n\n\ngoal (1 subgoal):\n 1. le\\<cdot>1\\<cdot>v = TT \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. le\\<cdot>1\\<cdot>v = TT \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "have \"le\\<cdot>(0::Integer)\\<cdot>1 = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>0\\<cdot>1 = TT", "by simp"], ["proof (state)\nthis:\n  le\\<cdot>0\\<cdot>1 = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>1\\<cdot>v = TT \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "moreover"], ["proof (state)\nthis:\n  le\\<cdot>0\\<cdot>1 = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>1\\<cdot>v = TT \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "assume \"le\\<cdot>1\\<cdot>v = TT\""], ["proof (state)\nthis:\n  le\\<cdot>1\\<cdot>v = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>1\\<cdot>v = TT \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "ultimately"], ["proof (chain)\npicking this:\n  le\\<cdot>0\\<cdot>1 = TT\n  le\\<cdot>1\\<cdot>v = TT", "have \"le\\<cdot>0\\<cdot>v = TT\""], ["proof (prove)\nusing this:\n  le\\<cdot>0\\<cdot>1 = TT\n  le\\<cdot>1\\<cdot>v = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>0\\<cdot>v = TT", "by (rule le_trans)"], ["proof (state)\nthis:\n  le\\<cdot>0\\<cdot>v = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>1\\<cdot>v = TT \\<Longrightarrow>\n    (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "then"], ["proof (chain)\npicking this:\n  le\\<cdot>0\\<cdot>v = TT", "show ?thesis"], ["proof (prove)\nusing this:\n  le\\<cdot>0\\<cdot>v = TT\n\ngoal (1 subgoal):\n 1. (\\<Lambda> c n.\n        foldr\\<cdot>c\\<cdot>n\\<cdot>\n        (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n    c\\<cdot>\n    n =\n    down'\\<cdot>v\\<cdot>c\\<cdot>n", "by (induct v rule: nonneg_Integer_induct)\n         (subst (1 2) down'.simps, simp)+"], ["proof (state)\nthis:\n  (\\<Lambda> c n.\n      foldr\\<cdot>c\\<cdot>n\\<cdot>\n      (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n  c\\<cdot>\n  n =\n  down'\\<cdot>v\\<cdot>c\\<cdot>n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Lambda> c n.\n      foldr\\<cdot>c\\<cdot>n\\<cdot>\n      (down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\\<cdot>\n  c\\<cdot>\n  n =\n  down'\\<cdot>v\\<cdot>c\\<cdot>n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cont_Abs_listfun_down' [simp]:\n  \"cont (\\<lambda>v. Abs_listfun (down'\\<cdot>v, down'\\<cdot>v\\<cdot>(:)\\<cdot>[]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>v.\n         Abs_listfun (down'\\<cdot>v, down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>v.\n         Abs_listfun (down'\\<cdot>v, down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))", "have \"\\<And>v. (down'\\<cdot>v, down'\\<cdot>v\\<cdot>(:)\\<cdot>[]) \\<in> {(f, xs). f = abstract_list xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       (down'\\<cdot>v, down'\\<cdot>v\\<cdot>Cons\\<cdot>[])\n       \\<in> {(f, xs). f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)}", "by simp"], ["proof (state)\nthis:\n  (down'\\<cdot>?v, down'\\<cdot>?v\\<cdot>Cons\\<cdot>[])\n  \\<in> {(f, xs). f = (\\<Lambda> c n. foldr\\<cdot>c\\<cdot>n\\<cdot>xs)}\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>v.\n         Abs_listfun (down'\\<cdot>v, down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))", "from cont_Abs_listfun [OF this, of id]"], ["proof (chain)\npicking this:\n  cont\n   (\\<lambda>x.\n       (down'\\<cdot>(id x),\n        down'\\<cdot>(id x)\\<cdot>Cons\\<cdot>[])) \\<Longrightarrow>\n  cont\n   (\\<lambda>x.\n       Abs_listfun\n        (down'\\<cdot>(id x), down'\\<cdot>(id x)\\<cdot>Cons\\<cdot>[]))", "show ?thesis"], ["proof (prove)\nusing this:\n  cont\n   (\\<lambda>x.\n       (down'\\<cdot>(id x),\n        down'\\<cdot>(id x)\\<cdot>Cons\\<cdot>[])) \\<Longrightarrow>\n  cont\n   (\\<lambda>x.\n       Abs_listfun\n        (down'\\<cdot>(id x), down'\\<cdot>(id x)\\<cdot>Cons\\<cdot>[]))\n\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>v.\n         Abs_listfun (down'\\<cdot>v, down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))", "by simp"], ["proof (state)\nthis:\n  cont\n   (\\<lambda>v.\n       Abs_listfun (down'\\<cdot>v, down'\\<cdot>v\\<cdot>Cons\\<cdot>[]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_down:\n  \"sum\\<cdot>((down TYPE(Integer))\\<cdot>v) = down'\\<cdot>v\\<cdot>(+)\\<cdot>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GHC_Rewrite_Rules.sum\\<cdot>(down TYPE(Integer)\\<cdot>v) =\n    down'\\<cdot>v\\<cdot>(+)\\<cdot>0", "by (simp add: down_def \"fold/build\")"], ["", "end"]]}