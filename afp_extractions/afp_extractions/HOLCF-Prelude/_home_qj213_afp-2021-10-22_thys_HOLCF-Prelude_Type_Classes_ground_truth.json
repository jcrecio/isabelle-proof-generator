{"file_name": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude/Type_Classes.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude", "problem_names": ["lemma eq_refl: \"eq\\<cdot>x\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow> eq\\<cdot>x\\<cdot>x = TT\"", "lemma eqD [dest]:\n  \"eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y\"\n  \"eq\\<cdot>x\\<cdot>y = FF \\<Longrightarrow> x \\<noteq> y\"", "lemma eq_ONE_ONE [simp]: \"eq\\<cdot>ONE\\<cdot>ONE = TT\"", "lemma oppOrdering_simps [simp]:\n  \"oppOrdering\\<cdot>LT = GT\"\n  \"oppOrdering\\<cdot>EQ = EQ\"\n  \"oppOrdering\\<cdot>GT = LT\"\n  \"oppOrdering\\<cdot>\\<bottom> = \\<bottom>\"", "lemma lt_eq_TT_iff: \"lt\\<cdot>x\\<cdot>y = TT \\<longleftrightarrow> compare\\<cdot>x\\<cdot>y = LT\"", "lemma lt_strict [simp]:\n  shows \"lt\\<cdot>\\<bottom>\\<cdot>x = \\<bottom>\"\n    and \"lt\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"", "lemma le_strict [simp]:\n  shows \"le\\<cdot>\\<bottom>\\<cdot>x = \\<bottom>\"\n    and \"le\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"", "lemma eq_TT_dest: \"eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y\"", "lemma le_iff_lt_or_eq:\n  \"le\\<cdot>x\\<cdot>y = TT \\<longleftrightarrow> lt\\<cdot>x\\<cdot>y = TT \\<or> eq\\<cdot>x\\<cdot>y = TT\"", "lemma compare_sym:\n  \"compare\\<cdot>x\\<cdot>y = (case compare\\<cdot>y\\<cdot>x of LT \\<Rightarrow> GT | EQ \\<Rightarrow> EQ | GT \\<Rightarrow> LT)\"", "lemma compare_self_neq_LT [simp]: \"compare\\<cdot>x\\<cdot>x \\<noteq> LT\"", "lemma compare_self_neq_GT [simp]: \"compare\\<cdot>x\\<cdot>x \\<noteq> GT\"", "lemma lt_trans: \"lt\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> lt\\<cdot>y\\<cdot>z = TT \\<Longrightarrow> lt\\<cdot>x\\<cdot>z = TT\"", "lemma compare_GT_iff_LT: \"compare\\<cdot>x\\<cdot>y = GT \\<longleftrightarrow> compare\\<cdot>y\\<cdot>x = LT\"", "lemma compare_GT_trans:\n  \"compare\\<cdot>x\\<cdot>y = GT \\<Longrightarrow> compare\\<cdot>y\\<cdot>z = GT \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = GT\"", "lemma compare_EQ_iff_eq_TT:\n  \"compare\\<cdot>x\\<cdot>y = EQ \\<longleftrightarrow> eq\\<cdot>x\\<cdot>y = TT\"", "lemma compare_EQ_trans:\n  \"compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> compare\\<cdot>y\\<cdot>z = EQ \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = EQ\"", "lemma le_trans:\n  \"le\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> le\\<cdot>y\\<cdot>z = TT \\<Longrightarrow> le\\<cdot>x\\<cdot>z = TT\"", "lemma neg_lt: \"neg\\<cdot>(lt\\<cdot>x\\<cdot>y) = le\\<cdot>y\\<cdot>x\"", "lemma neg_le: \"neg\\<cdot>(le\\<cdot>x\\<cdot>y) = lt\\<cdot>y\\<cdot>x\"", "lemma thenOrdering_simps [simp]:\n  \"thenOrdering\\<cdot>LT\\<cdot>y = LT\"\n  \"thenOrdering\\<cdot>EQ\\<cdot>y = y\"\n  \"thenOrdering\\<cdot>GT\\<cdot>y = GT\"\n  \"thenOrdering\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\"", "lemma thenOrdering_LT_iff [simp]:\n  \"thenOrdering\\<cdot>x\\<cdot>y = LT \\<longleftrightarrow> x = LT \\<or> x = EQ \\<and> y = LT\"", "lemma thenOrdering_EQ_iff [simp]:\n  \"thenOrdering\\<cdot>x\\<cdot>y = EQ \\<longleftrightarrow> x = EQ \\<and> y = EQ\"", "lemma thenOrdering_GT_iff [simp]:\n  \"thenOrdering\\<cdot>x\\<cdot>y = GT \\<longleftrightarrow> x = GT \\<or> x = EQ \\<and> y = GT\"", "lemma thenOrdering_below_EQ_iff [simp]:\n  \"thenOrdering\\<cdot>x\\<cdot>y \\<sqsubseteq> EQ \\<longleftrightarrow> x \\<sqsubseteq> EQ \\<and> (x = \\<bottom> \\<or> y \\<sqsubseteq> EQ)\"", "lemma is_EQ_thenOrdering [simp]:\n  \"is_EQ\\<cdot>(thenOrdering\\<cdot>x\\<cdot>y) = (is_EQ\\<cdot>x andalso is_EQ\\<cdot>y)\"", "lemma oppOrdering_thenOrdering:\n  \"oppOrdering\\<cdot>(thenOrdering\\<cdot>x\\<cdot>y) =\n    thenOrdering\\<cdot>(oppOrdering\\<cdot>x)\\<cdot>(oppOrdering\\<cdot>y)\"", "lemma lt_le:\n  \"lt\\<cdot>(x::'a::Ord_linear)\\<cdot>y = (le\\<cdot>x\\<cdot>y andalso neq\\<cdot>x\\<cdot>y)\""], "translations": [["", "lemma eq_refl: \"eq\\<cdot>x\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow> eq\\<cdot>x\\<cdot>x = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>x\\<cdot>x = TT", "by (cases \"eq\\<cdot>x\\<cdot>x\") simp+"], ["", "end"], ["", "class Eq_eq = Eq_sym +\n  assumes eq_self_neq_FF': \"eq\\<cdot>x\\<cdot>x \\<noteq> FF\"\n    and eq_TT_dest: \"eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y\"\nbegin"], ["", "subclass Eq_equiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.Eq_equiv eq", "by standard (auto simp: eq_self_neq_FF' dest: eq_TT_dest)"], ["", "lemma eqD [dest]:\n  \"eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y\"\n  \"eq\\<cdot>x\\<cdot>y = FF \\<Longrightarrow> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y) &&&\n    (eq\\<cdot>x\\<cdot>y = FF \\<Longrightarrow> x \\<noteq> y)", "by (auto elim: eq_TT_dest)"], ["", "end"], ["", "subsubsection \\<open>Class instances\\<close>"], ["", "instantiation lift :: (countable) Eq_eq\nbegin"], ["", "definition \"eq \\<equiv> (\\<Lambda>(Def x) (Def y). Def (x = y))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lift, Eq_eq_class)", "by standard (auto simp: eq_lift_def flift1_def split: lift.splits)"], ["", "end"], ["", "lemma eq_ONE_ONE [simp]: \"eq\\<cdot>ONE\\<cdot>ONE = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>ONE\\<cdot>ONE = TT", "unfolding ONE_def eq_lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> (Def x) (Def y). Def (x = y))\\<cdot>(Def ())\\<cdot>(Def ()) =\n    TT", "by simp"], ["", "subsection \\<open>Ord class\\<close>"], ["", "domain Ordering = LT | EQ | GT"], ["", "definition oppOrdering :: \"Ordering \\<rightarrow> Ordering\" where\n  \"oppOrdering = (\\<Lambda> x. case x of LT \\<Rightarrow> GT | EQ \\<Rightarrow> EQ | GT \\<Rightarrow> LT)\""], ["", "lemma oppOrdering_simps [simp]:\n  \"oppOrdering\\<cdot>LT = GT\"\n  \"oppOrdering\\<cdot>EQ = EQ\"\n  \"oppOrdering\\<cdot>GT = LT\"\n  \"oppOrdering\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oppOrdering\\<cdot>LT = GT &&& oppOrdering\\<cdot>EQ = EQ) &&&\n    oppOrdering\\<cdot>GT = LT &&& oppOrdering\\<cdot>\\<bottom> = \\<bottom>", "unfolding oppOrdering_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_cfun (Rep_cfun (Ordering_case\\<cdot>GT\\<cdot>EQ\\<cdot>LT))\\<cdot>\n     LT =\n     GT &&&\n     Abs_cfun (Rep_cfun (Ordering_case\\<cdot>GT\\<cdot>EQ\\<cdot>LT))\\<cdot>\n     EQ =\n     EQ) &&&\n    Abs_cfun (Rep_cfun (Ordering_case\\<cdot>GT\\<cdot>EQ\\<cdot>LT))\\<cdot>\n    GT =\n    LT &&&\n    Abs_cfun (Rep_cfun (Ordering_case\\<cdot>GT\\<cdot>EQ\\<cdot>LT))\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by simp_all"], ["", "class Ord = Eq +\n  fixes compare :: \"'a \\<rightarrow> 'a \\<rightarrow> Ordering\"\nbegin"], ["", "definition lt :: \"'a \\<rightarrow> 'a \\<rightarrow> tr\" where\n  \"lt = (\\<Lambda> x y. case compare\\<cdot>x\\<cdot>y of LT \\<Rightarrow> TT | EQ \\<Rightarrow> FF | GT \\<Rightarrow> FF)\""], ["", "definition le :: \"'a \\<rightarrow> 'a \\<rightarrow> tr\" where\n  \"le = (\\<Lambda> x y. case compare\\<cdot>x\\<cdot>y of LT \\<Rightarrow> TT | EQ \\<Rightarrow> TT | GT \\<Rightarrow> FF)\""], ["", "lemma lt_eq_TT_iff: \"lt\\<cdot>x\\<cdot>y = TT \\<longleftrightarrow> compare\\<cdot>x\\<cdot>y = LT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lt\\<cdot>x\\<cdot>y = TT) = (compare\\<cdot>x\\<cdot>y = LT)", "by (cases \"compare\\<cdot>x\\<cdot>y\") (simp add: lt_def)+"], ["", "end"], ["", "class Ord_strict = Ord +\n  assumes compare_strict [simp]:\n    \"compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\"\n    \"compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"\nbegin"], ["", "lemma lt_strict [simp]:\n  shows \"lt\\<cdot>\\<bottom>\\<cdot>x = \\<bottom>\"\n    and \"lt\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt\\<cdot>\\<bottom>\\<cdot>x = \\<bottom> &&&\n    lt\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: lt_def)+"], ["", "lemma le_strict [simp]:\n  shows \"le\\<cdot>\\<bottom>\\<cdot>x = \\<bottom>\"\n    and \"le\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>\\<bottom>\\<cdot>x = \\<bottom> &&&\n    le\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: le_def)+"], ["", "end"], ["", "text \\<open>TODO: It might make sense to have a class for preorders too,\nanalogous to class \\<open>eq_equiv\\<close>.\\<close>"], ["", "class Ord_linear = Ord_strict +\n  assumes eq_conv_compare: \"eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\"\n    and oppOrdering_compare [simp]:\n    \"oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\"\n    and compare_EQ_dest: \"compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\"\n    and compare_self_below_EQ: \"compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\"\n    and compare_LT_trans:\n    \"compare\\<cdot>x\\<cdot>y = LT \\<Longrightarrow> compare\\<cdot>y\\<cdot>z = LT \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT\"\n  (*BH: Is this set of axioms complete?*)\n  (*CS: How about totality of the order?*)\nbegin"], ["", "lemma eq_TT_dest: \"eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "by (cases \"compare\\<cdot>x\\<cdot>y\") (auto dest: compare_EQ_dest simp: eq_conv_compare)+"], ["", "lemma le_iff_lt_or_eq:\n  \"le\\<cdot>x\\<cdot>y = TT \\<longleftrightarrow> lt\\<cdot>x\\<cdot>y = TT \\<or> eq\\<cdot>x\\<cdot>y = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (le\\<cdot>x\\<cdot>y = TT) =\n    (lt\\<cdot>x\\<cdot>y = TT \\<or> eq\\<cdot>x\\<cdot>y = TT)", "by (cases \"compare\\<cdot>x\\<cdot>y\") (simp add: le_def lt_def eq_conv_compare)+"], ["", "lemma compare_sym:\n  \"compare\\<cdot>x\\<cdot>y = (case compare\\<cdot>y\\<cdot>x of LT \\<Rightarrow> GT | EQ \\<Rightarrow> EQ | GT \\<Rightarrow> LT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>y =\n    (case compare\\<cdot>y\\<cdot>x of LT \\<Rightarrow> GT\n     | EQ \\<Rightarrow> EQ | GT \\<Rightarrow> LT)", "by (subst oppOrdering_compare [symmetric]) (simp add: oppOrdering_def)"], ["", "lemma compare_self_neq_LT [simp]: \"compare\\<cdot>x\\<cdot>x \\<noteq> LT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>x \\<noteq> LT", "using compare_self_below_EQ [of x]"], ["proof (prove)\nusing this:\n  compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>x \\<noteq> LT", "by clarsimp"], ["", "lemma compare_self_neq_GT [simp]: \"compare\\<cdot>x\\<cdot>x \\<noteq> GT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>x \\<noteq> GT", "using compare_self_below_EQ [of x]"], ["proof (prove)\nusing this:\n  compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>x \\<noteq> GT", "by clarsimp"], ["", "declare compare_self_below_EQ [simp]"], ["", "lemma lt_trans: \"lt\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> lt\\<cdot>y\\<cdot>z = TT \\<Longrightarrow> lt\\<cdot>x\\<cdot>z = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lt\\<cdot>x\\<cdot>y = TT; lt\\<cdot>y\\<cdot>z = TT\\<rbrakk>\n    \\<Longrightarrow> lt\\<cdot>x\\<cdot>z = TT", "unfolding lt_eq_TT_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n     compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n    \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "by (rule compare_LT_trans)"], ["", "lemma compare_GT_iff_LT: \"compare\\<cdot>x\\<cdot>y = GT \\<longleftrightarrow> compare\\<cdot>y\\<cdot>x = LT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compare\\<cdot>x\\<cdot>y = GT) = (compare\\<cdot>y\\<cdot>x = LT)", "by (cases \"compare\\<cdot>x\\<cdot>y\", simp_all add: compare_sym [of y x])"], ["", "lemma compare_GT_trans:\n  \"compare\\<cdot>x\\<cdot>y = GT \\<Longrightarrow> compare\\<cdot>y\\<cdot>z = GT \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = GT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>compare\\<cdot>x\\<cdot>y = GT;\n     compare\\<cdot>y\\<cdot>z = GT\\<rbrakk>\n    \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = GT", "unfolding compare_GT_iff_LT"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>compare\\<cdot>y\\<cdot>x = LT;\n     compare\\<cdot>z\\<cdot>y = LT\\<rbrakk>\n    \\<Longrightarrow> compare\\<cdot>z\\<cdot>x = LT", "by (rule compare_LT_trans)"], ["", "lemma compare_EQ_iff_eq_TT:\n  \"compare\\<cdot>x\\<cdot>y = EQ \\<longleftrightarrow> eq\\<cdot>x\\<cdot>y = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compare\\<cdot>x\\<cdot>y = EQ) = (eq\\<cdot>x\\<cdot>y = TT)", "by (cases \"compare\\<cdot>x\\<cdot>y\") (simp add: is_EQ_def eq_conv_compare)+"], ["", "lemma compare_EQ_trans:\n  \"compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> compare\\<cdot>y\\<cdot>z = EQ \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = EQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>compare\\<cdot>x\\<cdot>y = EQ;\n     compare\\<cdot>y\\<cdot>z = EQ\\<rbrakk>\n    \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = EQ", "by (blast dest: compare_EQ_dest)"], ["", "lemma le_trans:\n  \"le\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> le\\<cdot>y\\<cdot>z = TT \\<Longrightarrow> le\\<cdot>x\\<cdot>z = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le\\<cdot>x\\<cdot>y = TT; le\\<cdot>y\\<cdot>z = TT\\<rbrakk>\n    \\<Longrightarrow> le\\<cdot>x\\<cdot>z = TT", "by (auto dest: eq_TT_dest lt_trans simp: le_iff_lt_or_eq)"], ["", "lemma neg_lt: \"neg\\<cdot>(lt\\<cdot>x\\<cdot>y) = le\\<cdot>y\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg\\<cdot>(lt\\<cdot>x\\<cdot>y) = le\\<cdot>y\\<cdot>x", "by (cases \"compare\\<cdot>x\\<cdot>y\", simp_all add: le_def lt_def compare_sym [of y x])"], ["", "lemma neg_le: \"neg\\<cdot>(le\\<cdot>x\\<cdot>y) = lt\\<cdot>y\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg\\<cdot>(le\\<cdot>x\\<cdot>y) = lt\\<cdot>y\\<cdot>x", "by (cases \"compare\\<cdot>x\\<cdot>y\", simp_all add: le_def lt_def compare_sym [of y x])"], ["", "subclass Eq_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.Eq_eq eq", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>y. eq\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n 3. \\<And>x y. eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x\n 4. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 5. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>y. eq\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n 3. \\<And>x y. eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x\n 4. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 5. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "show \"eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x", "unfolding eq_conv_compare"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y) =\n    is_EQ\\<cdot>(compare\\<cdot>y\\<cdot>x)", "by (cases \"compare\\<cdot>x\\<cdot>y\", simp_all add: compare_sym [of y x])"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x\n\ngoal (4 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>y. eq\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n 3. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 4. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "show \"eq\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "unfolding eq_conv_compare"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>\\<bottom>) = \\<bottom>", "by simp"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (3 subgoals):\n 1. \\<And>y. eq\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n 2. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 3. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "show \"eq\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>", "unfolding eq_conv_compare"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_EQ\\<cdot>(compare\\<cdot>\\<bottom>\\<cdot>y) = \\<bottom>", "by simp"], ["proof (state)\nthis:\n  eq\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n\ngoal (2 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 2. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "show \"eq\\<cdot>x\\<cdot>x \\<noteq> FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>x \\<noteq> FF", "unfolding eq_conv_compare"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>x) \\<noteq> FF", "by (cases \"compare\\<cdot>x\\<cdot>x\", simp_all)"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>x \\<noteq> FF\n\ngoal (1 subgoal):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "{"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>x \\<noteq> FF\n\ngoal (1 subgoal):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "assume \"eq\\<cdot>x\\<cdot>y = TT\""], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>y = TT\n\ngoal (1 subgoal):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  eq\\<cdot>x\\<cdot>y = TT", "show \"x = y\""], ["proof (prove)\nusing this:\n  eq\\<cdot>x\\<cdot>y = TT\n\ngoal (1 subgoal):\n 1. x = y", "unfolding eq_conv_compare"], ["proof (prove)\nusing this:\n  is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y) = TT\n\ngoal (1 subgoal):\n 1. x = y", "by (cases \"compare\\<cdot>x\\<cdot>y\", auto dest: compare_EQ_dest)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>A combinator for defining Ord instances for datatypes.\\<close>"], ["", "definition thenOrdering :: \"Ordering \\<rightarrow> Ordering \\<rightarrow> Ordering\" where\n  \"thenOrdering = (\\<Lambda> x y. case x of LT \\<Rightarrow> LT | EQ \\<Rightarrow> y | GT \\<Rightarrow> GT)\""], ["", "lemma thenOrdering_simps [simp]:\n  \"thenOrdering\\<cdot>LT\\<cdot>y = LT\"\n  \"thenOrdering\\<cdot>EQ\\<cdot>y = y\"\n  \"thenOrdering\\<cdot>GT\\<cdot>y = GT\"\n  \"thenOrdering\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (thenOrdering\\<cdot>LT\\<cdot>y = LT &&&\n     thenOrdering\\<cdot>EQ\\<cdot>y = y) &&&\n    thenOrdering\\<cdot>GT\\<cdot>y = GT &&&\n    thenOrdering\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>", "unfolding thenOrdering_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Lambda> x y.\n         case x of LT \\<Rightarrow> LT | EQ \\<Rightarrow> y\n         | GT \\<Rightarrow> GT)\\<cdot>\n     LT\\<cdot>\n     y =\n     LT &&&\n     (\\<Lambda> x y.\n         case x of LT \\<Rightarrow> LT | EQ \\<Rightarrow> y\n         | GT \\<Rightarrow> GT)\\<cdot>\n     EQ\\<cdot>\n     y =\n     y) &&&\n    (\\<Lambda> x y.\n        case x of LT \\<Rightarrow> LT | EQ \\<Rightarrow> y\n        | GT \\<Rightarrow> GT)\\<cdot>\n    GT\\<cdot>\n    y =\n    GT &&&\n    (\\<Lambda> x y.\n        case x of LT \\<Rightarrow> LT | EQ \\<Rightarrow> y\n        | GT \\<Rightarrow> GT)\\<cdot>\n    \\<bottom>\\<cdot>\n    y =\n    \\<bottom>", "by simp_all"], ["", "lemma thenOrdering_LT_iff [simp]:\n  \"thenOrdering\\<cdot>x\\<cdot>y = LT \\<longleftrightarrow> x = LT \\<or> x = EQ \\<and> y = LT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (thenOrdering\\<cdot>x\\<cdot>y = LT) =\n    (x = LT \\<or> x = EQ \\<and> y = LT)", "by (cases x, simp_all)"], ["", "lemma thenOrdering_EQ_iff [simp]:\n  \"thenOrdering\\<cdot>x\\<cdot>y = EQ \\<longleftrightarrow> x = EQ \\<and> y = EQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (thenOrdering\\<cdot>x\\<cdot>y = EQ) = (x = EQ \\<and> y = EQ)", "by (cases x, simp_all)"], ["", "lemma thenOrdering_GT_iff [simp]:\n  \"thenOrdering\\<cdot>x\\<cdot>y = GT \\<longleftrightarrow> x = GT \\<or> x = EQ \\<and> y = GT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (thenOrdering\\<cdot>x\\<cdot>y = GT) =\n    (x = GT \\<or> x = EQ \\<and> y = GT)", "by (cases x, simp_all)"], ["", "lemma thenOrdering_below_EQ_iff [simp]:\n  \"thenOrdering\\<cdot>x\\<cdot>y \\<sqsubseteq> EQ \\<longleftrightarrow> x \\<sqsubseteq> EQ \\<and> (x = \\<bottom> \\<or> y \\<sqsubseteq> EQ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (thenOrdering\\<cdot>x\\<cdot>y \\<sqsubseteq> EQ) =\n    (x \\<sqsubseteq> EQ \\<and> (x = \\<bottom> \\<or> y \\<sqsubseteq> EQ))", "by (cases x) simp_all"], ["", "lemma is_EQ_thenOrdering [simp]:\n  \"is_EQ\\<cdot>(thenOrdering\\<cdot>x\\<cdot>y) = (is_EQ\\<cdot>x andalso is_EQ\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_EQ\\<cdot>(thenOrdering\\<cdot>x\\<cdot>y) =\n    (is_EQ\\<cdot>x andalso is_EQ\\<cdot>y)", "by (cases x) simp_all"], ["", "lemma oppOrdering_thenOrdering:\n  \"oppOrdering\\<cdot>(thenOrdering\\<cdot>x\\<cdot>y) =\n    thenOrdering\\<cdot>(oppOrdering\\<cdot>x)\\<cdot>(oppOrdering\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oppOrdering\\<cdot>(thenOrdering\\<cdot>x\\<cdot>y) =\n    thenOrdering\\<cdot>(oppOrdering\\<cdot>x)\\<cdot>(oppOrdering\\<cdot>y)", "by (cases x) simp_all"], ["", "instantiation lift :: (\"{linorder,countable}\") Ord_linear\nbegin"], ["", "definition\n  \"compare \\<equiv> (\\<Lambda> (Def x) (Def y).\n    if x < y then LT else if x > y then GT else EQ)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lift, Ord_linear_class)", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y. compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n 2. \\<And>x. compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 4. \\<And>x y.\n       oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n 5. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 6. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 7. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "fix x y z :: \"'a lift\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y. compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n 2. \\<And>x. compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 4. \\<And>x y.\n       oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n 5. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 6. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 7. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "show \"compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>", "unfolding compare_lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> (Def x) (Def y).\n        if x < y then LT else if y < x then GT else EQ)\\<cdot>\n    \\<bottom>\\<cdot>\n    y =\n    \\<bottom>", "by simp"], ["proof (state)\nthis:\n  compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n\ngoal (6 subgoals):\n 1. \\<And>x. compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 3. \\<And>x y.\n       oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n 4. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 5. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 6. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "show \"compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "unfolding compare_lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> (Def x) (Def y).\n        if x < y then LT else if y < x then GT else EQ)\\<cdot>\n    x\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (5 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x y.\n       oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n 3. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 4. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 5. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "show \"oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x", "unfolding compare_lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. oppOrdering\\<cdot>\n    ((\\<Lambda> (Def x) (Def y).\n         if x < y then LT else if y < x then GT else EQ)\\<cdot>\n     x\\<cdot>\n     y) =\n    (\\<Lambda> (Def x) (Def y).\n        if x < y then LT else if y < x then GT else EQ)\\<cdot>\n    y\\<cdot>\n    x", "by (cases x, cases y, simp, simp,\n      cases y, simp, simp add: not_less less_imp_le)"], ["proof (state)\nthis:\n  oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n\ngoal (4 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 3. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 4. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "{"], ["proof (state)\nthis:\n  oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n\ngoal (4 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 3. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 4. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "assume \"compare\\<cdot>x\\<cdot>y = EQ\""], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = EQ\n\ngoal (4 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 3. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 4. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "then"], ["proof (chain)\npicking this:\n  compare\\<cdot>x\\<cdot>y = EQ", "show \"x = y\""], ["proof (prove)\nusing this:\n  compare\\<cdot>x\\<cdot>y = EQ\n\ngoal (1 subgoal):\n 1. x = y", "unfolding compare_lift_def"], ["proof (prove)\nusing this:\n  (\\<Lambda> (Def x) (Def y).\n      if x < y then LT else if y < x then GT else EQ)\\<cdot>\n  x\\<cdot>\n  y =\n  EQ\n\ngoal (1 subgoal):\n 1. x = y", "by (cases x, cases y, simp, simp,\n        cases y, simp, simp split: if_splits)"], ["proof (state)\nthis:\n  x = y\n\ngoal (3 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 3. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "}"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n\ngoal (3 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 3. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "{"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n\ngoal (3 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 3. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "assume \"compare\\<cdot>x\\<cdot>y = LT\" and \"compare\\<cdot>y\\<cdot>z = LT\""], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = LT\n  compare\\<cdot>y\\<cdot>z = LT\n\ngoal (3 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 3. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "then"], ["proof (chain)\npicking this:\n  compare\\<cdot>x\\<cdot>y = LT\n  compare\\<cdot>y\\<cdot>z = LT", "show \"compare\\<cdot>x\\<cdot>z = LT\""], ["proof (prove)\nusing this:\n  compare\\<cdot>x\\<cdot>y = LT\n  compare\\<cdot>y\\<cdot>z = LT\n\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>z = LT", "unfolding compare_lift_def"], ["proof (prove)\nusing this:\n  (\\<Lambda> (Def x) (Def y).\n      if x < y then LT else if y < x then GT else EQ)\\<cdot>\n  x\\<cdot>\n  y =\n  LT\n  (\\<Lambda> (Def x) (Def y).\n      if x < y then LT else if y < x then GT else EQ)\\<cdot>\n  y\\<cdot>\n  z =\n  LT\n\ngoal (1 subgoal):\n 1. (\\<Lambda> (Def x) (Def y).\n        if x < y then LT else if y < x then GT else EQ)\\<cdot>\n    x\\<cdot>\n    z =\n    LT", "by (cases x, simp, cases y, simp, cases z, simp,\n        auto split: if_splits)"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>z = LT\n\ngoal (2 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ", "}"], ["proof (state)\nthis:\n  \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n   compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n  \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT\n\ngoal (2 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ", "show \"eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)", "unfolding eq_lift_def compare_lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> (Def x) (Def y). Def (x = y))\\<cdot>x\\<cdot>y =\n    is_EQ\\<cdot>\n    ((\\<Lambda> (Def x) (Def y).\n         if x < y then LT else if y < x then GT else EQ)\\<cdot>\n     x\\<cdot>\n     y)", "by (cases x, simp, cases y, simp, auto)"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n\ngoal (1 subgoal):\n 1. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ", "show \"compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ", "unfolding compare_lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> (Def x) (Def y).\n        if x < y then LT else if y < x then GT else EQ)\\<cdot>\n    x\\<cdot>\n    x \\<sqsubseteq>\n    EQ", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma lt_le:\n  \"lt\\<cdot>(x::'a::Ord_linear)\\<cdot>y = (le\\<cdot>x\\<cdot>y andalso neq\\<cdot>x\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt\\<cdot>x\\<cdot>y = (le\\<cdot>x\\<cdot>y andalso neq\\<cdot>x\\<cdot>y)", "by (cases \"compare\\<cdot>x\\<cdot>y\")\n     (auto simp: lt_def le_def eq_conv_compare)"], ["", "end"]]}