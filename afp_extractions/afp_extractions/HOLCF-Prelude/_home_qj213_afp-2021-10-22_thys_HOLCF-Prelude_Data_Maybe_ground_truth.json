{"file_name": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude/Data_Maybe.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude", "problem_names": ["lemma eq_Maybe_simps [simp]:\n  \"eq\\<cdot>Nothing\\<cdot>Nothing = TT\"\n  \"eq\\<cdot>Nothing\\<cdot>(Just\\<cdot>y) = FF\"\n  \"eq\\<cdot>(Just\\<cdot>x)\\<cdot>Nothing = FF\"\n  \"eq\\<cdot>(Just\\<cdot>x)\\<cdot>(Just\\<cdot>y) = eq\\<cdot>x\\<cdot>y\"", "lemma compare_Maybe_simps [simp]:\n  \"compare\\<cdot>Nothing\\<cdot>Nothing = EQ\"\n  \"compare\\<cdot>Nothing\\<cdot>(Just\\<cdot>y) = LT\"\n  \"compare\\<cdot>(Just\\<cdot>x)\\<cdot>Nothing = GT\"\n  \"compare\\<cdot>(Just\\<cdot>x)\\<cdot>(Just\\<cdot>y) = compare\\<cdot>x\\<cdot>y\"", "lemma isJust_strict [simp]: \"isJust\\<cdot>\\<bottom>  = \\<bottom>\"", "lemma fromMaybe_strict [simp]: \"fromMaybe\\<cdot>x\\<cdot>\\<bottom>  = \\<bottom>\"", "lemma maybeToList_strict [simp]: \"maybeToList\\<cdot>\\<bottom>  = \\<bottom>\""], "translations": [["", "lemma eq_Maybe_simps [simp]:\n  \"eq\\<cdot>Nothing\\<cdot>Nothing = TT\"\n  \"eq\\<cdot>Nothing\\<cdot>(Just\\<cdot>y) = FF\"\n  \"eq\\<cdot>(Just\\<cdot>x)\\<cdot>Nothing = FF\"\n  \"eq\\<cdot>(Just\\<cdot>x)\\<cdot>(Just\\<cdot>y) = eq\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq\\<cdot>Nothing\\<cdot>Nothing = TT &&&\n     eq\\<cdot>Nothing\\<cdot>(Just\\<cdot>y) = FF) &&&\n    eq\\<cdot>(Just\\<cdot>x)\\<cdot>Nothing = FF &&&\n    eq\\<cdot>(Just\\<cdot>x)\\<cdot>(Just\\<cdot>y) = eq\\<cdot>x\\<cdot>y", "unfolding eq_Maybe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (maybe\\<cdot>(maybe\\<cdot>TT\\<cdot>(\\<Lambda> y. FF))\\<cdot>\n     (\\<Lambda> x.\n         maybe\\<cdot>FF\\<cdot>(Abs_cfun (Rep_cfun (eq\\<cdot>x))))\\<cdot>\n     Nothing\\<cdot>\n     Nothing =\n     TT &&&\n     maybe\\<cdot>(maybe\\<cdot>TT\\<cdot>(\\<Lambda> y. FF))\\<cdot>\n     (\\<Lambda> x.\n         maybe\\<cdot>FF\\<cdot>(Abs_cfun (Rep_cfun (eq\\<cdot>x))))\\<cdot>\n     Nothing\\<cdot>\n     (Just\\<cdot>y) =\n     FF) &&&\n    maybe\\<cdot>(maybe\\<cdot>TT\\<cdot>(\\<Lambda> y. FF))\\<cdot>\n    (\\<Lambda> x.\n        maybe\\<cdot>FF\\<cdot>(Abs_cfun (Rep_cfun (eq\\<cdot>x))))\\<cdot>\n    (Just\\<cdot>x)\\<cdot>\n    Nothing =\n    FF &&&\n    maybe\\<cdot>(maybe\\<cdot>TT\\<cdot>(\\<Lambda> y. FF))\\<cdot>\n    (\\<Lambda> x.\n        maybe\\<cdot>FF\\<cdot>(Abs_cfun (Rep_cfun (eq\\<cdot>x))))\\<cdot>\n    (Just\\<cdot>x)\\<cdot>\n    (Just\\<cdot>y) =\n    eq\\<cdot>x\\<cdot>y", "by simp_all"], ["", "instance Maybe :: (Eq_sym) Eq_sym"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Maybe, Eq_sym_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x", "fix x y :: \"'a Maybe\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x", "show \"eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x", "by (cases x, simp, cases y, simp, simp, simp,\n        cases y, simp, simp, simp add: eq_sym)"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "instance Maybe :: (Eq_equiv) Eq_equiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Maybe, Eq_equiv_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 2. \\<And>x y z.\n       \\<lbrakk>eq\\<cdot>x\\<cdot>y = TT; eq\\<cdot>y\\<cdot>z = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>x\\<cdot>z = TT", "fix x y z :: \"'a Maybe\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 2. \\<And>x y z.\n       \\<lbrakk>eq\\<cdot>x\\<cdot>y = TT; eq\\<cdot>y\\<cdot>z = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>x\\<cdot>z = TT", "show \"eq\\<cdot>x\\<cdot>x \\<noteq> FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>x \\<noteq> FF", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>x \\<noteq> FF\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>eq\\<cdot>x\\<cdot>y = TT; eq\\<cdot>y\\<cdot>z = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>x\\<cdot>z = TT", "assume \"eq\\<cdot>x\\<cdot>y = TT\" and \"eq\\<cdot>y\\<cdot>z = TT\""], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>y = TT\n  eq\\<cdot>y\\<cdot>z = TT\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>eq\\<cdot>x\\<cdot>y = TT; eq\\<cdot>y\\<cdot>z = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>x\\<cdot>z = TT", "then"], ["proof (chain)\npicking this:\n  eq\\<cdot>x\\<cdot>y = TT\n  eq\\<cdot>y\\<cdot>z = TT", "show \"eq\\<cdot>x\\<cdot>z = TT\""], ["proof (prove)\nusing this:\n  eq\\<cdot>x\\<cdot>y = TT\n  eq\\<cdot>y\\<cdot>z = TT\n\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>z = TT", "by (cases x, simp, cases y, simp, cases z, simp, simp, simp, simp,\n        cases y, simp, simp, cases z, simp, simp, simp, fast elim: eq_trans)"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>z = TT\n\ngoal:\nNo subgoals!", "qed"], ["", "instance Maybe :: (Eq_eq) Eq_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Maybe, Eq_eq_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 2. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "fix x y :: \"'a Maybe\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 2. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "show \"eq\\<cdot>x\\<cdot>x \\<noteq> FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>x \\<noteq> FF", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>x \\<noteq> FF\n\ngoal (1 subgoal):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "assume \"eq\\<cdot>x\\<cdot>y = TT\""], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>y = TT\n\ngoal (1 subgoal):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  eq\\<cdot>x\\<cdot>y = TT", "show \"x = y\""], ["proof (prove)\nusing this:\n  eq\\<cdot>x\\<cdot>y = TT\n\ngoal (1 subgoal):\n 1. x = y", "by (cases x, simp, cases y, simp, simp, simp,\n        cases y, simp, simp, simp, fast)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation Maybe :: (Ord) Ord_strict\nbegin"], ["", "definition\n  \"compare = maybe\\<cdot>(maybe\\<cdot>EQ\\<cdot>(\\<Lambda> y. LT))\\<cdot>(\\<Lambda> x. maybe\\<cdot>GT\\<cdot>(\\<Lambda> y. compare\\<cdot>x\\<cdot>y))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Maybe, Ord_strict_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n 2. \\<And>x. compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "fix x :: \"'a Maybe\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n 2. \\<And>x. compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "show \"compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "unfolding compare_Maybe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>(maybe\\<cdot>EQ\\<cdot>(\\<Lambda> y. LT))\\<cdot>\n    (\\<Lambda> x.\n        maybe\\<cdot>GT\\<cdot>(Abs_cfun (Rep_cfun (compare\\<cdot>x))))\\<cdot>\n    x\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by (cases x) simp_all"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>y. compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>", "show \"compare\\<cdot>\\<bottom>\\<cdot>x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>\\<bottom>\\<cdot>x = \\<bottom>", "unfolding compare_Maybe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>(maybe\\<cdot>EQ\\<cdot>(\\<Lambda> y. LT))\\<cdot>\n    (\\<Lambda> x.\n        maybe\\<cdot>GT\\<cdot>(Abs_cfun (Rep_cfun (compare\\<cdot>x))))\\<cdot>\n    \\<bottom>\\<cdot>\n    x =\n    \\<bottom>", "by simp"], ["proof (state)\nthis:\n  compare\\<cdot>\\<bottom>\\<cdot>x = \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma compare_Maybe_simps [simp]:\n  \"compare\\<cdot>Nothing\\<cdot>Nothing = EQ\"\n  \"compare\\<cdot>Nothing\\<cdot>(Just\\<cdot>y) = LT\"\n  \"compare\\<cdot>(Just\\<cdot>x)\\<cdot>Nothing = GT\"\n  \"compare\\<cdot>(Just\\<cdot>x)\\<cdot>(Just\\<cdot>y) = compare\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compare\\<cdot>Nothing\\<cdot>Nothing = EQ &&&\n     compare\\<cdot>Nothing\\<cdot>(Just\\<cdot>y) = LT) &&&\n    compare\\<cdot>(Just\\<cdot>x)\\<cdot>Nothing = GT &&&\n    compare\\<cdot>(Just\\<cdot>x)\\<cdot>(Just\\<cdot>y) =\n    compare\\<cdot>x\\<cdot>y", "unfolding compare_Maybe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (maybe\\<cdot>(maybe\\<cdot>EQ\\<cdot>(\\<Lambda> y. LT))\\<cdot>\n     (\\<Lambda> x.\n         maybe\\<cdot>GT\\<cdot>\n         (Abs_cfun (Rep_cfun (compare\\<cdot>x))))\\<cdot>\n     Nothing\\<cdot>\n     Nothing =\n     EQ &&&\n     maybe\\<cdot>(maybe\\<cdot>EQ\\<cdot>(\\<Lambda> y. LT))\\<cdot>\n     (\\<Lambda> x.\n         maybe\\<cdot>GT\\<cdot>\n         (Abs_cfun (Rep_cfun (compare\\<cdot>x))))\\<cdot>\n     Nothing\\<cdot>\n     (Just\\<cdot>y) =\n     LT) &&&\n    maybe\\<cdot>(maybe\\<cdot>EQ\\<cdot>(\\<Lambda> y. LT))\\<cdot>\n    (\\<Lambda> x.\n        maybe\\<cdot>GT\\<cdot>(Abs_cfun (Rep_cfun (compare\\<cdot>x))))\\<cdot>\n    (Just\\<cdot>x)\\<cdot>\n    Nothing =\n    GT &&&\n    maybe\\<cdot>(maybe\\<cdot>EQ\\<cdot>(\\<Lambda> y. LT))\\<cdot>\n    (\\<Lambda> x.\n        maybe\\<cdot>GT\\<cdot>(Abs_cfun (Rep_cfun (compare\\<cdot>x))))\\<cdot>\n    (Just\\<cdot>x)\\<cdot>\n    (Just\\<cdot>y) =\n    compare\\<cdot>x\\<cdot>y", "by simp_all"], ["", "instance Maybe :: (Ord_linear) Ord_linear"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Maybe, Ord_linear_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x y.\n       oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n 3. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 4. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 5. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "fix x y z :: \"'a Maybe\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x y.\n       oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n 3. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 4. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 5. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "show \"eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)", "by (cases x, simp, cases y, simp, simp, simp,\n        cases y, simp, simp, simp add: eq_conv_compare)"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n 2. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 3. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 4. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "show \"oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x", "by (cases x, simp, (cases y, simp, simp, simp)+)"], ["proof (state)\nthis:\n  oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n\ngoal (3 subgoals):\n 1. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 3. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "show \"compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ", "by (cases x) simp_all"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n\ngoal (2 subgoals):\n 1. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "{"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n\ngoal (2 subgoals):\n 1. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "assume \"compare\\<cdot>x\\<cdot>y = EQ\""], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = EQ\n\ngoal (2 subgoals):\n 1. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "then"], ["proof (chain)\npicking this:\n  compare\\<cdot>x\\<cdot>y = EQ", "show \"x = y\""], ["proof (prove)\nusing this:\n  compare\\<cdot>x\\<cdot>y = EQ\n\ngoal (1 subgoal):\n 1. x = y", "by (cases x, simp, cases y, simp, simp, simp,\n          cases y, simp, simp, simp) (erule compare_EQ_dest)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "}"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "{"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "assume \"compare\\<cdot>x\\<cdot>y = LT\" and \"compare\\<cdot>y\\<cdot>z = LT\""], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = LT\n  compare\\<cdot>y\\<cdot>z = LT\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "then"], ["proof (chain)\npicking this:\n  compare\\<cdot>x\\<cdot>y = LT\n  compare\\<cdot>y\\<cdot>z = LT", "show \"compare\\<cdot>x\\<cdot>z = LT\""], ["proof (prove)\nusing this:\n  compare\\<cdot>x\\<cdot>y = LT\n  compare\\<cdot>y\\<cdot>z = LT\n\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>z = LT", "apply (cases x, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT; compare\\<cdot>y\\<cdot>z = LT;\n     x = Nothing\\<rbrakk>\n    \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT\n 2. \\<And>a.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT; compare\\<cdot>y\\<cdot>z = LT;\n        x = Just\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "apply (cases y, simp, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT; compare\\<cdot>y\\<cdot>z = LT;\n        x = Nothing; y = Just\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT\n 2. \\<And>a.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT; compare\\<cdot>y\\<cdot>z = LT;\n        x = Just\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "apply (cases z, simp, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT; compare\\<cdot>y\\<cdot>z = LT;\n        x = Just\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "apply (cases y, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT; compare\\<cdot>y\\<cdot>z = LT;\n        x = Just\\<cdot>a; y = Just\\<cdot>aa\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "apply (cases z, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT; compare\\<cdot>y\\<cdot>z = LT;\n        x = Just\\<cdot>a; y = Just\\<cdot>aa; z = Just\\<cdot>ab\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "apply (auto elim: compare_LT_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>z = LT\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n   compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n  \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isJust_strict [simp]: \"isJust\\<cdot>\\<bottom>  = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isJust\\<cdot>\\<bottom> = \\<bottom>", "by (fixrec_simp)"], ["", "lemma fromMaybe_strict [simp]: \"fromMaybe\\<cdot>x\\<cdot>\\<bottom>  = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fromMaybe\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by (fixrec_simp)"], ["", "lemma maybeToList_strict [simp]: \"maybeToList\\<cdot>\\<bottom>  = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maybeToList\\<cdot>\\<bottom> = \\<bottom>", "by (fixrec_simp)"], ["", "end"]]}