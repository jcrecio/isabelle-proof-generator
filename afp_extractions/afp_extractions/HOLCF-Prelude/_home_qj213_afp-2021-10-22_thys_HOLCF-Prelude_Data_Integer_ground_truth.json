{"file_name": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude/Data_Integer.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude", "problem_names": ["lemma Integer_arith_strict [simp]:\n  fixes x :: Integer\n  shows \"\\<bottom> + x = \\<bottom>\" and \"x + \\<bottom> = \\<bottom>\"\n    and \"\\<bottom> * x = \\<bottom>\" and \"x * \\<bottom> = \\<bottom>\"\n    and \"\\<bottom> - x = \\<bottom>\" and \"x - \\<bottom> = \\<bottom>\"\n    and \"- \\<bottom> = (\\<bottom>::Integer)\"", "lemma Integer_arith_simps [simp]:\n  \"MkI\\<cdot>a + MkI\\<cdot>b = MkI\\<cdot>(a + b)\"\n  \"MkI\\<cdot>a * MkI\\<cdot>b = MkI\\<cdot>(a * b)\"\n  \"MkI\\<cdot>a - MkI\\<cdot>b = MkI\\<cdot>(a - b)\"\n  \"- MkI\\<cdot>a = MkI\\<cdot>(uminus a)\"", "lemma plus_MkI_MkI:\n  \"MkI\\<cdot>x + MkI\\<cdot>y = MkI\\<cdot>(x + y)\"", "lemma Integer_add_diff_cancel [simp]:\n  \"b \\<noteq> \\<bottom> \\<Longrightarrow> (a::Integer) + b - b = a\"", "lemma zero_Integer_neq_bottom [simp]: \"(0::Integer) \\<noteq> \\<bottom>\"", "lemma one_Integer_neq_bottom [simp]: \"(1::Integer) \\<noteq> \\<bottom>\"", "lemma plus_Integer_eq_bottom_iff [simp]:\n  fixes x y :: Integer shows \"x + y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\"", "lemma diff_Integer_eq_bottom_iff [simp]:\n  fixes x y :: Integer shows \"x - y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\"", "lemma mult_Integer_eq_bottom_iff [simp]:\n  fixes x y :: Integer shows \"x * y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\"", "lemma minus_Integer_eq_bottom_iff [simp]:\n  fixes x :: Integer shows \"- x = \\<bottom> \\<longleftrightarrow> x = \\<bottom>\"", "lemma numeral_Integer_eq: \"numeral k = MkI\\<cdot>(numeral k)\"", "lemma numeral_Integer_neq_bottom [simp]: \"(numeral k::Integer) \\<noteq> \\<bottom>\"", "lemma bottom_neq_zero_Integer [simp]: \"(\\<bottom>::Integer) \\<noteq> 0\"", "lemma bottom_neq_one_Integer [simp]: \"(\\<bottom>::Integer) \\<noteq> 1\"", "lemma bottom_neq_numeral_Integer [simp]: \"(\\<bottom>::Integer) \\<noteq> numeral k\"", "lemma eq_MkI_MkI [simp]:\n  \"eq\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) = (if m = n then TT else FF)\"", "lemma compare_MkI_MkI [simp]:\n  \"compare\\<cdot>(MkI\\<cdot>x)\\<cdot>(MkI\\<cdot>y) = (if x < y then LT else if x > y then GT else EQ)\"", "lemma lt_MkI_MkI [simp]:\n  \"lt\\<cdot>(MkI\\<cdot>x)\\<cdot>(MkI\\<cdot>y) = (if x < y then TT else FF)\"", "lemma le_MkI_MkI [simp]:\n  \"le\\<cdot>(MkI\\<cdot>x)\\<cdot>(MkI\\<cdot>y) = (if x \\<le> y then TT else FF)\"", "lemma eq_Integer_bottom_iff [simp]:\n  fixes x y :: Integer shows \"eq\\<cdot>x\\<cdot>y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\"", "lemma compare_Integer_bottom_iff [simp]:\n  fixes x y :: Integer shows \"compare\\<cdot>x\\<cdot>y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\"", "lemma lt_Integer_bottom_iff [simp]:\n  fixes x y :: Integer shows \"lt\\<cdot>x\\<cdot>y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\"", "lemma le_Integer_bottom_iff [simp]:\n  fixes x y :: Integer shows \"le\\<cdot>x\\<cdot>y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\"", "lemma compare_refl_Integer [simp]:\n  \"(x::Integer) \\<noteq> \\<bottom> \\<Longrightarrow> compare\\<cdot>x\\<cdot>x = EQ\"", "lemma eq_refl_Integer [simp]:\n  \"(x::Integer) \\<noteq> \\<bottom> \\<Longrightarrow> eq\\<cdot>x\\<cdot>x = TT\"", "lemma lt_refl_Integer [simp]:\n  \"(x::Integer) \\<noteq> \\<bottom> \\<Longrightarrow> lt\\<cdot>x\\<cdot>x = FF\"", "lemma le_refl_Integer [simp]:\n  \"(x::Integer) \\<noteq> \\<bottom> \\<Longrightarrow> le\\<cdot>x\\<cdot>x = TT\"", "lemma eq_Integer_numeral_simps [simp]:\n  \"eq\\<cdot>(0::Integer)\\<cdot>0 = TT\"\n  \"eq\\<cdot>(0::Integer)\\<cdot>1 = FF\"\n  \"eq\\<cdot>(1::Integer)\\<cdot>0 = FF\"\n  \"eq\\<cdot>(1::Integer)\\<cdot>1 = TT\"\n  \"eq\\<cdot>(0::Integer)\\<cdot>(numeral k) = FF\"\n  \"eq\\<cdot>(numeral k)\\<cdot>(0::Integer) = FF\"\n  \"k \\<noteq> Num.One \\<Longrightarrow> eq\\<cdot>(1::Integer)\\<cdot>(numeral k) = FF\"\n  \"k \\<noteq> Num.One \\<Longrightarrow> eq\\<cdot>(numeral k)\\<cdot>(1::Integer) = FF\"\n  \"eq\\<cdot>(numeral k::Integer)\\<cdot>(numeral l) = (if k = l then TT else FF)\"", "lemma compare_Integer_numeral_simps [simp]:\n  \"compare\\<cdot>(0::Integer)\\<cdot>0 = EQ\"\n  \"compare\\<cdot>(0::Integer)\\<cdot>1 = LT\"\n  \"compare\\<cdot>(1::Integer)\\<cdot>0 = GT\"\n  \"compare\\<cdot>(1::Integer)\\<cdot>1 = EQ\"\n  \"compare\\<cdot>(0::Integer)\\<cdot>(numeral k) = LT\"\n  \"compare\\<cdot>(numeral k)\\<cdot>(0::Integer) = GT\"\n  \"Num.One < k \\<Longrightarrow> compare\\<cdot>(1::Integer)\\<cdot>(numeral k) = LT\"\n  \"Num.One < k \\<Longrightarrow> compare\\<cdot>(numeral k)\\<cdot>(1::Integer) = GT\"\n  \"compare\\<cdot>(numeral k::Integer)\\<cdot>(numeral l) =\n    (if k < l then LT else if k > l then GT else EQ)\"", "lemma lt_Integer_numeral_simps [simp]:\n  \"lt\\<cdot>(0::Integer)\\<cdot>0 = FF\"\n  \"lt\\<cdot>(0::Integer)\\<cdot>1 = TT\"\n  \"lt\\<cdot>(1::Integer)\\<cdot>0 = FF\"\n  \"lt\\<cdot>(1::Integer)\\<cdot>1 = FF\"\n  \"lt\\<cdot>(0::Integer)\\<cdot>(numeral k) = TT\"\n  \"lt\\<cdot>(numeral k)\\<cdot>(0::Integer) = FF\"\n  \"Num.One < k \\<Longrightarrow> lt\\<cdot>(1::Integer)\\<cdot>(numeral k) = TT\"\n  \"lt\\<cdot>(numeral k)\\<cdot>(1::Integer) = FF\"\n  \"lt\\<cdot>(numeral k::Integer)\\<cdot>(numeral l) = (if k < l then TT else FF)\"", "lemma le_Integer_numeral_simps [simp]:\n  \"le\\<cdot>(0::Integer)\\<cdot>0 = TT\"\n  \"le\\<cdot>(0::Integer)\\<cdot>1 = TT\"\n  \"le\\<cdot>(1::Integer)\\<cdot>0 = FF\"\n  \"le\\<cdot>(1::Integer)\\<cdot>1 = TT\"\n  \"le\\<cdot>(0::Integer)\\<cdot>(numeral k) = TT\"\n  \"le\\<cdot>(numeral k)\\<cdot>(0::Integer) = FF\"\n  \"le\\<cdot>(1::Integer)\\<cdot>(numeral k) = TT\"\n  \"Num.One < k \\<Longrightarrow> le\\<cdot>(numeral k)\\<cdot>(1::Integer) = FF\"\n  \"le\\<cdot>(numeral k::Integer)\\<cdot>(numeral l) = (if k \\<le> l then TT else FF)\"", "lemma MkI_eq_0_iff [simp]: \"MkI\\<cdot>n = 0 \\<longleftrightarrow> n = 0\"", "lemma MkI_eq_1_iff [simp]: \"MkI\\<cdot>n = 1 \\<longleftrightarrow> n = 1\"", "lemma MkI_eq_numeral_iff [simp]: \"MkI\\<cdot>n = numeral k \\<longleftrightarrow> n = numeral k\"", "lemma MkI_0: \"MkI\\<cdot>0 = 0\"", "lemma MkI_1: \"MkI\\<cdot>1 = 1\"", "lemma le_plus_1:\n  fixes m :: \"Integer\"\n  assumes \"le\\<cdot>m\\<cdot>n = TT\"\n  shows \"le\\<cdot>m\\<cdot>(n + 1) = TT\"", "lemma nonneg_Integer_induct [consumes 1, case_names 0 step]:\n  fixes i :: Integer\n  assumes i_nonneg: \"le\\<cdot>0\\<cdot>i = TT\"\n    and zero: \"P 0\"\n    and step: \"\\<And>i. le\\<cdot>1\\<cdot>i = TT \\<Longrightarrow> P (i - 1) \\<Longrightarrow> P i\"\n  shows \"P i\""], "translations": [["", "lemma Integer_arith_strict [simp]:\n  fixes x :: Integer\n  shows \"\\<bottom> + x = \\<bottom>\" and \"x + \\<bottom> = \\<bottom>\"\n    and \"\\<bottom> * x = \\<bottom>\" and \"x * \\<bottom> = \\<bottom>\"\n    and \"\\<bottom> - x = \\<bottom>\" and \"x - \\<bottom> = \\<bottom>\"\n    and \"- \\<bottom> = (\\<bottom>::Integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bottom> + x = \\<bottom> &&&\n     x + \\<bottom> = \\<bottom> &&& \\<bottom> * x = \\<bottom>) &&&\n    (x * \\<bottom> = \\<bottom> &&& \\<bottom> - x = \\<bottom>) &&&\n    x - \\<bottom> = \\<bottom> &&& - \\<bottom> = \\<bottom>", "unfolding plus_Integer_def times_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case \\<bottom> of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x + y))\\<cdot>\n     x =\n     \\<bottom> &&&\n     (case x of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x + y))\\<cdot>\n     \\<bottom> =\n     \\<bottom> &&&\n     (case \\<bottom> of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x * y))\\<cdot>\n     x =\n     \\<bottom>) &&&\n    ((case x of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x * y))\\<cdot>\n     \\<bottom> =\n     \\<bottom> &&&\n     \\<bottom> - x = \\<bottom>) &&&\n    x - \\<bottom> = \\<bottom> &&& - \\<bottom> = \\<bottom>", "unfolding minus_Integer_def uminus_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case \\<bottom> of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x + y))\\<cdot>\n     x =\n     \\<bottom> &&&\n     (case x of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x + y))\\<cdot>\n     \\<bottom> =\n     \\<bottom> &&&\n     (case \\<bottom> of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x * y))\\<cdot>\n     x =\n     \\<bottom>) &&&\n    ((case x of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x * y))\\<cdot>\n     \\<bottom> =\n     \\<bottom> &&&\n     (case \\<bottom> of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x - y))\\<cdot>\n     x =\n     \\<bottom>) &&&\n    (case x of\n     MkI\\<cdot>x \\<Rightarrow>\n       \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x - y))\\<cdot>\n    \\<bottom> =\n    \\<bottom> &&&\n    (case \\<bottom> of MkI\\<cdot>x \\<Rightarrow> MkI\\<cdot>(- x)) =\n    \\<bottom>", "by (cases x, simp, simp)+"], ["", "lemma Integer_arith_simps [simp]:\n  \"MkI\\<cdot>a + MkI\\<cdot>b = MkI\\<cdot>(a + b)\"\n  \"MkI\\<cdot>a * MkI\\<cdot>b = MkI\\<cdot>(a * b)\"\n  \"MkI\\<cdot>a - MkI\\<cdot>b = MkI\\<cdot>(a - b)\"\n  \"- MkI\\<cdot>a = MkI\\<cdot>(uminus a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MkI\\<cdot>a + MkI\\<cdot>b = MkI\\<cdot>(a + b) &&&\n     MkI\\<cdot>a * MkI\\<cdot>b = MkI\\<cdot>(a * b)) &&&\n    MkI\\<cdot>a - MkI\\<cdot>b = MkI\\<cdot>(a - b) &&&\n    - MkI\\<cdot>a = MkI\\<cdot>(- a)", "unfolding plus_Integer_def times_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case MkI\\<cdot>a of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x + y))\\<cdot>\n     (MkI\\<cdot>b) =\n     MkI\\<cdot>(a + b) &&&\n     (case MkI\\<cdot>a of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x * y))\\<cdot>\n     (MkI\\<cdot>b) =\n     MkI\\<cdot>(a * b)) &&&\n    MkI\\<cdot>a - MkI\\<cdot>b = MkI\\<cdot>(a - b) &&&\n    - MkI\\<cdot>a = MkI\\<cdot>(- a)", "unfolding minus_Integer_def uminus_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case MkI\\<cdot>a of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x + y))\\<cdot>\n     (MkI\\<cdot>b) =\n     MkI\\<cdot>(a + b) &&&\n     (case MkI\\<cdot>a of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x * y))\\<cdot>\n     (MkI\\<cdot>b) =\n     MkI\\<cdot>(a * b)) &&&\n    (case MkI\\<cdot>a of\n     MkI\\<cdot>x \\<Rightarrow>\n       \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x - y))\\<cdot>\n    (MkI\\<cdot>b) =\n    MkI\\<cdot>(a - b) &&&\n    (case MkI\\<cdot>a of MkI\\<cdot>x \\<Rightarrow> MkI\\<cdot>(- x)) =\n    MkI\\<cdot>(- a)", "by simp_all"], ["", "lemma plus_MkI_MkI:\n  \"MkI\\<cdot>x + MkI\\<cdot>y = MkI\\<cdot>(x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI\\<cdot>x + MkI\\<cdot>y = MkI\\<cdot>(x + y)", "unfolding plus_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case MkI\\<cdot>x of\n     MkI\\<cdot>x \\<Rightarrow>\n       \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(x + y))\\<cdot>\n    (MkI\\<cdot>y) =\n    MkI\\<cdot>(x + y)", "by simp"], ["", "instance Integer :: \"{plus_cpo,minus_cpo,times_cpo}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Integer, minus_cpo_class) &&&\n    OFCLASS(Integer, plus_cpo_class) &&& OFCLASS(Integer, times_cpo_class)", "by standard (simp_all add: flatdom_strict2cont)"], ["", "instance Integer :: comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Integer, comm_monoid_add_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "fix a b c :: Integer"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "show \"(a + b) + c = a + (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "by (cases a; cases b; cases c) simp_all"], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal (2 subgoals):\n 1. \\<And>a b. a + b = b + a\n 2. \\<And>a. 0 + a = a", "show \"a + b = b + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = b + a", "by (cases a; cases b) simp_all"], ["proof (state)\nthis:\n  a + b = b + a\n\ngoal (1 subgoal):\n 1. \\<And>a. 0 + a = a", "show \"0 + a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + a = a", "unfolding zero_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI\\<cdot>0 + a = a", "by (cases a) simp_all"], ["proof (state)\nthis:\n  0 + a = a\n\ngoal:\nNo subgoals!", "qed"], ["", "instance Integer :: comm_monoid_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Integer, comm_monoid_mult_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. 1 * a = a", "fix a b c :: Integer"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. 1 * a = a", "show \"(a * b) * c = a * (b * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b * c = a * (b * c)", "by (cases a; cases b; cases c) simp_all"], ["proof (state)\nthis:\n  a * b * c = a * (b * c)\n\ngoal (2 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a. 1 * a = a", "show \"a * b = b * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b = b * a", "by (cases a; cases b) simp_all"], ["proof (state)\nthis:\n  a * b = b * a\n\ngoal (1 subgoal):\n 1. \\<And>a. 1 * a = a", "show \"1 * a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * a = a", "unfolding one_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI\\<cdot>1 * a = a", "by (cases a) simp_all"], ["proof (state)\nthis:\n  1 * a = a\n\ngoal:\nNo subgoals!", "qed"], ["", "instance Integer :: comm_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Integer, comm_semiring_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. (a + b) * c = a * c + b * c", "fix a b c :: Integer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. (a + b) * c = a * c + b * c", "show \"(a + b) * c = a * c + b * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b) * c = a * c + b * c", "by (cases a; cases b; cases c) (simp_all add: distrib_right)"], ["proof (state)\nthis:\n  (a + b) * c = a * c + b * c\n\ngoal:\nNo subgoals!", "qed"], ["", "instance Integer :: semiring_numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Integer, semiring_numeral_class)", ".."], ["", "lemma Integer_add_diff_cancel [simp]:\n  \"b \\<noteq> \\<bottom> \\<Longrightarrow> (a::Integer) + b - b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> \\<bottom> \\<Longrightarrow> a + b - b = a", "by (cases a; cases b) simp_all"], ["", "lemma zero_Integer_neq_bottom [simp]: \"(0::Integer) \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> \\<bottom>", "by (simp add: zero_Integer_def)"], ["", "lemma one_Integer_neq_bottom [simp]: \"(1::Integer) \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<noteq> \\<bottom>", "by (simp add: one_Integer_def)"], ["", "lemma plus_Integer_eq_bottom_iff [simp]:\n  fixes x y :: Integer shows \"x + y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y = \\<bottom>) = (x = \\<bottom> \\<or> y = \\<bottom>)", "by (cases x, simp, cases y, simp, simp)"], ["", "lemma diff_Integer_eq_bottom_iff [simp]:\n  fixes x y :: Integer shows \"x - y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - y = \\<bottom>) = (x = \\<bottom> \\<or> y = \\<bottom>)", "by (cases x, simp, cases y, simp, simp)"], ["", "lemma mult_Integer_eq_bottom_iff [simp]:\n  fixes x y :: Integer shows \"x * y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y = \\<bottom>) = (x = \\<bottom> \\<or> y = \\<bottom>)", "by (cases x, simp, cases y, simp, simp)"], ["", "lemma minus_Integer_eq_bottom_iff [simp]:\n  fixes x :: Integer shows \"- x = \\<bottom> \\<longleftrightarrow> x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x = \\<bottom>) = (x = \\<bottom>)", "by (cases x, simp, simp)"], ["", "lemma numeral_Integer_eq: \"numeral k = MkI\\<cdot>(numeral k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral k = MkI\\<cdot>(numeral k)", "by (induct k, simp_all only: numeral.simps one_Integer_def plus_MkI_MkI)"], ["", "lemma numeral_Integer_neq_bottom [simp]: \"(numeral k::Integer) \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral k \\<noteq> \\<bottom>", "unfolding numeral_Integer_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI\\<cdot>(numeral k) \\<noteq> \\<bottom>", "by simp"], ["", "text \\<open>Symmetric versions are also needed, because the reorient\n  simproc does not apply to these comparisons.\\<close>"], ["", "lemma bottom_neq_zero_Integer [simp]: \"(\\<bottom>::Integer) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<noteq> 0", "by (simp add: zero_Integer_def)"], ["", "lemma bottom_neq_one_Integer [simp]: \"(\\<bottom>::Integer) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<noteq> 1", "by (simp add: one_Integer_def)"], ["", "lemma bottom_neq_numeral_Integer [simp]: \"(\\<bottom>::Integer) \\<noteq> numeral k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<noteq> numeral k", "unfolding numeral_Integer_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<noteq> MkI\\<cdot>(numeral k)", "by simp"], ["", "instantiation Integer :: Ord_linear\nbegin"], ["", "definition\n  \"eq = (\\<Lambda> (MkI\\<cdot>x) (MkI\\<cdot>y). if x = y then TT else FF)\""], ["", "definition\n  \"compare = (\\<Lambda> (MkI\\<cdot>x) (MkI\\<cdot>y).\n    if x < y then LT else if x > y then GT else EQ)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Integer, Ord_linear_class)", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y. compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n 2. \\<And>x. compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 4. \\<And>x y.\n       oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n 5. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 6. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 7. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "fix x y z :: Integer"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y. compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n 2. \\<And>x. compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 4. \\<And>x y.\n       oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n 5. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 6. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 7. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "show \"compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>", "unfolding compare_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case \\<bottom> of\n     MkI\\<cdot>x \\<Rightarrow>\n       \\<Lambda> (MkI\\<cdot>y).\n          if x < y then LT else if y < x then GT else EQ)\\<cdot>\n    y =\n    \\<bottom>", "by simp"], ["proof (state)\nthis:\n  compare\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\n\ngoal (6 subgoals):\n 1. \\<And>x. compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 3. \\<And>x y.\n       oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n 4. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 5. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 6. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "show \"compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "unfolding compare_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     MkI\\<cdot>x \\<Rightarrow>\n       \\<Lambda> (MkI\\<cdot>y).\n          if x < y then LT else if y < x then GT else EQ)\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (5 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x y.\n       oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n 3. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 4. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 5. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "show \"oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x", "unfolding compare_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. oppOrdering\\<cdot>\n    ((case x of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y).\n           if x < y then LT else if y < x then GT else EQ)\\<cdot>\n     y) =\n    (case y of\n     MkI\\<cdot>x \\<Rightarrow>\n       \\<Lambda> (MkI\\<cdot>y).\n          if x < y then LT else if y < x then GT else EQ)\\<cdot>\n    x", "by (cases x, cases y, simp, simp,\n        cases y, simp, simp add: not_less less_imp_le)"], ["proof (state)\nthis:\n  oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n\ngoal (4 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 3. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 4. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "{"], ["proof (state)\nthis:\n  oppOrdering\\<cdot>(compare\\<cdot>x\\<cdot>y) = compare\\<cdot>y\\<cdot>x\n\ngoal (4 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 3. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 4. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "assume \"compare\\<cdot>x\\<cdot>y = EQ\""], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = EQ\n\ngoal (4 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x y. compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n 3. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 4. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "then"], ["proof (chain)\npicking this:\n  compare\\<cdot>x\\<cdot>y = EQ", "show \"x = y\""], ["proof (prove)\nusing this:\n  compare\\<cdot>x\\<cdot>y = EQ\n\ngoal (1 subgoal):\n 1. x = y", "unfolding compare_Integer_def"], ["proof (prove)\nusing this:\n  (case x of\n   MkI\\<cdot>x \\<Rightarrow>\n     \\<Lambda> (MkI\\<cdot>y).\n        if x < y then LT else if y < x then GT else EQ)\\<cdot>\n  y =\n  EQ\n\ngoal (1 subgoal):\n 1. x = y", "by (cases x, cases y, simp, simp,\n          cases y, simp, simp split: if_splits)"], ["proof (state)\nthis:\n  x = y\n\ngoal (3 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 3. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "}"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n\ngoal (3 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 3. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "{"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = EQ \\<Longrightarrow> x = y\n\ngoal (3 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 3. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "assume \"compare\\<cdot>x\\<cdot>y = LT\" and \"compare\\<cdot>y\\<cdot>z = LT\""], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>y = LT\n  compare\\<cdot>y\\<cdot>z = LT\n\ngoal (3 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n 3. \\<And>x y z.\n       \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n        compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n       \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT", "then"], ["proof (chain)\npicking this:\n  compare\\<cdot>x\\<cdot>y = LT\n  compare\\<cdot>y\\<cdot>z = LT", "show \"compare\\<cdot>x\\<cdot>z = LT\""], ["proof (prove)\nusing this:\n  compare\\<cdot>x\\<cdot>y = LT\n  compare\\<cdot>y\\<cdot>z = LT\n\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>z = LT", "unfolding compare_Integer_def"], ["proof (prove)\nusing this:\n  (case x of\n   MkI\\<cdot>x \\<Rightarrow>\n     \\<Lambda> (MkI\\<cdot>y).\n        if x < y then LT else if y < x then GT else EQ)\\<cdot>\n  y =\n  LT\n  (case y of\n   MkI\\<cdot>x \\<Rightarrow>\n     \\<Lambda> (MkI\\<cdot>y).\n        if x < y then LT else if y < x then GT else EQ)\\<cdot>\n  z =\n  LT\n\ngoal (1 subgoal):\n 1. (case x of\n     MkI\\<cdot>x \\<Rightarrow>\n       \\<Lambda> (MkI\\<cdot>y).\n          if x < y then LT else if y < x then GT else EQ)\\<cdot>\n    z =\n    LT", "by (cases x, simp, cases y, simp, cases z, simp,\n          auto split: if_splits)"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>z = LT\n\ngoal (2 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ", "}"], ["proof (state)\nthis:\n  \\<lbrakk>compare\\<cdot>x\\<cdot>y = LT;\n   compare\\<cdot>y\\<cdot>z = LT\\<rbrakk>\n  \\<Longrightarrow> compare\\<cdot>x\\<cdot>z = LT\n\ngoal (2 subgoals):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n 2. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ", "show \"eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)", "unfolding eq_Integer_def compare_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     MkI\\<cdot>x \\<Rightarrow>\n       \\<Lambda> (MkI\\<cdot>y). if x = y then TT else FF)\\<cdot>\n    y =\n    is_EQ\\<cdot>\n    ((case x of\n      MkI\\<cdot>x \\<Rightarrow>\n        \\<Lambda> (MkI\\<cdot>y).\n           if x < y then LT else if y < x then GT else EQ)\\<cdot>\n     y)", "by (cases x, simp, cases y, simp, auto)"], ["proof (state)\nthis:\n  eq\\<cdot>x\\<cdot>y = is_EQ\\<cdot>(compare\\<cdot>x\\<cdot>y)\n\ngoal (1 subgoal):\n 1. \\<And>x. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ", "show \"compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ", "unfolding compare_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     MkI\\<cdot>x \\<Rightarrow>\n       \\<Lambda> (MkI\\<cdot>y).\n          if x < y then LT else if y < x then GT else EQ)\\<cdot>\n    x \\<sqsubseteq>\n    EQ", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  compare\\<cdot>x\\<cdot>x \\<sqsubseteq> EQ\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma eq_MkI_MkI [simp]:\n  \"eq\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) = (if m = n then TT else FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) = (if m = n then TT else FF)", "by (simp add: eq_Integer_def)"], ["", "lemma compare_MkI_MkI [simp]:\n  \"compare\\<cdot>(MkI\\<cdot>x)\\<cdot>(MkI\\<cdot>y) = (if x < y then LT else if x > y then GT else EQ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare\\<cdot>(MkI\\<cdot>x)\\<cdot>(MkI\\<cdot>y) =\n    (if x < y then LT else if y < x then GT else EQ)", "unfolding compare_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case MkI\\<cdot>x of\n     MkI\\<cdot>x \\<Rightarrow>\n       \\<Lambda> (MkI\\<cdot>y).\n          if x < y then LT else if y < x then GT else EQ)\\<cdot>\n    (MkI\\<cdot>y) =\n    (if x < y then LT else if y < x then GT else EQ)", "by simp"], ["", "lemma lt_MkI_MkI [simp]:\n  \"lt\\<cdot>(MkI\\<cdot>x)\\<cdot>(MkI\\<cdot>y) = (if x < y then TT else FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt\\<cdot>(MkI\\<cdot>x)\\<cdot>(MkI\\<cdot>y) = (if x < y then TT else FF)", "unfolding lt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y.\n        case compare\\<cdot>x\\<cdot>y of LT \\<Rightarrow> TT\n        | EQ \\<Rightarrow> FF | GT \\<Rightarrow> FF)\\<cdot>\n    (MkI\\<cdot>x)\\<cdot>\n    (MkI\\<cdot>y) =\n    (if x < y then TT else FF)", "by simp"], ["", "lemma le_MkI_MkI [simp]:\n  \"le\\<cdot>(MkI\\<cdot>x)\\<cdot>(MkI\\<cdot>y) = (if x \\<le> y then TT else FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>(MkI\\<cdot>x)\\<cdot>(MkI\\<cdot>y) =\n    (if x \\<le> y then TT else FF)", "unfolding le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y.\n        case compare\\<cdot>x\\<cdot>y of LT \\<Rightarrow> TT\n        | EQ \\<Rightarrow> TT | GT \\<Rightarrow> FF)\\<cdot>\n    (MkI\\<cdot>x)\\<cdot>\n    (MkI\\<cdot>y) =\n    (if x \\<le> y then TT else FF)", "by simp"], ["", "lemma eq_Integer_bottom_iff [simp]:\n  fixes x y :: Integer shows \"eq\\<cdot>x\\<cdot>y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq\\<cdot>x\\<cdot>y = \\<bottom>) = (x = \\<bottom> \\<or> y = \\<bottom>)", "by (cases x, simp, cases y, simp, simp)"], ["", "lemma compare_Integer_bottom_iff [simp]:\n  fixes x y :: Integer shows \"compare\\<cdot>x\\<cdot>y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compare\\<cdot>x\\<cdot>y = \\<bottom>) =\n    (x = \\<bottom> \\<or> y = \\<bottom>)", "by (cases x, simp, cases y, simp, simp)"], ["", "lemma lt_Integer_bottom_iff [simp]:\n  fixes x y :: Integer shows \"lt\\<cdot>x\\<cdot>y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lt\\<cdot>x\\<cdot>y = \\<bottom>) = (x = \\<bottom> \\<or> y = \\<bottom>)", "by (cases x, simp, cases y, simp, simp)"], ["", "lemma le_Integer_bottom_iff [simp]:\n  fixes x y :: Integer shows \"le\\<cdot>x\\<cdot>y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (le\\<cdot>x\\<cdot>y = \\<bottom>) = (x = \\<bottom> \\<or> y = \\<bottom>)", "by (cases x, simp, cases y, simp, simp)"], ["", "lemma compare_refl_Integer [simp]:\n  \"(x::Integer) \\<noteq> \\<bottom> \\<Longrightarrow> compare\\<cdot>x\\<cdot>x = EQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<bottom> \\<Longrightarrow> compare\\<cdot>x\\<cdot>x = EQ", "by (cases x) simp_all"], ["", "lemma eq_refl_Integer [simp]:\n  \"(x::Integer) \\<noteq> \\<bottom> \\<Longrightarrow> eq\\<cdot>x\\<cdot>x = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<bottom> \\<Longrightarrow> eq\\<cdot>x\\<cdot>x = TT", "by (cases x) simp_all"], ["", "lemma lt_refl_Integer [simp]:\n  \"(x::Integer) \\<noteq> \\<bottom> \\<Longrightarrow> lt\\<cdot>x\\<cdot>x = FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<bottom> \\<Longrightarrow> lt\\<cdot>x\\<cdot>x = FF", "by (cases x) simp_all"], ["", "lemma le_refl_Integer [simp]:\n  \"(x::Integer) \\<noteq> \\<bottom> \\<Longrightarrow> le\\<cdot>x\\<cdot>x = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<bottom> \\<Longrightarrow> le\\<cdot>x\\<cdot>x = TT", "by (cases x) simp_all"], ["", "lemma eq_Integer_numeral_simps [simp]:\n  \"eq\\<cdot>(0::Integer)\\<cdot>0 = TT\"\n  \"eq\\<cdot>(0::Integer)\\<cdot>1 = FF\"\n  \"eq\\<cdot>(1::Integer)\\<cdot>0 = FF\"\n  \"eq\\<cdot>(1::Integer)\\<cdot>1 = TT\"\n  \"eq\\<cdot>(0::Integer)\\<cdot>(numeral k) = FF\"\n  \"eq\\<cdot>(numeral k)\\<cdot>(0::Integer) = FF\"\n  \"k \\<noteq> Num.One \\<Longrightarrow> eq\\<cdot>(1::Integer)\\<cdot>(numeral k) = FF\"\n  \"k \\<noteq> Num.One \\<Longrightarrow> eq\\<cdot>(numeral k)\\<cdot>(1::Integer) = FF\"\n  \"eq\\<cdot>(numeral k::Integer)\\<cdot>(numeral l) = (if k = l then TT else FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((eq\\<cdot>0\\<cdot>0 = TT &&& eq\\<cdot>0\\<cdot>1 = FF) &&&\n     eq\\<cdot>1\\<cdot>0 = FF &&& eq\\<cdot>1\\<cdot>1 = TT) &&&\n    (eq\\<cdot>0\\<cdot>(numeral k) = FF &&&\n     eq\\<cdot>(numeral k)\\<cdot>0 = FF) &&&\n    (k \\<noteq> num.One \\<Longrightarrow>\n     eq\\<cdot>1\\<cdot>(numeral k) = FF) &&&\n    (k \\<noteq> num.One \\<Longrightarrow>\n     eq\\<cdot>(numeral k)\\<cdot>1 = FF) &&&\n    eq\\<cdot>(numeral k)\\<cdot>(numeral l) = (if k = l then TT else FF)", "unfolding zero_Integer_def one_Integer_def numeral_Integer_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((eq\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>0) = TT &&&\n      eq\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>1) = FF) &&&\n     eq\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>0) = FF &&&\n     eq\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>1) = TT) &&&\n    (eq\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>(numeral k)) = FF &&&\n     eq\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>0) = FF) &&&\n    (k \\<noteq> num.One \\<Longrightarrow>\n     eq\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>(numeral k)) = FF) &&&\n    (k \\<noteq> num.One \\<Longrightarrow>\n     eq\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>1) = FF) &&&\n    eq\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>(numeral l)) =\n    (if k = l then TT else FF)", "by simp_all"], ["", "lemma compare_Integer_numeral_simps [simp]:\n  \"compare\\<cdot>(0::Integer)\\<cdot>0 = EQ\"\n  \"compare\\<cdot>(0::Integer)\\<cdot>1 = LT\"\n  \"compare\\<cdot>(1::Integer)\\<cdot>0 = GT\"\n  \"compare\\<cdot>(1::Integer)\\<cdot>1 = EQ\"\n  \"compare\\<cdot>(0::Integer)\\<cdot>(numeral k) = LT\"\n  \"compare\\<cdot>(numeral k)\\<cdot>(0::Integer) = GT\"\n  \"Num.One < k \\<Longrightarrow> compare\\<cdot>(1::Integer)\\<cdot>(numeral k) = LT\"\n  \"Num.One < k \\<Longrightarrow> compare\\<cdot>(numeral k)\\<cdot>(1::Integer) = GT\"\n  \"compare\\<cdot>(numeral k::Integer)\\<cdot>(numeral l) =\n    (if k < l then LT else if k > l then GT else EQ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((compare\\<cdot>0\\<cdot>0 = EQ &&& compare\\<cdot>0\\<cdot>1 = LT) &&&\n     compare\\<cdot>1\\<cdot>0 = GT &&& compare\\<cdot>1\\<cdot>1 = EQ) &&&\n    (compare\\<cdot>0\\<cdot>(numeral k) = LT &&&\n     compare\\<cdot>(numeral k)\\<cdot>0 = GT) &&&\n    (num.One < k \\<Longrightarrow>\n     compare\\<cdot>1\\<cdot>(numeral k) = LT) &&&\n    (num.One < k \\<Longrightarrow>\n     compare\\<cdot>(numeral k)\\<cdot>1 = GT) &&&\n    compare\\<cdot>(numeral k)\\<cdot>(numeral l) =\n    (if k < l then LT else if l < k then GT else EQ)", "unfolding zero_Integer_def one_Integer_def numeral_Integer_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((compare\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>0) = EQ &&&\n      compare\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>1) = LT) &&&\n     compare\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>0) = GT &&&\n     compare\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>1) = EQ) &&&\n    (compare\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>(numeral k)) = LT &&&\n     compare\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>0) = GT) &&&\n    (num.One < k \\<Longrightarrow>\n     compare\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>(numeral k)) = LT) &&&\n    (num.One < k \\<Longrightarrow>\n     compare\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>1) = GT) &&&\n    compare\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>(numeral l)) =\n    (if k < l then LT else if l < k then GT else EQ)", "by simp_all"], ["", "lemma lt_Integer_numeral_simps [simp]:\n  \"lt\\<cdot>(0::Integer)\\<cdot>0 = FF\"\n  \"lt\\<cdot>(0::Integer)\\<cdot>1 = TT\"\n  \"lt\\<cdot>(1::Integer)\\<cdot>0 = FF\"\n  \"lt\\<cdot>(1::Integer)\\<cdot>1 = FF\"\n  \"lt\\<cdot>(0::Integer)\\<cdot>(numeral k) = TT\"\n  \"lt\\<cdot>(numeral k)\\<cdot>(0::Integer) = FF\"\n  \"Num.One < k \\<Longrightarrow> lt\\<cdot>(1::Integer)\\<cdot>(numeral k) = TT\"\n  \"lt\\<cdot>(numeral k)\\<cdot>(1::Integer) = FF\"\n  \"lt\\<cdot>(numeral k::Integer)\\<cdot>(numeral l) = (if k < l then TT else FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((lt\\<cdot>0\\<cdot>0 = FF &&& lt\\<cdot>0\\<cdot>1 = TT) &&&\n     lt\\<cdot>1\\<cdot>0 = FF &&& lt\\<cdot>1\\<cdot>1 = FF) &&&\n    (lt\\<cdot>0\\<cdot>(numeral k) = TT &&&\n     lt\\<cdot>(numeral k)\\<cdot>0 = FF) &&&\n    (num.One < k \\<Longrightarrow> lt\\<cdot>1\\<cdot>(numeral k) = TT) &&&\n    lt\\<cdot>(numeral k)\\<cdot>1 = FF &&&\n    lt\\<cdot>(numeral k)\\<cdot>(numeral l) = (if k < l then TT else FF)", "unfolding zero_Integer_def one_Integer_def numeral_Integer_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((lt\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>0) = FF &&&\n      lt\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>1) = TT) &&&\n     lt\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>0) = FF &&&\n     lt\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>1) = FF) &&&\n    (lt\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>(numeral k)) = TT &&&\n     lt\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>0) = FF) &&&\n    (num.One < k \\<Longrightarrow>\n     lt\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>(numeral k)) = TT) &&&\n    lt\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>1) = FF &&&\n    lt\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>(numeral l)) =\n    (if k < l then TT else FF)", "by simp_all"], ["", "lemma le_Integer_numeral_simps [simp]:\n  \"le\\<cdot>(0::Integer)\\<cdot>0 = TT\"\n  \"le\\<cdot>(0::Integer)\\<cdot>1 = TT\"\n  \"le\\<cdot>(1::Integer)\\<cdot>0 = FF\"\n  \"le\\<cdot>(1::Integer)\\<cdot>1 = TT\"\n  \"le\\<cdot>(0::Integer)\\<cdot>(numeral k) = TT\"\n  \"le\\<cdot>(numeral k)\\<cdot>(0::Integer) = FF\"\n  \"le\\<cdot>(1::Integer)\\<cdot>(numeral k) = TT\"\n  \"Num.One < k \\<Longrightarrow> le\\<cdot>(numeral k)\\<cdot>(1::Integer) = FF\"\n  \"le\\<cdot>(numeral k::Integer)\\<cdot>(numeral l) = (if k \\<le> l then TT else FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((le\\<cdot>0\\<cdot>0 = TT &&& le\\<cdot>0\\<cdot>1 = TT) &&&\n     le\\<cdot>1\\<cdot>0 = FF &&& le\\<cdot>1\\<cdot>1 = TT) &&&\n    (le\\<cdot>0\\<cdot>(numeral k) = TT &&&\n     le\\<cdot>(numeral k)\\<cdot>0 = FF) &&&\n    le\\<cdot>1\\<cdot>(numeral k) = TT &&&\n    (num.One < k \\<Longrightarrow> le\\<cdot>(numeral k)\\<cdot>1 = FF) &&&\n    le\\<cdot>(numeral k)\\<cdot>(numeral l) = (if k \\<le> l then TT else FF)", "unfolding zero_Integer_def one_Integer_def numeral_Integer_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((le\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>0) = TT &&&\n      le\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>1) = TT) &&&\n     le\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>0) = FF &&&\n     le\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>1) = TT) &&&\n    (le\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>(numeral k)) = TT &&&\n     le\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>0) = FF) &&&\n    le\\<cdot>(MkI\\<cdot>1)\\<cdot>(MkI\\<cdot>(numeral k)) = TT &&&\n    (num.One < k \\<Longrightarrow>\n     le\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>1) = FF) &&&\n    le\\<cdot>(MkI\\<cdot>(numeral k))\\<cdot>(MkI\\<cdot>(numeral l)) =\n    (if k \\<le> l then TT else FF)", "by simp_all"], ["", "lemma MkI_eq_0_iff [simp]: \"MkI\\<cdot>n = 0 \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MkI\\<cdot>n = 0) = (n = 0)", "unfolding zero_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MkI\\<cdot>n = MkI\\<cdot>0) = (n = 0)", "by simp"], ["", "lemma MkI_eq_1_iff [simp]: \"MkI\\<cdot>n = 1 \\<longleftrightarrow> n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MkI\\<cdot>n = 1) = (n = 1)", "unfolding one_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MkI\\<cdot>n = MkI\\<cdot>1) = (n = 1)", "by simp"], ["", "lemma MkI_eq_numeral_iff [simp]: \"MkI\\<cdot>n = numeral k \\<longleftrightarrow> n = numeral k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MkI\\<cdot>n = numeral k) = (n = numeral k)", "unfolding numeral_Integer_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MkI\\<cdot>n = MkI\\<cdot>(numeral k)) = (n = numeral k)", "by simp"], ["", "lemma MkI_0: \"MkI\\<cdot>0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI\\<cdot>0 = 0", "by simp"], ["", "lemma MkI_1: \"MkI\\<cdot>1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI\\<cdot>1 = 1", "by simp"], ["", "lemma le_plus_1:\n  fixes m :: \"Integer\"\n  assumes \"le\\<cdot>m\\<cdot>n = TT\"\n  shows \"le\\<cdot>m\\<cdot>(n + 1) = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>m\\<cdot>(n + 1) = TT", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. le\\<cdot>m\\<cdot>(n + 1) = TT", "from assms"], ["proof (chain)\npicking this:\n  le\\<cdot>m\\<cdot>n = TT", "have \"n \\<noteq> \\<bottom>\""], ["proof (prove)\nusing this:\n  le\\<cdot>m\\<cdot>n = TT\n\ngoal (1 subgoal):\n 1. n \\<noteq> \\<bottom>", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. le\\<cdot>m\\<cdot>(n + 1) = TT", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> \\<bottom>", "have \"le\\<cdot>n\\<cdot>(n + 1) = TT\""], ["proof (prove)\nusing this:\n  n \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. le\\<cdot>n\\<cdot>(n + 1) = TT", "by (cases n) (auto, metis le_MkI_MkI less_add_one less_le_not_le one_Integer_def plus_MkI_MkI)"], ["proof (state)\nthis:\n  le\\<cdot>n\\<cdot>(n + 1) = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>m\\<cdot>(n + 1) = TT", "with assms"], ["proof (chain)\npicking this:\n  le\\<cdot>m\\<cdot>n = TT\n  le\\<cdot>n\\<cdot>(n + 1) = TT", "show ?thesis"], ["proof (prove)\nusing this:\n  le\\<cdot>m\\<cdot>n = TT\n  le\\<cdot>n\\<cdot>(n + 1) = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>m\\<cdot>(n + 1) = TT", "by (auto dest: le_trans)"], ["proof (state)\nthis:\n  le\\<cdot>m\\<cdot>(n + 1) = TT\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Induction rules that do not break the abstraction\\<close>"], ["", "lemma nonneg_Integer_induct [consumes 1, case_names 0 step]:\n  fixes i :: Integer\n  assumes i_nonneg: \"le\\<cdot>0\\<cdot>i = TT\"\n    and zero: \"P 0\"\n    and step: \"\\<And>i. le\\<cdot>1\\<cdot>i = TT \\<Longrightarrow> P (i - 1) \\<Longrightarrow> P i\"\n  shows \"P i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P i", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = \\<bottom> \\<Longrightarrow> P i\n 2. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "case bottom"], ["proof (state)\nthis:\n  i = \\<bottom>\n\ngoal (2 subgoals):\n 1. i = \\<bottom> \\<Longrightarrow> P i\n 2. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "then"], ["proof (chain)\npicking this:\n  i = \\<bottom>", "have False"], ["proof (prove)\nusing this:\n  i = \\<bottom>\n\ngoal (1 subgoal):\n 1. False", "using i_nonneg"], ["proof (prove)\nusing this:\n  i = \\<bottom>\n  le\\<cdot>0\\<cdot>i = TT\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. i = \\<bottom> \\<Longrightarrow> P i\n 2. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. P i", ".."], ["proof (state)\nthis:\n  P i\n\ngoal (1 subgoal):\n 1. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "case (MkI integer)"], ["proof (state)\nthis:\n  i = MkI\\<cdot>integer\n\ngoal (1 subgoal):\n 1. \\<And>int. i = MkI\\<cdot>int \\<Longrightarrow> P i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P i", "proof (cases integer)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i\n 2. \\<And>n. integer = - int (Suc n) \\<Longrightarrow> P i", "case neg"], ["proof (state)\nthis:\n  integer = - int (Suc n_)\n\ngoal (2 subgoals):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i\n 2. \\<And>n. integer = - int (Suc n) \\<Longrightarrow> P i", "then"], ["proof (chain)\npicking this:\n  integer = - int (Suc n_)", "have False"], ["proof (prove)\nusing this:\n  integer = - int (Suc n_)\n\ngoal (1 subgoal):\n 1. False", "using i_nonneg MkI"], ["proof (prove)\nusing this:\n  integer = - int (Suc n_)\n  le\\<cdot>0\\<cdot>i = TT\n  i = MkI\\<cdot>integer\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: zero_Integer_def one_Integer_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i\n 2. \\<And>n. integer = - int (Suc n) \\<Longrightarrow> P i", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. P i", ".."], ["proof (state)\nthis:\n  P i\n\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i", "case (nonneg nat)"], ["proof (state)\nthis:\n  integer = int nat\n\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i", "have \"P (MkI\\<cdot>(int nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (MkI\\<cdot>(int nat))", "proof(induct nat)"], ["proof (state)\ngoal (2 subgoals):\n 1. P (MkI\\<cdot>(int 0))\n 2. \\<And>nat.\n       P (MkI\\<cdot>(int nat)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int (Suc nat)))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. P (MkI\\<cdot>(int 0))\n 2. \\<And>nat.\n       P (MkI\\<cdot>(int nat)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int (Suc nat)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (MkI\\<cdot>(int 0))", "using zero"], ["proof (prove)\nusing this:\n  P 0\n\ngoal (1 subgoal):\n 1. P (MkI\\<cdot>(int 0))", "by (simp add: zero_Integer_def)"], ["proof (state)\nthis:\n  P (MkI\\<cdot>(int 0))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       P (MkI\\<cdot>(int nat)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int (Suc nat)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       P (MkI\\<cdot>(int nat)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int (Suc nat)))", "case (Suc nat)"], ["proof (state)\nthis:\n  P (MkI\\<cdot>(int nat))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       P (MkI\\<cdot>(int nat)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int (Suc nat)))", "have \"le\\<cdot>1\\<cdot>(MkI\\<cdot>(int (Suc nat))) = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>1\\<cdot>(MkI\\<cdot>(int (Suc nat))) = TT", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  le\\<cdot>1\\<cdot>(MkI\\<cdot>(int (Suc nat))) = TT\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       P (MkI\\<cdot>(int nat)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int (Suc nat)))", "moreover"], ["proof (state)\nthis:\n  le\\<cdot>1\\<cdot>(MkI\\<cdot>(int (Suc nat))) = TT\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       P (MkI\\<cdot>(int nat)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int (Suc nat)))", "have \"P (MkI\\<cdot>(int (Suc nat)) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (MkI\\<cdot>(int (Suc nat)) - 1)", "using Suc"], ["proof (prove)\nusing this:\n  P (MkI\\<cdot>(int nat))\n\ngoal (1 subgoal):\n 1. P (MkI\\<cdot>(int (Suc nat)) - 1)", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  P (MkI\\<cdot>(int (Suc nat)) - 1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       P (MkI\\<cdot>(int nat)) \\<Longrightarrow>\n       P (MkI\\<cdot>(int (Suc nat)))", "ultimately"], ["proof (chain)\npicking this:\n  le\\<cdot>1\\<cdot>(MkI\\<cdot>(int (Suc nat))) = TT\n  P (MkI\\<cdot>(int (Suc nat)) - 1)", "show ?case"], ["proof (prove)\nusing this:\n  le\\<cdot>1\\<cdot>(MkI\\<cdot>(int (Suc nat))) = TT\n  P (MkI\\<cdot>(int (Suc nat)) - 1)\n\ngoal (1 subgoal):\n 1. P (MkI\\<cdot>(int (Suc nat)))", "by (rule step)"], ["proof (state)\nthis:\n  P (MkI\\<cdot>(int (Suc nat)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (MkI\\<cdot>(int nat))\n\ngoal (1 subgoal):\n 1. \\<And>n. integer = int n \\<Longrightarrow> P i", "then"], ["proof (chain)\npicking this:\n  P (MkI\\<cdot>(int nat))", "show ?thesis"], ["proof (prove)\nusing this:\n  P (MkI\\<cdot>(int nat))\n\ngoal (1 subgoal):\n 1. P i", "using nonneg MkI"], ["proof (prove)\nusing this:\n  P (MkI\\<cdot>(int nat))\n  integer = int nat\n  i = MkI\\<cdot>integer\n\ngoal (1 subgoal):\n 1. P i", "by simp"], ["proof (state)\nthis:\n  P i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}