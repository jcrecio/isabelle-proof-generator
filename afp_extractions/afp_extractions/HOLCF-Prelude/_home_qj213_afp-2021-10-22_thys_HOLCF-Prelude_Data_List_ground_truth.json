{"file_name": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude/Data_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude", "problem_names": ["lemma finite_list_upwards:\n  assumes \"finite_list xs\" and \"xs \\<sqsubseteq> ys\"\n  shows \"finite_list ys\"", "lemma adm_finite_list [simp]: \"adm finite_list\"", "lemma bot_not_finite_list [simp]:\n  \"finite_list \\<bottom> = False\"", "lemma listmem_simps [simp]:\n  shows \"\\<not> listmem x \\<bottom>\" and \"\\<not> listmem x []\"\n  and \"listmem x (y : ys) \\<longleftrightarrow> x = y \\<or> listmem x ys\"", "lemma set_simps [simp]:\n  shows \"set \\<bottom> = {}\" and \"set [] = {}\"\n  and \"set (x : xs) = insert x (set xs)\"", "lemma map_strict [simp]:\n  \"map\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>\"", "lemma map_ID [simp]:\n  \"map\\<cdot>ID\\<cdot>xs = xs\"", "lemma enumFrom_intsFrom_conv [simp]:\n  \"enumFrom = intsFrom\"", "lemma enumFromTo_upto_conv [simp]:\n  \"enumFromTo = upto\"", "lemma zipWith_strict [simp]:\n  \"zipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\"\n  \"zipWith\\<cdot>f\\<cdot>(x : xs)\\<cdot>\\<bottom> = \\<bottom>\"", "lemma zip_simps [simp]:\n  \"zip\\<cdot>(x : xs)\\<cdot>(y : ys) = \\<langle>x, y\\<rangle> : zip\\<cdot>xs\\<cdot>ys\"\n  \"zip\\<cdot>(x : xs)\\<cdot>[] = []\"\n  \"zip\\<cdot>(x : xs)\\<cdot>\\<bottom> = \\<bottom>\"\n  \"zip\\<cdot>[]\\<cdot>ys = []\"\n  \"zip\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\"", "lemma zip_Nil2 [simp]:\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> zip\\<cdot>xs\\<cdot>[] = []\"", "lemma nth_strict [simp]:\n  \"nth\\<cdot>\\<bottom>\\<cdot>n = \\<bottom>\"\n  \"nth\\<cdot>xs\\<cdot>\\<bottom> = \\<bottom>\"", "lemma upto_strict [simp]:\n  \"upto\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\"\n  \"upto\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"", "lemma upto_simps [simp]:\n  \"n < m \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) = []\"\n  \"m \\<le> n \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) = MkI\\<cdot>m : [MkI\\<cdot>m+1..MkI\\<cdot>n]\"", "lemma filter_strict [simp]:\n  \"filter\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>\"", "lemma nth_Cons_simp [simp]:\n  \"eq\\<cdot>n\\<cdot>0 = TT \\<Longrightarrow> nth\\<cdot>(x : xs)\\<cdot>n = x\"\n  \"eq\\<cdot>n\\<cdot>0 = FF \\<Longrightarrow> nth\\<cdot>(x : xs)\\<cdot>n = nth\\<cdot>xs\\<cdot>(n - 1)\"", "lemma nth_Cons_split:\n   \"P (nth\\<cdot>(x : xs)\\<cdot>n) = ((eq\\<cdot>n\\<cdot>0 = FF \\<longrightarrow> P (nth\\<cdot>(x : xs)\\<cdot>n)) \\<and>\n                              (eq\\<cdot>n\\<cdot>0 = TT \\<longrightarrow> P (nth\\<cdot>(x : xs)\\<cdot>n)) \\<and>\n                              (n = \\<bottom> \\<longrightarrow> P (nth\\<cdot>(x : xs)\\<cdot>n)))\"", "lemma nth_Cons_numeral [simp]:\n  \"(x : xs) !! 0 = x\"\n  \"(x : xs) !! 1 = xs !! 0\"\n  \"(x : xs) !! numeral (Num.Bit0 k) = xs !! numeral (Num.BitM k)\"\n  \"(x : xs) !! numeral (Num.Bit1 k) = xs !! numeral (Num.Bit0 k)\"", "lemma take_strict [simp]:\n  \"take\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\"", "lemma take_strict_2 [simp]:\n  \"le\\<cdot>1\\<cdot>i = TT \\<Longrightarrow> take\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>\"", "lemma drop_strict [simp]:\n  \"drop\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\"", "lemma isPrefixOf_strict [simp]:\n  \"isPrefixOf\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\"\n  \"isPrefixOf\\<cdot>(x:xs)\\<cdot>\\<bottom> = \\<bottom>\"", "lemma last_strict[simp]:\n  \"last\\<cdot>\\<bottom>= \\<bottom>\"\n  \"last\\<cdot>(x:\\<bottom>) = \\<bottom>\"", "lemma last_nil [simp]:\n  \"last\\<cdot>[] = \\<bottom>\"", "lemma last_spine_strict: \"\\<not> finite_list xs \\<Longrightarrow> last\\<cdot>xs = \\<bottom>\"", "lemma init_strict [simp]:\n  \"init\\<cdot>\\<bottom>= \\<bottom>\"\n  \"init\\<cdot>(x:\\<bottom>) = \\<bottom>\"", "lemma init_nil [simp]:\n  \"init\\<cdot>[] = \\<bottom>\"", "lemma strict_foldr_strict2 [simp]:\n  \"(\\<And>x. f\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>) \\<Longrightarrow> foldr\\<cdot>f\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\"", "lemma foldr_strict [simp]:\n  \"foldr\\<cdot>f\\<cdot>d\\<cdot>\\<bottom> = \\<bottom>\"\n  \"foldr\\<cdot>f\\<cdot>\\<bottom>\\<cdot>[] = \\<bottom>\"\n  \"foldr\\<cdot>\\<bottom>\\<cdot>d\\<cdot>(x : xs) = \\<bottom>\"", "lemma foldr_Cons_Nil [simp]:\n  \"foldr\\<cdot>(:)\\<cdot>[]\\<cdot>xs = xs\"", "lemma append_strict1 [simp]:\n  \"\\<bottom> ++ ys = \\<bottom>\"", "lemma foldr_append [simp]:\n  \"foldr\\<cdot>f\\<cdot>a\\<cdot>(xs ++ ys) = foldr\\<cdot>f\\<cdot>(foldr\\<cdot>f\\<cdot>a\\<cdot>ys)\\<cdot>xs\"", "lemma foldl_strict [simp]:\n  \"foldl\\<cdot>f\\<cdot>d\\<cdot>\\<bottom> = \\<bottom>\"\n  \"foldl\\<cdot>f\\<cdot>\\<bottom>\\<cdot>[] = \\<bottom>\"", "lemma foldr1_strict [simp]:\n  \"foldr1\\<cdot>f\\<cdot>\\<bottom>= \\<bottom>\"\n  \"foldr1\\<cdot>f\\<cdot>(x:\\<bottom>)= \\<bottom>\"", "lemma foldl1_strict [simp]:\n  \"foldl1\\<cdot>f\\<cdot>\\<bottom>= \\<bottom>\"", "lemma foldl_spine_strict:\n  \"\\<not> finite_list xs \\<Longrightarrow> foldl\\<cdot>f\\<cdot>x\\<cdot>xs = \\<bottom>\"", "lemma foldl_assoc_foldr:\n  assumes \"finite_list xs\"\n    and assoc: \"\\<And>x y z. f\\<cdot>(f\\<cdot>x\\<cdot>y)\\<cdot>z = f\\<cdot>x\\<cdot>(f\\<cdot>y\\<cdot>z)\"\n    and neutr1: \"\\<And>x. f\\<cdot>z\\<cdot>x = x\"\n    and neutr2: \"\\<And>x. f\\<cdot>x\\<cdot>z = x\"\n  shows \"foldl\\<cdot>f\\<cdot>z\\<cdot>xs = foldr\\<cdot>f\\<cdot>z\\<cdot>xs\"", "lemma elem_strict [simp]:\n  \"elem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"", "lemma notElem_strict [simp]:\n  \"notElem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"", "lemma list_eq_nil[simp]:\n  \"eq\\<cdot>l\\<cdot>[] = TT \\<longleftrightarrow> l = []\"\n  \"eq\\<cdot>[]\\<cdot>l = TT \\<longleftrightarrow> l = []\"", "lemma take_Nil [simp]:\n  \"n \\<noteq> \\<bottom> \\<Longrightarrow> take\\<cdot>n\\<cdot>[] = []\"", "lemma take_0 [simp]:\n  \"take\\<cdot>0\\<cdot>xs = []\"\n  \"take\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = []\"", "lemma take_Cons [simp]:\n  \"le\\<cdot>1\\<cdot>i = TT \\<Longrightarrow> take\\<cdot>i\\<cdot>(x:xs) = x : take\\<cdot>(i - 1)\\<cdot>xs\"", "lemma take_MkI_Cons [simp]:\n  \"0 < n \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>(x : xs) = x : take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>xs\"", "lemma take_numeral_Cons [simp]:\n  \"take\\<cdot>1\\<cdot>(x : xs) = [x]\"\n  \"take\\<cdot>(numeral (Num.Bit0 k))\\<cdot>(x : xs) = x : take\\<cdot>(numeral (Num.BitM k))\\<cdot>xs\"\n  \"take\\<cdot>(numeral (Num.Bit1 k))\\<cdot>(x : xs) = x : take\\<cdot>(numeral (Num.Bit0 k))\\<cdot>xs\"", "lemma drop_0 [simp]:\n  \"drop\\<cdot>0\\<cdot>xs = xs\"\n  \"drop\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = xs\"", "lemma drop_pos [simp]:\n  \"le\\<cdot>n\\<cdot>0 = FF \\<Longrightarrow> drop\\<cdot>n\\<cdot>xs = (case xs of [] \\<Rightarrow> [] | y : ys \\<Rightarrow> drop\\<cdot>(n - 1)\\<cdot>ys)\"", "lemma drop_numeral_Cons [simp]:\n  \"drop\\<cdot>1\\<cdot>(x : xs) = xs\"\n  \"drop\\<cdot>(numeral (Num.Bit0 k))\\<cdot>(x : xs) = drop\\<cdot>(numeral (Num.BitM k))\\<cdot>xs\"\n  \"drop\\<cdot>(numeral (Num.Bit1 k))\\<cdot>(x : xs) = drop\\<cdot>(numeral (Num.Bit0 k))\\<cdot>xs\"", "lemma take_drop_append:\n  \"take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++ drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs = xs\"", "lemma take_intsFrom_enumFrom [simp]:\n  \"take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] = [MkI\\<cdot>i..MkI\\<cdot>(n+i) - 1]\"", "lemma drop_intsFrom_enumFrom [simp]:\n  assumes \"n \\<ge> 0\"\n  shows \"drop\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] = [MkI\\<cdot>(n+i)..]\"", "lemma last_append_singleton:\n  \"finite_list xs \\<Longrightarrow> last\\<cdot>(xs ++ [x]) = x\"", "lemma init_append_singleton:\n  \"finite_list xs \\<Longrightarrow> init\\<cdot>(xs ++ [x]) = xs\"", "lemma append_Nil2 [simp]:\n  \"xs ++ [] = xs\"", "lemma append_assoc [simp]:\n  \"(xs ++ ys) ++ zs = xs ++ ys ++ zs\"", "lemma concat_simps [simp]:\n  \"concat\\<cdot>[] = []\"\n  \"concat\\<cdot>(xs : xss) = xs ++ concat\\<cdot>xss\"\n  \"concat\\<cdot>\\<bottom> = \\<bottom>\"", "lemma concatMap_simps [simp]:\n  \"concatMap\\<cdot>f\\<cdot>[] = []\"\n  \"concatMap\\<cdot>f\\<cdot>(x : xs) = f\\<cdot>x ++ concatMap\\<cdot>f\\<cdot>xs\"\n  \"concatMap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"", "lemma filter_append [simp]:\n  \"filter\\<cdot>P\\<cdot>(xs ++ ys) = filter\\<cdot>P\\<cdot>xs ++ filter\\<cdot>P\\<cdot>ys\"", "lemma elem_append [simp]:\n  \"elem\\<cdot>x\\<cdot>(xs ++ ys) = (elem\\<cdot>x\\<cdot>xs orelse elem\\<cdot>x\\<cdot>ys)\"", "lemma filter_filter [simp]:\n  \"filter\\<cdot>P\\<cdot>(filter\\<cdot>Q\\<cdot>xs) = filter\\<cdot>(\\<Lambda> x. Q\\<cdot>x andalso P\\<cdot>x)\\<cdot>xs\"", "lemma filter_const_TT [simp]:\n  \"filter\\<cdot>(\\<Lambda> _. TT)\\<cdot>xs = xs\"", "lemma tails_strict [simp]:\n  \"tails\\<cdot>\\<bottom> = \\<bottom>\"", "lemma inits_strict [simp]:\n  \"inits\\<cdot>\\<bottom> = \\<bottom>\"", "lemma the_and_strict [simp]:\n  \"the_and\\<cdot>\\<bottom> = \\<bottom>\"", "lemma the_or_strict [simp]:\n  \"the_or\\<cdot>\\<bottom> = \\<bottom>\"", "lemma all_strict [simp]:\n  \"all\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>\"", "lemma any_strict [simp]:\n  \"any\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>\"", "lemma tails_neq_Nil [simp]:\n  \"tails\\<cdot>xs \\<noteq> []\"", "lemma inits_neq_Nil [simp]:\n  \"inits\\<cdot>xs \\<noteq> []\"", "lemma Nil_neq_tails [simp]:\n  \"[] \\<noteq> tails\\<cdot>xs\"", "lemma Nil_neq_inits [simp]:\n  \"[] \\<noteq> inits\\<cdot>xs\"", "lemma finite_list_not_bottom [simp]:\n  assumes \"finite_list xs\" shows \"xs \\<noteq> \\<bottom>\"", "lemma head_append [simp]:\n  \"head\\<cdot>(xs ++ ys) = If null\\<cdot>xs then head\\<cdot>ys else head\\<cdot>xs\"", "lemma filter_cong:\n  \"\\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow> filter\\<cdot>p\\<cdot>xs = filter\\<cdot>q\\<cdot>xs\"", "lemma filter_TT [simp]:\n  assumes \"\\<forall>x\\<in>set xs. P\\<cdot>x = TT\"\n  shows \"filter\\<cdot>P\\<cdot>xs = xs\"", "lemma filter_FF [simp]:\n  assumes \"finite_list xs\"\n    and \"\\<forall>x\\<in>set xs. P\\<cdot>x = FF\"\n  shows \"filter\\<cdot>P\\<cdot>xs = []\"", "lemma map_cong:\n  \"\\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow> map\\<cdot>p\\<cdot>xs = map\\<cdot>q\\<cdot>xs\"", "lemma finite_list_upto:\n  \"finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\" (is \"?P m n\")", "lemma filter_commute:\n  assumes \"\\<forall>x\\<in>set xs. (Q\\<cdot>x andalso P\\<cdot>x) = (P\\<cdot>x andalso Q\\<cdot>x)\"\n  shows \"filter\\<cdot>P\\<cdot>(filter\\<cdot>Q\\<cdot>xs) = filter\\<cdot>Q\\<cdot>(filter\\<cdot>P\\<cdot>xs)\"", "lemma upto_append_intsFrom [simp]:\n  assumes \"m \\<le> n\"\n  shows \"upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++ intsFrom\\<cdot>(MkI\\<cdot>n+1) = intsFrom\\<cdot>(MkI\\<cdot>m)\"\n    (is \"?u m n ++ _ = ?i m\")", "lemma set_upto [simp]:\n  \"set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) = {MkI\\<cdot>i | i. m \\<le> i \\<and> i \\<le> n}\"\n  (is \"set (?u m n) = ?R m n\")", "lemma Nil_append_iff [iff]:\n  \"xs ++ ys = [] \\<longleftrightarrow> xs = [] \\<and> ys = []\"", "lemma bottom_neq_Nil [simp]: \"\\<bottom> \\<noteq> []\"", "lemma set_append [simp]:\n  assumes \"finite_list xs\"\n  shows \"set (xs ++ ys) = set xs \\<union> set ys\"", "lemma distinct_Cons [simp]:\n  \"distinct (x : xs) \\<longleftrightarrow> distinct xs \\<and> x \\<notin> set xs\"\n  (is \"?l = ?r\")", "lemma finite_list_append [iff]:\n  \"finite_list (xs ++ ys) \\<longleftrightarrow> finite_list xs \\<and> finite_list ys\"\n  (is \"?l = ?r\")", "lemma distinct_append [simp]:\n  assumes \"finite_list (xs ++ ys)\"\n  shows \"distinct (xs ++ ys) \\<longleftrightarrow> distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {}\"\n    (is \"?P xs ys\")", "lemma finite_set [simp]:\n  assumes \"distinct xs\"\n  shows \"finite (set xs)\"", "lemma distinct_card:\n  assumes \"distinct xs\"\n  shows \"MkI\\<cdot>(int (card (set xs))) = length\\<cdot>xs\"", "lemma set_delete [simp]:\n  fixes xs :: \"['a::Eq_eq]\"\n  assumes \"distinct xs\"\n    and \"\\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"set (delete\\<cdot>a\\<cdot>xs) = set xs - {a}\"", "lemma distinct_delete [simp]:\n  fixes xs :: \"['a::Eq_eq]\"\n  assumes \"distinct xs\"\n    and \"\\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"distinct (delete\\<cdot>a\\<cdot>xs)\"", "lemma set_diff [simp]:\n  fixes xs ys :: \"['a::Eq_eq]\"\n  assumes \"distinct ys\" and \"distinct xs\"\n    and \"\\<forall>a\\<in>set ys. \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"set (xs \\\\\\\\ ys) = set xs - set ys\"", "lemma distinct_delete_filter:\n  fixes xs :: \"['a::Eq_eq]\"\n  assumes \"distinct xs\"\n    and \"\\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"delete\\<cdot>a\\<cdot>xs = filter\\<cdot>(\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>xs\"", "lemma distinct_diff_filter:\n  fixes xs ys :: \"['a::Eq_eq]\"\n  assumes \"finite_list ys\"\n    and \"distinct xs\"\n    and \"\\<forall>a\\<in>set ys. \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"xs \\\\\\\\ ys = filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>xs\"", "lemma distinct_upto [intro, simp]:\n  \"distinct [MkI\\<cdot>m..MkI\\<cdot>n]\"", "lemma set_intsFrom [simp]:\n  \"set (intsFrom\\<cdot>(MkI\\<cdot>m)) = {MkI\\<cdot>n | n. m \\<le> n}\"\n  (is \"set (?i m) = ?I\")", "lemma If_eq_bottom_iff [simp]: (* FIXME: move *)\n  \"(If b then x else y = \\<bottom>) \\<longleftrightarrow> b = \\<bottom> \\<or> b = TT \\<and> x = \\<bottom> \\<or> b = FF \\<and> y = \\<bottom>\"", "lemma upto_eq_bottom_iff [simp]:\n  \"upto\\<cdot>m\\<cdot>n = \\<bottom> \\<longleftrightarrow> m = \\<bottom> \\<or> n = \\<bottom>\"", "lemma seq_eq_bottom_iff [simp]: (* FIXME: move *)\n  \"seq\\<cdot>x\\<cdot>y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\"", "lemma intsFrom_eq_bottom_iff [simp]:\n  \"intsFrom\\<cdot>m = \\<bottom> \\<longleftrightarrow> m = \\<bottom>\"", "lemma intsFrom_split:\n  assumes \"m \\<ge> n\"\n  shows \"[MkI\\<cdot>n..] = [MkI\\<cdot>n .. MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]\"", "lemma filter_fast_forward:\n  assumes \"n+1 \\<le> n'\"\n    and  \"\\<forall>k . n < k \\<longrightarrow> k < n' \\<longrightarrow> \\<not> P k\"\n  shows \"filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i) . Def (P i))\\<cdot>[MkI\\<cdot>(n+1)..] = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i) . Def (P i))\\<cdot>[MkI\\<cdot>n'..]\"", "lemma null_eq_TT_iff [simp]:\n  \"null\\<cdot>xs = TT \\<longleftrightarrow> xs = []\"", "lemma null_set_empty_conv:\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> null\\<cdot>xs = TT \\<longleftrightarrow> set xs = {}\"", "lemma elem_TT [simp]:\n  fixes x :: \"'a::Eq_eq\" shows \"elem\\<cdot>x\\<cdot>xs = TT \\<Longrightarrow> x \\<in> set xs\"", "lemma elem_FF [simp]:\n  fixes x :: \"'a::Eq_equiv\" shows \"elem\\<cdot>x\\<cdot>xs = FF \\<Longrightarrow> x \\<notin> set xs\"", "lemma length_strict [simp]:\n  \"length\\<cdot>\\<bottom> = \\<bottom>\"", "lemma repeat_neq_bottom [simp]:\n  \"repeat\\<cdot>x \\<noteq> \\<bottom>\"", "lemma list_case_repeat [simp]:\n  \"list_case\\<cdot>a\\<cdot>f\\<cdot>(repeat\\<cdot>x) = f\\<cdot>x\\<cdot>(repeat\\<cdot>x)\"", "lemma length_append [simp]:\n  \"length\\<cdot>(xs ++ ys) = length\\<cdot>xs + length\\<cdot>ys\"", "lemma replicate_strict [simp]:\n  \"replicate\\<cdot>\\<bottom>\\<cdot>x = \\<bottom>\"", "lemma replicate_0 [simp]:\n  \"replicate\\<cdot>0\\<cdot>x = []\"\n  \"replicate\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = []\"", "lemma Integer_add_0 [simp]: \"MkI\\<cdot>0 + n = n\"", "lemma replicate_MkI_plus_1 [simp]:\n  \"0 \\<le> n \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>(n+1))\\<cdot>x = x : replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x\"\n  \"0 \\<le> n \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>(1+n))\\<cdot>x = x : replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x\"", "lemma replicate_append_plus_conv:\n  assumes \"0 \\<le> m\" and \"0 \\<le> n\"\n  shows \"replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++ replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x\n    = replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\"", "lemma replicate_MkI_1 [simp]:\n  \"replicate\\<cdot>(MkI\\<cdot>1)\\<cdot>x = x : []\"", "lemma length_replicate [simp]:\n  assumes \"0 \\<le> n\"\n  shows \"length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n\"", "lemma map_oo [simp]:\n  \"map\\<cdot>f\\<cdot>(map\\<cdot>g\\<cdot>xs) = map\\<cdot>(f oo g)\\<cdot>xs\"", "lemma nth_Cons_MkI [simp]:\n  \"0 < i \\<Longrightarrow> (a : xs) !! (MkI\\<cdot>i) = xs !! (MkI\\<cdot>(i - 1))\"", "lemma map_plus_intsFrom:\n  \"map\\<cdot>(+ MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m)) = intsFrom\\<cdot>(MkI\\<cdot>(m+n))\" (is \"?l = ?r\")", "lemma plus_eq_MkI_conv:\n  \"l + n = MkI\\<cdot>m \\<longleftrightarrow> (\\<exists>l' n'. l = MkI\\<cdot>l' \\<and> n = MkI\\<cdot>n' \\<and> m = l' + n')\"", "lemma length_ge_0:\n  \"length\\<cdot>xs = MkI\\<cdot>n \\<Longrightarrow> n \\<ge> 0\"", "lemma length_0_conv [simp]:\n  \"length\\<cdot>xs = MkI\\<cdot>0 \\<longleftrightarrow> xs = []\"", "lemma length_ge_1 [simp]:\n  \"length\\<cdot>xs = MkI\\<cdot>(1 + int n)\n    \\<longleftrightarrow> (\\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n))\"\n  (is \"?l = ?r\")", "lemma finite_list_length_conv:\n  \"finite_list xs \\<longleftrightarrow> (\\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n))\" (is \"?l = ?r\")", "lemma nth_append:\n  assumes \"length\\<cdot>xs = MkI\\<cdot>n\" and \"n \\<le> m\"\n  shows \"(xs ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\"", "lemma replicate_nth [simp]:\n  assumes \"0 \\<le> n\"\n  shows \"(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x ++ xs) !! MkI\\<cdot>n = xs !! MkI\\<cdot>0\"", "lemma map2_zip:\n  \"map\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>(zip\\<cdot>xs\\<cdot>ys) = zip\\<cdot>xs\\<cdot>(map\\<cdot>f\\<cdot>ys)\"", "lemma map2_filter:\n  \"map\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>(filter\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>xs)\n    = filter\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>(map\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>xs)\"", "lemma map_map_snd:\n  \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> map\\<cdot>f\\<cdot>(map\\<cdot>snd\\<cdot>xs)\n    = map\\<cdot>snd\\<cdot>(map\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>xs)\"", "lemma findIndices_Cons [simp]:\n  \"findIndices\\<cdot>P\\<cdot>(a : xs) =\n    If P\\<cdot>a then 0 : map\\<cdot>(+1)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)\n    else map\\<cdot>(+1)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)\"", "lemma filter_alt_def:\n  fixes xs :: \"['a]\"\n  shows \"filter\\<cdot>P\\<cdot>xs = map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)\"", "lemma set_map:\n  \"set (map\\<cdot>f\\<cdot>xs) = f `\\<cdot> set xs\" (is \"?l = ?r\")", "lemma reverse_Nil [simp]:\n  \"reverse\\<cdot>[] = []\"", "lemma reverse_singleton [simp]:\n  \"reverse\\<cdot>[x] = [x]\"", "lemma reverse_strict [simp]:\n  \"reverse\\<cdot>\\<bottom> = \\<bottom>\"", "lemma foldl_flip_Cons_append:\n  \"foldl\\<cdot>(flip\\<cdot>(:))\\<cdot>ys\\<cdot>xs = foldl\\<cdot>(flip\\<cdot>(:))\\<cdot>[]\\<cdot>xs ++ ys\"", "lemma reverse_Cons [simp]:\n  \"reverse\\<cdot>(x:xs) = reverse\\<cdot>xs ++ [x]\"", "lemma reverse_append_below:\n  \"reverse\\<cdot>(xs ++ ys) \\<sqsubseteq> reverse\\<cdot>ys ++ reverse\\<cdot>xs\"", "lemma reverse_reverse_below:\n  \"reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs\"", "lemma reverse_append [simp]:\n  assumes \"finite_list xs\"\n  shows \"reverse\\<cdot>(xs ++ ys) = reverse\\<cdot>ys ++ reverse\\<cdot>xs\"", "lemma reverse_spine_strict:\n  \"\\<not> finite_list xs \\<Longrightarrow> reverse\\<cdot>xs = \\<bottom>\"", "lemma reverse_finite [simp]:\n  assumes \"finite_list xs\" shows \"finite_list (reverse\\<cdot>xs)\"", "lemma reverse_reverse [simp]:\n  assumes \"finite_list xs\" shows \"reverse\\<cdot>(reverse\\<cdot>xs) = xs\"", "lemma reverse_induct [consumes 1, case_names Nil snoc]:\n  \"\\<lbrakk>finite_list xs; P []; \\<And>x xs . finite_list xs \\<Longrightarrow> P xs \\<Longrightarrow> P (xs ++ [x])\\<rbrakk> \\<Longrightarrow> P xs\"", "lemma length_plus_not_0:\n  \"le\\<cdot>1\\<cdot>n = TT \\<Longrightarrow> le\\<cdot>(length\\<cdot>xs + n)\\<cdot>0 = TT \\<Longrightarrow> False\"", "lemma take_length_plus_1:\n  \"length\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow> take\\<cdot>(length\\<cdot>xs + 1)\\<cdot>(y:ys) = y : take\\<cdot>(length\\<cdot>xs)\\<cdot>ys\"", "lemma le_length_plus:\n  \"length\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow> n \\<noteq> \\<bottom> \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>xs + n) = TT\"", "lemma eq_take_length_isPrefixOf:\n  \"eq\\<cdot>xs\\<cdot>(take\\<cdot>(length\\<cdot>xs)\\<cdot>ys) \\<sqsubseteq> isPrefixOf\\<cdot>xs\\<cdot>ys\""], "translations": [["", "lemma finite_list_upwards:\n  assumes \"finite_list xs\" and \"xs \\<sqsubseteq> ys\"\n  shows \"finite_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_list ys", "using assms"], ["proof (prove)\nusing this:\n  finite_list xs\n  xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. finite_list ys", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. [] \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys\n 2. \\<And>x xs ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>ys. xs \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys;\n        x : xs \\<sqsubseteq> ys\\<rbrakk>\n       \\<Longrightarrow> finite_list ys", "case Nil"], ["proof (state)\nthis:\n  [] \\<sqsubseteq> ys\n\ngoal (2 subgoals):\n 1. \\<And>ys. [] \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys\n 2. \\<And>x xs ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>ys. xs \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys;\n        x : xs \\<sqsubseteq> ys\\<rbrakk>\n       \\<Longrightarrow> finite_list ys", "then"], ["proof (chain)\npicking this:\n  [] \\<sqsubseteq> ys", "have \"ys = []\""], ["proof (prove)\nusing this:\n  [] \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. ys = []", "by (cases ys) simp+"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<And>ys. [] \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys\n 2. \\<And>x xs ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>ys. xs \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys;\n        x : xs \\<sqsubseteq> ys\\<rbrakk>\n       \\<Longrightarrow> finite_list ys", "then"], ["proof (chain)\npicking this:\n  ys = []", "show ?case"], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. finite_list ys", "by auto"], ["proof (state)\nthis:\n  finite_list ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>ys. xs \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys;\n        x : xs \\<sqsubseteq> ys\\<rbrakk>\n       \\<Longrightarrow> finite_list ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>ys. xs \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys;\n        x : xs \\<sqsubseteq> ys\\<rbrakk>\n       \\<Longrightarrow> finite_list ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  finite_list xs\n  xs \\<sqsubseteq> ?ys \\<Longrightarrow> finite_list ?ys\n  x : xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>ys. xs \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys;\n        x : xs \\<sqsubseteq> ys\\<rbrakk>\n       \\<Longrightarrow> finite_list ys", "from \\<open>x : xs \\<sqsubseteq> ys\\<close>"], ["proof (chain)\npicking this:\n  x : xs \\<sqsubseteq> ys", "obtain y ys' where \"ys = y : ys'\""], ["proof (prove)\nusing this:\n  x : xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'. ys = y : ys' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ys) auto"], ["proof (state)\nthis:\n  ys = y : ys'\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>ys. xs \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys;\n        x : xs \\<sqsubseteq> ys\\<rbrakk>\n       \\<Longrightarrow> finite_list ys", "with \\<open>x : xs \\<sqsubseteq> ys\\<close>"], ["proof (chain)\npicking this:\n  x : xs \\<sqsubseteq> ys\n  ys = y : ys'", "have \"xs \\<sqsubseteq> ys'\""], ["proof (prove)\nusing this:\n  x : xs \\<sqsubseteq> ys\n  ys = y : ys'\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys'", "by auto"], ["proof (state)\nthis:\n  xs \\<sqsubseteq> ys'\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>ys. xs \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys;\n        x : xs \\<sqsubseteq> ys\\<rbrakk>\n       \\<Longrightarrow> finite_list ys", "then"], ["proof (chain)\npicking this:\n  xs \\<sqsubseteq> ys'", "have \"finite_list ys'\""], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> ys'\n\ngoal (1 subgoal):\n 1. finite_list ys'", "by (rule Cons.hyps)"], ["proof (state)\nthis:\n  finite_list ys'\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>ys. xs \\<sqsubseteq> ys \\<Longrightarrow> finite_list ys;\n        x : xs \\<sqsubseteq> ys\\<rbrakk>\n       \\<Longrightarrow> finite_list ys", "with \\<open>ys = _\\<close>"], ["proof (chain)\npicking this:\n  ys = y : ys'\n  finite_list ys'", "show ?case"], ["proof (prove)\nusing this:\n  ys = y : ys'\n  finite_list ys'\n\ngoal (1 subgoal):\n 1. finite_list ys", "by auto"], ["proof (state)\nthis:\n  finite_list ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adm_finite_list [simp]: \"adm finite_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm finite_list", "by (metis finite_list_upwards adm_upward)"], ["", "lemma bot_not_finite_list [simp]:\n  \"finite_list \\<bottom> = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_list \\<bottom> = False", "by (rule, cases rule: finite_list.cases) auto"], ["", "inductive listmem :: \"'a \\<Rightarrow> ['a] \\<Rightarrow> bool\" where\n  \"listmem x (x : xs)\" |\n  \"listmem x xs \\<Longrightarrow> listmem x (y : xs)\""], ["", "lemma listmem_simps [simp]:\n  shows \"\\<not> listmem x \\<bottom>\" and \"\\<not> listmem x []\"\n  and \"listmem x (y : ys) \\<longleftrightarrow> x = y \\<or> listmem x ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> listmem x \\<bottom> &&&\n    \\<not> listmem x [] &&& listmem x (y : ys) = (x = y \\<or> listmem x ys)", "by (auto elim: listmem.cases intro: listmem.intros)"], ["", "definition set :: \"['a] \\<Rightarrow> 'a set\" where\n  \"set xs = {x. listmem x xs}\""], ["", "lemma set_simps [simp]:\n  shows \"set \\<bottom> = {}\" and \"set [] = {}\"\n  and \"set (x : xs) = insert x (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<bottom> = {} &&& set [] = {} &&& set (x : xs) = insert x (set xs)", "unfolding set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. listmem x \\<bottom>} = {} &&&\n    {x. listmem x []} = {} &&&\n    {xa. listmem xa (x : xs)} = insert x {x. listmem x xs}", "by auto"], ["", "inductive distinct :: \"['a] \\<Rightarrow> bool\" where\n  Nil [intro!, simp]: \"distinct []\" |\n  Cons [intro!, simp]: \"\\<And>x xs. distinct xs \\<Longrightarrow> x \\<notin> set xs \\<Longrightarrow> distinct (x : xs)\""], ["", "subsection \\<open>Properties\\<close>"], ["", "lemma map_strict [simp]:\n  \"map\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>", "by (fixrec_simp)"], ["", "lemma map_ID [simp]:\n  \"map\\<cdot>ID\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>ID\\<cdot>xs = xs", "by (induct xs) simp_all"], ["", "lemma enumFrom_intsFrom_conv [simp]:\n  \"enumFrom = intsFrom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enumFrom = intsFrom", "by (intro cfun_eqI) (simp add: enumFrom_def)"], ["", "lemma enumFromTo_upto_conv [simp]:\n  \"enumFromTo = upto\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enumFromTo = upto", "by (intro cfun_eqI) (simp add: enumFromTo_def)"], ["", "lemma zipWith_strict [simp]:\n  \"zipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\"\n  \"zipWith\\<cdot>f\\<cdot>(x : xs)\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom> &&&\n    zipWith\\<cdot>f\\<cdot>(x : xs)\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp+"], ["", "lemma zip_simps [simp]:\n  \"zip\\<cdot>(x : xs)\\<cdot>(y : ys) = \\<langle>x, y\\<rangle> : zip\\<cdot>xs\\<cdot>ys\"\n  \"zip\\<cdot>(x : xs)\\<cdot>[] = []\"\n  \"zip\\<cdot>(x : xs)\\<cdot>\\<bottom> = \\<bottom>\"\n  \"zip\\<cdot>[]\\<cdot>ys = []\"\n  \"zip\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zip\\<cdot>(x : xs)\\<cdot>(y : ys) =\n     \\<langle>x, y\\<rangle> : zip\\<cdot>xs\\<cdot>ys &&&\n     zip\\<cdot>(x : xs)\\<cdot>[] = []) &&&\n    zip\\<cdot>(x : xs)\\<cdot>\\<bottom> = \\<bottom> &&&\n    zip\\<cdot>[]\\<cdot>ys = [] &&& zip\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>", "unfolding zip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (zipWith\\<cdot>\\<langle>,\\<rangle>\\<cdot>(x : xs)\\<cdot>(y : ys) =\n     \\<langle>x, y\\<rangle> :\n     zipWith\\<cdot>\\<langle>,\\<rangle>\\<cdot>xs\\<cdot>ys &&&\n     zipWith\\<cdot>\\<langle>,\\<rangle>\\<cdot>(x : xs)\\<cdot>[] = []) &&&\n    zipWith\\<cdot>\\<langle>,\\<rangle>\\<cdot>(x : xs)\\<cdot>\\<bottom> =\n    \\<bottom> &&&\n    zipWith\\<cdot>\\<langle>,\\<rangle>\\<cdot>[]\\<cdot>ys = [] &&&\n    zipWith\\<cdot>\\<langle>,\\<rangle>\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>", "by simp_all"], ["", "lemma zip_Nil2 [simp]:\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> zip\\<cdot>xs\\<cdot>[] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> \\<bottom> \\<Longrightarrow> zip\\<cdot>xs\\<cdot>[] = []", "by (cases xs) simp_all"], ["", "lemma nth_strict [simp]:\n  \"nth\\<cdot>\\<bottom>\\<cdot>n = \\<bottom>\"\n  \"nth\\<cdot>xs\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> !! n = \\<bottom> &&& xs !! \\<bottom> = \\<bottom>", "by (fixrec_simp) (cases xs, fixrec_simp+)"], ["", "lemma upto_strict [simp]:\n  \"upto\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>\"\n  \"upto\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upto\\<cdot>\\<bottom>\\<cdot>y = \\<bottom> &&&\n    upto\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp+"], ["", "lemma upto_simps [simp]:\n  \"n < m \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) = []\"\n  \"m \\<le> n \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) = MkI\\<cdot>m : [MkI\\<cdot>m+1..MkI\\<cdot>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n < m \\<Longrightarrow>\n     upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) = []) &&&\n    (m \\<le> n \\<Longrightarrow>\n     upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) =\n     MkI\\<cdot>m : [MkI\\<cdot>m + 1..MkI\\<cdot>n])", "by (subst upto.simps, simp)+"], ["", "lemma filter_strict [simp]:\n  \"filter\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>", "by (fixrec_simp)"], ["", "lemma nth_Cons_simp [simp]:\n  \"eq\\<cdot>n\\<cdot>0 = TT \\<Longrightarrow> nth\\<cdot>(x : xs)\\<cdot>n = x\"\n  \"eq\\<cdot>n\\<cdot>0 = FF \\<Longrightarrow> nth\\<cdot>(x : xs)\\<cdot>n = nth\\<cdot>xs\\<cdot>(n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq\\<cdot>n\\<cdot>0 = TT \\<Longrightarrow> (x : xs) !! n = x) &&&\n    (eq\\<cdot>n\\<cdot>0 = FF \\<Longrightarrow>\n     (x : xs) !! n = xs !! (n - 1))", "by (subst nth.simps, simp)+"], ["", "lemma nth_Cons_split:\n   \"P (nth\\<cdot>(x : xs)\\<cdot>n) = ((eq\\<cdot>n\\<cdot>0 = FF \\<longrightarrow> P (nth\\<cdot>(x : xs)\\<cdot>n)) \\<and>\n                              (eq\\<cdot>n\\<cdot>0 = TT \\<longrightarrow> P (nth\\<cdot>(x : xs)\\<cdot>n)) \\<and>\n                              (n = \\<bottom> \\<longrightarrow> P (nth\\<cdot>(x : xs)\\<cdot>n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ((x : xs) !! n) =\n    ((eq\\<cdot>n\\<cdot>0 = FF \\<longrightarrow> P ((x : xs) !! n)) \\<and>\n     (eq\\<cdot>n\\<cdot>0 = TT \\<longrightarrow> P ((x : xs) !! n)) \\<and>\n     (n = \\<bottom> \\<longrightarrow> P ((x : xs) !! n)))", "(*   \"!!x. P (test x) = (~ (\\<exists>a b. x = (a, b) & ~ P (test (a, b))))\" *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ((x : xs) !! n) =\n    ((eq\\<cdot>n\\<cdot>0 = FF \\<longrightarrow> P ((x : xs) !! n)) \\<and>\n     (eq\\<cdot>n\\<cdot>0 = TT \\<longrightarrow> P ((x : xs) !! n)) \\<and>\n     (n = \\<bottom> \\<longrightarrow> P ((x : xs) !! n)))", "apply (cases n, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>int.\n       n = MkI\\<cdot>int \\<Longrightarrow>\n       P ((x : xs) !! n) =\n       ((eq\\<cdot>n\\<cdot>0 = FF \\<longrightarrow> P ((x : xs) !! n)) \\<and>\n        (eq\\<cdot>n\\<cdot>0 = TT \\<longrightarrow> P ((x : xs) !! n)) \\<and>\n        (n = \\<bottom> \\<longrightarrow> P ((x : xs) !! n)))", "apply (cases \"n = 0\", simp_all add: zero_Integer_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nth_Cons_numeral [simp]:\n  \"(x : xs) !! 0 = x\"\n  \"(x : xs) !! 1 = xs !! 0\"\n  \"(x : xs) !! numeral (Num.Bit0 k) = xs !! numeral (Num.BitM k)\"\n  \"(x : xs) !! numeral (Num.Bit1 k) = xs !! numeral (Num.Bit0 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x : xs) !! 0 = x &&& (x : xs) !! 1 = xs !! 0) &&&\n    (x : xs) !! numeral (num.Bit0 k) = xs !! numeral (Num.BitM k) &&&\n    (x : xs) !! numeral (num.Bit1 k) = xs !! numeral (num.Bit0 k)", "by (simp_all add: nth_Cons numeral_Integer_eq\n    zero_Integer_def one_Integer_def)"], ["", "lemma take_strict [simp]:\n  \"take\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>", "by (fixrec_simp)"], ["", "lemma take_strict_2 [simp]:\n  \"le\\<cdot>1\\<cdot>i = TT \\<Longrightarrow> take\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>1\\<cdot>i = TT \\<Longrightarrow>\n    take\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>", "by (subst take.simps, cases \"le\\<cdot>i\\<cdot>0\") (auto dest: le_trans)"], ["", "lemma drop_strict [simp]:\n  \"drop\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.drop\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>", "by (fixrec_simp)"], ["", "lemma isPrefixOf_strict [simp]:\n  \"isPrefixOf\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\"\n  \"isPrefixOf\\<cdot>(x:xs)\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefixOf\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom> &&&\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>\\<bottom> = \\<bottom>", "by (fixrec_simp)+"], ["", "lemma last_strict[simp]:\n  \"last\\<cdot>\\<bottom>= \\<bottom>\"\n  \"last\\<cdot>(x:\\<bottom>) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last\\<cdot>\\<bottom> = \\<bottom> &&&\n    last\\<cdot>(x : \\<bottom>) = \\<bottom>", "by (fixrec_simp+)"], ["", "lemma last_nil [simp]:\n  \"last\\<cdot>[] = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last\\<cdot>[] = \\<bottom>", "by (fixrec_simp)"], ["", "lemma last_spine_strict: \"\\<not> finite_list xs \\<Longrightarrow> last\\<cdot>xs = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> finite_list xs \\<Longrightarrow> last\\<cdot>xs = \\<bottom>", "proof (induct xs)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<not> finite_list a \\<longrightarrow> last\\<cdot>a = \\<bottom>)\n 2. \\<not> finite_list \\<bottom> \\<Longrightarrow>\n    last\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<not> finite_list [] \\<Longrightarrow> last\\<cdot>[] = \\<bottom>\n 4. \\<And>a xs.\n       \\<lbrakk>\\<not> finite_list xs \\<Longrightarrow>\n                last\\<cdot>xs = \\<bottom>;\n        \\<not> finite_list (a : xs)\\<rbrakk>\n       \\<Longrightarrow> last\\<cdot>(a : xs) = \\<bottom>", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<not> finite_list xs \\<Longrightarrow> last\\<cdot>xs = \\<bottom>\n  \\<not> finite_list (a : xs)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<not> finite_list a \\<longrightarrow> last\\<cdot>a = \\<bottom>)\n 2. \\<not> finite_list \\<bottom> \\<Longrightarrow>\n    last\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<not> finite_list [] \\<Longrightarrow> last\\<cdot>[] = \\<bottom>\n 4. \\<And>a xs.\n       \\<lbrakk>\\<not> finite_list xs \\<Longrightarrow>\n                last\\<cdot>xs = \\<bottom>;\n        \\<not> finite_list (a : xs)\\<rbrakk>\n       \\<Longrightarrow> last\\<cdot>(a : xs) = \\<bottom>", "then"], ["proof (chain)\npicking this:\n  \\<not> finite_list xs \\<Longrightarrow> last\\<cdot>xs = \\<bottom>\n  \\<not> finite_list (a : xs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> finite_list xs \\<Longrightarrow> last\\<cdot>xs = \\<bottom>\n  \\<not> finite_list (a : xs)\n\ngoal (1 subgoal):\n 1. last\\<cdot>(a : xs) = \\<bottom>", "by (cases xs) auto"], ["proof (state)\nthis:\n  last\\<cdot>(a : xs) = \\<bottom>\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<not> finite_list a \\<longrightarrow> last\\<cdot>a = \\<bottom>)\n 2. \\<not> finite_list \\<bottom> \\<Longrightarrow>\n    last\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<not> finite_list [] \\<Longrightarrow> last\\<cdot>[] = \\<bottom>", "qed auto"], ["", "lemma init_strict [simp]:\n  \"init\\<cdot>\\<bottom>= \\<bottom>\"\n  \"init\\<cdot>(x:\\<bottom>) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init\\<cdot>\\<bottom> = \\<bottom> &&&\n    init\\<cdot>(x : \\<bottom>) = \\<bottom>", "by (fixrec_simp+)"], ["", "lemma init_nil [simp]:\n  \"init\\<cdot>[] = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init\\<cdot>[] = \\<bottom>", "by (fixrec_simp)"], ["", "lemma strict_foldr_strict2 [simp]:\n  \"(\\<And>x. f\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>) \\<Longrightarrow> foldr\\<cdot>f\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>) \\<Longrightarrow>\n    foldr\\<cdot>f\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>", "by (induct xs, auto) fixrec_simp"], ["", "lemma foldr_strict [simp]:\n  \"foldr\\<cdot>f\\<cdot>d\\<cdot>\\<bottom> = \\<bottom>\"\n  \"foldr\\<cdot>f\\<cdot>\\<bottom>\\<cdot>[] = \\<bottom>\"\n  \"foldr\\<cdot>\\<bottom>\\<cdot>d\\<cdot>(x : xs) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>f\\<cdot>d\\<cdot>\\<bottom> = \\<bottom> &&&\n    foldr\\<cdot>f\\<cdot>\\<bottom>\\<cdot>[] = \\<bottom> &&&\n    foldr\\<cdot>\\<bottom>\\<cdot>d\\<cdot>(x : xs) = \\<bottom>", "by fixrec_simp+"], ["", "lemma foldr_Cons_Nil [simp]:\n  \"foldr\\<cdot>(:)\\<cdot>[]\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>Cons\\<cdot>[]\\<cdot>xs = xs", "by (induct xs) simp+"], ["", "lemma append_strict1 [simp]:\n  \"\\<bottom> ++ ys = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> ++ ys = \\<bottom>", "by fixrec_simp"], ["", "lemma foldr_append [simp]:\n  \"foldr\\<cdot>f\\<cdot>a\\<cdot>(xs ++ ys) = foldr\\<cdot>f\\<cdot>(foldr\\<cdot>f\\<cdot>a\\<cdot>ys)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>f\\<cdot>a\\<cdot>(xs ++ ys) =\n    foldr\\<cdot>f\\<cdot>(foldr\\<cdot>f\\<cdot>a\\<cdot>ys)\\<cdot>xs", "by (induct xs) simp+"], ["", "lemma foldl_strict [simp]:\n  \"foldl\\<cdot>f\\<cdot>d\\<cdot>\\<bottom> = \\<bottom>\"\n  \"foldl\\<cdot>f\\<cdot>\\<bottom>\\<cdot>[] = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>f\\<cdot>d\\<cdot>\\<bottom> = \\<bottom> &&&\n    foldl\\<cdot>f\\<cdot>\\<bottom>\\<cdot>[] = \\<bottom>", "by fixrec_simp+"], ["", "lemma foldr1_strict [simp]:\n  \"foldr1\\<cdot>f\\<cdot>\\<bottom>= \\<bottom>\"\n  \"foldr1\\<cdot>f\\<cdot>(x:\\<bottom>)= \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr1\\<cdot>f\\<cdot>\\<bottom> = \\<bottom> &&&\n    foldr1\\<cdot>f\\<cdot>(x : \\<bottom>) = \\<bottom>", "by fixrec_simp+"], ["", "lemma foldl1_strict [simp]:\n  \"foldl1\\<cdot>f\\<cdot>\\<bottom>= \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma foldl_spine_strict:\n  \"\\<not> finite_list xs \\<Longrightarrow> foldl\\<cdot>f\\<cdot>x\\<cdot>xs = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> finite_list xs \\<Longrightarrow>\n    foldl\\<cdot>f\\<cdot>x\\<cdot>xs = \\<bottom>", "by (induct xs arbitrary: x) auto"], ["", "lemma foldl_assoc_foldr:\n  assumes \"finite_list xs\"\n    and assoc: \"\\<And>x y z. f\\<cdot>(f\\<cdot>x\\<cdot>y)\\<cdot>z = f\\<cdot>x\\<cdot>(f\\<cdot>y\\<cdot>z)\"\n    and neutr1: \"\\<And>x. f\\<cdot>z\\<cdot>x = x\"\n    and neutr2: \"\\<And>x. f\\<cdot>x\\<cdot>z = x\"\n  shows \"foldl\\<cdot>f\\<cdot>z\\<cdot>xs = foldr\\<cdot>f\\<cdot>z\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>xs = foldr\\<cdot>f\\<cdot>z\\<cdot>xs", "using \\<open>finite_list xs\\<close>"], ["proof (prove)\nusing this:\n  finite_list xs\n\ngoal (1 subgoal):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>xs = foldr\\<cdot>f\\<cdot>z\\<cdot>xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = foldr\\<cdot>f\\<cdot>z\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>finite_list xs;\n        foldl\\<cdot>f\\<cdot>z\\<cdot>xs =\n        foldr\\<cdot>f\\<cdot>z\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n                         foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  finite_list xs\n  foldl\\<cdot>f\\<cdot>z\\<cdot>xs = foldr\\<cdot>f\\<cdot>z\\<cdot>xs\n\ngoal (2 subgoals):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = foldr\\<cdot>f\\<cdot>z\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>finite_list xs;\n        foldl\\<cdot>f\\<cdot>z\\<cdot>xs =\n        foldr\\<cdot>f\\<cdot>z\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n                         foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "from \\<open>finite_list xs\\<close>"], ["proof (chain)\npicking this:\n  finite_list xs", "have step: \"\\<And>y. f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) = foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\""], ["proof (prove)\nusing this:\n  finite_list xs\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "case (Cons x xs y)"], ["proof (state)\nthis:\n  finite_list xs\n  f\\<cdot>?y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>?y)\\<cdot>xs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "have \"f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) = f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n    f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs)", "by auto"], ["proof (state)\nthis:\n  f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n  f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "also"], ["proof (state)\nthis:\n  f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n  f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "have \"... = f\\<cdot>y\\<cdot>(f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs) =\n    f\\<cdot>y\\<cdot>(f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs))", "by (simp only: Cons.hyps)"], ["proof (state)\nthis:\n  f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs) =\n  f\\<cdot>y\\<cdot>(f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs))\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "also"], ["proof (state)\nthis:\n  f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs) =\n  f\\<cdot>y\\<cdot>(f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs))\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "have \"... = f\\<cdot>(f\\<cdot>y\\<cdot>x)\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>y\\<cdot>(f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs)) =\n    f\\<cdot>(f\\<cdot>y\\<cdot>x)\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs)", "by (simp only: assoc)"], ["proof (state)\nthis:\n  f\\<cdot>y\\<cdot>(f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs)) =\n  f\\<cdot>(f\\<cdot>y\\<cdot>x)\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "also"], ["proof (state)\nthis:\n  f\\<cdot>y\\<cdot>(f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs)) =\n  f\\<cdot>(f\\<cdot>y\\<cdot>x)\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "have \"... = foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>(f\\<cdot>y\\<cdot>x))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>(f\\<cdot>y\\<cdot>x)\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n    foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>(f\\<cdot>y\\<cdot>x))\\<cdot>xs", "by (simp only: Cons.hyps)"], ["proof (state)\nthis:\n  f\\<cdot>(f\\<cdot>y\\<cdot>x)\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>(f\\<cdot>y\\<cdot>x))\\<cdot>xs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "also"], ["proof (state)\nthis:\n  f\\<cdot>(f\\<cdot>y\\<cdot>x)\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>(f\\<cdot>y\\<cdot>x))\\<cdot>xs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "have \"... = foldl\\<cdot>f\\<cdot>(f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>x)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>(f\\<cdot>y\\<cdot>x))\\<cdot>xs =\n    foldl\\<cdot>f\\<cdot>(f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>x)\\<cdot>xs", "by (simp only: assoc)"], ["proof (state)\nthis:\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>(f\\<cdot>y\\<cdot>x))\\<cdot>xs =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>x)\\<cdot>xs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "also"], ["proof (state)\nthis:\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>(f\\<cdot>y\\<cdot>x))\\<cdot>xs =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>x)\\<cdot>xs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "have \"... = foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>(x : xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>f\\<cdot>(f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>x)\\<cdot>xs =\n    foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>(x : xs)", "by auto"], ["proof (state)\nthis:\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>x)\\<cdot>xs =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>(x : xs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]\n 2. \\<And>x xs y.\n       \\<lbrakk>finite_list xs;\n        \\<And>y.\n           f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n           foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>y\\<cdot>\n                         (foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n                         foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>\n                         (x : xs)", "finally"], ["proof (chain)\npicking this:\n  f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>(x : xs)", "show ?case"], ["proof (prove)\nusing this:\n  f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>(x : xs)\n\ngoal (1 subgoal):\n 1. f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n    foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>(x : xs)", "."], ["proof (state)\nthis:\n  f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs)) =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>(x : xs)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       f\\<cdot>y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>[]) =\n       foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>y)\\<cdot>[]", "qed (simp add: neutr1 neutr2)"], ["proof (state)\nthis:\n  f\\<cdot>?y\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>?y)\\<cdot>xs\n\ngoal (2 subgoals):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = foldr\\<cdot>f\\<cdot>z\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>finite_list xs;\n        foldl\\<cdot>f\\<cdot>z\\<cdot>xs =\n        foldr\\<cdot>f\\<cdot>z\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n                         foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "have \"foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) = foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n    foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs", "by auto"], ["proof (state)\nthis:\n  foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs\n\ngoal (2 subgoals):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = foldr\\<cdot>f\\<cdot>z\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>finite_list xs;\n        foldl\\<cdot>f\\<cdot>z\\<cdot>xs =\n        foldr\\<cdot>f\\<cdot>z\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n                         foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "also"], ["proof (state)\nthis:\n  foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs\n\ngoal (2 subgoals):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = foldr\\<cdot>f\\<cdot>z\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>finite_list xs;\n        foldl\\<cdot>f\\<cdot>z\\<cdot>xs =\n        foldr\\<cdot>f\\<cdot>z\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n                         foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "have \"... = f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs =\n    f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs)", "by (simp only: step)"], ["proof (state)\nthis:\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs =\n  f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs)\n\ngoal (2 subgoals):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = foldr\\<cdot>f\\<cdot>z\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>finite_list xs;\n        foldl\\<cdot>f\\<cdot>z\\<cdot>xs =\n        foldr\\<cdot>f\\<cdot>z\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n                         foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "also"], ["proof (state)\nthis:\n  foldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs =\n  f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs)\n\ngoal (2 subgoals):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = foldr\\<cdot>f\\<cdot>z\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>finite_list xs;\n        foldl\\<cdot>f\\<cdot>z\\<cdot>xs =\n        foldr\\<cdot>f\\<cdot>z\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n                         foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "have \"... = f\\<cdot>x\\<cdot>(foldr\\<cdot>f\\<cdot>z\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n    f\\<cdot>x\\<cdot>(foldr\\<cdot>f\\<cdot>z\\<cdot>xs)", "by (simp only: Cons.hyps)"], ["proof (state)\nthis:\n  f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n  f\\<cdot>x\\<cdot>(foldr\\<cdot>f\\<cdot>z\\<cdot>xs)\n\ngoal (2 subgoals):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = foldr\\<cdot>f\\<cdot>z\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>finite_list xs;\n        foldl\\<cdot>f\\<cdot>z\\<cdot>xs =\n        foldr\\<cdot>f\\<cdot>z\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n                         foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "also"], ["proof (state)\nthis:\n  f\\<cdot>x\\<cdot>(foldl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n  f\\<cdot>x\\<cdot>(foldr\\<cdot>f\\<cdot>z\\<cdot>xs)\n\ngoal (2 subgoals):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = foldr\\<cdot>f\\<cdot>z\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>finite_list xs;\n        foldl\\<cdot>f\\<cdot>z\\<cdot>xs =\n        foldr\\<cdot>f\\<cdot>z\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n                         foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "have \"... = (foldr\\<cdot>f\\<cdot>z\\<cdot>(x:xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>x\\<cdot>(foldr\\<cdot>f\\<cdot>z\\<cdot>xs) =\n    foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "by auto"], ["proof (state)\nthis:\n  f\\<cdot>x\\<cdot>(foldr\\<cdot>f\\<cdot>z\\<cdot>xs) =\n  foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)\n\ngoal (2 subgoals):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = foldr\\<cdot>f\\<cdot>z\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>finite_list xs;\n        foldl\\<cdot>f\\<cdot>z\\<cdot>xs =\n        foldr\\<cdot>f\\<cdot>z\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n                         foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "finally"], ["proof (chain)\npicking this:\n  foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n  foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "show ?case"], ["proof (prove)\nusing this:\n  foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n  foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)\n\ngoal (1 subgoal):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n    foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)", "."], ["proof (state)\nthis:\n  foldl\\<cdot>f\\<cdot>z\\<cdot>(x : xs) =\n  foldr\\<cdot>f\\<cdot>z\\<cdot>(x : xs)\n\ngoal (1 subgoal):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = foldr\\<cdot>f\\<cdot>z\\<cdot>[]", "qed auto"], ["", "lemma elem_strict [simp]:\n  \"elem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma notElem_strict [simp]:\n  \"notElem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. notElem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma list_eq_nil[simp]:\n  \"eq\\<cdot>l\\<cdot>[] = TT \\<longleftrightarrow> l = []\"\n  \"eq\\<cdot>[]\\<cdot>l = TT \\<longleftrightarrow> l = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq\\<cdot>l\\<cdot>[] = TT) = (l = []) &&&\n    (eq\\<cdot>[]\\<cdot>l = TT) = (l = [])", "by (cases l, auto)+"], ["", "lemma take_Nil [simp]:\n  \"n \\<noteq> \\<bottom> \\<Longrightarrow> take\\<cdot>n\\<cdot>[] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> \\<bottom> \\<Longrightarrow> take\\<cdot>n\\<cdot>[] = []", "by (subst take.simps) (cases \"le\\<cdot>n\\<cdot>0\"; simp)"], ["", "lemma take_0 [simp]:\n  \"take\\<cdot>0\\<cdot>xs = []\"\n  \"take\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>0\\<cdot>xs = [] &&& take\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = []", "by (subst take.simps, simp add: zero_Integer_def)+"], ["", "lemma take_Cons [simp]:\n  \"le\\<cdot>1\\<cdot>i = TT \\<Longrightarrow> take\\<cdot>i\\<cdot>(x:xs) = x : take\\<cdot>(i - 1)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>1\\<cdot>i = TT \\<Longrightarrow>\n    take\\<cdot>i\\<cdot>(x : xs) = x : take\\<cdot>(i - 1)\\<cdot>xs", "by (subst take.simps, cases \"le\\<cdot>i\\<cdot>0\") (auto dest: le_trans)"], ["", "lemma take_MkI_Cons [simp]:\n  \"0 < n \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>(x : xs) = x : take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    take\\<cdot>(MkI\\<cdot>n)\\<cdot>(x : xs) =\n    x : take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>xs", "by (subst take.simps) (simp add: zero_Integer_def one_Integer_def)"], ["", "lemma take_numeral_Cons [simp]:\n  \"take\\<cdot>1\\<cdot>(x : xs) = [x]\"\n  \"take\\<cdot>(numeral (Num.Bit0 k))\\<cdot>(x : xs) = x : take\\<cdot>(numeral (Num.BitM k))\\<cdot>xs\"\n  \"take\\<cdot>(numeral (Num.Bit1 k))\\<cdot>(x : xs) = x : take\\<cdot>(numeral (Num.Bit0 k))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>1\\<cdot>(x : xs) = [x] &&&\n    take\\<cdot>(numeral (num.Bit0 k))\\<cdot>(x : xs) =\n    x : take\\<cdot>(numeral (Num.BitM k))\\<cdot>xs &&&\n    take\\<cdot>(numeral (num.Bit1 k))\\<cdot>(x : xs) =\n    x : take\\<cdot>(numeral (num.Bit0 k))\\<cdot>xs", "by (subst take.simps,\n      simp add: zero_Integer_def one_Integer_def numeral_Integer_eq)+"], ["", "lemma drop_0 [simp]:\n  \"drop\\<cdot>0\\<cdot>xs = xs\"\n  \"drop\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.drop\\<cdot>0\\<cdot>xs = xs &&&\n    Data_List.drop\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = xs", "by (subst drop.simps, simp add: zero_Integer_def)+"], ["", "lemma drop_pos [simp]:\n  \"le\\<cdot>n\\<cdot>0 = FF \\<Longrightarrow> drop\\<cdot>n\\<cdot>xs = (case xs of [] \\<Rightarrow> [] | y : ys \\<Rightarrow> drop\\<cdot>(n - 1)\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>n\\<cdot>0 = FF \\<Longrightarrow>\n    Data_List.drop\\<cdot>n\\<cdot>xs =\n    (case xs of [] \\<Rightarrow> []\n     | y : ys \\<Rightarrow> Data_List.drop\\<cdot>(n - 1)\\<cdot>ys)", "by (subst drop.simps, simp)"], ["", "lemma drop_numeral_Cons [simp]:\n  \"drop\\<cdot>1\\<cdot>(x : xs) = xs\"\n  \"drop\\<cdot>(numeral (Num.Bit0 k))\\<cdot>(x : xs) = drop\\<cdot>(numeral (Num.BitM k))\\<cdot>xs\"\n  \"drop\\<cdot>(numeral (Num.Bit1 k))\\<cdot>(x : xs) = drop\\<cdot>(numeral (Num.Bit0 k))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.drop\\<cdot>1\\<cdot>(x : xs) = xs &&&\n    Data_List.drop\\<cdot>(numeral (num.Bit0 k))\\<cdot>(x : xs) =\n    Data_List.drop\\<cdot>(numeral (Num.BitM k))\\<cdot>xs &&&\n    Data_List.drop\\<cdot>(numeral (num.Bit1 k))\\<cdot>(x : xs) =\n    Data_List.drop\\<cdot>(numeral (num.Bit0 k))\\<cdot>xs", "by (subst drop.simps,\n      simp add: zero_Integer_def one_Integer_def numeral_Integer_eq)+"], ["", "lemma take_drop_append:\n  \"take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++ drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n    Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n    xs", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       i = int n \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n       Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n       xs\n 2. \\<And>n.\n       i = - int (Suc n) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n       Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n       xs", "case (nonneg n)"], ["proof (state)\nthis:\n  i = int n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       i = int n \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n       Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n       xs\n 2. \\<And>n.\n       i = - int (Suc n) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n       Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n       xs", "then"], ["proof (chain)\npicking this:\n  i = int n", "show ?thesis"], ["proof (prove)\nusing this:\n  i = int n\n\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n    Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n    xs", "proof (induct n arbitrary : i xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i xs.\n       i = int 0 \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n       Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n       xs\n 2. \\<And>n i xs.\n       \\<lbrakk>\\<And>i xs.\n                   i = int n \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n                   Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n                   xs;\n        i = int (Suc n)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n                         Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n                         xs", "case (Suc n)"], ["proof (state)\nthis:\n  ?i = int n \\<Longrightarrow>\n  take\\<cdot>(MkI\\<cdot>?i)\\<cdot>?xs ++\n  Data_List.drop\\<cdot>(MkI\\<cdot>?i)\\<cdot>?xs =\n  ?xs\n  i = int (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>i xs.\n       i = int 0 \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n       Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n       xs\n 2. \\<And>n i xs.\n       \\<lbrakk>\\<And>i xs.\n                   i = int n \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n                   Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n                   xs;\n        i = int (Suc n)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n                         Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n                         xs", "thus ?case"], ["proof (prove)\nusing this:\n  ?i = int n \\<Longrightarrow>\n  take\\<cdot>(MkI\\<cdot>?i)\\<cdot>?xs ++\n  Data_List.drop\\<cdot>(MkI\\<cdot>?i)\\<cdot>?xs =\n  ?xs\n  i = int (Suc n)\n\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n    Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n    xs", "apply (subst drop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i xs.\n                i = int n \\<Longrightarrow>\n                take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n                Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n                xs;\n     i = int (Suc n)\\<rbrakk>\n    \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n                      (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then xs\n                       else list_case\\<cdot>[]\\<cdot>\n                            (\\<Lambda> y.\n                                Abs_cfun\n                                 (Rep_cfun\n                                   (Data_List.drop\\<cdot>\n                                    (MkI\\<cdot>i - 1))))\\<cdot>\n                            xs) =\n                      xs", "apply (subst take.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i xs.\n                i = int n \\<Longrightarrow>\n                take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n                Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n                xs;\n     i = int (Suc n)\\<rbrakk>\n    \\<Longrightarrow> (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then []\n                       else (case xs of [] \\<Rightarrow> []\n                             | y : ys \\<Rightarrow>\n                                 y :\n                                 take\\<cdot>(MkI\\<cdot>i - 1)\\<cdot>ys)) ++\n                      (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then xs\n                       else list_case\\<cdot>[]\\<cdot>\n                            (\\<Lambda> y.\n                                Abs_cfun\n                                 (Rep_cfun\n                                   (Data_List.drop\\<cdot>\n                                    (MkI\\<cdot>i - 1))))\\<cdot>\n                            xs) =\n                      xs", "apply (cases xs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>i xs.\n                i = int n \\<Longrightarrow>\n                take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n                Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n                xs;\n     i = int (Suc n); xs = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then []\n                       else (case xs of [] \\<Rightarrow> []\n                             | y : ys \\<Rightarrow>\n                                 y :\n                                 take\\<cdot>(MkI\\<cdot>i - 1)\\<cdot>ys)) ++\n                      (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then xs\n                       else list_case\\<cdot>[]\\<cdot>\n                            (\\<Lambda> y.\n                                Abs_cfun\n                                 (Rep_cfun\n                                   (Data_List.drop\\<cdot>\n                                    (MkI\\<cdot>i - 1))))\\<cdot>\n                            xs) =\n                      xs\n 2. \\<lbrakk>\\<And>i xs.\n                i = int n \\<Longrightarrow>\n                take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n                Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n                xs;\n     i = int (Suc n); xs = []\\<rbrakk>\n    \\<Longrightarrow> (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then []\n                       else (case xs of [] \\<Rightarrow> []\n                             | y : ys \\<Rightarrow>\n                                 y :\n                                 take\\<cdot>(MkI\\<cdot>i - 1)\\<cdot>ys)) ++\n                      (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then xs\n                       else list_case\\<cdot>[]\\<cdot>\n                            (\\<Lambda> y.\n                                Abs_cfun\n                                 (Rep_cfun\n                                   (Data_List.drop\\<cdot>\n                                    (MkI\\<cdot>i - 1))))\\<cdot>\n                            xs) =\n                      xs\n 3. \\<And>a list.\n       \\<lbrakk>\\<And>i xs.\n                   i = int n \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n                   Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n                   xs;\n        i = int (Suc n); xs = a : list\\<rbrakk>\n       \\<Longrightarrow> (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then []\n                          else (case xs of [] \\<Rightarrow> []\n                                | y : ys \\<Rightarrow>\n                                    y :\n                                    take\\<cdot>(MkI\\<cdot>i - 1)\\<cdot>\n                                    ys)) ++\n                         (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then xs\n                          else list_case\\<cdot>[]\\<cdot>\n                               (\\<Lambda> y.\n                                   Abs_cfun\n                                    (Rep_cfun\n(Data_List.drop\\<cdot>(MkI\\<cdot>i - 1))))\\<cdot>\n                               xs) =\n                         xs", "apply (auto simp add: zero_Integer_def one_Integer_def )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n  Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n  xs\n\ngoal (1 subgoal):\n 1. \\<And>i xs.\n       i = int 0 \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n       Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n       xs", "qed simp"], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n  Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n  xs\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       i = - int (Suc n) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n       Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n       xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       i = - int (Suc n) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n       Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n       xs", "case (neg nat)"], ["proof (state)\nthis:\n  i = - int (Suc nat)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       i = - int (Suc n) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n       Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n       xs", "then"], ["proof (chain)\npicking this:\n  i = - int (Suc nat)", "show ?thesis"], ["proof (prove)\nusing this:\n  i = - int (Suc nat)\n\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n    Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n    xs", "apply (subst drop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = - int (Suc nat) \\<Longrightarrow>\n    take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n    (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then xs\n     else list_case\\<cdot>[]\\<cdot>\n          (\\<Lambda> y.\n              Abs_cfun\n               (Rep_cfun (Data_List.drop\\<cdot>(MkI\\<cdot>i - 1))))\\<cdot>\n          xs) =\n    xs", "apply (subst take.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = - int (Suc nat) \\<Longrightarrow>\n    (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then []\n     else (case xs of [] \\<Rightarrow> []\n           | y : ys \\<Rightarrow>\n               y : take\\<cdot>(MkI\\<cdot>i - 1)\\<cdot>ys)) ++\n    (If le\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then xs\n     else list_case\\<cdot>[]\\<cdot>\n          (\\<Lambda> y.\n              Abs_cfun\n               (Rep_cfun (Data_List.drop\\<cdot>(MkI\\<cdot>i - 1))))\\<cdot>\n          xs) =\n    xs", "apply (auto simp add: zero_Integer_def one_Integer_def )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>i)\\<cdot>xs ++\n  Data_List.drop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs =\n  xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma take_intsFrom_enumFrom [simp]:\n  \"take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] = [MkI\\<cdot>i..MkI\\<cdot>(n+i) - 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n    [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       n = int na \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]\n 2. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       n = int na \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]\n 2. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "assume \"n = int m\""], ["proof (state)\nthis:\n  n = int m\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       n = int na \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]\n 2. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "then"], ["proof (chain)\npicking this:\n  n = int m", "show ?thesis"], ["proof (prove)\nusing this:\n  n = int m\n\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n    [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "proof (induct m arbitrary: n i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n i.\n       n = int 0 \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]\n 2. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "case 0"], ["proof (state)\nthis:\n  n = int 0\n\ngoal (2 subgoals):\n 1. \\<And>n i.\n       n = int 0 \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]\n 2. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "then"], ["proof (chain)\npicking this:\n  n = int 0", "show ?case"], ["proof (prove)\nusing this:\n  n = int 0\n\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n    [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n  [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]\n\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "case (Suc m)"], ["proof (state)\nthis:\n  ?n = int m \\<Longrightarrow>\n  take\\<cdot>(MkI\\<cdot>?n)\\<cdot>[MkI\\<cdot>?i..] =\n  [MkI\\<cdot>?i..MkI\\<cdot>(?n + ?i) - 1]\n  n = int (Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "then"], ["proof (chain)\npicking this:\n  ?n = int m \\<Longrightarrow>\n  take\\<cdot>(MkI\\<cdot>?n)\\<cdot>[MkI\\<cdot>?i..] =\n  [MkI\\<cdot>?i..MkI\\<cdot>(?n + ?i) - 1]\n  n = int (Suc m)", "have \"n - 1 = int m\""], ["proof (prove)\nusing this:\n  ?n = int m \\<Longrightarrow>\n  take\\<cdot>(MkI\\<cdot>?n)\\<cdot>[MkI\\<cdot>?i..] =\n  [MkI\\<cdot>?i..MkI\\<cdot>(?n + ?i) - 1]\n  n = int (Suc m)\n\ngoal (1 subgoal):\n 1. n - 1 = int m", "by simp"], ["proof (state)\nthis:\n  n - 1 = int m\n\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "from Suc(1) [OF this]"], ["proof (chain)\npicking this:\n  take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>?i..] =\n  [MkI\\<cdot>?i..MkI\\<cdot>(n - 1 + ?i) - 1]", "have \"take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i+1)..] = [MkI\\<cdot>(i+1)..MkI\\<cdot>(n - 1 + (i+1)) - 1]\""], ["proof (prove)\nusing this:\n  take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>?i..] =\n  [MkI\\<cdot>?i..MkI\\<cdot>(n - 1 + ?i) - 1]\n\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i + 1)..] =\n    [MkI\\<cdot>(i + 1)..MkI\\<cdot>(n - 1 + (i + 1)) - 1]", "."], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i + 1)..] =\n  [MkI\\<cdot>(i + 1)..MkI\\<cdot>(n - 1 + (i + 1)) - 1]\n\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "moreover"], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i + 1)..] =\n  [MkI\\<cdot>(i + 1)..MkI\\<cdot>(n - 1 + (i + 1)) - 1]\n\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "have \"(n - 1) + (i+1) - 1 = n + i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - 1 + (i + 1) - 1 = n + i - 1", "by arith"], ["proof (state)\nthis:\n  n - 1 + (i + 1) - 1 = n + i - 1\n\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "ultimately"], ["proof (chain)\npicking this:\n  take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i + 1)..] =\n  [MkI\\<cdot>(i + 1)..MkI\\<cdot>(n - 1 + (i + 1)) - 1]\n  n - 1 + (i + 1) - 1 = n + i - 1", "have IH: \"take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i+1)..] = [MkI\\<cdot>(i+1)..MkI\\<cdot>(n+i) - 1]\""], ["proof (prove)\nusing this:\n  take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i + 1)..] =\n  [MkI\\<cdot>(i + 1)..MkI\\<cdot>(n - 1 + (i + 1)) - 1]\n  n - 1 + (i + 1) - 1 = n + i - 1\n\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i + 1)..] =\n    [MkI\\<cdot>(i + 1)..MkI\\<cdot>(n + i) - 1]", "by simp"], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i + 1)..] =\n  [MkI\\<cdot>(i + 1)..MkI\\<cdot>(n + i) - 1]\n\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "from Suc(2)"], ["proof (chain)\npicking this:\n  n = int (Suc m)", "have gt: \"n > 0\""], ["proof (prove)\nusing this:\n  n = int (Suc m)\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "moreover"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "have \"[MkI\\<cdot>i..] = MkI\\<cdot>i : [MkI\\<cdot>i + 1..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [MkI\\<cdot>i..] = MkI\\<cdot>i : [MkI\\<cdot>i + 1..]", "by (simp, subst intsFrom.simps) simp"], ["proof (state)\nthis:\n  [MkI\\<cdot>i..] = MkI\\<cdot>i : [MkI\\<cdot>i + 1..]\n\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "ultimately"], ["proof (chain)\npicking this:\n  0 < n\n  [MkI\\<cdot>i..] = MkI\\<cdot>i : [MkI\\<cdot>i + 1..]", "have *: \"take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] = MkI\\<cdot>i : take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i+1)..]\""], ["proof (prove)\nusing this:\n  0 < n\n  [MkI\\<cdot>i..] = MkI\\<cdot>i : [MkI\\<cdot>i + 1..]\n\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n    MkI\\<cdot>i : take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i + 1)..]", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n  MkI\\<cdot>i : take\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>[MkI\\<cdot>(i + 1)..]\n\ngoal (1 subgoal):\n 1. \\<And>m n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int m \\<Longrightarrow>\n                   take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                   [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1];\n        n = int (Suc m)\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n                         [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n    [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "unfolding IH *"], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI\\<cdot>i : [MkI\\<cdot>(i + 1)..MkI\\<cdot>(n + i) - 1] =\n    [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "using gt"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. MkI\\<cdot>i : [MkI\\<cdot>(i + 1)..MkI\\<cdot>(n + i) - 1] =\n    [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n  [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n  [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "assume \"n = - int m\""], ["proof (state)\nthis:\n  n = - int m\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "then"], ["proof (chain)\npicking this:\n  n = - int m", "have \"n \\<le> 0\""], ["proof (prove)\nusing this:\n  n = - int m\n\ngoal (1 subgoal):\n 1. n \\<le> 0", "by simp"], ["proof (state)\nthis:\n  n \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "then"], ["proof (chain)\npicking this:\n  n \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> 0\n\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n    [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]", "by (subst take.simps) (simp add: zero_Integer_def one_Integer_def)"], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n  [MkI\\<cdot>i..MkI\\<cdot>(n + i) - 1]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drop_intsFrom_enumFrom [simp]:\n  assumes \"n \\<ge> 0\"\n  shows \"drop\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] = [MkI\\<cdot>(n+i)..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n    [MkI\\<cdot>(n + i)..]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n    [MkI\\<cdot>(n + i)..]", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> n", "obtain n' where \"n = int n'\""], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = int n' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n, auto)"], ["proof (state)\nthis:\n  n = int n'\n\ngoal (1 subgoal):\n 1. Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n    [MkI\\<cdot>(n + i)..]", "then"], ["proof (chain)\npicking this:\n  n = int n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n = int n'\n\ngoal (1 subgoal):\n 1. Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n    [MkI\\<cdot>(n + i)..]", "apply(induct n' arbitrary: n i )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n i.\n       n = int 0 \\<Longrightarrow>\n       Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n       [MkI\\<cdot>(n + i)..]\n 2. \\<And>n' n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int n' \\<Longrightarrow>\n                   Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>\n                   [MkI\\<cdot>i..] =\n                   [MkI\\<cdot>(n + i)..];\n        n = int (Suc n')\\<rbrakk>\n       \\<Longrightarrow> Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>\n                         [MkI\\<cdot>i..] =\n                         [MkI\\<cdot>(n + i)..]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int n' \\<Longrightarrow>\n                   Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>\n                   [MkI\\<cdot>i..] =\n                   [MkI\\<cdot>(n + i)..];\n        n = int (Suc n')\\<rbrakk>\n       \\<Longrightarrow> Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>\n                         [MkI\\<cdot>i..] =\n                         [MkI\\<cdot>(n + i)..]", "apply (subst intsFrom.simps[unfolded enumFrom_intsFrom_conv[symmetric]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int n' \\<Longrightarrow>\n                   Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>\n                   [MkI\\<cdot>i..] =\n                   [MkI\\<cdot>(n + i)..];\n        n = int (Suc n')\\<rbrakk>\n       \\<Longrightarrow> Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>\n                         (seq\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                          (MkI\\<cdot>i : [MkI\\<cdot>i + 1..])) =\n                         [MkI\\<cdot>(n + i)..]", "apply (subst drop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' n i.\n       \\<lbrakk>\\<And>n i.\n                   n = int n' \\<Longrightarrow>\n                   Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>\n                   [MkI\\<cdot>i..] =\n                   [MkI\\<cdot>(n + i)..];\n        n = int (Suc n')\\<rbrakk>\n       \\<Longrightarrow> If le\\<cdot>(MkI\\<cdot>n)\\<cdot>0\n                         then seq\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                              (MkI\\<cdot>i : [MkI\\<cdot>i + 1..])\n                         else list_case\\<cdot>[]\\<cdot>\n                              (\\<Lambda> y.\n                                  Abs_cfun\n                                   (Rep_cfun\n                                     (Data_List.drop\\<cdot>\n(MkI\\<cdot>n - 1))))\\<cdot>\n                              (seq\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                               (MkI\\<cdot>i : [MkI\\<cdot>i + 1..])) =\n                         [MkI\\<cdot>(n + i)..]", "apply (auto simp add: zero_Integer_def one_Integer_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' i.\n       (\\<And>n i.\n           n = int n' \\<Longrightarrow>\n           Data_List.drop\\<cdot>(MkI\\<cdot>(int n'))\\<cdot>\n           (intsFrom\\<cdot>(MkI\\<cdot>i)) =\n           intsFrom\\<cdot>(MkI\\<cdot>(int n' + i))) \\<Longrightarrow>\n       intsFrom\\<cdot>(MkI\\<cdot>(int n' + (i + 1))) =\n       intsFrom\\<cdot>(MkI\\<cdot>(1 + int n' + i))", "apply (rule cfun_arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' i.\n       (\\<And>n i.\n           n = int n' \\<Longrightarrow>\n           Data_List.drop\\<cdot>(MkI\\<cdot>(int n'))\\<cdot>\n           (intsFrom\\<cdot>(MkI\\<cdot>i)) =\n           intsFrom\\<cdot>(MkI\\<cdot>(int n' + i))) \\<Longrightarrow>\n       MkI\\<cdot>(int n' + (i + 1)) = MkI\\<cdot>(1 + int n' + i)", "apply (rule cfun_arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' i.\n       (\\<And>n i.\n           n = int n' \\<Longrightarrow>\n           Data_List.drop\\<cdot>(MkI\\<cdot>(int n'))\\<cdot>\n           (intsFrom\\<cdot>(MkI\\<cdot>i)) =\n           intsFrom\\<cdot>(MkI\\<cdot>(int n' + i))) \\<Longrightarrow>\n       int n' + (i + 1) = 1 + int n' + i", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Data_List.drop\\<cdot>(MkI\\<cdot>n)\\<cdot>[MkI\\<cdot>i..] =\n  [MkI\\<cdot>(n + i)..]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma last_append_singleton:\n  \"finite_list xs \\<Longrightarrow> last\\<cdot>(xs ++ [x]) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_list xs \\<Longrightarrow> last\\<cdot>(xs ++ [x]) = x", "proof (induct xs rule:finite_list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. last\\<cdot>([] ++ [x]) = x\n 2. \\<And>xa xs.\n       \\<lbrakk>finite_list xs; last\\<cdot>(xs ++ [x]) = x\\<rbrakk>\n       \\<Longrightarrow> last\\<cdot>((xa : xs) ++ [x]) = x", "case (Cons x xs)"], ["proof (state)\nthis:\n  finite_list xs\n  last\\<cdot>(xs ++ [x]) = x\n\ngoal (2 subgoals):\n 1. last\\<cdot>([] ++ [x]) = x\n 2. \\<And>xa xs.\n       \\<lbrakk>finite_list xs; last\\<cdot>(xs ++ [x]) = x\\<rbrakk>\n       \\<Longrightarrow> last\\<cdot>((xa : xs) ++ [x]) = x", "then"], ["proof (chain)\npicking this:\n  finite_list xs\n  last\\<cdot>(xs ++ [x]) = x", "show ?case"], ["proof (prove)\nusing this:\n  finite_list xs\n  last\\<cdot>(xs ++ [x]) = x\n\ngoal (1 subgoal):\n 1. last\\<cdot>((x : xs) ++ [x]) = x", "by (cases xs) auto"], ["proof (state)\nthis:\n  last\\<cdot>((x : xs) ++ [x]) = x\n\ngoal (1 subgoal):\n 1. last\\<cdot>([] ++ [x]) = x", "qed auto"], ["", "lemma init_append_singleton:\n  \"finite_list xs \\<Longrightarrow> init\\<cdot>(xs ++ [x]) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_list xs \\<Longrightarrow> init\\<cdot>(xs ++ [x]) = xs", "proof (induct xs rule:finite_list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. init\\<cdot>([] ++ [x]) = []\n 2. \\<And>xa xs.\n       \\<lbrakk>finite_list xs; init\\<cdot>(xs ++ [x]) = xs\\<rbrakk>\n       \\<Longrightarrow> init\\<cdot>((xa : xs) ++ [x]) = xa : xs", "case (Cons x xs)"], ["proof (state)\nthis:\n  finite_list xs\n  init\\<cdot>(xs ++ [x]) = xs\n\ngoal (2 subgoals):\n 1. init\\<cdot>([] ++ [x]) = []\n 2. \\<And>xa xs.\n       \\<lbrakk>finite_list xs; init\\<cdot>(xs ++ [x]) = xs\\<rbrakk>\n       \\<Longrightarrow> init\\<cdot>((xa : xs) ++ [x]) = xa : xs", "then"], ["proof (chain)\npicking this:\n  finite_list xs\n  init\\<cdot>(xs ++ [x]) = xs", "show ?case"], ["proof (prove)\nusing this:\n  finite_list xs\n  init\\<cdot>(xs ++ [x]) = xs\n\ngoal (1 subgoal):\n 1. init\\<cdot>((x : xs) ++ [x]) = x : xs", "by (cases xs) auto"], ["proof (state)\nthis:\n  init\\<cdot>((x : xs) ++ [x]) = x : xs\n\ngoal (1 subgoal):\n 1. init\\<cdot>([] ++ [x]) = []", "qed auto"], ["", "lemma append_Nil2 [simp]:\n  \"xs ++ [] = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ++ [] = xs", "by (induct xs) simp_all"], ["", "lemma append_assoc [simp]:\n  \"(xs ++ ys) ++ zs = xs ++ ys ++ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs ++ ys) ++ zs = xs ++ ys ++ zs", "by (induct xs) simp_all"], ["", "lemma concat_simps [simp]:\n  \"concat\\<cdot>[] = []\"\n  \"concat\\<cdot>(xs : xss) = xs ++ concat\\<cdot>xss\"\n  \"concat\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\\<cdot>[] = [] &&&\n    concat\\<cdot>(xs : xss) = xs ++ concat\\<cdot>xss &&&\n    concat\\<cdot>\\<bottom> = \\<bottom>", "unfolding concat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>append\\<cdot>[]\\<cdot>[] = [] &&&\n    foldr\\<cdot>append\\<cdot>[]\\<cdot>(xs : xss) =\n    xs ++ foldr\\<cdot>append\\<cdot>[]\\<cdot>xss &&&\n    foldr\\<cdot>append\\<cdot>[]\\<cdot>\\<bottom> = \\<bottom>", "by simp_all"], ["", "lemma concatMap_simps [simp]:\n  \"concatMap\\<cdot>f\\<cdot>[] = []\"\n  \"concatMap\\<cdot>f\\<cdot>(x : xs) = f\\<cdot>x ++ concatMap\\<cdot>f\\<cdot>xs\"\n  \"concatMap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMap\\<cdot>f\\<cdot>[] = [] &&&\n    concatMap\\<cdot>f\\<cdot>(x : xs) =\n    f\\<cdot>x ++ concatMap\\<cdot>f\\<cdot>xs &&&\n    concatMap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "unfolding concatMap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f. concat oo map\\<cdot>f)\\<cdot>f\\<cdot>[] = [] &&&\n    (\\<Lambda> f. concat oo map\\<cdot>f)\\<cdot>f\\<cdot>(x : xs) =\n    f\\<cdot>x ++ (\\<Lambda> f. concat oo map\\<cdot>f)\\<cdot>f\\<cdot>xs &&&\n    (\\<Lambda> f. concat oo map\\<cdot>f)\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "by simp_all"], ["", "lemma filter_append [simp]:\n  \"filter\\<cdot>P\\<cdot>(xs ++ ys) = filter\\<cdot>P\\<cdot>xs ++ filter\\<cdot>P\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>(xs ++ ys) =\n    filter\\<cdot>P\\<cdot>xs ++ filter\\<cdot>P\\<cdot>ys", "proof (induct xs)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            filter\\<cdot>P\\<cdot>(a ++ ys) =\n            filter\\<cdot>P\\<cdot>a ++ filter\\<cdot>P\\<cdot>ys)\n 2. filter\\<cdot>P\\<cdot>(\\<bottom> ++ ys) =\n    filter\\<cdot>P\\<cdot>\\<bottom> ++ filter\\<cdot>P\\<cdot>ys\n 3. filter\\<cdot>P\\<cdot>([] ++ ys) =\n    filter\\<cdot>P\\<cdot>[] ++ filter\\<cdot>P\\<cdot>ys\n 4. \\<And>a xs.\n       filter\\<cdot>P\\<cdot>(xs ++ ys) =\n       filter\\<cdot>P\\<cdot>xs ++ filter\\<cdot>P\\<cdot>ys \\<Longrightarrow>\n       filter\\<cdot>P\\<cdot>((a : xs) ++ ys) =\n       filter\\<cdot>P\\<cdot>(a : xs) ++ filter\\<cdot>P\\<cdot>ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  filter\\<cdot>P\\<cdot>(xs ++ ys) =\n  filter\\<cdot>P\\<cdot>xs ++ filter\\<cdot>P\\<cdot>ys\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            filter\\<cdot>P\\<cdot>(a ++ ys) =\n            filter\\<cdot>P\\<cdot>a ++ filter\\<cdot>P\\<cdot>ys)\n 2. filter\\<cdot>P\\<cdot>(\\<bottom> ++ ys) =\n    filter\\<cdot>P\\<cdot>\\<bottom> ++ filter\\<cdot>P\\<cdot>ys\n 3. filter\\<cdot>P\\<cdot>([] ++ ys) =\n    filter\\<cdot>P\\<cdot>[] ++ filter\\<cdot>P\\<cdot>ys\n 4. \\<And>a xs.\n       filter\\<cdot>P\\<cdot>(xs ++ ys) =\n       filter\\<cdot>P\\<cdot>xs ++ filter\\<cdot>P\\<cdot>ys \\<Longrightarrow>\n       filter\\<cdot>P\\<cdot>((a : xs) ++ ys) =\n       filter\\<cdot>P\\<cdot>(a : xs) ++ filter\\<cdot>P\\<cdot>ys", "then"], ["proof (chain)\npicking this:\n  filter\\<cdot>P\\<cdot>(xs ++ ys) =\n  filter\\<cdot>P\\<cdot>xs ++ filter\\<cdot>P\\<cdot>ys", "show ?case"], ["proof (prove)\nusing this:\n  filter\\<cdot>P\\<cdot>(xs ++ ys) =\n  filter\\<cdot>P\\<cdot>xs ++ filter\\<cdot>P\\<cdot>ys\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>((x : xs) ++ ys) =\n    filter\\<cdot>P\\<cdot>(x : xs) ++ filter\\<cdot>P\\<cdot>ys", "by (cases \"P\\<cdot>x\") (auto simp: If_and_if)"], ["proof (state)\nthis:\n  filter\\<cdot>P\\<cdot>((x : xs) ++ ys) =\n  filter\\<cdot>P\\<cdot>(x : xs) ++ filter\\<cdot>P\\<cdot>ys\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            filter\\<cdot>P\\<cdot>(a ++ ys) =\n            filter\\<cdot>P\\<cdot>a ++ filter\\<cdot>P\\<cdot>ys)\n 2. filter\\<cdot>P\\<cdot>(\\<bottom> ++ ys) =\n    filter\\<cdot>P\\<cdot>\\<bottom> ++ filter\\<cdot>P\\<cdot>ys\n 3. filter\\<cdot>P\\<cdot>([] ++ ys) =\n    filter\\<cdot>P\\<cdot>[] ++ filter\\<cdot>P\\<cdot>ys", "qed simp_all"], ["", "lemma elem_append [simp]:\n  \"elem\\<cdot>x\\<cdot>(xs ++ ys) = (elem\\<cdot>x\\<cdot>xs orelse elem\\<cdot>x\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem\\<cdot>x\\<cdot>(xs ++ ys) =\n    (elem\\<cdot>x\\<cdot>xs orelse elem\\<cdot>x\\<cdot>ys)", "by (induct xs) auto"], ["", "lemma filter_filter [simp]:\n  \"filter\\<cdot>P\\<cdot>(filter\\<cdot>Q\\<cdot>xs) = filter\\<cdot>(\\<Lambda> x. Q\\<cdot>x andalso P\\<cdot>x)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>(filter\\<cdot>Q\\<cdot>xs) =\n    filter\\<cdot>(\\<Lambda> x. Q\\<cdot>x andalso P\\<cdot>x)\\<cdot>xs", "by (induct xs) (auto simp: If2_def [symmetric] split: split_If2)"], ["", "lemma filter_const_TT [simp]:\n  \"filter\\<cdot>(\\<Lambda> _. TT)\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\\<cdot>(\\<Lambda> uu_. TT)\\<cdot>xs = xs", "by (induct xs) simp_all"], ["", "lemma tails_strict [simp]:\n  \"tails\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tails\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma inits_strict [simp]:\n  \"inits\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inits\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma the_and_strict [simp]:\n  \"the_and\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_and\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma the_or_strict [simp]:\n  \"the_or\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_or\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma all_strict [simp]:\n  \"all\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma any_strict [simp]:\n  \"any\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. any\\<cdot>P\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma tails_neq_Nil [simp]:\n  \"tails\\<cdot>xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tails\\<cdot>xs \\<noteq> []", "by (cases xs) simp_all"], ["", "lemma inits_neq_Nil [simp]:\n  \"inits\\<cdot>xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inits\\<cdot>xs \\<noteq> []", "by (cases xs) simp_all"], ["", "lemma Nil_neq_tails [simp]:\n  \"[] \\<noteq> tails\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> tails\\<cdot>xs", "by (cases xs) simp_all"], ["", "lemma Nil_neq_inits [simp]:\n  \"[] \\<noteq> inits\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> inits\\<cdot>xs", "by (cases xs) simp_all"], ["", "lemma finite_list_not_bottom [simp]:\n  assumes \"finite_list xs\" shows \"xs \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> \\<bottom>", "using assms"], ["proof (prove)\nusing this:\n  finite_list xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> \\<bottom>", "by (cases) simp_all"], ["", "lemma head_append [simp]:\n  \"head\\<cdot>(xs ++ ys) = If null\\<cdot>xs then head\\<cdot>ys else head\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head\\<cdot>(xs ++ ys) =\n    If null\\<cdot>xs then head\\<cdot>ys else head\\<cdot>xs", "by (cases xs) simp_all"], ["", "lemma filter_cong:\n  \"\\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow> filter\\<cdot>p\\<cdot>xs = filter\\<cdot>q\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n    filter\\<cdot>p\\<cdot>xs = filter\\<cdot>q\\<cdot>xs", "proof (induct arbitrary: xs rule: filter.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. adm (\\<lambda>filter.\n            \\<forall>x.\n               (\\<forall>x\\<in>set x.\n                   p\\<cdot>x = q\\<cdot>x) \\<longrightarrow>\n               filter\\<cdot>p\\<cdot>x = filter\\<cdot>q\\<cdot>x)\n 2. \\<And>xs.\n       \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n       \\<bottom>\\<cdot>p\\<cdot>xs = \\<bottom>\\<cdot>q\\<cdot>xs\n 3. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<forall>x\\<in>set xs.\n                      p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n                   x\\<cdot>p\\<cdot>xs = x\\<cdot>q\\<cdot>xs;\n        \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> P v.\n                             Fixrec.run\\<cdot>\n                             (match_Nil\\<cdot>v\\<cdot>\n                              (Fixrec.succeed\\<cdot>[]) +++\n                              match_Cons\\<cdot>v\\<cdot>\n                              (\\<Lambda> xa xs.\n                                  Fixrec.succeed\\<cdot>\n                                  (If P\\<cdot>xa\n                                   then xa : x\\<cdot>P\\<cdot>xs\n                                   else x\\<cdot>P\\<cdot>xs))))\\<cdot>\n                         p\\<cdot>\n                         xs =\n                         (\\<Lambda> P v.\n                             Fixrec.run\\<cdot>\n                             (match_Nil\\<cdot>v\\<cdot>\n                              (Fixrec.succeed\\<cdot>[]) +++\n                              match_Cons\\<cdot>v\\<cdot>\n                              (\\<Lambda> xa xs.\n                                  Fixrec.succeed\\<cdot>\n                                  (If P\\<cdot>xa\n                                   then xa : x\\<cdot>P\\<cdot>xs\n                                   else x\\<cdot>P\\<cdot>xs))))\\<cdot>\n                         q\\<cdot>\n                         xs", "case (3 x)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ?xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n  x\\<cdot>p\\<cdot>?xs = x\\<cdot>q\\<cdot>?xs\n  \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>filter.\n            \\<forall>x.\n               (\\<forall>x\\<in>set x.\n                   p\\<cdot>x = q\\<cdot>x) \\<longrightarrow>\n               filter\\<cdot>p\\<cdot>x = filter\\<cdot>q\\<cdot>x)\n 2. \\<And>xs.\n       \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n       \\<bottom>\\<cdot>p\\<cdot>xs = \\<bottom>\\<cdot>q\\<cdot>xs\n 3. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<forall>x\\<in>set xs.\n                      p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n                   x\\<cdot>p\\<cdot>xs = x\\<cdot>q\\<cdot>xs;\n        \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> P v.\n                             Fixrec.run\\<cdot>\n                             (match_Nil\\<cdot>v\\<cdot>\n                              (Fixrec.succeed\\<cdot>[]) +++\n                              match_Cons\\<cdot>v\\<cdot>\n                              (\\<Lambda> xa xs.\n                                  Fixrec.succeed\\<cdot>\n                                  (If P\\<cdot>xa\n                                   then xa : x\\<cdot>P\\<cdot>xs\n                                   else x\\<cdot>P\\<cdot>xs))))\\<cdot>\n                         p\\<cdot>\n                         xs =\n                         (\\<Lambda> P v.\n                             Fixrec.run\\<cdot>\n                             (match_Nil\\<cdot>v\\<cdot>\n                              (Fixrec.succeed\\<cdot>[]) +++\n                              match_Cons\\<cdot>v\\<cdot>\n                              (\\<Lambda> xa xs.\n                                  Fixrec.succeed\\<cdot>\n                                  (If P\\<cdot>xa\n                                   then xa : x\\<cdot>P\\<cdot>xs\n                                   else x\\<cdot>P\\<cdot>xs))))\\<cdot>\n                         q\\<cdot>\n                         xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set ?xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n  x\\<cdot>p\\<cdot>?xs = x\\<cdot>q\\<cdot>?xs\n  \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ?xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n  x\\<cdot>p\\<cdot>?xs = x\\<cdot>q\\<cdot>?xs\n  \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x\n\ngoal (1 subgoal):\n 1. (\\<Lambda> P v.\n        Fixrec.run\\<cdot>\n        (match_Nil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>[]) +++\n         match_Cons\\<cdot>v\\<cdot>\n         (\\<Lambda> xa xs.\n             Fixrec.succeed\\<cdot>\n             (If P\\<cdot>xa then xa : x\\<cdot>P\\<cdot>xs\n              else x\\<cdot>P\\<cdot>xs))))\\<cdot>\n    p\\<cdot>\n    xs =\n    (\\<Lambda> P v.\n        Fixrec.run\\<cdot>\n        (match_Nil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>[]) +++\n         match_Cons\\<cdot>v\\<cdot>\n         (\\<Lambda> xa xs.\n             Fixrec.succeed\\<cdot>\n             (If P\\<cdot>xa then xa : x\\<cdot>P\\<cdot>xs\n              else x\\<cdot>P\\<cdot>xs))))\\<cdot>\n    q\\<cdot>\n    xs", "by (cases xs) auto"], ["proof (state)\nthis:\n  (\\<Lambda> P v.\n      Fixrec.run\\<cdot>\n      (match_Nil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>[]) +++\n       match_Cons\\<cdot>v\\<cdot>\n       (\\<Lambda> xa xs.\n           Fixrec.succeed\\<cdot>\n           (If P\\<cdot>xa then xa : x\\<cdot>P\\<cdot>xs\n            else x\\<cdot>P\\<cdot>xs))))\\<cdot>\n  p\\<cdot>\n  xs =\n  (\\<Lambda> P v.\n      Fixrec.run\\<cdot>\n      (match_Nil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>[]) +++\n       match_Cons\\<cdot>v\\<cdot>\n       (\\<Lambda> xa xs.\n           Fixrec.succeed\\<cdot>\n           (If P\\<cdot>xa then xa : x\\<cdot>P\\<cdot>xs\n            else x\\<cdot>P\\<cdot>xs))))\\<cdot>\n  q\\<cdot>\n  xs\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>filter.\n            \\<forall>x.\n               (\\<forall>x\\<in>set x.\n                   p\\<cdot>x = q\\<cdot>x) \\<longrightarrow>\n               filter\\<cdot>p\\<cdot>x = filter\\<cdot>q\\<cdot>x)\n 2. \\<And>xs.\n       \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n       \\<bottom>\\<cdot>p\\<cdot>xs = \\<bottom>\\<cdot>q\\<cdot>xs", "qed simp_all"], ["", "lemma filter_TT [simp]:\n  assumes \"\\<forall>x\\<in>set xs. P\\<cdot>x = TT\"\n  shows \"filter\\<cdot>P\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs = xs", "by (rule filter_cong [of xs P \"\\<Lambda> _. TT\", simplified, OF assms])"], ["", "lemma filter_FF [simp]:\n  assumes \"finite_list xs\"\n    and \"\\<forall>x\\<in>set xs. P\\<cdot>x = FF\"\n  shows \"filter\\<cdot>P\\<cdot>xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs = []", "using assms"], ["proof (prove)\nusing this:\n  finite_list xs\n  \\<forall>x\\<in>set xs. P\\<cdot>x = FF\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs = []", "by (induct xs) simp_all"], ["", "lemma map_cong:\n  \"\\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow> map\\<cdot>p\\<cdot>xs = map\\<cdot>q\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n    map\\<cdot>p\\<cdot>xs = map\\<cdot>q\\<cdot>xs", "proof (induct arbitrary: xs rule: map.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. adm (\\<lambda>map.\n            \\<forall>x.\n               (\\<forall>x\\<in>set x.\n                   p\\<cdot>x = q\\<cdot>x) \\<longrightarrow>\n               map\\<cdot>p\\<cdot>x = map\\<cdot>q\\<cdot>x)\n 2. \\<And>xs.\n       \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n       \\<bottom>\\<cdot>p\\<cdot>xs = \\<bottom>\\<cdot>q\\<cdot>xs\n 3. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<forall>x\\<in>set xs.\n                      p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n                   x\\<cdot>p\\<cdot>xs = x\\<cdot>q\\<cdot>xs;\n        \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f v.\n                             Fixrec.run\\<cdot>\n                             (match_Nil\\<cdot>v\\<cdot>\n                              (Fixrec.succeed\\<cdot>[]) +++\n                              match_Cons\\<cdot>v\\<cdot>\n                              (\\<Lambda> xa xs.\n                                  Fixrec.succeed\\<cdot>\n                                  (f\\<cdot>xa :\n                                   x\\<cdot>f\\<cdot>xs))))\\<cdot>\n                         p\\<cdot>\n                         xs =\n                         (\\<Lambda> f v.\n                             Fixrec.run\\<cdot>\n                             (match_Nil\\<cdot>v\\<cdot>\n                              (Fixrec.succeed\\<cdot>[]) +++\n                              match_Cons\\<cdot>v\\<cdot>\n                              (\\<Lambda> xa xs.\n                                  Fixrec.succeed\\<cdot>\n                                  (f\\<cdot>xa :\n                                   x\\<cdot>f\\<cdot>xs))))\\<cdot>\n                         q\\<cdot>\n                         xs", "case (3 x)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ?xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n  x\\<cdot>p\\<cdot>?xs = x\\<cdot>q\\<cdot>?xs\n  \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>map.\n            \\<forall>x.\n               (\\<forall>x\\<in>set x.\n                   p\\<cdot>x = q\\<cdot>x) \\<longrightarrow>\n               map\\<cdot>p\\<cdot>x = map\\<cdot>q\\<cdot>x)\n 2. \\<And>xs.\n       \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n       \\<bottom>\\<cdot>p\\<cdot>xs = \\<bottom>\\<cdot>q\\<cdot>xs\n 3. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<forall>x\\<in>set xs.\n                      p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n                   x\\<cdot>p\\<cdot>xs = x\\<cdot>q\\<cdot>xs;\n        \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f v.\n                             Fixrec.run\\<cdot>\n                             (match_Nil\\<cdot>v\\<cdot>\n                              (Fixrec.succeed\\<cdot>[]) +++\n                              match_Cons\\<cdot>v\\<cdot>\n                              (\\<Lambda> xa xs.\n                                  Fixrec.succeed\\<cdot>\n                                  (f\\<cdot>xa :\n                                   x\\<cdot>f\\<cdot>xs))))\\<cdot>\n                         p\\<cdot>\n                         xs =\n                         (\\<Lambda> f v.\n                             Fixrec.run\\<cdot>\n                             (match_Nil\\<cdot>v\\<cdot>\n                              (Fixrec.succeed\\<cdot>[]) +++\n                              match_Cons\\<cdot>v\\<cdot>\n                              (\\<Lambda> xa xs.\n                                  Fixrec.succeed\\<cdot>\n                                  (f\\<cdot>xa :\n                                   x\\<cdot>f\\<cdot>xs))))\\<cdot>\n                         q\\<cdot>\n                         xs", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set ?xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n  x\\<cdot>p\\<cdot>?xs = x\\<cdot>q\\<cdot>?xs\n  \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ?xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n  x\\<cdot>p\\<cdot>?xs = x\\<cdot>q\\<cdot>?xs\n  \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x\n\ngoal (1 subgoal):\n 1. (\\<Lambda> f v.\n        Fixrec.run\\<cdot>\n        (match_Nil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>[]) +++\n         match_Cons\\<cdot>v\\<cdot>\n         (\\<Lambda> xa xs.\n             Fixrec.succeed\\<cdot>\n             (f\\<cdot>xa : x\\<cdot>f\\<cdot>xs))))\\<cdot>\n    p\\<cdot>\n    xs =\n    (\\<Lambda> f v.\n        Fixrec.run\\<cdot>\n        (match_Nil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>[]) +++\n         match_Cons\\<cdot>v\\<cdot>\n         (\\<Lambda> xa xs.\n             Fixrec.succeed\\<cdot>\n             (f\\<cdot>xa : x\\<cdot>f\\<cdot>xs))))\\<cdot>\n    q\\<cdot>\n    xs", "by (cases xs) auto"], ["proof (state)\nthis:\n  (\\<Lambda> f v.\n      Fixrec.run\\<cdot>\n      (match_Nil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>[]) +++\n       match_Cons\\<cdot>v\\<cdot>\n       (\\<Lambda> xa xs.\n           Fixrec.succeed\\<cdot>(f\\<cdot>xa : x\\<cdot>f\\<cdot>xs))))\\<cdot>\n  p\\<cdot>\n  xs =\n  (\\<Lambda> f v.\n      Fixrec.run\\<cdot>\n      (match_Nil\\<cdot>v\\<cdot>(Fixrec.succeed\\<cdot>[]) +++\n       match_Cons\\<cdot>v\\<cdot>\n       (\\<Lambda> xa xs.\n           Fixrec.succeed\\<cdot>(f\\<cdot>xa : x\\<cdot>f\\<cdot>xs))))\\<cdot>\n  q\\<cdot>\n  xs\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>map.\n            \\<forall>x.\n               (\\<forall>x\\<in>set x.\n                   p\\<cdot>x = q\\<cdot>x) \\<longrightarrow>\n               map\\<cdot>p\\<cdot>x = map\\<cdot>q\\<cdot>x)\n 2. \\<And>xs.\n       \\<forall>x\\<in>set xs. p\\<cdot>x = q\\<cdot>x \\<Longrightarrow>\n       \\<bottom>\\<cdot>p\\<cdot>xs = \\<bottom>\\<cdot>q\\<cdot>xs", "qed simp_all"], ["", "lemma finite_list_upto:\n  \"finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\" (is \"?P m n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "proof (cases \"n - m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       n - m = int na \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n 2. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "fix d"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       n - m = int na \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n 2. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "assume \"n - m = int d\""], ["proof (state)\nthis:\n  n - m = int d\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       n - m = int na \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n 2. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "then"], ["proof (chain)\npicking this:\n  n - m = int d", "show \"?P m n\""], ["proof (prove)\nusing this:\n  n - m = int d\n\ngoal (1 subgoal):\n 1. finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "proof (induct d arbitrary: m n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n 2. \\<And>d m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int d \\<Longrightarrow>\n                   finite_list\n                    (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n));\n        n - m = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> finite_list\n                          (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "case (Suc d)"], ["proof (state)\nthis:\n  ?n - ?m = int d \\<Longrightarrow>\n  finite_list (upto\\<cdot>(MkI\\<cdot>?m)\\<cdot>(MkI\\<cdot>?n))\n  n - m = int (Suc d)\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n 2. \\<And>d m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int d \\<Longrightarrow>\n                   finite_list\n                    (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n));\n        n - m = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> finite_list\n                          (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "then"], ["proof (chain)\npicking this:\n  ?n - ?m = int d \\<Longrightarrow>\n  finite_list (upto\\<cdot>(MkI\\<cdot>?m)\\<cdot>(MkI\\<cdot>?n))\n  n - m = int (Suc d)", "have \"n - (m + 1) = int d\" and le: \"m \\<le> n\""], ["proof (prove)\nusing this:\n  ?n - ?m = int d \\<Longrightarrow>\n  finite_list (upto\\<cdot>(MkI\\<cdot>?m)\\<cdot>(MkI\\<cdot>?n))\n  n - m = int (Suc d)\n\ngoal (1 subgoal):\n 1. n - (m + 1) = int d &&& m \\<le> n", "by simp_all"], ["proof (state)\nthis:\n  n - (m + 1) = int d\n  m \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n 2. \\<And>d m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int d \\<Longrightarrow>\n                   finite_list\n                    (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n));\n        n - m = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> finite_list\n                          (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "from Suc(1) [OF this(1)]"], ["proof (chain)\npicking this:\n  finite_list (upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n))", "have IH: \"?P (m+1) n\""], ["proof (prove)\nusing this:\n  finite_list (upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. finite_list (upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n))", "."], ["proof (state)\nthis:\n  finite_list (upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n))\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n 2. \\<And>d m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int d \\<Longrightarrow>\n                   finite_list\n                    (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n));\n        n - m = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> finite_list\n                          (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "then"], ["proof (chain)\npicking this:\n  finite_list (upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n))", "show ?case"], ["proof (prove)\nusing this:\n  finite_list (upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "using le"], ["proof (prove)\nusing this:\n  finite_list (upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n))\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "qed (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "assume \"n - m = - int d\""], ["proof (state)\nthis:\n  n - m = - int d\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "then"], ["proof (chain)\npicking this:\n  n - m = - int d", "have \"n \\<le> m\""], ["proof (prove)\nusing this:\n  n - m = - int d\n\ngoal (1 subgoal):\n 1. n \\<le> m", "by auto"], ["proof (state)\nthis:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "moreover"], ["proof (state)\nthis:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "{"], ["proof (state)\nthis:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "assume \"n = m\""], ["proof (state)\nthis:\n  n = m\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "then"], ["proof (chain)\npicking this:\n  n = m", "have \"?P m n\""], ["proof (prove)\nusing this:\n  n = m\n\ngoal (1 subgoal):\n 1. finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "}"], ["proof (state)\nthis:\n  n = m \\<Longrightarrow>\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "moreover"], ["proof (state)\nthis:\n  n = m \\<Longrightarrow>\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "{"], ["proof (state)\nthis:\n  n = m \\<Longrightarrow>\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "assume \"n < m\""], ["proof (state)\nthis:\n  n < m\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "then"], ["proof (chain)\npicking this:\n  n < m", "have \"?P m n\""], ["proof (prove)\nusing this:\n  n < m\n\ngoal (1 subgoal):\n 1. finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "}"], ["proof (state)\nthis:\n  n < m \\<Longrightarrow>\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "ultimately"], ["proof (chain)\npicking this:\n  n \\<le> m\n  n = m \\<Longrightarrow>\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n  n < m \\<Longrightarrow>\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> m\n  n = m \\<Longrightarrow>\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n  n < m \\<Longrightarrow>\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))", "by arith"], ["proof (state)\nthis:\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_commute:\n  assumes \"\\<forall>x\\<in>set xs. (Q\\<cdot>x andalso P\\<cdot>x) = (P\\<cdot>x andalso Q\\<cdot>x)\"\n  shows \"filter\\<cdot>P\\<cdot>(filter\\<cdot>Q\\<cdot>xs) = filter\\<cdot>Q\\<cdot>(filter\\<cdot>P\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>(filter\\<cdot>Q\\<cdot>xs) =\n    filter\\<cdot>Q\\<cdot>(filter\\<cdot>P\\<cdot>xs)", "using filter_cong [of xs \"\\<Lambda> x. Q\\<cdot>x andalso P\\<cdot>x\" \"\\<Lambda> x. P\\<cdot>x andalso Q\\<cdot>x\"]\n    and assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs.\n     (\\<Lambda> x. Q\\<cdot>x andalso P\\<cdot>x)\\<cdot>x =\n     (\\<Lambda> x. P\\<cdot>x andalso Q\\<cdot>x)\\<cdot>x \\<Longrightarrow>\n  filter\\<cdot>(\\<Lambda> x. Q\\<cdot>x andalso P\\<cdot>x)\\<cdot>xs =\n  filter\\<cdot>(\\<Lambda> x. P\\<cdot>x andalso Q\\<cdot>x)\\<cdot>xs\n  \\<forall>x\\<in>set xs.\n     (Q\\<cdot>x andalso P\\<cdot>x) = (P\\<cdot>x andalso Q\\<cdot>x)\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>(filter\\<cdot>Q\\<cdot>xs) =\n    filter\\<cdot>Q\\<cdot>(filter\\<cdot>P\\<cdot>xs)", "by simp"], ["", "lemma upto_append_intsFrom [simp]:\n  assumes \"m \\<le> n\"\n  shows \"upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++ intsFrom\\<cdot>(MkI\\<cdot>n+1) = intsFrom\\<cdot>(MkI\\<cdot>m)\"\n    (is \"?u m n ++ _ = ?i m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n    intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n    intsFrom\\<cdot>(MkI\\<cdot>m)", "proof (cases \"n - m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       n - m = int na \\<Longrightarrow>\n       upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n       intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n       intsFrom\\<cdot>(MkI\\<cdot>m)\n 2. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n       intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n       intsFrom\\<cdot>(MkI\\<cdot>m)", "case (nonneg i)"], ["proof (state)\nthis:\n  n - m = int i\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       n - m = int na \\<Longrightarrow>\n       upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n       intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n       intsFrom\\<cdot>(MkI\\<cdot>m)\n 2. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n       intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n       intsFrom\\<cdot>(MkI\\<cdot>m)", "with assms"], ["proof (chain)\npicking this:\n  m \\<le> n\n  n - m = int i", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<le> n\n  n - m = int i\n\ngoal (1 subgoal):\n 1. upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n    intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n    intsFrom\\<cdot>(MkI\\<cdot>m)", "proof (induct i arbitrary: m n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<le> n; n - m = int 0\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m \\<le> n; n - m = int i\\<rbrakk>\n                   \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     (MkI\\<cdot>n) ++\n                                     intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                                     intsFrom\\<cdot>(MkI\\<cdot>m);\n        m \\<le> n; n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>?m \\<le> ?n; ?n - ?m = int i\\<rbrakk>\n  \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>?m)\\<cdot>(MkI\\<cdot>?n) ++\n                    intsFrom\\<cdot>(MkI\\<cdot>?n + 1) =\n                    intsFrom\\<cdot>(MkI\\<cdot>?m)\n  m \\<le> n\n  n - m = int (Suc i)\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<le> n; n - m = int 0\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m \\<le> n; n - m = int i\\<rbrakk>\n                   \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     (MkI\\<cdot>n) ++\n                                     intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                                     intsFrom\\<cdot>(MkI\\<cdot>m);\n        m \\<le> n; n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?m \\<le> ?n; ?n - ?m = int i\\<rbrakk>\n  \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>?m)\\<cdot>(MkI\\<cdot>?n) ++\n                    intsFrom\\<cdot>(MkI\\<cdot>?n + 1) =\n                    intsFrom\\<cdot>(MkI\\<cdot>?m)\n  m \\<le> n\n  n - m = int (Suc i)", "have \"m + 1 \\<le> n\" and \"n - (m + 1) = int i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?m \\<le> ?n; ?n - ?m = int i\\<rbrakk>\n  \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>?m)\\<cdot>(MkI\\<cdot>?n) ++\n                    intsFrom\\<cdot>(MkI\\<cdot>?n + 1) =\n                    intsFrom\\<cdot>(MkI\\<cdot>?m)\n  m \\<le> n\n  n - m = int (Suc i)\n\ngoal (1 subgoal):\n 1. m + 1 \\<le> n &&& n - (m + 1) = int i", "by simp_all"], ["proof (state)\nthis:\n  m + 1 \\<le> n\n  n - (m + 1) = int i\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<le> n; n - m = int 0\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m \\<le> n; n - m = int i\\<rbrakk>\n                   \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     (MkI\\<cdot>n) ++\n                                     intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                                     intsFrom\\<cdot>(MkI\\<cdot>m);\n        m \\<le> n; n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)", "from Suc(1) [OF this]"], ["proof (chain)\npicking this:\n  upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n  intsFrom\\<cdot>(MkI\\<cdot>(m + 1))", "have IH: \"?u (m+1) n ++ ?i (n+1) = ?i (m+1)\""], ["proof (prove)\nusing this:\n  upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n  intsFrom\\<cdot>(MkI\\<cdot>(m + 1))\n\ngoal (1 subgoal):\n 1. upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n) ++\n    intsFrom\\<cdot>(MkI\\<cdot>(n + 1)) =\n    intsFrom\\<cdot>(MkI\\<cdot>(m + 1))", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>(n + 1)) =\n  intsFrom\\<cdot>(MkI\\<cdot>(m + 1))\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<le> n; n - m = int 0\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m \\<le> n; n - m = int i\\<rbrakk>\n                   \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     (MkI\\<cdot>n) ++\n                                     intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                                     intsFrom\\<cdot>(MkI\\<cdot>m);\n        m \\<le> n; n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)", "from \\<open>m + 1 \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  m + 1 \\<le> n", "have \"m \\<le> n\""], ["proof (prove)\nusing this:\n  m + 1 \\<le> n\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by simp"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<le> n; n - m = int 0\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m \\<le> n; n - m = int i\\<rbrakk>\n                   \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     (MkI\\<cdot>n) ++\n                                     intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                                     intsFrom\\<cdot>(MkI\\<cdot>m);\n        m \\<le> n; n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)", "then"], ["proof (chain)\npicking this:\n  m \\<le> n", "have \"?u m n ++ ?i (n+1) = (MkI\\<cdot>m : ?u (m+1) n) ++ ?i (n+1)\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n    intsFrom\\<cdot>(MkI\\<cdot>(n + 1)) =\n    (MkI\\<cdot>m : upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) ++\n    intsFrom\\<cdot>(MkI\\<cdot>(n + 1))", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>(n + 1)) =\n  (MkI\\<cdot>m : upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) ++\n  intsFrom\\<cdot>(MkI\\<cdot>(n + 1))\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<le> n; n - m = int 0\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m \\<le> n; n - m = int i\\<rbrakk>\n                   \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     (MkI\\<cdot>n) ++\n                                     intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                                     intsFrom\\<cdot>(MkI\\<cdot>m);\n        m \\<le> n; n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)", "also"], ["proof (state)\nthis:\n  upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>(n + 1)) =\n  (MkI\\<cdot>m : upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) ++\n  intsFrom\\<cdot>(MkI\\<cdot>(n + 1))\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<le> n; n - m = int 0\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m \\<le> n; n - m = int i\\<rbrakk>\n                   \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     (MkI\\<cdot>n) ++\n                                     intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                                     intsFrom\\<cdot>(MkI\\<cdot>m);\n        m \\<le> n; n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)", "have \"\\<dots> = MkI\\<cdot>m : ?i (m+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MkI\\<cdot>m : upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) ++\n    intsFrom\\<cdot>(MkI\\<cdot>(n + 1)) =\n    MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))", "by (simp add: IH)"], ["proof (state)\nthis:\n  (MkI\\<cdot>m : upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) ++\n  intsFrom\\<cdot>(MkI\\<cdot>(n + 1)) =\n  MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<le> n; n - m = int 0\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>m \\<le> n; n - m = int i\\<rbrakk>\n                   \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     (MkI\\<cdot>n) ++\n                                     intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                                     intsFrom\\<cdot>(MkI\\<cdot>m);\n        m \\<le> n; n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)", "finally"], ["proof (chain)\npicking this:\n  upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>(n + 1)) =\n  MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))", "show ?case"], ["proof (prove)\nusing this:\n  upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>(n + 1)) =\n  MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))\n\ngoal (1 subgoal):\n 1. upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n    intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n    intsFrom\\<cdot>(MkI\\<cdot>m)", "by (subst (2) intsFrom.simps) (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n  intsFrom\\<cdot>(MkI\\<cdot>m)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<le> n; n - m = int 0\\<rbrakk>\n       \\<Longrightarrow> upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n                         intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n                         intsFrom\\<cdot>(MkI\\<cdot>m)", "qed (subst (2) intsFrom.simps, simp add: one_Integer_def)"], ["proof (state)\nthis:\n  upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n  intsFrom\\<cdot>(MkI\\<cdot>m)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n       intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n       intsFrom\\<cdot>(MkI\\<cdot>m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n       intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n       intsFrom\\<cdot>(MkI\\<cdot>m)", "case (neg i)"], ["proof (state)\nthis:\n  n - m = - int (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n       intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n       intsFrom\\<cdot>(MkI\\<cdot>m)", "then"], ["proof (chain)\npicking this:\n  n - m = - int (Suc i)", "have \"n < m\""], ["proof (prove)\nusing this:\n  n - m = - int (Suc i)\n\ngoal (1 subgoal):\n 1. n < m", "by simp"], ["proof (state)\nthis:\n  n < m\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n       intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n       intsFrom\\<cdot>(MkI\\<cdot>m)", "with assms"], ["proof (chain)\npicking this:\n  m \\<le> n\n  n < m", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<le> n\n  n < m\n\ngoal (1 subgoal):\n 1. upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n    intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n    intsFrom\\<cdot>(MkI\\<cdot>m)", "by simp"], ["proof (state)\nthis:\n  upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>n + 1) =\n  intsFrom\\<cdot>(MkI\\<cdot>m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_upto [simp]:\n  \"set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) = {MkI\\<cdot>i | i. m \\<le> i \\<and> i \\<le> n}\"\n  (is \"set (?u m n) = ?R m n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n    {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "proof (cases \"n - m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       n - m = int na \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "case (nonneg i)"], ["proof (state)\nthis:\n  n - m = int i\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       n - m = int na \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "then"], ["proof (chain)\npicking this:\n  n - m = int i", "show ?thesis"], ["proof (prove)\nusing this:\n  n - m = int i\n\ngoal (1 subgoal):\n 1. set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n    {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "proof (induct i arbitrary: m n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int i \\<Longrightarrow>\n                   set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n                   {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n};\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                              (MkI\\<cdot>n)) =\n                         {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "case (Suc i)"], ["proof (state)\nthis:\n  ?n - ?m = int i \\<Longrightarrow>\n  set (upto\\<cdot>(MkI\\<cdot>?m)\\<cdot>(MkI\\<cdot>?n)) =\n  {MkI\\<cdot>i |i. ?m \\<le> i \\<and> i \\<le> ?n}\n  n - m = int (Suc i)\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int i \\<Longrightarrow>\n                   set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n                   {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n};\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                              (MkI\\<cdot>n)) =\n                         {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "then"], ["proof (chain)\npicking this:\n  ?n - ?m = int i \\<Longrightarrow>\n  set (upto\\<cdot>(MkI\\<cdot>?m)\\<cdot>(MkI\\<cdot>?n)) =\n  {MkI\\<cdot>i |i. ?m \\<le> i \\<and> i \\<le> ?n}\n  n - m = int (Suc i)", "have *: \"n - (m + 1) = int i\""], ["proof (prove)\nusing this:\n  ?n - ?m = int i \\<Longrightarrow>\n  set (upto\\<cdot>(MkI\\<cdot>?m)\\<cdot>(MkI\\<cdot>?n)) =\n  {MkI\\<cdot>i |i. ?m \\<le> i \\<and> i \\<le> ?n}\n  n - m = int (Suc i)\n\ngoal (1 subgoal):\n 1. n - (m + 1) = int i", "by simp"], ["proof (state)\nthis:\n  n - (m + 1) = int i\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int i \\<Longrightarrow>\n                   set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n                   {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n};\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                              (MkI\\<cdot>n)) =\n                         {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "from Suc(1) [OF *]"], ["proof (chain)\npicking this:\n  set (upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) =\n  {MkI\\<cdot>i |i. m + 1 \\<le> i \\<and> i \\<le> n}", "have IH: \"set (?u (m+1) n) = ?R (m+1) n\""], ["proof (prove)\nusing this:\n  set (upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) =\n  {MkI\\<cdot>i |i. m + 1 \\<le> i \\<and> i \\<le> n}\n\ngoal (1 subgoal):\n 1. set (upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) =\n    {MkI\\<cdot>i |i. m + 1 \\<le> i \\<and> i \\<le> n}", "."], ["proof (state)\nthis:\n  set (upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) =\n  {MkI\\<cdot>i |i. m + 1 \\<le> i \\<and> i \\<le> n}\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int i \\<Longrightarrow>\n                   set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n                   {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n};\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                              (MkI\\<cdot>n)) =\n                         {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "from *"], ["proof (chain)\npicking this:\n  n - (m + 1) = int i", "have \"m \\<le> n\""], ["proof (prove)\nusing this:\n  n - (m + 1) = int i\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by simp"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int i \\<Longrightarrow>\n                   set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n                   {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n};\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                              (MkI\\<cdot>n)) =\n                         {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "then"], ["proof (chain)\npicking this:\n  m \\<le> n", "have \"set (?u m n) = set (MkI\\<cdot>m : ?u (m+1) n)\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n    set (MkI\\<cdot>m : upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n))", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n  set (MkI\\<cdot>m : upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n))\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int i \\<Longrightarrow>\n                   set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n                   {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n};\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                              (MkI\\<cdot>n)) =\n                         {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "also"], ["proof (state)\nthis:\n  set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n  set (MkI\\<cdot>m : upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n))\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int i \\<Longrightarrow>\n                   set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n                   {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n};\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                              (MkI\\<cdot>n)) =\n                         {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "have \"\\<dots> = insert (MkI\\<cdot>m) (?R (m+1) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (MkI\\<cdot>m : upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) =\n    insert (MkI\\<cdot>m) {MkI\\<cdot>i |i. m + 1 \\<le> i \\<and> i \\<le> n}", "by (simp add: IH)"], ["proof (state)\nthis:\n  set (MkI\\<cdot>m : upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) =\n  insert (MkI\\<cdot>m) {MkI\\<cdot>i |i. m + 1 \\<le> i \\<and> i \\<le> n}\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int i \\<Longrightarrow>\n                   set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n                   {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n};\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                              (MkI\\<cdot>n)) =\n                         {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "also"], ["proof (state)\nthis:\n  set (MkI\\<cdot>m : upto\\<cdot>(MkI\\<cdot>(m + 1))\\<cdot>(MkI\\<cdot>n)) =\n  insert (MkI\\<cdot>m) {MkI\\<cdot>i |i. m + 1 \\<le> i \\<and> i \\<le> n}\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int i \\<Longrightarrow>\n                   set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n                   {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n};\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                              (MkI\\<cdot>n)) =\n                         {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "have \"\\<dots> = ?R m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (MkI\\<cdot>m) {MkI\\<cdot>i |i. m + 1 \\<le> i \\<and> i \\<le> n} =\n    {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "using \\<open>m \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. insert (MkI\\<cdot>m) {MkI\\<cdot>i |i. m + 1 \\<le> i \\<and> i \\<le> n} =\n    {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "by auto"], ["proof (state)\nthis:\n  insert (MkI\\<cdot>m) {MkI\\<cdot>i |i. m + 1 \\<le> i \\<and> i \\<le> n} =\n  {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n 2. \\<And>i m n.\n       \\<lbrakk>\\<And>m n.\n                   n - m = int i \\<Longrightarrow>\n                   set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n                   {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n};\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                              (MkI\\<cdot>n)) =\n                         {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "finally"], ["proof (chain)\npicking this:\n  set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n  {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "show ?case"], ["proof (prove)\nusing this:\n  set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n  {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n\ngoal (1 subgoal):\n 1. set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n    {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "."], ["proof (state)\nthis:\n  set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n  {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       n - m = int 0 \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "qed (force simp: one_Integer_def)"], ["proof (state)\nthis:\n  set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n  {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) =\n       {MkI\\<cdot>i |i. m \\<le> i \\<and> i \\<le> n}", "qed simp"], ["", "lemma Nil_append_iff [iff]:\n  \"xs ++ ys = [] \\<longleftrightarrow> xs = [] \\<and> ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs ++ ys = []) = (xs = [] \\<and> ys = [])", "by (induct xs) simp_all"], ["", "text \\<open>This version of definedness rule for Nil is made necessary by\nthe reorient simproc.\\<close>"], ["", "lemma bottom_neq_Nil [simp]: \"\\<bottom> \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<noteq> []", "by simp"], ["", "text \\<open>Simproc to rewrite @{term \"Nil = x\"} to @{term \"x = Nil\"}.\\<close>"], ["", "setup \\<open>\n  Reorient_Proc.add\n    (fn Const(@{const_name Nil}, _) => true | _ => false)\n\\<close>"], ["", "simproc_setup reorient_Nil (\"Nil = x\") = Reorient_Proc.proc"], ["", "lemma set_append [simp]:\n  assumes \"finite_list xs\"\n  shows \"set (xs ++ ys) = set xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xs ++ ys) = set xs \\<union> set ys", "using assms"], ["proof (prove)\nusing this:\n  finite_list xs\n\ngoal (1 subgoal):\n 1. set (xs ++ ys) = set xs \\<union> set ys", "by (induct) simp_all"], ["", "lemma distinct_Cons [simp]:\n  \"distinct (x : xs) \\<longleftrightarrow> distinct xs \\<and> x \\<notin> set xs\"\n  (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (x : xs) = (distinct xs \\<and> x \\<notin> set xs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (x : xs) \\<Longrightarrow> distinct xs \\<and> x \\<notin> set xs\n 2. distinct xs \\<and> x \\<notin> set xs \\<Longrightarrow> distinct (x : xs)", "assume ?l"], ["proof (state)\nthis:\n  distinct (x : xs)\n\ngoal (2 subgoals):\n 1. distinct (x : xs) \\<Longrightarrow> distinct xs \\<and> x \\<notin> set xs\n 2. distinct xs \\<and> x \\<notin> set xs \\<Longrightarrow> distinct (x : xs)", "then"], ["proof (chain)\npicking this:\n  distinct (x : xs)", "show ?r"], ["proof (prove)\nusing this:\n  distinct (x : xs)\n\ngoal (1 subgoal):\n 1. distinct xs \\<and> x \\<notin> set xs", "by (cases) simp_all"], ["proof (state)\nthis:\n  distinct xs \\<and> x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. distinct xs \\<and> x \\<notin> set xs \\<Longrightarrow> distinct (x : xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct xs \\<and> x \\<notin> set xs \\<Longrightarrow> distinct (x : xs)", "assume ?r"], ["proof (state)\nthis:\n  distinct xs \\<and> x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. distinct xs \\<and> x \\<notin> set xs \\<Longrightarrow> distinct (x : xs)", "then"], ["proof (chain)\npicking this:\n  distinct xs \\<and> x \\<notin> set xs", "show ?l"], ["proof (prove)\nusing this:\n  distinct xs \\<and> x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. distinct (x : xs)", "by auto"], ["proof (state)\nthis:\n  distinct (x : xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_list_append [iff]:\n  \"finite_list (xs ++ ys) \\<longleftrightarrow> finite_list xs \\<and> finite_list ys\"\n  (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_list (xs ++ ys) = (finite_list xs \\<and> finite_list ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite_list (xs ++ ys) \\<Longrightarrow>\n    finite_list xs \\<and> finite_list ys\n 2. finite_list xs \\<and> finite_list ys \\<Longrightarrow>\n    finite_list (xs ++ ys)", "presume \"finite_list xs\" and \"finite_list ys\""], ["proof (state)\nthis:\n  finite_list xs\n  finite_list ys\n\ngoal (2 subgoals):\n 1. finite_list (xs ++ ys) \\<Longrightarrow>\n    finite_list xs \\<and> finite_list ys\n 2. finite_list xs \\<and> finite_list ys \\<Longrightarrow>\n    finite_list (xs ++ ys)", "then"], ["proof (chain)\npicking this:\n  finite_list xs\n  finite_list ys", "show ?l"], ["proof (prove)\nusing this:\n  finite_list xs\n  finite_list ys\n\ngoal (1 subgoal):\n 1. finite_list (xs ++ ys)", "by (induct) simp_all"], ["proof (state)\nthis:\n  finite_list (xs ++ ys)\n\ngoal (3 subgoals):\n 1. finite_list (xs ++ ys) \\<Longrightarrow>\n    finite_list xs \\<and> finite_list ys\n 2. finite_list xs \\<and> finite_list ys \\<Longrightarrow> finite_list xs\n 3. finite_list xs \\<and> finite_list ys \\<Longrightarrow> finite_list ys", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. finite_list (xs ++ ys) \\<Longrightarrow>\n    finite_list xs \\<and> finite_list ys\n 2. finite_list xs \\<and> finite_list ys \\<Longrightarrow> finite_list xs\n 3. finite_list xs \\<and> finite_list ys \\<Longrightarrow> finite_list ys", "assume \"?l\""], ["proof (state)\nthis:\n  finite_list (xs ++ ys)\n\ngoal (3 subgoals):\n 1. finite_list (xs ++ ys) \\<Longrightarrow>\n    finite_list xs \\<and> finite_list ys\n 2. finite_list xs \\<and> finite_list ys \\<Longrightarrow> finite_list xs\n 3. finite_list xs \\<and> finite_list ys \\<Longrightarrow> finite_list ys", "then"], ["proof (chain)\npicking this:\n  finite_list (xs ++ ys)", "show \"?r\""], ["proof (prove)\nusing this:\n  finite_list (xs ++ ys)\n\ngoal (1 subgoal):\n 1. finite_list xs \\<and> finite_list ys", "proof (induct \"xs ++ ys\" arbitrary: xs ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       [] = xs ++ ys \\<Longrightarrow> finite_list xs \\<and> finite_list ys\n 2. \\<And>x xs xsa ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa ys.\n           xs = xsa ++ ys \\<Longrightarrow>\n           finite_list xsa \\<and> finite_list ys;\n        x : xs = xsa ++ ys\\<rbrakk>\n       \\<Longrightarrow> finite_list xsa \\<and> finite_list ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  finite_list xsa__\n  xsa__ = ?xs ++ ?ys \\<Longrightarrow>\n  finite_list ?xs \\<and> finite_list ?ys\n  x : xsa__ = xs ++ ys\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       [] = xs ++ ys \\<Longrightarrow> finite_list xs \\<and> finite_list ys\n 2. \\<And>x xs xsa ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa ys.\n           xs = xsa ++ ys \\<Longrightarrow>\n           finite_list xsa \\<and> finite_list ys;\n        x : xs = xsa ++ ys\\<rbrakk>\n       \\<Longrightarrow> finite_list xsa \\<and> finite_list ys", "then"], ["proof (chain)\npicking this:\n  finite_list xsa__\n  xsa__ = ?xs ++ ?ys \\<Longrightarrow>\n  finite_list ?xs \\<and> finite_list ?ys\n  x : xsa__ = xs ++ ys", "show ?case"], ["proof (prove)\nusing this:\n  finite_list xsa__\n  xsa__ = ?xs ++ ?ys \\<Longrightarrow>\n  finite_list ?xs \\<and> finite_list ?ys\n  x : xsa__ = xs ++ ys\n\ngoal (1 subgoal):\n 1. finite_list xs \\<and> finite_list ys", "by (cases xs) auto"], ["proof (state)\nthis:\n  finite_list xs \\<and> finite_list ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       [] = xs ++ ys \\<Longrightarrow> finite_list xs \\<and> finite_list ys", "qed simp"], ["proof (state)\nthis:\n  finite_list xs \\<and> finite_list ys\n\ngoal (2 subgoals):\n 1. finite_list xs \\<and> finite_list ys \\<Longrightarrow> finite_list xs\n 2. finite_list xs \\<and> finite_list ys \\<Longrightarrow> finite_list ys", "qed simp_all"], ["", "lemma distinct_append [simp]:\n  assumes \"finite_list (xs ++ ys)\"\n  shows \"distinct (xs ++ ys) \\<longleftrightarrow> distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {}\"\n    (is \"?P xs ys\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})", "using assms"], ["proof (prove)\nusing this:\n  finite_list (xs ++ ys)\n\ngoal (1 subgoal):\n 1. distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})", "proof (induct \"xs ++ ys\" arbitrary: xs ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       [] = xs ++ ys \\<Longrightarrow>\n       distinct (xs ++ ys) =\n       (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n 2. \\<And>x xs xsa ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa ys.\n           xs = xsa ++ ys \\<Longrightarrow>\n           distinct (xsa ++ ys) =\n           (distinct xsa \\<and>\n            distinct ys \\<and> set xsa \\<inter> set ys = {});\n        x : xs = xsa ++ ys\\<rbrakk>\n       \\<Longrightarrow> distinct (xsa ++ ys) =\n                         (distinct xsa \\<and>\n                          distinct ys \\<and> set xsa \\<inter> set ys = {})", "case (Cons z zs)"], ["proof (state)\nthis:\n  finite_list zs\n  zs = ?xs ++ ?ys \\<Longrightarrow>\n  distinct (?xs ++ ?ys) =\n  (distinct ?xs \\<and> distinct ?ys \\<and> set ?xs \\<inter> set ?ys = {})\n  z : zs = xs ++ ys\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       [] = xs ++ ys \\<Longrightarrow>\n       distinct (xs ++ ys) =\n       (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n 2. \\<And>x xs xsa ys.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa ys.\n           xs = xsa ++ ys \\<Longrightarrow>\n           distinct (xsa ++ ys) =\n           (distinct xsa \\<and>\n            distinct ys \\<and> set xsa \\<inter> set ys = {});\n        x : xs = xsa ++ ys\\<rbrakk>\n       \\<Longrightarrow> distinct (xsa ++ ys) =\n                         (distinct xsa \\<and>\n                          distinct ys \\<and> set xsa \\<inter> set ys = {})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})", "proof (cases xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. xs = \\<bottom> \\<Longrightarrow>\n    distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n 2. xs = [] \\<Longrightarrow>\n    distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n 3. \\<And>a list.\n       xs = a : list \\<Longrightarrow>\n       distinct (xs ++ ys) =\n       (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})", "note Cons' = Cons"], ["proof (state)\nthis:\n  finite_list zs\n  zs = ?xs ++ ?ys \\<Longrightarrow>\n  distinct (?xs ++ ?ys) =\n  (distinct ?xs \\<and> distinct ?ys \\<and> set ?xs \\<inter> set ?ys = {})\n  z : zs = xs ++ ys\n\ngoal (3 subgoals):\n 1. xs = \\<bottom> \\<Longrightarrow>\n    distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n 2. xs = [] \\<Longrightarrow>\n    distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n 3. \\<And>a list.\n       xs = a : list \\<Longrightarrow>\n       distinct (xs ++ ys) =\n       (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})", "case (Cons u us)"], ["proof (state)\nthis:\n  xs = u : us\n\ngoal (3 subgoals):\n 1. xs = \\<bottom> \\<Longrightarrow>\n    distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n 2. xs = [] \\<Longrightarrow>\n    distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n 3. \\<And>a list.\n       xs = a : list \\<Longrightarrow>\n       distinct (xs ++ ys) =\n       (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})", "with Cons'"], ["proof (chain)\npicking this:\n  finite_list zs\n  zs = ?xs ++ ?ys \\<Longrightarrow>\n  distinct (?xs ++ ?ys) =\n  (distinct ?xs \\<and> distinct ?ys \\<and> set ?xs \\<inter> set ?ys = {})\n  z : zs = xs ++ ys\n  xs = u : us", "have \"finite_list us\"\n      and [simp]: \"zs = us ++ ys\" \"?P us ys\""], ["proof (prove)\nusing this:\n  finite_list zs\n  zs = ?xs ++ ?ys \\<Longrightarrow>\n  distinct (?xs ++ ?ys) =\n  (distinct ?xs \\<and> distinct ?ys \\<and> set ?xs \\<inter> set ?ys = {})\n  z : zs = xs ++ ys\n  xs = u : us\n\ngoal (1 subgoal):\n 1. finite_list us &&&\n    zs = us ++ ys &&&\n    distinct (us ++ ys) =\n    (distinct us \\<and> distinct ys \\<and> set us \\<inter> set ys = {})", "by simp_all"], ["proof (state)\nthis:\n  finite_list us\n  zs = us ++ ys\n  distinct (us ++ ys) =\n  (distinct us \\<and> distinct ys \\<and> set us \\<inter> set ys = {})\n\ngoal (3 subgoals):\n 1. xs = \\<bottom> \\<Longrightarrow>\n    distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n 2. xs = [] \\<Longrightarrow>\n    distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n 3. \\<And>a list.\n       xs = a : list \\<Longrightarrow>\n       distinct (xs ++ ys) =\n       (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})", "then"], ["proof (chain)\npicking this:\n  finite_list us\n  zs = us ++ ys\n  distinct (us ++ ys) =\n  (distinct us \\<and> distinct ys \\<and> set us \\<inter> set ys = {})", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_list us\n  zs = us ++ ys\n  distinct (us ++ ys) =\n  (distinct us \\<and> distinct ys \\<and> set us \\<inter> set ys = {})\n\ngoal (1 subgoal):\n 1. distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})", "by (auto simp: Cons)"], ["proof (state)\nthis:\n  distinct (xs ++ ys) =\n  (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n\ngoal (2 subgoals):\n 1. xs = \\<bottom> \\<Longrightarrow>\n    distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n 2. xs = [] \\<Longrightarrow>\n    distinct (xs ++ ys) =\n    (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})", "qed (insert Cons, simp_all)"], ["proof (state)\nthis:\n  distinct (xs ++ ys) =\n  (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       [] = xs ++ ys \\<Longrightarrow>\n       distinct (xs ++ ys) =\n       (distinct xs \\<and> distinct ys \\<and> set xs \\<inter> set ys = {})", "qed simp"], ["", "lemma finite_set [simp]:\n  assumes \"distinct xs\"\n  shows \"finite (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. finite (set xs)", "by induct auto"], ["", "lemma distinct_card:\n  assumes \"distinct xs\"\n  shows \"MkI\\<cdot>(int (card (set xs))) = length\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI\\<cdot>(int (card (set xs))) = length\\<cdot>xs", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. MkI\\<cdot>(int (card (set xs))) = length\\<cdot>xs", "by (induct)\n     (simp_all add: zero_Integer_def plus_MkI_MkI [symmetric] one_Integer_def ac_simps)"], ["", "lemma set_delete [simp]:\n  fixes xs :: \"['a::Eq_eq]\"\n  assumes \"distinct xs\"\n    and \"\\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"set (delete\\<cdot>a\\<cdot>xs) = set xs - {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (delete\\<cdot>a\\<cdot>xs) = set xs - {a}", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. set (delete\\<cdot>a\\<cdot>xs) = set xs - {a}", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n    set (delete\\<cdot>a\\<cdot>[]) = set [] - {a}\n 2. \\<And>x xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>x\\<in>set xs.\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n        set (delete\\<cdot>a\\<cdot>xs) = set xs - {a};\n        x \\<notin> set xs;\n        \\<forall>x\\<in>set (x : xs).\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (delete\\<cdot>a\\<cdot>(x : xs)) =\n                         set (x : xs) - {a}", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct xs\n  \\<forall>x\\<in>set xs.\n     eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n  set (delete\\<cdot>a\\<cdot>xs) = set xs - {a}\n  x \\<notin> set xs\n  \\<forall>x\\<in>set (x : xs). eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n    set (delete\\<cdot>a\\<cdot>[]) = set [] - {a}\n 2. \\<And>x xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>x\\<in>set xs.\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n        set (delete\\<cdot>a\\<cdot>xs) = set xs - {a};\n        x \\<notin> set xs;\n        \\<forall>x\\<in>set (x : xs).\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (delete\\<cdot>a\\<cdot>(x : xs)) =\n                         set (x : xs) - {a}", "then"], ["proof (chain)\npicking this:\n  distinct xs\n  \\<forall>x\\<in>set xs.\n     eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n  set (delete\\<cdot>a\\<cdot>xs) = set xs - {a}\n  x \\<notin> set xs\n  \\<forall>x\\<in>set (x : xs). eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>x\\<in>set xs.\n     eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n  set (delete\\<cdot>a\\<cdot>xs) = set xs - {a}\n  x \\<notin> set xs\n  \\<forall>x\\<in>set (x : xs). eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. set (delete\\<cdot>a\\<cdot>(x : xs)) = set (x : xs) - {a}", "by (cases \"eq\\<cdot>a\\<cdot>x\", force+)"], ["proof (state)\nthis:\n  set (delete\\<cdot>a\\<cdot>(x : xs)) = set (x : xs) - {a}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set [].\n       eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n    set (delete\\<cdot>a\\<cdot>[]) = set [] - {a}", "qed simp"], ["", "lemma distinct_delete [simp]:\n  fixes xs :: \"['a::Eq_eq]\"\n  assumes \"distinct xs\"\n    and \"\\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"distinct (delete\\<cdot>a\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (delete\\<cdot>a\\<cdot>xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. distinct (delete\\<cdot>a\\<cdot>xs)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n    distinct (delete\\<cdot>a\\<cdot>[])\n 2. \\<And>x xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>x\\<in>set xs.\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n        distinct (delete\\<cdot>a\\<cdot>xs);\n        x \\<notin> set xs;\n        \\<forall>x\\<in>set (x : xs).\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> distinct (delete\\<cdot>a\\<cdot>(x : xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct xs\n  \\<forall>x\\<in>set xs.\n     eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n  distinct (delete\\<cdot>a\\<cdot>xs)\n  x \\<notin> set xs\n  \\<forall>x\\<in>set (x : xs). eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n    distinct (delete\\<cdot>a\\<cdot>[])\n 2. \\<And>x xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>x\\<in>set xs.\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n        distinct (delete\\<cdot>a\\<cdot>xs);\n        x \\<notin> set xs;\n        \\<forall>x\\<in>set (x : xs).\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> distinct (delete\\<cdot>a\\<cdot>(x : xs))", "then"], ["proof (chain)\npicking this:\n  distinct xs\n  \\<forall>x\\<in>set xs.\n     eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n  distinct (delete\\<cdot>a\\<cdot>xs)\n  x \\<notin> set xs\n  \\<forall>x\\<in>set (x : xs). eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>x\\<in>set xs.\n     eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n  distinct (delete\\<cdot>a\\<cdot>xs)\n  x \\<notin> set xs\n  \\<forall>x\\<in>set (x : xs). eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. distinct (delete\\<cdot>a\\<cdot>(x : xs))", "by (cases \"eq\\<cdot>a\\<cdot>x\", force+)"], ["proof (state)\nthis:\n  distinct (delete\\<cdot>a\\<cdot>(x : xs))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set [].\n       eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n    distinct (delete\\<cdot>a\\<cdot>[])", "qed simp"], ["", "lemma set_diff [simp]:\n  fixes xs ys :: \"['a::Eq_eq]\"\n  assumes \"distinct ys\" and \"distinct xs\"\n    and \"\\<forall>a\\<in>set ys. \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"set (xs \\\\\\\\ ys) = set xs - set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xs \\\\ ys) = set xs - set ys", "using assms"], ["proof (prove)\nusing this:\n  distinct ys\n  distinct xs\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. set (xs \\\\ ys) = set xs - set ys", "proof (induct arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>a\\<in>set [].\n           \\<forall>x\\<in>set xs.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xs \\\\ []) = set xs - set []\n 2. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "case Nil"], ["proof (state)\nthis:\n  distinct xs\n  \\<forall>a\\<in>set [].\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>a\\<in>set [].\n           \\<forall>x\\<in>set xs.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xs \\\\ []) = set xs - set []\n 2. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "then"], ["proof (chain)\npicking this:\n  distinct xs\n  \\<forall>a\\<in>set [].\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>a\\<in>set [].\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. set (xs \\\\ []) = set xs - set []", "by (induct xs rule: distinct.induct) simp_all"], ["proof (state)\nthis:\n  set (xs \\\\ []) = set xs - set []\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "case (Cons y ys)"], ["proof (state)\nthis:\n  distinct ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> set (?xs \\\\ ys) = set ?xs - set ys\n  y \\<notin> set ys\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "let ?xs = \"delete\\<cdot>y\\<cdot>xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "from Cons"], ["proof (chain)\npicking this:\n  distinct ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> set (?xs \\\\ ys) = set ?xs - set ys\n  y \\<notin> set ys\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>", "have *: \"\\<forall>x\\<in>set xs. eq\\<cdot>y\\<cdot>x \\<noteq> \\<bottom>\""], ["proof (prove)\nusing this:\n  distinct ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> set (?xs \\\\ ys) = set ?xs - set ys\n  y \\<notin> set ys\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. eq\\<cdot>y\\<cdot>x \\<noteq> \\<bottom>", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. eq\\<cdot>y\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "from set_delete [OF \\<open>distinct xs\\<close> this]"], ["proof (chain)\npicking this:\n  set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}", "have **: \"set ?xs = set xs - {y}\""], ["proof (prove)\nusing this:\n  set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}\n\ngoal (1 subgoal):\n 1. set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}", "."], ["proof (state)\nthis:\n  set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "with Cons"], ["proof (chain)\npicking this:\n  distinct ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> set (?xs \\\\ ys) = set ?xs - set ys\n  y \\<notin> set ys\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}", "have \"\\<forall>a\\<in>set ys. \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\""], ["proof (prove)\nusing this:\n  distinct ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> set (?xs \\\\ ys) = set ?xs - set ys\n  y \\<notin> set ys\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set ys.\n       \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n          eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n        eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "moreover"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n        eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "from * and \\<open>distinct xs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set xs. eq\\<cdot>y\\<cdot>x \\<noteq> \\<bottom>\n  distinct xs", "have \"distinct ?xs\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. eq\\<cdot>y\\<cdot>x \\<noteq> \\<bottom>\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct (delete\\<cdot>y\\<cdot>xs)", "by simp"], ["proof (state)\nthis:\n  distinct (delete\\<cdot>y\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n        eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  distinct (delete\\<cdot>y\\<cdot>xs)", "have \"set (?xs \\\\\\\\ ys) = set ?xs - set ys\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n        eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  distinct (delete\\<cdot>y\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. set (delete\\<cdot>y\\<cdot>xs \\\\ ys) =\n    set (delete\\<cdot>y\\<cdot>xs) - set ys", "using Cons"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n        eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  distinct (delete\\<cdot>y\\<cdot>xs)\n  distinct ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> set (?xs \\\\ ys) = set ?xs - set ys\n  y \\<notin> set ys\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. set (delete\\<cdot>y\\<cdot>xs \\\\ ys) =\n    set (delete\\<cdot>y\\<cdot>xs) - set ys", "by blast"], ["proof (state)\nthis:\n  set (delete\\<cdot>y\\<cdot>xs \\\\ ys) =\n  set (delete\\<cdot>y\\<cdot>xs) - set ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>distinct xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> set (xsa \\\\ xs) = set xsa - set xs;\n        x \\<notin> set xs; distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (xsa \\\\ (x : xs)) = set xsa - set (x : xs)", "then"], ["proof (chain)\npicking this:\n  set (delete\\<cdot>y\\<cdot>xs \\\\ ys) =\n  set (delete\\<cdot>y\\<cdot>xs) - set ys", "show ?case"], ["proof (prove)\nusing this:\n  set (delete\\<cdot>y\\<cdot>xs \\\\ ys) =\n  set (delete\\<cdot>y\\<cdot>xs) - set ys\n\ngoal (1 subgoal):\n 1. set (xs \\\\ (y : ys)) = set xs - set (y : ys)", "by (force simp: **)"], ["proof (state)\nthis:\n  set (xs \\\\ (y : ys)) = set xs - set (y : ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_delete_filter:\n  fixes xs :: \"['a::Eq_eq]\"\n  assumes \"distinct xs\"\n    and \"\\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"delete\\<cdot>a\\<cdot>xs = filter\\<cdot>(\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete\\<cdot>a\\<cdot>xs =\n    filter\\<cdot>(\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>xs", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. delete\\<cdot>a\\<cdot>xs =\n    filter\\<cdot>(\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>xs", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>[] =\n    filter\\<cdot>(Abs_cfun (Rep_cfun (neq\\<cdot>a)))\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>x\\<in>set xs.\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n        delete\\<cdot>a\\<cdot>xs =\n        filter\\<cdot>(Abs_cfun (Rep_cfun (neq\\<cdot>a)))\\<cdot>xs;\n        x \\<notin> set xs;\n        \\<forall>x\\<in>set (x : xs).\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> delete\\<cdot>a\\<cdot>(x : xs) =\n                         filter\\<cdot>\n                         (Abs_cfun (Rep_cfun (neq\\<cdot>a)))\\<cdot>\n                         (x : xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct xs\n  \\<forall>x\\<in>set xs.\n     eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n  delete\\<cdot>a\\<cdot>xs =\n  filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>xs\n  x \\<notin> set xs\n  \\<forall>x\\<in>set (x : xs). eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>[] =\n    filter\\<cdot>(Abs_cfun (Rep_cfun (neq\\<cdot>a)))\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>x\\<in>set xs.\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n        delete\\<cdot>a\\<cdot>xs =\n        filter\\<cdot>(Abs_cfun (Rep_cfun (neq\\<cdot>a)))\\<cdot>xs;\n        x \\<notin> set xs;\n        \\<forall>x\\<in>set (x : xs).\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> delete\\<cdot>a\\<cdot>(x : xs) =\n                         filter\\<cdot>\n                         (Abs_cfun (Rep_cfun (neq\\<cdot>a)))\\<cdot>\n                         (x : xs)", "then"], ["proof (chain)\npicking this:\n  distinct xs\n  \\<forall>x\\<in>set xs.\n     eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n  delete\\<cdot>a\\<cdot>xs =\n  filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>xs\n  x \\<notin> set xs\n  \\<forall>x\\<in>set (x : xs). eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>", "have IH: \"delete\\<cdot>a\\<cdot>xs = filter\\<cdot>(\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>xs\""], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>x\\<in>set xs.\n     eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n  delete\\<cdot>a\\<cdot>xs =\n  filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>xs\n  x \\<notin> set xs\n  \\<forall>x\\<in>set (x : xs). eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. delete\\<cdot>a\\<cdot>xs =\n    filter\\<cdot>(\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>xs", "by simp"], ["proof (state)\nthis:\n  delete\\<cdot>a\\<cdot>xs =\n  filter\\<cdot>(\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>xs\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>[] =\n    filter\\<cdot>(Abs_cfun (Rep_cfun (neq\\<cdot>a)))\\<cdot>[]\n 2. \\<And>x xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>x\\<in>set xs.\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n        delete\\<cdot>a\\<cdot>xs =\n        filter\\<cdot>(Abs_cfun (Rep_cfun (neq\\<cdot>a)))\\<cdot>xs;\n        x \\<notin> set xs;\n        \\<forall>x\\<in>set (x : xs).\n           eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> delete\\<cdot>a\\<cdot>(x : xs) =\n                         filter\\<cdot>\n                         (Abs_cfun (Rep_cfun (neq\\<cdot>a)))\\<cdot>\n                         (x : xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)", "proof (cases \"eq\\<cdot>a\\<cdot>x\")"], ["proof (state)\ngoal (3 subgoals):\n 1. eq\\<cdot>a\\<cdot>x = \\<bottom> \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)\n 2. eq\\<cdot>a\\<cdot>x = TT \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)\n 3. eq\\<cdot>a\\<cdot>x = FF \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)", "case TT"], ["proof (state)\nthis:\n  eq\\<cdot>a\\<cdot>x = TT\n\ngoal (3 subgoals):\n 1. eq\\<cdot>a\\<cdot>x = \\<bottom> \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)\n 2. eq\\<cdot>a\\<cdot>x = TT \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)\n 3. eq\\<cdot>a\\<cdot>x = FF \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)", "have \"\\<forall>x\\<in>set xs. (\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>x = (\\<Lambda> _. TT)\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs.\n       (\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>x =\n       (\\<Lambda> uu_. TT)\\<cdot>x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       (\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>x =\n       (\\<Lambda> uu_. TT)\\<cdot>x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       (\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>x =\n       (\\<Lambda> uu_. TT)\\<cdot>x", "assume \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       (\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>x =\n       (\\<Lambda> uu_. TT)\\<cdot>x", "with Cons(3, 4)"], ["proof (chain)\npicking this:\n  x \\<notin> set xs\n  \\<forall>x\\<in>set (x : xs). eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  y \\<in> set xs", "have \"x \\<noteq> y\" and \"eq\\<cdot>a\\<cdot>y \\<noteq> \\<bottom>\""], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n  \\<forall>x\\<in>set (x : xs). eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<noteq> y &&& eq\\<cdot>a\\<cdot>y \\<noteq> \\<bottom>", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n  eq\\<cdot>a\\<cdot>y \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       (\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>x =\n       (\\<Lambda> uu_. TT)\\<cdot>x", "with TT"], ["proof (chain)\npicking this:\n  eq\\<cdot>a\\<cdot>x = TT\n  x \\<noteq> y\n  eq\\<cdot>a\\<cdot>y \\<noteq> \\<bottom>", "have \"eq\\<cdot>a\\<cdot>y = FF\""], ["proof (prove)\nusing this:\n  eq\\<cdot>a\\<cdot>x = TT\n  x \\<noteq> y\n  eq\\<cdot>a\\<cdot>y \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. eq\\<cdot>a\\<cdot>y = FF", "by (metis (no_types) eqD(1) trE)"], ["proof (state)\nthis:\n  eq\\<cdot>a\\<cdot>y = FF\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow>\n       (\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>x =\n       (\\<Lambda> uu_. TT)\\<cdot>x", "then"], ["proof (chain)\npicking this:\n  eq\\<cdot>a\\<cdot>y = FF", "show \"(\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>y = (\\<Lambda> _. TT)\\<cdot>y\""], ["proof (prove)\nusing this:\n  eq\\<cdot>a\\<cdot>y = FF\n\ngoal (1 subgoal):\n 1. (\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>y = (\\<Lambda> uu_. TT)\\<cdot>y", "by simp"], ["proof (state)\nthis:\n  (\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>y = (\\<Lambda> uu_. TT)\\<cdot>y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs.\n     (\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>x =\n     (\\<Lambda> uu_. TT)\\<cdot>x\n\ngoal (3 subgoals):\n 1. eq\\<cdot>a\\<cdot>x = \\<bottom> \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)\n 2. eq\\<cdot>a\\<cdot>x = TT \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)\n 3. eq\\<cdot>a\\<cdot>x = FF \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)", "from filter_cong [OF this] and TT"], ["proof (chain)\npicking this:\n  filter\\<cdot>(\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>xs =\n  filter\\<cdot>(\\<Lambda> uu_. TT)\\<cdot>xs\n  eq\\<cdot>a\\<cdot>x = TT", "show ?thesis"], ["proof (prove)\nusing this:\n  filter\\<cdot>(\\<Lambda> x. neq\\<cdot>a\\<cdot>x)\\<cdot>xs =\n  filter\\<cdot>(\\<Lambda> uu_. TT)\\<cdot>xs\n  eq\\<cdot>a\\<cdot>x = TT\n\ngoal (1 subgoal):\n 1. delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)", "by simp"], ["proof (state)\nthis:\n  delete\\<cdot>a\\<cdot>(x : xs) =\n  filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)\n\ngoal (2 subgoals):\n 1. eq\\<cdot>a\\<cdot>x = \\<bottom> \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)\n 2. eq\\<cdot>a\\<cdot>x = FF \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>(x : xs) =\n    filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)", "qed (simp_all add: IH)"], ["proof (state)\nthis:\n  delete\\<cdot>a\\<cdot>(x : xs) =\n  filter\\<cdot>(\\<Lambda> b. neq\\<cdot>a\\<cdot>b)\\<cdot>(x : xs)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set [].\n       eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom> \\<Longrightarrow>\n    delete\\<cdot>a\\<cdot>[] =\n    filter\\<cdot>(Abs_cfun (Rep_cfun (neq\\<cdot>a)))\\<cdot>[]", "qed simp"], ["", "lemma distinct_diff_filter:\n  fixes xs ys :: \"['a::Eq_eq]\"\n  assumes \"finite_list ys\"\n    and \"distinct xs\"\n    and \"\\<forall>a\\<in>set ys. \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"xs \\\\\\\\ ys = filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\\\ ys =\n    filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>xs", "using assms"], ["proof (prove)\nusing this:\n  finite_list ys\n  distinct xs\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. xs \\\\ ys =\n    filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>xs", "proof (induct arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>a\\<in>set [].\n           \\<forall>x\\<in>set xs.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xs \\\\ [] =\n                         filter\\<cdot>\n                         (\\<Lambda> x.\n                             neg\\<cdot>(elem\\<cdot>x\\<cdot>[]))\\<cdot>\n                         xs\n 2. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "case Nil"], ["proof (state)\nthis:\n  distinct xs\n  \\<forall>a\\<in>set [].\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>a\\<in>set [].\n           \\<forall>x\\<in>set xs.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xs \\\\ [] =\n                         filter\\<cdot>\n                         (\\<Lambda> x.\n                             neg\\<cdot>(elem\\<cdot>x\\<cdot>[]))\\<cdot>\n                         xs\n 2. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "then"], ["proof (chain)\npicking this:\n  distinct xs\n  \\<forall>a\\<in>set [].\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>a\\<in>set [].\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. xs \\\\ [] =\n    filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>[]))\\<cdot>xs", "by simp"], ["proof (state)\nthis:\n  xs \\\\ [] =\n  filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>[]))\\<cdot>xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "case (Cons y ys)"], ["proof (state)\nthis:\n  finite_list ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> ?xs \\\\ ys =\n                    filter\\<cdot>\n                    (\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n                    ?xs\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "let ?xs = \"delete\\<cdot>y\\<cdot>xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "from Cons"], ["proof (chain)\npicking this:\n  finite_list ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> ?xs \\\\ ys =\n                    filter\\<cdot>\n                    (\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n                    ?xs\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>", "have *: \"\\<forall>x\\<in>set xs. eq\\<cdot>y\\<cdot>x \\<noteq> \\<bottom>\""], ["proof (prove)\nusing this:\n  finite_list ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> ?xs \\\\ ys =\n                    filter\\<cdot>\n                    (\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n                    ?xs\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. eq\\<cdot>y\\<cdot>x \\<noteq> \\<bottom>", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. eq\\<cdot>y\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "from set_delete [OF \\<open>distinct xs\\<close> this]"], ["proof (chain)\npicking this:\n  set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}", "have \"set ?xs = set xs - {y}\""], ["proof (prove)\nusing this:\n  set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}\n\ngoal (1 subgoal):\n 1. set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}", "."], ["proof (state)\nthis:\n  set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "with Cons"], ["proof (chain)\npicking this:\n  finite_list ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> ?xs \\\\ ys =\n                    filter\\<cdot>\n                    (\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n                    ?xs\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}", "have \"\\<forall>a\\<in>set ys. \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\""], ["proof (prove)\nusing this:\n  finite_list ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> ?xs \\\\ ys =\n                    filter\\<cdot>\n                    (\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n                    ?xs\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  set (delete\\<cdot>y\\<cdot>xs) = set xs - {y}\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set ys.\n       \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n          eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n        eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "moreover"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n        eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "from * and \\<open>distinct xs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set xs. eq\\<cdot>y\\<cdot>x \\<noteq> \\<bottom>\n  distinct xs", "have \"distinct ?xs\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. eq\\<cdot>y\\<cdot>x \\<noteq> \\<bottom>\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct (delete\\<cdot>y\\<cdot>xs)", "by simp"], ["proof (state)\nthis:\n  distinct (delete\\<cdot>y\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n        eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  distinct (delete\\<cdot>y\\<cdot>xs)", "have \"?xs \\\\\\\\ ys = filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>?xs\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n        eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  distinct (delete\\<cdot>y\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. delete\\<cdot>y\\<cdot>xs \\\\ ys =\n    filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n    (delete\\<cdot>y\\<cdot>xs)", "using Cons"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ys.\n     \\<forall>x\\<in>set (delete\\<cdot>y\\<cdot>xs).\n        eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n  distinct (delete\\<cdot>y\\<cdot>xs)\n  finite_list ys\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ys.\n      \\<forall>x\\<in>set ?xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> ?xs \\\\ ys =\n                    filter\\<cdot>\n                    (\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n                    ?xs\n  distinct xs\n  \\<forall>a\\<in>set (y : ys).\n     \\<forall>x\\<in>set xs. eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. delete\\<cdot>y\\<cdot>xs \\\\ ys =\n    filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n    (delete\\<cdot>y\\<cdot>xs)", "by blast"], ["proof (state)\nthis:\n  delete\\<cdot>y\\<cdot>xs \\\\ ys =\n  filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n  (delete\\<cdot>y\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa.\n       \\<lbrakk>finite_list xs;\n        \\<And>xsa.\n           \\<lbrakk>distinct xsa;\n            \\<forall>a\\<in>set xs.\n               \\<forall>x\\<in>set xsa.\n                  eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> xsa \\\\ xs =\n                             filter\\<cdot>\n                             (\\<Lambda> x.\n                                 neg\\<cdot>(elem\\<cdot>x\\<cdot>xs))\\<cdot>\n                             xsa;\n        distinct xsa;\n        \\<forall>a\\<in>set (x : xs).\n           \\<forall>x\\<in>set xsa.\n              eq\\<cdot>a\\<cdot>x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> xsa \\\\ (x : xs) =\n                         filter\\<cdot>\n                         (\\<Lambda> xa.\n                             neg\\<cdot>\n                             (elem\\<cdot>xa\\<cdot>(x : xs)))\\<cdot>\n                         xsa", "then"], ["proof (chain)\npicking this:\n  delete\\<cdot>y\\<cdot>xs \\\\ ys =\n  filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n  (delete\\<cdot>y\\<cdot>xs)", "show ?case"], ["proof (prove)\nusing this:\n  delete\\<cdot>y\\<cdot>xs \\\\ ys =\n  filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n  (delete\\<cdot>y\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. xs \\\\ (y : ys) =\n    filter\\<cdot>\n    (\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>(y : ys)))\\<cdot>\n    xs", "using \\<open>distinct xs\\<close> and *"], ["proof (prove)\nusing this:\n  delete\\<cdot>y\\<cdot>xs \\\\ ys =\n  filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>ys))\\<cdot>\n  (delete\\<cdot>y\\<cdot>xs)\n  distinct xs\n  \\<forall>x\\<in>set xs. eq\\<cdot>y\\<cdot>x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. xs \\\\ (y : ys) =\n    filter\\<cdot>\n    (\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>(y : ys)))\\<cdot>\n    xs", "by (simp add: distinct_delete_filter)"], ["proof (state)\nthis:\n  xs \\\\ (y : ys) =\n  filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(elem\\<cdot>x\\<cdot>(y : ys)))\\<cdot>\n  xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_upto [intro, simp]:\n  \"distinct [MkI\\<cdot>m..MkI\\<cdot>n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [MkI\\<cdot>m..MkI\\<cdot>n]", "proof (cases \"n - m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       n - m = int na \\<Longrightarrow> distinct [MkI\\<cdot>m..MkI\\<cdot>n]\n 2. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       distinct [MkI\\<cdot>m..MkI\\<cdot>n]", "case (nonneg i)"], ["proof (state)\nthis:\n  n - m = int i\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       n - m = int na \\<Longrightarrow> distinct [MkI\\<cdot>m..MkI\\<cdot>n]\n 2. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       distinct [MkI\\<cdot>m..MkI\\<cdot>n]", "then"], ["proof (chain)\npicking this:\n  n - m = int i", "show ?thesis"], ["proof (prove)\nusing this:\n  n - m = int i\n\ngoal (1 subgoal):\n 1. distinct [MkI\\<cdot>m..MkI\\<cdot>n]", "proof (induct i arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       n - m = int 0 \\<Longrightarrow> distinct [MkI\\<cdot>m..MkI\\<cdot>n]\n 2. \\<And>i m.\n       \\<lbrakk>\\<And>m.\n                   n - m = int i \\<Longrightarrow>\n                   distinct [MkI\\<cdot>m..MkI\\<cdot>n];\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> distinct [MkI\\<cdot>m..MkI\\<cdot>n]", "case (Suc i)"], ["proof (state)\nthis:\n  n - ?m = int i \\<Longrightarrow> distinct [MkI\\<cdot>?m..MkI\\<cdot>n]\n  n - m = int (Suc i)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       n - m = int 0 \\<Longrightarrow> distinct [MkI\\<cdot>m..MkI\\<cdot>n]\n 2. \\<And>i m.\n       \\<lbrakk>\\<And>m.\n                   n - m = int i \\<Longrightarrow>\n                   distinct [MkI\\<cdot>m..MkI\\<cdot>n];\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> distinct [MkI\\<cdot>m..MkI\\<cdot>n]", "then"], ["proof (chain)\npicking this:\n  n - ?m = int i \\<Longrightarrow> distinct [MkI\\<cdot>?m..MkI\\<cdot>n]\n  n - m = int (Suc i)", "have \"n - (m + 1) = int i\" and \"m \\<le> n\""], ["proof (prove)\nusing this:\n  n - ?m = int i \\<Longrightarrow> distinct [MkI\\<cdot>?m..MkI\\<cdot>n]\n  n - m = int (Suc i)\n\ngoal (1 subgoal):\n 1. n - (m + 1) = int i &&& m \\<le> n", "by simp_all"], ["proof (state)\nthis:\n  n - (m + 1) = int i\n  m \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       n - m = int 0 \\<Longrightarrow> distinct [MkI\\<cdot>m..MkI\\<cdot>n]\n 2. \\<And>i m.\n       \\<lbrakk>\\<And>m.\n                   n - m = int i \\<Longrightarrow>\n                   distinct [MkI\\<cdot>m..MkI\\<cdot>n];\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> distinct [MkI\\<cdot>m..MkI\\<cdot>n]", "with Suc"], ["proof (chain)\npicking this:\n  n - ?m = int i \\<Longrightarrow> distinct [MkI\\<cdot>?m..MkI\\<cdot>n]\n  n - m = int (Suc i)\n  n - (m + 1) = int i\n  m \\<le> n", "have \"distinct [MkI\\<cdot>(m+1)..MkI\\<cdot>n]\""], ["proof (prove)\nusing this:\n  n - ?m = int i \\<Longrightarrow> distinct [MkI\\<cdot>?m..MkI\\<cdot>n]\n  n - m = int (Suc i)\n  n - (m + 1) = int i\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. distinct [MkI\\<cdot>(m + 1)..MkI\\<cdot>n]", "by force"], ["proof (state)\nthis:\n  distinct [MkI\\<cdot>(m + 1)..MkI\\<cdot>n]\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       n - m = int 0 \\<Longrightarrow> distinct [MkI\\<cdot>m..MkI\\<cdot>n]\n 2. \\<And>i m.\n       \\<lbrakk>\\<And>m.\n                   n - m = int i \\<Longrightarrow>\n                   distinct [MkI\\<cdot>m..MkI\\<cdot>n];\n        n - m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> distinct [MkI\\<cdot>m..MkI\\<cdot>n]", "with \\<open>m \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  m \\<le> n\n  distinct [MkI\\<cdot>(m + 1)..MkI\\<cdot>n]", "show ?case"], ["proof (prove)\nusing this:\n  m \\<le> n\n  distinct [MkI\\<cdot>(m + 1)..MkI\\<cdot>n]\n\ngoal (1 subgoal):\n 1. distinct [MkI\\<cdot>m..MkI\\<cdot>n]", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  distinct [MkI\\<cdot>m..MkI\\<cdot>n]\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       n - m = int 0 \\<Longrightarrow> distinct [MkI\\<cdot>m..MkI\\<cdot>n]", "qed (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  distinct [MkI\\<cdot>m..MkI\\<cdot>n]\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n - m = - int (Suc na) \\<Longrightarrow>\n       distinct [MkI\\<cdot>m..MkI\\<cdot>n]", "qed simp"], ["", "lemma set_intsFrom [simp]:\n  \"set (intsFrom\\<cdot>(MkI\\<cdot>m)) = {MkI\\<cdot>n | n. m \\<le> n}\"\n  (is \"set (?i m) = ?I\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (intsFrom\\<cdot>(MkI\\<cdot>m)) = {MkI\\<cdot>n |n. m \\<le> n}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. set (intsFrom\\<cdot>(MkI\\<cdot>m))\n    \\<subseteq> {MkI\\<cdot>n |n. m \\<le> n}\n 2. {MkI\\<cdot>n |n. m \\<le> n}\n    \\<subseteq> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "show \"set (?i m) \\<subseteq> ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (intsFrom\\<cdot>(MkI\\<cdot>m))\n    \\<subseteq> {MkI\\<cdot>n |n. m \\<le> n}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m)) \\<Longrightarrow>\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m)) \\<Longrightarrow>\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "assume \"n \\<in> set (?i m)\""], ["proof (state)\nthis:\n  n \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m)) \\<Longrightarrow>\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "then"], ["proof (chain)\npicking this:\n  n \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "have \"listmem n (?i m)\""], ["proof (prove)\nusing this:\n  n \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m))\n\ngoal (1 subgoal):\n 1. listmem n (intsFrom\\<cdot>(MkI\\<cdot>m))", "by (simp add: set_def)"], ["proof (state)\nthis:\n  listmem n (intsFrom\\<cdot>(MkI\\<cdot>m))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m)) \\<Longrightarrow>\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "then"], ["proof (chain)\npicking this:\n  listmem n (intsFrom\\<cdot>(MkI\\<cdot>m))", "show \"n \\<in> ?I\""], ["proof (prove)\nusing this:\n  listmem n (intsFrom\\<cdot>(MkI\\<cdot>m))\n\ngoal (1 subgoal):\n 1. n \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "proof (induct n \"(?i m)\" arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs m.\n       x : xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n}\n 2. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "fix x xs m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs m.\n       x : xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n}\n 2. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "assume \"x : xs = ?i m\""], ["proof (state)\nthis:\n  x : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\n\ngoal (2 subgoals):\n 1. \\<And>x xs m.\n       x : xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n}\n 2. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "then"], ["proof (chain)\npicking this:\n  x : xs = intsFrom\\<cdot>(MkI\\<cdot>m)", "have \"x : xs = MkI\\<cdot>m : ?i (m+1)\""], ["proof (prove)\nusing this:\n  x : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\n\ngoal (1 subgoal):\n 1. x : xs = MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))", "by (subst (asm) intsFrom.simps) (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  x : xs = MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))\n\ngoal (2 subgoals):\n 1. \\<And>x xs m.\n       x : xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n}\n 2. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "then"], ["proof (chain)\npicking this:\n  x : xs = MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))", "have [simp]: \"x = MkI\\<cdot>m\" \"xs = ?i (m+1)\""], ["proof (prove)\nusing this:\n  x : xs = MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))\n\ngoal (1 subgoal):\n 1. x = MkI\\<cdot>m &&& xs = intsFrom\\<cdot>(MkI\\<cdot>(m + 1))", "by simp_all"], ["proof (state)\nthis:\n  x = MkI\\<cdot>m\n  xs = intsFrom\\<cdot>(MkI\\<cdot>(m + 1))\n\ngoal (2 subgoals):\n 1. \\<And>x xs m.\n       x : xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n}\n 2. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "show \"x \\<in> {MkI\\<cdot>n | n. m \\<le> n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "by simp"], ["proof (state)\nthis:\n  x \\<in> {MkI\\<cdot>n |n. m \\<le> n}\n\ngoal (1 subgoal):\n 1. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "fix x xs y m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "assume IH: \"listmem x xs\"\n        \"\\<And>m. xs = ?i m \\<Longrightarrow> x \\<in> {MkI\\<cdot>n | n. m \\<le> n}\"\n        \"y : xs = ?i m\""], ["proof (state)\nthis:\n  listmem x xs\n  xs = intsFrom\\<cdot>(MkI\\<cdot>?m) \\<Longrightarrow>\n  x \\<in> {MkI\\<cdot>n |n. ?m \\<le> n}\n  y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "then"], ["proof (chain)\npicking this:\n  listmem x xs\n  xs = intsFrom\\<cdot>(MkI\\<cdot>?m) \\<Longrightarrow>\n  x \\<in> {MkI\\<cdot>n |n. ?m \\<le> n}\n  y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)", "have \"y : xs = MkI\\<cdot>m : ?i (m+1)\""], ["proof (prove)\nusing this:\n  listmem x xs\n  xs = intsFrom\\<cdot>(MkI\\<cdot>?m) \\<Longrightarrow>\n  x \\<in> {MkI\\<cdot>n |n. ?m \\<le> n}\n  y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\n\ngoal (1 subgoal):\n 1. y : xs = MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))", "by (subst (asm) (2) intsFrom.simps) (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  y : xs = MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))\n\ngoal (1 subgoal):\n 1. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "then"], ["proof (chain)\npicking this:\n  y : xs = MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))", "have [simp]: \"y = MkI\\<cdot>m\" \"xs = ?i (m+1)\""], ["proof (prove)\nusing this:\n  y : xs = MkI\\<cdot>m : intsFrom\\<cdot>(MkI\\<cdot>(m + 1))\n\ngoal (1 subgoal):\n 1. y = MkI\\<cdot>m &&& xs = intsFrom\\<cdot>(MkI\\<cdot>(m + 1))", "by simp_all"], ["proof (state)\nthis:\n  y = MkI\\<cdot>m\n  xs = intsFrom\\<cdot>(MkI\\<cdot>(m + 1))\n\ngoal (1 subgoal):\n 1. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "from IH (2) [of \"m+1\"]"], ["proof (chain)\npicking this:\n  xs = intsFrom\\<cdot>(MkI\\<cdot>(m + 1)) \\<Longrightarrow>\n  x \\<in> {MkI\\<cdot>n |n. m + 1 \\<le> n}", "have \"x \\<in> {MkI\\<cdot>n | n. m+1 \\<le> n}\""], ["proof (prove)\nusing this:\n  xs = intsFrom\\<cdot>(MkI\\<cdot>(m + 1)) \\<Longrightarrow>\n  x \\<in> {MkI\\<cdot>n |n. m + 1 \\<le> n}\n\ngoal (1 subgoal):\n 1. x \\<in> {MkI\\<cdot>n |n. m + 1 \\<le> n}", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  x \\<in> {MkI\\<cdot>n |n. m + 1 \\<le> n}\n\ngoal (1 subgoal):\n 1. \\<And>x xs y m.\n       \\<lbrakk>listmem x xs;\n        \\<And>m.\n           xs = intsFrom\\<cdot>(MkI\\<cdot>m) \\<Longrightarrow>\n           x \\<in> {MkI\\<cdot>n |n. m \\<le> n};\n        y : xs = intsFrom\\<cdot>(MkI\\<cdot>m)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "then"], ["proof (chain)\npicking this:\n  x \\<in> {MkI\\<cdot>n |n. m + 1 \\<le> n}", "show \"x \\<in> {MkI\\<cdot>n | n. m \\<le> n}\""], ["proof (prove)\nusing this:\n  x \\<in> {MkI\\<cdot>n |n. m + 1 \\<le> n}\n\ngoal (1 subgoal):\n 1. x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "by force"], ["proof (state)\nthis:\n  x \\<in> {MkI\\<cdot>n |n. m \\<le> n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> {MkI\\<cdot>n |n. m \\<le> n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (intsFrom\\<cdot>(MkI\\<cdot>m)) \\<subseteq> {MkI\\<cdot>n |n. m \\<le> n}\n\ngoal (1 subgoal):\n 1. {MkI\\<cdot>n |n. m \\<le> n}\n    \\<subseteq> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {MkI\\<cdot>n |n. m \\<le> n}\n    \\<subseteq> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "show \"?I \\<subseteq> set (?i m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {MkI\\<cdot>n |n. m \\<le> n}\n    \\<subseteq> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n} \\<Longrightarrow>\n       x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n} \\<Longrightarrow>\n       x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "assume \"x \\<in> ?I\""], ["proof (state)\nthis:\n  x \\<in> {MkI\\<cdot>n |n. m \\<le> n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n} \\<Longrightarrow>\n       x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "then"], ["proof (chain)\npicking this:\n  x \\<in> {MkI\\<cdot>n |n. m \\<le> n}", "obtain n where [simp]: \"x = MkI\\<cdot>n\" and \"m \\<le> n\""], ["proof (prove)\nusing this:\n  x \\<in> {MkI\\<cdot>n |n. m \\<le> n}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>x = MkI\\<cdot>n; m \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = MkI\\<cdot>n\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n} \\<Longrightarrow>\n       x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "from upto_append_intsFrom [OF this(2), symmetric]"], ["proof (chain)\npicking this:\n  intsFrom\\<cdot>(MkI\\<cdot>m) =\n  upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>n + 1)", "have *: \"set (?i m) = set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) \\<union> set (?i (n+1))\""], ["proof (prove)\nusing this:\n  intsFrom\\<cdot>(MkI\\<cdot>m) =\n  upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>n + 1)\n\ngoal (1 subgoal):\n 1. set (intsFrom\\<cdot>(MkI\\<cdot>m)) =\n    set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) \\<union>\n    set (intsFrom\\<cdot>(MkI\\<cdot>(n + 1)))", "using finite_list_upto [of m n]"], ["proof (prove)\nusing this:\n  intsFrom\\<cdot>(MkI\\<cdot>m) =\n  upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n) ++\n  intsFrom\\<cdot>(MkI\\<cdot>n + 1)\n  finite_list (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n))\n\ngoal (1 subgoal):\n 1. set (intsFrom\\<cdot>(MkI\\<cdot>m)) =\n    set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) \\<union>\n    set (intsFrom\\<cdot>(MkI\\<cdot>(n + 1)))", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  set (intsFrom\\<cdot>(MkI\\<cdot>m)) =\n  set (upto\\<cdot>(MkI\\<cdot>m)\\<cdot>(MkI\\<cdot>n)) \\<union>\n  set (intsFrom\\<cdot>(MkI\\<cdot>(n + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {MkI\\<cdot>n |n. m \\<le> n} \\<Longrightarrow>\n       x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "show \"x \\<in> set (?i m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "using \\<open>m \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m))", "by (auto simp: * one_Integer_def)"], ["proof (state)\nthis:\n  x \\<in> set (intsFrom\\<cdot>(MkI\\<cdot>m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {MkI\\<cdot>n |n. m \\<le> n} \\<subseteq> set (intsFrom\\<cdot>(MkI\\<cdot>m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma If_eq_bottom_iff [simp]: (* FIXME: move *)\n  \"(If b then x else y = \\<bottom>) \\<longleftrightarrow> b = \\<bottom> \\<or> b = TT \\<and> x = \\<bottom> \\<or> b = FF \\<and> y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (If b then x else y = \\<bottom>) =\n    (b = \\<bottom> \\<or>\n     b = TT \\<and> x = \\<bottom> \\<or> b = FF \\<and> y = \\<bottom>)", "by (induct b) simp_all"], ["", "lemma upto_eq_bottom_iff [simp]:\n  \"upto\\<cdot>m\\<cdot>n = \\<bottom> \\<longleftrightarrow> m = \\<bottom> \\<or> n = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (upto\\<cdot>m\\<cdot>n = \\<bottom>) = (m = \\<bottom> \\<or> n = \\<bottom>)", "by (subst upto.simps, simp)"], ["", "lemma seq_eq_bottom_iff [simp]: (* FIXME: move *)\n  \"seq\\<cdot>x\\<cdot>y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<or> y = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (seq\\<cdot>x\\<cdot>y = \\<bottom>) = (x = \\<bottom> \\<or> y = \\<bottom>)", "by (simp add: seq_conv_if)"], ["", "lemma intsFrom_eq_bottom_iff [simp]:\n  \"intsFrom\\<cdot>m = \\<bottom> \\<longleftrightarrow> m = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (intsFrom\\<cdot>m = \\<bottom>) = (m = \\<bottom>)", "by (subst intsFrom.simps, simp)"], ["", "lemma intsFrom_split:\n  assumes \"m \\<ge> n\"\n  shows \"[MkI\\<cdot>n..] = [MkI\\<cdot>n .. MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [MkI\\<cdot>n..] = [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [MkI\\<cdot>n..] = [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]", "from assms"], ["proof (chain)\npicking this:\n  n \\<le> m", "have ge: \"m - n \\<ge> 0\""], ["proof (prove)\nusing this:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. 0 \\<le> m - n", "by arith"], ["proof (state)\nthis:\n  0 \\<le> m - n\n\ngoal (1 subgoal):\n 1. [MkI\\<cdot>n..] = [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]", "have \"[MkI\\<cdot>n..] = (take\\<cdot>(MkI\\<cdot>(m - n)) \\<cdot> [MkI\\<cdot>n..]) ++ (drop\\<cdot>(MkI\\<cdot>(m - n)) \\<cdot> [MkI\\<cdot>n..])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [MkI\\<cdot>n..] =\n    take\\<cdot>(MkI\\<cdot>(m - n))\\<cdot>[MkI\\<cdot>n..] ++\n    Data_List.drop\\<cdot>(MkI\\<cdot>(m - n))\\<cdot>[MkI\\<cdot>n..]", "by (subst take_drop_append, rule)"], ["proof (state)\nthis:\n  [MkI\\<cdot>n..] =\n  take\\<cdot>(MkI\\<cdot>(m - n))\\<cdot>[MkI\\<cdot>n..] ++\n  Data_List.drop\\<cdot>(MkI\\<cdot>(m - n))\\<cdot>[MkI\\<cdot>n..]\n\ngoal (1 subgoal):\n 1. [MkI\\<cdot>n..] = [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]", "also"], ["proof (state)\nthis:\n  [MkI\\<cdot>n..] =\n  take\\<cdot>(MkI\\<cdot>(m - n))\\<cdot>[MkI\\<cdot>n..] ++\n  Data_List.drop\\<cdot>(MkI\\<cdot>(m - n))\\<cdot>[MkI\\<cdot>n..]\n\ngoal (1 subgoal):\n 1. [MkI\\<cdot>n..] = [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]", "have \"... = [MkI\\<cdot>n.. MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>(MkI\\<cdot>(m - n))\\<cdot>[MkI\\<cdot>n..] ++\n    Data_List.drop\\<cdot>(MkI\\<cdot>(m - n))\\<cdot>[MkI\\<cdot>n..] =\n    [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]", "by (subst drop_intsFrom_enumFrom[OF ge], auto simp add:take_intsFrom_enumFrom[simplified] one_Integer_def)"], ["proof (state)\nthis:\n  take\\<cdot>(MkI\\<cdot>(m - n))\\<cdot>[MkI\\<cdot>n..] ++\n  Data_List.drop\\<cdot>(MkI\\<cdot>(m - n))\\<cdot>[MkI\\<cdot>n..] =\n  [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]\n\ngoal (1 subgoal):\n 1. [MkI\\<cdot>n..] = [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]", "finally"], ["proof (chain)\npicking this:\n  [MkI\\<cdot>n..] = [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]", "show ?thesis"], ["proof (prove)\nusing this:\n  [MkI\\<cdot>n..] = [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]\n\ngoal (1 subgoal):\n 1. [MkI\\<cdot>n..] = [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]", "."], ["proof (state)\nthis:\n  [MkI\\<cdot>n..] = [MkI\\<cdot>n..MkI\\<cdot>(m - 1)] ++ [MkI\\<cdot>m..]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_fast_forward:\n  assumes \"n+1 \\<le> n'\"\n    and  \"\\<forall>k . n < k \\<longrightarrow> k < n' \\<longrightarrow> \\<not> P k\"\n  shows \"filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i) . Def (P i))\\<cdot>[MkI\\<cdot>(n+1)..] = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i) . Def (P i))\\<cdot>[MkI\\<cdot>n'..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>\n    [MkI\\<cdot>(n + 1)..] =\n    filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>[MkI\\<cdot>n'..]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>\n    [MkI\\<cdot>(n + 1)..] =\n    filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>[MkI\\<cdot>n'..]", "from assms(1)"], ["proof (chain)\npicking this:\n  n + 1 \\<le> n'", "have\"[MkI\\<cdot>(n+1)..] = [MkI\\<cdot>(n+1).. MkI\\<cdot>(n'- 1)] ++ [MkI\\<cdot>n'..]\" (is \"_ = ?l1 ++ ?l2\")"], ["proof (prove)\nusing this:\n  n + 1 \\<le> n'\n\ngoal (1 subgoal):\n 1. [MkI\\<cdot>(n + 1)..] =\n    [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)] ++ [MkI\\<cdot>n'..]", "by (subst intsFrom_split[of \"n+1\" n'], auto)"], ["proof (state)\nthis:\n  [MkI\\<cdot>(n + 1)..] =\n  [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)] ++ [MkI\\<cdot>n'..]\n\ngoal (1 subgoal):\n 1. filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>\n    [MkI\\<cdot>(n + 1)..] =\n    filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>[MkI\\<cdot>n'..]", "moreover"], ["proof (state)\nthis:\n  [MkI\\<cdot>(n + 1)..] =\n  [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)] ++ [MkI\\<cdot>n'..]\n\ngoal (1 subgoal):\n 1. filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>\n    [MkI\\<cdot>(n + 1)..] =\n    filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>[MkI\\<cdot>n'..]", "have \"filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i) . Def (P i))\\<cdot>[MkI\\<cdot>(n+1).. MkI\\<cdot>(n'- 1)] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>\n    [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)] =\n    []", "apply (rule filter_FF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite_list [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)]\n 2. \\<forall>x\\<in>set [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)].\n       (case x of MkI\\<cdot>i \\<Rightarrow> Def (P i)) = FF", "apply (simp, rule finite_list_upto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)].\n       (case x of MkI\\<cdot>i \\<Rightarrow> Def (P i)) = FF", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>k>n. k < n' \\<longrightarrow> \\<not> P k\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)].\n       (case x of MkI\\<cdot>i \\<Rightarrow> Def (P i)) = FF", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>\n  [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)] =\n  []\n\ngoal (1 subgoal):\n 1. filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>\n    [MkI\\<cdot>(n + 1)..] =\n    filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>[MkI\\<cdot>n'..]", "ultimately"], ["proof (chain)\npicking this:\n  [MkI\\<cdot>(n + 1)..] =\n  [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)] ++ [MkI\\<cdot>n'..]\n  filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>\n  [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)] =\n  []", "show ?thesis"], ["proof (prove)\nusing this:\n  [MkI\\<cdot>(n + 1)..] =\n  [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)] ++ [MkI\\<cdot>n'..]\n  filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>\n  [MkI\\<cdot>(n + 1)..MkI\\<cdot>(n' - 1)] =\n  []\n\ngoal (1 subgoal):\n 1. filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>\n    [MkI\\<cdot>(n + 1)..] =\n    filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>[MkI\\<cdot>n'..]", "by simp"], ["proof (state)\nthis:\n  filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>\n  [MkI\\<cdot>(n + 1)..] =\n  filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (P i))\\<cdot>[MkI\\<cdot>n'..]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma null_eq_TT_iff [simp]:\n  \"null\\<cdot>xs = TT \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null\\<cdot>xs = TT) = (xs = [])", "by (cases xs) simp_all"], ["", "lemma null_set_empty_conv:\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> null\\<cdot>xs = TT \\<longleftrightarrow> set xs = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    (null\\<cdot>xs = TT) = (set xs = {})", "by (cases xs) simp_all"], ["", "lemma elem_TT [simp]:\n  fixes x :: \"'a::Eq_eq\" shows \"elem\\<cdot>x\\<cdot>xs = TT \\<Longrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem\\<cdot>x\\<cdot>xs = TT \\<Longrightarrow> x \\<in> set xs", "apply (induct arbitrary: xs rule: elem.induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>\\<And>xs.\n                   xa\\<cdot>x\\<cdot>xs = TT \\<Longrightarrow>\n                   x \\<in> set xs;\n        Fixrec.run\\<cdot>\n        (match_Nil\\<cdot>xs\\<cdot>(Fixrec.succeed\\<cdot>FF) +++\n         match_Cons\\<cdot>xs\\<cdot>\n         (\\<Lambda> y ys.\n             Fixrec.succeed\\<cdot>\n             (eq\\<cdot>y\\<cdot>x orelse xa\\<cdot>x\\<cdot>ys))) =\n        TT\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xs", "apply (rename_tac xs, case_tac xs, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs a list.\n       \\<lbrakk>\\<And>xs.\n                   xa\\<cdot>x\\<cdot>xs = TT \\<Longrightarrow>\n                   x \\<in> set xs;\n        (eq\\<cdot>a\\<cdot>x orelse xa\\<cdot>x\\<cdot>list) = TT;\n        xs = a : list\\<rbrakk>\n       \\<Longrightarrow> x = a \\<or> x \\<in> set list", "apply (rename_tac a list, case_tac \"eq\\<cdot>a\\<cdot>x\", force+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma elem_FF [simp]:\n  fixes x :: \"'a::Eq_equiv\" shows \"elem\\<cdot>x\\<cdot>xs = FF \\<Longrightarrow> x \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem\\<cdot>x\\<cdot>xs = FF \\<Longrightarrow> x \\<notin> set xs", "by (induct arbitrary: xs rule: elem.induct, simp_all)\n     (rename_tac xs, case_tac xs, simp_all, force)"], ["", "lemma length_strict [simp]:\n  \"length\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\\<cdot>\\<bottom> = \\<bottom>", "by (fixrec_simp)"], ["", "lemma repeat_neq_bottom [simp]:\n  \"repeat\\<cdot>x \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat\\<cdot>x \\<noteq> \\<bottom>", "by (subst repeat.simps) simp"], ["", "lemma list_case_repeat [simp]:\n  \"list_case\\<cdot>a\\<cdot>f\\<cdot>(repeat\\<cdot>x) = f\\<cdot>x\\<cdot>(repeat\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_case\\<cdot>a\\<cdot>f\\<cdot>(repeat\\<cdot>x) =\n    f\\<cdot>x\\<cdot>(repeat\\<cdot>x)", "by (subst repeat.simps) simp"], ["", "lemma length_append [simp]:\n  \"length\\<cdot>(xs ++ ys) = length\\<cdot>xs + length\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\\<cdot>(xs ++ ys) = length\\<cdot>xs + length\\<cdot>ys", "by (induct xs) (simp_all add: ac_simps)"], ["", "lemma replicate_strict [simp]:\n  \"replicate\\<cdot>\\<bottom>\\<cdot>x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate\\<cdot>\\<bottom>\\<cdot>x = \\<bottom>", "by (simp add: replicate_def)"], ["", "lemma replicate_0 [simp]:\n  \"replicate\\<cdot>0\\<cdot>x = []\"\n  \"replicate\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate\\<cdot>0\\<cdot>x = [] &&&\n    replicate\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = []", "by (simp add: replicate_def)+"], ["", "lemma Integer_add_0 [simp]: \"MkI\\<cdot>0 + n = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI\\<cdot>0 + n = n", "by (cases n) simp_all"], ["", "lemma replicate_MkI_plus_1 [simp]:\n  \"0 \\<le> n \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>(n+1))\\<cdot>x = x : replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x\"\n  \"0 \\<le> n \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>(1+n))\\<cdot>x = x : replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> n \\<Longrightarrow>\n     replicate\\<cdot>(MkI\\<cdot>(n + 1))\\<cdot>x =\n     x : replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) &&&\n    (0 \\<le> n \\<Longrightarrow>\n     replicate\\<cdot>(MkI\\<cdot>(1 + n))\\<cdot>x =\n     x : replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x)", "by (simp add: replicate_def, subst take.simps, simp add: one_Integer_def zero_Integer_def)+"], ["", "lemma replicate_append_plus_conv:\n  assumes \"0 \\<le> m\" and \"0 \\<le> n\"\n  shows \"replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++ replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x\n    = replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n    replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "proof (cases m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       m = int na \\<Longrightarrow>\n       replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n       replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n       replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\n 2. \\<And>na.\n       m = - int (Suc na) \\<Longrightarrow>\n       replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n       replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n       replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "case (nonneg i)"], ["proof (state)\nthis:\n  m = int i\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       m = int na \\<Longrightarrow>\n       replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n       replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n       replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\n 2. \\<And>na.\n       m = - int (Suc na) \\<Longrightarrow>\n       replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n       replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n       replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> m\n  0 \\<le> n\n  m = int i", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> m\n  0 \\<le> n\n  m = int i\n\ngoal (1 subgoal):\n 1. replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n    replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "proof (induct i arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int 0\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\n 2. \\<And>i m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int i\\<rbrakk>\n                   \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     x ++\n                                     replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                                     replicate\\<cdot>\n                                     (MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>\n                                     x;\n        0 \\<le> m; 0 \\<le> n; m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?m; 0 \\<le> n; ?m = int i\\<rbrakk>\n  \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>?m)\\<cdot>x ++\n                    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                    replicate\\<cdot>(MkI\\<cdot>?m + MkI\\<cdot>n)\\<cdot>x\n  0 \\<le> m\n  0 \\<le> n\n  m = int (Suc i)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int 0\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\n 2. \\<And>i m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int i\\<rbrakk>\n                   \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     x ++\n                                     replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                                     replicate\\<cdot>\n                                     (MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>\n                                     x;\n        0 \\<le> m; 0 \\<le> n; m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?m; 0 \\<le> n; ?m = int i\\<rbrakk>\n  \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>?m)\\<cdot>x ++\n                    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                    replicate\\<cdot>(MkI\\<cdot>?m + MkI\\<cdot>n)\\<cdot>x\n  0 \\<le> m\n  0 \\<le> n\n  m = int (Suc i)", "have ge: \"int i + n \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?m; 0 \\<le> n; ?m = int i\\<rbrakk>\n  \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>?m)\\<cdot>x ++\n                    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                    replicate\\<cdot>(MkI\\<cdot>?m + MkI\\<cdot>n)\\<cdot>x\n  0 \\<le> m\n  0 \\<le> n\n  m = int (Suc i)\n\ngoal (1 subgoal):\n 1. 0 \\<le> int i + n", "by force"], ["proof (state)\nthis:\n  0 \\<le> int i + n\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int 0\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\n 2. \\<And>i m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int i\\<rbrakk>\n                   \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     x ++\n                                     replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                                     replicate\\<cdot>\n                                     (MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>\n                                     x;\n        0 \\<le> m; 0 \\<le> n; m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "have \"replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++ replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x = x : (replicate\\<cdot>(MkI\\<cdot>(int i))\\<cdot>x ++ replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n    x :\n    replicate\\<cdot>(MkI\\<cdot>(int i))\\<cdot>x ++\n    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x", "by (simp add: Suc)"], ["proof (state)\nthis:\n  replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n  replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n  x :\n  replicate\\<cdot>(MkI\\<cdot>(int i))\\<cdot>x ++\n  replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int 0\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\n 2. \\<And>i m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int i\\<rbrakk>\n                   \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     x ++\n                                     replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                                     replicate\\<cdot>\n                                     (MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>\n                                     x;\n        0 \\<le> m; 0 \\<le> n; m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "also"], ["proof (state)\nthis:\n  replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n  replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n  x :\n  replicate\\<cdot>(MkI\\<cdot>(int i))\\<cdot>x ++\n  replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int 0\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\n 2. \\<And>i m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int i\\<rbrakk>\n                   \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     x ++\n                                     replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                                     replicate\\<cdot>\n                                     (MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>\n                                     x;\n        0 \\<le> m; 0 \\<le> n; m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "have \"\\<dots> = x : replicate\\<cdot>(MkI\\<cdot>(int i) + MkI\\<cdot>n)\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x :\n    replicate\\<cdot>(MkI\\<cdot>(int i))\\<cdot>x ++\n    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n    x : replicate\\<cdot>(MkI\\<cdot>(int i) + MkI\\<cdot>n)\\<cdot>x", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?m; 0 \\<le> n; ?m = int i\\<rbrakk>\n  \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>?m)\\<cdot>x ++\n                    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                    replicate\\<cdot>(MkI\\<cdot>?m + MkI\\<cdot>n)\\<cdot>x\n  0 \\<le> m\n  0 \\<le> n\n  m = int (Suc i)\n\ngoal (1 subgoal):\n 1. x :\n    replicate\\<cdot>(MkI\\<cdot>(int i))\\<cdot>x ++\n    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n    x : replicate\\<cdot>(MkI\\<cdot>(int i) + MkI\\<cdot>n)\\<cdot>x", "by simp"], ["proof (state)\nthis:\n  x :\n  replicate\\<cdot>(MkI\\<cdot>(int i))\\<cdot>x ++\n  replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n  x : replicate\\<cdot>(MkI\\<cdot>(int i) + MkI\\<cdot>n)\\<cdot>x\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int 0\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\n 2. \\<And>i m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int i\\<rbrakk>\n                   \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>\n                                     x ++\n                                     replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                                     replicate\\<cdot>\n                                     (MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>\n                                     x;\n        0 \\<le> m; 0 \\<le> n; m = int (Suc i)\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "finally"], ["proof (chain)\npicking this:\n  replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n  replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n  x : replicate\\<cdot>(MkI\\<cdot>(int i) + MkI\\<cdot>n)\\<cdot>x", "show ?case"], ["proof (prove)\nusing this:\n  replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n  replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n  x : replicate\\<cdot>(MkI\\<cdot>(int i) + MkI\\<cdot>n)\\<cdot>x\n\ngoal (1 subgoal):\n 1. replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n    replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "using ge"], ["proof (prove)\nusing this:\n  replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n  replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n  x : replicate\\<cdot>(MkI\\<cdot>(int i) + MkI\\<cdot>n)\\<cdot>x\n  0 \\<le> int i + n\n\ngoal (1 subgoal):\n 1. replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n    replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "by (simp add: Suc ac_simps)"], ["proof (state)\nthis:\n  replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n  replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n  replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>0 \\<le> m; 0 \\<le> n; m = int 0\\<rbrakk>\n       \\<Longrightarrow> replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n                         replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n                         replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "qed simp"], ["proof (state)\nthis:\n  replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n  replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n  replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       m = - int (Suc na) \\<Longrightarrow>\n       replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n       replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n       replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       m = - int (Suc na) \\<Longrightarrow>\n       replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n       replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n       replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "case (neg i)"], ["proof (state)\nthis:\n  m = - int (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       m = - int (Suc na) \\<Longrightarrow>\n       replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n       replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n       replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> m\n  0 \\<le> n\n  m = - int (Suc i)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> m\n  0 \\<le> n\n  m = - int (Suc i)\n\ngoal (1 subgoal):\n 1. replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n    replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n    replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x", "by simp"], ["proof (state)\nthis:\n  replicate\\<cdot>(MkI\\<cdot>m)\\<cdot>x ++\n  replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x =\n  replicate\\<cdot>(MkI\\<cdot>m + MkI\\<cdot>n)\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replicate_MkI_1 [simp]:\n  \"replicate\\<cdot>(MkI\\<cdot>1)\\<cdot>x = x : []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate\\<cdot>(MkI\\<cdot>1)\\<cdot>x = [x]", "by (simp add: replicate_def, subst take.simps, simp add: zero_Integer_def one_Integer_def)"], ["", "lemma length_replicate [simp]:\n  assumes \"0 \\<le> n\"\n  shows \"length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       n = int na \\<Longrightarrow>\n       length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n\n 2. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n", "case (nonneg i)"], ["proof (state)\nthis:\n  n = int i\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       n = int na \\<Longrightarrow>\n       length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n\n 2. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> n\n  n = int i", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> n\n  n = int i\n\ngoal (1 subgoal):\n 1. length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n", "by (induct i arbitrary: n)\n       (simp_all add: replicate_append_plus_conv zero_Integer_def one_Integer_def)"], ["proof (state)\nthis:\n  length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n", "case (neg i)"], ["proof (state)\nthis:\n  n = - int (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       n = - int (Suc na) \\<Longrightarrow>\n       length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> n\n  n = - int (Suc i)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> n\n  n = - int (Suc i)\n\ngoal (1 subgoal):\n 1. length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n", "by (simp add: replicate_def)"], ["proof (state)\nthis:\n  length\\<cdot>(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x) = MkI\\<cdot>n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_oo [simp]:\n  \"map\\<cdot>f\\<cdot>(map\\<cdot>g\\<cdot>xs) = map\\<cdot>(f oo g)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>f\\<cdot>(map\\<cdot>g\\<cdot>xs) = map\\<cdot>(f oo g)\\<cdot>xs", "by (induct xs) simp_all"], ["", "lemma nth_Cons_MkI [simp]:\n  \"0 < i \\<Longrightarrow> (a : xs) !! (MkI\\<cdot>i) = xs !! (MkI\\<cdot>(i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<Longrightarrow>\n    (a : xs) !! MkI\\<cdot>i = xs !! MkI\\<cdot>(i - 1)", "unfolding nth_Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<Longrightarrow>\n    If eq\\<cdot>(MkI\\<cdot>i)\\<cdot>0 then a else xs !! (MkI\\<cdot>i - 1) =\n    xs !! MkI\\<cdot>(i - 1)", "by (cases i, simp add: zero_Integer_def one_Integer_def) (case_tac n, simp_all)"], ["", "lemma map_plus_intsFrom:\n  \"map\\<cdot>(+ MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m)) = intsFrom\\<cdot>(MkI\\<cdot>(m+n))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m)) =\n    intsFrom\\<cdot>(MkI\\<cdot>(m + n))", "proof (rule list.take_lemma)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       list_take na\\<cdot>\n       (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n       list_take na\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(m + n)))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       list_take na\\<cdot>\n       (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n       list_take na\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(m + n)))", "show \"list_take i\\<cdot>?l = list_take i\\<cdot>?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_take i\\<cdot>\n    (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n    list_take i\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(m + n)))", "proof (induct i arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       list_take 0\\<cdot>\n       (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n       list_take 0\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(m + n)))\n 2. \\<And>i m.\n       (\\<And>m.\n           list_take i\\<cdot>\n           (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n           list_take i\\<cdot>\n           (intsFrom\\<cdot>(MkI\\<cdot>(m + n)))) \\<Longrightarrow>\n       list_take (Suc i)\\<cdot>\n       (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n       list_take (Suc i)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(m + n)))", "case (Suc i)"], ["proof (state)\nthis:\n  list_take i\\<cdot>\n  (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>?m))) =\n  list_take i\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(?m + n)))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       list_take 0\\<cdot>\n       (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n       list_take 0\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(m + n)))\n 2. \\<And>i m.\n       (\\<And>m.\n           list_take i\\<cdot>\n           (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n           list_take i\\<cdot>\n           (intsFrom\\<cdot>(MkI\\<cdot>(m + n)))) \\<Longrightarrow>\n       list_take (Suc i)\\<cdot>\n       (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n       list_take (Suc i)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(m + n)))", "then"], ["proof (chain)\npicking this:\n  list_take i\\<cdot>\n  (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>?m))) =\n  list_take i\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(?m + n)))", "show ?case"], ["proof (prove)\nusing this:\n  list_take i\\<cdot>\n  (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>?m))) =\n  list_take i\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(?m + n)))\n\ngoal (1 subgoal):\n 1. list_take (Suc i)\\<cdot>\n    (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n    list_take (Suc i)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(m + n)))", "by (subst (1 2) intsFrom.simps) (simp add: ac_simps one_Integer_def)"], ["proof (state)\nthis:\n  list_take (Suc i)\\<cdot>\n  (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n  list_take (Suc i)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(m + n)))\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       list_take 0\\<cdot>\n       (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n       list_take 0\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(m + n)))", "qed simp"], ["proof (state)\nthis:\n  list_take i\\<cdot>\n  (map\\<cdot>(+MkI\\<cdot>n)\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>m))) =\n  list_take i\\<cdot>(intsFrom\\<cdot>(MkI\\<cdot>(m + n)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_eq_MkI_conv:\n  \"l + n = MkI\\<cdot>m \\<longleftrightarrow> (\\<exists>l' n'. l = MkI\\<cdot>l' \\<and> n = MkI\\<cdot>n' \\<and> m = l' + n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l + n = MkI\\<cdot>m) =\n    (\\<exists>l' n'.\n        l = MkI\\<cdot>l' \\<and> n = MkI\\<cdot>n' \\<and> m = l' + n')", "by (cases l, simp) (cases n, auto)"], ["", "lemma length_ge_0:\n  \"length\\<cdot>xs = MkI\\<cdot>n \\<Longrightarrow> n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>n \\<Longrightarrow> 0 \\<le> n", "by (induct xs arbitrary: n) (auto simp: one_Integer_def plus_eq_MkI_conv)"], ["", "lemma length_0_conv [simp]:\n  \"length\\<cdot>xs = MkI\\<cdot>0 \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length\\<cdot>xs = MkI\\<cdot>0) = (xs = [])", "apply (cases xs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. xs = \\<bottom> \\<Longrightarrow>\n    (length\\<cdot>xs = MkI\\<cdot>0) = (xs = [])\n 2. xs = [] \\<Longrightarrow> (length\\<cdot>xs = MkI\\<cdot>0) = (xs = [])\n 3. \\<And>a list.\n       xs = a : list \\<Longrightarrow>\n       (length\\<cdot>xs = MkI\\<cdot>0) = (xs = [])", "apply (simp_all add: one_Integer_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a : list \\<Longrightarrow>\n       length\\<cdot>list + MkI\\<cdot>1 \\<noteq> MkI\\<cdot>0", "apply (case_tac \"length\\<cdot>list\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>xs = a : list; length\\<cdot>list = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> length\\<cdot>list + MkI\\<cdot>1 \\<noteq>\n                         MkI\\<cdot>0\n 2. \\<And>a list int.\n       \\<lbrakk>xs = a : list; length\\<cdot>list = MkI\\<cdot>int\\<rbrakk>\n       \\<Longrightarrow> length\\<cdot>list + MkI\\<cdot>1 \\<noteq>\n                         MkI\\<cdot>0", "apply (auto dest: length_ge_0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_ge_1 [simp]:\n  \"length\\<cdot>xs = MkI\\<cdot>(1 + int n)\n    \\<longleftrightarrow> (\\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n))\"\n  (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length\\<cdot>xs = MkI\\<cdot>(1 + int n)) =\n    (\\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n) \\<Longrightarrow>\n    \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)\n 2. \\<exists>u us.\n       xs = u : us \\<and>\n       length\\<cdot>us = MkI\\<cdot>(int n) \\<Longrightarrow>\n    length\\<cdot>xs = MkI\\<cdot>(1 + int n)", "assume ?r"], ["proof (state)\nthis:\n  \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)\n\ngoal (2 subgoals):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n) \\<Longrightarrow>\n    \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)\n 2. \\<exists>u us.\n       xs = u : us \\<and>\n       length\\<cdot>us = MkI\\<cdot>(int n) \\<Longrightarrow>\n    length\\<cdot>xs = MkI\\<cdot>(1 + int n)", "then"], ["proof (chain)\npicking this:\n  \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)", "show ?l"], ["proof (prove)\nusing this:\n  \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n)", "by (auto simp: one_Integer_def)"], ["proof (state)\nthis:\n  length\\<cdot>xs = MkI\\<cdot>(1 + int n)\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n) \\<Longrightarrow>\n    \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n) \\<Longrightarrow>\n    \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)", "assume 1: ?l"], ["proof (state)\nthis:\n  length\\<cdot>xs = MkI\\<cdot>(1 + int n)\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n) \\<Longrightarrow>\n    \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)", "then"], ["proof (chain)\npicking this:\n  length\\<cdot>xs = MkI\\<cdot>(1 + int n)", "obtain u us where [simp]: \"xs = u : us\""], ["proof (prove)\nusing this:\n  length\\<cdot>xs = MkI\\<cdot>(1 + int n)\n\ngoal (1 subgoal):\n 1. (\\<And>u us. xs = u : us \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs) auto"], ["proof (state)\nthis:\n  xs = u : us\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n) \\<Longrightarrow>\n    \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)", "from 1"], ["proof (chain)\npicking this:\n  length\\<cdot>xs = MkI\\<cdot>(1 + int n)", "have 2: \"1 + length\\<cdot>us = MkI\\<cdot>(1 + int n)\""], ["proof (prove)\nusing this:\n  length\\<cdot>xs = MkI\\<cdot>(1 + int n)\n\ngoal (1 subgoal):\n 1. 1 + length\\<cdot>us = MkI\\<cdot>(1 + int n)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  1 + length\\<cdot>us = MkI\\<cdot>(1 + int n)\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n) \\<Longrightarrow>\n    \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)", "then"], ["proof (chain)\npicking this:\n  1 + length\\<cdot>us = MkI\\<cdot>(1 + int n)", "have \"length\\<cdot>us \\<noteq> \\<bottom>\""], ["proof (prove)\nusing this:\n  1 + length\\<cdot>us = MkI\\<cdot>(1 + int n)\n\ngoal (1 subgoal):\n 1. length\\<cdot>us \\<noteq> \\<bottom>", "by (cases \"length\\<cdot>us\") simp_all"], ["proof (state)\nthis:\n  length\\<cdot>us \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n) \\<Longrightarrow>\n    \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)", "moreover"], ["proof (state)\nthis:\n  length\\<cdot>us \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n) \\<Longrightarrow>\n    \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)", "from 2"], ["proof (chain)\npicking this:\n  1 + length\\<cdot>us = MkI\\<cdot>(1 + int n)", "have \"length\\<cdot>us + 1 = MkI\\<cdot>(int n) + 1\""], ["proof (prove)\nusing this:\n  1 + length\\<cdot>us = MkI\\<cdot>(1 + int n)\n\ngoal (1 subgoal):\n 1. length\\<cdot>us + 1 = MkI\\<cdot>(int n) + 1", "by (simp add: one_Integer_def ac_simps)"], ["proof (state)\nthis:\n  length\\<cdot>us + 1 = MkI\\<cdot>(int n) + 1\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n) \\<Longrightarrow>\n    \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)", "ultimately"], ["proof (chain)\npicking this:\n  length\\<cdot>us \\<noteq> \\<bottom>\n  length\\<cdot>us + 1 = MkI\\<cdot>(int n) + 1", "have \"length\\<cdot>us = MkI\\<cdot>(int n)\""], ["proof (prove)\nusing this:\n  length\\<cdot>us \\<noteq> \\<bottom>\n  length\\<cdot>us + 1 = MkI\\<cdot>(int n) + 1\n\ngoal (1 subgoal):\n 1. length\\<cdot>us = MkI\\<cdot>(int n)", "by (cases \"length\\<cdot>us\") (simp_all add: one_Integer_def)"], ["proof (state)\nthis:\n  length\\<cdot>us = MkI\\<cdot>(int n)\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>(1 + int n) \\<Longrightarrow>\n    \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)", "then"], ["proof (chain)\npicking this:\n  length\\<cdot>us = MkI\\<cdot>(int n)", "show ?r"], ["proof (prove)\nusing this:\n  length\\<cdot>us = MkI\\<cdot>(int n)\n\ngoal (1 subgoal):\n 1. \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)", "by simp"], ["proof (state)\nthis:\n  \\<exists>u us. xs = u : us \\<and> length\\<cdot>us = MkI\\<cdot>(int n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_list_length_conv:\n  \"finite_list xs \\<longleftrightarrow> (\\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_list xs = (\\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite_list xs \\<Longrightarrow>\n    \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n)\n 2. \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n) \\<Longrightarrow>\n    finite_list xs", "assume \"?l\""], ["proof (state)\nthis:\n  finite_list xs\n\ngoal (2 subgoals):\n 1. finite_list xs \\<Longrightarrow>\n    \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n)\n 2. \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n) \\<Longrightarrow>\n    finite_list xs", "then"], ["proof (chain)\npicking this:\n  finite_list xs", "show \"?r\""], ["proof (prove)\nusing this:\n  finite_list xs\n\ngoal (1 subgoal):\n 1. \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n)", "by (induct, auto simp: one_Integer_def) presburger"], ["proof (state)\nthis:\n  \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n)\n\ngoal (1 subgoal):\n 1. \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n) \\<Longrightarrow>\n    finite_list xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n) \\<Longrightarrow>\n    finite_list xs", "assume \"?r\""], ["proof (state)\nthis:\n  \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n)\n\ngoal (1 subgoal):\n 1. \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n) \\<Longrightarrow>\n    finite_list xs", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n)", "obtain n where \"length\\<cdot>xs = MkI\\<cdot>(int n)\""], ["proof (prove)\nusing this:\n  \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        length\\<cdot>xs = MkI\\<cdot>(int n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length\\<cdot>xs = MkI\\<cdot>(int n)\n\ngoal (1 subgoal):\n 1. \\<exists>n. length\\<cdot>xs = MkI\\<cdot>(int n) \\<Longrightarrow>\n    finite_list xs", "then"], ["proof (chain)\npicking this:\n  length\\<cdot>xs = MkI\\<cdot>(int n)", "show \"?l\""], ["proof (prove)\nusing this:\n  length\\<cdot>xs = MkI\\<cdot>(int n)\n\ngoal (1 subgoal):\n 1. finite_list xs", "by (induct n arbitrary: xs) auto"], ["proof (state)\nthis:\n  finite_list xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_append:\n  assumes \"length\\<cdot>xs = MkI\\<cdot>n\" and \"n \\<le> m\"\n  shows \"(xs ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)", "using assms"], ["proof (prove)\nusing this:\n  length\\<cdot>xs = MkI\\<cdot>n\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. (xs ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)", "proof (induct xs arbitrary: n m)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>?n; ?n \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>?m = ys !! MkI\\<cdot>(?m - ?n)\n  length\\<cdot>(x : xs) = MkI\\<cdot>n\n  n \\<le> m\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>?n; ?n \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>?m = ys !! MkI\\<cdot>(?m - ?n)\n  length\\<cdot>(x : xs) = MkI\\<cdot>n\n  n \\<le> m", "have ge: \"n \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>?n; ?n \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>?m = ys !! MkI\\<cdot>(?m - ?n)\n  length\\<cdot>(x : xs) = MkI\\<cdot>n\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. 0 \\<le> n", "by (blast intro: length_ge_0)"], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "from Cons(2)"], ["proof (chain)\npicking this:\n  length\\<cdot>(x : xs) = MkI\\<cdot>n", "have len: \"length\\<cdot>xs = MkI\\<cdot>(n - 1)\""], ["proof (prove)\nusing this:\n  length\\<cdot>(x : xs) = MkI\\<cdot>n\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs = MkI\\<cdot>(n - 1)", "by (auto simp: plus_eq_MkI_conv one_Integer_def)"], ["proof (state)\nthis:\n  length\\<cdot>xs = MkI\\<cdot>(n - 1)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "from Cons(3)"], ["proof (chain)\npicking this:\n  n \\<le> m", "have le: \"n - 1 \\<le> m - 1\""], ["proof (prove)\nusing this:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. n - 1 \\<le> m - 1", "by simp"], ["proof (state)\nthis:\n  n - 1 \\<le> m - 1\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "{"], ["proof (state)\nthis:\n  n - 1 \\<le> m - 1\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "assume \"m < 0\""], ["proof (state)\nthis:\n  m < 0\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "with ge"], ["proof (chain)\npicking this:\n  0 \\<le> n\n  m < 0", "have ?case"], ["proof (prove)\nusing this:\n  0 \\<le> n\n  m < 0\n\ngoal (1 subgoal):\n 1. ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)", "using Cons(3)"], ["proof (prove)\nusing this:\n  0 \\<le> n\n  m < 0\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)", "by simp"], ["proof (state)\nthis:\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "}"], ["proof (state)\nthis:\n  m < 0 \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "moreover"], ["proof (state)\nthis:\n  m < 0 \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "{"], ["proof (state)\nthis:\n  m < 0 \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "assume \"m = 0\""], ["proof (state)\nthis:\n  m = 0\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "with Cons(3) and ge"], ["proof (chain)\npicking this:\n  n \\<le> m\n  0 \\<le> n\n  m = 0", "have \"n = 0\""], ["proof (prove)\nusing this:\n  n \\<le> m\n  0 \\<le> n\n  m = 0\n\ngoal (1 subgoal):\n 1. n = 0", "by simp"], ["proof (state)\nthis:\n  n = 0\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "with Cons(2)"], ["proof (chain)\npicking this:\n  length\\<cdot>(x : xs) = MkI\\<cdot>n\n  n = 0", "have ?case"], ["proof (prove)\nusing this:\n  length\\<cdot>(x : xs) = MkI\\<cdot>n\n  n = 0\n\ngoal (1 subgoal):\n 1. ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)", "by (auto dest: length_ge_0 simp: one_Integer_def plus_eq_MkI_conv)"], ["proof (state)\nthis:\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "}"], ["proof (state)\nthis:\n  m = 0 \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "moreover"], ["proof (state)\nthis:\n  m = 0 \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "{"], ["proof (state)\nthis:\n  m = 0 \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "assume \"m > 0\""], ["proof (state)\nthis:\n  0 < m\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "then"], ["proof (chain)\npicking this:\n  0 < m", "have ?case"], ["proof (prove)\nusing this:\n  0 < m\n\ngoal (1 subgoal):\n 1. ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)", "by (auto simp: Cons(1) [OF len le] zero_Integer_def one_Integer_def)"], ["proof (state)\nthis:\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "}"], ["proof (state)\nthis:\n  0 < m \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n 4. \\<And>a xs n m.\n       \\<lbrakk>\\<And>n m.\n                   \\<lbrakk>length\\<cdot>xs = MkI\\<cdot>n;\n                    n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> (xs ++ ys) !! MkI\\<cdot>m =\n                                     ys !! MkI\\<cdot>(m - n);\n        length\\<cdot>(a : xs) = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ((a : xs) ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)", "ultimately"], ["proof (chain)\npicking this:\n  m < 0 \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n  m = 0 \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n  0 < m \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)", "show ?case"], ["proof (prove)\nusing this:\n  m < 0 \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n  m = 0 \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n  0 < m \\<Longrightarrow>\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (1 subgoal):\n 1. ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)", "by arith"], ["proof (state)\nthis:\n  ((x : xs) ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               length\\<cdot>a = MkI\\<cdot>x \\<longrightarrow>\n               (\\<forall>xa\\<ge>x.\n                   (a ++ ys) !! MkI\\<cdot>xa = ys !! MkI\\<cdot>(xa - x)))\n 2. \\<And>n m.\n       \\<lbrakk>length\\<cdot>\\<bottom> = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> ++ ys) !! MkI\\<cdot>m =\n                         ys !! MkI\\<cdot>(m - n)\n 3. \\<And>n m.\n       \\<lbrakk>length\\<cdot>[] = MkI\\<cdot>n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> ([] ++ ys) !! MkI\\<cdot>m = ys !! MkI\\<cdot>(m - n)", "qed (simp_all add: zero_Integer_def)"], ["", "lemma replicate_nth [simp]:\n  assumes \"0 \\<le> n\"\n  shows \"(replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x ++ xs) !! MkI\\<cdot>n = xs !! MkI\\<cdot>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x ++ xs) !! MkI\\<cdot>n =\n    xs !! MkI\\<cdot>0", "using nth_append [OF length_replicate [OF assms], of n]"], ["proof (prove)\nusing this:\n  n \\<le> n \\<Longrightarrow>\n  (replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>?x1 ++ ?ys) !! MkI\\<cdot>n =\n  ?ys !! MkI\\<cdot>(n - n)\n\ngoal (1 subgoal):\n 1. (replicate\\<cdot>(MkI\\<cdot>n)\\<cdot>x ++ xs) !! MkI\\<cdot>n =\n    xs !! MkI\\<cdot>0", "by simp"], ["", "lemma map2_zip:\n  \"map\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>(zip\\<cdot>xs\\<cdot>ys) = zip\\<cdot>xs\\<cdot>(map\\<cdot>f\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>\n    (\\<Lambda> \\<langle>x, y\\<rangle>.\n        \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n    (zip\\<cdot>xs\\<cdot>ys) =\n    zip\\<cdot>xs\\<cdot>(map\\<cdot>f\\<cdot>ys)", "by (induct xs arbitrary: ys) (simp_all, case_tac ys, simp_all)"], ["", "lemma map2_filter:\n  \"map\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>(filter\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>xs)\n    = filter\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>(map\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>\n    (\\<Lambda> \\<langle>x, y\\<rangle>.\n        \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n    (filter\\<cdot>(\\<Lambda> \\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>xs) =\n    filter\\<cdot>(\\<Lambda> \\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>\n    (map\\<cdot>\n     (\\<Lambda> \\<langle>x, y\\<rangle>.\n         \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n     xs)", "apply (induct xs, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       map\\<cdot>\n       (\\<Lambda> \\<langle>x, y\\<rangle>.\n           \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n       (filter\\<cdot>(\\<Lambda> \\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>\n        xs) =\n       filter\\<cdot>(\\<Lambda> \\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>\n       (map\\<cdot>\n        (\\<Lambda> \\<langle>x, y\\<rangle>.\n            \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n        xs) \\<Longrightarrow>\n       map\\<cdot>\n       (\\<Lambda> \\<langle>x, y\\<rangle>.\n           \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n       (If case a of \\<langle>x, y\\<rangle> \\<Rightarrow> P\\<cdot>x\n        then a :\n             filter\\<cdot>\n             (\\<Lambda> \\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>\n             xs\n        else filter\\<cdot>\n             (\\<Lambda> \\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>\n             xs) =\n       If case case a of\n               \\<langle>x, y\\<rangle> \\<Rightarrow>\n                 \\<langle>x, f\\<cdot>y\\<rangle> of\n          \\<langle>x, y\\<rangle> \\<Rightarrow> P\\<cdot>x\n       then (case a of\n             \\<langle>x, y\\<rangle> \\<Rightarrow>\n               \\<langle>x, f\\<cdot>y\\<rangle>) :\n            filter\\<cdot>\n            (\\<Lambda> \\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>\n            (map\\<cdot>\n             (\\<Lambda> \\<langle>x, y\\<rangle>.\n                 \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n             xs)\n       else filter\\<cdot>\n            (\\<Lambda> \\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>\n            (map\\<cdot>\n             (\\<Lambda> \\<langle>x, y\\<rangle>.\n                 \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n             xs)", "apply (rename_tac x xs, case_tac x, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs a b.\n       \\<lbrakk>map\\<cdot>\n                (\\<Lambda> \\<langle>x, y\\<rangle>.\n                    \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n                (filter\\<cdot>\n                 (\\<Lambda> \\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>\n                 xs) =\n                filter\\<cdot>\n                (\\<Lambda> \\<langle>x, y\\<rangle>. P\\<cdot>x)\\<cdot>\n                (map\\<cdot>\n                 (\\<Lambda> \\<langle>x, y\\<rangle>.\n                     \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n                 xs);\n        x = \\<langle>a, b\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> map\\<cdot>\n                         (\\<Lambda> \\<langle>x, y\\<rangle>.\n                             \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n                         (If P\\<cdot>a\n                          then \\<langle>a, b\\<rangle> :\n                               filter\\<cdot>\n                               (\\<Lambda> \\<langle>x, y\\<rangle>.\n                                   P\\<cdot>x)\\<cdot>\n                               xs\n                          else filter\\<cdot>\n                               (\\<Lambda> \\<langle>x, y\\<rangle>.\n                                   P\\<cdot>x)\\<cdot>\n                               xs) =\n                         If P\\<cdot>a\n                         then \\<langle>a, f\\<cdot>b\\<rangle> :\n                              filter\\<cdot>\n                              (\\<Lambda> \\<langle>x, y\\<rangle>.\n                                  P\\<cdot>x)\\<cdot>\n                              (map\\<cdot>\n                               (\\<Lambda> \\<langle>x, y\\<rangle>.\n                                   \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n                               xs)\n                         else filter\\<cdot>\n                              (\\<Lambda> \\<langle>x, y\\<rangle>.\n                                  P\\<cdot>x)\\<cdot>\n                              (map\\<cdot>\n                               (\\<Lambda> \\<langle>x, y\\<rangle>.\n                                   \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n                               xs)", "apply (rename_tac a b, case_tac \"P\\<cdot>a\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_map_snd:\n  \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> map\\<cdot>f\\<cdot>(map\\<cdot>snd\\<cdot>xs)\n    = map\\<cdot>snd\\<cdot>(map\\<cdot>(\\<Lambda>\\<langle>x, y\\<rangle>. \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n    map\\<cdot>f\\<cdot>(map\\<cdot>snd\\<cdot>xs) =\n    map\\<cdot>snd\\<cdot>\n    (map\\<cdot>\n     (\\<Lambda> \\<langle>x, y\\<rangle>.\n         \\<langle>x, f\\<cdot>y\\<rangle>)\\<cdot>\n     xs)", "by (induct xs, simp_all, rename_tac a b, case_tac a, simp_all)"], ["", "lemma findIndices_Cons [simp]:\n  \"findIndices\\<cdot>P\\<cdot>(a : xs) =\n    If P\\<cdot>a then 0 : map\\<cdot>(+1)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)\n    else map\\<cdot>(+1)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. findIndices\\<cdot>P\\<cdot>(a : xs) =\n    If P\\<cdot>a\n    then 0 : map\\<cdot>(+1)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)\n    else map\\<cdot>(+1)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "by (auto simp: findIndices_def, subst intsFrom.simps, cases \"P\\<cdot>a\")\n     (simp_all\n       del: map_oo\n       add: map_oo [symmetric] map_map_snd one_Integer_def zero_Integer_def\n       map_plus_intsFrom [of 1 0, simplified, symmetric]\n       map2_zip [of \"(+ MkI\\<cdot>1)\", simplified]\n       map2_filter [of \"(+ MkI\\<cdot>1)\", simplified])"], ["", "lemma filter_alt_def:\n  fixes xs :: \"['a]\"\n  shows \"filter\\<cdot>P\\<cdot>xs = map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "fix f g :: \"Integer \\<rightarrow> 'a\"\n      and P :: \"'a \\<rightarrow> tr\"\n      and i xs"], ["proof (state)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "assume \"\\<forall>j\\<ge>i. f\\<cdot>(MkI\\<cdot>j) = g\\<cdot>(MkI\\<cdot>j)\""], ["proof (state)\nthis:\n  \\<forall>j\\<ge>i. f\\<cdot>(MkI\\<cdot>j) = g\\<cdot>(MkI\\<cdot>j)\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>j\\<ge>i. f\\<cdot>(MkI\\<cdot>j) = g\\<cdot>(MkI\\<cdot>j)", "have \"map\\<cdot>f\\<cdot>(map\\<cdot>snd\\<cdot>(filter\\<cdot>(\\<Lambda>\\<langle>x, i\\<rangle>. P\\<cdot>x)\\<cdot>(zip\\<cdot>xs\\<cdot>[MkI\\<cdot>i..])))\n      = map\\<cdot>g\\<cdot>(map\\<cdot>snd\\<cdot>(filter\\<cdot>(\\<Lambda>\\<langle>x, i\\<rangle>. P\\<cdot>x)\\<cdot>(zip\\<cdot>xs\\<cdot>[MkI\\<cdot>i..])))\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<ge>i. f\\<cdot>(MkI\\<cdot>j) = g\\<cdot>(MkI\\<cdot>j)\n\ngoal (1 subgoal):\n 1. map\\<cdot>f\\<cdot>\n    (map\\<cdot>snd\\<cdot>\n     (filter\\<cdot>(\\<Lambda> \\<langle>x, i\\<rangle>. P\\<cdot>x)\\<cdot>\n      (zip\\<cdot>xs\\<cdot>[MkI\\<cdot>i..]))) =\n    map\\<cdot>g\\<cdot>\n    (map\\<cdot>snd\\<cdot>\n     (filter\\<cdot>(\\<Lambda> \\<langle>x, i\\<rangle>. P\\<cdot>x)\\<cdot>\n      (zip\\<cdot>xs\\<cdot>[MkI\\<cdot>i..])))", "by (induct xs arbitrary: i, simp_all, subst (1 2) intsFrom.simps)\n        (rename_tac a b c, case_tac \"P\\<cdot>a\", simp_all add: one_Integer_def)"], ["proof (state)\nthis:\n  map\\<cdot>f\\<cdot>\n  (map\\<cdot>snd\\<cdot>\n   (filter\\<cdot>(\\<Lambda> \\<langle>x, i\\<rangle>. P\\<cdot>x)\\<cdot>\n    (zip\\<cdot>xs\\<cdot>[MkI\\<cdot>i..]))) =\n  map\\<cdot>g\\<cdot>\n  (map\\<cdot>snd\\<cdot>\n   (filter\\<cdot>(\\<Lambda> \\<langle>x, i\\<rangle>. P\\<cdot>x)\\<cdot>\n    (zip\\<cdot>xs\\<cdot>[MkI\\<cdot>i..])))\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "}"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>?i2.\n     ?f2\\<cdot>(MkI\\<cdot>j) = ?g2\\<cdot>(MkI\\<cdot>j) \\<Longrightarrow>\n  map\\<cdot>?f2\\<cdot>\n  (map\\<cdot>snd\\<cdot>\n   (filter\\<cdot>(\\<Lambda> \\<langle>x, i\\<rangle>. ?Pa2\\<cdot>x)\\<cdot>\n    (zip\\<cdot>?xsa2\\<cdot>[MkI\\<cdot>?i2..]))) =\n  map\\<cdot>?g2\\<cdot>\n  (map\\<cdot>snd\\<cdot>\n   (filter\\<cdot>(\\<Lambda> \\<langle>x, i\\<rangle>. ?Pa2\\<cdot>x)\\<cdot>\n    (zip\\<cdot>?xsa2\\<cdot>[MkI\\<cdot>?i2..])))\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "note 1 = this"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>?i2.\n     ?f2\\<cdot>(MkI\\<cdot>j) = ?g2\\<cdot>(MkI\\<cdot>j) \\<Longrightarrow>\n  map\\<cdot>?f2\\<cdot>\n  (map\\<cdot>snd\\<cdot>\n   (filter\\<cdot>(\\<Lambda> \\<langle>x, i\\<rangle>. ?Pa2\\<cdot>x)\\<cdot>\n    (zip\\<cdot>?xsa2\\<cdot>[MkI\\<cdot>?i2..]))) =\n  map\\<cdot>?g2\\<cdot>\n  (map\\<cdot>snd\\<cdot>\n   (filter\\<cdot>(\\<Lambda> \\<langle>x, i\\<rangle>. ?Pa2\\<cdot>x)\\<cdot>\n    (zip\\<cdot>?xsa2\\<cdot>[MkI\\<cdot>?i2..])))\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "{"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>?i2.\n     ?f2\\<cdot>(MkI\\<cdot>j) = ?g2\\<cdot>(MkI\\<cdot>j) \\<Longrightarrow>\n  map\\<cdot>?f2\\<cdot>\n  (map\\<cdot>snd\\<cdot>\n   (filter\\<cdot>(\\<Lambda> \\<langle>x, i\\<rangle>. ?Pa2\\<cdot>x)\\<cdot>\n    (zip\\<cdot>?xsa2\\<cdot>[MkI\\<cdot>?i2..]))) =\n  map\\<cdot>?g2\\<cdot>\n  (map\\<cdot>snd\\<cdot>\n   (filter\\<cdot>(\\<Lambda> \\<langle>x, i\\<rangle>. ?Pa2\\<cdot>x)\\<cdot>\n    (zip\\<cdot>?xsa2\\<cdot>[MkI\\<cdot>?i2..])))\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "fix a and ys :: \"['a]\""], ["proof (state)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "have \"\\<forall>i\\<ge>0. nth\\<cdot>ys\\<cdot>(MkI\\<cdot>i) = (nth\\<cdot>(a : ys) oo (+1))\\<cdot>(MkI\\<cdot>i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>0.\n       ys !! MkI\\<cdot>i = (nth\\<cdot>(a : ys) oo (+1))\\<cdot>(MkI\\<cdot>i)", "by (auto simp: one_Integer_def zero_Integer_def)"], ["proof (state)\nthis:\n  \\<forall>i\\<ge>0.\n     ys !! MkI\\<cdot>i = (nth\\<cdot>(a : ys) oo (+1))\\<cdot>(MkI\\<cdot>i)\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "}"], ["proof (state)\nthis:\n  \\<forall>i\\<ge>0.\n     ?ys2 !! MkI\\<cdot>i =\n     (nth\\<cdot>(?a2 : ?ys2) oo (+1))\\<cdot>(MkI\\<cdot>i)\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "note 2 = this"], ["proof (state)\nthis:\n  \\<forall>i\\<ge>0.\n     ?ys2 !! MkI\\<cdot>i =\n     (nth\\<cdot>(?a2 : ?ys2) oo (+1))\\<cdot>(MkI\\<cdot>i)\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "{"], ["proof (state)\nthis:\n  \\<forall>i\\<ge>0.\n     ?ys2 !! MkI\\<cdot>i =\n     (nth\\<cdot>(?a2 : ?ys2) oo (+1))\\<cdot>(MkI\\<cdot>i)\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "fix a P and ys xs :: \"['a]\""], ["proof (state)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "have \"map\\<cdot>(nth\\<cdot>(a : ys) oo (+1))\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)\n      = map\\<cdot>(nth\\<cdot>ys)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>(nth\\<cdot>(a : ys) oo (+1))\\<cdot>\n    (findIndices\\<cdot>P\\<cdot>xs) =\n    map\\<cdot>(nth\\<cdot>ys)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "by (simp add: findIndices_def 1 [OF 2, simplified, of ys P xs a] zero_Integer_def)"], ["proof (state)\nthis:\n  map\\<cdot>(nth\\<cdot>(a : ys) oo (+1))\\<cdot>\n  (findIndices\\<cdot>P\\<cdot>xs) =\n  map\\<cdot>(nth\\<cdot>ys)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "}"], ["proof (state)\nthis:\n  map\\<cdot>(nth\\<cdot>(?a2 : ?ys2) oo (+1))\\<cdot>\n  (findIndices\\<cdot>?Pa2\\<cdot>?xsa2) =\n  map\\<cdot>(nth\\<cdot>?ys2)\\<cdot>(findIndices\\<cdot>?Pa2\\<cdot>?xsa2)\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "note 3 = this"], ["proof (state)\nthis:\n  map\\<cdot>(nth\\<cdot>(?a2 : ?ys2) oo (+1))\\<cdot>\n  (findIndices\\<cdot>?Pa2\\<cdot>?xsa2) =\n  map\\<cdot>(nth\\<cdot>?ys2)\\<cdot>(findIndices\\<cdot>?Pa2\\<cdot>?xsa2)\n\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\\<cdot>P\\<cdot>xs =\n    map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)", "by (induct xs, simp_all, simp add: findIndices_def, simp add: findIndices_def)\n       (rename_tac a b, case_tac \"P\\<cdot>a\", simp add: findIndices_def, simp_all add: 3)"], ["proof (state)\nthis:\n  filter\\<cdot>P\\<cdot>xs =\n  map\\<cdot>(nth\\<cdot>xs)\\<cdot>(findIndices\\<cdot>P\\<cdot>xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation cfun_image :: \"('a \\<rightarrow> 'b) \\<Rightarrow> 'a set \\<Rightarrow> 'b set\" (infixr \"`\\<cdot>\" 90) where\n  \"f `\\<cdot> A \\<equiv> Rep_cfun f ` A\""], ["", "lemma set_map:\n  \"set (map\\<cdot>f\\<cdot>xs) = f `\\<cdot> set xs\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map\\<cdot>f\\<cdot>xs) = f `\\<cdot> set xs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs\n 2. f `\\<cdot> set xs \\<subseteq> set (map\\<cdot>f\\<cdot>xs)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs\n 2. f `\\<cdot> set xs \\<subseteq> set (map\\<cdot>f\\<cdot>xs)", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs\n 2. f `\\<cdot> set xs \\<subseteq> set (map\\<cdot>f\\<cdot>xs)", "assume \"listmem a xs\""], ["proof (state)\nthis:\n  listmem a xs\n\ngoal (2 subgoals):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs\n 2. f `\\<cdot> set xs \\<subseteq> set (map\\<cdot>f\\<cdot>xs)", "then"], ["proof (chain)\npicking this:\n  listmem a xs", "have \"listmem (f\\<cdot>a) (map\\<cdot>f\\<cdot>xs)\""], ["proof (prove)\nusing this:\n  listmem a xs\n\ngoal (1 subgoal):\n 1. listmem (f\\<cdot>a) (map\\<cdot>f\\<cdot>xs)", "by (induct) simp_all"], ["proof (state)\nthis:\n  listmem (f\\<cdot>a) (map\\<cdot>f\\<cdot>xs)\n\ngoal (2 subgoals):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs\n 2. f `\\<cdot> set xs \\<subseteq> set (map\\<cdot>f\\<cdot>xs)", "}"], ["proof (state)\nthis:\n  listmem ?a2 xs \\<Longrightarrow>\n  listmem (f\\<cdot>?a2) (map\\<cdot>f\\<cdot>xs)\n\ngoal (2 subgoals):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs\n 2. f `\\<cdot> set xs \\<subseteq> set (map\\<cdot>f\\<cdot>xs)", "then"], ["proof (chain)\npicking this:\n  listmem ?a2 xs \\<Longrightarrow>\n  listmem (f\\<cdot>?a2) (map\\<cdot>f\\<cdot>xs)", "show \"?r \\<subseteq> ?l\""], ["proof (prove)\nusing this:\n  listmem ?a2 xs \\<Longrightarrow>\n  listmem (f\\<cdot>?a2) (map\\<cdot>f\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. f `\\<cdot> set xs \\<subseteq> set (map\\<cdot>f\\<cdot>xs)", "by (auto simp: set_def)"], ["proof (state)\nthis:\n  f `\\<cdot> set xs \\<subseteq> set (map\\<cdot>f\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs", "assume \"listmem a (map\\<cdot>f\\<cdot>xs)\""], ["proof (state)\nthis:\n  listmem a (map\\<cdot>f\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs", "then"], ["proof (chain)\npicking this:\n  listmem a (map\\<cdot>f\\<cdot>xs)", "have \"\\<exists>b. a = f\\<cdot>b \\<and> listmem b xs\""], ["proof (prove)\nusing this:\n  listmem a (map\\<cdot>f\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. \\<exists>b. a = f\\<cdot>b \\<and> listmem b xs", "by (induct a \"map\\<cdot>f\\<cdot>xs\" arbitrary: xs)\n       (rename_tac xsa, case_tac xsa, auto)+"], ["proof (state)\nthis:\n  \\<exists>b. a = f\\<cdot>b \\<and> listmem b xs\n\ngoal (1 subgoal):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs", "}"], ["proof (state)\nthis:\n  listmem ?a2 (map\\<cdot>f\\<cdot>xs) \\<Longrightarrow>\n  \\<exists>b. ?a2 = f\\<cdot>b \\<and> listmem b xs\n\ngoal (1 subgoal):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs", "then"], ["proof (chain)\npicking this:\n  listmem ?a2 (map\\<cdot>f\\<cdot>xs) \\<Longrightarrow>\n  \\<exists>b. ?a2 = f\\<cdot>b \\<and> listmem b xs", "show \"?l \\<subseteq> ?r\""], ["proof (prove)\nusing this:\n  listmem ?a2 (map\\<cdot>f\\<cdot>xs) \\<Longrightarrow>\n  \\<exists>b. ?a2 = f\\<cdot>b \\<and> listmem b xs\n\ngoal (1 subgoal):\n 1. set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs", "unfolding set_def"], ["proof (prove)\nusing this:\n  listmem ?a2 (map\\<cdot>f\\<cdot>xs) \\<Longrightarrow>\n  \\<exists>b. ?a2 = f\\<cdot>b \\<and> listmem b xs\n\ngoal (1 subgoal):\n 1. {x. listmem x (map\\<cdot>f\\<cdot>xs)}\n    \\<subseteq> f `\\<cdot> {x. listmem x xs}", "by auto"], ["proof (state)\nthis:\n  set (map\\<cdot>f\\<cdot>xs) \\<subseteq> f `\\<cdot> set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{const reverse} and @{const reverse} induction\\<close>"], ["", "text \\<open>Alternative simplification rules for @{const reverse} (easier\nto use for equational reasoning):\\<close>"], ["", "lemma reverse_Nil [simp]:\n  \"reverse\\<cdot>[] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>[] = []", "by (simp add: reverse.simps)"], ["", "lemma reverse_singleton [simp]:\n  \"reverse\\<cdot>[x] = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>[x] = [x]", "by (simp add: reverse.simps)"], ["", "lemma reverse_strict [simp]:\n  \"reverse\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: reverse.simps)"], ["", "lemma foldl_flip_Cons_append:\n  \"foldl\\<cdot>(flip\\<cdot>(:))\\<cdot>ys\\<cdot>xs = foldl\\<cdot>(flip\\<cdot>(:))\\<cdot>[]\\<cdot>xs ++ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>xs =\n    foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>xs ++ ys", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>x\\<cdot>a =\n               foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>a ++ x)\n 2. \\<And>ys.\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>\\<bottom> =\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>\\<bottom> ++ ys\n 3. \\<And>ys.\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>[] =\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>[] ++ ys\n 4. \\<And>a xs ys.\n       (\\<And>ys.\n           foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>xs =\n           foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>xs ++\n           ys) \\<Longrightarrow>\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>(a : xs) =\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>(a : xs) ++ ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>?ys\\<cdot>xs =\n  foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>xs ++ ?ys\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>x\\<cdot>a =\n               foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>a ++ x)\n 2. \\<And>ys.\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>\\<bottom> =\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>\\<bottom> ++ ys\n 3. \\<And>ys.\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>[] =\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>[] ++ ys\n 4. \\<And>a xs ys.\n       (\\<And>ys.\n           foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>xs =\n           foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>xs ++\n           ys) \\<Longrightarrow>\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>(a : xs) =\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>(a : xs) ++ ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>(x : xs) =\n    foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>(x : xs) ++ ys", "by simp (metis (no_types) Cons append.simps append_assoc)"], ["proof (state)\nthis:\n  foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>(x : xs) =\n  foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>(x : xs) ++ ys\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>x\\<cdot>a =\n               foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>a ++ x)\n 2. \\<And>ys.\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>\\<bottom> =\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>\\<bottom> ++ ys\n 3. \\<And>ys.\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>ys\\<cdot>[] =\n       foldl\\<cdot>(flip\\<cdot>Cons)\\<cdot>[]\\<cdot>[] ++ ys", "qed simp+"], ["", "lemma reverse_Cons [simp]:\n  \"reverse\\<cdot>(x:xs) = reverse\\<cdot>xs ++ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>(x : xs) = reverse\\<cdot>xs ++ [x]", "by (simp add: reverse.simps)\n     (subst foldl_flip_Cons_append, rule refl)"], ["", "lemma reverse_append_below:\n  \"reverse\\<cdot>(xs ++ ys) \\<sqsubseteq> reverse\\<cdot>ys ++ reverse\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>(xs ++ ys) \\<sqsubseteq>\n    reverse\\<cdot>ys ++ reverse\\<cdot>xs", "apply (induction xs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            reverse\\<cdot>(a ++ ys) \\<sqsubseteq>\n            reverse\\<cdot>ys ++ reverse\\<cdot>a)\n 2. reverse\\<cdot>(\\<bottom> ++ ys) \\<sqsubseteq>\n    reverse\\<cdot>ys ++ reverse\\<cdot>\\<bottom>\n 3. reverse\\<cdot>([] ++ ys) \\<sqsubseteq>\n    reverse\\<cdot>ys ++ reverse\\<cdot>[]\n 4. \\<And>a xs.\n       reverse\\<cdot>(xs ++ ys) \\<sqsubseteq>\n       reverse\\<cdot>ys ++ reverse\\<cdot>xs \\<Longrightarrow>\n       reverse\\<cdot>((a : xs) ++ ys) \\<sqsubseteq>\n       reverse\\<cdot>ys ++ reverse\\<cdot>(a : xs)", "apply (simp del: append_assoc add: append_assoc [symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       reverse\\<cdot>(xs ++ ys) \\<sqsubseteq>\n       reverse\\<cdot>ys ++ reverse\\<cdot>xs \\<Longrightarrow>\n       reverse\\<cdot>(xs ++ ys) ++ [a] \\<sqsubseteq>\n       (reverse\\<cdot>ys ++ reverse\\<cdot>xs) ++ [a]", "apply (blast intro: monofun_cfun append_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reverse_reverse_below:\n  \"reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs", "proof (induction xs)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. reverse\\<cdot>(reverse\\<cdot>a) \\<sqsubseteq> a)\n 2. reverse\\<cdot>(reverse\\<cdot>\\<bottom>) \\<sqsubseteq> \\<bottom>\n 3. reverse\\<cdot>(reverse\\<cdot>[]) \\<sqsubseteq> []\n 4. \\<And>a xs.\n       reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs \\<Longrightarrow>\n       reverse\\<cdot>(reverse\\<cdot>(a : xs)) \\<sqsubseteq> a : xs", "case (Cons x xs)"], ["proof (state)\nthis:\n  reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. reverse\\<cdot>(reverse\\<cdot>a) \\<sqsubseteq> a)\n 2. reverse\\<cdot>(reverse\\<cdot>\\<bottom>) \\<sqsubseteq> \\<bottom>\n 3. reverse\\<cdot>(reverse\\<cdot>[]) \\<sqsubseteq> []\n 4. \\<And>a xs.\n       reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs \\<Longrightarrow>\n       reverse\\<cdot>(reverse\\<cdot>(a : xs)) \\<sqsubseteq> a : xs", "have \"reverse\\<cdot>(reverse\\<cdot>(x:xs)) = reverse\\<cdot>(reverse\\<cdot>xs ++ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>(reverse\\<cdot>(x : xs)) =\n    reverse\\<cdot>(reverse\\<cdot>xs ++ [x])", "by simp"], ["proof (state)\nthis:\n  reverse\\<cdot>(reverse\\<cdot>(x : xs)) =\n  reverse\\<cdot>(reverse\\<cdot>xs ++ [x])\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. reverse\\<cdot>(reverse\\<cdot>a) \\<sqsubseteq> a)\n 2. reverse\\<cdot>(reverse\\<cdot>\\<bottom>) \\<sqsubseteq> \\<bottom>\n 3. reverse\\<cdot>(reverse\\<cdot>[]) \\<sqsubseteq> []\n 4. \\<And>a xs.\n       reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs \\<Longrightarrow>\n       reverse\\<cdot>(reverse\\<cdot>(a : xs)) \\<sqsubseteq> a : xs", "also"], ["proof (state)\nthis:\n  reverse\\<cdot>(reverse\\<cdot>(x : xs)) =\n  reverse\\<cdot>(reverse\\<cdot>xs ++ [x])\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. reverse\\<cdot>(reverse\\<cdot>a) \\<sqsubseteq> a)\n 2. reverse\\<cdot>(reverse\\<cdot>\\<bottom>) \\<sqsubseteq> \\<bottom>\n 3. reverse\\<cdot>(reverse\\<cdot>[]) \\<sqsubseteq> []\n 4. \\<And>a xs.\n       reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs \\<Longrightarrow>\n       reverse\\<cdot>(reverse\\<cdot>(a : xs)) \\<sqsubseteq> a : xs", "have \"\\<dots> \\<sqsubseteq> reverse\\<cdot>[x] ++ reverse\\<cdot>(reverse\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>(reverse\\<cdot>xs ++ [x]) \\<sqsubseteq>\n    reverse\\<cdot>[x] ++ reverse\\<cdot>(reverse\\<cdot>xs)", "by (rule reverse_append_below)"], ["proof (state)\nthis:\n  reverse\\<cdot>(reverse\\<cdot>xs ++ [x]) \\<sqsubseteq>\n  reverse\\<cdot>[x] ++ reverse\\<cdot>(reverse\\<cdot>xs)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. reverse\\<cdot>(reverse\\<cdot>a) \\<sqsubseteq> a)\n 2. reverse\\<cdot>(reverse\\<cdot>\\<bottom>) \\<sqsubseteq> \\<bottom>\n 3. reverse\\<cdot>(reverse\\<cdot>[]) \\<sqsubseteq> []\n 4. \\<And>a xs.\n       reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs \\<Longrightarrow>\n       reverse\\<cdot>(reverse\\<cdot>(a : xs)) \\<sqsubseteq> a : xs", "also"], ["proof (state)\nthis:\n  reverse\\<cdot>(reverse\\<cdot>xs ++ [x]) \\<sqsubseteq>\n  reverse\\<cdot>[x] ++ reverse\\<cdot>(reverse\\<cdot>xs)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. reverse\\<cdot>(reverse\\<cdot>a) \\<sqsubseteq> a)\n 2. reverse\\<cdot>(reverse\\<cdot>\\<bottom>) \\<sqsubseteq> \\<bottom>\n 3. reverse\\<cdot>(reverse\\<cdot>[]) \\<sqsubseteq> []\n 4. \\<And>a xs.\n       reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs \\<Longrightarrow>\n       reverse\\<cdot>(reverse\\<cdot>(a : xs)) \\<sqsubseteq> a : xs", "have \"\\<dots> = x : reverse\\<cdot>(reverse\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>[x] ++ reverse\\<cdot>(reverse\\<cdot>xs) =\n    x : reverse\\<cdot>(reverse\\<cdot>xs)", "by simp"], ["proof (state)\nthis:\n  reverse\\<cdot>[x] ++ reverse\\<cdot>(reverse\\<cdot>xs) =\n  x : reverse\\<cdot>(reverse\\<cdot>xs)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. reverse\\<cdot>(reverse\\<cdot>a) \\<sqsubseteq> a)\n 2. reverse\\<cdot>(reverse\\<cdot>\\<bottom>) \\<sqsubseteq> \\<bottom>\n 3. reverse\\<cdot>(reverse\\<cdot>[]) \\<sqsubseteq> []\n 4. \\<And>a xs.\n       reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs \\<Longrightarrow>\n       reverse\\<cdot>(reverse\\<cdot>(a : xs)) \\<sqsubseteq> a : xs", "also"], ["proof (state)\nthis:\n  reverse\\<cdot>[x] ++ reverse\\<cdot>(reverse\\<cdot>xs) =\n  x : reverse\\<cdot>(reverse\\<cdot>xs)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. reverse\\<cdot>(reverse\\<cdot>a) \\<sqsubseteq> a)\n 2. reverse\\<cdot>(reverse\\<cdot>\\<bottom>) \\<sqsubseteq> \\<bottom>\n 3. reverse\\<cdot>(reverse\\<cdot>[]) \\<sqsubseteq> []\n 4. \\<And>a xs.\n       reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs \\<Longrightarrow>\n       reverse\\<cdot>(reverse\\<cdot>(a : xs)) \\<sqsubseteq> a : xs", "have \"\\<dots> \\<sqsubseteq> x : xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x : reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> x : xs", "by (simp add: Cons)"], ["proof (state)\nthis:\n  x : reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> x : xs\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. reverse\\<cdot>(reverse\\<cdot>a) \\<sqsubseteq> a)\n 2. reverse\\<cdot>(reverse\\<cdot>\\<bottom>) \\<sqsubseteq> \\<bottom>\n 3. reverse\\<cdot>(reverse\\<cdot>[]) \\<sqsubseteq> []\n 4. \\<And>a xs.\n       reverse\\<cdot>(reverse\\<cdot>xs) \\<sqsubseteq> xs \\<Longrightarrow>\n       reverse\\<cdot>(reverse\\<cdot>(a : xs)) \\<sqsubseteq> a : xs", "finally"], ["proof (chain)\npicking this:\n  reverse\\<cdot>(reverse\\<cdot>(x : xs)) \\<sqsubseteq> x : xs", "show ?case"], ["proof (prove)\nusing this:\n  reverse\\<cdot>(reverse\\<cdot>(x : xs)) \\<sqsubseteq> x : xs\n\ngoal (1 subgoal):\n 1. reverse\\<cdot>(reverse\\<cdot>(x : xs)) \\<sqsubseteq> x : xs", "."], ["proof (state)\nthis:\n  reverse\\<cdot>(reverse\\<cdot>(x : xs)) \\<sqsubseteq> x : xs\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a. reverse\\<cdot>(reverse\\<cdot>a) \\<sqsubseteq> a)\n 2. reverse\\<cdot>(reverse\\<cdot>\\<bottom>) \\<sqsubseteq> \\<bottom>\n 3. reverse\\<cdot>(reverse\\<cdot>[]) \\<sqsubseteq> []", "qed simp+"], ["", "lemma reverse_append [simp]:\n  assumes \"finite_list xs\"\n  shows \"reverse\\<cdot>(xs ++ ys) = reverse\\<cdot>ys ++ reverse\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>(xs ++ ys) = reverse\\<cdot>ys ++ reverse\\<cdot>xs", "using assms"], ["proof (prove)\nusing this:\n  finite_list xs\n\ngoal (1 subgoal):\n 1. reverse\\<cdot>(xs ++ ys) = reverse\\<cdot>ys ++ reverse\\<cdot>xs", "by (induct xs) simp+"], ["", "lemma reverse_spine_strict:\n  \"\\<not> finite_list xs \\<Longrightarrow> reverse\\<cdot>xs = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> finite_list xs \\<Longrightarrow> reverse\\<cdot>xs = \\<bottom>", "by (auto simp add: reverse.simps foldl_spine_strict)"], ["", "lemma reverse_finite [simp]:\n  assumes \"finite_list xs\" shows \"finite_list (reverse\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_list (reverse\\<cdot>xs)", "using assms"], ["proof (prove)\nusing this:\n  finite_list xs\n\ngoal (1 subgoal):\n 1. finite_list (reverse\\<cdot>xs)", "by (induct xs) simp+"], ["", "lemma reverse_reverse [simp]:\n  assumes \"finite_list xs\" shows \"reverse\\<cdot>(reverse\\<cdot>xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>(reverse\\<cdot>xs) = xs", "using assms"], ["proof (prove)\nusing this:\n  finite_list xs\n\ngoal (1 subgoal):\n 1. reverse\\<cdot>(reverse\\<cdot>xs) = xs", "by (induct xs) simp+"], ["", "lemma reverse_induct [consumes 1, case_names Nil snoc]:\n  \"\\<lbrakk>finite_list xs; P []; \\<And>x xs . finite_list xs \\<Longrightarrow> P xs \\<Longrightarrow> P (xs ++ [x])\\<rbrakk> \\<Longrightarrow> P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_list xs; P [];\n     \\<And>x xs.\n        \\<lbrakk>finite_list xs; P xs\\<rbrakk>\n        \\<Longrightarrow> P (xs ++ [x])\\<rbrakk>\n    \\<Longrightarrow> P xs", "apply (subst reverse_reverse [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite_list xs; P [];\n     \\<And>x xs.\n        \\<lbrakk>finite_list xs; P xs\\<rbrakk>\n        \\<Longrightarrow> P (xs ++ [x])\\<rbrakk>\n    \\<Longrightarrow> finite_list xs\n 2. \\<lbrakk>finite_list xs; P [];\n     \\<And>x xs.\n        \\<lbrakk>finite_list xs; P xs\\<rbrakk>\n        \\<Longrightarrow> P (xs ++ [x])\\<rbrakk>\n    \\<Longrightarrow> P (reverse\\<cdot>(reverse\\<cdot>xs))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_list xs; P [];\n     \\<And>x xs.\n        \\<lbrakk>finite_list xs; P xs\\<rbrakk>\n        \\<Longrightarrow> P (xs ++ [x])\\<rbrakk>\n    \\<Longrightarrow> P (reverse\\<cdot>(reverse\\<cdot>xs))", "apply (rule finite_list.induct[where x = \"reverse\\<cdot>xs\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite_list xs; P [];\n     \\<And>x xs.\n        \\<lbrakk>finite_list xs; P xs\\<rbrakk>\n        \\<Longrightarrow> P (xs ++ [x])\\<rbrakk>\n    \\<Longrightarrow> finite_list (reverse\\<cdot>xs)\n 2. \\<lbrakk>finite_list xs; P [];\n     \\<And>x xs.\n        \\<lbrakk>finite_list xs; P xs\\<rbrakk>\n        \\<Longrightarrow> P (xs ++ [x])\\<rbrakk>\n    \\<Longrightarrow> P (reverse\\<cdot>[])\n 3. \\<And>x xsa.\n       \\<lbrakk>finite_list xs; P [];\n        \\<And>x xs.\n           \\<lbrakk>finite_list xs; P xs\\<rbrakk>\n           \\<Longrightarrow> P (xs ++ [x]);\n        finite_list xsa; P (reverse\\<cdot>xsa)\\<rbrakk>\n       \\<Longrightarrow> P (reverse\\<cdot>(x : xsa))", "apply simp+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_plus_not_0:\n  \"le\\<cdot>1\\<cdot>n = TT \\<Longrightarrow> le\\<cdot>(length\\<cdot>xs + n)\\<cdot>0 = TT \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n     le\\<cdot>(length\\<cdot>xs + n)\\<cdot>0 = TT\\<rbrakk>\n    \\<Longrightarrow> False", "proof (induct xs arbitrary: n)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               le\\<cdot>1\\<cdot>x = TT \\<longrightarrow>\n               le\\<cdot>(length\\<cdot>a + x)\\<cdot>0 = TT \\<longrightarrow>\n               False)\n 2. \\<And>n.\n       \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>\\<bottom> + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n.\n       \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>[] + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n                    le\\<cdot>(length\\<cdot>xs + n)\\<cdot>0 = TT\\<rbrakk>\n                   \\<Longrightarrow> False;\n        le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>(a : xs) + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  le\\<cdot>1\\<cdot>n = TT\n  le\\<cdot>(length\\<cdot>[] + n)\\<cdot>0 = TT\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               le\\<cdot>1\\<cdot>x = TT \\<longrightarrow>\n               le\\<cdot>(length\\<cdot>a + x)\\<cdot>0 = TT \\<longrightarrow>\n               False)\n 2. \\<And>n.\n       \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>\\<bottom> + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n.\n       \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>[] + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n                    le\\<cdot>(length\\<cdot>xs + n)\\<cdot>0 = TT\\<rbrakk>\n                   \\<Longrightarrow> False;\n        le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>(a : xs) + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  le\\<cdot>1\\<cdot>n = TT\n  le\\<cdot>(length\\<cdot>[] + n)\\<cdot>0 = TT", "show ?case"], ["proof (prove)\nusing this:\n  le\\<cdot>1\\<cdot>n = TT\n  le\\<cdot>(length\\<cdot>[] + n)\\<cdot>0 = TT\n\ngoal (1 subgoal):\n 1. False", "by auto (metis Ord_linear_class.le_trans dist_eq_tr(3) le_Integer_numeral_simps(3))"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               le\\<cdot>1\\<cdot>x = TT \\<longrightarrow>\n               le\\<cdot>(length\\<cdot>a + x)\\<cdot>0 = TT \\<longrightarrow>\n               False)\n 2. \\<And>n.\n       \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>\\<bottom> + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n                    le\\<cdot>(length\\<cdot>xs + n)\\<cdot>0 = TT\\<rbrakk>\n                   \\<Longrightarrow> False;\n        le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>(a : xs) + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               le\\<cdot>1\\<cdot>x = TT \\<longrightarrow>\n               le\\<cdot>(length\\<cdot>a + x)\\<cdot>0 = TT \\<longrightarrow>\n               False)\n 2. \\<And>n.\n       \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>\\<bottom> + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n                    le\\<cdot>(length\\<cdot>xs + n)\\<cdot>0 = TT\\<rbrakk>\n                   \\<Longrightarrow> False;\n        le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>(a : xs) + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>le\\<cdot>1\\<cdot>?n = TT;\n   le\\<cdot>(length\\<cdot>xs + ?n)\\<cdot>0 = TT\\<rbrakk>\n  \\<Longrightarrow> False\n  le\\<cdot>1\\<cdot>n = TT\n  le\\<cdot>(length\\<cdot>(x : xs) + n)\\<cdot>0 = TT\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               le\\<cdot>1\\<cdot>x = TT \\<longrightarrow>\n               le\\<cdot>(length\\<cdot>a + x)\\<cdot>0 = TT \\<longrightarrow>\n               False)\n 2. \\<And>n.\n       \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>\\<bottom> + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n                    le\\<cdot>(length\\<cdot>xs + n)\\<cdot>0 = TT\\<rbrakk>\n                   \\<Longrightarrow> False;\n        le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>(a : xs) + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False", "from Cons(1) [of \"n + 1\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>le\\<cdot>1\\<cdot>(n + 1) = TT;\n   le\\<cdot>(length\\<cdot>xs + (n + 1))\\<cdot>0 = TT\\<rbrakk>\n  \\<Longrightarrow> False", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>le\\<cdot>1\\<cdot>(n + 1) = TT;\n   le\\<cdot>(length\\<cdot>xs + (n + 1))\\<cdot>0 = TT\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "using Cons(2-)"], ["proof (prove)\nusing this:\n  \\<lbrakk>le\\<cdot>1\\<cdot>(n + 1) = TT;\n   le\\<cdot>(length\\<cdot>xs + (n + 1))\\<cdot>0 = TT\\<rbrakk>\n  \\<Longrightarrow> False\n  le\\<cdot>1\\<cdot>n = TT\n  le\\<cdot>(length\\<cdot>(x : xs) + n)\\<cdot>0 = TT\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: ac_simps dest: le_plus_1)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               le\\<cdot>1\\<cdot>x = TT \\<longrightarrow>\n               le\\<cdot>(length\\<cdot>a + x)\\<cdot>0 = TT \\<longrightarrow>\n               False)\n 2. \\<And>n.\n       \\<lbrakk>le\\<cdot>1\\<cdot>n = TT;\n        le\\<cdot>(length\\<cdot>\\<bottom> + n)\\<cdot>0 = TT\\<rbrakk>\n       \\<Longrightarrow> False", "qed simp+"], ["", "lemma take_length_plus_1:\n  \"length\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow> take\\<cdot>(length\\<cdot>xs + 1)\\<cdot>(y:ys) = y : take\\<cdot>(length\\<cdot>xs)\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>xs + 1)\\<cdot>(y : ys) =\n    y : take\\<cdot>(length\\<cdot>xs)\\<cdot>ys", "by (subst take.simps, cases \"le\\<cdot>(length\\<cdot>xs + 1)\\<cdot>0\")\n     (auto, metis (no_types) length_plus_not_0 le_Integer_numeral_simps(4))"], ["", "lemma le_length_plus:\n  \"length\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow> n \\<noteq> \\<bottom> \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>xs + n) = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length\\<cdot>xs \\<noteq> \\<bottom>;\n     n \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>xs + n) = TT", "proof (induct xs arbitrary: n)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            length\\<cdot>a \\<noteq> \\<bottom> \\<longrightarrow>\n            (\\<forall>x.\n                x \\<noteq> \\<bottom> \\<longrightarrow>\n                le\\<cdot>x\\<cdot>(length\\<cdot>a + x) = TT))\n 2. \\<And>n.\n       \\<lbrakk>length\\<cdot>\\<bottom> \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>\\<bottom> + n) = TT\n 3. \\<And>n.\n       \\<lbrakk>length\\<cdot>[] \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>[] + n) = TT\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>length\\<cdot>xs \\<noteq> \\<bottom>;\n                    n \\<noteq> \\<bottom>\\<rbrakk>\n                   \\<Longrightarrow> le\\<cdot>n\\<cdot>\n                                     (length\\<cdot>xs + n) =\n                                     TT;\n        length\\<cdot>(a : xs) \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>(a : xs) + n) = TT", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>length\\<cdot>xs \\<noteq> \\<bottom>;\n   ?n \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> le\\<cdot>?n\\<cdot>(length\\<cdot>xs + ?n) = TT\n  length\\<cdot>(x : xs) \\<noteq> \\<bottom>\n  n \\<noteq> \\<bottom>\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            length\\<cdot>a \\<noteq> \\<bottom> \\<longrightarrow>\n            (\\<forall>x.\n                x \\<noteq> \\<bottom> \\<longrightarrow>\n                le\\<cdot>x\\<cdot>(length\\<cdot>a + x) = TT))\n 2. \\<And>n.\n       \\<lbrakk>length\\<cdot>\\<bottom> \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>\\<bottom> + n) = TT\n 3. \\<And>n.\n       \\<lbrakk>length\\<cdot>[] \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>[] + n) = TT\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>length\\<cdot>xs \\<noteq> \\<bottom>;\n                    n \\<noteq> \\<bottom>\\<rbrakk>\n                   \\<Longrightarrow> le\\<cdot>n\\<cdot>\n                                     (length\\<cdot>xs + n) =\n                                     TT;\n        length\\<cdot>(a : xs) \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>(a : xs) + n) = TT", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length\\<cdot>xs \\<noteq> \\<bottom>;\n   ?n \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> le\\<cdot>?n\\<cdot>(length\\<cdot>xs + ?n) = TT\n  length\\<cdot>(x : xs) \\<noteq> \\<bottom>\n  n \\<noteq> \\<bottom>", "have \"le\\<cdot>(n + 1)\\<cdot>(length\\<cdot>xs + (n + 1)) = TT\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length\\<cdot>xs \\<noteq> \\<bottom>;\n   ?n \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> le\\<cdot>?n\\<cdot>(length\\<cdot>xs + ?n) = TT\n  length\\<cdot>(x : xs) \\<noteq> \\<bottom>\n  n \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. le\\<cdot>(n + 1)\\<cdot>(length\\<cdot>xs + (n + 1)) = TT", "by simp"], ["proof (state)\nthis:\n  le\\<cdot>(n + 1)\\<cdot>(length\\<cdot>xs + (n + 1)) = TT\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            length\\<cdot>a \\<noteq> \\<bottom> \\<longrightarrow>\n            (\\<forall>x.\n                x \\<noteq> \\<bottom> \\<longrightarrow>\n                le\\<cdot>x\\<cdot>(length\\<cdot>a + x) = TT))\n 2. \\<And>n.\n       \\<lbrakk>length\\<cdot>\\<bottom> \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>\\<bottom> + n) = TT\n 3. \\<And>n.\n       \\<lbrakk>length\\<cdot>[] \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>[] + n) = TT\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>length\\<cdot>xs \\<noteq> \\<bottom>;\n                    n \\<noteq> \\<bottom>\\<rbrakk>\n                   \\<Longrightarrow> le\\<cdot>n\\<cdot>\n                                     (length\\<cdot>xs + n) =\n                                     TT;\n        length\\<cdot>(a : xs) \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>(a : xs) + n) = TT", "moreover"], ["proof (state)\nthis:\n  le\\<cdot>(n + 1)\\<cdot>(length\\<cdot>xs + (n + 1)) = TT\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            length\\<cdot>a \\<noteq> \\<bottom> \\<longrightarrow>\n            (\\<forall>x.\n                x \\<noteq> \\<bottom> \\<longrightarrow>\n                le\\<cdot>x\\<cdot>(length\\<cdot>a + x) = TT))\n 2. \\<And>n.\n       \\<lbrakk>length\\<cdot>\\<bottom> \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>\\<bottom> + n) = TT\n 3. \\<And>n.\n       \\<lbrakk>length\\<cdot>[] \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>[] + n) = TT\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>length\\<cdot>xs \\<noteq> \\<bottom>;\n                    n \\<noteq> \\<bottom>\\<rbrakk>\n                   \\<Longrightarrow> le\\<cdot>n\\<cdot>\n                                     (length\\<cdot>xs + n) =\n                                     TT;\n        length\\<cdot>(a : xs) \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>(a : xs) + n) = TT", "have \"le\\<cdot>n\\<cdot>(n + 1) = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>n\\<cdot>(n + 1) = TT", "using \\<open>n \\<noteq> \\<bottom>\\<close>"], ["proof (prove)\nusing this:\n  n \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. le\\<cdot>n\\<cdot>(n + 1) = TT", "by (metis le_plus_1 le_refl_Integer)"], ["proof (state)\nthis:\n  le\\<cdot>n\\<cdot>(n + 1) = TT\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            length\\<cdot>a \\<noteq> \\<bottom> \\<longrightarrow>\n            (\\<forall>x.\n                x \\<noteq> \\<bottom> \\<longrightarrow>\n                le\\<cdot>x\\<cdot>(length\\<cdot>a + x) = TT))\n 2. \\<And>n.\n       \\<lbrakk>length\\<cdot>\\<bottom> \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>\\<bottom> + n) = TT\n 3. \\<And>n.\n       \\<lbrakk>length\\<cdot>[] \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>[] + n) = TT\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>length\\<cdot>xs \\<noteq> \\<bottom>;\n                    n \\<noteq> \\<bottom>\\<rbrakk>\n                   \\<Longrightarrow> le\\<cdot>n\\<cdot>\n                                     (length\\<cdot>xs + n) =\n                                     TT;\n        length\\<cdot>(a : xs) \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>(a : xs) + n) = TT", "ultimately"], ["proof (chain)\npicking this:\n  le\\<cdot>(n + 1)\\<cdot>(length\\<cdot>xs + (n + 1)) = TT\n  le\\<cdot>n\\<cdot>(n + 1) = TT", "have \"le\\<cdot>n\\<cdot>(length\\<cdot>xs + (n + 1)) = TT\""], ["proof (prove)\nusing this:\n  le\\<cdot>(n + 1)\\<cdot>(length\\<cdot>xs + (n + 1)) = TT\n  le\\<cdot>n\\<cdot>(n + 1) = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>n\\<cdot>(length\\<cdot>xs + (n + 1)) = TT", "by (blast dest: le_trans)"], ["proof (state)\nthis:\n  le\\<cdot>n\\<cdot>(length\\<cdot>xs + (n + 1)) = TT\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            length\\<cdot>a \\<noteq> \\<bottom> \\<longrightarrow>\n            (\\<forall>x.\n                x \\<noteq> \\<bottom> \\<longrightarrow>\n                le\\<cdot>x\\<cdot>(length\\<cdot>a + x) = TT))\n 2. \\<And>n.\n       \\<lbrakk>length\\<cdot>\\<bottom> \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>\\<bottom> + n) = TT\n 3. \\<And>n.\n       \\<lbrakk>length\\<cdot>[] \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>[] + n) = TT\n 4. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>length\\<cdot>xs \\<noteq> \\<bottom>;\n                    n \\<noteq> \\<bottom>\\<rbrakk>\n                   \\<Longrightarrow> le\\<cdot>n\\<cdot>\n                                     (length\\<cdot>xs + n) =\n                                     TT;\n        length\\<cdot>(a : xs) \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>(a : xs) + n) = TT", "then"], ["proof (chain)\npicking this:\n  le\\<cdot>n\\<cdot>(length\\<cdot>xs + (n + 1)) = TT", "show ?case"], ["proof (prove)\nusing this:\n  le\\<cdot>n\\<cdot>(length\\<cdot>xs + (n + 1)) = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>n\\<cdot>(length\\<cdot>(x : xs) + n) = TT", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  le\\<cdot>n\\<cdot>(length\\<cdot>(x : xs) + n) = TT\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            length\\<cdot>a \\<noteq> \\<bottom> \\<longrightarrow>\n            (\\<forall>x.\n                x \\<noteq> \\<bottom> \\<longrightarrow>\n                le\\<cdot>x\\<cdot>(length\\<cdot>a + x) = TT))\n 2. \\<And>n.\n       \\<lbrakk>length\\<cdot>\\<bottom> \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>\\<bottom> + n) = TT\n 3. \\<And>n.\n       \\<lbrakk>length\\<cdot>[] \\<noteq> \\<bottom>;\n        n \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>n\\<cdot>(length\\<cdot>[] + n) = TT", "qed simp+"], ["", "lemma eq_take_length_isPrefixOf:\n  \"eq\\<cdot>xs\\<cdot>(take\\<cdot>(length\\<cdot>xs)\\<cdot>ys) \\<sqsubseteq> isPrefixOf\\<cdot>xs\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>xs\\<cdot>(take\\<cdot>(length\\<cdot>xs)\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>xs\\<cdot>ys", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               eq\\<cdot>a\\<cdot>\n               (take\\<cdot>(length\\<cdot>a)\\<cdot>x) \\<sqsubseteq>\n               isPrefixOf\\<cdot>a\\<cdot>x)\n 2. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>\n       (take\\<cdot>(length\\<cdot>\\<bottom>)\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>\\<bottom>\\<cdot>ys\n 3. \\<And>ys.\n       eq\\<cdot>[]\\<cdot>\n       (take\\<cdot>(length\\<cdot>[])\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>[]\\<cdot>ys\n 4. \\<And>a xs ys.\n       (\\<And>ys.\n           eq\\<cdot>xs\\<cdot>\n           (take\\<cdot>(length\\<cdot>xs)\\<cdot>ys) \\<sqsubseteq>\n           isPrefixOf\\<cdot>xs\\<cdot>ys) \\<Longrightarrow>\n       eq\\<cdot>(a : xs)\\<cdot>\n       (take\\<cdot>(length\\<cdot>(a : xs))\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>(a : xs)\\<cdot>ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  eq\\<cdot>xs\\<cdot>(take\\<cdot>(length\\<cdot>xs)\\<cdot>?ys) \\<sqsubseteq>\n  isPrefixOf\\<cdot>xs\\<cdot>?ys\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               eq\\<cdot>a\\<cdot>\n               (take\\<cdot>(length\\<cdot>a)\\<cdot>x) \\<sqsubseteq>\n               isPrefixOf\\<cdot>a\\<cdot>x)\n 2. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>\n       (take\\<cdot>(length\\<cdot>\\<bottom>)\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>\\<bottom>\\<cdot>ys\n 3. \\<And>ys.\n       eq\\<cdot>[]\\<cdot>\n       (take\\<cdot>(length\\<cdot>[])\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>[]\\<cdot>ys\n 4. \\<And>a xs ys.\n       (\\<And>ys.\n           eq\\<cdot>xs\\<cdot>\n           (take\\<cdot>(length\\<cdot>xs)\\<cdot>ys) \\<sqsubseteq>\n           isPrefixOf\\<cdot>xs\\<cdot>ys) \\<Longrightarrow>\n       eq\\<cdot>(a : xs)\\<cdot>\n       (take\\<cdot>(length\\<cdot>(a : xs))\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>(a : xs)\\<cdot>ys", "note IH = this"], ["proof (state)\nthis:\n  eq\\<cdot>xs\\<cdot>(take\\<cdot>(length\\<cdot>xs)\\<cdot>?ys) \\<sqsubseteq>\n  isPrefixOf\\<cdot>xs\\<cdot>?ys\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               eq\\<cdot>a\\<cdot>\n               (take\\<cdot>(length\\<cdot>a)\\<cdot>x) \\<sqsubseteq>\n               isPrefixOf\\<cdot>a\\<cdot>x)\n 2. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>\n       (take\\<cdot>(length\\<cdot>\\<bottom>)\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>\\<bottom>\\<cdot>ys\n 3. \\<And>ys.\n       eq\\<cdot>[]\\<cdot>\n       (take\\<cdot>(length\\<cdot>[])\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>[]\\<cdot>ys\n 4. \\<And>a xs ys.\n       (\\<And>ys.\n           eq\\<cdot>xs\\<cdot>\n           (take\\<cdot>(length\\<cdot>xs)\\<cdot>ys) \\<sqsubseteq>\n           isPrefixOf\\<cdot>xs\\<cdot>ys) \\<Longrightarrow>\n       eq\\<cdot>(a : xs)\\<cdot>\n       (take\\<cdot>(length\\<cdot>(a : xs))\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>(a : xs)\\<cdot>ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "proof (cases \"length\\<cdot>xs = \\<bottom>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length\\<cdot>xs = \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n 2. length\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "case True"], ["proof (state)\nthis:\n  length\\<cdot>xs = \\<bottom>\n\ngoal (2 subgoals):\n 1. length\\<cdot>xs = \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n 2. length\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "then"], ["proof (chain)\npicking this:\n  length\\<cdot>xs = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  length\\<cdot>xs = \\<bottom>\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "by simp"], ["proof (state)\nthis:\n  eq\\<cdot>(x : xs)\\<cdot>\n  (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n  isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "case False"], ["proof (state)\nthis:\n  length\\<cdot>xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. length\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "proof (cases ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. ys = \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n 2. ys = [] \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n 3. \\<And>a list.\n       ys = a : list \\<Longrightarrow>\n       eq\\<cdot>(x : xs)\\<cdot>\n       (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "case bottom"], ["proof (state)\nthis:\n  ys = \\<bottom>\n\ngoal (3 subgoals):\n 1. ys = \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n 2. ys = [] \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n 3. \\<And>a list.\n       ys = a : list \\<Longrightarrow>\n       eq\\<cdot>(x : xs)\\<cdot>\n       (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "then"], ["proof (chain)\npicking this:\n  ys = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = \\<bottom>\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "using False"], ["proof (prove)\nusing this:\n  ys = \\<bottom>\n  length\\<cdot>xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "using le_length_plus [of xs 1]"], ["proof (prove)\nusing this:\n  ys = \\<bottom>\n  length\\<cdot>xs \\<noteq> \\<bottom>\n  \\<lbrakk>length\\<cdot>xs \\<noteq> \\<bottom>; 1 \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> le\\<cdot>1\\<cdot>(length\\<cdot>xs + 1) = TT\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "by simp"], ["proof (state)\nthis:\n  eq\\<cdot>(x : xs)\\<cdot>\n  (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n  isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n 2. \\<And>a list.\n       ys = a : list \\<Longrightarrow>\n       eq\\<cdot>(x : xs)\\<cdot>\n       (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n 2. \\<And>a list.\n       ys = a : list \\<Longrightarrow>\n       eq\\<cdot>(x : xs)\\<cdot>\n       (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "case Nil"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n 2. \\<And>a list.\n       ys = a : list \\<Longrightarrow>\n       eq\\<cdot>(x : xs)\\<cdot>\n       (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "then"], ["proof (chain)\npicking this:\n  ys = []", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "using False"], ["proof (prove)\nusing this:\n  ys = []\n  length\\<cdot>xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "by simp"], ["proof (state)\nthis:\n  eq\\<cdot>(x : xs)\\<cdot>\n  (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n  isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a : list \\<Longrightarrow>\n       eq\\<cdot>(x : xs)\\<cdot>\n       (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a : list \\<Longrightarrow>\n       eq\\<cdot>(x : xs)\\<cdot>\n       (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "case (Cons z zs)"], ["proof (state)\nthis:\n  ys = z : zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a : list \\<Longrightarrow>\n       eq\\<cdot>(x : xs)\\<cdot>\n       (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "then"], ["proof (chain)\npicking this:\n  ys = z : zs", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = z : zs\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "using False and IH [of zs]"], ["proof (prove)\nusing this:\n  ys = z : zs\n  length\\<cdot>xs \\<noteq> \\<bottom>\n  eq\\<cdot>xs\\<cdot>(take\\<cdot>(length\\<cdot>xs)\\<cdot>zs) \\<sqsubseteq>\n  isPrefixOf\\<cdot>xs\\<cdot>zs\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(x : xs)\\<cdot>\n    (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n    isPrefixOf\\<cdot>(x : xs)\\<cdot>ys", "by (simp add: take_length_plus_1 monofun_cfun_arg)"], ["proof (state)\nthis:\n  eq\\<cdot>(x : xs)\\<cdot>\n  (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n  isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eq\\<cdot>(x : xs)\\<cdot>\n  (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n  isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eq\\<cdot>(x : xs)\\<cdot>\n  (take\\<cdot>(length\\<cdot>(x : xs))\\<cdot>ys) \\<sqsubseteq>\n  isPrefixOf\\<cdot>(x : xs)\\<cdot>ys\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               eq\\<cdot>a\\<cdot>\n               (take\\<cdot>(length\\<cdot>a)\\<cdot>x) \\<sqsubseteq>\n               isPrefixOf\\<cdot>a\\<cdot>x)\n 2. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>\n       (take\\<cdot>(length\\<cdot>\\<bottom>)\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>\\<bottom>\\<cdot>ys\n 3. \\<And>ys.\n       eq\\<cdot>[]\\<cdot>\n       (take\\<cdot>(length\\<cdot>[])\\<cdot>ys) \\<sqsubseteq>\n       isPrefixOf\\<cdot>[]\\<cdot>ys", "qed simp+"], ["", "end"]]}