{"file_name": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude/examples/Sieve_Primes.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude", "problem_names": ["lemma MkI'_simps [simp]:\n  shows \"MkI' 0 = 0\" and \"MkI' 1 = 1\" and \"MkI' (numeral k) = numeral k\"", "lemma modI_numeral_numeral [simp]:\n  \"mod\\<cdot>(numeral i)\\<cdot>(numeral j) = MkI' (Rings.modulo (numeral i) (numeral j))\"", "lemma \"primes !! 0 = 2\"", "lemma \"primes !! 1 = 3\"", "lemma \"primes !! 2 = 5\"", "lemma \"primes !! 3 = 7\"", "lemma find_next_prime_nat:\n  fixes n :: nat\n  assumes \"prime n\"\n  shows \"\\<exists> n'. n' > n \\<and> prime n' \\<and> (\\<forall>k. n < k \\<longrightarrow> k < n' \\<longrightarrow> \\<not> prime k)\"", "lemma andAlso_Def[simp]: \"((Def x) andalso (Def y)) = Def (x \\<and> y)\"", "lemma prim_bisim_is_bisim: \"list_bisim prim_bisim\"", "lemma sieve_produces_primes:\n  fixes n :: nat\n  assumes \"prime n\"\n  shows \"sieve\\<cdot>(filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d < n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>n..])\n    = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>[MkI\\<cdot>n..]\"", "theorem primes:\n  shows \"primes = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>[MkI\\<cdot>2..]\""], "translations": [["", "lemma MkI'_simps [simp]:\n  shows \"MkI' 0 = 0\" and \"MkI' 1 = 1\" and \"MkI' (numeral k) = numeral k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI' 0 = 0 &&& MkI' 1 = 1 &&& MkI' (numeral k) = numeral k", "unfolding MkI'_def zero_Integer_def one_Integer_def numeral_Integer_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI\\<cdot>0 = MkI\\<cdot>0 &&&\n    MkI\\<cdot>1 = MkI\\<cdot>1 &&&\n    MkI\\<cdot>(numeral k) = MkI\\<cdot>(numeral k)", "by rule+"], ["", "lemma modI_numeral_numeral [simp]:\n  \"mod\\<cdot>(numeral i)\\<cdot>(numeral j) = MkI' (Rings.modulo (numeral i) (numeral j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod\\<cdot>(numeral i)\\<cdot>(numeral j) =\n    MkI' (modulo (numeral i) (numeral j))", "unfolding numeral_Integer_eq mod_Integer_def MkI'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case MkI\\<cdot>(numeral i) of\n     MkI\\<cdot>x \\<Rightarrow>\n       \\<Lambda> (MkI\\<cdot>y). MkI\\<cdot>(modulo x y))\\<cdot>\n    (MkI\\<cdot>(numeral j)) =\n    MkI\\<cdot>(modulo (numeral i) (numeral j))", "by simp"], ["", "text \\<open>Some lemmas demonstrating evaluation of our list:\\<close>"], ["", "lemma \"primes !! 0 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primes !! 0 = 2", "unfolding primes.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>[2..] !! 0 = 2", "apply (simp only: enumFrom_intsFrom_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>(intsFrom\\<cdot>2) !! 0 = 2", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>(seq\\<cdot>2\\<cdot>(2 : intsFrom\\<cdot>(2 + 1))) !! 0 = 2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"primes !! 1 = 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primes !! 1 = 3", "unfolding primes.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>[2..] !! 1 = 3", "apply (simp only: enumFrom_intsFrom_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>(intsFrom\\<cdot>2) !! 1 = 3", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>(seq\\<cdot>2\\<cdot>(2 : intsFrom\\<cdot>(2 + 1))) !! 1 = 3", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (seq\\<cdot>2\\<cdot>\n     (2 :\n      seq\\<cdot>(2 + 1)\\<cdot>((2 + 1) : intsFrom\\<cdot>(2 + 1 + 1)))) !!\n    1 =\n    3", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"primes !! 2 = 5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primes !! 2 = 5", "unfolding primes.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>[2..] !! 2 = 5", "apply (simp only: enumFrom_intsFrom_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>(intsFrom\\<cdot>2) !! 2 = 5", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>(seq\\<cdot>2\\<cdot>(2 : intsFrom\\<cdot>(2 + 1))) !! 2 = 5", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (seq\\<cdot>2\\<cdot>\n     (2 :\n      seq\\<cdot>(2 + 1)\\<cdot>((2 + 1) : intsFrom\\<cdot>(2 + 1 + 1)))) !!\n    2 =\n    5", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (seq\\<cdot>2\\<cdot>\n     (2 :\n      seq\\<cdot>(2 + 1)\\<cdot>\n      ((2 + 1) :\n       seq\\<cdot>(2 + 1 + 1)\\<cdot>\n       ((2 + 1 + 1) : intsFrom\\<cdot>(2 + 1 + 1 + 1))))) !!\n    2 =\n    5", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (seq\\<cdot>2\\<cdot>\n     (2 :\n      seq\\<cdot>(2 + 1)\\<cdot>\n      ((2 + 1) :\n       seq\\<cdot>(2 + 1 + 1)\\<cdot>\n       ((2 + 1 + 1) :\n        seq\\<cdot>(2 + 1 + 1 + 1)\\<cdot>\n        ((2 + 1 + 1 + 1) : intsFrom\\<cdot>(2 + 1 + 1 + 1 + 1)))))) !!\n    2 =\n    5", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"primes !! 3 = 7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primes !! 3 = 7", "unfolding primes.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>[2..] !! 3 = 7", "apply (simp only: enumFrom_intsFrom_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>(intsFrom\\<cdot>2) !! 3 = 7", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>(seq\\<cdot>2\\<cdot>(2 : intsFrom\\<cdot>(2 + 1))) !! 3 = 7", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (seq\\<cdot>2\\<cdot>\n     (2 :\n      seq\\<cdot>(2 + 1)\\<cdot>((2 + 1) : intsFrom\\<cdot>(2 + 1 + 1)))) !!\n    3 =\n    7", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (seq\\<cdot>2\\<cdot>\n     (2 :\n      seq\\<cdot>(2 + 1)\\<cdot>\n      ((2 + 1) :\n       seq\\<cdot>(2 + 1 + 1)\\<cdot>\n       ((2 + 1 + 1) : intsFrom\\<cdot>(2 + 1 + 1 + 1))))) !!\n    3 =\n    7", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (seq\\<cdot>2\\<cdot>\n     (2 :\n      seq\\<cdot>(2 + 1)\\<cdot>\n      ((2 + 1) :\n       seq\\<cdot>(2 + 1 + 1)\\<cdot>\n       ((2 + 1 + 1) :\n        seq\\<cdot>(2 + 1 + 1 + 1)\\<cdot>\n        ((2 + 1 + 1 + 1) : intsFrom\\<cdot>(2 + 1 + 1 + 1 + 1)))))) !!\n    3 =\n    7", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (seq\\<cdot>2\\<cdot>\n     (2 :\n      seq\\<cdot>(2 + 1)\\<cdot>\n      ((2 + 1) :\n       seq\\<cdot>(2 + 1 + 1)\\<cdot>\n       ((2 + 1 + 1) :\n        seq\\<cdot>(2 + 1 + 1 + 1)\\<cdot>\n        ((2 + 1 + 1 + 1) :\n         seq\\<cdot>(2 + 1 + 1 + 1 + 1)\\<cdot>\n         ((2 + 1 + 1 + 1 + 1) :\n          intsFrom\\<cdot>(2 + 1 + 1 + 1 + 1 + 1))))))) !!\n    3 =\n    7", "apply (subst intsFrom.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (seq\\<cdot>2\\<cdot>\n     (2 :\n      seq\\<cdot>(2 + 1)\\<cdot>\n      ((2 + 1) :\n       seq\\<cdot>(2 + 1 + 1)\\<cdot>\n       ((2 + 1 + 1) :\n        seq\\<cdot>(2 + 1 + 1 + 1)\\<cdot>\n        ((2 + 1 + 1 + 1) :\n         seq\\<cdot>(2 + 1 + 1 + 1 + 1)\\<cdot>\n         ((2 + 1 + 1 + 1 + 1) :\n          seq\\<cdot>(2 + 1 + 1 + 1 + 1 + 1)\\<cdot>\n          ((2 + 1 + 1 + 1 + 1 + 1) :\n           intsFrom\\<cdot>(2 + 1 + 1 + 1 + 1 + 1 + 1)))))))) !!\n    3 =\n    7", "apply (simp del: filter_FF filter_TT)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* FIXME: remove these two from the default simpset *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Auxiliary lemmas about prime numbers\\<close>"], ["", "lemma find_next_prime_nat:\n  fixes n :: nat\n  assumes \"prime n\"\n  shows \"\\<exists> n'. n' > n \\<and> prime n' \\<and> (\\<forall>k. n < k \\<longrightarrow> k < n' \\<longrightarrow> \\<not> prime k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n'>n.\n       prime n' \\<and>\n       (\\<forall>k>n. k < n' \\<longrightarrow> \\<not> prime k)", "using ex_least_nat_le[of \"\\<lambda> k . k > n \\<and> prime k\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < ?n \\<and> prime ?n; \\<not> (n < 0 \\<and> prime 0)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<le>?n.\n                       (\\<forall>i<k. \\<not> (n < i \\<and> prime i)) \\<and>\n                       n < k \\<and> prime k\n\ngoal (1 subgoal):\n 1. \\<exists>n'>n.\n       prime n' \\<and>\n       (\\<forall>k>n. k < n' \\<longrightarrow> \\<not> prime k)", "by (metis bigger_prime not_prime_0)"], ["", "text \\<open>Simplification for andalso:\\<close>"], ["", "lemma andAlso_Def[simp]: \"((Def x) andalso (Def y)) = Def (x \\<and> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Def x andalso Def y) = Def (x \\<and> y)", "by (metis Def_bool2 Def_bool4 andalso_thms(1) andalso_thms(2))"], ["", "text \\<open>This defines the bisimulation and proves it to be a list bisimulation.\\<close>"], ["", "definition prim_bisim:\n  \"prim_bisim x1 x2 = (\\<exists> n . prime n  \\<and>\n    x1 = sieve\\<cdot>(filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d. d > 1 \\<longrightarrow> d < n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>n..]) \\<and>\n    x2 = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>[MkI\\<cdot>n..])\""], ["", "lemma prim_bisim_is_bisim: \"list_bisim prim_bisim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "assume \"prim_bisim xs ys\""], ["proof (state)\nthis:\n  prim_bisim xs ys\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "then"], ["proof (chain)\npicking this:\n  prim_bisim xs ys", "obtain n :: nat where\n      \"prime n\" and\n      \"n > 1\" and\n      \"xs = sieve\\<cdot>(filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d < n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>n..])\" (is \"_ = sieve\\<cdot>?xs\") and\n      \"ys = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>[MkI\\<cdot>n..]\""], ["proof (prove)\nusing this:\n  prim_bisim xs ys\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>prime n; 1 < n;\n         xs =\n         sieve\\<cdot>\n         (Data_List.filter\\<cdot>\n          (\\<Lambda> (MkI\\<cdot>i).\n              Def (\\<forall>d>1.\n                      d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n          [MkI\\<cdot>(int n)..]);\n         ys =\n         Data_List.filter\\<cdot>\n         (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n         [MkI\\<cdot>(int n)..]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "(* sledgehammer *)"], ["proof (prove)\nusing this:\n  prim_bisim xs ys\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>prime n; 1 < n;\n         xs =\n         sieve\\<cdot>\n         (Data_List.filter\\<cdot>\n          (\\<Lambda> (MkI\\<cdot>i).\n              Def (\\<forall>d>1.\n                      d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n          [MkI\\<cdot>(int n)..]);\n         ys =\n         Data_List.filter\\<cdot>\n         (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n         [MkI\\<cdot>(int n)..]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>prime n; 1 < n;\n                 xs =\n                 sieve\\<cdot>\n                 (Data_List.filter\\<cdot>\n                  (\\<Lambda> (MkI\\<cdot>i).\n                      Def (\\<forall>d>1.\n                              d < int n \\<longrightarrow>\n                              \\<not> d dvd i))\\<cdot>\n                  [MkI\\<cdot>(int n)..]);\n                 ys =\n                 Data_List.filter\\<cdot>\n                 (\\<Lambda> (MkI\\<cdot>i).\n                     Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n                 [MkI\\<cdot>(int n)..]\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prim_bisim xs ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume a1: \"\\<And>n. \\<lbrakk>prime n; 1 < n; xs = sieve\\<cdot> (Data_List.filter\\<cdot> (\\<Lambda> (MkI\\<cdot>i). Def (\\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot> [MkI\\<cdot>(int n)..]); ys = Data_List.filter\\<cdot> (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot> [MkI\\<cdot>(int n)..]\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>prime ?n; 1 < ?n;\n   xs =\n   sieve\\<cdot>\n   (Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i).\n        Def (\\<forall>d>1.\n                d < int ?n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n    [MkI\\<cdot>(int ?n)..]);\n   ys =\n   Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n   [MkI\\<cdot>(int ?n)..]\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>prime n; 1 < n;\n                 xs =\n                 sieve\\<cdot>\n                 (Data_List.filter\\<cdot>\n                  (\\<Lambda> (MkI\\<cdot>i).\n                      Def (\\<forall>d>1.\n                              d < int n \\<longrightarrow>\n                              \\<not> d dvd i))\\<cdot>\n                  [MkI\\<cdot>(int n)..]);\n                 ys =\n                 Data_List.filter\\<cdot>\n                 (\\<Lambda> (MkI\\<cdot>i).\n                     Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n                 [MkI\\<cdot>(int n)..]\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prim_bisim xs ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain ii  where\n        f2: \"\\<forall>is isa. (\\<not> prim_bisim is isa \\<or> prime (ii is isa) \\<and> is = sieve\\<cdot> (Data_List.filter\\<cdot> (\\<Lambda> (MkI\\<cdot>i). Def (\\<forall>ia>1. ia < ii is isa \\<longrightarrow> \\<not> ia dvd i))\\<cdot> [MkI\\<cdot>(ii is isa)..]) \\<and> isa = Data_List.filter\\<cdot> (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot> [MkI\\<cdot>(ii is isa)..]) \\<and> ((\\<forall>i. \\<not> prime i \\<or> is \\<noteq> sieve\\<cdot> (Data_List.filter\\<cdot> (\\<Lambda> (MkI\\<cdot>ia). Def (\\<forall>ib>1. ib < i \\<longrightarrow> \\<not> ib dvd ia))\\<cdot> [MkI\\<cdot>i..]) \\<or> isa \\<noteq> Data_List.filter\\<cdot> (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot> [MkI\\<cdot>i..]) \\<or> prim_bisim is isa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ii.\n        \\<forall>is isa.\n           (\\<not> prim_bisim is isa \\<or>\n            prime (ii is isa) \\<and>\n            is =\n            sieve\\<cdot>\n            (Data_List.filter\\<cdot>\n             (\\<Lambda> (MkI\\<cdot>i).\n                 Def (\\<forall>ia>1.\n                         ia < ii is isa \\<longrightarrow>\n                         \\<not> ia dvd i))\\<cdot>\n             [MkI\\<cdot>(ii is isa)..]) \\<and>\n            isa =\n            Data_List.filter\\<cdot>\n            (\\<Lambda> (MkI\\<cdot>i).\n                Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n            [MkI\\<cdot>(ii is isa)..]) \\<and>\n           ((\\<forall>i.\n                \\<not> prime i \\<or>\n                is \\<noteq>\n                sieve\\<cdot>\n                (Data_List.filter\\<cdot>\n                 (\\<Lambda> (MkI\\<cdot>ia).\n                     Def (\\<forall>ib>1.\n                             ib < i \\<longrightarrow>\n                             \\<not> ib dvd ia))\\<cdot>\n                 [MkI\\<cdot>i..]) \\<or>\n                isa \\<noteq>\n                Data_List.filter\\<cdot>\n                (\\<Lambda> (MkI\\<cdot>i).\n                    Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n                [MkI\\<cdot>i..]) \\<or>\n            prim_bisim is isa) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prim_bisim"], ["proof (prove)\nusing this:\n  prim_bisim ?x1.0 ?x2.0 =\n  (\\<exists>n.\n      prime n \\<and>\n      ?x1.0 =\n      sieve\\<cdot>\n      (Data_List.filter\\<cdot>\n       (\\<Lambda> (MkI\\<cdot>i).\n           Def (\\<forall>d>1.\n                   d < n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n       [MkI\\<cdot>n..]) \\<and>\n      ?x2.0 =\n      Data_List.filter\\<cdot>\n      (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n      [MkI\\<cdot>n..])\n\ngoal (1 subgoal):\n 1. (\\<And>ii.\n        \\<forall>is isa.\n           (\\<not> prim_bisim is isa \\<or>\n            prime (ii is isa) \\<and>\n            is =\n            sieve\\<cdot>\n            (Data_List.filter\\<cdot>\n             (\\<Lambda> (MkI\\<cdot>i).\n                 Def (\\<forall>ia>1.\n                         ia < ii is isa \\<longrightarrow>\n                         \\<not> ia dvd i))\\<cdot>\n             [MkI\\<cdot>(ii is isa)..]) \\<and>\n            isa =\n            Data_List.filter\\<cdot>\n            (\\<Lambda> (MkI\\<cdot>i).\n                Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n            [MkI\\<cdot>(ii is isa)..]) \\<and>\n           ((\\<forall>i.\n                \\<not> prime i \\<or>\n                is \\<noteq>\n                sieve\\<cdot>\n                (Data_List.filter\\<cdot>\n                 (\\<Lambda> (MkI\\<cdot>ia).\n                     Def (\\<forall>ib>1.\n                             ib < i \\<longrightarrow>\n                             \\<not> ib dvd ia))\\<cdot>\n                 [MkI\\<cdot>i..]) \\<or>\n                isa \\<noteq>\n                Data_List.filter\\<cdot>\n                (\\<Lambda> (MkI\\<cdot>i).\n                    Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n                [MkI\\<cdot>i..]) \\<or>\n            prim_bisim is isa) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>is isa.\n     (\\<not> prim_bisim is isa \\<or>\n      prime (ii is isa) \\<and>\n      is =\n      sieve\\<cdot>\n      (Data_List.filter\\<cdot>\n       (\\<Lambda> (MkI\\<cdot>i).\n           Def (\\<forall>ia>1.\n                   ia < ii is isa \\<longrightarrow> \\<not> ia dvd i))\\<cdot>\n       [MkI\\<cdot>(ii is isa)..]) \\<and>\n      isa =\n      Data_List.filter\\<cdot>\n      (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n      [MkI\\<cdot>(ii is isa)..]) \\<and>\n     ((\\<forall>i.\n          \\<not> prime i \\<or>\n          is \\<noteq>\n          sieve\\<cdot>\n          (Data_List.filter\\<cdot>\n           (\\<Lambda> (MkI\\<cdot>ia).\n               Def (\\<forall>ib>1.\n                       ib < i \\<longrightarrow> \\<not> ib dvd ia))\\<cdot>\n           [MkI\\<cdot>i..]) \\<or>\n          isa \\<noteq>\n          Data_List.filter\\<cdot>\n          (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n          [MkI\\<cdot>i..]) \\<or>\n      prim_bisim is isa)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>prime n; 1 < n;\n                 xs =\n                 sieve\\<cdot>\n                 (Data_List.filter\\<cdot>\n                  (\\<Lambda> (MkI\\<cdot>i).\n                      Def (\\<forall>d>1.\n                              d < int n \\<longrightarrow>\n                              \\<not> d dvd i))\\<cdot>\n                  [MkI\\<cdot>(int n)..]);\n                 ys =\n                 Data_List.filter\\<cdot>\n                 (\\<Lambda> (MkI\\<cdot>i).\n                     Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n                 [MkI\\<cdot>(int n)..]\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prim_bisim xs ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>is isa.\n     (\\<not> prim_bisim is isa \\<or>\n      prime (ii is isa) \\<and>\n      is =\n      sieve\\<cdot>\n      (Data_List.filter\\<cdot>\n       (\\<Lambda> (MkI\\<cdot>i).\n           Def (\\<forall>ia>1.\n                   ia < ii is isa \\<longrightarrow> \\<not> ia dvd i))\\<cdot>\n       [MkI\\<cdot>(ii is isa)..]) \\<and>\n      isa =\n      Data_List.filter\\<cdot>\n      (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n      [MkI\\<cdot>(ii is isa)..]) \\<and>\n     ((\\<forall>i.\n          \\<not> prime i \\<or>\n          is \\<noteq>\n          sieve\\<cdot>\n          (Data_List.filter\\<cdot>\n           (\\<Lambda> (MkI\\<cdot>ia).\n               Def (\\<forall>ib>1.\n                       ib < i \\<longrightarrow> \\<not> ib dvd ia))\\<cdot>\n           [MkI\\<cdot>i..]) \\<or>\n          isa \\<noteq>\n          Data_List.filter\\<cdot>\n          (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n          [MkI\\<cdot>i..]) \\<or>\n      prim_bisim is isa)", "have f3: \"prime (ii xs ys)\""], ["proof (prove)\nusing this:\n  \\<forall>is isa.\n     (\\<not> prim_bisim is isa \\<or>\n      prime (ii is isa) \\<and>\n      is =\n      sieve\\<cdot>\n      (Data_List.filter\\<cdot>\n       (\\<Lambda> (MkI\\<cdot>i).\n           Def (\\<forall>ia>1.\n                   ia < ii is isa \\<longrightarrow> \\<not> ia dvd i))\\<cdot>\n       [MkI\\<cdot>(ii is isa)..]) \\<and>\n      isa =\n      Data_List.filter\\<cdot>\n      (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n      [MkI\\<cdot>(ii is isa)..]) \\<and>\n     ((\\<forall>i.\n          \\<not> prime i \\<or>\n          is \\<noteq>\n          sieve\\<cdot>\n          (Data_List.filter\\<cdot>\n           (\\<Lambda> (MkI\\<cdot>ia).\n               Def (\\<forall>ib>1.\n                       ib < i \\<longrightarrow> \\<not> ib dvd ia))\\<cdot>\n           [MkI\\<cdot>i..]) \\<or>\n          isa \\<noteq>\n          Data_List.filter\\<cdot>\n          (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n          [MkI\\<cdot>i..]) \\<or>\n      prim_bisim is isa)\n\ngoal (1 subgoal):\n 1. prime (ii xs ys)", "using \\<open>prim_bisim xs ys\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>is isa.\n     (\\<not> prim_bisim is isa \\<or>\n      prime (ii is isa) \\<and>\n      is =\n      sieve\\<cdot>\n      (Data_List.filter\\<cdot>\n       (\\<Lambda> (MkI\\<cdot>i).\n           Def (\\<forall>ia>1.\n                   ia < ii is isa \\<longrightarrow> \\<not> ia dvd i))\\<cdot>\n       [MkI\\<cdot>(ii is isa)..]) \\<and>\n      isa =\n      Data_List.filter\\<cdot>\n      (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n      [MkI\\<cdot>(ii is isa)..]) \\<and>\n     ((\\<forall>i.\n          \\<not> prime i \\<or>\n          is \\<noteq>\n          sieve\\<cdot>\n          (Data_List.filter\\<cdot>\n           (\\<Lambda> (MkI\\<cdot>ia).\n               Def (\\<forall>ib>1.\n                       ib < i \\<longrightarrow> \\<not> ib dvd ia))\\<cdot>\n           [MkI\\<cdot>i..]) \\<or>\n          isa \\<noteq>\n          Data_List.filter\\<cdot>\n          (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n          [MkI\\<cdot>i..]) \\<or>\n      prim_bisim is isa)\n  prim_bisim xs ys\n\ngoal (1 subgoal):\n 1. prime (ii xs ys)", "by blast"], ["proof (state)\nthis:\n  prime (ii xs ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>prime n; 1 < n;\n                 xs =\n                 sieve\\<cdot>\n                 (Data_List.filter\\<cdot>\n                  (\\<Lambda> (MkI\\<cdot>i).\n                      Def (\\<forall>d>1.\n                              d < int n \\<longrightarrow>\n                              \\<not> d dvd i))\\<cdot>\n                  [MkI\\<cdot>(int n)..]);\n                 ys =\n                 Data_List.filter\\<cdot>\n                 (\\<Lambda> (MkI\\<cdot>i).\n                     Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n                 [MkI\\<cdot>(int n)..]\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prim_bisim xs ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  prime (ii xs ys)", "obtain nn :: \"int \\<Rightarrow> nat\" where\n        f4: \"int (nn (ii xs ys)) = ii xs ys\""], ["proof (prove)\nusing this:\n  prime (ii xs ys)\n\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        int (nn (ii xs ys)) = ii xs ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types) prime_gt_0_int zero_less_imp_eq_int)"], ["proof (state)\nthis:\n  int (nn (ii xs ys)) = ii xs ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>prime n; 1 < n;\n                 xs =\n                 sieve\\<cdot>\n                 (Data_List.filter\\<cdot>\n                  (\\<Lambda> (MkI\\<cdot>i).\n                      Def (\\<forall>d>1.\n                              d < int n \\<longrightarrow>\n                              \\<not> d dvd i))\\<cdot>\n                  [MkI\\<cdot>(int n)..]);\n                 ys =\n                 Data_List.filter\\<cdot>\n                 (\\<Lambda> (MkI\\<cdot>i).\n                     Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n                 [MkI\\<cdot>(int n)..]\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prim_bisim xs ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  int (nn (ii xs ys)) = ii xs ys", "have \"prime (nn (ii xs ys))\""], ["proof (prove)\nusing this:\n  int (nn (ii xs ys)) = ii xs ys\n\ngoal (1 subgoal):\n 1. prime (nn (ii xs ys))", "using f3"], ["proof (prove)\nusing this:\n  int (nn (ii xs ys)) = ii xs ys\n  prime (ii xs ys)\n\ngoal (1 subgoal):\n 1. prime (nn (ii xs ys))", "by (metis (no_types) prime_nat_int_transfer)"], ["proof (state)\nthis:\n  prime (nn (ii xs ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>prime n; 1 < n;\n                 xs =\n                 sieve\\<cdot>\n                 (Data_List.filter\\<cdot>\n                  (\\<Lambda> (MkI\\<cdot>i).\n                      Def (\\<forall>d>1.\n                              d < int n \\<longrightarrow>\n                              \\<not> d dvd i))\\<cdot>\n                  [MkI\\<cdot>(int n)..]);\n                 ys =\n                 Data_List.filter\\<cdot>\n                 (\\<Lambda> (MkI\\<cdot>i).\n                     Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n                 [MkI\\<cdot>(int n)..]\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prim_bisim xs ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  prime (nn (ii xs ys))", "show ?thesis"], ["proof (prove)\nusing this:\n  prime (nn (ii xs ys))\n\ngoal (1 subgoal):\n 1. thesis", "using f4 f2 a1 \\<open>prim_bisim xs ys\\<close> prime_gt_1_nat"], ["proof (prove)\nusing this:\n  prime (nn (ii xs ys))\n  int (nn (ii xs ys)) = ii xs ys\n  \\<forall>is isa.\n     (\\<not> prim_bisim is isa \\<or>\n      prime (ii is isa) \\<and>\n      is =\n      sieve\\<cdot>\n      (Data_List.filter\\<cdot>\n       (\\<Lambda> (MkI\\<cdot>i).\n           Def (\\<forall>ia>1.\n                   ia < ii is isa \\<longrightarrow> \\<not> ia dvd i))\\<cdot>\n       [MkI\\<cdot>(ii is isa)..]) \\<and>\n      isa =\n      Data_List.filter\\<cdot>\n      (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n      [MkI\\<cdot>(ii is isa)..]) \\<and>\n     ((\\<forall>i.\n          \\<not> prime i \\<or>\n          is \\<noteq>\n          sieve\\<cdot>\n          (Data_List.filter\\<cdot>\n           (\\<Lambda> (MkI\\<cdot>ia).\n               Def (\\<forall>ib>1.\n                       ib < i \\<longrightarrow> \\<not> ib dvd ia))\\<cdot>\n           [MkI\\<cdot>i..]) \\<or>\n          isa \\<noteq>\n          Data_List.filter\\<cdot>\n          (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n          [MkI\\<cdot>i..]) \\<or>\n      prim_bisim is isa)\n  \\<lbrakk>prime ?n; 1 < ?n;\n   xs =\n   sieve\\<cdot>\n   (Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i).\n        Def (\\<forall>d>1.\n                d < int ?n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n    [MkI\\<cdot>(int ?n)..]);\n   ys =\n   Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n   [MkI\\<cdot>(int ?n)..]\\<rbrakk>\n  \\<Longrightarrow> thesis\n  prim_bisim xs ys\n  prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. thesis", "by presburger"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime n\n  1 < n\n  xs =\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n)..])\n  ys =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n)..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "obtain n' where \"n' > n\" and \"prime n'\" and not_prime: \"\\<forall>k. n < k \\<longrightarrow> k < n' \\<longrightarrow> \\<not> prime k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>n < n'; prime n';\n         \\<forall>k>n. k < n' \\<longrightarrow> \\<not> prime k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using find_next_prime_nat[OF \\<open>prime n\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>n'>n.\n     prime n' \\<and> (\\<forall>k>n. k < n' \\<longrightarrow> \\<not> prime k)\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>n < n'; prime n';\n         \\<forall>k>n. k < n' \\<longrightarrow> \\<not> prime k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n < n'\n  prime n'\n  \\<forall>k>n. k < n' \\<longrightarrow> \\<not> prime k\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "{"], ["proof (state)\nthis:\n  n < n'\n  prime n'\n  \\<forall>k>n. k < n' \\<longrightarrow> \\<not> prime k\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "fix k :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "assume \"n < k\" and \"k < n'\""], ["proof (state)\nthis:\n  int n < k\n  k < int n'\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have  \"k > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < k", "using \\<open>n < k\\<close> \\<open>n > 1\\<close>"], ["proof (prove)\nusing this:\n  int n < k\n  1 < n\n\ngoal (1 subgoal):\n 1. 1 < k", "by auto"], ["proof (state)\nthis:\n  1 < k\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "then"], ["proof (chain)\npicking this:\n  1 < k", "obtain k' :: nat where \"k = int k'\""], ["proof (prove)\nusing this:\n  1 < k\n\ngoal (1 subgoal):\n 1. (\\<And>k'. k = int k' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases k) auto"], ["proof (state)\nthis:\n  k = int k'\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "then"], ["proof (chain)\npicking this:\n  k = int k'", "obtain p where \"prime p\" and \"p dvd k\""], ["proof (prove)\nusing this:\n  k = int k'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>k > 1\\<close> \\<open>k = int k'\\<close>"], ["proof (prove)\nusing this:\n  k = int k'\n  1 < k\n  k = int k'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) less_numeral_extra(4) of_nat_1 of_nat_dvd_iff prime_factor_nat prime_nat_int_transfer)"], ["proof (state)\nthis:\n  prime p\n  p dvd k\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "then"], ["proof (chain)\npicking this:\n  prime p\n  p dvd k", "have \"p < n'\""], ["proof (prove)\nusing this:\n  prime p\n  p dvd k\n\ngoal (1 subgoal):\n 1. p < int n'", "using \\<open>k < n'\\<close>  \\<open>k > 1\\<close>"], ["proof (prove)\nusing this:\n  prime p\n  p dvd k\n  k < int n'\n  1 < k\n\ngoal (1 subgoal):\n 1. p < int n'", "using zdvd_imp_le [of p k]"], ["proof (prove)\nusing this:\n  prime p\n  p dvd k\n  k < int n'\n  1 < k\n  \\<lbrakk>p dvd k; 0 < k\\<rbrakk> \\<Longrightarrow> p \\<le> k\n\ngoal (1 subgoal):\n 1. p < int n'", "by simp"], ["proof (state)\nthis:\n  p < int n'\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "then"], ["proof (chain)\npicking this:\n  p < int n'", "have \"p \\<le> n\""], ["proof (prove)\nusing this:\n  p < int n'\n\ngoal (1 subgoal):\n 1. p \\<le> int n", "using \\<open>prime p\\<close> not_prime"], ["proof (prove)\nusing this:\n  p < int n'\n  prime p\n  \\<forall>k>n. k < n' \\<longrightarrow> \\<not> prime k\n\ngoal (1 subgoal):\n 1. p \\<le> int n", "using not_le prime_gt_0_int zero_less_imp_eq_int"], ["proof (prove)\nusing this:\n  p < int n'\n  prime p\n  \\<forall>k>n. k < n' \\<longrightarrow> \\<not> prime k\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n  prime ?p \\<Longrightarrow> 0 < ?p\n  0 < ?k \\<Longrightarrow> \\<exists>n>0. ?k = int n\n\ngoal (1 subgoal):\n 1. p \\<le> int n", "by (metis of_nat_less_iff prime_nat_int_transfer)"], ["proof (state)\nthis:\n  p \\<le> int n\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "then"], ["proof (chain)\npicking this:\n  p \\<le> int n", "have \"\\<exists>d::int>1. d \\<le> n \\<and> d dvd k\""], ["proof (prove)\nusing this:\n  p \\<le> int n\n\ngoal (1 subgoal):\n 1. \\<exists>d>1. d \\<le> int n \\<and> d dvd k", "using \\<open>p dvd k\\<close> \\<open>prime p\\<close> of_nat_le_iff prime_gt_1_nat\n          prime_gt_1_int"], ["proof (prove)\nusing this:\n  p \\<le> int n\n  p dvd k\n  prime p\n  (of_nat ?m \\<le> of_nat ?n) = (?m \\<le> ?n)\n  prime ?p \\<Longrightarrow> 1 < ?p\n  prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. \\<exists>d>1. d \\<le> int n \\<and> d dvd k", "by auto"], ["proof (state)\nthis:\n  \\<exists>d>1. d \\<le> int n \\<and> d dvd k\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "}"], ["proof (state)\nthis:\n  \\<lbrakk>int n < ?k2; ?k2 < int n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d>1. d \\<le> int n \\<and> d dvd ?k2\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>int n < ?k2; ?k2 < int n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d>1. d \\<le> int n \\<and> d dvd ?k2", "have between_have_divisors: \"\\<And>k::int. n < k \\<Longrightarrow> k < n' \\<Longrightarrow> \\<exists>d::int>1. d \\<le> n \\<and> d dvd k\""], ["proof (prove)\nusing this:\n  \\<lbrakk>int n < ?k2; ?k2 < int n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d>1. d \\<le> int n \\<and> d dvd ?k2\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>int n < k; k < int n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d>1. d \\<le> int n \\<and> d dvd k", "."], ["proof (state)\nthis:\n  \\<lbrakk>int n < ?k; ?k < int n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d>1. d \\<le> int n \\<and> d dvd ?k\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "{"], ["proof (state)\nthis:\n  \\<lbrakk>int n < ?k; ?k < int n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d>1. d \\<le> int n \\<and> d dvd ?k\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "assume small: \"\\<forall>d::int>1. d \\<le> n \\<longrightarrow> \\<not> d dvd i\""], ["proof (state)\nthis:\n  \\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "assume \"1 < d\" and \"d dvd i\" and \"d < n'\""], ["proof (state)\nthis:\n  1 < d\n  d dvd i\n  d < int n'\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "with small"], ["proof (chain)\npicking this:\n  \\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i\n  1 < d\n  d dvd i\n  d < int n'", "have \"d > n\""], ["proof (prove)\nusing this:\n  \\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i\n  1 < d\n  d dvd i\n  d < int n'\n\ngoal (1 subgoal):\n 1. int n < d", "by auto"], ["proof (state)\nthis:\n  int n < d\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "obtain d'::int where \"d' > 1\" and \"d' \\<le> n\" and \"d' dvd d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>1 < d'; d' \\<le> int n; d' dvd d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using between_have_divisors[OF \\<open>n < d\\<close> \\<open>d < n'\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>da>1. da \\<le> int n \\<and> da dvd d\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>1 < d'; d' \\<le> int n; d' dvd d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  1 < d'\n  d' \\<le> int n\n  d' dvd d\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "with \\<open>d dvd i\\<close> small"], ["proof (chain)\npicking this:\n  d dvd i\n  \\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i\n  1 < d'\n  d' \\<le> int n\n  d' dvd d", "have False"], ["proof (prove)\nusing this:\n  d dvd i\n  \\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i\n  1 < d'\n  d' \\<le> int n\n  d' dvd d\n\ngoal (1 subgoal):\n 1. False", "by (metis (full_types) dvd_trans)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i;\n   1 < ?d2; ?d2 dvd i; ?d2 < int n'\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i;\n   1 < ?d2; ?d2 dvd i; ?d2 < int n'\\<rbrakk>\n  \\<Longrightarrow> False", "have \"(\\<forall>d::int. d > 1 \\<longrightarrow> d \\<le> n \\<longrightarrow> \\<not> (d dvd i)) = (\\<forall>d::int. d > 1 \\<longrightarrow> d < n' \\<longrightarrow> \\<not> (d dvd i))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i;\n   1 < ?d2; ?d2 dvd i; ?d2 < int n'\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i) =\n    (\\<forall>d>1. d < int n' \\<longrightarrow> \\<not> d dvd i)", "using \\<open>n' > n\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i;\n   1 < ?d2; ?d2 dvd i; ?d2 < int n'\\<rbrakk>\n  \\<Longrightarrow> False\n  n < n'\n\ngoal (1 subgoal):\n 1. (\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i) =\n    (\\<forall>d>1. d < int n' \\<longrightarrow> \\<not> d dvd i)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i) =\n  (\\<forall>d>1. d < int n' \\<longrightarrow> \\<not> d dvd i)\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "}"], ["proof (state)\nthis:\n  (\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd ?i2) =\n  (\\<forall>d>1. d < int n' \\<longrightarrow> \\<not> d dvd ?i2)\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "then"], ["proof (chain)\npicking this:\n  (\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd ?i2) =\n  (\\<forall>d>1. d < int n' \\<longrightarrow> \\<not> d dvd ?i2)", "have between_not_relvant:  \"\\<And> i. (\\<forall>d::int. d > 1 \\<longrightarrow> d \\<le> n \\<longrightarrow> \\<not> (d dvd i)) = (\\<forall>d::int. d > 1 \\<longrightarrow> d < n' \\<longrightarrow> \\<not> (d dvd i))\""], ["proof (prove)\nusing this:\n  (\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd ?i2) =\n  (\\<forall>d>1. d < int n' \\<longrightarrow> \\<not> d dvd ?i2)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd i) =\n       (\\<forall>d>1. d < int n' \\<longrightarrow> \\<not> d dvd i)", "."], ["proof (state)\nthis:\n  (\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd ?i) =\n  (\\<forall>d>1. d < int n' \\<longrightarrow> \\<not> d dvd ?i)\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "from \\<open>prime n\\<close>"], ["proof (chain)\npicking this:\n  prime n", "have \"\\<forall>d::int >1. d < n \\<longrightarrow> \\<not> d dvd n\""], ["proof (prove)\nusing this:\n  prime n\n\ngoal (1 subgoal):\n 1. \\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd int n", "unfolding prime_int_altdef"], ["proof (prove)\nusing this:\n  prime n\n\ngoal (1 subgoal):\n 1. \\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd int n", "using int_one_le_iff_zero_less le_less"], ["proof (prove)\nusing this:\n  prime n\n  (1 \\<le> ?z) = (0 < ?z)\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd int n", "by (simp add: prime_int_not_dvd)"], ["proof (state)\nthis:\n  \\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd int n\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "then"], ["proof (chain)\npicking this:\n  \\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd int n", "obtain xs' where \"?xs = (MkI\\<cdot>n) : xs'\" and \"xs' = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d < n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>(n+1)..]\""], ["proof (prove)\nusing this:\n  \\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd int n\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        \\<lbrakk>Data_List.filter\\<cdot>\n                 (\\<Lambda> (MkI\\<cdot>i).\n                     Def (\\<forall>d>1.\n                             d < int n \\<longrightarrow>\n                             \\<not> d dvd i))\\<cdot>\n                 [MkI\\<cdot>(int n)..] =\n                 MkI\\<cdot>(int n) : xs';\n         xs' =\n         Data_List.filter\\<cdot>\n         (\\<Lambda> (MkI\\<cdot>i).\n             Def (\\<forall>d>1.\n                     d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n         [MkI\\<cdot>(int (n + 1))..]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) intsFrom.simps[unfolded enumFrom_intsFrom_conv[symmetric]], simp add: one_Integer_def TT_def[symmetric] add.commute)"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n)..] =\n  MkI\\<cdot>(int n) : xs'\n  xs' =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int (n + 1))..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "{"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n)..] =\n  MkI\\<cdot>(int n) : xs'\n  xs' =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int (n + 1))..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"filter\\<cdot>(\\<Lambda> x. neg\\<cdot>(eq\\<cdot>(mod\\<cdot>x\\<cdot>(MkI\\<cdot>n))\\<cdot>0))\\<cdot>(filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d < n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>(n+1)..])\n            = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>x). Def (\\<not> n dvd x))\\<cdot>(filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d < n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>(n+1)..])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.filter\\<cdot>\n    (\\<Lambda> x.\n        neg\\<cdot>\n        (eq\\<cdot>(mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>0))\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int (n + 1))..]) =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>x). Def (\\<not> int n dvd x))\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int (n + 1))..])", "apply (rule filter_cong[rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Data_List.set\n                (Data_List.filter\\<cdot>\n                 (\\<Lambda> (MkI\\<cdot>i).\n                     Def (\\<forall>d>1.\n                             d < int n \\<longrightarrow>\n                             \\<not> d dvd i))\\<cdot>\n                 [MkI\\<cdot>(int (n + 1))..]) \\<Longrightarrow>\n       (\\<Lambda> x.\n           neg\\<cdot>\n           (eq\\<cdot>(mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>\n            0))\\<cdot>\n       x =\n       (case x of MkI\\<cdot>x \\<Rightarrow> Def (\\<not> int n dvd x))", "apply (rename_tac x, case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> Data_List.set\n                         (Data_List.filter\\<cdot>\n                          (\\<Lambda> (MkI\\<cdot>i).\n                              Def (\\<forall>d>1.\nd < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n                          [MkI\\<cdot>(int (n + 1))..]);\n        x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             neg\\<cdot>\n                             (eq\\<cdot>\n                              (mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>\n                              0))\\<cdot>\n                         x =\n                         (case x of\n                          MkI\\<cdot>x \\<Rightarrow>\n                            Def (\\<not> int n dvd x))\n 2. \\<And>x inta.\n       \\<lbrakk>x \\<in> Data_List.set\n                         (Data_List.filter\\<cdot>\n                          (\\<Lambda> (MkI\\<cdot>i).\n                              Def (\\<forall>d>1.\nd < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n                          [MkI\\<cdot>(int (n + 1))..]);\n        x = MkI\\<cdot>inta\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             neg\\<cdot>\n                             (eq\\<cdot>\n                              (mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>\n                              0))\\<cdot>\n                         x =\n                         (case x of\n                          MkI\\<cdot>x \\<Rightarrow>\n                            Def (\\<not> int n dvd x))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x inta.\n       \\<lbrakk>x \\<in> Data_List.set\n                         (Data_List.filter\\<cdot>\n                          (\\<Lambda> (MkI\\<cdot>i).\n                              Def (\\<forall>d>1.\nd < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n                          [MkI\\<cdot>(int (n + 1))..]);\n        x = MkI\\<cdot>inta\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             neg\\<cdot>\n                             (eq\\<cdot>\n                              (mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>\n                              0))\\<cdot>\n                         x =\n                         (case x of\n                          MkI\\<cdot>x \\<Rightarrow>\n                            Def (\\<not> int n dvd x))", "apply (auto simp add: zero_Integer_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       MkI\\<cdot>(int n * q)\n       \\<in> Data_List.set\n              (Data_List.filter\\<cdot>\n               (\\<Lambda> (MkI\\<cdot>i).\n                   Def (\\<forall>d>1.\n                           d < int n \\<longrightarrow>\n                           \\<not> d dvd i))\\<cdot>\n               (intsFrom\\<cdot>(MkI\\<cdot>(1 + int n)))) \\<Longrightarrow>\n       FF = Def False\n 2. \\<And>inta.\n       \\<lbrakk>MkI\\<cdot>inta\n                \\<in> Data_List.set\n                       (Data_List.filter\\<cdot>\n                        (\\<Lambda> (MkI\\<cdot>i).\n                            Def (\\<forall>d>1.\n                                    d < int n \\<longrightarrow>\n                                    \\<not> d dvd i))\\<cdot>\n                        (intsFrom\\<cdot>(MkI\\<cdot>(1 + int n))));\n        modulo inta (int n) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> TT = Def (\\<not> int n dvd inta)", "apply (rule FF_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>inta.\n       \\<lbrakk>MkI\\<cdot>inta\n                \\<in> Data_List.set\n                       (Data_List.filter\\<cdot>\n                        (\\<Lambda> (MkI\\<cdot>i).\n                            Def (\\<forall>d>1.\n                                    d < int n \\<longrightarrow>\n                                    \\<not> d dvd i))\\<cdot>\n                        (intsFrom\\<cdot>(MkI\\<cdot>(1 + int n))));\n        modulo inta (int n) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> TT = Def (\\<not> int n dvd inta)", "apply (simp add: TT_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>inta.\n       \\<lbrakk>MkI\\<cdot>inta\n                \\<in> Data_List.set\n                       (Data_List.filter\\<cdot>\n                        (\\<Lambda> (MkI\\<cdot>i).\n                            Def (\\<forall>d>1.\n                                    d < int n \\<longrightarrow>\n                                    \\<not> d dvd i))\\<cdot>\n                        (intsFrom\\<cdot>(MkI\\<cdot>(1 + int n))));\n        modulo inta (int n) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> int n dvd inta", "by (metis dvd_eq_mod_eq_0)"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> x.\n      neg\\<cdot>\n      (eq\\<cdot>(mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>0))\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..]) =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>x). Def (\\<not> int n dvd x))\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> x.\n      neg\\<cdot>\n      (eq\\<cdot>(mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>0))\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..]) =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>x). Def (\\<not> int n dvd x))\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"... = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<not> n dvd i) \\<and> (\\<forall>d::int. d > 1 \\<longrightarrow> d < n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>(n+1)..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>x). Def (\\<not> int n dvd x))\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int (n + 1))..]) =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i).\n        Def (\\<not> int n dvd i \\<and>\n             (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i)))\\<cdot>\n    [MkI\\<cdot>(int (n + 1))..]", "by (auto intro!: filter_cong[rule_format])"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>x). Def (\\<not> int n dvd x))\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..]) =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<not> int n dvd i \\<and>\n           (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i)))\\<cdot>\n  [MkI\\<cdot>(int (n + 1))..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>x). Def (\\<not> int n dvd x))\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..]) =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<not> int n dvd i \\<and>\n           (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i)))\\<cdot>\n  [MkI\\<cdot>(int (n + 1))..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"... = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d \\<le> n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>(n+1)..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i).\n        Def (\\<not> int n dvd i \\<and>\n             (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i)))\\<cdot>\n    [MkI\\<cdot>(int (n + 1))..] =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i).\n        Def (\\<forall>d>1.\n                d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n    [MkI\\<cdot>(int (n + 1))..]", "apply (rule filter_cong[rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Data_List.set [MkI\\<cdot>(int (n + 1))..] \\<Longrightarrow>\n       (case x of\n        MkI\\<cdot>i \\<Rightarrow>\n          Def (\\<not> int n dvd i \\<and>\n               (\\<forall>d>1.\n                   d < int n \\<longrightarrow> \\<not> d dvd i))) =\n       (case x of\n        MkI\\<cdot>i \\<Rightarrow>\n          Def (\\<forall>d>1.\n                  d \\<le> int n \\<longrightarrow> \\<not> d dvd i))", "apply (rename_tac x, case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> Data_List.set [MkI\\<cdot>(int (n + 1))..];\n        x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          MkI\\<cdot>i \\<Rightarrow>\n                            Def (\\<not> int n dvd i \\<and>\n                                 (\\<forall>d>1.\n                                     d < int n \\<longrightarrow>\n                                     \\<not> d dvd i))) =\n                         (case x of\n                          MkI\\<cdot>i \\<Rightarrow>\n                            Def (\\<forall>d>1.\n                                    d \\<le> int n \\<longrightarrow>\n                                    \\<not> d dvd i))\n 2. \\<And>x inta.\n       \\<lbrakk>x \\<in> Data_List.set [MkI\\<cdot>(int (n + 1))..];\n        x = MkI\\<cdot>inta\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          MkI\\<cdot>i \\<Rightarrow>\n                            Def (\\<not> int n dvd i \\<and>\n                                 (\\<forall>d>1.\n                                     d < int n \\<longrightarrow>\n                                     \\<not> d dvd i))) =\n                         (case x of\n                          MkI\\<cdot>i \\<Rightarrow>\n                            Def (\\<forall>d>1.\n                                    d \\<le> int n \\<longrightarrow>\n                                    \\<not> d dvd i))", "using \\<open>n > 1\\<close>"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> Data_List.set [MkI\\<cdot>(int (n + 1))..];\n        x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          MkI\\<cdot>i \\<Rightarrow>\n                            Def (\\<not> int n dvd i \\<and>\n                                 (\\<forall>d>1.\n                                     d < int n \\<longrightarrow>\n                                     \\<not> d dvd i))) =\n                         (case x of\n                          MkI\\<cdot>i \\<Rightarrow>\n                            Def (\\<forall>d>1.\n                                    d \\<le> int n \\<longrightarrow>\n                                    \\<not> d dvd i))\n 2. \\<And>x inta.\n       \\<lbrakk>x \\<in> Data_List.set [MkI\\<cdot>(int (n + 1))..];\n        x = MkI\\<cdot>inta\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          MkI\\<cdot>i \\<Rightarrow>\n                            Def (\\<not> int n dvd i \\<and>\n                                 (\\<forall>d>1.\n                                     d < int n \\<longrightarrow>\n                                     \\<not> d dvd i))) =\n                         (case x of\n                          MkI\\<cdot>i \\<Rightarrow>\n                            Def (\\<forall>d>1.\n                                    d \\<le> int n \\<longrightarrow>\n                                    \\<not> d dvd i))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<not> int n dvd i \\<and>\n           (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i)))\\<cdot>\n  [MkI\\<cdot>(int (n + 1))..] =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int (n + 1))..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<not> int n dvd i \\<and>\n           (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i)))\\<cdot>\n  [MkI\\<cdot>(int (n + 1))..] =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int (n + 1))..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"... = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d \\<le> n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>(int n+1)..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i).\n        Def (\\<forall>d>1.\n                d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n    [MkI\\<cdot>(int (n + 1))..] =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i).\n        Def (\\<forall>d>1.\n                d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n    [MkI\\<cdot>(int n + 1)..]", "by (metis (no_types, lifting) of_nat_1 of_nat_add)"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int (n + 1))..] =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n + 1)..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int (n + 1))..] =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n + 1)..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"... = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d \\<le> n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>n'..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i).\n        Def (\\<forall>d>1.\n                d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n    [MkI\\<cdot>(int n + 1)..] =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i).\n        Def (\\<forall>d>1.\n                d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n    [MkI\\<cdot>(int n')..]", "apply (rule filter_fast_forward[of n n'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. int n + 1 \\<le> int n'\n 2. \\<forall>k>int n.\n       k < int n' \\<longrightarrow>\n       \\<not> (\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd k)", "using \\<open>n' > n\\<close>"], ["proof (prove)\nusing this:\n  n < n'\n\ngoal (2 subgoals):\n 1. int n + 1 \\<le> int n'\n 2. \\<forall>k>int n.\n       k < int n' \\<longrightarrow>\n       \\<not> (\\<forall>d>1. d \\<le> int n \\<longrightarrow> \\<not> d dvd k)", "apply (auto simp add: between_have_divisors)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n + 1)..] =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n + 1)..] =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"... = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d < n' \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>n'..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i).\n        Def (\\<forall>d>1.\n                d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n    [MkI\\<cdot>(int n')..] =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i).\n        Def (\\<forall>d>1.\n                d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n    [MkI\\<cdot>(int n')..]", "by (auto intro: filter_cong[rule_format] simp add: between_not_relvant)"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n')..] =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d \\<le> int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n')..] =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "note calculation"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> x.\n      neg\\<cdot>\n      (eq\\<cdot>(mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>0))\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..]) =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "}"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> x.\n      neg\\<cdot>\n      (eq\\<cdot>(mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>0))\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..]) =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "note tmp = this"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> x.\n      neg\\<cdot>\n      (eq\\<cdot>(mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>0))\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..]) =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "{"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> x.\n      neg\\<cdot>\n      (eq\\<cdot>(mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>0))\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..]) =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"xs = sieve\\<cdot>?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    sieve\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int n)..])", "by fact"], ["proof (state)\nthis:\n  xs =\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n)..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  xs =\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n)..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"... = sieve\\<cdot>((MkI\\<cdot>n) : xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int n)..]) =\n    sieve\\<cdot>(MkI\\<cdot>(int n) : xs')", "using \\<open>?xs = _\\<close>"], ["proof (prove)\nusing this:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n)..] =\n  MkI\\<cdot>(int n) : xs'\n\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int n)..]) =\n    sieve\\<cdot>(MkI\\<cdot>(int n) : xs')", "by simp"], ["proof (state)\nthis:\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n)..]) =\n  sieve\\<cdot>(MkI\\<cdot>(int n) : xs')\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n)..]) =\n  sieve\\<cdot>(MkI\\<cdot>(int n) : xs')\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"... = sieve\\<cdot>((MkI\\<cdot>n) : filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d < n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>(n+1)..])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>(MkI\\<cdot>(int n) : xs') =\n    sieve\\<cdot>\n    (MkI\\<cdot>(int n) :\n     Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int (n + 1))..])", "using \\<open>xs' = _\\<close>"], ["proof (prove)\nusing this:\n  xs' =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1. d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int (n + 1))..]\n\ngoal (1 subgoal):\n 1. sieve\\<cdot>(MkI\\<cdot>(int n) : xs') =\n    sieve\\<cdot>\n    (MkI\\<cdot>(int n) :\n     Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int (n + 1))..])", "by simp"], ["proof (state)\nthis:\n  sieve\\<cdot>(MkI\\<cdot>(int n) : xs') =\n  sieve\\<cdot>\n  (MkI\\<cdot>(int n) :\n   Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  sieve\\<cdot>(MkI\\<cdot>(int n) : xs') =\n  sieve\\<cdot>\n  (MkI\\<cdot>(int n) :\n   Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"... = (MkI\\<cdot>n) : sieve\\<cdot>(filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d < n' \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>n'..])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (MkI\\<cdot>(int n) :\n     Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int (n + 1))..]) =\n    MkI\\<cdot>(int n) :\n    sieve\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int n')..])", "using tmp"], ["proof (prove)\nusing this:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> x.\n      neg\\<cdot>\n      (eq\\<cdot>(mod\\<cdot>x\\<cdot>(MkI\\<cdot>(int n)))\\<cdot>0))\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..]) =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i).\n      Def (\\<forall>d>1.\n              d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (MkI\\<cdot>(int n) :\n     Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int (n + 1))..]) =\n    MkI\\<cdot>(int n) :\n    sieve\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int n')..])", "by simp"], ["proof (state)\nthis:\n  sieve\\<cdot>\n  (MkI\\<cdot>(int n) :\n   Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..]) =\n  MkI\\<cdot>(int n) :\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n')..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  sieve\\<cdot>\n  (MkI\\<cdot>(int n) :\n   Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int (n + 1))..]) =\n  MkI\\<cdot>(int n) :\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n')..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "note calculation"], ["proof (state)\nthis:\n  xs =\n  MkI\\<cdot>(int n) :\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n')..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "}"], ["proof (state)\nthis:\n  xs =\n  MkI\\<cdot>(int n) :\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n')..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "moreover"], ["proof (state)\nthis:\n  xs =\n  MkI\\<cdot>(int n) :\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n')..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "{"], ["proof (state)\nthis:\n  xs =\n  MkI\\<cdot>(int n) :\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n')..])\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"ys = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>[MkI\\<cdot>n..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n)..]", "by fact"], ["proof (state)\nthis:\n  ys =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n)..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  ys =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n)..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"... = (MkI\\<cdot>n) : filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>[MkI\\<cdot>(int n+1)..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n)..] =\n    MkI\\<cdot>(int n) :\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n + 1)..]", "using \\<open>prime n\\<close>"], ["proof (prove)\nusing this:\n  prime n\n\ngoal (1 subgoal):\n 1. Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n)..] =\n    MkI\\<cdot>(int n) :\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n + 1)..]", "by (subst intsFrom.simps[unfolded enumFrom_intsFrom_conv[symmetric]])(simp add: one_Integer_def TT_def[symmetric] add.commute)"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n)..] =\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n + 1)..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n)..] =\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n + 1)..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "have \"... = (MkI\\<cdot>n) : filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>[MkI\\<cdot>n'..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkI\\<cdot>(int n) :\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n + 1)..] =\n    MkI\\<cdot>(int n) :\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n')..]", "apply (subst filter_fast_forward[of n n'])"], ["proof (prove)\ngoal (3 subgoals):\n 1. int n + 1 \\<le> int n'\n 2. \\<forall>k>int n.\n       k < int n' \\<longrightarrow> \\<not> prime (nat \\<bar>k\\<bar>)\n 3. MkI\\<cdot>(int n) :\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n')..] =\n    MkI\\<cdot>(int n) :\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n')..]", "using \\<open>n' > n\\<close> and not_prime"], ["proof (prove)\nusing this:\n  n < n'\n  \\<forall>k>n. k < n' \\<longrightarrow> \\<not> prime k\n\ngoal (3 subgoals):\n 1. int n + 1 \\<le> int n'\n 2. \\<forall>k>int n.\n       k < int n' \\<longrightarrow> \\<not> prime (nat \\<bar>k\\<bar>)\n 3. MkI\\<cdot>(int n) :\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n')..] =\n    MkI\\<cdot>(int n) :\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n')..]", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<forall>k>n. k < n' \\<longrightarrow> \\<not> prime k;\n        int n < k; k < int n'; prime k\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis (full_types) \\<open>\\<And>k. \\<lbrakk>int n < k; k < int n'\\<rbrakk> \\<Longrightarrow> \\<exists>d>1. d \\<le> int n \\<and> d dvd k\\<close> le_less not_le prime_gt_0_int prime_int_not_dvd zdvd_imp_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n + 1)..] =\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "also"], ["proof (state)\nthis:\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n + 1)..] =\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "note calculation"], ["proof (state)\nthis:\n  ys =\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "}"], ["proof (state)\nthis:\n  ys =\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "moreover"], ["proof (state)\nthis:\n  ys =\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "note \\<open>prime n'\\<close>"], ["proof (state)\nthis:\n  prime n'\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "ultimately"], ["proof (chain)\npicking this:\n  xs =\n  MkI\\<cdot>(int n) :\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n')..])\n  ys =\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n  prime n'", "have \"\\<exists> p xs' ys'. xs = p : xs' \\<and> ys = p : ys' \\<and> prim_bisim xs' ys'\""], ["proof (prove)\nusing this:\n  xs =\n  MkI\\<cdot>(int n) :\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n')..])\n  ys =\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n  prime n'\n\ngoal (1 subgoal):\n 1. \\<exists>p xs' ys'.\n       xs = p : xs' \\<and> ys = p : ys' \\<and> prim_bisim xs' ys'", "unfolding prim_bisim"], ["proof (prove)\nusing this:\n  xs =\n  MkI\\<cdot>(int n) :\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n')..])\n  ys =\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n  prime n'\n\ngoal (1 subgoal):\n 1. \\<exists>p xs' ys'.\n       xs = p : xs' \\<and>\n       ys = p : ys' \\<and>\n       (\\<exists>n.\n           prime n \\<and>\n           xs' =\n           sieve\\<cdot>\n           (Data_List.filter\\<cdot>\n            (\\<Lambda> (MkI\\<cdot>i).\n                Def (\\<forall>d>1.\n                        d < n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n            [MkI\\<cdot>n..]) \\<and>\n           ys' =\n           Data_List.filter\\<cdot>\n           (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n           [MkI\\<cdot>n..])", "using prime_nat_int_transfer"], ["proof (prove)\nusing this:\n  xs =\n  MkI\\<cdot>(int n) :\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int n' \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int n')..])\n  ys =\n  MkI\\<cdot>(int n) :\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int n')..]\n  prime n'\n  prime (int ?n) = prime ?n\n\ngoal (1 subgoal):\n 1. \\<exists>p xs' ys'.\n       xs = p : xs' \\<and>\n       ys = p : ys' \\<and>\n       (\\<exists>n.\n           prime n \\<and>\n           xs' =\n           sieve\\<cdot>\n           (Data_List.filter\\<cdot>\n            (\\<Lambda> (MkI\\<cdot>i).\n                Def (\\<forall>d>1.\n                        d < n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n            [MkI\\<cdot>n..]) \\<and>\n           ys' =\n           Data_List.filter\\<cdot>\n           (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n           [MkI\\<cdot>n..])", "by blast"], ["proof (state)\nthis:\n  \\<exists>p xs' ys'.\n     xs = p : xs' \\<and> ys = p : ys' \\<and> prim_bisim xs' ys'\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "}"], ["proof (state)\nthis:\n  prim_bisim ?xs2 ?ys2 \\<Longrightarrow>\n  \\<exists>p xs' ys'.\n     ?xs2 = p : xs' \\<and> ?ys2 = p : ys' \\<and> prim_bisim xs' ys'\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "then"], ["proof (chain)\npicking this:\n  prim_bisim ?xs2 ?ys2 \\<Longrightarrow>\n  \\<exists>p xs' ys'.\n     ?xs2 = p : xs' \\<and> ?ys2 = p : ys' \\<and> prim_bisim xs' ys'", "show ?thesis"], ["proof (prove)\nusing this:\n  prim_bisim ?xs2 ?ys2 \\<Longrightarrow>\n  \\<exists>p xs' ys'.\n     ?xs2 = p : xs' \\<and> ?ys2 = p : ys' \\<and> prim_bisim xs' ys'\n\ngoal (1 subgoal):\n 1. list_bisim prim_bisim", "unfolding list.bisim_def"], ["proof (prove)\nusing this:\n  prim_bisim ?xs2 ?ys2 \\<Longrightarrow>\n  \\<exists>p xs' ys'.\n     ?xs2 = p : xs' \\<and> ?ys2 = p : ys' \\<and> prim_bisim xs' ys'\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       prim_bisim x y \\<longrightarrow>\n       x = \\<bottom> \\<and> y = \\<bottom> \\<or>\n       x = [] \\<and> y = [] \\<or>\n       (\\<exists>a list a' list'.\n           a = a' \\<and>\n           prim_bisim list list' \\<and> x = a : list \\<and> y = a' : list')", "by metis"], ["proof (state)\nthis:\n  list_bisim prim_bisim\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now we apply coinduction:\\<close>"], ["", "lemma sieve_produces_primes:\n  fixes n :: nat\n  assumes \"prime n\"\n  shows \"sieve\\<cdot>(filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d < n \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>n..])\n    = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>[MkI\\<cdot>n..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int n)..]) =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n)..]", "using assms"], ["proof (prove)\nusing this:\n  prime n\n\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int n)..]) =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n)..]", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime n \\<Longrightarrow>\n    sieve\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int n)..]) =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int n)..]", "apply (rule list.coinduct[OF prim_bisim_is_bisim], auto simp add: prim_bisim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime n \\<Longrightarrow>\n    \\<exists>na.\n       prime na \\<and>\n       sieve\\<cdot>\n       (Data_List.filter\\<cdot>\n        (\\<Lambda> (MkI\\<cdot>i).\n            Def (\\<forall>d>1.\n                    d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n        (intsFrom\\<cdot>(MkI\\<cdot>(int n)))) =\n       sieve\\<cdot>\n       (Data_List.filter\\<cdot>\n        (\\<Lambda> (MkI\\<cdot>i).\n            Def (\\<forall>d>1.\n                    d < na \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n        (intsFrom\\<cdot>(MkI\\<cdot>na))) \\<and>\n       Data_List.filter\\<cdot>\n       (\\<Lambda> (MkI\\<cdot>i). Def (prime \\<bar>i\\<bar>))\\<cdot>\n       (intsFrom\\<cdot>(MkI\\<cdot>(int n))) =\n       Data_List.filter\\<cdot>\n       (\\<Lambda> (MkI\\<cdot>i). Def (prime \\<bar>i\\<bar>))\\<cdot>\n       (intsFrom\\<cdot>(MkI\\<cdot>na))", "using prime_nat_int_transfer"], ["proof (prove)\nusing this:\n  prime (int ?n) = prime ?n\n\ngoal (1 subgoal):\n 1. prime n \\<Longrightarrow>\n    \\<exists>na.\n       prime na \\<and>\n       sieve\\<cdot>\n       (Data_List.filter\\<cdot>\n        (\\<Lambda> (MkI\\<cdot>i).\n            Def (\\<forall>d>1.\n                    d < int n \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n        (intsFrom\\<cdot>(MkI\\<cdot>(int n)))) =\n       sieve\\<cdot>\n       (Data_List.filter\\<cdot>\n        (\\<Lambda> (MkI\\<cdot>i).\n            Def (\\<forall>d>1.\n                    d < na \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n        (intsFrom\\<cdot>(MkI\\<cdot>na))) \\<and>\n       Data_List.filter\\<cdot>\n       (\\<Lambda> (MkI\\<cdot>i). Def (prime \\<bar>i\\<bar>))\\<cdot>\n       (intsFrom\\<cdot>(MkI\\<cdot>(int n))) =\n       Data_List.filter\\<cdot>\n       (\\<Lambda> (MkI\\<cdot>i). Def (prime \\<bar>i\\<bar>))\\<cdot>\n       (intsFrom\\<cdot>(MkI\\<cdot>na))", "by blast"], ["", "text \\<open>And finally show the correctness of primes.\\<close>"], ["", "theorem primes:\n  shows \"primes = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>[MkI\\<cdot>2..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primes =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>2..]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. primes =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>2..]", "have \"primes = sieve\\<cdot>[2 ..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primes = sieve\\<cdot>[2..]", "by (rule primes.simps)"], ["proof (state)\nthis:\n  primes = sieve\\<cdot>[2..]\n\ngoal (1 subgoal):\n 1. primes =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>2..]", "also"], ["proof (state)\nthis:\n  primes = sieve\\<cdot>[2..]\n\ngoal (1 subgoal):\n 1. primes =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>2..]", "have \"... = sieve\\<cdot>(filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def ((\\<forall>d::int. d > 1 \\<longrightarrow> d < (int 2) \\<longrightarrow> \\<not> (d dvd i))))\\<cdot>[MkI\\<cdot>(int 2)..])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>[2..] =\n    sieve\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int 2 \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int 2)..])", "unfolding numeral_Integer_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>[MkI\\<cdot>2..] =\n    sieve\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int 2 \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int 2)..])", "by (subst filter_TT, auto)"], ["proof (state)\nthis:\n  sieve\\<cdot>[2..] =\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int 2 \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int 2)..])\n\ngoal (1 subgoal):\n 1. primes =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>2..]", "also"], ["proof (state)\nthis:\n  sieve\\<cdot>[2..] =\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int 2 \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int 2)..])\n\ngoal (1 subgoal):\n 1. primes =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>2..]", "have \"... = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>[MkI\\<cdot>(int 2)..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sieve\\<cdot>\n    (Data_List.filter\\<cdot>\n     (\\<Lambda> (MkI\\<cdot>i).\n         Def (\\<forall>d>1.\n                 d < int 2 \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n     [MkI\\<cdot>(int 2)..]) =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int 2)..]", "by (rule sieve_produces_primes[OF two_is_prime_nat])"], ["proof (state)\nthis:\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int 2 \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int 2)..]) =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int 2)..]\n\ngoal (1 subgoal):\n 1. primes =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>2..]", "also"], ["proof (state)\nthis:\n  sieve\\<cdot>\n  (Data_List.filter\\<cdot>\n   (\\<Lambda> (MkI\\<cdot>i).\n       Def (\\<forall>d>1.\n               d < int 2 \\<longrightarrow> \\<not> d dvd i))\\<cdot>\n   [MkI\\<cdot>(int 2)..]) =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int 2)..]\n\ngoal (1 subgoal):\n 1. primes =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>2..]", "have \"... = filter\\<cdot>(\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>[MkI\\<cdot>2..]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>(int 2)..] =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>2..]", "by simp"], ["proof (state)\nthis:\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>(int 2)..] =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>2..]\n\ngoal (1 subgoal):\n 1. primes =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>2..]", "finally"], ["proof (chain)\npicking this:\n  primes =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>2..]", "show ?thesis"], ["proof (prove)\nusing this:\n  primes =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>2..]\n\ngoal (1 subgoal):\n 1. primes =\n    Data_List.filter\\<cdot>\n    (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n    [MkI\\<cdot>2..]", "."], ["proof (state)\nthis:\n  primes =\n  Data_List.filter\\<cdot>\n  (\\<Lambda> (MkI\\<cdot>i). Def (prime (nat \\<bar>i\\<bar>)))\\<cdot>\n  [MkI\\<cdot>2..]\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}