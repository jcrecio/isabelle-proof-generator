{"file_name": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude/examples/HLint.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude", "problem_names": ["lemma \"(eq\\<cdot>(x::'a::Eq_sym)\\<cdot>a orelse eq\\<cdot>x\\<cdot>b orelse eq\\<cdot>x\\<cdot>c) = elem\\<cdot>x\\<cdot>[a, b, c]\"", "lemma \"(neq\\<cdot>(x::'a::Eq_sym)\\<cdot>a andalso neq\\<cdot>x\\<cdot>b andalso neq\\<cdot>x\\<cdot>c) = notElem\\<cdot>x\\<cdot>[a, b, c]\"", "lemma \"concat\\<cdot>(map\\<cdot>f\\<cdot>x) = concatMap\\<cdot>f\\<cdot>x\"", "lemma \"concat\\<cdot>[a, b] = a ++ b\"", "lemma \"map\\<cdot>f\\<cdot>(map\\<cdot>g\\<cdot>x) = map\\<cdot>(f oo g)\\<cdot>x\"", "lemma \"x !! 0 = head\\<cdot>x\"", "lemma \"take\\<cdot>n\\<cdot>(repeat\\<cdot>x) = replicate\\<cdot>n\\<cdot>x\"", "lemma \"head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x\"", "lemma\n  assumes \"le\\<cdot>0\\<cdot>n \\<noteq> FF\"\n  shows \"head\\<cdot>(drop\\<cdot>n\\<cdot>x) = x !! n\"", "lemma \"reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x\"", "lemma\n  assumes \"x \\<noteq> []\"\n  shows \"take\\<cdot>(length\\<cdot>x - 1)\\<cdot>x \\<sqsubseteq> init\\<cdot>x\"", "lemma foldr_append_concat:\"foldr\\<cdot>append\\<cdot>[] = concat\"", "lemma \"foldl\\<cdot>append\\<cdot>[] \\<sqsubseteq> concat\"", "lemma \"span\\<cdot>(neg oo p) = break\\<cdot>p\"", "lemma \"break\\<cdot>(neg oo p) = span\\<cdot>p\"", "lemma \"the_or\\<cdot>(map\\<cdot>p\\<cdot>x) = any\\<cdot>p\\<cdot>x\"", "lemma \"the_and\\<cdot>(map\\<cdot>p\\<cdot>x) = all\\<cdot>p\\<cdot>x\"", "lemma \"zipWith\\<cdot>\\<langle>,\\<rangle> = zip\"", "lemma \"zipWith3\\<cdot>\\<langle>,,\\<rangle> = zip3\"", "lemma \"eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x\"", "lemma \"neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> neg\\<cdot>(null\\<cdot>x)\"", "lemma \"map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>x\\<cdot>y) = zipWith\\<cdot>f\\<cdot>x\\<cdot>y\"", "lemma \"map\\<cdot>f\\<cdot>(zip\\<cdot>x\\<cdot>y) = zipWith\\<cdot>(curry\\<cdot>f)\\<cdot>x\\<cdot>y\"", "lemma \"neg\\<cdot>(elem\\<cdot>x\\<cdot>y) = notElem\\<cdot>x\\<cdot>y\"", "lemma \"foldr\\<cdot>f\\<cdot>z\\<cdot>(map\\<cdot>g\\<cdot>x) = foldr\\<cdot>(f oo g)\\<cdot>z\\<cdot>x\"", "lemma \"null\\<cdot>(filter\\<cdot>f\\<cdot>x) = neg\\<cdot>(any\\<cdot>f\\<cdot>x)\"", "lemma \"eq\\<cdot>(filter\\<cdot>f\\<cdot>x)\\<cdot>[] = neg\\<cdot>(any\\<cdot>f\\<cdot>x)\"", "lemma \"neq\\<cdot>(filter\\<cdot>f\\<cdot>x)\\<cdot>[] = any\\<cdot>f\\<cdot>x\"", "lemma \"any\\<cdot>(\\<Lambda> z. eq\\<cdot>z\\<cdot>a) = elem\\<cdot>a\"", "lemma \"any\\<cdot>(eq\\<cdot>(a::'a::Eq_sym)) = elem\\<cdot>a\"", "lemma \"any\\<cdot>(\\<Lambda> z. eq\\<cdot>(a::'a::Eq_sym)\\<cdot>z) = elem\\<cdot>a\"", "lemma \"all\\<cdot>(\\<Lambda> z. neq\\<cdot>z\\<cdot>(a::'a::Eq_sym)) = notElem\\<cdot>a\"", "lemma \"all\\<cdot>(\\<Lambda> z. neq\\<cdot>(a::'a::Eq_sym)\\<cdot>z) = notElem\\<cdot>a\"", "lemma \"foldr\\<cdot>trand\\<cdot>TT = the_and\"", "lemma foldl_to_and:\"foldl\\<cdot>trand\\<cdot>TT \\<sqsubseteq> the_and\"", "lemma \"foldr1\\<cdot>trand \\<sqsubseteq> the_and\"", "lemma \"foldl1\\<cdot>trand \\<sqsubseteq> the_and\"", "lemma \"foldr\\<cdot>tror\\<cdot>FF = the_or\"", "lemma foldl_to_or: \"foldl\\<cdot>tror\\<cdot>FF \\<sqsubseteq> the_or\"", "lemma \"foldr1\\<cdot>tror \\<sqsubseteq> the_or\"", "lemma \"foldl1\\<cdot>tror \\<sqsubseteq> the_or\"", "lemma \"(\\<Lambda> x. x) = ID\"", "lemma \"(\\<Lambda> x y. x) = const\"", "lemma \"(\\<Lambda> \\<langle>x, y\\<rangle>. x) = fst\"", "lemma \"(\\<Lambda> \\<langle>x, y\\<rangle>. y) = snd\"", "lemma \"(\\<Lambda> x y. f\\<cdot>\\<langle>x, y\\<rangle>) = curry\\<cdot>f\"", "lemma \"(\\<Lambda> \\<langle>x, y\\<rangle>. f\\<cdot>x\\<cdot>y) \\<sqsubseteq> uncurry\\<cdot>f\"", "lemma \"(\\<Lambda> x. y) = const\\<cdot>y\"", "lemma \"flip\\<cdot>f\\<cdot>x\\<cdot>y = f\\<cdot>y\\<cdot>x\"", "lemma eq_true:\"eq\\<cdot>x\\<cdot>TT = x\"", "lemma eq_false:\"eq\\<cdot>x\\<cdot>FF = neg\\<cdot>x\"", "lemma if_equal:\"(If a then x else x) \\<sqsubseteq> x\"", "lemma \"(If a then TT else FF) = a\"", "lemma \"(If a then FF else TT) = neg\\<cdot>a\"", "lemma \"(If a then t else (If b then t else f)) = (If a orelse b then t else f)\"", "lemma \"(If a then (If b then t else f) else f) = (If a andalso b then t else f)\"", "lemma \"(If x then TT else y) = (x orelse y)\"", "lemma \"(If x then y else FF) = (x andalso y)\"", "lemma \"(If c then \\<langle>TT, x\\<rangle> else \\<langle>FF, x\\<rangle>) \\<sqsubseteq> \\<langle>c, x\\<rangle>\"", "lemma \"(If c then \\<langle>FF, x\\<rangle> else \\<langle>TT, x\\<rangle>) \\<sqsubseteq> \\<langle>neg\\<cdot>c, x\\<rangle>\"", "lemma \"the_or\\<cdot>[x, y] = (x orelse y)\"", "lemma \"the_or\\<cdot>[x, y, z] = (x orelse y orelse z)\"", "lemma \"the_and\\<cdot>[x, y] = (x andalso y)\"", "lemma \"the_and\\<cdot>[x, y, z] = (x andalso y andalso z)\"", "lemma \"x \\<sqsubseteq> \\<langle>fst\\<cdot>x, snd\\<cdot>x\\<rangle>\"", "lemma \"seq\\<cdot>x\\<cdot>x = x\"", "lemma \"(TT andalso x) = x\"", "lemma \"(FF andalso x) = FF\"", "lemma \"(TT orelse x) = TT\"", "lemma \"(FF orelse x) = x\"", "lemma \"neg\\<cdot>TT = FF\"", "lemma \"neg\\<cdot>FF = TT\"", "lemma \"fst\\<cdot>\\<langle>x, y\\<rangle> = x\"", "lemma \"snd\\<cdot>\\<langle>x, y\\<rangle> = y\"", "lemma \"f\\<cdot>(fst\\<cdot>p)\\<cdot>(snd\\<cdot>p) = uncurry\\<cdot>f\\<cdot>p\"", "lemma \"init\\<cdot>[x] = []\"", "lemma \"null\\<cdot>[] = TT\"", "lemma \"length\\<cdot>[] = 0\"", "lemma \"foldl\\<cdot>f\\<cdot>z\\<cdot>[] = z\"", "lemma \"foldr\\<cdot>f\\<cdot>z\\<cdot>[] = z\"", "lemma \"foldr1\\<cdot>f\\<cdot>[x] = x\"", "lemma \"scanr\\<cdot>f\\<cdot>z\\<cdot>[] = [z]\"", "lemma \"scanr1\\<cdot>f\\<cdot>[] = []\"", "lemma \"scanr1\\<cdot>f\\<cdot>[x] = [x]\"", "lemma \"take\\<cdot>n\\<cdot>[] \\<sqsubseteq> []\"", "lemma \"drop\\<cdot>n\\<cdot>[] \\<sqsubseteq> []\"", "lemma \"takeWhile\\<cdot>p\\<cdot>[] = []\"", "lemma \"dropWhile\\<cdot>p\\<cdot>[] = []\"", "lemma \"span\\<cdot>p\\<cdot>[] = \\<langle>[], []\\<rangle>\"", "lemma \"concat\\<cdot>[a] = a\"", "lemma \"concat\\<cdot>[] = []\"", "lemma \"zip\\<cdot>[]\\<cdot>[] = []\"", "lemma \"ID\\<cdot>x = x\"", "lemma \"const\\<cdot>x\\<cdot>y = x\"", "lemma\n  fixes t :: \"['a::Eq_sym]\"\n  shows \"eq\\<cdot>(take\\<cdot>(length\\<cdot>t)\\<cdot>s)\\<cdot>t \\<sqsubseteq> isPrefixOf\\<cdot>t\\<cdot>s\"", "lemma\n  assumes \"t = []\" and \"s = x : xs\" and \"i = 1\"\n  shows \"\\<not> (eq\\<cdot>(take\\<cdot>i\\<cdot>s)\\<cdot>t \\<sqsubseteq> (le\\<cdot>(length\\<cdot>t)\\<cdot>i andalso isPrefixOf\\<cdot>t\\<cdot>s))\"", "lemma\n  assumes \"le\\<cdot>0\\<cdot>i = TT\" and \"le\\<cdot>i\\<cdot>0 = FF\"\n    and \"s = \\<bottom>\" and \"t = []\"\n  shows \"\\<not> ((le\\<cdot>(length\\<cdot>t)\\<cdot>i andalso isPrefixOf\\<cdot>t\\<cdot>s) \\<sqsubseteq> eq\\<cdot>(take\\<cdot>i\\<cdot>s)\\<cdot>t)\"", "lemma \"neg\\<cdot>(eq\\<cdot>a\\<cdot>b) = neq\\<cdot>a\\<cdot>b\"", "lemma \"neg\\<cdot>(neq\\<cdot>a\\<cdot>b) = eq\\<cdot>a\\<cdot>b\"", "lemma map_id:\"map\\<cdot>ID = ID\"", "lemma \"eq\\<cdot>x\\<cdot>[] = null\\<cdot>x\"", "lemma \"any\\<cdot>ID = the_or\"", "lemma \"all\\<cdot>ID = the_and\"", "lemma \"(If x then FF else y) = (neg\\<cdot>x andalso y)\"", "lemma \"(If x then y else TT) = (neg\\<cdot>x orelse y)\"", "lemma \"neg\\<cdot>(neg\\<cdot>x) = x\"", "lemma \"(If c then f\\<cdot>x else f\\<cdot>y) \\<sqsubseteq> f\\<cdot>(If c then x else y)\"", "lemma \"(\\<Lambda> x. [x]) = (\\<Lambda> z. z : [])\"", "lemma \"eq\\<cdot>TT\\<cdot>a = a\"", "lemma \"eq\\<cdot>FF\\<cdot>a = neg\\<cdot>a\"", "lemma \"neq\\<cdot>a\\<cdot>TT = neg\\<cdot>a\"", "lemma \"neq\\<cdot>a\\<cdot>FF = a\"", "lemma \"neq\\<cdot>TT\\<cdot>a = neg\\<cdot>a\"", "lemma \"neq\\<cdot>FF\\<cdot>a = a\"", "lemma \"neg\\<cdot>(isNothing\\<cdot>x) = isJust\\<cdot>x\"", "lemma \"neg\\<cdot>(isJust\\<cdot>x) = isNothing\\<cdot>x\"", "lemma \"eq\\<cdot>x\\<cdot>Nothing = isNothing\\<cdot>x\"", "lemma \"eq\\<cdot>Nothing\\<cdot>x = isNothing\\<cdot>x\"", "lemma \"neq\\<cdot>x\\<cdot>Nothing = isJust\\<cdot>x\"", "lemma \"neq\\<cdot>Nothing\\<cdot>x = isJust\\<cdot>x\"", "lemma \"(If isNothing\\<cdot>x then y else fromJust\\<cdot>x) = fromMaybe\\<cdot>y\\<cdot>x\"", "lemma \"(If isJust\\<cdot>x then fromJust\\<cdot>x else y) = fromMaybe\\<cdot>y\\<cdot>x\"", "lemma \"(isJust\\<cdot>x andalso (eq\\<cdot>(fromJust\\<cdot>x)\\<cdot>y)) = eq\\<cdot>x\\<cdot>(Just\\<cdot>y)\"", "lemma \"elem\\<cdot>TT = the_or\"", "lemma \"notElem\\<cdot>FF = the_and\"", "lemma \"all\\<cdot>(neq\\<cdot>(a::'a::Eq_sym)) = notElem\\<cdot>a\"", "lemma \"maybe\\<cdot>x\\<cdot>ID = fromMaybe\\<cdot>x\"", "lemma \"maybe\\<cdot>FF\\<cdot>(const\\<cdot>TT) = isJust\"", "lemma \"maybe\\<cdot>TT\\<cdot>(const\\<cdot>FF) = isNothing\"", "lemma \"maybe\\<cdot>[]\\<cdot>(\\<Lambda> z. z : []) = maybeToList\"", "lemma \"catMaybes\\<cdot>(map\\<cdot>f\\<cdot>x) = mapMaybe\\<cdot>f\\<cdot>x\"", "lemma \"(If isNothing\\<cdot>x then y else f\\<cdot>(fromJust\\<cdot>x)) = maybe\\<cdot>y\\<cdot>f\\<cdot>x\"", "lemma \"(If isJust\\<cdot>x then f\\<cdot>(fromJust\\<cdot>x) else y) = maybe\\<cdot>y\\<cdot>f\\<cdot>x\"", "lemma \"(map\\<cdot>fromJust oo filter\\<cdot>isJust) = catMaybes\"", "lemma \"concatMap\\<cdot>(maybeToList oo f) = mapMaybe\\<cdot>f\"", "lemma \"concatMap\\<cdot>maybeToList = catMaybes\"", "lemma \"mapMaybe\\<cdot>f\\<cdot>(map\\<cdot>g\\<cdot>x) = mapMaybe\\<cdot>(f oo g)\\<cdot>x\"", "lemma \"(dollar oo f) = f\"", "lemma \"(\\<Lambda> z. dollar\\<cdot>f\\<cdot>z) = f\"", "lemma \"(\\<Lambda> a b. g\\<cdot>(f\\<cdot>a)\\<cdot>(f\\<cdot>b)) = on\\<cdot>g\\<cdot>f\"", "lemma \"dollarBang\\<cdot>ID\\<cdot>x = x\"", "lemma \"[x | x <- y] = y\"", "lemma \"isPrefixOf\\<cdot>(reverse\\<cdot>x)\\<cdot>(reverse\\<cdot>y) = isSuffixOf\\<cdot>x\\<cdot>y\"", "lemma \"concat\\<cdot>(intersperse\\<cdot>x\\<cdot>y) = intercalate\\<cdot>x\\<cdot>y\"", "lemma\n  assumes \"x \\<noteq> \\<bottom>\" shows \"seq\\<cdot>x\\<cdot>y = y\"", "lemma assumes \"x \\<noteq> \\<bottom>\" shows \"dollarBang\\<cdot>f\\<cdot>x = f\\<cdot>x\"", "lemma \"maybe\\<cdot>(f\\<cdot>x)\\<cdot>(f oo g) \\<sqsubseteq> (f oo maybe\\<cdot>x\\<cdot>g)\""], "translations": [["", "lemma \"(eq\\<cdot>(x::'a::Eq_sym)\\<cdot>a orelse eq\\<cdot>x\\<cdot>b orelse eq\\<cdot>x\\<cdot>c) = elem\\<cdot>x\\<cdot>[a, b, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq\\<cdot>x\\<cdot>\n     a orelse eq\\<cdot>x\\<cdot>b orelse eq\\<cdot>x\\<cdot>c) =\n    elem\\<cdot>x\\<cdot>[a, b, c]", "by (auto simp add: eq_sym)"], ["", "text \\<open>@{verbatim \\<open> x /= a && x /= b && x /= c ==> x `notElem` [a,b,c]\\<close> } \\<close>"], ["", "lemma \"(neq\\<cdot>(x::'a::Eq_sym)\\<cdot>a andalso neq\\<cdot>x\\<cdot>b andalso neq\\<cdot>x\\<cdot>c) = notElem\\<cdot>x\\<cdot>[a, b, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (neq\\<cdot>x\\<cdot>\n     a andalso neq\\<cdot>x\\<cdot>b andalso neq\\<cdot>x\\<cdot>c) =\n    notElem\\<cdot>x\\<cdot>[a, b, c]", "by (auto simp add: eq_sym)"], ["", "(*  compare (f x) (f y) ==> Data.Ord.comparing f x y -- not that great *)\n    (*  on compare f ==> Data.Ord.comparing f -- not that great *)\n    (* -- READ/SHOW *)\n    (*  showsPrec 0 x \"\" ==> show x *)\n    (*  readsPrec 0 ==> reads *)\n    (*  showsPrec 0 ==> shows *)\n    (*  showIntAtBase 16 intToDigit ==> showHex *)\n    (*  showIntAtBase 8 intToDigit ==> showOct *)"], ["", "subsection \\<open>List\\<close>"], ["", "text \\<open>@{verbatim \\<open> concat (map f x) ==> concatMap f x\\<close> } \\<close>"], ["", "lemma \"concat\\<cdot>(map\\<cdot>f\\<cdot>x) = concatMap\\<cdot>f\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\\<cdot>(map\\<cdot>f\\<cdot>x) = concatMap\\<cdot>f\\<cdot>x", "by (auto simp add: concatMap_def)"], ["", "text \\<open>@{verbatim \\<open> concat [a, b] ==> a ++ b\\<close> } \\<close>"], ["", "lemma \"concat\\<cdot>[a, b] = a ++ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\\<cdot>[a, b] = a ++ b", "by auto"], ["", "text \\<open>@{verbatim \\<open> map f (map g x) ==> map (f . g) x\\<close> } \\<close>"], ["", "lemma \"map\\<cdot>f\\<cdot>(map\\<cdot>g\\<cdot>x) = map\\<cdot>(f oo g)\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>f\\<cdot>(map\\<cdot>g\\<cdot>x) = map\\<cdot>(f oo g)\\<cdot>x", "by auto"], ["", "text \\<open>@{verbatim \\<open> x !! 0 ==> head x\\<close> } \\<close>"], ["", "lemma \"x !! 0 = head\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x !! 0 = head\\<cdot>x", "by (cases x) auto"], ["", "text \\<open>@{verbatim \\<open> take n (repeat x) ==> replicate n x\\<close> } \\<close>"], ["", "lemma \"take\\<cdot>n\\<cdot>(repeat\\<cdot>x) = replicate\\<cdot>n\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>n\\<cdot>(repeat\\<cdot>x) = replicate\\<cdot>n\\<cdot>x", "by (simp add: replicate_def)"], ["", "text \\<open>@{verbatim \\<open>lemma \"head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x\" \\<close> } \\<close>"], ["", "lemma \"head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x", "proof (cases \"finite_list x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite_list x \\<Longrightarrow>\n    head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x\n 2. \\<not> finite_list x \\<Longrightarrow>\n    head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x", "case True"], ["proof (state)\nthis:\n  finite_list x\n\ngoal (2 subgoals):\n 1. finite_list x \\<Longrightarrow>\n    head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x\n 2. \\<not> finite_list x \\<Longrightarrow>\n    head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x", "then"], ["proof (chain)\npicking this:\n  finite_list x", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_list x\n\ngoal (1 subgoal):\n 1. head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x", "by (induct x rule: reverse_induct) (auto simp add: last_append_singleton)"], ["proof (state)\nthis:\n  head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<not> finite_list x \\<Longrightarrow>\n    head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> finite_list x \\<Longrightarrow>\n    head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x", "case False"], ["proof (state)\nthis:\n  \\<not> finite_list x\n\ngoal (1 subgoal):\n 1. \\<not> finite_list x \\<Longrightarrow>\n    head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x", "then"], ["proof (chain)\npicking this:\n  \\<not> finite_list x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> finite_list x\n\ngoal (1 subgoal):\n 1. head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x", "by (simp add: last_spine_strict reverse_spine_strict)"], ["proof (state)\nthis:\n  head\\<cdot>(reverse\\<cdot>x) = last\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> head (drop n x) ==> x !! n where note = \"if the index is non-negative\"\\<close> } \\<close>"], ["", "lemma\n  assumes \"le\\<cdot>0\\<cdot>n \\<noteq> FF\"\n  shows \"head\\<cdot>(drop\\<cdot>n\\<cdot>x) = x !! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n", "proof (cases \"le\\<cdot>0\\<cdot>n\")"], ["proof (state)\ngoal (3 subgoals):\n 1. le\\<cdot>0\\<cdot>n = \\<bottom> \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n\n 2. le\\<cdot>0\\<cdot>n = TT \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n\n 3. le\\<cdot>0\\<cdot>n = FF \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n", "assume \"le\\<cdot>0\\<cdot>n = FF\""], ["proof (state)\nthis:\n  le\\<cdot>0\\<cdot>n = FF\n\ngoal (3 subgoals):\n 1. le\\<cdot>0\\<cdot>n = \\<bottom> \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n\n 2. le\\<cdot>0\\<cdot>n = TT \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n\n 3. le\\<cdot>0\\<cdot>n = FF \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n", "with assms"], ["proof (chain)\npicking this:\n  le\\<cdot>0\\<cdot>n \\<noteq> FF\n  le\\<cdot>0\\<cdot>n = FF", "show ?thesis"], ["proof (prove)\nusing this:\n  le\\<cdot>0\\<cdot>n \\<noteq> FF\n  le\\<cdot>0\\<cdot>n = FF\n\ngoal (1 subgoal):\n 1. head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n", ".."], ["proof (state)\nthis:\n  head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n\n\ngoal (2 subgoals):\n 1. le\\<cdot>0\\<cdot>n = \\<bottom> \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n\n 2. le\\<cdot>0\\<cdot>n = TT \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. le\\<cdot>0\\<cdot>n = \\<bottom> \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n\n 2. le\\<cdot>0\\<cdot>n = TT \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n", "assume \"le\\<cdot>0\\<cdot>n = TT\""], ["proof (state)\nthis:\n  le\\<cdot>0\\<cdot>n = TT\n\ngoal (2 subgoals):\n 1. le\\<cdot>0\\<cdot>n = \\<bottom> \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n\n 2. le\\<cdot>0\\<cdot>n = TT \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n", "then"], ["proof (chain)\npicking this:\n  le\\<cdot>0\\<cdot>n = TT", "show ?thesis"], ["proof (prove)\nusing this:\n  le\\<cdot>0\\<cdot>n = TT\n\ngoal (1 subgoal):\n 1. head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n", "proof (induction arbitrary: x rule: nonneg_Integer_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. head\\<cdot>(Data_List.drop\\<cdot>0\\<cdot>x) = x !! 0\n 2. \\<And>i x.\n       \\<lbrakk>le\\<cdot>1\\<cdot>i = TT;\n        \\<And>x.\n           head\\<cdot>(Data_List.drop\\<cdot>(i - 1)\\<cdot>x) =\n           x !! (i - 1)\\<rbrakk>\n       \\<Longrightarrow> head\\<cdot>(Data_List.drop\\<cdot>i\\<cdot>x) =\n                         x !! i", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. head\\<cdot>(Data_List.drop\\<cdot>0\\<cdot>x) = x !! 0\n 2. \\<And>i x.\n       \\<lbrakk>le\\<cdot>1\\<cdot>i = TT;\n        \\<And>x.\n           head\\<cdot>(Data_List.drop\\<cdot>(i - 1)\\<cdot>x) =\n           x !! (i - 1)\\<rbrakk>\n       \\<Longrightarrow> head\\<cdot>(Data_List.drop\\<cdot>i\\<cdot>x) =\n                         x !! i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. head\\<cdot>(Data_List.drop\\<cdot>0\\<cdot>x) = x !! 0", "by (cases x) auto"], ["proof (state)\nthis:\n  head\\<cdot>(Data_List.drop\\<cdot>0\\<cdot>x) = x !! 0\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>le\\<cdot>1\\<cdot>i = TT;\n        \\<And>x.\n           head\\<cdot>(Data_List.drop\\<cdot>(i - 1)\\<cdot>x) =\n           x !! (i - 1)\\<rbrakk>\n       \\<Longrightarrow> head\\<cdot>(Data_List.drop\\<cdot>i\\<cdot>x) =\n                         x !! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>le\\<cdot>1\\<cdot>i = TT;\n        \\<And>x.\n           head\\<cdot>(Data_List.drop\\<cdot>(i - 1)\\<cdot>x) =\n           x !! (i - 1)\\<rbrakk>\n       \\<Longrightarrow> head\\<cdot>(Data_List.drop\\<cdot>i\\<cdot>x) =\n                         x !! i", "case (step i x)"], ["proof (state)\nthis:\n  le\\<cdot>1\\<cdot>i = TT\n  head\\<cdot>(Data_List.drop\\<cdot>(i - 1)\\<cdot>?x) = ?x !! (i - 1)\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>le\\<cdot>1\\<cdot>i = TT;\n        \\<And>x.\n           head\\<cdot>(Data_List.drop\\<cdot>(i - 1)\\<cdot>x) =\n           x !! (i - 1)\\<rbrakk>\n       \\<Longrightarrow> head\\<cdot>(Data_List.drop\\<cdot>i\\<cdot>x) =\n                         x !! i", "from step.hyps"], ["proof (chain)\npicking this:\n  le\\<cdot>1\\<cdot>i = TT", "have [simp]:\"le\\<cdot>i\\<cdot>0 = FF\""], ["proof (prove)\nusing this:\n  le\\<cdot>1\\<cdot>i = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>i\\<cdot>0 = FF", "by (cases i, auto simp add: one_Integer_def zero_Integer_def)"], ["proof (state)\nthis:\n  le\\<cdot>i\\<cdot>0 = FF\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>le\\<cdot>1\\<cdot>i = TT;\n        \\<And>x.\n           head\\<cdot>(Data_List.drop\\<cdot>(i - 1)\\<cdot>x) =\n           x !! (i - 1)\\<rbrakk>\n       \\<Longrightarrow> head\\<cdot>(Data_List.drop\\<cdot>i\\<cdot>x) =\n                         x !! i", "from step.hyps"], ["proof (chain)\npicking this:\n  le\\<cdot>1\\<cdot>i = TT", "have [simp]:\"eq\\<cdot>i\\<cdot>0 = FF\""], ["proof (prove)\nusing this:\n  le\\<cdot>1\\<cdot>i = TT\n\ngoal (1 subgoal):\n 1. eq\\<cdot>i\\<cdot>0 = FF", "by (cases i, auto simp add: one_Integer_def zero_Integer_def)"], ["proof (state)\nthis:\n  eq\\<cdot>i\\<cdot>0 = FF\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>le\\<cdot>1\\<cdot>i = TT;\n        \\<And>x.\n           head\\<cdot>(Data_List.drop\\<cdot>(i - 1)\\<cdot>x) =\n           x !! (i - 1)\\<rbrakk>\n       \\<Longrightarrow> head\\<cdot>(Data_List.drop\\<cdot>i\\<cdot>x) =\n                         x !! i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. head\\<cdot>(Data_List.drop\\<cdot>i\\<cdot>x) = x !! i", "using step.IH"], ["proof (prove)\nusing this:\n  head\\<cdot>(Data_List.drop\\<cdot>(i - 1)\\<cdot>?x) = ?x !! (i - 1)\n\ngoal (1 subgoal):\n 1. head\\<cdot>(Data_List.drop\\<cdot>i\\<cdot>x) = x !! i", "by (cases x)auto"], ["proof (state)\nthis:\n  head\\<cdot>(Data_List.drop\\<cdot>i\\<cdot>x) = x !! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n\n\ngoal (1 subgoal):\n 1. le\\<cdot>0\\<cdot>n = \\<bottom> \\<Longrightarrow>\n    head\\<cdot>(Data_List.drop\\<cdot>n\\<cdot>x) = x !! n", "qed simp"], ["", "text \\<open>@{verbatim \\<open> reverse (tail (reverse x)) ==> init x\\<close> } \\<close>"], ["", "lemma \"reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x", "proof (cases \"finite_list x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite_list x \\<Longrightarrow>\n    reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x\n 2. \\<not> finite_list x \\<Longrightarrow>\n    reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x", "case True"], ["proof (state)\nthis:\n  finite_list x\n\ngoal (2 subgoals):\n 1. finite_list x \\<Longrightarrow>\n    reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x\n 2. \\<not> finite_list x \\<Longrightarrow>\n    reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x", "then"], ["proof (chain)\npicking this:\n  finite_list x", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_list x\n\ngoal (1 subgoal):\n 1. reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x", "by (induct x rule: reverse_induct) (auto simp add: init_append_singleton)"], ["proof (state)\nthis:\n  reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<not> finite_list x \\<Longrightarrow>\n    reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> finite_list x \\<Longrightarrow>\n    reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x", "case False"], ["proof (state)\nthis:\n  \\<not> finite_list x\n\ngoal (1 subgoal):\n 1. \\<not> finite_list x \\<Longrightarrow>\n    reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x", "then"], ["proof (chain)\npicking this:\n  \\<not> finite_list x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> finite_list x\n\ngoal (1 subgoal):\n 1. reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x", "by (auto simp add: reverse_spine_strict)"], ["proof (state)\nthis:\n  reverse\\<cdot>(tail\\<cdot>(reverse\\<cdot>x)) \\<sqsubseteq> init\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> take (length x - 1) x ==> init x\\<close> } \\<close>"], ["", "lemma\n  assumes \"x \\<noteq> []\"\n  shows \"take\\<cdot>(length\\<cdot>x - 1)\\<cdot>x \\<sqsubseteq> init\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>(length\\<cdot>x - 1)\\<cdot>x \\<sqsubseteq> init\\<cdot>x", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. take\\<cdot>(length\\<cdot>x - 1)\\<cdot>x \\<sqsubseteq> init\\<cdot>x", "proof (induct x)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            a \\<noteq> [] \\<longrightarrow>\n            take\\<cdot>(length\\<cdot>a - 1)\\<cdot>a \\<sqsubseteq>\n            init\\<cdot>a)\n 2. \\<bottom> \\<noteq> [] \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>\\<bottom> - 1)\\<cdot>\\<bottom> \\<sqsubseteq>\n    init\\<cdot>\\<bottom>\n 3. [] \\<noteq> [] \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>[] - 1)\\<cdot>[] \\<sqsubseteq> init\\<cdot>[]\n 4. \\<And>a x.\n       \\<lbrakk>x \\<noteq> [] \\<Longrightarrow>\n                take\\<cdot>(length\\<cdot>x - 1)\\<cdot>x \\<sqsubseteq>\n                init\\<cdot>x;\n        a : x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(length\\<cdot>(a : x) - 1)\\<cdot>\n                         (a : x) \\<sqsubseteq>\n                         init\\<cdot>(a : x)", "case (Cons y ys)"], ["proof (state)\nthis:\n  ys \\<noteq> [] \\<Longrightarrow>\n  take\\<cdot>(length\\<cdot>ys - 1)\\<cdot>ys \\<sqsubseteq> init\\<cdot>ys\n  y : ys \\<noteq> []\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            a \\<noteq> [] \\<longrightarrow>\n            take\\<cdot>(length\\<cdot>a - 1)\\<cdot>a \\<sqsubseteq>\n            init\\<cdot>a)\n 2. \\<bottom> \\<noteq> [] \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>\\<bottom> - 1)\\<cdot>\\<bottom> \\<sqsubseteq>\n    init\\<cdot>\\<bottom>\n 3. [] \\<noteq> [] \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>[] - 1)\\<cdot>[] \\<sqsubseteq> init\\<cdot>[]\n 4. \\<And>a x.\n       \\<lbrakk>x \\<noteq> [] \\<Longrightarrow>\n                take\\<cdot>(length\\<cdot>x - 1)\\<cdot>x \\<sqsubseteq>\n                init\\<cdot>x;\n        a : x \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> take\\<cdot>(length\\<cdot>(a : x) - 1)\\<cdot>\n                         (a : x) \\<sqsubseteq>\n                         init\\<cdot>(a : x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n    init\\<cdot>(y : ys)", "proof (cases ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. ys = \\<bottom> \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n    init\\<cdot>(y : ys)\n 2. ys = [] \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n    init\\<cdot>(y : ys)\n 3. \\<And>a list.\n       ys = a : list \\<Longrightarrow>\n       take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n       init\\<cdot>(y : ys)", "note IH = Cons"], ["proof (state)\nthis:\n  ys \\<noteq> [] \\<Longrightarrow>\n  take\\<cdot>(length\\<cdot>ys - 1)\\<cdot>ys \\<sqsubseteq> init\\<cdot>ys\n  y : ys \\<noteq> []\n\ngoal (3 subgoals):\n 1. ys = \\<bottom> \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n    init\\<cdot>(y : ys)\n 2. ys = [] \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n    init\\<cdot>(y : ys)\n 3. \\<And>a list.\n       ys = a : list \\<Longrightarrow>\n       take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n       init\\<cdot>(y : ys)", "case (Cons z zs)"], ["proof (state)\nthis:\n  ys = z : zs\n\ngoal (3 subgoals):\n 1. ys = \\<bottom> \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n    init\\<cdot>(y : ys)\n 2. ys = [] \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n    init\\<cdot>(y : ys)\n 3. \\<And>a list.\n       ys = a : list \\<Longrightarrow>\n       take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n       init\\<cdot>(y : ys)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n    init\\<cdot>(y : ys)", "using IH"], ["proof (prove)\nusing this:\n  ys \\<noteq> [] \\<Longrightarrow>\n  take\\<cdot>(length\\<cdot>ys - 1)\\<cdot>ys \\<sqsubseteq> init\\<cdot>ys\n  y : ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n    init\\<cdot>(y : ys)", "by (cases \"length\\<cdot>zs\")\n         (auto simp: Cons one_Integer_def dest: length_ge_0)"], ["proof (state)\nthis:\n  take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n  init\\<cdot>(y : ys)\n\ngoal (2 subgoals):\n 1. ys = \\<bottom> \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n    init\\<cdot>(y : ys)\n 2. ys = [] \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n    init\\<cdot>(y : ys)", "qed (auto simp: one_Integer_def)"], ["proof (state)\nthis:\n  take\\<cdot>(length\\<cdot>(y : ys) - 1)\\<cdot>(y : ys) \\<sqsubseteq>\n  init\\<cdot>(y : ys)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            a \\<noteq> [] \\<longrightarrow>\n            take\\<cdot>(length\\<cdot>a - 1)\\<cdot>a \\<sqsubseteq>\n            init\\<cdot>a)\n 2. \\<bottom> \\<noteq> [] \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>\\<bottom> - 1)\\<cdot>\\<bottom> \\<sqsubseteq>\n    init\\<cdot>\\<bottom>\n 3. [] \\<noteq> [] \\<Longrightarrow>\n    take\\<cdot>(length\\<cdot>[] - 1)\\<cdot>[] \\<sqsubseteq> init\\<cdot>[]", "qed auto"], ["", "text \\<open>@{verbatim \\<open> foldr (++) [] ==> concat\\<close> } \\<close>"], ["", "lemma foldr_append_concat:\"foldr\\<cdot>append\\<cdot>[] = concat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>append\\<cdot>[] = concat", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldr\\<cdot>append\\<cdot>[]\\<cdot>x = concat\\<cdot>x", "fix xs :: \"[['a]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldr\\<cdot>append\\<cdot>[]\\<cdot>x = concat\\<cdot>x", "show \"foldr\\<cdot>append\\<cdot>[]\\<cdot>xs = concat\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>append\\<cdot>[]\\<cdot>xs = concat\\<cdot>xs", "by (induct xs) auto"], ["proof (state)\nthis:\n  foldr\\<cdot>append\\<cdot>[]\\<cdot>xs = concat\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> foldl (++) [] ==> concat\\<close> } \\<close>"], ["", "lemma \"foldl\\<cdot>append\\<cdot>[] \\<sqsubseteq> concat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>append\\<cdot>[] \\<sqsubseteq> concat", "proof (rule cfun_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       foldl\\<cdot>append\\<cdot>[]\\<cdot>x \\<sqsubseteq> concat\\<cdot>x", "fix xs :: \"[['a]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       foldl\\<cdot>append\\<cdot>[]\\<cdot>x \\<sqsubseteq> concat\\<cdot>x", "show \"foldl\\<cdot>append\\<cdot>[]\\<cdot>xs \\<sqsubseteq> concat\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>append\\<cdot>[]\\<cdot>xs \\<sqsubseteq> concat\\<cdot>xs", "by (cases \"finite_list xs\")\n       (auto simp add: foldr_append_concat foldl_assoc_foldr foldl_spine_strict)"], ["proof (state)\nthis:\n  foldl\\<cdot>append\\<cdot>[]\\<cdot>xs \\<sqsubseteq> concat\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> span (not . p) ==> break p\\<close> } \\<close>"], ["", "lemma \"span\\<cdot>(neg oo p) = break\\<cdot>p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span\\<cdot>(neg oo p) = break\\<cdot>p", "by simp"], ["", "text \\<open>@{verbatim \\<open> break (not . p) ==> span p\\<close> } \\<close>"], ["", "lemma \"break\\<cdot>(neg oo p) = span\\<cdot>p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. break\\<cdot>(neg oo p) = span\\<cdot>p", "by (unfold break.simps) (subst assoc_oo, simp)"], ["", "(*  concatMap (++ \"\\n\") ==> unlines *)"], ["", "text \\<open>@{verbatim \\<open> or (map p x) ==> any p x\\<close> } \\<close>"], ["", "lemma \"the_or\\<cdot>(map\\<cdot>p\\<cdot>x) = any\\<cdot>p\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_or\\<cdot>(map\\<cdot>p\\<cdot>x) = any\\<cdot>p\\<cdot>x", "by simp"], ["", "text \\<open>@{verbatim \\<open> and (map p x) ==> all p x\\<close> } \\<close>"], ["", "lemma \"the_and\\<cdot>(map\\<cdot>p\\<cdot>x) = all\\<cdot>p\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_and\\<cdot>(map\\<cdot>p\\<cdot>x) = all\\<cdot>p\\<cdot>x", "by simp"], ["", "text \\<open>@{verbatim \\<open> zipWith (,) ==> zip\\<close> } \\<close>"], ["", "lemma \"zipWith\\<cdot>\\<langle>,\\<rangle> = zip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zipWith\\<cdot>\\<langle>,\\<rangle> = zip", "by (simp add: zip_def)"], ["", "text \\<open>@{verbatim \\<open> zipWith3 (,,) ==> zip3\\<close> } \\<close>"], ["", "lemma \"zipWith3\\<cdot>\\<langle>,,\\<rangle> = zip3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zipWith3\\<cdot>\\<langle>,,\\<rangle> = zip3", "by (simp add: zip3_def)"], ["", "text \\<open>@{verbatim \\<open> length x == 0 ==> null x where note = \"increases laziness\"\\<close> } \\<close>"], ["", "lemma \"eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x", "proof (cases x)"], ["proof (state)\ngoal (3 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x\n 2. x = [] \\<Longrightarrow>\n    eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x\n 3. \\<And>a list.\n       x = a : list \\<Longrightarrow>\n       eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x", "case (Cons y ys)"], ["proof (state)\nthis:\n  x = y : ys\n\ngoal (3 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x\n 2. x = [] \\<Longrightarrow>\n    eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x\n 3. \\<And>a list.\n       x = a : list \\<Longrightarrow>\n       eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x", "then"], ["proof (chain)\npicking this:\n  x = y : ys", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y : ys\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x", "by (cases \"length\\<cdot>ys\")\n       (auto dest: length_ge_0 simp: zero_Integer_def one_Integer_def)"], ["proof (state)\nthis:\n  eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x\n\ngoal (2 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow>\n    eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x\n 2. x = [] \\<Longrightarrow>\n    eq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> null\\<cdot>x", "qed simp+"], ["", "text \\<open>@{verbatim \\<open> length x /= 0 ==> not (null x)\\<close> } \\<close>"], ["", "lemma \"neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> neg\\<cdot>(null\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq>\n    neg\\<cdot>(null\\<cdot>x)", "proof (cases x)"], ["proof (state)\ngoal (3 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow>\n    neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq>\n    neg\\<cdot>(null\\<cdot>x)\n 2. x = [] \\<Longrightarrow>\n    neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq>\n    neg\\<cdot>(null\\<cdot>x)\n 3. \\<And>a list.\n       x = a : list \\<Longrightarrow>\n       neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq>\n       neg\\<cdot>(null\\<cdot>x)", "case (Cons y ys)"], ["proof (state)\nthis:\n  x = y : ys\n\ngoal (3 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow>\n    neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq>\n    neg\\<cdot>(null\\<cdot>x)\n 2. x = [] \\<Longrightarrow>\n    neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq>\n    neg\\<cdot>(null\\<cdot>x)\n 3. \\<And>a list.\n       x = a : list \\<Longrightarrow>\n       neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq>\n       neg\\<cdot>(null\\<cdot>x)", "then"], ["proof (chain)\npicking this:\n  x = y : ys", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y : ys\n\ngoal (1 subgoal):\n 1. neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq>\n    neg\\<cdot>(null\\<cdot>x)", "by (cases \"length\\<cdot>ys\")\n       (auto dest: length_ge_0 simp: zero_Integer_def one_Integer_def)"], ["proof (state)\nthis:\n  neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq> neg\\<cdot>(null\\<cdot>x)\n\ngoal (2 subgoals):\n 1. x = \\<bottom> \\<Longrightarrow>\n    neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq>\n    neg\\<cdot>(null\\<cdot>x)\n 2. x = [] \\<Longrightarrow>\n    neq\\<cdot>(length\\<cdot>x)\\<cdot>0 \\<sqsubseteq>\n    neg\\<cdot>(null\\<cdot>x)", "qed simp+"], ["", "(*  (\\x -> [x]) ==> (:[]) *)"], ["", "text \\<open>@{verbatim \\<open> map (uncurry f) (zip x y) ==> zipWith f x y\\<close> } \\<close>"], ["", "lemma \"map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>x\\<cdot>y) = zipWith\\<cdot>f\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>x\\<cdot>y) =\n    zipWith\\<cdot>f\\<cdot>x\\<cdot>y", "proof (induct x arbitrary: y)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>a\\<cdot>x) =\n               zipWith\\<cdot>f\\<cdot>a\\<cdot>x)\n 2. \\<And>y.\n       map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>\\<bottom>\\<cdot>y) =\n       zipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>y\n 3. \\<And>y.\n       map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>[]\\<cdot>y) =\n       zipWith\\<cdot>f\\<cdot>[]\\<cdot>y\n 4. \\<And>a x y.\n       (\\<And>y.\n           map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>x\\<cdot>y) =\n           zipWith\\<cdot>f\\<cdot>x\\<cdot>y) \\<Longrightarrow>\n       map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>(a : x)\\<cdot>y) =\n       zipWith\\<cdot>f\\<cdot>(a : x)\\<cdot>y", "case (Cons x xs y)"], ["proof (state)\nthis:\n  map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>xs\\<cdot>?y) =\n  zipWith\\<cdot>f\\<cdot>xs\\<cdot>?y\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>a\\<cdot>x) =\n               zipWith\\<cdot>f\\<cdot>a\\<cdot>x)\n 2. \\<And>y.\n       map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>\\<bottom>\\<cdot>y) =\n       zipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>y\n 3. \\<And>y.\n       map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>[]\\<cdot>y) =\n       zipWith\\<cdot>f\\<cdot>[]\\<cdot>y\n 4. \\<And>a x y.\n       (\\<And>y.\n           map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>x\\<cdot>y) =\n           zipWith\\<cdot>f\\<cdot>x\\<cdot>y) \\<Longrightarrow>\n       map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>(a : x)\\<cdot>y) =\n       zipWith\\<cdot>f\\<cdot>(a : x)\\<cdot>y", "then"], ["proof (chain)\npicking this:\n  map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>xs\\<cdot>?y) =\n  zipWith\\<cdot>f\\<cdot>xs\\<cdot>?y", "show ?case"], ["proof (prove)\nusing this:\n  map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>xs\\<cdot>?y) =\n  zipWith\\<cdot>f\\<cdot>xs\\<cdot>?y\n\ngoal (1 subgoal):\n 1. map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>(x : xs)\\<cdot>y) =\n    zipWith\\<cdot>f\\<cdot>(x : xs)\\<cdot>y", "by (cases y) auto"], ["proof (state)\nthis:\n  map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>(x : xs)\\<cdot>y) =\n  zipWith\\<cdot>f\\<cdot>(x : xs)\\<cdot>y\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>a\\<cdot>x) =\n               zipWith\\<cdot>f\\<cdot>a\\<cdot>x)\n 2. \\<And>y.\n       map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>\\<bottom>\\<cdot>y) =\n       zipWith\\<cdot>f\\<cdot>\\<bottom>\\<cdot>y\n 3. \\<And>y.\n       map\\<cdot>(uncurry\\<cdot>f)\\<cdot>(zip\\<cdot>[]\\<cdot>y) =\n       zipWith\\<cdot>f\\<cdot>[]\\<cdot>y", "qed auto"], ["", "text \\<open>@{verbatim \\<open> map f (zip x y) ==> zipWith (curry f) x y where _ = isVar f\\<close> } \\<close>"], ["", "lemma \"map\\<cdot>f\\<cdot>(zip\\<cdot>x\\<cdot>y) = zipWith\\<cdot>(curry\\<cdot>f)\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>f\\<cdot>(zip\\<cdot>x\\<cdot>y) =\n    zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>x\\<cdot>y", "proof(induct x arbitrary: y)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               map\\<cdot>f\\<cdot>(zip\\<cdot>a\\<cdot>x) =\n               zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>a\\<cdot>x)\n 2. \\<And>y.\n       map\\<cdot>f\\<cdot>(zip\\<cdot>\\<bottom>\\<cdot>y) =\n       zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>\\<bottom>\\<cdot>y\n 3. \\<And>y.\n       map\\<cdot>f\\<cdot>(zip\\<cdot>[]\\<cdot>y) =\n       zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>[]\\<cdot>y\n 4. \\<And>a x y.\n       (\\<And>y.\n           map\\<cdot>f\\<cdot>(zip\\<cdot>x\\<cdot>y) =\n           zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>x\\<cdot>\n           y) \\<Longrightarrow>\n       map\\<cdot>f\\<cdot>(zip\\<cdot>(a : x)\\<cdot>y) =\n       zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>(a : x)\\<cdot>y", "case (Cons x xs y)"], ["proof (state)\nthis:\n  map\\<cdot>f\\<cdot>(zip\\<cdot>xs\\<cdot>?y) =\n  zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>xs\\<cdot>?y\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               map\\<cdot>f\\<cdot>(zip\\<cdot>a\\<cdot>x) =\n               zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>a\\<cdot>x)\n 2. \\<And>y.\n       map\\<cdot>f\\<cdot>(zip\\<cdot>\\<bottom>\\<cdot>y) =\n       zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>\\<bottom>\\<cdot>y\n 3. \\<And>y.\n       map\\<cdot>f\\<cdot>(zip\\<cdot>[]\\<cdot>y) =\n       zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>[]\\<cdot>y\n 4. \\<And>a x y.\n       (\\<And>y.\n           map\\<cdot>f\\<cdot>(zip\\<cdot>x\\<cdot>y) =\n           zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>x\\<cdot>\n           y) \\<Longrightarrow>\n       map\\<cdot>f\\<cdot>(zip\\<cdot>(a : x)\\<cdot>y) =\n       zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>(a : x)\\<cdot>y", "then"], ["proof (chain)\npicking this:\n  map\\<cdot>f\\<cdot>(zip\\<cdot>xs\\<cdot>?y) =\n  zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>xs\\<cdot>?y", "show ?case"], ["proof (prove)\nusing this:\n  map\\<cdot>f\\<cdot>(zip\\<cdot>xs\\<cdot>?y) =\n  zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>xs\\<cdot>?y\n\ngoal (1 subgoal):\n 1. map\\<cdot>f\\<cdot>(zip\\<cdot>(x : xs)\\<cdot>y) =\n    zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>(x : xs)\\<cdot>y", "by (cases y) auto"], ["proof (state)\nthis:\n  map\\<cdot>f\\<cdot>(zip\\<cdot>(x : xs)\\<cdot>y) =\n  zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>(x : xs)\\<cdot>y\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            \\<forall>x.\n               map\\<cdot>f\\<cdot>(zip\\<cdot>a\\<cdot>x) =\n               zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>a\\<cdot>x)\n 2. \\<And>y.\n       map\\<cdot>f\\<cdot>(zip\\<cdot>\\<bottom>\\<cdot>y) =\n       zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>\\<bottom>\\<cdot>y\n 3. \\<And>y.\n       map\\<cdot>f\\<cdot>(zip\\<cdot>[]\\<cdot>y) =\n       zipWith\\<cdot>(Data_Tuple.curry\\<cdot>f)\\<cdot>[]\\<cdot>y", "qed auto"], ["", "text \\<open>@{verbatim \\<open> not (elem x y) ==> notElem x y\\<close> } \\<close>"], ["", "lemma \"neg\\<cdot>(elem\\<cdot>x\\<cdot>y) = notElem\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg\\<cdot>(elem\\<cdot>x\\<cdot>y) = notElem\\<cdot>x\\<cdot>y", "by (induct y) auto"], ["", "text \\<open>@{verbatim \\<open> foldr f z (map g x) ==> foldr (f . g) z x\\<close> } \\<close>"], ["", "lemma \"foldr\\<cdot>f\\<cdot>z\\<cdot>(map\\<cdot>g\\<cdot>x) = foldr\\<cdot>(f oo g)\\<cdot>z\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>f\\<cdot>z\\<cdot>(map\\<cdot>g\\<cdot>x) =\n    foldr\\<cdot>(f oo g)\\<cdot>z\\<cdot>x", "by (induct x) auto"], ["", "(*  x ++ concatMap (' ':) y ==> unwords (x:y) *)\n(*  intercalate \" \" ==> unwords *)\n(*  concat (intersperse x y) ==> intercalate x y where _ = notEq x \" \" *)\n(*  concat (intersperse \" \" x) ==> unwords x *)"], ["", "text \\<open>@{verbatim \\<open> null (filter f x) ==> not (any f x)\\<close> } \\<close>"], ["", "lemma \"null\\<cdot>(filter\\<cdot>f\\<cdot>x) = neg\\<cdot>(any\\<cdot>f\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null\\<cdot>(filter\\<cdot>f\\<cdot>x) = neg\\<cdot>(any\\<cdot>f\\<cdot>x)", "proof (induct x)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            null\\<cdot>(filter\\<cdot>f\\<cdot>a) =\n            neg\\<cdot>(any\\<cdot>f\\<cdot>a))\n 2. null\\<cdot>(filter\\<cdot>f\\<cdot>\\<bottom>) =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>\\<bottom>)\n 3. null\\<cdot>(filter\\<cdot>f\\<cdot>[]) = neg\\<cdot>(any\\<cdot>f\\<cdot>[])\n 4. \\<And>a x.\n       null\\<cdot>(filter\\<cdot>f\\<cdot>x) =\n       neg\\<cdot>(any\\<cdot>f\\<cdot>x) \\<Longrightarrow>\n       null\\<cdot>(filter\\<cdot>f\\<cdot>(a : x)) =\n       neg\\<cdot>(any\\<cdot>f\\<cdot>(a : x))", "case (Cons x xs)"], ["proof (state)\nthis:\n  null\\<cdot>(filter\\<cdot>f\\<cdot>xs) = neg\\<cdot>(any\\<cdot>f\\<cdot>xs)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            null\\<cdot>(filter\\<cdot>f\\<cdot>a) =\n            neg\\<cdot>(any\\<cdot>f\\<cdot>a))\n 2. null\\<cdot>(filter\\<cdot>f\\<cdot>\\<bottom>) =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>\\<bottom>)\n 3. null\\<cdot>(filter\\<cdot>f\\<cdot>[]) = neg\\<cdot>(any\\<cdot>f\\<cdot>[])\n 4. \\<And>a x.\n       null\\<cdot>(filter\\<cdot>f\\<cdot>x) =\n       neg\\<cdot>(any\\<cdot>f\\<cdot>x) \\<Longrightarrow>\n       null\\<cdot>(filter\\<cdot>f\\<cdot>(a : x)) =\n       neg\\<cdot>(any\\<cdot>f\\<cdot>(a : x))", "then"], ["proof (chain)\npicking this:\n  null\\<cdot>(filter\\<cdot>f\\<cdot>xs) = neg\\<cdot>(any\\<cdot>f\\<cdot>xs)", "show ?case"], ["proof (prove)\nusing this:\n  null\\<cdot>(filter\\<cdot>f\\<cdot>xs) = neg\\<cdot>(any\\<cdot>f\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. null\\<cdot>(filter\\<cdot>f\\<cdot>(x : xs)) =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>(x : xs))", "by (cases \"f\\<cdot>x\") auto"], ["proof (state)\nthis:\n  null\\<cdot>(filter\\<cdot>f\\<cdot>(x : xs)) =\n  neg\\<cdot>(any\\<cdot>f\\<cdot>(x : xs))\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            null\\<cdot>(filter\\<cdot>f\\<cdot>a) =\n            neg\\<cdot>(any\\<cdot>f\\<cdot>a))\n 2. null\\<cdot>(filter\\<cdot>f\\<cdot>\\<bottom>) =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>\\<bottom>)\n 3. null\\<cdot>(filter\\<cdot>f\\<cdot>[]) = neg\\<cdot>(any\\<cdot>f\\<cdot>[])", "qed auto"], ["", "text \\<open>@{verbatim \\<open> filter f x == [] ==> not (any f x)\\<close> } \\<close>"], ["", "lemma \"eq\\<cdot>(filter\\<cdot>f\\<cdot>x)\\<cdot>[] = neg\\<cdot>(any\\<cdot>f\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>(filter\\<cdot>f\\<cdot>x)\\<cdot>[] =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>x)", "proof (induct x)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            eq\\<cdot>(filter\\<cdot>f\\<cdot>a)\\<cdot>[] =\n            neg\\<cdot>(any\\<cdot>f\\<cdot>a))\n 2. eq\\<cdot>(filter\\<cdot>f\\<cdot>\\<bottom>)\\<cdot>[] =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>\\<bottom>)\n 3. eq\\<cdot>(filter\\<cdot>f\\<cdot>[])\\<cdot>[] =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>[])\n 4. \\<And>a x.\n       eq\\<cdot>(filter\\<cdot>f\\<cdot>x)\\<cdot>[] =\n       neg\\<cdot>(any\\<cdot>f\\<cdot>x) \\<Longrightarrow>\n       eq\\<cdot>(filter\\<cdot>f\\<cdot>(a : x))\\<cdot>[] =\n       neg\\<cdot>(any\\<cdot>f\\<cdot>(a : x))", "case (Cons x xs)"], ["proof (state)\nthis:\n  eq\\<cdot>(filter\\<cdot>f\\<cdot>xs)\\<cdot>[] =\n  neg\\<cdot>(any\\<cdot>f\\<cdot>xs)\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            eq\\<cdot>(filter\\<cdot>f\\<cdot>a)\\<cdot>[] =\n            neg\\<cdot>(any\\<cdot>f\\<cdot>a))\n 2. eq\\<cdot>(filter\\<cdot>f\\<cdot>\\<bottom>)\\<cdot>[] =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>\\<bottom>)\n 3. eq\\<cdot>(filter\\<cdot>f\\<cdot>[])\\<cdot>[] =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>[])\n 4. \\<And>a x.\n       eq\\<cdot>(filter\\<cdot>f\\<cdot>x)\\<cdot>[] =\n       neg\\<cdot>(any\\<cdot>f\\<cdot>x) \\<Longrightarrow>\n       eq\\<cdot>(filter\\<cdot>f\\<cdot>(a : x))\\<cdot>[] =\n       neg\\<cdot>(any\\<cdot>f\\<cdot>(a : x))", "then"], ["proof (chain)\npicking this:\n  eq\\<cdot>(filter\\<cdot>f\\<cdot>xs)\\<cdot>[] =\n  neg\\<cdot>(any\\<cdot>f\\<cdot>xs)", "show ?case"], ["proof (prove)\nusing this:\n  eq\\<cdot>(filter\\<cdot>f\\<cdot>xs)\\<cdot>[] =\n  neg\\<cdot>(any\\<cdot>f\\<cdot>xs)\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(filter\\<cdot>f\\<cdot>(x : xs))\\<cdot>[] =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>(x : xs))", "by (cases \"f\\<cdot>x\") auto"], ["proof (state)\nthis:\n  eq\\<cdot>(filter\\<cdot>f\\<cdot>(x : xs))\\<cdot>[] =\n  neg\\<cdot>(any\\<cdot>f\\<cdot>(x : xs))\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            eq\\<cdot>(filter\\<cdot>f\\<cdot>a)\\<cdot>[] =\n            neg\\<cdot>(any\\<cdot>f\\<cdot>a))\n 2. eq\\<cdot>(filter\\<cdot>f\\<cdot>\\<bottom>)\\<cdot>[] =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>\\<bottom>)\n 3. eq\\<cdot>(filter\\<cdot>f\\<cdot>[])\\<cdot>[] =\n    neg\\<cdot>(any\\<cdot>f\\<cdot>[])", "qed auto"], ["", "text \\<open>@{verbatim \\<open> filter f x /= [] ==> any f x\\<close> } \\<close>"], ["", "lemma \"neq\\<cdot>(filter\\<cdot>f\\<cdot>x)\\<cdot>[] = any\\<cdot>f\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neq\\<cdot>(filter\\<cdot>f\\<cdot>x)\\<cdot>[] = any\\<cdot>f\\<cdot>x", "proof (induct x)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            neq\\<cdot>(filter\\<cdot>f\\<cdot>a)\\<cdot>[] =\n            any\\<cdot>f\\<cdot>a)\n 2. neq\\<cdot>(filter\\<cdot>f\\<cdot>\\<bottom>)\\<cdot>[] =\n    any\\<cdot>f\\<cdot>\\<bottom>\n 3. neq\\<cdot>(filter\\<cdot>f\\<cdot>[])\\<cdot>[] = any\\<cdot>f\\<cdot>[]\n 4. \\<And>a x.\n       neq\\<cdot>(filter\\<cdot>f\\<cdot>x)\\<cdot>[] =\n       any\\<cdot>f\\<cdot>x \\<Longrightarrow>\n       neq\\<cdot>(filter\\<cdot>f\\<cdot>(a : x))\\<cdot>[] =\n       any\\<cdot>f\\<cdot>(a : x)", "case (Cons x xs)"], ["proof (state)\nthis:\n  neq\\<cdot>(filter\\<cdot>f\\<cdot>xs)\\<cdot>[] = any\\<cdot>f\\<cdot>xs\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            neq\\<cdot>(filter\\<cdot>f\\<cdot>a)\\<cdot>[] =\n            any\\<cdot>f\\<cdot>a)\n 2. neq\\<cdot>(filter\\<cdot>f\\<cdot>\\<bottom>)\\<cdot>[] =\n    any\\<cdot>f\\<cdot>\\<bottom>\n 3. neq\\<cdot>(filter\\<cdot>f\\<cdot>[])\\<cdot>[] = any\\<cdot>f\\<cdot>[]\n 4. \\<And>a x.\n       neq\\<cdot>(filter\\<cdot>f\\<cdot>x)\\<cdot>[] =\n       any\\<cdot>f\\<cdot>x \\<Longrightarrow>\n       neq\\<cdot>(filter\\<cdot>f\\<cdot>(a : x))\\<cdot>[] =\n       any\\<cdot>f\\<cdot>(a : x)", "then"], ["proof (chain)\npicking this:\n  neq\\<cdot>(filter\\<cdot>f\\<cdot>xs)\\<cdot>[] = any\\<cdot>f\\<cdot>xs", "show ?case"], ["proof (prove)\nusing this:\n  neq\\<cdot>(filter\\<cdot>f\\<cdot>xs)\\<cdot>[] = any\\<cdot>f\\<cdot>xs\n\ngoal (1 subgoal):\n 1. neq\\<cdot>(filter\\<cdot>f\\<cdot>(x : xs))\\<cdot>[] =\n    any\\<cdot>f\\<cdot>(x : xs)", "by (cases \"f\\<cdot>x\") auto"], ["proof (state)\nthis:\n  neq\\<cdot>(filter\\<cdot>f\\<cdot>(x : xs))\\<cdot>[] =\n  any\\<cdot>f\\<cdot>(x : xs)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            neq\\<cdot>(filter\\<cdot>f\\<cdot>a)\\<cdot>[] =\n            any\\<cdot>f\\<cdot>a)\n 2. neq\\<cdot>(filter\\<cdot>f\\<cdot>\\<bottom>)\\<cdot>[] =\n    any\\<cdot>f\\<cdot>\\<bottom>\n 3. neq\\<cdot>(filter\\<cdot>f\\<cdot>[])\\<cdot>[] = any\\<cdot>f\\<cdot>[]", "qed auto"], ["", "text \\<open>@{verbatim \\<open> any (== a) ==> elem a\\<close> } \\<close>"], ["", "lemma \"any\\<cdot>(\\<Lambda> z. eq\\<cdot>z\\<cdot>a) = elem\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. any\\<cdot>(\\<Lambda> z. eq\\<cdot>z\\<cdot>a) = elem\\<cdot>a", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       any\\<cdot>(\\<Lambda> z. eq\\<cdot>z\\<cdot>a)\\<cdot>x =\n       elem\\<cdot>a\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       any\\<cdot>(\\<Lambda> z. eq\\<cdot>z\\<cdot>a)\\<cdot>x =\n       elem\\<cdot>a\\<cdot>x", "show \"any\\<cdot>(\\<Lambda> z. eq\\<cdot>z\\<cdot>a)\\<cdot>xs = elem\\<cdot>a\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. any\\<cdot>(\\<Lambda> z. eq\\<cdot>z\\<cdot>a)\\<cdot>xs =\n    elem\\<cdot>a\\<cdot>xs", "by (induct xs) auto"], ["proof (state)\nthis:\n  any\\<cdot>(\\<Lambda> z. eq\\<cdot>z\\<cdot>a)\\<cdot>xs =\n  elem\\<cdot>a\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> any ((==) a) ==> elem a\\<close> } \\<close>"], ["", "lemma \"any\\<cdot>(eq\\<cdot>(a::'a::Eq_sym)) = elem\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. any\\<cdot>(eq\\<cdot>a) = elem\\<cdot>a", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. any\\<cdot>(eq\\<cdot>a)\\<cdot>x = elem\\<cdot>a\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. any\\<cdot>(eq\\<cdot>a)\\<cdot>x = elem\\<cdot>a\\<cdot>x", "show \"any\\<cdot>(eq\\<cdot>a)\\<cdot>xs = elem\\<cdot>a\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. any\\<cdot>(eq\\<cdot>a)\\<cdot>xs = elem\\<cdot>a\\<cdot>xs", "by (induct xs) (auto simp: eq_sym)"], ["proof (state)\nthis:\n  any\\<cdot>(eq\\<cdot>a)\\<cdot>xs = elem\\<cdot>a\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open>any (a ==) ==> elem a\\<close> } \\<close>"], ["", "lemma \"any\\<cdot>(\\<Lambda> z. eq\\<cdot>(a::'a::Eq_sym)\\<cdot>z) = elem\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. any\\<cdot>(\\<Lambda> z. eq\\<cdot>a\\<cdot>z) = elem\\<cdot>a", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       any\\<cdot>(\\<Lambda> z. eq\\<cdot>a\\<cdot>z)\\<cdot>x =\n       elem\\<cdot>a\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       any\\<cdot>(\\<Lambda> z. eq\\<cdot>a\\<cdot>z)\\<cdot>x =\n       elem\\<cdot>a\\<cdot>x", "show \"any\\<cdot>(\\<Lambda> z. eq\\<cdot>a\\<cdot>z)\\<cdot>xs = elem\\<cdot>a\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. any\\<cdot>(\\<Lambda> z. eq\\<cdot>a\\<cdot>z)\\<cdot>xs =\n    elem\\<cdot>a\\<cdot>xs", "by (induct xs) (auto simp: eq_sym)"], ["proof (state)\nthis:\n  any\\<cdot>(\\<Lambda> z. eq\\<cdot>a\\<cdot>z)\\<cdot>xs =\n  elem\\<cdot>a\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> all (/= a) ==> notElem a\\<close> } \\<close>"], ["", "lemma \"all\\<cdot>(\\<Lambda> z. neq\\<cdot>z\\<cdot>(a::'a::Eq_sym)) = notElem\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all\\<cdot>(\\<Lambda> z. neq\\<cdot>z\\<cdot>a) = notElem\\<cdot>a", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       all\\<cdot>(\\<Lambda> z. neq\\<cdot>z\\<cdot>a)\\<cdot>x =\n       notElem\\<cdot>a\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       all\\<cdot>(\\<Lambda> z. neq\\<cdot>z\\<cdot>a)\\<cdot>x =\n       notElem\\<cdot>a\\<cdot>x", "show \"all\\<cdot>(\\<Lambda> z. neq\\<cdot>z\\<cdot>a)\\<cdot>xs = notElem\\<cdot>a\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all\\<cdot>(\\<Lambda> z. neq\\<cdot>z\\<cdot>a)\\<cdot>xs =\n    notElem\\<cdot>a\\<cdot>xs", "by (induct xs) auto"], ["proof (state)\nthis:\n  all\\<cdot>(\\<Lambda> z. neq\\<cdot>z\\<cdot>a)\\<cdot>xs =\n  notElem\\<cdot>a\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> all (a /=) ==> notElem a\\<close> } \\<close>"], ["", "lemma \"all\\<cdot>(\\<Lambda> z. neq\\<cdot>(a::'a::Eq_sym)\\<cdot>z) = notElem\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all\\<cdot>(\\<Lambda> z. neq\\<cdot>a\\<cdot>z) = notElem\\<cdot>a", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       all\\<cdot>(\\<Lambda> z. neq\\<cdot>a\\<cdot>z)\\<cdot>x =\n       notElem\\<cdot>a\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       all\\<cdot>(\\<Lambda> z. neq\\<cdot>a\\<cdot>z)\\<cdot>x =\n       notElem\\<cdot>a\\<cdot>x", "show \"all\\<cdot>(\\<Lambda> z. neq\\<cdot>a\\<cdot>z)\\<cdot>xs = notElem\\<cdot>a\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all\\<cdot>(\\<Lambda> z. neq\\<cdot>a\\<cdot>z)\\<cdot>xs =\n    notElem\\<cdot>a\\<cdot>xs", "by (induct xs) (auto simp: eq_sym)"], ["proof (state)\nthis:\n  all\\<cdot>(\\<Lambda> z. neq\\<cdot>a\\<cdot>z)\\<cdot>xs =\n  notElem\\<cdot>a\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "(* findIndex ((==) a) ==> elemIndex a *)\n(* findIndex (a ==) ==> elemIndex a *)\n(* findIndex (== a) ==> elemIndex a *)\n(* findIndices ((==) a) ==> elemIndices a *)\n(* findIndices (a ==) ==> elemIndices a *)\n(* findIndices (== a) ==> elemIndices a *)\n(* lookup b (zip l [0..]) ==> elemIndex b l *)"], ["", "subsection \\<open>Folds\\<close>"], ["", "(*  foldr  (>>) (return ()) ==> sequence_ *)"], ["", "text \\<open>@{verbatim \\<open> foldr  (&&) True ==> and\\<close> } \\<close>"], ["", "lemma \"foldr\\<cdot>trand\\<cdot>TT = the_and\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>trand\\<cdot>TT = the_and", "by (subst the_and.simps, rule)"], ["", "text \\<open>@{verbatim \\<open> foldl  (&&) True ==> and\\<close> } \\<close>"], ["", "lemma foldl_to_and:\"foldl\\<cdot>trand\\<cdot>TT \\<sqsubseteq> the_and\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>trand\\<cdot>TT \\<sqsubseteq> the_and", "proof (rule cfun_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       foldl\\<cdot>trand\\<cdot>TT\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       foldl\\<cdot>trand\\<cdot>TT\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "show \"foldl\\<cdot>trand\\<cdot>TT\\<cdot>xs \\<sqsubseteq> the_and\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>trand\\<cdot>TT\\<cdot>xs \\<sqsubseteq> the_and\\<cdot>xs", "by (cases \"finite_list xs\") (auto simp: foldl_assoc_foldr foldl_spine_strict)"], ["proof (state)\nthis:\n  foldl\\<cdot>trand\\<cdot>TT\\<cdot>xs \\<sqsubseteq> the_and\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> foldr1 (&&)  ==> and\\<close> } \\<close>"], ["", "lemma \"foldr1\\<cdot>trand \\<sqsubseteq> the_and\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr1\\<cdot>trand \\<sqsubseteq> the_and", "proof (rule cfun_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldr1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldr1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "show \"foldr1\\<cdot>trand\\<cdot>xs \\<sqsubseteq> the_and\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr1\\<cdot>trand\\<cdot>xs \\<sqsubseteq> the_and\\<cdot>xs", "proof (induct xs)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            foldr1\\<cdot>trand\\<cdot>a \\<sqsubseteq> the_and\\<cdot>a)\n 2. foldr1\\<cdot>trand\\<cdot>\\<bottom> \\<sqsubseteq> the_and\\<cdot>\\<bottom>\n 3. foldr1\\<cdot>trand\\<cdot>[] \\<sqsubseteq> the_and\\<cdot>[]\n 4. \\<And>a xs.\n       foldr1\\<cdot>trand\\<cdot>xs \\<sqsubseteq>\n       the_and\\<cdot>xs \\<Longrightarrow>\n       foldr1\\<cdot>trand\\<cdot>(a : xs) \\<sqsubseteq>\n       the_and\\<cdot>(a : xs)", "case (Cons y ys)"], ["proof (state)\nthis:\n  foldr1\\<cdot>trand\\<cdot>ys \\<sqsubseteq> the_and\\<cdot>ys\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            foldr1\\<cdot>trand\\<cdot>a \\<sqsubseteq> the_and\\<cdot>a)\n 2. foldr1\\<cdot>trand\\<cdot>\\<bottom> \\<sqsubseteq> the_and\\<cdot>\\<bottom>\n 3. foldr1\\<cdot>trand\\<cdot>[] \\<sqsubseteq> the_and\\<cdot>[]\n 4. \\<And>a xs.\n       foldr1\\<cdot>trand\\<cdot>xs \\<sqsubseteq>\n       the_and\\<cdot>xs \\<Longrightarrow>\n       foldr1\\<cdot>trand\\<cdot>(a : xs) \\<sqsubseteq>\n       the_and\\<cdot>(a : xs)", "then"], ["proof (chain)\npicking this:\n  foldr1\\<cdot>trand\\<cdot>ys \\<sqsubseteq> the_and\\<cdot>ys", "show ?case"], ["proof (prove)\nusing this:\n  foldr1\\<cdot>trand\\<cdot>ys \\<sqsubseteq> the_and\\<cdot>ys\n\ngoal (1 subgoal):\n 1. foldr1\\<cdot>trand\\<cdot>(y : ys) \\<sqsubseteq> the_and\\<cdot>(y : ys)", "by (cases ys) (auto elim: monofun_cfun_arg)"], ["proof (state)\nthis:\n  foldr1\\<cdot>trand\\<cdot>(y : ys) \\<sqsubseteq> the_and\\<cdot>(y : ys)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            foldr1\\<cdot>trand\\<cdot>a \\<sqsubseteq> the_and\\<cdot>a)\n 2. foldr1\\<cdot>trand\\<cdot>\\<bottom> \\<sqsubseteq> the_and\\<cdot>\\<bottom>\n 3. foldr1\\<cdot>trand\\<cdot>[] \\<sqsubseteq> the_and\\<cdot>[]", "qed simp+"], ["proof (state)\nthis:\n  foldr1\\<cdot>trand\\<cdot>xs \\<sqsubseteq> the_and\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> foldl1 (&&)  ==> and\\<close> } \\<close>"], ["", "lemma \"foldl1\\<cdot>trand \\<sqsubseteq> the_and\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1\\<cdot>trand \\<sqsubseteq> the_and", "proof (rule cfun_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "have \"foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq> foldl\\<cdot>trand\\<cdot>TT\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq>\n    foldl\\<cdot>trand\\<cdot>TT\\<cdot>x", "by (cases x, auto)"], ["proof (state)\nthis:\n  foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq>\n  foldl\\<cdot>trand\\<cdot>TT\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<And>x. foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "also"], ["proof (state)\nthis:\n  foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq>\n  foldl\\<cdot>trand\\<cdot>TT\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<And>x. foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "have \"... \\<sqsubseteq> the_and\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>trand\\<cdot>TT\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "by (rule monofun_cfun_fun[OF foldl_to_and])"], ["proof (state)\nthis:\n  foldl\\<cdot>trand\\<cdot>TT\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<And>x. foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "finally"], ["proof (chain)\npicking this:\n  foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "show \"foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x\""], ["proof (prove)\nusing this:\n  foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x\n\ngoal (1 subgoal):\n 1. foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x", "."], ["proof (state)\nthis:\n  foldl1\\<cdot>trand\\<cdot>x \\<sqsubseteq> the_and\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> foldr  (||) False ==> or\\<close> } \\<close>"], ["", "lemma \"foldr\\<cdot>tror\\<cdot>FF = the_or\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>tror\\<cdot>FF = the_or", "by (subst the_or.simps, rule)"], ["", "text \\<open>@{verbatim \\<open> foldl  (||) False ==> or\\<close> } \\<close>"], ["", "lemma foldl_to_or: \"foldl\\<cdot>tror\\<cdot>FF \\<sqsubseteq> the_or\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>tror\\<cdot>FF \\<sqsubseteq> the_or", "proof (rule cfun_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldl\\<cdot>tror\\<cdot>FF\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldl\\<cdot>tror\\<cdot>FF\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "show \"foldl\\<cdot>tror\\<cdot>FF\\<cdot>xs \\<sqsubseteq> the_or\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>tror\\<cdot>FF\\<cdot>xs \\<sqsubseteq> the_or\\<cdot>xs", "by (cases \"finite_list xs\") (auto simp: foldl_assoc_foldr foldl_spine_strict)"], ["proof (state)\nthis:\n  foldl\\<cdot>tror\\<cdot>FF\\<cdot>xs \\<sqsubseteq> the_or\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> foldr1 (||)  ==> or\\<close> } \\<close>"], ["", "lemma \"foldr1\\<cdot>tror \\<sqsubseteq> the_or\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr1\\<cdot>tror \\<sqsubseteq> the_or", "proof (rule cfun_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldr1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldr1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "show \"foldr1\\<cdot>tror\\<cdot>xs \\<sqsubseteq> the_or\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr1\\<cdot>tror\\<cdot>xs \\<sqsubseteq> the_or\\<cdot>xs", "proof (induct xs)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. foldr1\\<cdot>tror\\<cdot>a \\<sqsubseteq> the_or\\<cdot>a)\n 2. foldr1\\<cdot>tror\\<cdot>\\<bottom> \\<sqsubseteq> the_or\\<cdot>\\<bottom>\n 3. foldr1\\<cdot>tror\\<cdot>[] \\<sqsubseteq> the_or\\<cdot>[]\n 4. \\<And>a xs.\n       foldr1\\<cdot>tror\\<cdot>xs \\<sqsubseteq>\n       the_or\\<cdot>xs \\<Longrightarrow>\n       foldr1\\<cdot>tror\\<cdot>(a : xs) \\<sqsubseteq> the_or\\<cdot>(a : xs)", "case (Cons y ys)"], ["proof (state)\nthis:\n  foldr1\\<cdot>tror\\<cdot>ys \\<sqsubseteq> the_or\\<cdot>ys\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a. foldr1\\<cdot>tror\\<cdot>a \\<sqsubseteq> the_or\\<cdot>a)\n 2. foldr1\\<cdot>tror\\<cdot>\\<bottom> \\<sqsubseteq> the_or\\<cdot>\\<bottom>\n 3. foldr1\\<cdot>tror\\<cdot>[] \\<sqsubseteq> the_or\\<cdot>[]\n 4. \\<And>a xs.\n       foldr1\\<cdot>tror\\<cdot>xs \\<sqsubseteq>\n       the_or\\<cdot>xs \\<Longrightarrow>\n       foldr1\\<cdot>tror\\<cdot>(a : xs) \\<sqsubseteq> the_or\\<cdot>(a : xs)", "then"], ["proof (chain)\npicking this:\n  foldr1\\<cdot>tror\\<cdot>ys \\<sqsubseteq> the_or\\<cdot>ys", "show ?case"], ["proof (prove)\nusing this:\n  foldr1\\<cdot>tror\\<cdot>ys \\<sqsubseteq> the_or\\<cdot>ys\n\ngoal (1 subgoal):\n 1. foldr1\\<cdot>tror\\<cdot>(y : ys) \\<sqsubseteq> the_or\\<cdot>(y : ys)", "by (cases ys) (auto elim: monofun_cfun_arg)"], ["proof (state)\nthis:\n  foldr1\\<cdot>tror\\<cdot>(y : ys) \\<sqsubseteq> the_or\\<cdot>(y : ys)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a. foldr1\\<cdot>tror\\<cdot>a \\<sqsubseteq> the_or\\<cdot>a)\n 2. foldr1\\<cdot>tror\\<cdot>\\<bottom> \\<sqsubseteq> the_or\\<cdot>\\<bottom>\n 3. foldr1\\<cdot>tror\\<cdot>[] \\<sqsubseteq> the_or\\<cdot>[]", "qed simp+"], ["proof (state)\nthis:\n  foldr1\\<cdot>tror\\<cdot>xs \\<sqsubseteq> the_or\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> foldl1 (||)  ==> or\\<close> } \\<close>"], ["", "lemma \"foldl1\\<cdot>tror \\<sqsubseteq> the_or\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1\\<cdot>tror \\<sqsubseteq> the_or", "proof(rule cfun_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "have \"foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> foldl\\<cdot>tror\\<cdot>FF\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq>\n    foldl\\<cdot>tror\\<cdot>FF\\<cdot>x", "by (cases x, auto)"], ["proof (state)\nthis:\n  foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> foldl\\<cdot>tror\\<cdot>FF\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<And>x. foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "also"], ["proof (state)\nthis:\n  foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> foldl\\<cdot>tror\\<cdot>FF\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<And>x. foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "have \"... \\<sqsubseteq> the_or\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>tror\\<cdot>FF\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "by (rule monofun_cfun_fun[OF foldl_to_or])"], ["proof (state)\nthis:\n  foldl\\<cdot>tror\\<cdot>FF\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<And>x. foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "finally"], ["proof (chain)\npicking this:\n  foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "show \"foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x\""], ["proof (prove)\nusing this:\n  foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x\n\ngoal (1 subgoal):\n 1. foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x", "."], ["proof (state)\nthis:\n  foldl1\\<cdot>tror\\<cdot>x \\<sqsubseteq> the_or\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "(*  foldl  (+) 0 ==> sum *)\n(*  foldr  (+) 0 ==> sum *)\n(*  foldl1 (+)   ==> sum *)\n(*  foldr1 (+)   ==> sum *)\n(*  foldl  ( * ) 1 ==> product *)\n(*  foldr  ( * ) 1 ==> product *)\n(*  foldl1 ( * )   ==> product *)\n(*  foldr1 ( * )   ==> product *)\n(*  foldl1 max   ==> maximum *)\n(*  foldr1 max   ==> maximum *)\n(*  foldl1 min   ==> minimum *)\n(*  foldr1 min   ==> minimum *)\n(*  foldr mplus mzero ==> msum *)"], ["", "subsection \\<open>Function\\<close>"], ["", "text \\<open>@{verbatim \\<open> (\\x -> x) ==> id\\<close> } \\<close>"], ["", "lemma \"(\\<Lambda> x. x) = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x. x) = ID", "by (metis ID_def)"], ["", "text \\<open>@{verbatim \\<open> (\\x y -> x) ==> const\\<close> } \\<close>"], ["", "lemma \"(\\<Lambda> x y. x) = const\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y. x) = const", "by (intro cfun_eqI) simp"], ["", "text \\<open>@{verbatim \\<open>(\\(x,y) -> y) ==> fst where _ = notIn x y\\<close> } \\<close>"], ["", "lemma \"(\\<Lambda> \\<langle>x, y\\<rangle>. x) = fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> \\<langle>x, y\\<rangle>. x) = fst", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case x of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>x", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case x of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>x", "show \"(case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst \\<cdot> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p", "proof (cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = \\<bottom> \\<Longrightarrow>\n    (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p\n 2. \\<And>a b.\n       p = \\<langle>a, b\\<rangle> \\<Longrightarrow>\n       (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p", "case bottom"], ["proof (state)\nthis:\n  p = \\<bottom>\n\ngoal (2 subgoals):\n 1. p = \\<bottom> \\<Longrightarrow>\n    (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p\n 2. \\<And>a b.\n       p = \\<langle>a, b\\<rangle> \\<Longrightarrow>\n       (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p", "then"], ["proof (chain)\npicking this:\n  p = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  p = \\<bottom>\n\ngoal (1 subgoal):\n 1. (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p", "by simp"], ["proof (state)\nthis:\n  (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = \\<langle>a, b\\<rangle> \\<Longrightarrow>\n       (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = \\<langle>a, b\\<rangle> \\<Longrightarrow>\n       (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p", "case Tuple2"], ["proof (state)\nthis:\n  p = \\<langle>a_, b_\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = \\<langle>a, b\\<rangle> \\<Longrightarrow>\n       (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p", "then"], ["proof (chain)\npicking this:\n  p = \\<langle>a_, b_\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  p = \\<langle>a_, b_\\<rangle>\n\ngoal (1 subgoal):\n 1. (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p", "by simp"], ["proof (state)\nthis:\n  (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> x) = fst\\<cdot>p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open>(\\(x,y) -> y) ==> snd where _ = notIn x y\\<close> } \\<close>"], ["", "lemma \"(\\<Lambda> \\<langle>x, y\\<rangle>. y) = snd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> \\<langle>x, y\\<rangle>. y) = snd", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case x of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>x", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case x of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>x", "show \"(case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd \\<cdot> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p", "proof (cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = \\<bottom> \\<Longrightarrow>\n    (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p\n 2. \\<And>a b.\n       p = \\<langle>a, b\\<rangle> \\<Longrightarrow>\n       (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p", "case bottom"], ["proof (state)\nthis:\n  p = \\<bottom>\n\ngoal (2 subgoals):\n 1. p = \\<bottom> \\<Longrightarrow>\n    (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p\n 2. \\<And>a b.\n       p = \\<langle>a, b\\<rangle> \\<Longrightarrow>\n       (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p", "then"], ["proof (chain)\npicking this:\n  p = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  p = \\<bottom>\n\ngoal (1 subgoal):\n 1. (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p", "by simp"], ["proof (state)\nthis:\n  (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = \\<langle>a, b\\<rangle> \\<Longrightarrow>\n       (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = \\<langle>a, b\\<rangle> \\<Longrightarrow>\n       (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p", "case Tuple2"], ["proof (state)\nthis:\n  p = \\<langle>a_, b_\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = \\<langle>a, b\\<rangle> \\<Longrightarrow>\n       (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p", "then"], ["proof (chain)\npicking this:\n  p = \\<langle>a_, b_\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  p = \\<langle>a_, b_\\<rangle>\n\ngoal (1 subgoal):\n 1. (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p", "by simp"], ["proof (state)\nthis:\n  (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case p of \\<langle>x, y\\<rangle> \\<Rightarrow> y) = snd\\<cdot>p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open> (\\x y-> f (x,y)) ==> curry f where _ = notIn [x,y] f\\<close> } \\<close>"], ["", "lemma \"(\\<Lambda> x y. f\\<cdot>\\<langle>x, y\\<rangle>) = curry\\<cdot>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x y. f\\<cdot>\\<langle>x, y\\<rangle>) =\n    Data_Tuple.curry\\<cdot>f", "by (auto intro!: cfun_eqI)"], ["", "text \\<open>@{verbatim \\<open> (\\(x,y) -> f x y) ==> uncurry f where _ = notIn [x,y] f\\<close> } \\<close>"], ["", "lemma \"(\\<Lambda> \\<langle>x, y\\<rangle>. f\\<cdot>x\\<cdot>y) \\<sqsubseteq> uncurry\\<cdot>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> \\<langle>x, y\\<rangle>. f\\<cdot>x\\<cdot>y) \\<sqsubseteq>\n    uncurry\\<cdot>f", "by (rule cfun_belowI, rename_tac x, case_tac x, auto)"], ["", "(*  (($) . f) ==> f *)\n(*  (f $) ==> f *)"], ["", "text \\<open>@{verbatim \\<open> (\\x -> y) ==> const y where _ = isAtom y && notIn x y\\<close> } \\<close>"], ["", "lemma \"(\\<Lambda> x. y) = const\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x. y) = const\\<cdot>y", "by (intro cfun_eqI) simp"], ["", "(*  flip f x y ==> f y x where _ = isApp original *)"], ["", "lemma \"flip\\<cdot>f\\<cdot>x\\<cdot>y = f\\<cdot>y\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip\\<cdot>f\\<cdot>x\\<cdot>y = f\\<cdot>y\\<cdot>x", "by simp"], ["", "(*  (\\a b -> o (f a) (f b)) ==> o `Data.Function.on` f *)\n(* -- CHAR *)\n(*  a >= 'a' && a <= 'z' ==> isAsciiLower a *)\n(*  a >= 'A' && a <= 'Z' ==> isAsciiUpper a *)\n(*  a >= '0' && a <= '9' ==> isDigit a *)\n(*  a >= '0' && a <= '7' ==> isOctDigit a *)\n(*  not (isControl a) ==> isPrint a *)\n(*  isLower a || isUpper a ==> isAlpha a *)\n(*  isAlpha a || isDigit a ==> isAlphaNum a *)"], ["", "subsection \\<open>Bool\\<close>"], ["", "text \\<open>@{verbatim \\<open> a == True ==> a\\<close> } \\<close>"], ["", "lemma eq_true:\"eq\\<cdot>x\\<cdot>TT = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>TT = x", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open> a == False ==> not a\\<close> } \\<close>"], ["", "lemma eq_false:\"eq\\<cdot>x\\<cdot>FF = neg\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>FF = neg\\<cdot>x", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open> (if a then x else x) ==> x where note = \"reduces strictness\"\\<close> } \\<close>"], ["", "lemma if_equal:\"(If a then x else x) \\<sqsubseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If a then x else x \\<sqsubseteq> x", "by (cases a, auto)"], ["", "text \\<open>@{verbatim \\<open> (if a then True else False) ==> a\\<close> } \\<close>"], ["", "lemma \"(If a then TT else FF) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If a then TT else FF = a", "by (cases a, auto)"], ["", "text \\<open>@{verbatim \\<open> (if a then False else True) ==> not a\\<close> } \\<close>"], ["", "lemma \"(If a then FF else TT) = neg\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If a then FF else TT = neg\\<cdot>a", "by (cases a, auto)"], ["", "text \\<open>@{verbatim \\<open> (if a then t else (if b then t else f)) ==> if a || b then t else f\\<close> } \\<close>"], ["", "lemma \"(If a then t else (If b then t else f)) = (If a orelse b then t else f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If a then t else If b then t else f = If a orelse b then t else f", "by (cases a, auto)"], ["", "text \\<open>@{verbatim \\<open> (if a then (if b then t else f) else f) ==> if a && b then t else f\\<close> } \\<close>"], ["", "lemma \"(If a then (If b then t else f) else f) = (If a andalso b then t else f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If a then If b then t else f else f = If a andalso b then t else f", "by (cases a, auto)"], ["", "text \\<open>@{verbatim \\<open> (if x then True else y) ==> x || y where _ = notEq y False\\<close> } \\<close>"], ["", "lemma \"(If x then TT else y) = (x orelse y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If x then TT else y = (x orelse y)", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open> (if x then y else False) ==> x && y where _ = notEq y True\\<close> } \\<close>"], ["", "lemma \"(If x then y else FF) = (x andalso y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If x then y else FF = (x andalso y)", "by (cases x, auto)"], ["", "(*  case a of {True -> t; False -> f} ==> if a then t else f *)\n(*  case a of {False -> f; True -> t} ==> if a then t else f *)\n(*  case a of {True -> t; _ -> f} ==> if a then t else f *)\n(*  case a of {False -> f; _ -> t} ==> if a then t else f *)"], ["", "text \\<open>@{verbatim \\<open> (if c then (True, x) else (False, x)) ==> (c, x) where note = \"reduces strictness\"\\<close> } \\<close>"], ["", "lemma \"(If c then \\<langle>TT, x\\<rangle> else \\<langle>FF, x\\<rangle>) \\<sqsubseteq> \\<langle>c, x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If c then \\<langle>TT, x\\<rangle>\n    else \\<langle>FF, x\\<rangle> \\<sqsubseteq>\n    \\<langle>c, x\\<rangle>", "by (cases c, auto)"], ["", "text \\<open>@{verbatim \\<open> (if c then (False, x) else (True, x)) ==> (not c, x) where note = \"reduces strictness\"\\<close> } \\<close>"], ["", "lemma \"(If c then \\<langle>FF, x\\<rangle> else \\<langle>TT, x\\<rangle>) \\<sqsubseteq> \\<langle>neg\\<cdot>c, x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If c then \\<langle>FF, x\\<rangle>\n    else \\<langle>TT, x\\<rangle> \\<sqsubseteq>\n    \\<langle>neg\\<cdot>c, x\\<rangle>", "by (cases c, auto)"], ["", "text \\<open>@{verbatim \\<open> or [x,y]  ==> x || y\\<close> } \\<close>"], ["", "lemma \"the_or\\<cdot>[x, y] = (x orelse y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_or\\<cdot>[x, y] = (x orelse y)", "by (fixrec_simp)"], ["", "text \\<open>@{verbatim \\<open> or [x,y,z]  ==> x || y || z\\<close> } \\<close>"], ["", "lemma \"the_or\\<cdot>[x, y, z] = (x orelse y orelse z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_or\\<cdot>[x, y, z] = (x orelse y orelse z)", "by (fixrec_simp)"], ["", "text \\<open>@{verbatim \\<open> and [x,y]  ==> x && y\\<close> } \\<close>"], ["", "lemma \"the_and\\<cdot>[x, y] = (x andalso y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_and\\<cdot>[x, y] = (x andalso y)", "by (fixrec_simp)"], ["", "text \\<open>@{verbatim \\<open> and [x,y,z]  ==> x && y && z\\<close> } \\<close>"], ["", "lemma \"the_and\\<cdot>[x, y, z] = (x andalso y andalso z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_and\\<cdot>[x, y, z] = (x andalso y andalso z)", "by (fixrec_simp)"], ["", "subsection \\<open>Arrow\\<close>"], ["", "(*  id *** g ==> second g *)\n(*  f *** id ==> first f *)\n(*  zip (map f x) (map g x) ==> map (f Control.Arrow.&&& g) x *)\n(*  (\\(x,y) -> (f x, g y)) ==> f Control.Arrow.*** g where _ = notIn [x,y] [f,g] *)\n(*  (\\x -> (f x, g x)) ==> f Control.Arrow.&&& g where _ = notIn x [f,g] *)\n(*  (\\(x,y) -> (f x,y)) ==> Control.Arrow.first f where _ = notIn [x,y] f *)\n(*  (\\(x,y) -> (x,f y)) ==> Control.Arrow.second f where _ = notIn [x,y] f *)\n(*  (f (fst x), g (snd x)) ==> (f Control.Arrow.*** g) x *)"], ["", "text \\<open>@{verbatim \\<open> (fst x, snd x) ==>  x\\<close> } \\<close>"], ["", "lemma \"x \\<sqsubseteq> \\<langle>fst\\<cdot>x, snd\\<cdot>x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> \\<langle>fst\\<cdot>x, snd\\<cdot>x\\<rangle>", "by (cases x, auto)"], ["", "(* -- FUNCTOR *)\n(*  fmap f (fmap g x) ==> fmap (f . g) x *)\n(*  fmap id ==> id *)\n(* -- MONAD *)\n(*  return a >>= f ==> f a *)\n(*  m >>= return ==> m *)\n(*  m >>= return . f ==> Control.Monad.liftM f m -- cannot be fmap, because is in Functor not Monad *)\n(*  (if x then y else return ()) ==> Control.Monad.when x $ _noParen_ y where _ = not (isAtom y) *)\n(*  (if x then y else return ()) ==> Control.Monad.when x y where _ = isAtom y *)\n(*  (if x then return () else y) ==> Control.Monad.unless x $ _noParen_ y where _ = not (isAtom y) *)\n(*  (if x then return () else y) ==> Control.Monad.unless x y where _ = isAtom y *)\n(*  sequence (map f x) ==> mapM f x *)\n(*  sequence_ (map f x) ==> mapM_ f x *)\n(*  flip mapM ==> Control.Monad.forM *)\n(*  flip mapM_ ==> Control.Monad.forM_ *)\n(*  flip forM ==> mapM *)\n(*  flip forM_ ==> mapM_ *)\n(*  when (not x) ==> unless x *)\n(*  x >>= id ==> Control.Monad.join x *)\n(*  liftM f (liftM g x) ==> liftM (f . g) x *)\n(*  a >> return () ==> void a *)\n(*  fmap (const ()) ==> void *)\n(*  flip (>=>) ==> (<=<) *)\n(*  flip (<=<) ==> (>=>) *)\n(*  (\\x -> f x >>= g) ==> f Control.Monad.>=> g where _ = notIn x [f,g] *)\n(*  (\\x -> f =<< g x) ==> f Control.Monad.<=< g where _ = notIn x [f,g] *)\n(*  a >> forever a ==> forever a *)\n(*  liftM2 id ==> ap *)\n(* -- MONAD LIST *)\n(*  liftM unzip (mapM f x) ==> Control.Monad.mapAndUnzipM f x *)\n(*  sequence (zipWith f x y) ==> Control.Monad.zipWithM f x y *)\n(*  sequence_ (zipWith f x y) ==> Control.Monad.zipWithM_ f x y *)\n(*  sequence (replicate n x) ==> Control.Monad.replicateM n x *)\n(*  sequence_ (replicate n x) ==> Control.Monad.replicateM_ n x *)\n(*  mapM f (map g x) ==> mapM (f . g) x *)\n(*  mapM_ f (map g x) ==> mapM_ (f . g) x *)\n(* -- APPLICATIVE / TRAVERSABLE *)\n(*  flip traverse ==> for *)\n(*  flip for ==> traverse *)\n(*  flip traverse_ ==> for_ *)\n(*  flip for_ ==> traverse_ *)\n(*  foldr ( *>) (pure ()) ==> sequenceA_ *)\n(*  foldr (<|>) empty ==> asum *)\n(*  liftA2 (flip ($)) ==> (<**>) *)\n(*  Just <$> a <|> pure Nothing ==> optional a *)\n(* -- LIST COMP *)\n(*  (if b then [x] else []) ==> [x | b] *)\n(*  [x | x <- y] ==> y where _ = isVar x *)\n(* -- SEQ *)"], ["", "subsection \\<open>Seq\\<close>"], ["", "text \\<open>@{verbatim \\<open> x `seq` x ==> x\\<close> } \\<close>"], ["", "lemma \"seq\\<cdot>x\\<cdot>x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq\\<cdot>x\\<cdot>x = x", "by (simp add: seq_def)"], ["", "(*  id $! x ==> x *)\n(*  x `seq` y ==> y where _ = isWHNF x *)\n(*  f $! x ==> f x where _ = isWHNF x *)\n(*  evaluate x ==> return x where _ = isWHNF x *)\n(* -- MAYBE *)\n(*  maybe x id ==> Data.Maybe.fromMaybe x *)\n(*  maybe False (const True) ==> Data.Maybe.isJust *)\n(*  maybe True (const False) ==> Data.Maybe.isNothing *)\n(*  not (isNothing x) ==> isJust x *)\n(*  not (isJust x) ==> isNothing x *)\n(*  maybe [] (:[]) ==> maybeToList *)\n(*  catMaybes (map f x) ==> mapMaybe f x *)\n(*  (case x of Nothing -> y; Just a -> a)  ==> fromMaybe y x *)\n(*  (if isNothing x then y else f (fromJust x)) ==> maybe y f x *)\n(*  (if isJust x then f (fromJust x) else y) ==> maybe y f x *)\n(*  maybe Nothing (Just . f) ==> fmap f *)\n(*  map fromJust . filter isJust  ==>  Data.Maybe.catMaybes *)\n(*  x == Nothing  ==>  isNothing x *)\n(*  Nothing == x  ==>  isNothing x *)\n(*  x /= Nothing  ==>  Data.Maybe.isJust x *)\n(*  Nothing /= x  ==>  Data.Maybe.isJust x *)\n(*  concatMap (maybeToList . f) ==> Data.Maybe.mapMaybe f *)\n(*  concatMap maybeToList ==> catMaybes *)\n(*  maybe n Just x ==> Control.Monad.mplus x n *)\n(*  (case x of Just a -> a; Nothing -> y)  ==> fromMaybe y x *)\n(*  (if isNothing x then y else fromJust x) ==> fromMaybe y x *)\n(*  (if isJust x then fromJust x else y) ==> fromMaybe y x *)\n(*  isJust x && (fromJust x == y) ==> x == Just y *)\n(*  mapMaybe f (map g x) ==> mapMaybe (f . g) x *)\n(*  fromMaybe a (fmap f x) ==> maybe a f x *)\n(*  [x | Just x <- a] ==> Data.Maybe.catMaybes a *)\n(* -- EITHER *)\n(*  [a | Left a <- a] ==> lefts a *)\n(*  [a | Right a <- a] ==> rights a *)\n(* -- INFIX *)\n(*  X.elem x y ==> x `X.elem` y where _ = not (isInfixApp original) && not (isParen result) *)\n(*  X.notElem x y ==> x `X.notElem` y where _ = not (isInfixApp original) && not (isParen result) *)\n(*  X.isInfixOf x y ==> x `X.isInfixOf` y where _ = not (isInfixApp original) && not (isParen result) *)\n(*  X.isSuffixOf x y ==> x `X.isSuffixOf` y where _ = not (isInfixApp original) && not (isParen result) *)\n(*  X.isPrefixOf x y ==> x `X.isPrefixOf` y where _ = not (isInfixApp original) && not (isParen result) *)\n(*  X.union x y ==> x `X.union` y where _ = not (isInfixApp original) && not (isParen result) *)\n(*  X.intersect x y ==> x `X.intersect` y where _ = not (isInfixApp original) && not (isParen result) *)\n(* -- MATHS *)\n(*  fromIntegral x ==> x where _ = isLitInt x *)\n(*  fromInteger x ==> x where _ = isLitInt x *)\n(*  x + negate y ==> x - y *)\n(*  0 - x ==> negate x *)\n(*  log y / log x ==> logBase x y *)\n(*  x ** 0.5 ==> sqrt x *)\n(*  sin x / cos x ==> tan x *)\n(*  sinh x / cosh x ==> tanh x *)\n(*  n `rem` 2 == 0 ==> even n *)\n(*  n `rem` 2 /= 0 ==> odd n *)\n(*  not (even x) ==> odd x *)\n(*  not (odd x) ==> even x *)\n(*  x ** 0.5 ==> sqrt x *)\n(*  x ^^ y ==> x ** y where _ = isLitInt y *)\n(*  x ^ 0 ==> 1 *)\n(*  round (x - 0.5) ==> floor x *)\n(* -- CONCURRENT *)\n(*  mapM_ (writeChan a) ==> writeList2Chan a *)\n(* -- EXCEPTION *)\n(*  Prelude.catch ==> Control.Exception.catch where note = \"Prelude.catch does not catch most exceptions\" *)\n(*  flip Control.Exception.catch ==> handle *)\n(*  flip handle ==> Control.Exception.catch *)\n(*  flip (catchJust p) ==> handleJust p *)\n(*  flip (handleJust p) ==> catchJust p *)\n(*  Control.Exception.bracket b (const a) (const t) ==> Control.Exception.bracket_ b a t *)\n(*  Control.Exception.bracket (openFile x y) hClose ==> withFile x y *)\n(*  Control.Exception.bracket (openBinaryFile x y) hClose ==> withBinaryFile x y *)\n(*  throw (ErrorCall a) ==> error a *)\n(*  a `seq` return a ==> Control.Exception.evaluate a *)\n(*  toException NonTermination ==> nonTermination *)\n(*  toException NestedAtomically ==> nestedAtomically *)\n(* -- WEAK POINTERS *)\n(*  mkWeak a a b ==> mkWeakPtr a b *)\n(*  mkWeak a (a, b) c ==> mkWeakPair a b c *)"], ["", "subsection \\<open>Evaluate\\<close>"], ["", "text \\<open>@{verbatim \\<open> True && x ==> x\\<close> } \\<close>"], ["", "lemma \"(TT andalso x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (TT andalso x) = x", "by auto"], ["", "text \\<open>@{verbatim \\<open> False && x ==> False\\<close> } \\<close>"], ["", "lemma \"(FF andalso x) = FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FF andalso x) = FF", "by auto"], ["", "text \\<open>@{verbatim \\<open> True || x ==> True\\<close> } \\<close>"], ["", "lemma \"(TT orelse x) = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (TT orelse x) = TT", "by auto"], ["", "text \\<open>@{verbatim \\<open> False || x ==> x\\<close> } \\<close>"], ["", "lemma \"(FF orelse x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FF orelse x) = x", "by auto"], ["", "text \\<open>@{verbatim \\<open> not True ==> False\\<close> } \\<close>"], ["", "lemma \"neg\\<cdot>TT = FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg\\<cdot>TT = FF", "by auto"], ["", "text \\<open>@{verbatim \\<open> not False ==> True\\<close> } \\<close>"], ["", "lemma \"neg\\<cdot>FF = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg\\<cdot>FF = TT", "by auto"], ["", "(*  Nothing >>= k ==> Nothing *)\n(*  either f g (Left x) ==> f x *)\n(*  either f g (Right y) ==> g y *)"], ["", "text \\<open>@{verbatim \\<open> fst (x,y) ==> x\\<close> } \\<close>"], ["", "lemma \"fst\\<cdot>\\<langle>x, y\\<rangle> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst\\<cdot>\\<langle>x, y\\<rangle> = x", "by auto"], ["", "text \\<open>@{verbatim \\<open> snd (x,y) ==> y\\<close> } \\<close>"], ["", "lemma \"snd\\<cdot>\\<langle>x, y\\<rangle> = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd\\<cdot>\\<langle>x, y\\<rangle> = y", "by auto"], ["", "text \\<open>@{verbatim \\<open> f (fst p) (snd p) ==> uncurry f p\\<close> } \\<close>"], ["", "lemma \"f\\<cdot>(fst\\<cdot>p)\\<cdot>(snd\\<cdot>p) = uncurry\\<cdot>f\\<cdot>p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>(fst\\<cdot>p)\\<cdot>(snd\\<cdot>p) = uncurry\\<cdot>f\\<cdot>p", "by (cases p, auto)"], ["", "text \\<open>@{verbatim \\<open> init [x] ==> []\\<close> } \\<close>"], ["", "lemma \"init\\<cdot>[x] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init\\<cdot>[x] = []", "by auto"], ["", "text \\<open>@{verbatim \\<open> null [] ==> True\\<close> } \\<close>"], ["", "lemma \"null\\<cdot>[] = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null\\<cdot>[] = TT", "by auto"], ["", "text \\<open>@{verbatim \\<open> length [] ==> 0\\<close> } \\<close>"], ["", "lemma \"length\\<cdot>[] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\\<cdot>[] = 0", "by auto"], ["", "text \\<open>@{verbatim \\<open> foldl f z [] ==> z\\<close> } \\<close>"], ["", "lemma \"foldl\\<cdot>f\\<cdot>z\\<cdot>[] = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl\\<cdot>f\\<cdot>z\\<cdot>[] = z", "by simp"], ["", "text \\<open>@{verbatim \\<open> foldr f z [] ==> z\\<close> } \\<close>"], ["", "lemma \"foldr\\<cdot>f\\<cdot>z\\<cdot>[] = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr\\<cdot>f\\<cdot>z\\<cdot>[] = z", "by auto"], ["", "text \\<open>@{verbatim \\<open> foldr1 f [x] ==> x\\<close> } \\<close>"], ["", "lemma \"foldr1\\<cdot>f\\<cdot>[x] = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr1\\<cdot>f\\<cdot>[x] = x", "by simp"], ["", "text \\<open>@{verbatim \\<open> scanr f z [] ==> [z]\\<close> } \\<close>"], ["", "lemma \"scanr\\<cdot>f\\<cdot>z\\<cdot>[] = [z]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scanr\\<cdot>f\\<cdot>z\\<cdot>[] = [z]", "by simp"], ["", "text \\<open>@{verbatim \\<open> scanr1 f [] ==> []\\<close> } \\<close>"], ["", "lemma \"scanr1\\<cdot>f\\<cdot>[] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scanr1\\<cdot>f\\<cdot>[] = []", "by simp"], ["", "text \\<open>@{verbatim \\<open> scanr1 f [x] ==> [x]\\<close> } \\<close>"], ["", "lemma \"scanr1\\<cdot>f\\<cdot>[x] = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scanr1\\<cdot>f\\<cdot>[x] = [x]", "by simp"], ["", "text \\<open>@{verbatim \\<open> take n [] ==> []\\<close> } \\<close>"], ["", "lemma \"take\\<cdot>n\\<cdot>[] \\<sqsubseteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take\\<cdot>n\\<cdot>[] \\<sqsubseteq> []", "by (cases n, auto)"], ["", "text \\<open>@{verbatim \\<open> drop n [] ==> []\\<close> } \\<close>"], ["", "lemma \"drop\\<cdot>n\\<cdot>[] \\<sqsubseteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.drop\\<cdot>n\\<cdot>[] \\<sqsubseteq> []", "by (subst drop.simps) (auto simp: if_equal)"], ["", "text \\<open>@{verbatim \\<open> takeWhile p [] ==> []\\<close> } \\<close>"], ["", "lemma \"takeWhile\\<cdot>p\\<cdot>[] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.takeWhile\\<cdot>p\\<cdot>[] = []", "by (fixrec_simp)"], ["", "text \\<open>@{verbatim \\<open> dropWhile p [] ==> []\\<close> } \\<close>"], ["", "lemma \"dropWhile\\<cdot>p\\<cdot>[] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Data_List.dropWhile\\<cdot>p\\<cdot>[] = []", "by (fixrec_simp)"], ["", "text \\<open>@{verbatim \\<open> span p [] ==> ([],[])\\<close> } \\<close>"], ["", "lemma \"span\\<cdot>p\\<cdot>[] = \\<langle>[], []\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span\\<cdot>p\\<cdot>[] = \\<langle>[], []\\<rangle>", "by (fixrec_simp)"], ["", "(*  lines \"\" ==> [] *)\n(*  unwords [] ==> \"\" *)\n(*  x - 0 ==> x *)\n(*  x * 1 ==> x *)\n(*  x / 1 ==> x *)"], ["", "text \\<open>@{verbatim \\<open> concat [a] ==> a\\<close> } \\<close>"], ["", "lemma \"concat\\<cdot>[a] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\\<cdot>[a] = a", "by auto"], ["", "text \\<open>@{verbatim \\<open> concat [] ==> []\\<close> } \\<close>"], ["", "lemma \"concat\\<cdot>[] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\\<cdot>[] = []", "by auto"], ["", "text \\<open>@{verbatim \\<open> zip [] [] ==> []\\<close> } \\<close>"], ["", "lemma \"zip\\<cdot>[]\\<cdot>[] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip\\<cdot>[]\\<cdot>[] = []", "by auto"], ["", "text \\<open>@{verbatim \\<open> id x ==> x\\<close> } \\<close>"], ["", "lemma \"ID\\<cdot>x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID\\<cdot>x = x", "by auto"], ["", "text \\<open>@{verbatim \\<open> const x y ==> x\\<close> } \\<close>"], ["", "lemma \"const\\<cdot>x\\<cdot>y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const\\<cdot>x\\<cdot>y = x", "by simp"], ["", "subsection \\<open>Complex hints\\<close>"], ["", "text \\<open>@{verbatim \\<open> take (length t) s == t ==> t `Data.List.isPrefixOf` s\\<close> } \\<close>"], ["", "lemma\n  fixes t :: \"['a::Eq_sym]\"\n  shows \"eq\\<cdot>(take\\<cdot>(length\\<cdot>t)\\<cdot>s)\\<cdot>t \\<sqsubseteq> isPrefixOf\\<cdot>t\\<cdot>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>(take\\<cdot>(length\\<cdot>t)\\<cdot>s)\\<cdot>t \\<sqsubseteq>\n    isPrefixOf\\<cdot>t\\<cdot>s", "by (subst eq_sym) (rule eq_take_length_isPrefixOf)"], ["", "text \\<open>@{verbatim \\<open> (take i s == t) ==> _eval_ ((i >= length t) && (t `Data.List.isPrefixOf` s))\\<close> } \\<close>"], ["", "text \\<open>The hint is not true in general, as the following two lemmas show:\\<close>"], ["", "lemma\n  assumes \"t = []\" and \"s = x : xs\" and \"i = 1\"\n  shows \"\\<not> (eq\\<cdot>(take\\<cdot>i\\<cdot>s)\\<cdot>t \\<sqsubseteq> (le\\<cdot>(length\\<cdot>t)\\<cdot>i andalso isPrefixOf\\<cdot>t\\<cdot>s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>(take\\<cdot>i\\<cdot>s)\\<cdot>t \\<notsqsubseteq>\n    (le\\<cdot>(length\\<cdot>t)\\<cdot>i andalso isPrefixOf\\<cdot>t\\<cdot>s)", "using assms"], ["proof (prove)\nusing this:\n  t = []\n  s = x : xs\n  i = 1\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(take\\<cdot>i\\<cdot>s)\\<cdot>t \\<notsqsubseteq>\n    (le\\<cdot>(length\\<cdot>t)\\<cdot>i andalso isPrefixOf\\<cdot>t\\<cdot>s)", "by simp"], ["", "lemma\n  assumes \"le\\<cdot>0\\<cdot>i = TT\" and \"le\\<cdot>i\\<cdot>0 = FF\"\n    and \"s = \\<bottom>\" and \"t = []\"\n  shows \"\\<not> ((le\\<cdot>(length\\<cdot>t)\\<cdot>i andalso isPrefixOf\\<cdot>t\\<cdot>s) \\<sqsubseteq> eq\\<cdot>(take\\<cdot>i\\<cdot>s)\\<cdot>t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (le\\<cdot>(length\\<cdot>t)\\<cdot>\n     i andalso isPrefixOf\\<cdot>t\\<cdot>s) \\<notsqsubseteq>\n    eq\\<cdot>(take\\<cdot>i\\<cdot>s)\\<cdot>t", "using assms"], ["proof (prove)\nusing this:\n  le\\<cdot>0\\<cdot>i = TT\n  le\\<cdot>i\\<cdot>0 = FF\n  s = \\<bottom>\n  t = []\n\ngoal (1 subgoal):\n 1. (le\\<cdot>(length\\<cdot>t)\\<cdot>\n     i andalso isPrefixOf\\<cdot>t\\<cdot>s) \\<notsqsubseteq>\n    eq\\<cdot>(take\\<cdot>i\\<cdot>s)\\<cdot>t", "by (subst take.simps) simp"], ["", "(* -- clever hint, but not actually a good idea *)\n(*  (do a <- f; g a) ==> f >>= g *)\n(*  a $$$$ b $$$$ c ==> a . b $$$$$ c *)\n\n(* not (a == b) ==> a /= b *)"], ["", "lemma \"neg\\<cdot>(eq\\<cdot>a\\<cdot>b) = neq\\<cdot>a\\<cdot>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg\\<cdot>(eq\\<cdot>a\\<cdot>b) = neq\\<cdot>a\\<cdot>b", "by auto"], ["", "text \\<open>@{verbatim \\<open>not (a /= b) ==> a == b\\<close> } \\<close>"], ["", "lemma \"neg\\<cdot>(neq\\<cdot>a\\<cdot>b) = eq\\<cdot>a\\<cdot>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg\\<cdot>(neq\\<cdot>a\\<cdot>b) = eq\\<cdot>a\\<cdot>b", "by auto"], ["", "text \\<open>@{verbatim \\<open>map id ==> id\\<close> } \\<close>"], ["", "lemma map_id:\"map\\<cdot>ID = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>ID = ID", "by (auto simp add: cfun_eq_iff)"], ["", "text \\<open>@{verbatim \\<open>x == [] ==> null x\\<close> } \\<close>"], ["", "lemma \"eq\\<cdot>x\\<cdot>[] = null\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>[] = null\\<cdot>x", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>any id ==> or\\<close> } \\<close>"], ["", "lemma \"any\\<cdot>ID = the_or\""], ["proof (prove)\ngoal (1 subgoal):\n 1. any\\<cdot>ID = the_or", "by (auto simp add:map_id)"], ["", "text \\<open>@{verbatim \\<open>all id ==> and\\<close> } \\<close>"], ["", "lemma \"all\\<cdot>ID = the_and\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all\\<cdot>ID = the_and", "by (auto simp add:map_id)"], ["", "text \\<open>@{verbatim \\<open>(if x then False else y) ==> (not x && y)\\<close> } \\<close>"], ["", "lemma \"(If x then FF else y) = (neg\\<cdot>x andalso y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If x then FF else y = (neg\\<cdot>x andalso y)", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>(if x then y else True) ==> (not x || y)\\<close> } \\<close>"], ["", "lemma \"(If x then y else TT) = (neg\\<cdot>x orelse y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If x then y else TT = (neg\\<cdot>x orelse y)", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>not (not x) ==> x\\<close> } \\<close>"], ["", "lemma \"neg\\<cdot>(neg\\<cdot>x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg\\<cdot>(neg\\<cdot>x) = x", "by auto"], ["", "text \\<open>@{verbatim \\<open>(if c then f x else f y) ==> f (if c then x else y)\\<close> } \\<close>"], ["", "lemma \"(If c then f\\<cdot>x else f\\<cdot>y) \\<sqsubseteq> f\\<cdot>(If c then x else y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If c then f\\<cdot>x else f\\<cdot>y \\<sqsubseteq>\n    f\\<cdot>(If c then x else y)", "by (cases c, auto)"], ["", "text \\<open>@{verbatim \\<open>(\\ x -> [x]) ==> (: [])\\<close> } \\<close>"], ["", "lemma \"(\\<Lambda> x. [x]) = (\\<Lambda> z. z : [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (:[]) = (:[])", "by auto"], ["", "text \\<open>@{verbatim \\<open>True == a ==> a\\<close> } \\<close>"], ["", "lemma \"eq\\<cdot>TT\\<cdot>a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>TT\\<cdot>a = a", "by (cases a, auto)"], ["", "text \\<open>@{verbatim \\<open>False == a ==> not a\\<close> } \\<close>"], ["", "lemma \"eq\\<cdot>FF\\<cdot>a = neg\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>FF\\<cdot>a = neg\\<cdot>a", "by (cases a, auto)"], ["", "text \\<open>@{verbatim \\<open>a /= True ==> not a\\<close> } \\<close>"], ["", "lemma \"neq\\<cdot>a\\<cdot>TT = neg\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neq\\<cdot>a\\<cdot>TT = neg\\<cdot>a", "by (cases a, auto)"], ["", "text \\<open>@{verbatim \\<open>a /= False ==> a\\<close> } \\<close>"], ["", "lemma \"neq\\<cdot>a\\<cdot>FF = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neq\\<cdot>a\\<cdot>FF = a", "by (cases a, auto)"], ["", "text \\<open>@{verbatim \\<open>True /= a ==> not a\\<close> } \\<close>"], ["", "lemma \"neq\\<cdot>TT\\<cdot>a = neg\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neq\\<cdot>TT\\<cdot>a = neg\\<cdot>a", "by (cases a, auto)"], ["", "text \\<open>@{verbatim \\<open>False /= a ==> a\\<close> } \\<close>"], ["", "lemma \"neq\\<cdot>FF\\<cdot>a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neq\\<cdot>FF\\<cdot>a = a", "by (cases a, auto)"], ["", "text \\<open>@{verbatim \\<open>not (isNothing x) ==> isJust x\\<close> } \\<close>"], ["", "lemma \"neg\\<cdot>(isNothing\\<cdot>x) = isJust\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg\\<cdot>(isNothing\\<cdot>x) = isJust\\<cdot>x", "by auto"], ["", "text \\<open>@{verbatim \\<open>not (isJust x) ==> isNothing x\\<close> } \\<close>"], ["", "lemma \"neg\\<cdot>(isJust\\<cdot>x) = isNothing\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg\\<cdot>(isJust\\<cdot>x) = isNothing\\<cdot>x", "by auto"], ["", "text \\<open>@{verbatim \\<open>x == Nothing ==> isNothing x\\<close> } \\<close>"], ["", "lemma \"eq\\<cdot>x\\<cdot>Nothing = isNothing\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>x\\<cdot>Nothing = isNothing\\<cdot>x", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>Nothing == x ==> isNothing x\\<close> } \\<close>"], ["", "lemma \"eq\\<cdot>Nothing\\<cdot>x = isNothing\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>Nothing\\<cdot>x = isNothing\\<cdot>x", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>x /= Nothing ==> Data.Maybe.isJust x\\<close> } \\<close>"], ["", "lemma \"neq\\<cdot>x\\<cdot>Nothing = isJust\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neq\\<cdot>x\\<cdot>Nothing = isJust\\<cdot>x", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>Nothing /= x ==> Data.Maybe.isJust x\\<close> } \\<close>"], ["", "lemma \"neq\\<cdot>Nothing\\<cdot>x = isJust\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neq\\<cdot>Nothing\\<cdot>x = isJust\\<cdot>x", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>(if isNothing x then y else fromJust x) ==> fromMaybe y x\\<close> } \\<close>"], ["", "lemma \"(If isNothing\\<cdot>x then y else fromJust\\<cdot>x) = fromMaybe\\<cdot>y\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If isNothing\\<cdot>x then y else fromJust\\<cdot>x =\n    fromMaybe\\<cdot>y\\<cdot>x", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>(if isJust x then fromJust x else y) ==> fromMaybe y x\\<close> } \\<close>"], ["", "lemma \"(If isJust\\<cdot>x then fromJust\\<cdot>x else y) = fromMaybe\\<cdot>y\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If isJust\\<cdot>x then fromJust\\<cdot>x else y =\n    fromMaybe\\<cdot>y\\<cdot>x", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>(isJust x && (fromJust x == y)) ==> x == Just y\\<close> } \\<close>"], ["", "lemma \"(isJust\\<cdot>x andalso (eq\\<cdot>(fromJust\\<cdot>x)\\<cdot>y)) = eq\\<cdot>x\\<cdot>(Just\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (isJust\\<cdot>x andalso eq\\<cdot>(fromJust\\<cdot>x)\\<cdot>y) =\n    eq\\<cdot>x\\<cdot>(Just\\<cdot>y)", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>elem True ==> or\\<close> } \\<close>"], ["", "lemma \"elem\\<cdot>TT = the_or\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem\\<cdot>TT = the_or", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. elem\\<cdot>TT\\<cdot>x = the_or\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. elem\\<cdot>TT\\<cdot>x = the_or\\<cdot>x", "show \"elem\\<cdot>TT\\<cdot>xs = the_or\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elem\\<cdot>TT\\<cdot>xs = the_or\\<cdot>xs", "by (induct xs) (auto simp: eq_true)"], ["proof (state)\nthis:\n  elem\\<cdot>TT\\<cdot>xs = the_or\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open>notElem False ==> and\\<close> } \\<close>"], ["", "lemma \"notElem\\<cdot>FF = the_and\""], ["proof (prove)\ngoal (1 subgoal):\n 1. notElem\\<cdot>FF = the_and", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. notElem\\<cdot>FF\\<cdot>x = the_and\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. notElem\\<cdot>FF\\<cdot>x = the_and\\<cdot>x", "show \"notElem\\<cdot>FF\\<cdot>xs = the_and\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. notElem\\<cdot>FF\\<cdot>xs = the_and\\<cdot>xs", "by (induct xs) (auto simp: eq_false)"], ["proof (state)\nthis:\n  notElem\\<cdot>FF\\<cdot>xs = the_and\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open>all ((/=) a) ==> notElem a\\<close> } \\<close>"], ["", "lemma \"all\\<cdot>(neq\\<cdot>(a::'a::Eq_sym)) = notElem\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all\\<cdot>(neq\\<cdot>a) = notElem\\<cdot>a", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. all\\<cdot>(neq\\<cdot>a)\\<cdot>x = notElem\\<cdot>a\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. all\\<cdot>(neq\\<cdot>a)\\<cdot>x = notElem\\<cdot>a\\<cdot>x", "show \"all\\<cdot>(neq\\<cdot>a)\\<cdot>xs = notElem\\<cdot>a\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all\\<cdot>(neq\\<cdot>a)\\<cdot>xs = notElem\\<cdot>a\\<cdot>xs", "by (induct xs) (auto simp: eq_sym)"], ["proof (state)\nthis:\n  all\\<cdot>(neq\\<cdot>a)\\<cdot>xs = notElem\\<cdot>a\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open>maybe x id ==> Data.Maybe.fromMaybe x\\<close> } \\<close>"], ["", "lemma \"maybe\\<cdot>x\\<cdot>ID = fromMaybe\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>x\\<cdot>ID = fromMaybe\\<cdot>x", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. maybe\\<cdot>x\\<cdot>ID\\<cdot>xa = fromMaybe\\<cdot>x\\<cdot>xa", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. maybe\\<cdot>x\\<cdot>ID\\<cdot>xa = fromMaybe\\<cdot>x\\<cdot>xa", "show \"maybe\\<cdot>x\\<cdot>ID\\<cdot>xs = fromMaybe\\<cdot>x\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>x\\<cdot>ID\\<cdot>xs = fromMaybe\\<cdot>x\\<cdot>xs", "by (cases xs) auto"], ["proof (state)\nthis:\n  maybe\\<cdot>x\\<cdot>ID\\<cdot>xs = fromMaybe\\<cdot>x\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open>maybe False (const True) ==> Data.Maybe.isJust\\<close> } \\<close>"], ["", "lemma \"maybe\\<cdot>FF\\<cdot>(const\\<cdot>TT) = isJust\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>FF\\<cdot>(const\\<cdot>TT) = isJust", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. maybe\\<cdot>FF\\<cdot>(const\\<cdot>TT)\\<cdot>x = isJust\\<cdot>x", "fix x :: \"'a Maybe\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. maybe\\<cdot>FF\\<cdot>(const\\<cdot>TT)\\<cdot>x = isJust\\<cdot>x", "show \"maybe\\<cdot>FF\\<cdot>(const\\<cdot>TT)\\<cdot>x = isJust\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>FF\\<cdot>(const\\<cdot>TT)\\<cdot>x = isJust\\<cdot>x", "by (cases x) simp+"], ["proof (state)\nthis:\n  maybe\\<cdot>FF\\<cdot>(const\\<cdot>TT)\\<cdot>x = isJust\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open>maybe True (const False) ==> Data.Maybe.isNothing\\<close> } \\<close>"], ["", "lemma \"maybe\\<cdot>TT\\<cdot>(const\\<cdot>FF) = isNothing\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>TT\\<cdot>(const\\<cdot>FF) = isNothing", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       maybe\\<cdot>TT\\<cdot>(const\\<cdot>FF)\\<cdot>x = isNothing\\<cdot>x", "fix x :: \"'a Maybe\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       maybe\\<cdot>TT\\<cdot>(const\\<cdot>FF)\\<cdot>x = isNothing\\<cdot>x", "show \"maybe\\<cdot>TT\\<cdot>(const\\<cdot>FF)\\<cdot>x = isNothing\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>TT\\<cdot>(const\\<cdot>FF)\\<cdot>x = isNothing\\<cdot>x", "by (cases x) simp+"], ["proof (state)\nthis:\n  maybe\\<cdot>TT\\<cdot>(const\\<cdot>FF)\\<cdot>x = isNothing\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open>maybe [] (: []) ==> maybeToList\\<close> } \\<close>"], ["", "lemma \"maybe\\<cdot>[]\\<cdot>(\\<Lambda> z. z : []) = maybeToList\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>[]\\<cdot>(:[]) = maybeToList", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. maybe\\<cdot>[]\\<cdot>(:[])\\<cdot>x = maybeToList\\<cdot>x", "fix x :: \"'a Maybe\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. maybe\\<cdot>[]\\<cdot>(:[])\\<cdot>x = maybeToList\\<cdot>x", "show \"maybe\\<cdot>[]\\<cdot>(\\<Lambda> z. z : [])\\<cdot>x = maybeToList\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>[]\\<cdot>(:[])\\<cdot>x = maybeToList\\<cdot>x", "by (cases x) simp+"], ["proof (state)\nthis:\n  maybe\\<cdot>[]\\<cdot>(:[])\\<cdot>x = maybeToList\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open>catMaybes (map f x) ==> mapMaybe f x\\<close> } \\<close>"], ["", "lemma \"catMaybes\\<cdot>(map\\<cdot>f\\<cdot>x) = mapMaybe\\<cdot>f\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catMaybes\\<cdot>(map\\<cdot>f\\<cdot>x) = mapMaybe\\<cdot>f\\<cdot>x", "by auto"], ["", "text \\<open>@{verbatim \\<open>(if isNothing x then y else f (fromJust x)) ==> maybe y f x\\<close> } \\<close>"], ["", "lemma \"(If isNothing\\<cdot>x then y else f\\<cdot>(fromJust\\<cdot>x)) = maybe\\<cdot>y\\<cdot>f\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If isNothing\\<cdot>x then y else f\\<cdot>(fromJust\\<cdot>x) =\n    maybe\\<cdot>y\\<cdot>f\\<cdot>x", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>(if isJust x then f (fromJust x) else y) ==> maybe y f x\\<close> } \\<close>"], ["", "lemma \"(If isJust\\<cdot>x then f\\<cdot>(fromJust\\<cdot>x) else y) = maybe\\<cdot>y\\<cdot>f\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If isJust\\<cdot>x then f\\<cdot>(fromJust\\<cdot>x) else y =\n    maybe\\<cdot>y\\<cdot>f\\<cdot>x", "by (cases x, auto)"], ["", "text \\<open>@{verbatim \\<open>(map fromJust . filter isJust) ==> Data.Maybe.catMaybes\\<close> } \\<close>"], ["", "lemma \"(map\\<cdot>fromJust oo filter\\<cdot>isJust) = catMaybes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map\\<cdot>fromJust oo filter\\<cdot>isJust = catMaybes", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>x =\n       catMaybes\\<cdot>x", "fix xs :: \"['a Maybe]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>x =\n       catMaybes\\<cdot>x", "show \"(map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>xs = catMaybes\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>xs =\n    catMaybes\\<cdot>xs", "proof (induct xs)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>a =\n            catMaybes\\<cdot>a)\n 2. (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>\\<bottom> =\n    catMaybes\\<cdot>\\<bottom>\n 3. (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>[] =\n    catMaybes\\<cdot>[]\n 4. \\<And>a xs.\n       (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>xs =\n       catMaybes\\<cdot>xs \\<Longrightarrow>\n       (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>(a : xs) =\n       catMaybes\\<cdot>(a : xs)", "case (Cons y ys)"], ["proof (state)\nthis:\n  (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>ys = catMaybes\\<cdot>ys\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>a =\n            catMaybes\\<cdot>a)\n 2. (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>\\<bottom> =\n    catMaybes\\<cdot>\\<bottom>\n 3. (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>[] =\n    catMaybes\\<cdot>[]\n 4. \\<And>a xs.\n       (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>xs =\n       catMaybes\\<cdot>xs \\<Longrightarrow>\n       (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>(a : xs) =\n       catMaybes\\<cdot>(a : xs)", "then"], ["proof (chain)\npicking this:\n  (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>ys = catMaybes\\<cdot>ys", "show ?case"], ["proof (prove)\nusing this:\n  (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>ys = catMaybes\\<cdot>ys\n\ngoal (1 subgoal):\n 1. (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>(y : ys) =\n    catMaybes\\<cdot>(y : ys)", "by (cases y) simp+"], ["proof (state)\nthis:\n  (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>(y : ys) =\n  catMaybes\\<cdot>(y : ys)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>a =\n            catMaybes\\<cdot>a)\n 2. (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>\\<bottom> =\n    catMaybes\\<cdot>\\<bottom>\n 3. (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>[] =\n    catMaybes\\<cdot>[]", "qed simp+"], ["proof (state)\nthis:\n  (map\\<cdot>fromJust oo filter\\<cdot>isJust)\\<cdot>xs = catMaybes\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open>concatMap (maybeToList . f) ==> Data.Maybe.mapMaybe f\\<close> } \\<close>"], ["", "lemma \"concatMap\\<cdot>(maybeToList oo f) = mapMaybe\\<cdot>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMap\\<cdot>(maybeToList oo f) = mapMaybe\\<cdot>f", "proof (rule cfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       concatMap\\<cdot>(maybeToList oo f)\\<cdot>x = mapMaybe\\<cdot>f\\<cdot>x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       concatMap\\<cdot>(maybeToList oo f)\\<cdot>x = mapMaybe\\<cdot>f\\<cdot>x", "show \"concatMap\\<cdot>(maybeToList oo f)\\<cdot>xs = mapMaybe\\<cdot>f\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMap\\<cdot>(maybeToList oo f)\\<cdot>xs = mapMaybe\\<cdot>f\\<cdot>xs", "by (induct xs) auto"], ["proof (state)\nthis:\n  concatMap\\<cdot>(maybeToList oo f)\\<cdot>xs = mapMaybe\\<cdot>f\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{verbatim \\<open>concatMap maybeToList ==> catMaybes\\<close> } \\<close>"], ["", "lemma \"concatMap\\<cdot>maybeToList = catMaybes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMap\\<cdot>maybeToList = catMaybes", "by auto"], ["", "text \\<open>@{verbatim \\<open>mapMaybe f (map g x) ==> mapMaybe (f . g) x\\<close> } \\<close>"], ["", "lemma \"mapMaybe\\<cdot>f\\<cdot>(map\\<cdot>g\\<cdot>x) = mapMaybe\\<cdot>(f oo g)\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapMaybe\\<cdot>f\\<cdot>(map\\<cdot>g\\<cdot>x) =\n    mapMaybe\\<cdot>(f oo g)\\<cdot>x", "by auto"], ["", "text \\<open>@{verbatim \\<open>(($) . f) ==> f\\<close> } \\<close>"], ["", "lemma \"(dollar oo f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dollar oo f = f", "by (auto simp add:cfun_eq_iff)"], ["", "text \\<open>@{verbatim \\<open>(f $) ==> f\\<close> } \\<close>"], ["", "lemma \"(\\<Lambda> z. dollar\\<cdot>f\\<cdot>z) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> z. dollar\\<cdot>f\\<cdot>z) = f", "by (auto simp add:cfun_eq_iff)"], ["", "text \\<open>@{verbatim \\<open>(\\ a b -> g (f a) (f b)) ==> g `Data.Function.on` f\\<close> } \\<close>"], ["", "lemma \"(\\<Lambda> a b. g\\<cdot>(f\\<cdot>a)\\<cdot>(f\\<cdot>b)) = on\\<cdot>g\\<cdot>f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> a b. g\\<cdot>(f\\<cdot>a)\\<cdot>(f\\<cdot>b)) =\n    on\\<cdot>g\\<cdot>f", "by (auto simp add:cfun_eq_iff)"], ["", "text \\<open>@{verbatim \\<open>id $! x ==> x\\<close> } \\<close>"], ["", "lemma \"dollarBang\\<cdot>ID\\<cdot>x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dollarBang\\<cdot>ID\\<cdot>x = x", "by (auto simp add:seq_def)"], ["", "text \\<open>@{verbatim \\<open>[x | x <- y] ==> y\\<close> } \\<close>"], ["", "lemma \"[x | x <- y] = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMap\\<cdot>(:[])\\<cdot>y = y", "by (induct y, auto)"], ["", "text \\<open>@{verbatim \\<open>isPrefixOf (reverse x) (reverse y) ==> isSuffixOf x y\\<close> } \\<close>"], ["", "lemma \"isPrefixOf\\<cdot>(reverse\\<cdot>x)\\<cdot>(reverse\\<cdot>y) = isSuffixOf\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPrefixOf\\<cdot>(reverse\\<cdot>x)\\<cdot>(reverse\\<cdot>y) =\n    isSuffixOf\\<cdot>x\\<cdot>y", "by auto"], ["", "text \\<open>@{verbatim \\<open>concat (intersperse x y) ==> intercalate x y\\<close> } \\<close>"], ["", "lemma \"concat\\<cdot>(intersperse\\<cdot>x\\<cdot>y) = intercalate\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\\<cdot>(intersperse\\<cdot>x\\<cdot>y) = intercalate\\<cdot>x\\<cdot>y", "by auto"], ["", "text \\<open>@{verbatim \\<open>x `seq` y ==> y\\<close> } \\<close>"], ["", "lemma\n  assumes \"x \\<noteq> \\<bottom>\" shows \"seq\\<cdot>x\\<cdot>y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq\\<cdot>x\\<cdot>y = y", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. seq\\<cdot>x\\<cdot>y = y", "by (simp add: seq_def)"], ["", "text \\<open>@{verbatim \\<open>f $! x ==> f x\\<close> } \\<close>"], ["", "lemma assumes \"x \\<noteq> \\<bottom>\" shows \"dollarBang\\<cdot>f\\<cdot>x = f\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dollarBang\\<cdot>f\\<cdot>x = f\\<cdot>x", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. dollarBang\\<cdot>f\\<cdot>x = f\\<cdot>x", "by (simp add: seq_def)"], ["", "text \\<open>@{verbatim \\<open>maybe (f x) (f . g) ==> (f . maybe x g)\\<close> } \\<close>"], ["", "lemma \"maybe\\<cdot>(f\\<cdot>x)\\<cdot>(f oo g) \\<sqsubseteq> (f oo maybe\\<cdot>x\\<cdot>g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>(f\\<cdot>x)\\<cdot>(f oo g) \\<sqsubseteq>\n    f oo maybe\\<cdot>x\\<cdot>g", "proof (rule cfun_belowI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       maybe\\<cdot>(f\\<cdot>x)\\<cdot>(f oo g)\\<cdot>xa \\<sqsubseteq>\n       (f oo maybe\\<cdot>x\\<cdot>g)\\<cdot>xa", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       maybe\\<cdot>(f\\<cdot>x)\\<cdot>(f oo g)\\<cdot>xa \\<sqsubseteq>\n       (f oo maybe\\<cdot>x\\<cdot>g)\\<cdot>xa", "show \"maybe\\<cdot>(f\\<cdot>x)\\<cdot>(f oo g)\\<cdot>y \\<sqsubseteq> (f oo maybe\\<cdot>x\\<cdot>g)\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maybe\\<cdot>(f\\<cdot>x)\\<cdot>(f oo g)\\<cdot>y \\<sqsubseteq>\n    (f oo maybe\\<cdot>x\\<cdot>g)\\<cdot>y", "by (cases y) auto"], ["proof (state)\nthis:\n  maybe\\<cdot>(f\\<cdot>x)\\<cdot>(f oo g)\\<cdot>y \\<sqsubseteq>\n  (f oo maybe\\<cdot>x\\<cdot>g)\\<cdot>y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}