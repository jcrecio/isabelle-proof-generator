{"file_name": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude/List_Comprehension.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude", "problem_names": ["lemma concatMap_singleton [simp]:\n  \"concatMap\\<cdot>(\\<Lambda> x. [f\\<cdot>x])\\<cdot>xs = map\\<cdot>f\\<cdot>xs\"", "lemma listcompr_filter [simp]:\n  \"[x | x <- xs, P\\<cdot>x] = filter\\<cdot>P\\<cdot>xs\"", "lemma \"[y | let y = x*2; z = y, x <- xs] = A\""], "translations": [["", "lemma concatMap_singleton [simp]:\n  \"concatMap\\<cdot>(\\<Lambda> x. [f\\<cdot>x])\\<cdot>xs = map\\<cdot>f\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMap\\<cdot>(\\<Lambda> x. [f\\<cdot>x])\\<cdot>xs =\n    map\\<cdot>f\\<cdot>xs", "by (induct xs) simp_all"], ["", "lemma listcompr_filter [simp]:\n  \"[x | x <- xs, P\\<cdot>x] = filter\\<cdot>P\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>xs =\n    filter\\<cdot>P\\<cdot>xs", "proof (induct xs)"], ["proof (state)\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            concatMap\\<cdot>\n            (\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n            a =\n            filter\\<cdot>P\\<cdot>a)\n 2. concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n    \\<bottom> =\n    filter\\<cdot>P\\<cdot>\\<bottom>\n 3. concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>[] =\n    filter\\<cdot>P\\<cdot>[]\n 4. \\<And>a xs.\n       concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n       xs =\n       filter\\<cdot>P\\<cdot>xs \\<Longrightarrow>\n       concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n       (a : xs) =\n       filter\\<cdot>P\\<cdot>(a : xs)", "case (Cons a xs)"], ["proof (state)\nthis:\n  concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>xs =\n  filter\\<cdot>P\\<cdot>xs\n\ngoal (4 subgoals):\n 1. adm (\\<lambda>a.\n            concatMap\\<cdot>\n            (\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n            a =\n            filter\\<cdot>P\\<cdot>a)\n 2. concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n    \\<bottom> =\n    filter\\<cdot>P\\<cdot>\\<bottom>\n 3. concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>[] =\n    filter\\<cdot>P\\<cdot>[]\n 4. \\<And>a xs.\n       concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n       xs =\n       filter\\<cdot>P\\<cdot>xs \\<Longrightarrow>\n       concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n       (a : xs) =\n       filter\\<cdot>P\\<cdot>(a : xs)", "then"], ["proof (chain)\npicking this:\n  concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>xs =\n  filter\\<cdot>P\\<cdot>xs", "show ?case"], ["proof (prove)\nusing this:\n  concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>xs =\n  filter\\<cdot>P\\<cdot>xs\n\ngoal (1 subgoal):\n 1. concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n    (a : xs) =\n    filter\\<cdot>P\\<cdot>(a : xs)", "by (cases \"P\\<cdot>a\"; simp)"], ["proof (state)\nthis:\n  concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n  (a : xs) =\n  filter\\<cdot>P\\<cdot>(a : xs)\n\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            concatMap\\<cdot>\n            (\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n            a =\n            filter\\<cdot>P\\<cdot>a)\n 2. concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>\n    \\<bottom> =\n    filter\\<cdot>P\\<cdot>\\<bottom>\n 3. concatMap\\<cdot>(\\<Lambda> x. If P\\<cdot>x then [x] else [])\\<cdot>[] =\n    filter\\<cdot>P\\<cdot>[]", "qed simp_all"], ["", "lemma \"[y | let y = x*2; z = y, x <- xs] = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let y = x * (2::'a); z = y\n     in concatMap\\<cdot>(\\<Lambda> x. [y])\\<cdot>xs) =\n    A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. concatMap\\<cdot>(\\<Lambda> xa. [x * (2::'a)])\\<cdot>xs = A", "oops"], ["", "end"]]}