{"file_name": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude/Numeral_Cpo.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HOLCF-Prelude", "problem_names": ["lemma cont2cont_plus [simp, cont2cont]:\n  assumes \"cont (\\<lambda>x. f x)\" and \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x + g x :: 'a::plus_cpo)\"", "lemma cont2cont_minus [simp, cont2cont]:\n  assumes \"cont (\\<lambda>x. f x)\" and \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x - g x :: 'a::minus_cpo)\"", "lemma cont2cont_times [simp, cont2cont]:\n  assumes \"cont (\\<lambda>x. f x)\" and \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x * g x :: 'a::times_cpo)\"", "lemma plus_u_strict [simp]:\n  fixes x :: \"_ u\" shows \"x + \\<bottom> = \\<bottom>\" and \"\\<bottom> + x = \\<bottom>\"", "lemma minus_u_strict [simp]:\n  fixes x :: \"_ u\" shows \"x - \\<bottom> = \\<bottom>\" and \"\\<bottom> - x = \\<bottom>\"", "lemma times_u_strict [simp]:\n  fixes x :: \"_ u\" shows \"x * \\<bottom> = \\<bottom>\" and \"\\<bottom> * x = \\<bottom>\"", "lemma plus_up_up [simp]: \"up\\<cdot>x + up\\<cdot>y = up\\<cdot>(x + y)\"", "lemma minus_up_up [simp]: \"up\\<cdot>x - up\\<cdot>y = up\\<cdot>(x - y)\"", "lemma times_up_up [simp]: \"up\\<cdot>x * up\\<cdot>y = up\\<cdot>(x * y)\""], "translations": [["", "lemma cont2cont_plus [simp, cont2cont]:\n  assumes \"cont (\\<lambda>x. f x)\" and \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x + g x :: 'a::plus_cpo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. f x + g x)", "apply (rule cont_apply [OF assms(1) cont_plus1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. cont (\\<lambda>x. y + g x)", "apply (rule cont_apply [OF assms(2) cont_plus2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya. cont (\\<lambda>x. y + ya)", "apply (rule cont_const)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont2cont_minus [simp, cont2cont]:\n  assumes \"cont (\\<lambda>x. f x)\" and \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x - g x :: 'a::minus_cpo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. f x - g x)", "apply (rule cont_apply [OF assms(1) cont_minus1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. cont (\\<lambda>x. y - g x)", "apply (rule cont_apply [OF assms(2) cont_minus2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya. cont (\\<lambda>x. y - ya)", "apply (rule cont_const)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont2cont_times [simp, cont2cont]:\n  assumes \"cont (\\<lambda>x. f x)\" and \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x * g x :: 'a::times_cpo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. f x * g x)", "apply (rule cont_apply [OF assms(1) cont_times1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. cont (\\<lambda>x. y * g x)", "apply (rule cont_apply [OF assms(2) cont_times2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ya. cont (\\<lambda>x. y * ya)", "apply (rule cont_const)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation u :: (\"{zero,cpo}\") zero\nbegin"], ["", "definition \"zero_u = up\\<cdot>(0::'a)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, zero_class)", ".."], ["", "end"], ["", "instantiation u :: (\"{one,cpo}\") one\nbegin"], ["", "definition \"one_u = up\\<cdot>(1::'a)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, one_class)", ".."], ["", "end"], ["", "instantiation u :: (plus_cpo) plus\nbegin"], ["", "definition \"plus_u x y = (\\<Lambda>(up\\<cdot>a) (up\\<cdot>b). up\\<cdot>(a + b))\\<cdot>x\\<cdot>y\" for x y :: \"'a\\<^sub>\\<bottom>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, plus_class)", ".."], ["", "end"], ["", "instantiation u :: (minus_cpo) minus\nbegin"], ["", "definition \"minus_u x y = (\\<Lambda>(up\\<cdot>a) (up\\<cdot>b). up\\<cdot>(a - b))\\<cdot>x\\<cdot>y\" for x y :: \"'a\\<^sub>\\<bottom>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, minus_class)", ".."], ["", "end"], ["", "instantiation u :: (times_cpo) times\nbegin"], ["", "definition \"times_u x y = (\\<Lambda>(up\\<cdot>a) (up\\<cdot>b). up\\<cdot>(a * b))\\<cdot>x\\<cdot>y\" for x y :: \"'a\\<^sub>\\<bottom>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, times_class)", ".."], ["", "end"], ["", "lemma plus_u_strict [simp]:\n  fixes x :: \"_ u\" shows \"x + \\<bottom> = \\<bottom>\" and \"\\<bottom> + x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + \\<bottom> = \\<bottom> &&& \\<bottom> + x = \\<bottom>", "unfolding plus_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     up\\<cdot>a \\<Rightarrow>\n       \\<Lambda> (up\\<cdot>b). up\\<cdot>(a + b))\\<cdot>\n    \\<bottom> =\n    \\<bottom> &&&\n    (case \\<bottom> of\n     up\\<cdot>a \\<Rightarrow>\n       \\<Lambda> (up\\<cdot>b). up\\<cdot>(a + b))\\<cdot>\n    x =\n    \\<bottom>", "by (cases x, simp, simp)+"], ["", "lemma minus_u_strict [simp]:\n  fixes x :: \"_ u\" shows \"x - \\<bottom> = \\<bottom>\" and \"\\<bottom> - x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - \\<bottom> = \\<bottom> &&& \\<bottom> - x = \\<bottom>", "unfolding minus_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     up\\<cdot>a \\<Rightarrow>\n       \\<Lambda> (up\\<cdot>b). up\\<cdot>(a - b))\\<cdot>\n    \\<bottom> =\n    \\<bottom> &&&\n    (case \\<bottom> of\n     up\\<cdot>a \\<Rightarrow>\n       \\<Lambda> (up\\<cdot>b). up\\<cdot>(a - b))\\<cdot>\n    x =\n    \\<bottom>", "by (cases x, simp_all)+"], ["", "lemma times_u_strict [simp]:\n  fixes x :: \"_ u\" shows \"x * \\<bottom> = \\<bottom>\" and \"\\<bottom> * x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<bottom> = \\<bottom> &&& \\<bottom> * x = \\<bottom>", "unfolding times_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     up\\<cdot>a \\<Rightarrow>\n       \\<Lambda> (up\\<cdot>b). up\\<cdot>(a * b))\\<cdot>\n    \\<bottom> =\n    \\<bottom> &&&\n    (case \\<bottom> of\n     up\\<cdot>a \\<Rightarrow>\n       \\<Lambda> (up\\<cdot>b). up\\<cdot>(a * b))\\<cdot>\n    x =\n    \\<bottom>", "by (cases x, simp_all)+"], ["", "lemma plus_up_up [simp]: \"up\\<cdot>x + up\\<cdot>y = up\\<cdot>(x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up\\<cdot>x + up\\<cdot>y = up\\<cdot>(x + y)", "unfolding plus_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case up\\<cdot>x of\n     up\\<cdot>a \\<Rightarrow>\n       \\<Lambda> (up\\<cdot>b). up\\<cdot>(a + b))\\<cdot>\n    (up\\<cdot>y) =\n    up\\<cdot>(x + y)", "by simp"], ["", "lemma minus_up_up [simp]: \"up\\<cdot>x - up\\<cdot>y = up\\<cdot>(x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up\\<cdot>x - up\\<cdot>y = up\\<cdot>(x - y)", "unfolding minus_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case up\\<cdot>x of\n     up\\<cdot>a \\<Rightarrow>\n       \\<Lambda> (up\\<cdot>b). up\\<cdot>(a - b))\\<cdot>\n    (up\\<cdot>y) =\n    up\\<cdot>(x - y)", "by simp"], ["", "lemma times_up_up [simp]: \"up\\<cdot>x * up\\<cdot>y = up\\<cdot>(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up\\<cdot>x * up\\<cdot>y = up\\<cdot>(x * y)", "unfolding times_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case up\\<cdot>x of\n     up\\<cdot>a \\<Rightarrow>\n       \\<Lambda> (up\\<cdot>b). up\\<cdot>(a * b))\\<cdot>\n    (up\\<cdot>y) =\n    up\\<cdot>(x * y)", "by simp"], ["", "instance u :: (plus_cpo) plus_cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, plus_cpo_class)", "by standard (simp_all add: plus_u_def)"], ["", "instance u :: (minus_cpo) minus_cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, minus_cpo_class)", "by standard (simp_all add: minus_u_def)"], ["", "instance u :: (times_cpo) times_cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, times_cpo_class)", "by standard (simp_all add: times_u_def)"], ["", "instance u :: (\"{semigroup_add,plus_cpo}\") semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, semigroup_add_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "fix a b c :: \"'a u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "show \"(a + b) + c = a + (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "unfolding plus_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (case a of\n           up\\<cdot>a \\<Rightarrow>\n             \\<Lambda> (up\\<cdot>b). up\\<cdot>(a + b))\\<cdot>\n          b of\n     up\\<cdot>a \\<Rightarrow>\n       \\<Lambda> (up\\<cdot>b). up\\<cdot>(a + b))\\<cdot>\n    c =\n    (case a of\n     up\\<cdot>a \\<Rightarrow>\n       \\<Lambda> (up\\<cdot>b). up\\<cdot>(a + b))\\<cdot>\n    ((case b of\n      up\\<cdot>a \\<Rightarrow>\n        \\<Lambda> (up\\<cdot>b). up\\<cdot>(a + b))\\<cdot>\n     c)", "by (cases a; cases b; cases c) (simp_all add: add.assoc)"], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance u :: (\"{ab_semigroup_add,plus_cpo}\") ab_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, ab_semigroup_add_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. a + b = b + a", "fix a b :: \"'a u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. a + b = b + a", "show \"a + b = b + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = b + a", "by (cases a; cases b) (simp_all add: add.commute)"], ["proof (state)\nthis:\n  a + b = b + a\n\ngoal:\nNo subgoals!", "qed"], ["", "instance u :: (\"{monoid_add,plus_cpo}\") monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, monoid_add_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. 0 + a = a\n 2. \\<And>a. a + 0 = a", "fix a :: \"'a u\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. 0 + a = a\n 2. \\<And>a. a + 0 = a", "show \"0 + a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + a = a", "unfolding zero_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. up\\<cdot>(0::'a) + a = a", "by (cases a) simp_all"], ["proof (state)\nthis:\n  0 + a = a\n\ngoal (1 subgoal):\n 1. \\<And>a. a + 0 = a", "show \"a + 0 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 0 = a", "unfolding zero_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + up\\<cdot>(0::'a) = a", "by (cases a) simp_all"], ["proof (state)\nthis:\n  a + 0 = a\n\ngoal:\nNo subgoals!", "qed"], ["", "instance u :: (\"{comm_monoid_add,plus_cpo}\") comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, comm_monoid_add_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. 0 + a = a", "fix a :: \"'a u\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. 0 + a = a", "show \"0 + a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + a = a", "unfolding zero_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. up\\<cdot>(0::'a) + a = a", "by (cases a) simp_all"], ["proof (state)\nthis:\n  0 + a = a\n\ngoal:\nNo subgoals!", "qed"], ["", "instance u :: (\"{numeral, plus_cpo}\") numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, numeral_class)", ".."], ["", "instance int :: plus_cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, plus_cpo_class)", "by standard simp_all"], ["", "instance int :: minus_cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, minus_cpo_class)", "by standard simp_all"], ["", "end"]]}