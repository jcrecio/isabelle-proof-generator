{"file_name": "/home/qj213/afp-2021-10-22/thys/Attack_Trees/MC.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Attack_Trees", "problem_names": ["lemma predtrans_empty: \n  assumes \"mono (\\<tau> :: 'a set \\<Rightarrow> 'a set)\"\n  shows \"\\<forall> i. (\\<tau> ^^ i) ({}) \\<subseteq> (\\<tau> ^^(i + 1))({})\"", "lemma ex_card: \"finite S \\<Longrightarrow> \\<exists> n:: nat. card S = n\"", "lemma less_not_le: \"\\<lbrakk>(x:: nat) < y; y \\<le> x\\<rbrakk> \\<Longrightarrow> False\"", "lemma infchain_outruns_all: \n  assumes \"finite (UNIV :: 'a set)\" \n    and \"\\<forall>i :: nat. ((\\<tau> :: 'a set \\<Rightarrow> 'a set)^^ i) ({}:: 'a set) \\<subset> (\\<tau> ^^ (i + 1)) {}\"\n  shows \"\\<forall>j :: nat. \\<exists>i :: nat. j < card ((\\<tau> ^^ i) {})\"", "lemma no_infinite_subset_chain: \n   assumes \"finite (UNIV :: 'a set)\"\n    and    \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n    and    \"\\<forall>i :: nat. ((\\<tau> :: 'a set \\<Rightarrow> 'a set) ^^ i) {} \\<subset> (\\<tau> ^^ (i + (1 :: nat))) ({} :: 'a set)\" \n  shows   \"False\"", "lemma finite_fixp: \n  assumes \"finite(UNIV :: 'a set)\" \n      and \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n    shows \"\\<exists> i. (\\<tau> ^^ i) ({}) = (\\<tau> ^^(i + 1))({})\"", "lemma predtrans_UNIV: \n  assumes \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n  shows \"\\<forall> i. (\\<tau> ^^ i) (UNIV) \\<supseteq> (\\<tau> ^^(i + 1))(UNIV)\"", "lemma Suc_less_le: \"x < (y - n) \\<Longrightarrow> x \\<le> (y - (Suc n))\"", "lemma card_univ_subtract: \n  assumes \"finite (UNIV :: 'a set)\" and  \"mono \\<tau>\"\n     and  \"(\\<forall>i :: nat. ((\\<tau> :: 'a set \\<Rightarrow> 'a set) ^^ (i + (1 :: nat)))(UNIV :: 'a set) \\<subset> (\\<tau> ^^ i) UNIV)\"\n   shows \"(\\<forall> i :: nat. card((\\<tau> ^^ i) (UNIV ::'a set)) \\<le> (card (UNIV :: 'a set)) - i)\"", "lemma card_UNIV_tau_i_below_zero: \n  assumes \"finite (UNIV :: 'a set)\" and \"mono \\<tau>\"\n   and  \"(\\<forall>i :: nat. ((\\<tau> :: ('a set \\<Rightarrow> 'a set)) ^^ (i + (1 :: nat)))(UNIV :: 'a set) \\<subset> (\\<tau> ^^ i) UNIV)\"\n shows \"card((\\<tau> ^^ (card (UNIV ::'a set))) (UNIV ::'a set)) \\<le> 0\"", "lemma finite_card_zero_empty: \"\\<lbrakk> finite S; card S \\<le> 0\\<rbrakk> \\<Longrightarrow> S = {}\"", "lemma UNIV_tau_i_is_empty:\n  assumes \"finite (UNIV :: 'a set)\" and \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n    and   \"(\\<forall>i :: nat. ((\\<tau> :: 'a set \\<Rightarrow> 'a set) ^^ (i + (1 :: nat)))(UNIV :: 'a set) \\<subset> (\\<tau> ^^ i) UNIV)\"\n  shows \"(\\<tau> ^^ (card (UNIV ::'a set))) (UNIV ::'a set) = {}\"", "lemma down_chain_reaches_empty:\n  assumes \"finite (UNIV :: 'a set)\" and \"mono (\\<tau> :: 'a set \\<Rightarrow> 'a set)\"\n   and \"(\\<forall>i :: nat. ((\\<tau> :: 'a set \\<Rightarrow> 'a set) ^^ (i + (1 :: nat))) UNIV \\<subset> (\\<tau> ^^ i) UNIV)\"\n shows \"\\<exists> (j :: nat). (\\<tau> ^^ j) UNIV = {}\"", "lemma no_infinite_subset_chain2: \n  assumes \"finite (UNIV :: 'a set)\" and \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n      and \"\\<forall>i :: nat. (\\<tau> ^^ i) UNIV \\<supset> (\\<tau> ^^ (i + (1 :: nat))) UNIV\"\n  shows \"False\"", "lemma finite_fixp2: \n  assumes \"finite(UNIV :: 'a set)\" and \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n  shows \"\\<exists> i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^(i + 1)) UNIV\"", "lemma lfp_loop: \n  assumes \"finite (UNIV :: 'b set)\" and \"mono (\\<tau> :: ('b set \\<Rightarrow> 'b set))\"\n  shows \"\\<exists> n . lfp \\<tau>  = (\\<tau> ^^ n) {}\"", "lemma Kleene_iter_gpfp:\n  assumes \"mono f\" and \"p \\<le> f p\" shows \"p \\<le> (f^^k) (top::'a::order_top)\"", "lemma gfp_loop: \n  assumes \"finite (UNIV :: 'b set)\"\n   and \"mono (\\<tau> :: ('b set \\<Rightarrow> 'b set))\"\n    shows \"\\<exists> n . gfp \\<tau>  = (\\<tau> ^^ n)UNIV\"", "lemma EF_lem0: \"(x \\<in> EF f) = (x \\<in> f \\<union> EX' (lfp (\\<lambda>Z :: ('a :: state) set. f \\<union> EX' Z)))\"", "lemma EF_lem00: \"(EF f) = (f \\<union> EX' (lfp (\\<lambda> Z :: ('a :: state) set. f \\<union> EX' Z)))\"", "lemma EF_lem000: \"(EF f) = (f \\<union> EX' (EF f))\"", "lemma EF_lem1: \"x \\<in> f \\<or> x \\<in> (EX' (EF f)) \\<Longrightarrow> x \\<in> EF f\"", "lemma EF_lem2b: \n  assumes \"x \\<in> (EX' (EF f))\"\n  shows \"x \\<in> EF f\"", "lemma EF_lem2a: assumes \"x \\<in> f\" shows \"x \\<in> EF f\"", "lemma EF_lem2c: assumes \"x \\<notin> f\" shows \"x \\<in> EF (- f)\"", "lemma EF_lem2d: assumes \"x \\<notin> EF f\" shows \"x \\<notin> f\"", "lemma EF_lem3b: assumes \"x \\<in> EX' (f \\<union> EX' (EF f))\" shows \"x \\<in> (EF f)\"", "lemma EX_lem0l: \"x \\<in> (EX' f) \\<Longrightarrow> x \\<in> (EX' (f \\<union> g))\"", "lemma EX_lem0r: \"x \\<in> (EX' g) \\<Longrightarrow> x \\<in> (EX' (f \\<union> g))\"", "lemma EX_step: assumes \"x  \\<rightarrow>\\<^sub>i y\" and \"y \\<in> f\" shows \"x \\<in> EX' f\"", "lemma EF_E[rule_format]: \"\\<forall> f. x \\<in> (EF f) \\<longrightarrow> x \\<in> (f \\<union> EX' (EF f))\"", "lemma EF_step: assumes \"x  \\<rightarrow>\\<^sub>i y\" and \"y \\<in> f\" shows \"x \\<in> EF f\"", "lemma EF_step_step: assumes \"x  \\<rightarrow>\\<^sub>i y\" and \"y \\<in> EF f\" shows  \"x \\<in> EF f\"", "lemma EF_step_star: \"\\<lbrakk> x  \\<rightarrow>\\<^sub>i* y; y \\<in> f \\<rbrakk> \\<Longrightarrow> x \\<in> EF f\"", "lemma EF_induct: \"(a::'a::state) \\<in> EF f \\<Longrightarrow>\n    mono (\\<lambda> Z. f \\<union> EX' Z) \\<Longrightarrow>\n    (\\<And>x. x \\<in> ((\\<lambda> Z. f \\<union> EX' Z)(EF f \\<inter> {x::'a::state. P x})) \\<Longrightarrow> P x) \\<Longrightarrow>\n    P a\"", "lemma valEF_E: \"M \\<turnstile> EF f \\<Longrightarrow> x \\<in> init M \\<Longrightarrow> x \\<in> EF f\"", "lemma EF_step_star_rev[rule_format]: \"x \\<in> EF s \\<Longrightarrow>  (\\<exists> y \\<in> s.  x  \\<rightarrow>\\<^sub>i* y)\"", "lemma EF_step_inv: \"(I \\<subseteq> {sa::'s :: state. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> EF s})  \n         \\<Longrightarrow> \\<forall> x \\<in> I. \\<exists> y \\<in> s. x \\<rightarrow>\\<^sub>i* y\"", "lemma AG_in_lem:   \"x \\<in> AG s \\<Longrightarrow> x \\<in> s\"", "lemma AG_lem1: \"x \\<in> s \\<and> x \\<in> (AX (AG s)) \\<Longrightarrow> x \\<in> AG s\"", "lemma AG_lem2: \"x \\<in> AG s \\<Longrightarrow> x \\<in> (s \\<inter> (AX (AG s)))\"", "lemma AG_lem3: \"AG s = (s \\<inter> (AX (AG s)))\"", "lemma AG_step: \"y \\<rightarrow>\\<^sub>i z \\<Longrightarrow> y \\<in> AG s \\<Longrightarrow> z \\<in> AG s\"", "lemma AG_all_s: \" x \\<rightarrow>\\<^sub>i* y \\<Longrightarrow> x \\<in> AG s \\<Longrightarrow> y \\<in> AG s\"", "lemma AG_imp_notnotEF: \n\"I \\<noteq> {} \\<Longrightarrow> ((Kripke {s. \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} I  \\<turnstile> AG s)) \\<Longrightarrow> \n (\\<not>(Kripke {s. \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} (I :: ('s :: state)set)  \\<turnstile> EF (- s)))\"", "lemma check2_def: \"(Kripke S I \\<turnstile> f) = (I \\<subseteq> S \\<inter> f)\""], "translations": [["", "lemma predtrans_empty: \n  assumes \"mono (\\<tau> :: 'a set \\<Rightarrow> 'a set)\"\n  shows \"\\<forall> i. (\\<tau> ^^ i) ({}) \\<subseteq> (\\<tau> ^^(i + 1))({})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. (\\<tau> ^^ i) {} \\<subseteq> (\\<tau> ^^ (i + 1)) {}", "using assms funpow_decreasing le_add1"], ["proof (prove)\nusing this:\n  mono \\<tau>\n  \\<lbrakk>?m \\<le> ?n; mono ?f\\<rbrakk>\n  \\<Longrightarrow> (?f ^^ ?m) bot \\<le> (?f ^^ ?n) bot\n  ?n \\<le> ?n + ?m\n\ngoal (1 subgoal):\n 1. \\<forall>i. (\\<tau> ^^ i) {} \\<subseteq> (\\<tau> ^^ (i + 1)) {}", "by blast"], ["", "lemma ex_card: \"finite S \\<Longrightarrow> \\<exists> n:: nat. card S = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow> \\<exists>n. card S = n", "by simp"], ["", "lemma less_not_le: \"\\<lbrakk>(x:: nat) < y; y \\<le> x\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y \\<le> x\\<rbrakk> \\<Longrightarrow> False", "by arith"], ["", "lemma infchain_outruns_all: \n  assumes \"finite (UNIV :: 'a set)\" \n    and \"\\<forall>i :: nat. ((\\<tau> :: 'a set \\<Rightarrow> 'a set)^^ i) ({}:: 'a set) \\<subset> (\\<tau> ^^ (i + 1)) {}\"\n  shows \"\\<forall>j :: nat. \\<exists>i :: nat. j < card ((\\<tau> ^^ i) {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j. \\<exists>i. j < card ((\\<tau> ^^ i) {})", "proof (rule allI, induct_tac j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j. \\<exists>i. 0 < card ((\\<tau> ^^ i) {})\n 2. \\<And>j n.\n       \\<exists>i. n < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n       \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})", "show \"\\<exists>i. 0 < card ((\\<tau> ^^ i) {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. 0 < card ((\\<tau> ^^ i) {})", "using assms"], ["proof (prove)\nusing this:\n  finite UNIV\n  \\<forall>i. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. \\<exists>i. 0 < card ((\\<tau> ^^ i) {})", "by (metis bot.not_eq_extremum card_gt_0_iff finite_subset subset_UNIV)"], ["proof (state)\nthis:\n  \\<exists>i. 0 < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. \\<And>j n.\n       \\<exists>i. n < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n       \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j n.\n       \\<exists>i. n < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n       \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})", "show \"\\<And>j n. \\<exists>i. n < card ((\\<tau> ^^ i) {}) \n             \\<Longrightarrow> \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j n.\n       \\<exists>i. n < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n       \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j n.\n       \\<exists>i. n < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n       \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})", "fix j n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j n.\n       \\<exists>i. n < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n       \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})", "assume a: \"\\<exists>i. n < card ((\\<tau> ^^ i) {})\""], ["proof (state)\nthis:\n  \\<exists>i. n < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. \\<And>j n.\n       \\<exists>i. n < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n       \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})", "obtain i where \"n < card ((\\<tau> ^^ i) {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        n < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using a"], ["proof (prove)\nusing this:\n  \\<exists>i. n < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        n < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. \\<And>j n.\n       \\<exists>i. n < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n       \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})", "thus \"\\<exists> i. Suc n < card ((\\<tau> ^^ i) {})\""], ["proof (prove)\nusing this:\n  n < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})", "using assms"], ["proof (prove)\nusing this:\n  n < card ((\\<tau> ^^ i) {})\n  finite UNIV\n  \\<forall>i. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})", "by (meson finite_subset le_less_trans le_simps(3) psubset_card_mono subset_UNIV)"], ["proof (state)\nthis:\n  \\<exists>i. Suc n < card ((\\<tau> ^^ i) {})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i. ?n < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n  \\<exists>i. Suc ?n < card ((\\<tau> ^^ i) {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_infinite_subset_chain: \n   assumes \"finite (UNIV :: 'a set)\"\n    and    \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n    and    \"\\<forall>i :: nat. ((\\<tau> :: 'a set \\<Rightarrow> 'a set) ^^ i) {} \\<subset> (\\<tau> ^^ (i + (1 :: nat))) ({} :: 'a set)\" \n  shows   \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "text \\<open>Proof idea: since @{term \"UNIV\"} is finite, we have from @{text \\<open>ex_card\\<close>} that there is\n    an n with @{term \"card UNIV = n\"}. Now, use @{text \\<open>infchain_outruns_all\\<close>} to show as \n    contradiction point that\n    @{term \"\\<exists> i :: nat. card UNIV < card ((\\<tau> ^^ i) {})\"}. \n    Since all sets are subsets of @{term \"UNIV\"}, we also have \n    @{term \"card ((\\<tau> ^^ i) {}) \\<le> card UNIV\"}:\n    Contradiction!, i.e. proof of False  \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have a: \"\\<forall> (j :: nat). (\\<exists> (i :: nat). (j :: nat) < card((\\<tau> ^^ i)({} :: 'a set)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j. \\<exists>i. j < card ((\\<tau> ^^ i) {})", "using assms"], ["proof (prove)\nusing this:\n  finite UNIV\n  mono \\<tau>\n  \\<forall>i. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. \\<forall>j. \\<exists>i. j < card ((\\<tau> ^^ i) {})", "by (erule_tac \\<tau> = \\<tau> in infchain_outruns_all)"], ["proof (state)\nthis:\n  \\<forall>j. \\<exists>i. j < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. False", "hence b: \"\\<exists> (n :: nat). card(UNIV :: 'a set) = n\""], ["proof (prove)\nusing this:\n  \\<forall>j. \\<exists>i. j < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. \\<exists>n. card UNIV = n", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>j. \\<exists>i. j < card ((\\<tau> ^^ i) {})\n  finite UNIV\n  mono \\<tau>\n  \\<forall>i. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. \\<exists>n. card UNIV = n", "by (erule_tac S = UNIV in ex_card)"], ["proof (state)\nthis:\n  \\<exists>n. card UNIV = n\n\ngoal (1 subgoal):\n 1. False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>n. card UNIV = n", "obtain n where c: \"card(UNIV :: 'a set) = n\""], ["proof (prove)\nusing this:\n  \\<exists>n. card UNIV = n\n\ngoal (1 subgoal):\n 1. (\\<And>n. card UNIV = n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule exE)"], ["proof (state)\nthis:\n  card UNIV = n\n\ngoal (1 subgoal):\n 1. False", "hence   d: \"\\<exists>i. card UNIV < card ((\\<tau> ^^ i) {})\""], ["proof (prove)\nusing this:\n  card UNIV = n\n\ngoal (1 subgoal):\n 1. \\<exists>i. card UNIV < card ((\\<tau> ^^ i) {})", "using a"], ["proof (prove)\nusing this:\n  card UNIV = n\n  \\<forall>j. \\<exists>i. j < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. \\<exists>i. card UNIV < card ((\\<tau> ^^ i) {})", "by (drule_tac x = \"card UNIV\" in spec)"], ["proof (state)\nthis:\n  \\<exists>i. card UNIV < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>i. card UNIV < card ((\\<tau> ^^ i) {})", "obtain i where e: \"card (UNIV :: 'a set) < card ((\\<tau> ^^ i) {})\""], ["proof (prove)\nusing this:\n  \\<exists>i. card UNIV < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        card UNIV < card ((\\<tau> ^^ i) {}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (erule exE)"], ["proof (state)\nthis:\n  card UNIV < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. False", "hence f: \"(card((\\<tau> ^^ i){})) \\<le> (card (UNIV :: 'a set))\""], ["proof (prove)\nusing this:\n  card UNIV < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. card ((\\<tau> ^^ i) {}) \\<le> card UNIV", "using assms"], ["proof (prove)\nusing this:\n  card UNIV < card ((\\<tau> ^^ i) {})\n  finite UNIV\n  mono \\<tau>\n  \\<forall>i. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. card ((\\<tau> ^^ i) {}) \\<le> card UNIV", "apply (erule_tac A = \"((\\<tau> ^^ i){})\" in Finite_Set.card_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>card UNIV < card ((\\<tau> ^^ i) {}); mono \\<tau>;\n     \\<forall>i. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {}\\<rbrakk>\n    \\<Longrightarrow> (\\<tau> ^^ i) {} \\<subseteq> UNIV", "by (rule subset_UNIV)"], ["proof (state)\nthis:\n  card ((\\<tau> ^^ i) {}) \\<le> card UNIV\n\ngoal (1 subgoal):\n 1. False", "thus \"False\""], ["proof (prove)\nusing this:\n  card ((\\<tau> ^^ i) {}) \\<le> card UNIV\n\ngoal (1 subgoal):\n 1. False", "using e"], ["proof (prove)\nusing this:\n  card ((\\<tau> ^^ i) {}) \\<le> card UNIV\n  card UNIV < card ((\\<tau> ^^ i) {})\n\ngoal (1 subgoal):\n 1. False", "by (erule_tac y = \"card((\\<tau> ^^ i){})\" in less_not_le)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_fixp: \n  assumes \"finite(UNIV :: 'a set)\" \n      and \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n    shows \"\\<exists> i. (\\<tau> ^^ i) ({}) = (\\<tau> ^^(i + 1))({})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}", "text \\<open>Proof idea: \nwith @{text predtrans_empty} we know \n\n@{term \"\\<forall> i. (\\<tau> ^^ i){} \\<subseteq> (\\<tau> ^^(i + 1))({})\"} (1).\n\nIf we can additionally show \n\n@{term \"\\<exists> i.  (\\<tau> ^^ i)({}) \\<supseteq> (\\<tau> ^^(i + 1))({})\"} (2),\n\nwe can get the goal together with equalityI \n@{text \"\\<subseteq> + \\<supseteq> \\<longrightarrow> =\"}. \nTo prove (1) we observe that \n@{term \"(\\<tau> ^^ i)({}) \\<supseteq> (\\<tau> ^^(i + 1))({})\"} \ncan be inferred from \n@{term \"\\<not>((\\<tau> ^^ i)({}) \\<subseteq> (\\<tau> ^^(i + 1))({}))\"} \nand (1).\nFinally, the latter is solved directly by @{text \\<open>no_infinite_subset_chain\\<close>}.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}", "have a: \"\\<forall>i. (\\<tau> ^^ i) ({}:: 'a set) \\<subseteq> (\\<tau> ^^ (i + (1))) {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. (\\<tau> ^^ i) {} \\<subseteq> (\\<tau> ^^ (i + 1)) {}", "by(rule predtrans_empty, rule assms(2))"], ["proof (state)\nthis:\n  \\<forall>i. (\\<tau> ^^ i) {} \\<subseteq> (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}", "have a3: \"\\<not> (\\<forall> i :: nat. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^(i + 1)) {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {})", "by (rule notI, rule no_infinite_subset_chain, (rule assms)+)"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {})\n\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}", "hence b: \"(\\<exists> i :: nat. \\<not>((\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^(i + 1)) {}))\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {})\n\ngoal (1 subgoal):\n 1. \\<exists>i. \\<not> (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {}", "using assms a3"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {})\n  finite UNIV\n  mono \\<tau>\n  \\<not> (\\<forall>i. (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {})\n\ngoal (1 subgoal):\n 1. \\<exists>i. \\<not> (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. \\<not> (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}", "thus \"\\<exists> i. (\\<tau> ^^ i) ({}) = (\\<tau> ^^(i + 1))({})\""], ["proof (prove)\nusing this:\n  \\<exists>i. \\<not> (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}", "using a"], ["proof (prove)\nusing this:\n  \\<exists>i. \\<not> (\\<tau> ^^ i) {} \\<subset> (\\<tau> ^^ (i + 1)) {}\n  \\<forall>i. (\\<tau> ^^ i) {} \\<subseteq> (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma predtrans_UNIV: \n  assumes \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n  shows \"\\<forall> i. (\\<tau> ^^ i) (UNIV) \\<supseteq> (\\<tau> ^^(i + 1))(UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subseteq> (\\<tau> ^^ i) UNIV", "proof (rule allI, induct_tac i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. (\\<tau> ^^ (0 + 1)) UNIV \\<subseteq> (\\<tau> ^^ 0) UNIV\n 2. \\<And>i n.\n       (\\<tau> ^^ (n + 1)) UNIV\n       \\<subseteq> (\\<tau> ^^ n) UNIV \\<Longrightarrow>\n       (\\<tau> ^^ (Suc n + 1)) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV", "show \"(\\<tau> ^^ ((0) + (1))) UNIV \\<subseteq> (\\<tau> ^^ (0)) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> ^^ (0 + 1)) UNIV \\<subseteq> (\\<tau> ^^ 0) UNIV", "by simp"], ["proof (state)\nthis:\n  (\\<tau> ^^ (0 + 1)) UNIV \\<subseteq> (\\<tau> ^^ 0) UNIV\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       (\\<tau> ^^ (n + 1)) UNIV\n       \\<subseteq> (\\<tau> ^^ n) UNIV \\<Longrightarrow>\n       (\\<tau> ^^ (Suc n + 1)) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       (\\<tau> ^^ (n + 1)) UNIV\n       \\<subseteq> (\\<tau> ^^ n) UNIV \\<Longrightarrow>\n       (\\<tau> ^^ (Suc n + 1)) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV", "show \"\\<And>(i) n.\n       (\\<tau> ^^ (n + (1))) UNIV \\<subseteq> (\\<tau> ^^ n) UNIV \\<Longrightarrow> (\\<tau> ^^ (Suc n + (1))) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       (\\<tau> ^^ (n + 1)) UNIV\n       \\<subseteq> (\\<tau> ^^ n) UNIV \\<Longrightarrow>\n       (\\<tau> ^^ (Suc n + 1)) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       (\\<tau> ^^ (n + 1)) UNIV\n       \\<subseteq> (\\<tau> ^^ n) UNIV \\<Longrightarrow>\n       (\\<tau> ^^ (Suc n + 1)) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV", "fix i n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       (\\<tau> ^^ (n + 1)) UNIV\n       \\<subseteq> (\\<tau> ^^ n) UNIV \\<Longrightarrow>\n       (\\<tau> ^^ (Suc n + 1)) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV", "assume a: \"(\\<tau> ^^ (n + (1))) UNIV \\<subseteq> (\\<tau> ^^ n) UNIV\""], ["proof (state)\nthis:\n  (\\<tau> ^^ (n + 1)) UNIV \\<subseteq> (\\<tau> ^^ n) UNIV\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       (\\<tau> ^^ (n + 1)) UNIV\n       \\<subseteq> (\\<tau> ^^ n) UNIV \\<Longrightarrow>\n       (\\<tau> ^^ (Suc n + 1)) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV", "have \"(\\<tau> ((\\<tau> ^^ n) UNIV)) \\<supseteq> (\\<tau> ((\\<tau> ^^ (n + (1 :: nat))) UNIV))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> ((\\<tau> ^^ (n + 1)) UNIV)\n    \\<subseteq> \\<tau> ((\\<tau> ^^ n) UNIV)", "using assms a"], ["proof (prove)\nusing this:\n  mono \\<tau>\n  (\\<tau> ^^ (n + 1)) UNIV \\<subseteq> (\\<tau> ^^ n) UNIV\n\ngoal (1 subgoal):\n 1. \\<tau> ((\\<tau> ^^ (n + 1)) UNIV)\n    \\<subseteq> \\<tau> ((\\<tau> ^^ n) UNIV)", "by (rule monoE)"], ["proof (state)\nthis:\n  \\<tau> ((\\<tau> ^^ (n + 1)) UNIV) \\<subseteq> \\<tau> ((\\<tau> ^^ n) UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       (\\<tau> ^^ (n + 1)) UNIV\n       \\<subseteq> (\\<tau> ^^ n) UNIV \\<Longrightarrow>\n       (\\<tau> ^^ (Suc n + 1)) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV", "thus \"(\\<tau> ^^ (Suc n + (1))) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV\""], ["proof (prove)\nusing this:\n  \\<tau> ((\\<tau> ^^ (n + 1)) UNIV) \\<subseteq> \\<tau> ((\\<tau> ^^ n) UNIV)\n\ngoal (1 subgoal):\n 1. (\\<tau> ^^ (Suc n + 1)) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV", "by simp"], ["proof (state)\nthis:\n  (\\<tau> ^^ (Suc n + 1)) UNIV \\<subseteq> (\\<tau> ^^ Suc n) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<tau> ^^ (?n + 1)) UNIV\n  \\<subseteq> (\\<tau> ^^ ?n) UNIV \\<Longrightarrow>\n  (\\<tau> ^^ (Suc ?n + 1)) UNIV \\<subseteq> (\\<tau> ^^ Suc ?n) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Suc_less_le: \"x < (y - n) \\<Longrightarrow> x \\<le> (y - (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y - n \\<Longrightarrow> x \\<le> y - Suc n", "by simp"], ["", "lemma card_univ_subtract: \n  assumes \"finite (UNIV :: 'a set)\" and  \"mono \\<tau>\"\n     and  \"(\\<forall>i :: nat. ((\\<tau> :: 'a set \\<Rightarrow> 'a set) ^^ (i + (1 :: nat)))(UNIV :: 'a set) \\<subset> (\\<tau> ^^ i) UNIV)\"\n   shows \"(\\<forall> i :: nat. card((\\<tau> ^^ i) (UNIV ::'a set)) \\<le> (card (UNIV :: 'a set)) - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. card ((\\<tau> ^^ i) UNIV) \\<le> card UNIV - i", "proof (rule allI, induct_tac i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. card ((\\<tau> ^^ 0) UNIV) \\<le> card UNIV - 0\n 2. \\<And>i n.\n       card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n \\<Longrightarrow>\n       card ((\\<tau> ^^ Suc n) UNIV) \\<le> card UNIV - Suc n", "show \"card ((\\<tau> ^^ (0)) UNIV) \\<le> card (UNIV :: 'a set) - (0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<tau> ^^ 0) UNIV) \\<le> card UNIV - 0", "using assms"], ["proof (prove)\nusing this:\n  finite UNIV\n  mono \\<tau>\n  \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\n\ngoal (1 subgoal):\n 1. card ((\\<tau> ^^ 0) UNIV) \\<le> card UNIV - 0", "by (simp)"], ["proof (state)\nthis:\n  card ((\\<tau> ^^ 0) UNIV) \\<le> card UNIV - 0\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n \\<Longrightarrow>\n       card ((\\<tau> ^^ Suc n) UNIV) \\<le> card UNIV - Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n \\<Longrightarrow>\n       card ((\\<tau> ^^ Suc n) UNIV) \\<le> card UNIV - Suc n", "show \"\\<And>(i) n.\n       card ((\\<tau> ^^ n) (UNIV :: 'a set)) \\<le> card (UNIV :: 'a set) - n \\<Longrightarrow>\n       card ((\\<tau> ^^ Suc n) (UNIV :: 'a set)) \\<le> card (UNIV :: 'a set) - Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n \\<Longrightarrow>\n       card ((\\<tau> ^^ Suc n) UNIV) \\<le> card UNIV - Suc n", "using assms"], ["proof (prove)\nusing this:\n  finite UNIV\n  mono \\<tau>\n  \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n \\<Longrightarrow>\n       card ((\\<tau> ^^ Suc n) UNIV) \\<le> card UNIV - Suc n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n; finite UNIV;\n        mono \\<tau>;\n        \\<forall>i.\n           (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\\<rbrakk>\n       \\<Longrightarrow> card ((\\<tau> ^^ Suc n) UNIV)\n                         \\<le> card UNIV - Suc n", "fix i n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n; finite UNIV;\n        mono \\<tau>;\n        \\<forall>i.\n           (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\\<rbrakk>\n       \\<Longrightarrow> card ((\\<tau> ^^ Suc n) UNIV)\n                         \\<le> card UNIV - Suc n", "assume a: \"card ((\\<tau> ^^ n) (UNIV :: 'a set)) \\<le> card (UNIV :: 'a set) - n\""], ["proof (state)\nthis:\n  card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n; finite UNIV;\n        mono \\<tau>;\n        \\<forall>i.\n           (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\\<rbrakk>\n       \\<Longrightarrow> card ((\\<tau> ^^ Suc n) UNIV)\n                         \\<le> card UNIV - Suc n", "have b: \"(\\<tau> ^^ (n + (1)))(UNIV :: 'a set) \\<subset> (\\<tau> ^^ n) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> ^^ (n + 1)) UNIV \\<subset> (\\<tau> ^^ n) UNIV", "using assms"], ["proof (prove)\nusing this:\n  finite UNIV\n  mono \\<tau>\n  \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\n\ngoal (1 subgoal):\n 1. (\\<tau> ^^ (n + 1)) UNIV \\<subset> (\\<tau> ^^ n) UNIV", "by (erule_tac x = n in spec)"], ["proof (state)\nthis:\n  (\\<tau> ^^ (n + 1)) UNIV \\<subset> (\\<tau> ^^ n) UNIV\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n; finite UNIV;\n        mono \\<tau>;\n        \\<forall>i.\n           (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\\<rbrakk>\n       \\<Longrightarrow> card ((\\<tau> ^^ Suc n) UNIV)\n                         \\<le> card UNIV - Suc n", "have \"card((\\<tau> ^^ (n + (1 :: nat)))(UNIV :: 'a set)) < card((\\<tau> ^^ n) (UNIV :: 'a set))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<tau> ^^ (n + 1)) UNIV) < card ((\\<tau> ^^ n) UNIV)", "by (rule psubset_card_mono, rule finite_subset, rule subset_UNIV, rule assms(1), rule b)"], ["proof (state)\nthis:\n  card ((\\<tau> ^^ (n + 1)) UNIV) < card ((\\<tau> ^^ n) UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<lbrakk>card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n; finite UNIV;\n        mono \\<tau>;\n        \\<forall>i.\n           (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\\<rbrakk>\n       \\<Longrightarrow> card ((\\<tau> ^^ Suc n) UNIV)\n                         \\<le> card UNIV - Suc n", "thus \"card ((\\<tau> ^^ Suc n) (UNIV :: 'a set)) \\<le> card (UNIV :: 'a set) - Suc n\""], ["proof (prove)\nusing this:\n  card ((\\<tau> ^^ (n + 1)) UNIV) < card ((\\<tau> ^^ n) UNIV)\n\ngoal (1 subgoal):\n 1. card ((\\<tau> ^^ Suc n) UNIV) \\<le> card UNIV - Suc n", "using a"], ["proof (prove)\nusing this:\n  card ((\\<tau> ^^ (n + 1)) UNIV) < card ((\\<tau> ^^ n) UNIV)\n  card ((\\<tau> ^^ n) UNIV) \\<le> card UNIV - n\n\ngoal (1 subgoal):\n 1. card ((\\<tau> ^^ Suc n) UNIV) \\<le> card UNIV - Suc n", "by simp"], ["proof (state)\nthis:\n  card ((\\<tau> ^^ Suc n) UNIV) \\<le> card UNIV - Suc n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card ((\\<tau> ^^ ?n) UNIV) \\<le> card UNIV - ?n \\<Longrightarrow>\n  card ((\\<tau> ^^ Suc ?n) UNIV) \\<le> card UNIV - Suc ?n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_UNIV_tau_i_below_zero: \n  assumes \"finite (UNIV :: 'a set)\" and \"mono \\<tau>\"\n   and  \"(\\<forall>i :: nat. ((\\<tau> :: ('a set \\<Rightarrow> 'a set)) ^^ (i + (1 :: nat)))(UNIV :: 'a set) \\<subset> (\\<tau> ^^ i) UNIV)\"\n shows \"card((\\<tau> ^^ (card (UNIV ::'a set))) (UNIV ::'a set)) \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<tau> ^^ card UNIV) UNIV) \\<le> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card ((\\<tau> ^^ card UNIV) UNIV) \\<le> 0", "have \"(\\<forall> i :: nat. card((\\<tau> ^^ i) (UNIV ::'a set)) \\<le> (card (UNIV :: 'a set)) - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. card ((\\<tau> ^^ i) UNIV) \\<le> card UNIV - i", "using assms"], ["proof (prove)\nusing this:\n  finite UNIV\n  mono \\<tau>\n  \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\n\ngoal (1 subgoal):\n 1. \\<forall>i. card ((\\<tau> ^^ i) UNIV) \\<le> card UNIV - i", "by (rule card_univ_subtract)"], ["proof (state)\nthis:\n  \\<forall>i. card ((\\<tau> ^^ i) UNIV) \\<le> card UNIV - i\n\ngoal (1 subgoal):\n 1. card ((\\<tau> ^^ card UNIV) UNIV) \\<le> 0", "thus \"card((\\<tau> ^^ (card (UNIV ::'a set))) (UNIV ::'a set)) \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<forall>i. card ((\\<tau> ^^ i) UNIV) \\<le> card UNIV - i\n\ngoal (1 subgoal):\n 1. card ((\\<tau> ^^ card UNIV) UNIV) \\<le> 0", "by (drule_tac x = \"card (UNIV ::'a set)\" in spec, simp)"], ["proof (state)\nthis:\n  card ((\\<tau> ^^ card UNIV) UNIV) \\<le> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_card_zero_empty: \"\\<lbrakk> finite S; card S \\<le> 0\\<rbrakk> \\<Longrightarrow> S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S; card S \\<le> 0\\<rbrakk> \\<Longrightarrow> S = {}", "by simp"], ["", "lemma UNIV_tau_i_is_empty:\n  assumes \"finite (UNIV :: 'a set)\" and \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n    and   \"(\\<forall>i :: nat. ((\\<tau> :: 'a set \\<Rightarrow> 'a set) ^^ (i + (1 :: nat)))(UNIV :: 'a set) \\<subset> (\\<tau> ^^ i) UNIV)\"\n  shows \"(\\<tau> ^^ (card (UNIV ::'a set))) (UNIV ::'a set) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> ^^ card UNIV) UNIV = {}", "by (meson assms card_UNIV_tau_i_below_zero finite_card_zero_empty finite_subset subset_UNIV)"], ["", "lemma down_chain_reaches_empty:\n  assumes \"finite (UNIV :: 'a set)\" and \"mono (\\<tau> :: 'a set \\<Rightarrow> 'a set)\"\n   and \"(\\<forall>i :: nat. ((\\<tau> :: 'a set \\<Rightarrow> 'a set) ^^ (i + (1 :: nat))) UNIV \\<subset> (\\<tau> ^^ i) UNIV)\"\n shows \"\\<exists> (j :: nat). (\\<tau> ^^ j) UNIV = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j. (\\<tau> ^^ j) UNIV = {}", "using UNIV_tau_i_is_empty assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite UNIV; mono ?\\<tau>;\n   \\<forall>i.\n      (?\\<tau> ^^ (i + 1)) UNIV \\<subset> (?\\<tau> ^^ i) UNIV\\<rbrakk>\n  \\<Longrightarrow> (?\\<tau> ^^ card UNIV) UNIV = {}\n  finite UNIV\n  mono \\<tau>\n  \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>j. (\\<tau> ^^ j) UNIV = {}", "by blast"], ["", "lemma no_infinite_subset_chain2: \n  assumes \"finite (UNIV :: 'a set)\" and \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n      and \"\\<forall>i :: nat. (\\<tau> ^^ i) UNIV \\<supset> (\\<tau> ^^ (i + (1 :: nat))) UNIV\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<exists> j :: nat. (\\<tau> ^^ j) UNIV = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j. (\\<tau> ^^ j) UNIV = {}", "using assms"], ["proof (prove)\nusing this:\n  finite UNIV\n  mono \\<tau>\n  \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>j. (\\<tau> ^^ j) UNIV = {}", "by (rule down_chain_reaches_empty)"], ["proof (state)\nthis:\n  \\<exists>j. (\\<tau> ^^ j) UNIV = {}\n\ngoal (1 subgoal):\n 1. False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>j. (\\<tau> ^^ j) UNIV = {}", "obtain j where a: \"(\\<tau> ^^ j) UNIV = {}\""], ["proof (prove)\nusing this:\n  \\<exists>j. (\\<tau> ^^ j) UNIV = {}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        (\\<tau> ^^ j) UNIV = {} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule exE)"], ["proof (state)\nthis:\n  (\\<tau> ^^ j) UNIV = {}\n\ngoal (1 subgoal):\n 1. False", "have \"(\\<tau> ^^ (j + (1))) UNIV \\<subset> (\\<tau> ^^ j) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> ^^ (j + 1)) UNIV \\<subset> (\\<tau> ^^ j) UNIV", "using assms"], ["proof (prove)\nusing this:\n  finite UNIV\n  mono \\<tau>\n  \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\n\ngoal (1 subgoal):\n 1. (\\<tau> ^^ (j + 1)) UNIV \\<subset> (\\<tau> ^^ j) UNIV", "by (erule_tac x = j in spec)"], ["proof (state)\nthis:\n  (\\<tau> ^^ (j + 1)) UNIV \\<subset> (\\<tau> ^^ j) UNIV\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  (\\<tau> ^^ (j + 1)) UNIV \\<subset> (\\<tau> ^^ j) UNIV\n\ngoal (1 subgoal):\n 1. False", "using a"], ["proof (prove)\nusing this:\n  (\\<tau> ^^ (j + 1)) UNIV \\<subset> (\\<tau> ^^ j) UNIV\n  (\\<tau> ^^ j) UNIV = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_fixp2: \n  assumes \"finite(UNIV :: 'a set)\" and \"mono (\\<tau> :: ('a set \\<Rightarrow> 'a set))\"\n  shows \"\\<exists> i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^(i + 1)) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV", "have \"\\<forall>i. (\\<tau> ^^ (i + (1))) UNIV \\<subseteq> (\\<tau> ^^ i) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subseteq> (\\<tau> ^^ i) UNIV", "by (rule predtrans_UNIV , simp add: assms(2))"], ["proof (state)\nthis:\n  \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subseteq> (\\<tau> ^^ i) UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV", "moreover"], ["proof (state)\nthis:\n  \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subseteq> (\\<tau> ^^ i) UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV", "have \"\\<exists>i. \\<not> (\\<tau> ^^ (i + (1))) UNIV \\<subset> (\\<tau> ^^ i) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. \\<not> (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV", "using assms"], ["proof (prove)\nusing this:\n  finite UNIV\n  mono \\<tau>\n\ngoal (1 subgoal):\n 1. \\<exists>i. \\<not> (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite UNIV; mono \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         \\<not> (\\<tau> ^^ (i + 1)) UNIV\n                                \\<subset> (\\<tau> ^^ i) UNIV", "have \"\\<not> (\\<forall> i :: nat. (\\<tau> ^^ i) UNIV \\<supset> (\\<tau> ^^(i + 1)) UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV)", "using assms(1) assms(2) no_infinite_subset_chain2"], ["proof (prove)\nusing this:\n  finite UNIV\n  mono \\<tau>\n  \\<lbrakk>finite UNIV; mono ?\\<tau>;\n   \\<forall>i.\n      (?\\<tau> ^^ (i + 1)) UNIV \\<subset> (?\\<tau> ^^ i) UNIV\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i.\n               (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV)", "by blast"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite UNIV; mono \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i.\n                         \\<not> (\\<tau> ^^ (i + 1)) UNIV\n                                \\<subset> (\\<tau> ^^ i) UNIV", "thus \"\\<exists>i. \\<not> (\\<tau> ^^ (i + (1))) UNIV \\<subset> (\\<tau> ^^ i) UNIV\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV)\n\ngoal (1 subgoal):\n 1. \\<exists>i. \\<not> (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. \\<not> (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i. \\<not> (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subseteq> (\\<tau> ^^ i) UNIV\n  \\<exists>i. \\<not> (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV", "show \"\\<exists> i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^(i + 1)) UNIV\""], ["proof (prove)\nusing this:\n  \\<forall>i. (\\<tau> ^^ (i + 1)) UNIV \\<subseteq> (\\<tau> ^^ i) UNIV\n  \\<exists>i. \\<not> (\\<tau> ^^ (i + 1)) UNIV \\<subset> (\\<tau> ^^ i) UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfp_loop: \n  assumes \"finite (UNIV :: 'b set)\" and \"mono (\\<tau> :: ('b set \\<Rightarrow> 'b set))\"\n  shows \"\\<exists> n . lfp \\<tau>  = (\\<tau> ^^ n) {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. lfp \\<tau> = (\\<tau> ^^ n) {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. lfp \\<tau> = (\\<tau> ^^ n) {}", "have \"\\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + (1))) {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}", "using assms"], ["proof (prove)\nusing this:\n  finite UNIV\n  mono \\<tau>\n\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}", "by (rule finite_fixp)"], ["proof (state)\nthis:\n  \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. \\<exists>n. lfp \\<tau> = (\\<tau> ^^ n) {}", "from this"], ["proof (chain)\npicking this:\n  \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}", "obtain i where \" (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + (1))) {}\""], ["proof (prove)\nusing this:\n  \\<exists>i. (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (erule exE)"], ["proof (state)\nthis:\n  (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. \\<exists>n. lfp \\<tau> = (\\<tau> ^^ n) {}", "hence \"(\\<tau> ^^ i) {} = (\\<tau> ^^ Suc i) {}\""], ["proof (prove)\nusing this:\n  (\\<tau> ^^ i) {} = (\\<tau> ^^ (i + 1)) {}\n\ngoal (1 subgoal):\n 1. (\\<tau> ^^ i) {} = (\\<tau> ^^ Suc i) {}", "by simp"], ["proof (state)\nthis:\n  (\\<tau> ^^ i) {} = (\\<tau> ^^ Suc i) {}\n\ngoal (1 subgoal):\n 1. \\<exists>n. lfp \\<tau> = (\\<tau> ^^ n) {}", "hence \"(\\<tau> ^^ Suc i) {} = (\\<tau> ^^ i) {}\""], ["proof (prove)\nusing this:\n  (\\<tau> ^^ i) {} = (\\<tau> ^^ Suc i) {}\n\ngoal (1 subgoal):\n 1. (\\<tau> ^^ Suc i) {} = (\\<tau> ^^ i) {}", "by (rule sym)"], ["proof (state)\nthis:\n  (\\<tau> ^^ Suc i) {} = (\\<tau> ^^ i) {}\n\ngoal (1 subgoal):\n 1. \\<exists>n. lfp \\<tau> = (\\<tau> ^^ n) {}", "hence \"lfp \\<tau> = (\\<tau> ^^ i) {}\""], ["proof (prove)\nusing this:\n  (\\<tau> ^^ Suc i) {} = (\\<tau> ^^ i) {}\n\ngoal (1 subgoal):\n 1. lfp \\<tau> = (\\<tau> ^^ i) {}", "by (simp add: assms(2) lfp_Kleene_iter)"], ["proof (state)\nthis:\n  lfp \\<tau> = (\\<tau> ^^ i) {}\n\ngoal (1 subgoal):\n 1. \\<exists>n. lfp \\<tau> = (\\<tau> ^^ n) {}", "thus \"\\<exists> n . lfp \\<tau>  = (\\<tau> ^^ n) {}\""], ["proof (prove)\nusing this:\n  lfp \\<tau> = (\\<tau> ^^ i) {}\n\ngoal (1 subgoal):\n 1. \\<exists>n. lfp \\<tau> = (\\<tau> ^^ n) {}", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>n. lfp \\<tau> = (\\<tau> ^^ n) {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>These next two are repeated from the corresponding\n   theorems in HOL/ZF/Nat.thy for the sake of self-containedness of the exposition.\\<close>"], ["", "lemma Kleene_iter_gpfp:\n  assumes \"mono f\" and \"p \\<le> f p\" shows \"p \\<le> (f^^k) (top::'a::order_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> (f ^^ k) top", "proof(induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<le> (f ^^ 0) top\n 2. \\<And>k. p \\<le> (f ^^ k) top \\<Longrightarrow> p \\<le> (f ^^ Suc k) top", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. p \\<le> (f ^^ 0) top\n 2. \\<And>k. p \\<le> (f ^^ k) top \\<Longrightarrow> p \\<le> (f ^^ Suc k) top", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> (f ^^ 0) top", "by simp"], ["proof (state)\nthis:\n  p \\<le> (f ^^ 0) top\n\ngoal (1 subgoal):\n 1. \\<And>k. p \\<le> (f ^^ k) top \\<Longrightarrow> p \\<le> (f ^^ Suc k) top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. p \\<le> (f ^^ k) top \\<Longrightarrow> p \\<le> (f ^^ Suc k) top", "case Suc"], ["proof (state)\nthis:\n  p \\<le> (f ^^ k_) top\n\ngoal (1 subgoal):\n 1. \\<And>k. p \\<le> (f ^^ k) top \\<Longrightarrow> p \\<le> (f ^^ Suc k) top", "from monoD[OF assms(1) Suc] assms(2)"], ["proof (chain)\npicking this:\n  f p \\<le> f ((f ^^ k_) top)\n  p \\<le> f p", "show ?case"], ["proof (prove)\nusing this:\n  f p \\<le> f ((f ^^ k_) top)\n  p \\<le> f p\n\ngoal (1 subgoal):\n 1. p \\<le> (f ^^ Suc k_) top", "by simp"], ["proof (state)\nthis:\n  p \\<le> (f ^^ Suc k_) top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gfp_loop: \n  assumes \"finite (UNIV :: 'b set)\"\n   and \"mono (\\<tau> :: ('b set \\<Rightarrow> 'b set))\"\n    shows \"\\<exists> n . gfp \\<tau>  = (\\<tau> ^^ n)UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. gfp \\<tau> = (\\<tau> ^^ n) UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. gfp \\<tau> = (\\<tau> ^^ n) UNIV", "have \" \\<exists>i. (\\<tau> ^^ i)(UNIV :: 'b set) = (\\<tau> ^^ (i + (1))) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV", "using assms"], ["proof (prove)\nusing this:\n  finite UNIV\n  mono \\<tau>\n\ngoal (1 subgoal):\n 1. \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV", "by (rule finite_fixp2)"], ["proof (state)\nthis:\n  \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>n. gfp \\<tau> = (\\<tau> ^^ n) UNIV", "from this"], ["proof (chain)\npicking this:\n  \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV", "obtain i where \"(\\<tau> ^^ i)UNIV = (\\<tau> ^^ (i + (1))) UNIV\""], ["proof (prove)\nusing this:\n  \\<exists>i. (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (erule exE)"], ["proof (state)\nthis:\n  (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>n. gfp \\<tau> = (\\<tau> ^^ n) UNIV", "thus \"\\<exists> n . gfp \\<tau>  = (\\<tau> ^^ n)UNIV\""], ["proof (prove)\nusing this:\n  (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>n. gfp \\<tau> = (\\<tau> ^^ n) UNIV", "using assms"], ["proof (prove)\nusing this:\n  (\\<tau> ^^ i) UNIV = (\\<tau> ^^ (i + 1)) UNIV\n  finite UNIV\n  mono \\<tau>\n\ngoal (1 subgoal):\n 1. \\<exists>n. gfp \\<tau> = (\\<tau> ^^ n) UNIV", "by (metis Suc_eq_plus1 gfp_Kleene_iter)"], ["proof (state)\nthis:\n  \\<exists>n. gfp \\<tau> = (\\<tau> ^^ n) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Generic type of state with state transition and CTL operators\\<close>"], ["", "text \\<open>The system states and their transition relation are defined as a class called\n @{text \\<open>state\\<close>} containing an abstract constant@{text \\<open>state_transition\\<close>}. It introduces the \nsyntactic infix notation @{text \\<open>I \\<rightarrow>\\<^sub>i I'\\<close>} to denote that system state @{text \\<open>I\\<close>} and @{text \\<open>I?\\<close>} \nare in this relation over an arbitrary (polymorphic) type @{text \\<open>'a\\<close>}.\\<close>"], ["", "class state =\n  fixes state_transition :: \"['a :: type, 'a] \\<Rightarrow> bool\"  (infixr \"\\<rightarrow>\\<^sub>i\" 50)"], ["", "text \\<open>The above class definition lifts Kripke structures and CTL to a general level. \nThe definition of the inductive relation is given by a set of specific rules which are, \nhowever, part of an application like infrastructures. Branching time temporal logic CTL \nis defined in general over Kripke structures with arbitrary state transitions and can later \nbe applied to suitable theories, like infrastructures.\nBased on the generic state transition @{text \\<open>\\<rightarrow>\\<close>} of the type class state, the CTL-operators \nEX and AX express that property f holds in some or all next states, respectively.\\<close>"], ["", "definition AX where \"AX f \\<equiv> {s. {f0. s \\<rightarrow>\\<^sub>i f0} \\<subseteq> f}\""], ["", "definition EX' where \"EX' f \\<equiv> {s . \\<exists> f0 \\<in> f. s \\<rightarrow>\\<^sub>i f0 }\""], ["", "text \\<open>The CTL formula @{text \\<open>AG f\\<close>} means that on all paths branching from a state @{text \\<open>s\\<close>} \nthe formula @{text \\<open>f\\<close>} is always true (@{text \\<open>G\\<close>} stands for ?globally?). It can be defined \nusing the Tarski fixpoint theory by applying the greatest fixpoint operator. In a similar way, \nthe other CTL operators are defined.\\<close>"], ["", "definition AF where \"AF f \\<equiv> lfp (\\<lambda> Z. f \\<union> AX Z)\""], ["", "definition EF where \"EF f \\<equiv> lfp (\\<lambda> Z. f \\<union> EX' Z)\""], ["", "definition AG where \"AG f \\<equiv> gfp (\\<lambda> Z. f \\<inter> AX Z)\""], ["", "definition EG where \"EG f \\<equiv> gfp (\\<lambda> Z. f \\<inter> EX' Z)\""], ["", "definition AU where \"AU f1 f2 \\<equiv> lfp(\\<lambda> Z. f2 \\<union> (f1 \\<inter> AX Z))\""], ["", "definition EU where \"EU f1 f2 \\<equiv> lfp(\\<lambda> Z. f2 \\<union> (f1 \\<inter> EX' Z))\""], ["", "definition AR where \"AR f1 f2 \\<equiv> gfp(\\<lambda> Z. f2 \\<inter> (f1 \\<union> AX Z))\""], ["", "definition ER where \"ER f1 f2 \\<equiv> gfp(\\<lambda> Z. f2 \\<inter> (f1 \\<union> EX' Z))\""], ["", "subsection  \\<open>Kripke structures and Modelchecking\\<close>"], ["", "datatype 'a kripke = \n  Kripke \"'a set\" \"'a set\""], ["", "primrec states where \"states (Kripke S I) = S\""], ["", "primrec init where \"init (Kripke S I) = I\""], ["", "text \\<open>The formal Isabelle definition of what it means that formula f holds \nin a Kripke structure M can be stated as: the initial states of the Kripke \nstructure init M need to be contained in the set of all states states M that \nimply f.\\<close>"], ["", "definition check (\"_ \\<turnstile> _\" 50)\n where \"M \\<turnstile> f \\<equiv> (init M) \\<subseteq> {s \\<in> (states M). s \\<in> f }\""], ["", "definition state_transition_refl (infixr \"\\<rightarrow>\\<^sub>i*\" 50)\nwhere \"s \\<rightarrow>\\<^sub>i* s' \\<equiv> ((s,s') \\<in> {(x,y). state_transition x y}\\<^sup>*)\""], ["", "subsection \\<open>Lemmas for CTL operators\\<close>"], ["", "subsubsection \\<open>EF lemmas\\<close>"], ["", "lemma EF_lem0: \"(x \\<in> EF f) = (x \\<in> f \\<union> EX' (lfp (\\<lambda>Z :: ('a :: state) set. f \\<union> EX' Z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> EF f) =\n    (x \\<in> f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<in> EF f) =\n    (x \\<in> f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z)))", "have \"lfp (\\<lambda>Z :: ('a :: state) set. f \\<union> EX' Z) = \n                    f \\<union> (EX' (lfp (\\<lambda>Z :: 'a set. f \\<union> EX' Z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>Z. f \\<union> EX' Z) =\n    f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z))", "by (rule def_lfp_unfold, rule reflexive, unfold mono_def EX'_def, auto)"], ["proof (state)\nthis:\n  lfp (\\<lambda>Z. f \\<union> EX' Z) =\n  f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z))\n\ngoal (1 subgoal):\n 1. (x \\<in> EF f) =\n    (x \\<in> f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z)))", "thus \"(x \\<in> EF (f :: ('a :: state) set)) = (x \\<in> f \\<union> EX' (lfp (\\<lambda>Z :: ('a :: state) set. f \\<union> EX' Z)))\""], ["proof (prove)\nusing this:\n  lfp (\\<lambda>Z. f \\<union> EX' Z) =\n  f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z))\n\ngoal (1 subgoal):\n 1. (x \\<in> EF f) =\n    (x \\<in> f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z)))", "by (simp add: EF_def)"], ["proof (state)\nthis:\n  (x \\<in> EF f) =\n  (x \\<in> f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma EF_lem00: \"(EF f) = (f \\<union> EX' (lfp (\\<lambda> Z :: ('a :: state) set. f \\<union> EX' Z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EF f = f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z))", "by (auto simp: EF_lem0)"], ["", "lemma EF_lem000: \"(EF f) = (f \\<union> EX' (EF f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EF f = f \\<union> EX' (EF f)", "by (metis EF_def EF_lem00)"], ["", "lemma EF_lem1: \"x \\<in> f \\<or> x \\<in> (EX' (EF f)) \\<Longrightarrow> x \\<in> EF f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> f \\<or> x \\<in> EX' (EF f) \\<Longrightarrow> x \\<in> EF f", "proof (simp add: EF_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> f \\<or>\n    x \\<in> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z)) \\<Longrightarrow>\n    x \\<in> lfp (\\<lambda>Z. f \\<union> EX' Z)", "assume a: \"x \\<in> f \\<or> x \\<in> EX' (lfp (\\<lambda>Z::'a set. f \\<union> EX' Z))\""], ["proof (state)\nthis:\n  x \\<in> f \\<or> x \\<in> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z))\n\ngoal (1 subgoal):\n 1. x \\<in> f \\<or>\n    x \\<in> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z)) \\<Longrightarrow>\n    x \\<in> lfp (\\<lambda>Z. f \\<union> EX' Z)", "show \"x \\<in> lfp (\\<lambda>Z::'a set. f \\<union> EX' Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lfp (\\<lambda>Z. f \\<union> EX' Z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> lfp (\\<lambda>Z. f \\<union> EX' Z)", "have b: \"lfp (\\<lambda>Z :: ('a :: state) set. f \\<union> EX' Z) =\n                    f \\<union> (EX' (lfp (\\<lambda>Z :: ('a :: state) set. f \\<union> EX' Z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>Z. f \\<union> EX' Z) =\n    f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z))", "using EF_def EF_lem00"], ["proof (prove)\nusing this:\n  EF ?f \\<equiv> lfp (\\<lambda>Z. ?f \\<union> EX' Z)\n  EF ?f = ?f \\<union> EX' (lfp (\\<lambda>Z. ?f \\<union> EX' Z))\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>Z. f \\<union> EX' Z) =\n    f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z))", "by blast"], ["proof (state)\nthis:\n  lfp (\\<lambda>Z. f \\<union> EX' Z) =\n  f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z))\n\ngoal (1 subgoal):\n 1. x \\<in> lfp (\\<lambda>Z. f \\<union> EX' Z)", "thus \"x \\<in> lfp (\\<lambda>Z::'a set. f \\<union> EX' Z)\""], ["proof (prove)\nusing this:\n  lfp (\\<lambda>Z. f \\<union> EX' Z) =\n  f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z))\n\ngoal (1 subgoal):\n 1. x \\<in> lfp (\\<lambda>Z. f \\<union> EX' Z)", "using a"], ["proof (prove)\nusing this:\n  lfp (\\<lambda>Z. f \\<union> EX' Z) =\n  f \\<union> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z))\n  x \\<in> f \\<or> x \\<in> EX' (lfp (\\<lambda>Z. f \\<union> EX' Z))\n\ngoal (1 subgoal):\n 1. x \\<in> lfp (\\<lambda>Z. f \\<union> EX' Z)", "by (subst b, blast)"], ["proof (state)\nthis:\n  x \\<in> lfp (\\<lambda>Z. f \\<union> EX' Z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> lfp (\\<lambda>Z. f \\<union> EX' Z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma EF_lem2b: \n  assumes \"x \\<in> (EX' (EF f))\"\n  shows \"x \\<in> EF f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> EF f", "by (simp add: EF_lem1 assms)"], ["", "lemma EF_lem2a: assumes \"x \\<in> f\" shows \"x \\<in> EF f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> EF f", "by (simp add: EF_lem1 assms)"], ["", "lemma EF_lem2c: assumes \"x \\<notin> f\" shows \"x \\<in> EF (- f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> EF (- f)", "by (simp add: EF_lem1 assms)"], ["", "lemma EF_lem2d: assumes \"x \\<notin> EF f\" shows \"x \\<notin> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> f", "using EF_lem1 assms"], ["proof (prove)\nusing this:\n  ?x \\<in> ?f \\<or> ?x \\<in> EX' (EF ?f) \\<Longrightarrow> ?x \\<in> EF ?f\n  x \\<notin> EF f\n\ngoal (1 subgoal):\n 1. x \\<notin> f", "by auto"], ["", "lemma EF_lem3b: assumes \"x \\<in> EX' (f \\<union> EX' (EF f))\" shows \"x \\<in> (EF f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> EF f", "by (metis EF_lem000 EF_lem2b assms)"], ["", "lemma EX_lem0l: \"x \\<in> (EX' f) \\<Longrightarrow> x \\<in> (EX' (f \\<union> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> EX' f \\<Longrightarrow> x \\<in> EX' (f \\<union> g)", "by (auto simp: EX'_def)"], ["", "lemma EX_lem0r: \"x \\<in> (EX' g) \\<Longrightarrow> x \\<in> (EX' (f \\<union> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> EX' g \\<Longrightarrow> x \\<in> EX' (f \\<union> g)", "by (auto simp: EX'_def)"], ["", "lemma EX_step: assumes \"x  \\<rightarrow>\\<^sub>i y\" and \"y \\<in> f\" shows \"x \\<in> EX' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> EX' f", "using assms"], ["proof (prove)\nusing this:\n  x \\<rightarrow>\\<^sub>i y\n  y \\<in> f\n\ngoal (1 subgoal):\n 1. x \\<in> EX' f", "by (auto simp: EX'_def)"], ["", "lemma EF_E[rule_format]: \"\\<forall> f. x \\<in> (EF f) \\<longrightarrow> x \\<in> (f \\<union> EX' (EF f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f. x \\<in> EF f \\<longrightarrow> x \\<in> f \\<union> EX' (EF f)", "using EF_lem000"], ["proof (prove)\nusing this:\n  EF ?f = ?f \\<union> EX' (EF ?f)\n\ngoal (1 subgoal):\n 1. \\<forall>f. x \\<in> EF f \\<longrightarrow> x \\<in> f \\<union> EX' (EF f)", "by blast"], ["", "lemma EF_step: assumes \"x  \\<rightarrow>\\<^sub>i y\" and \"y \\<in> f\" shows \"x \\<in> EF f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> EF f", "using EF_lem3b EX_step assms"], ["proof (prove)\nusing this:\n  ?x \\<in> EX' (?f \\<union> EX' (EF ?f)) \\<Longrightarrow> ?x \\<in> EF ?f\n  \\<lbrakk>?x \\<rightarrow>\\<^sub>i ?y; ?y \\<in> ?f\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> EX' ?f\n  x \\<rightarrow>\\<^sub>i y\n  y \\<in> f\n\ngoal (1 subgoal):\n 1. x \\<in> EF f", "by blast"], ["", "lemma EF_step_step: assumes \"x  \\<rightarrow>\\<^sub>i y\" and \"y \\<in> EF f\" shows  \"x \\<in> EF f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> EF f", "using EF_lem2b EX_step assms"], ["proof (prove)\nusing this:\n  ?x \\<in> EX' (EF ?f) \\<Longrightarrow> ?x \\<in> EF ?f\n  \\<lbrakk>?x \\<rightarrow>\\<^sub>i ?y; ?y \\<in> ?f\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> EX' ?f\n  x \\<rightarrow>\\<^sub>i y\n  y \\<in> EF f\n\ngoal (1 subgoal):\n 1. x \\<in> EF f", "by blast"], ["", "lemma EF_step_star: \"\\<lbrakk> x  \\<rightarrow>\\<^sub>i* y; y \\<in> f \\<rbrakk> \\<Longrightarrow> x \\<in> EF f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<rightarrow>\\<^sub>i* y; y \\<in> f\\<rbrakk>\n    \\<Longrightarrow> x \\<in> EF f", "proof (simp add: state_transition_refl_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n     y \\<in> f\\<rbrakk>\n    \\<Longrightarrow> x \\<in> EF f", "show \"(x, y) \\<in> {(x::'a, y::'a). x \\<rightarrow>\\<^sub>i y}\\<^sup>* \\<Longrightarrow> y \\<in> f \\<Longrightarrow> x \\<in> EF f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n     y \\<in> f\\<rbrakk>\n    \\<Longrightarrow> x \\<in> EF f", "proof (erule converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> f \\<Longrightarrow> y \\<in> EF f\n 2. \\<And>ya z.\n       \\<lbrakk>y \\<in> f;\n        (ya, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y};\n        (z, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n        z \\<in> EF f\\<rbrakk>\n       \\<Longrightarrow> ya \\<in> EF f", "show \"y \\<in> f \\<Longrightarrow> y \\<in> EF f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> f \\<Longrightarrow> y \\<in> EF f", "by (erule EF_lem2a)"], ["proof (state)\nthis:\n  y \\<in> f \\<Longrightarrow> y \\<in> EF f\n\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>y \\<in> f;\n        (ya, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y};\n        (z, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n        z \\<in> EF f\\<rbrakk>\n       \\<Longrightarrow> ya \\<in> EF f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>y \\<in> f;\n        (ya, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y};\n        (z, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n        z \\<in> EF f\\<rbrakk>\n       \\<Longrightarrow> ya \\<in> EF f", "show \"\\<And>ya z::'a. y \\<in> f \\<Longrightarrow>\n                 (ya, z) \\<in> {(x,y). x \\<rightarrow>\\<^sub>i y} \\<Longrightarrow>\n                 (z, y) \\<in> {(x,y). x \\<rightarrow>\\<^sub>i y}\\<^sup>* \\<Longrightarrow> z \\<in> EF f \\<Longrightarrow> ya \\<in> EF f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>y \\<in> f;\n        (ya, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y};\n        (z, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n        z \\<in> EF f\\<rbrakk>\n       \\<Longrightarrow> ya \\<in> EF f", "by (simp add: EF_step_step)"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<in> f; (?ya, ?z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y};\n   (?z, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n   ?z \\<in> EF f\\<rbrakk>\n  \\<Longrightarrow> ?ya \\<in> EF f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n   y \\<in> f\\<rbrakk>\n  \\<Longrightarrow> x \\<in> EF f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma EF_induct: \"(a::'a::state) \\<in> EF f \\<Longrightarrow>\n    mono (\\<lambda> Z. f \\<union> EX' Z) \\<Longrightarrow>\n    (\\<And>x. x \\<in> ((\\<lambda> Z. f \\<union> EX' Z)(EF f \\<inter> {x::'a::state. P x})) \\<Longrightarrow> P x) \\<Longrightarrow>\n    P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> EF f; mono (\\<lambda>Z. f \\<union> EX' Z);\n     \\<And>x.\n        x \\<in> f \\<union> EX' (EF f \\<inter> {x. P x}) \\<Longrightarrow>\n        P x\\<rbrakk>\n    \\<Longrightarrow> P a", "by (metis (mono_tags, lifting) EF_def def_lfp_induct_set)"], ["", "lemma valEF_E: \"M \\<turnstile> EF f \\<Longrightarrow> x \\<in> init M \\<Longrightarrow> x \\<in> EF f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M \\<turnstile> EF f; x \\<in> init M\\<rbrakk>\n    \\<Longrightarrow> x \\<in> EF f", "by (auto simp: check_def)"], ["", "lemma EF_step_star_rev[rule_format]: \"x \\<in> EF s \\<Longrightarrow>  (\\<exists> y \\<in> s.  x  \\<rightarrow>\\<^sub>i* y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> EF s \\<Longrightarrow>\n    \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "proof (erule EF_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. mono (\\<lambda>Z. s \\<union> EX' Z)\n 2. \\<And>x.\n       x \\<in> s \\<union>\n               EX' (EF s \\<inter>\n                    {x. \\<exists>y\\<in>s.\n                           x \\<rightarrow>\\<^sub>i* y}) \\<Longrightarrow>\n       \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "show \"mono (\\<lambda>Z::'a set. s \\<union> EX' Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>Z. s \\<union> EX' Z)", "by (force simp add: mono_def EX'_def)"], ["proof (state)\nthis:\n  mono (\\<lambda>Z. s \\<union> EX' Z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> s \\<union>\n               EX' (EF s \\<inter>\n                    {x. \\<exists>y\\<in>s.\n                           x \\<rightarrow>\\<^sub>i* y}) \\<Longrightarrow>\n       \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> s \\<union>\n               EX' (EF s \\<inter>\n                    {x. \\<exists>y\\<in>s.\n                           x \\<rightarrow>\\<^sub>i* y}) \\<Longrightarrow>\n       \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "show \"\\<And>x::'a. x \\<in> s \\<union> EX' (EF s \\<inter> {x::'a. \\<exists>y::'a\\<in>s. x \\<rightarrow>\\<^sub>i* y}) \\<Longrightarrow> \\<exists>y::'a\\<in>s. x \\<rightarrow>\\<^sub>i* y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> s \\<union>\n               EX' (EF s \\<inter>\n                    {x. \\<exists>y\\<in>s.\n                           x \\<rightarrow>\\<^sub>i* y}) \\<Longrightarrow>\n       \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "apply (erule UnE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> s \\<Longrightarrow>\n       \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\n 2. \\<And>x.\n       x \\<in> EX' (EF s \\<inter>\n                    {x. \\<exists>y\\<in>s.\n                           x \\<rightarrow>\\<^sub>i* y}) \\<Longrightarrow>\n       \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "using state_transition_refl_def"], ["proof (prove)\nusing this:\n  ?s \\<rightarrow>\\<^sub>i* ?s' \\<equiv>\n  (?s, ?s') \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> s \\<Longrightarrow>\n       \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\n 2. \\<And>x.\n       x \\<in> EX' (EF s \\<inter>\n                    {x. \\<exists>y\\<in>s.\n                           x \\<rightarrow>\\<^sub>i* y}) \\<Longrightarrow>\n       \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> EX' (EF s \\<inter>\n                    {x. \\<exists>y\\<in>s.\n                           x \\<rightarrow>\\<^sub>i* y}) \\<Longrightarrow>\n       \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "by (auto simp add: EX'_def state_transition_refl_def intro: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  ?x \\<in> s \\<union>\n           EX' (EF s \\<inter>\n                {x. \\<exists>y\\<in>s.\n                       x \\<rightarrow>\\<^sub>i* y}) \\<Longrightarrow>\n  \\<exists>y\\<in>s. ?x \\<rightarrow>\\<^sub>i* y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma EF_step_inv: \"(I \\<subseteq> {sa::'s :: state. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> EF s})  \n         \\<Longrightarrow> \\<forall> x \\<in> I. \\<exists> y \\<in> s. x \\<rightarrow>\\<^sub>i* y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> {sa.\n                   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                   sa \\<in> EF s} \\<Longrightarrow>\n    \\<forall>x\\<in>I. \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "using EF_step_star_rev"], ["proof (prove)\nusing this:\n  ?x \\<in> EF ?s \\<Longrightarrow>\n  \\<exists>y\\<in>?s. ?x \\<rightarrow>\\<^sub>i* y\n\ngoal (1 subgoal):\n 1. I \\<subseteq> {sa.\n                   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                   sa \\<in> EF s} \\<Longrightarrow>\n    \\<forall>x\\<in>I. \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "by fastforce"], ["", "subsubsection \\<open>AG lemmas\\<close>"], ["", "lemma AG_in_lem:   \"x \\<in> AG s \\<Longrightarrow> x \\<in> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> AG s \\<Longrightarrow> x \\<in> s", "by (auto simp add: AG_def gfp_def)"], ["", "lemma AG_lem1: \"x \\<in> s \\<and> x \\<in> (AX (AG s)) \\<Longrightarrow> x \\<in> AG s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> s \\<and> x \\<in> AX (AG s) \\<Longrightarrow> x \\<in> AG s", "proof (simp add: AG_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> s \\<and>\n    x \\<in> AX (gfp (\\<lambda>Z. s \\<inter> AX Z)) \\<Longrightarrow>\n    x \\<in> gfp (\\<lambda>Z. s \\<inter> AX Z)", "have \"gfp (\\<lambda>Z::'a set. s \\<inter> AX Z) = s \\<inter> (AX (gfp (\\<lambda>Z::'a set. s \\<inter> AX Z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp (\\<lambda>Z. s \\<inter> AX Z) =\n    s \\<inter> AX (gfp (\\<lambda>Z. s \\<inter> AX Z))", "by (rule def_gfp_unfold) (auto simp: mono_def AX_def)"], ["proof (state)\nthis:\n  gfp (\\<lambda>Z. s \\<inter> AX Z) =\n  s \\<inter> AX (gfp (\\<lambda>Z. s \\<inter> AX Z))\n\ngoal (1 subgoal):\n 1. x \\<in> s \\<and>\n    x \\<in> AX (gfp (\\<lambda>Z. s \\<inter> AX Z)) \\<Longrightarrow>\n    x \\<in> gfp (\\<lambda>Z. s \\<inter> AX Z)", "then"], ["proof (chain)\npicking this:\n  gfp (\\<lambda>Z. s \\<inter> AX Z) =\n  s \\<inter> AX (gfp (\\<lambda>Z. s \\<inter> AX Z))", "show \"x \\<in> s \\<and> x \\<in> AX (gfp (\\<lambda>Z::'a set. s \\<inter> AX Z)) \\<Longrightarrow> x \\<in> gfp (\\<lambda>Z::'a set. s \\<inter> AX Z)\""], ["proof (prove)\nusing this:\n  gfp (\\<lambda>Z. s \\<inter> AX Z) =\n  s \\<inter> AX (gfp (\\<lambda>Z. s \\<inter> AX Z))\n\ngoal (1 subgoal):\n 1. x \\<in> s \\<and>\n    x \\<in> AX (gfp (\\<lambda>Z. s \\<inter> AX Z)) \\<Longrightarrow>\n    x \\<in> gfp (\\<lambda>Z. s \\<inter> AX Z)", "by blast"], ["proof (state)\nthis:\n  x \\<in> s \\<and>\n  x \\<in> AX (gfp (\\<lambda>Z. s \\<inter> AX Z)) \\<Longrightarrow>\n  x \\<in> gfp (\\<lambda>Z. s \\<inter> AX Z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AG_lem2: \"x \\<in> AG s \\<Longrightarrow> x \\<in> (s \\<inter> (AX (AG s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> AG s \\<Longrightarrow> x \\<in> s \\<inter> AX (AG s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> AG s \\<Longrightarrow> x \\<in> s \\<inter> AX (AG s)", "have a: \"AG s = s \\<inter> (AX (AG s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AG s = s \\<inter> AX (AG s)", "unfolding AG_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp (\\<lambda>Z. s \\<inter> AX Z) =\n    s \\<inter> AX (gfp (\\<lambda>Z. s \\<inter> AX Z))", "by (rule def_gfp_unfold) (auto simp: mono_def AX_def)"], ["proof (state)\nthis:\n  AG s = s \\<inter> AX (AG s)\n\ngoal (1 subgoal):\n 1. x \\<in> AG s \\<Longrightarrow> x \\<in> s \\<inter> AX (AG s)", "thus \"x \\<in> AG s \\<Longrightarrow> x \\<in> (s \\<inter> (AX (AG s)))\""], ["proof (prove)\nusing this:\n  AG s = s \\<inter> AX (AG s)\n\ngoal (1 subgoal):\n 1. x \\<in> AG s \\<Longrightarrow> x \\<in> s \\<inter> AX (AG s)", "by (erule subst)"], ["proof (state)\nthis:\n  x \\<in> AG s \\<Longrightarrow> x \\<in> s \\<inter> AX (AG s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AG_lem3: \"AG s = (s \\<inter> (AX (AG s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AG s = s \\<inter> AX (AG s)", "using AG_lem1 AG_lem2"], ["proof (prove)\nusing this:\n  ?x \\<in> ?s \\<and> ?x \\<in> AX (AG ?s) \\<Longrightarrow> ?x \\<in> AG ?s\n  ?x \\<in> AG ?s \\<Longrightarrow> ?x \\<in> ?s \\<inter> AX (AG ?s)\n\ngoal (1 subgoal):\n 1. AG s = s \\<inter> AX (AG s)", "by blast"], ["", "lemma AG_step: \"y \\<rightarrow>\\<^sub>i z \\<Longrightarrow> y \\<in> AG s \\<Longrightarrow> z \\<in> AG s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<rightarrow>\\<^sub>i z; y \\<in> AG s\\<rbrakk>\n    \\<Longrightarrow> z \\<in> AG s", "using AG_lem2 AX_def"], ["proof (prove)\nusing this:\n  ?x \\<in> AG ?s \\<Longrightarrow> ?x \\<in> ?s \\<inter> AX (AG ?s)\n  AX ?f \\<equiv> {s. {f0. s \\<rightarrow>\\<^sub>i f0} \\<subseteq> ?f}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<rightarrow>\\<^sub>i z; y \\<in> AG s\\<rbrakk>\n    \\<Longrightarrow> z \\<in> AG s", "by blast"], ["", "lemma AG_all_s: \" x \\<rightarrow>\\<^sub>i* y \\<Longrightarrow> x \\<in> AG s \\<Longrightarrow> y \\<in> AG s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<rightarrow>\\<^sub>i* y; x \\<in> AG s\\<rbrakk>\n    \\<Longrightarrow> y \\<in> AG s", "proof (simp add: state_transition_refl_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n     x \\<in> AG s\\<rbrakk>\n    \\<Longrightarrow> y \\<in> AG s", "show \"(x, y) \\<in> {(x,y). x \\<rightarrow>\\<^sub>i y}\\<^sup>* \\<Longrightarrow> x \\<in> AG s \\<Longrightarrow> y \\<in> AG s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n     x \\<in> AG s\\<rbrakk>\n    \\<Longrightarrow> y \\<in> AG s", "by (erule rtrancl_induct) (auto simp add: AG_step)"], ["proof (state)\nthis:\n  \\<lbrakk>(x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n   x \\<in> AG s\\<rbrakk>\n  \\<Longrightarrow> y \\<in> AG s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AG_imp_notnotEF: \n\"I \\<noteq> {} \\<Longrightarrow> ((Kripke {s. \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} I  \\<turnstile> AG s)) \\<Longrightarrow> \n (\\<not>(Kripke {s. \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} (I :: ('s :: state)set)  \\<turnstile> EF (- s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {};\n     Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n      I \\<turnstile> AG s\\<rbrakk>\n    \\<Longrightarrow> \\<not> Kripke\n                              {s. \\<exists>i\\<in>I.\n                                     i \\<rightarrow>\\<^sub>i* s}\n                              I \\<turnstile> EF (- s)", "proof (rule notI, simp add: check_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {};\n     I \\<subseteq> {sa.\n                    (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                    sa \\<in> AG s};\n     I \\<subseteq> {sa.\n                    (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                    sa \\<in> EF (- s)}\\<rbrakk>\n    \\<Longrightarrow> False", "assume a0: \"I \\<noteq> {}\" and\n    a1: \"I \\<subseteq> {sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> AG s}\" and\n    a2: \"I \\<subseteq> {sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> EF (- s)}\""], ["proof (state)\nthis:\n  I \\<noteq> {}\n  I \\<subseteq> {sa.\n                 (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                 sa \\<in> AG s}\n  I \\<subseteq> {sa.\n                 (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                 sa \\<in> EF (- s)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {};\n     I \\<subseteq> {sa.\n                    (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                    sa \\<in> AG s};\n     I \\<subseteq> {sa.\n                    (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                    sa \\<in> EF (- s)}\\<rbrakk>\n    \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have a3: \"{sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> AG s} \\<inter>\n                        {sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> EF (- s)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {sa.\n     (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n     sa \\<in> AG s} \\<inter>\n    {sa.\n     (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n     sa \\<in> EF (- s)} =\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {sa.\n     (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n     sa \\<in> AG s} \\<inter>\n    {sa.\n     (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n     sa \\<in> EF (- s)} =\n    {}", "have \"(? x. x \\<in> {sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> AG s} \\<and>\n                           x \\<in> {sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> EF (- s)}) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {sa.\n                (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                sa \\<in> AG s} \\<and>\n       x \\<in> {sa.\n                (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                sa \\<in> EF (- s)} \\<Longrightarrow>\n    False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {sa.\n                (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                sa \\<in> AG s} \\<and>\n       x \\<in> {sa.\n                (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                sa \\<in> EF (- s)} \\<Longrightarrow>\n    False", "assume a4: \"(? x. x \\<in> {sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> AG s} \\<and>\n                           x \\<in> {sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> EF (- s)})\""], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<in> {sa.\n              (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n              sa \\<in> AG s} \\<and>\n     x \\<in> {sa.\n              (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n              sa \\<in> EF (- s)}\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {sa.\n                (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                sa \\<in> AG s} \\<and>\n       x \\<in> {sa.\n                (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                sa \\<in> EF (- s)} \\<Longrightarrow>\n    False", "from a4"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     x \\<in> {sa.\n              (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n              sa \\<in> AG s} \\<and>\n     x \\<in> {sa.\n              (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n              sa \\<in> EF (- s)}", "obtain x where  a5: \"x \\<in> {sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> AG s} \\<and>\n                                   x \\<in> {sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> EF (- s)}\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> {sa.\n              (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n              sa \\<in> AG s} \\<and>\n     x \\<in> {sa.\n              (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n              sa \\<in> EF (- s)}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {sa.\n                 (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                 sa \\<in> AG s} \\<and>\n        x \\<in> {sa.\n                 (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                 sa \\<in> EF (- s)} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (erule exE)"], ["proof (state)\nthis:\n  x \\<in> {sa.\n           (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n           sa \\<in> AG s} \\<and>\n  x \\<in> {sa.\n           (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n           sa \\<in> EF (- s)}\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {sa.\n                (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                sa \\<in> AG s} \\<and>\n       x \\<in> {sa.\n                (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                sa \\<in> EF (- s)} \\<Longrightarrow>\n    False", "thus \"False\""], ["proof (prove)\nusing this:\n  x \\<in> {sa.\n           (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n           sa \\<in> AG s} \\<and>\n  x \\<in> {sa.\n           (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n           sa \\<in> EF (- s)}\n\ngoal (1 subgoal):\n 1. False", "by (metis (mono_tags, lifting) AG_all_s AG_in_lem ComplD EF_step_star_rev a5 mem_Collect_eq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<in> {sa.\n              (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n              sa \\<in> AG s} \\<and>\n     x \\<in> {sa.\n              (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n              sa \\<in> EF (- s)} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. {sa.\n     (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n     sa \\<in> AG s} \\<inter>\n    {sa.\n     (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n     sa \\<in> EF (- s)} =\n    {}", "thus \"{sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> AG s} \\<inter>\n                        {sa::'s. (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> EF (- s)} = {}\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> {sa.\n              (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n              sa \\<in> AG s} \\<and>\n     x \\<in> {sa.\n              (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n              sa \\<in> EF (- s)} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. {sa.\n     (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n     sa \\<in> AG s} \\<inter>\n    {sa.\n     (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n     sa \\<in> EF (- s)} =\n    {}", "by blast"], ["proof (state)\nthis:\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> AG s} \\<inter>\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> EF (- s)} =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> AG s} \\<inter>\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> EF (- s)} =\n  {}\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> AG s} \\<inter>\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> EF (- s)} =\n  {}\n\ngoal (1 subgoal):\n 1. False", "have b: \"? x. x : I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> I", "using a0"], ["proof (prove)\nusing this:\n  I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> I", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> I\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> I\n\ngoal (1 subgoal):\n 1. False", "obtain x where \"x \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> I \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using b"], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> I \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> I\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> AG s} \\<inter>\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> EF (- s)} =\n  {}\n  \\<exists>x. x \\<in> I\n  x \\<in> I", "show \"False\""], ["proof (prove)\nusing this:\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> AG s} \\<inter>\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> EF (- s)} =\n  {}\n  \\<exists>x. x \\<in> I\n  x \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using a0 a1 a2"], ["proof (prove)\nusing this:\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> AG s} \\<inter>\n  {sa.\n   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n   sa \\<in> EF (- s)} =\n  {}\n  \\<exists>x. x \\<in> I\n  x \\<in> I\n  I \\<noteq> {}\n  I \\<subseteq> {sa.\n                 (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                 sa \\<in> AG s}\n  I \\<subseteq> {sa.\n                 (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                 sa \\<in> EF (- s)}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A simplified way of Modelchecking is given by the following lemma.\\<close>"], ["", "lemma check2_def: \"(Kripke S I \\<turnstile> f) = (I \\<subseteq> S \\<inter> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Kripke S I \\<turnstile> f) = (I \\<subseteq> S \\<inter> f)", "by (auto simp add: check_def)"], ["", "end"]]}